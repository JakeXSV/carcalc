(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher')

},{"./lib/Dispatcher":4}],4:[function(require,module,exports){
/*
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * @typechecks
 */

"use strict";

var invariant = require('./invariant');

var _lastID = 1;
var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *    CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *
 *         case 'city-update':
 *           FlightPriceStore.price =
 *             FlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

  function Dispatcher() {
    this.$Dispatcher_callbacks = {};
    this.$Dispatcher_isPending = {};
    this.$Dispatcher_isHandled = {};
    this.$Dispatcher_isDispatching = false;
    this.$Dispatcher_pendingPayload = null;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   *
   * @param {function} callback
   * @return {string}
   */
  Dispatcher.prototype.register=function(callback) {
    var id = _prefix + _lastID++;
    this.$Dispatcher_callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   *
   * @param {string} id
   */
  Dispatcher.prototype.unregister=function(id) {
    invariant(
      this.$Dispatcher_callbacks[id],
      'Dispatcher.unregister(...): `%s` does not map to a registered callback.',
      id
    );
    delete this.$Dispatcher_callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   *
   * @param {array<string>} ids
   */
  Dispatcher.prototype.waitFor=function(ids) {
    invariant(
      this.$Dispatcher_isDispatching,
      'Dispatcher.waitFor(...): Must be invoked while dispatching.'
    );
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this.$Dispatcher_isPending[id]) {
        invariant(
          this.$Dispatcher_isHandled[id],
          'Dispatcher.waitFor(...): Circular dependency detected while ' +
          'waiting for `%s`.',
          id
        );
        continue;
      }
      invariant(
        this.$Dispatcher_callbacks[id],
        'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',
        id
      );
      this.$Dispatcher_invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   *
   * @param {object} payload
   */
  Dispatcher.prototype.dispatch=function(payload) {
    invariant(
      !this.$Dispatcher_isDispatching,
      'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'
    );
    this.$Dispatcher_startDispatching(payload);
    try {
      for (var id in this.$Dispatcher_callbacks) {
        if (this.$Dispatcher_isPending[id]) {
          continue;
        }
        this.$Dispatcher_invokeCallback(id);
      }
    } finally {
      this.$Dispatcher_stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   *
   * @return {boolean}
   */
  Dispatcher.prototype.isDispatching=function() {
    return this.$Dispatcher_isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @param {string} id
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_invokeCallback=function(id) {
    this.$Dispatcher_isPending[id] = true;
    this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);
    this.$Dispatcher_isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @param {object} payload
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_startDispatching=function(payload) {
    for (var id in this.$Dispatcher_callbacks) {
      this.$Dispatcher_isPending[id] = false;
      this.$Dispatcher_isHandled[id] = false;
    }
    this.$Dispatcher_pendingPayload = payload;
    this.$Dispatcher_isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_stopDispatching=function() {
    this.$Dispatcher_pendingPayload = null;
    this.$Dispatcher_isDispatching = false;
  };


module.exports = Dispatcher;

},{"./invariant":5}],5:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

},{}],6:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

"use strict";

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  if (!(obj instanceof Object && !Array.isArray(obj))) {
    throw new Error('keyMirror(...): Argument must be an object.');
  }
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

},{}],7:[function(require,module,exports){
'use strict';
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function ownEnumerableKeys(obj) {
	var keys = Object.getOwnPropertyNames(obj);

	if (Object.getOwnPropertySymbols) {
		keys = keys.concat(Object.getOwnPropertySymbols(obj));
	}

	return keys.filter(function (key) {
		return propIsEnumerable.call(obj, key);
	});
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = ownEnumerableKeys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],8:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react/addons"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react/addons"], factory);
	else if(typeof exports === 'object')
		exports["Highcharts"] = factory(require("react"), require("react/addons"));
	else
		root["Highcharts"] = factory(root["react"], root["react/addons"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {global.HighchartsAdapter = __webpack_require__(5);
	var Highcharts = __webpack_require__(6);
	var React = __webpack_require__(2);
	var update = __webpack_require__(3).addons.update;
	module.exports = React.createClass({
	  displayName: 'Highcharts',

	  renderChart: function () {
	    if (!this.props.config) {
	      throw new Error('Config has to be specified, for the Highchart component');
	    }

	    var config = this.props.config;
	    var node = this.refs.chart.getDOMNode();

	    if (!config.chart) {
	      config = update(config, {chart: {$set: {}}})
	    }

	    config = update(config, {chart: {renderTo: {$set: node}}});

	    new Highcharts.Chart(config);
	  },

	  componentDidMount: function () {
	    this.renderChart();
	  },
	  componentDidUpdate: function () {
	    this.renderChart();
	  },
	  render: function () {
	    return React.createElement("div", {className: "chart", ref: "chart"})
	  }
	});

	module.exports.Highcharts = Highcharts;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */,
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license @product.name@ JS v@product.version@ (@product.date@)
	 *
	 * Standalone Highcharts Framework
	 *
	 * License: MIT License
	 */


	/*global Highcharts */
	var HighchartsAdapter = (function () {

	var UNDEFINED,
		doc = document,
		emptyArray = [],
		timers = [],
		timerId,
		animSetters = {},
		Fx;

	Math.easeInOutSine = function (t, b, c, d) {
		return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	};



	/**
	 * Extend given object with custom events
	 */
	function augment(obj) {
		function removeOneEvent(el, type, fn) {
			el.removeEventListener(type, fn, false);
		}

		function IERemoveOneEvent(el, type, fn) {
			fn = el.HCProxiedMethods[fn.toString()];
			el.detachEvent('on' + type, fn);
		}

		function removeAllEvents(el, type) {
			var events = el.HCEvents,
				remove,
				types,
				len,
				n;

			if (el.removeEventListener) {
				remove = removeOneEvent;
			} else if (el.attachEvent) {
				remove = IERemoveOneEvent;
			} else {
				return; // break on non-DOM events
			}


			if (type) {
				types = {};
				types[type] = true;
			} else {
				types = events;
			}

			for (n in types) {
				if (events[n]) {
					len = events[n].length;
					while (len--) {
						remove(el, n, events[n][len]);
					}
				}
			}
		}

		if (!obj.HCExtended) {
			Highcharts.extend(obj, {
				HCExtended: true,

				HCEvents: {},

				bind: function (name, fn) {
					var el = this,
						events = this.HCEvents,
						wrappedFn;

					// handle DOM events in modern browsers
					if (el.addEventListener) {
						el.addEventListener(name, fn, false);

					// handle old IE implementation
					} else if (el.attachEvent) {
						
						wrappedFn = function (e) {
							e.target = e.srcElement || window; // #2820
							fn.call(el, e);
						};

						if (!el.HCProxiedMethods) {
							el.HCProxiedMethods = {};
						}

						// link wrapped fn with original fn, so we can get this in removeEvent
						el.HCProxiedMethods[fn.toString()] = wrappedFn;

						el.attachEvent('on' + name, wrappedFn);
					}


					if (events[name] === UNDEFINED) {
						events[name] = [];
					}

					events[name].push(fn);
				},

				unbind: function (name, fn) {
					var events,
						index;

					if (name) {
						events = this.HCEvents[name] || [];
						if (fn) {
							index = HighchartsAdapter.inArray(fn, events);
							if (index > -1) {
								events.splice(index, 1);
								this.HCEvents[name] = events;
							}
							if (this.removeEventListener) {
								removeOneEvent(this, name, fn);
							} else if (this.attachEvent) {
								IERemoveOneEvent(this, name, fn);
							}
						} else {
							removeAllEvents(this, name);
							this.HCEvents[name] = [];
						}
					} else {
						removeAllEvents(this);
						this.HCEvents = {};
					}
				},

				trigger: function (name, args) {
					var events = this.HCEvents[name] || [],
						target = this,
						len = events.length,
						i,
						preventDefault,
						fn;

					// Attach a simple preventDefault function to skip default handler if called
					preventDefault = function () {
						args.defaultPrevented = true;
					};
					
					for (i = 0; i < len; i++) {
						fn = events[i];

						// args is never null here
						if (args.stopped) {
							return;
						}

						args.preventDefault = preventDefault;
						args.target = target;

						// If the type is not set, we're running a custom event (#2297). If it is set,
						// we're running a browser event, and setting it will cause en error in
						// IE8 (#2465).
						if (!args.type) {
							args.type = name;
						}
						

						
						// If the event handler return false, prevent the default handler from executing
						if (fn.call(this, args) === false) {
							args.preventDefault();
						}
					}
				}
			});
		}

		return obj;
	}


	return {

		/**
		 * Initialize the adapter. This is run once as Highcharts is first run.
		 */
		init: function (pathAnim) {

			/**
			 * Compatibility section to add support for legacy IE. This can be removed if old IE 
			 * support is not needed.
			 */
			if (!doc.defaultView) {
				this._getStyle = function (el, prop) {
					var val;
					if (el.style[prop]) {
						return el.style[prop];
					} else {
						if (prop === 'opacity') {
							prop = 'filter';
						}
						/*jslint unparam: true*/
						val = el.currentStyle[prop.replace(/\-(\w)/g, function (a, b) { return b.toUpperCase(); })];
						if (prop === 'filter') {
							val = val.replace(
								/alpha\(opacity=([0-9]+)\)/, 
								function (a, b) { 
									return b / 100; 
								}
							);
						}
						/*jslint unparam: false*/
						return val === '' ? 1 : val;
					} 
				};
				this.adapterRun = function (elem, method) {
					var alias = { width: 'clientWidth', height: 'clientHeight' }[method];

					if (alias) {
						elem.style.zoom = 1;
						return elem[alias] - 2 * parseInt(HighchartsAdapter._getStyle(elem, 'padding'), 10);
					}
				};
			}

			if (!Array.prototype.forEach) {
				this.each = function (arr, fn) { // legacy
					var i = 0, 
						len = arr.length;
					for (; i < len; i++) {
						if (fn.call(arr[i], arr[i], i, arr) === false) {
							return i;
						}
					}
				};
			}

			if (!Array.prototype.indexOf) {
				this.inArray = function (item, arr) {
					var len, 
						i = 0;

					if (arr) {
						len = arr.length;
						
						for (; i < len; i++) {
							if (arr[i] === item) {
								return i;
							}
						}
					}

					return -1;
				};
			}

			if (!Array.prototype.filter) {
				this.grep = function (elements, callback) {
					var ret = [],
						i = 0,
						length = elements.length;

					for (; i < length; i++) {
						if (!!callback(elements[i], i)) {
							ret.push(elements[i]);
						}
					}

					return ret;
				};
			}

			//--- End compatibility section ---


			/**
			 * Start of animation specific code
			 */
			Fx = function (elem, options, prop) {
				this.options = options;
				this.elem = elem;
				this.prop = prop;
			};
			Fx.prototype = {
				
				update: function () {
					var styles,
						paths = this.paths,
						elem = this.elem,
						elemelem = elem.element; // if destroyed, it is null

					// Animation setter defined from outside
					if (animSetters[this.prop]) {
						animSetters[this.prop](this);

					// Animating a path definition on SVGElement
					} else if (paths && elemelem) {
						elem.attr('d', pathAnim.step(paths[0], paths[1], this.now, this.toD));

					// Other animations on SVGElement
					} else if (elem.attr) {
						if (elemelem) {
							elem.attr(this.prop, this.now);
						}

					// HTML styles
					} else {
						styles = {};
						styles[this.prop] = this.now + this.unit;
						Highcharts.css(elem, styles);
					}
					
					if (this.options.step) {
						this.options.step.call(this.elem, this.now, this);
					}

				},
				custom: function (from, to, unit) {
					var self = this,
						t = function (gotoEnd) {
							return self.step(gotoEnd);
						},
						i;

					this.startTime = +new Date();
					this.start = from;
					this.end = to;
					this.unit = unit;
					this.now = this.start;
					this.pos = this.state = 0;

					t.elem = this.elem;

					if (t() && timers.push(t) === 1) {
						timerId = setInterval(function () {
							
							for (i = 0; i < timers.length; i++) {
								if (!timers[i]()) {
									timers.splice(i--, 1);
								}
							}

							if (!timers.length) {
								clearInterval(timerId);
							}
						}, 13);
					}
				},
				
				step: function (gotoEnd) {
					var t = +new Date(),
						ret,
						done,
						options = this.options,
						elem = this.elem,
						i;
					
					if (elem.stopAnimation || (elem.attr && !elem.element)) { // #2616, element including flag is destroyed
						ret = false;

					} else if (gotoEnd || t >= options.duration + this.startTime) {
						this.now = this.end;
						this.pos = this.state = 1;
						this.update();

						this.options.curAnim[this.prop] = true;

						done = true;
						for (i in options.curAnim) {
							if (options.curAnim[i] !== true) {
								done = false;
							}
						}

						if (done) {
							if (options.complete) {
								options.complete.call(elem);
							}
						}
						ret = false;

					} else {
						var n = t - this.startTime;
						this.state = n / options.duration;
						this.pos = options.easing(n, 0, 1, options.duration);
						this.now = this.start + ((this.end - this.start) * this.pos);
						this.update();
						ret = true;
					}
					return ret;
				}
			};

			/**
			 * The adapter animate method
			 */
			this.animate = function (el, prop, opt) {
				var start,
					unit = '',
					end,
					fx,
					args,
					name;

				el.stopAnimation = false; // ready for new

				if (typeof opt !== 'object' || opt === null) {
					args = arguments;
					opt = {
						duration: args[2],
						easing: args[3],
						complete: args[4]
					};
				}
				if (typeof opt.duration !== 'number') {
					opt.duration = 400;
				}
				opt.easing = Math[opt.easing] || Math.easeInOutSine;
				opt.curAnim = Highcharts.extend({}, prop);
				
				for (name in prop) {
					fx = new Fx(el, opt, name);
					end = null;
					
					if (name === 'd') {
						fx.paths = pathAnim.init(
							el,
							el.d,
							prop.d
						);
						fx.toD = prop.d;
						start = 0;
						end = 1;
					} else if (el.attr) {
						start = el.attr(name);
					} else {
						start = parseFloat(HighchartsAdapter._getStyle(el, name)) || 0;
						if (name !== 'opacity') {
							unit = 'px';
						}
					}
		
					if (!end) {
						end = prop[name];
					}
					fx.custom(start, end, unit);
				}	
			};
		},

		/**
		 * Internal method to return CSS value for given element and property
		 */
		_getStyle: function (el, prop) {
			return window.getComputedStyle(el, undefined).getPropertyValue(prop);
		},

		/**
		 * Add an animation setter for a specific property
		 */
		addAnimSetter: function (prop, fn) {
			animSetters[prop] = fn;
		},

		/**
		 * Downloads a script and executes a callback when done.
		 * @param {String} scriptLocation
		 * @param {Function} callback
		 */
		getScript: function (scriptLocation, callback) {
			// We cannot assume that Assets class from mootools-more is available so instead insert a script tag to download script.
			var head = doc.getElementsByTagName('head')[0],
				script = doc.createElement('script');

			script.type = 'text/javascript';
			script.src = scriptLocation;
			script.onload = callback;

			head.appendChild(script);
		},

		/**
		 * Return the index of an item in an array, or -1 if not found
		 */
		inArray: function (item, arr) {
			return arr.indexOf ? arr.indexOf(item) : emptyArray.indexOf.call(arr, item);
		},


		/**
		 * A direct link to adapter methods
		 */
		adapterRun: function (elem, method) {
			return parseInt(HighchartsAdapter._getStyle(elem, method), 10);
		},

		/**
		 * Filter an array
		 */
		grep: function (elements, callback) {
			return emptyArray.filter.call(elements, callback);
		},

		/**
		 * Map an array
		 */
		map: function (arr, fn) {
			var results = [], i = 0, len = arr.length;

			for (; i < len; i++) {
				results[i] = fn.call(arr[i], arr[i], i, arr);
			}

			return results;
		},

		/**
		 * Get the element's offset position, corrected by overflow:auto. Loosely based on jQuery's offset method.
		 */
		offset: function (el) {
			var docElem = document.documentElement,
				box = el.getBoundingClientRect();

			return {
				top: box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),
				left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
			};
		},

		/**
		 * Add an event listener
		 */
		addEvent: function (el, type, fn) {
			augment(el).bind(type, fn);
		},

		/**
		 * Remove event added with addEvent
		 */
		removeEvent: function (el, type, fn) {
			augment(el).unbind(type, fn);
		},

		/**
		 * Fire an event on a custom object
		 */
		fireEvent: function (el, type, eventArguments, defaultFunction) {
			var e;

			if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
				e = doc.createEvent('Events');
				e.initEvent(type, true, true);
				e.target = el;

				Highcharts.extend(e, eventArguments);

				if (el.dispatchEvent) {
					el.dispatchEvent(e);
				} else {
					el.fireEvent(type, e);
				}

			} else if (el.HCExtended === true) {
				eventArguments = eventArguments || {};
				el.trigger(type, eventArguments);
			}

			if (eventArguments && eventArguments.defaultPrevented) {
				defaultFunction = null;
			}

			if (defaultFunction) {
				defaultFunction(eventArguments);
			}
		},

		washMouseEvent: function (e) {
			return e;
		},


		/**
		 * Stop running animation
		 */
		stop: function (el) {
			el.stopAnimation = true;
		},

		/**
		 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
		 * @param {Array} arr
		 * @param {Function} fn
		 */
		each: function (arr, fn) { // modern browsers
			return Array.prototype.forEach.call(arr, fn);
		}
	};
	}());


	/*** EXPORTS FROM exports-loader ***/
	module.exports = HighchartsAdapter

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// ==ClosureCompiler==
	// @compilation_level SIMPLE_OPTIMIZATIONS

	/**
	 * @license Highcharts JS v4.1.4-modified ()
	 *
	 * (c) 2009-2014 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	// JSLint options:
	/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */
	/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */
	(function () {
	// encapsulated variables
	var UNDEFINED,
		doc = document,
		win = window,
		math = Math,
		mathRound = math.round,
		mathFloor = math.floor,
		mathCeil = math.ceil,
		mathMax = math.max,
		mathMin = math.min,
		mathAbs = math.abs,
		mathCos = math.cos,
		mathSin = math.sin,
		mathPI = math.PI,
		deg2rad = mathPI * 2 / 360,


		// some variables
		userAgent = navigator.userAgent,
		isOpera = win.opera,
		isIE = /(msie|trident)/i.test(userAgent) && !isOpera,
		docMode8 = doc.documentMode === 8,
		isWebKit = /AppleWebKit/.test(userAgent),
		isFirefox = /Firefox/.test(userAgent),
		isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
		SVG_NS = 'http://www.w3.org/2000/svg',
		hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
		hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
		useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
		Renderer,
		hasTouch,
		symbolSizes = {},
		idCounter = 0,
		garbageBin,
		defaultOptions,
		dateFormat, // function
		globalAnimation,
		pathAnim,
		timeUnits,
		noop = function () { return UNDEFINED; },
		charts = [],
		chartCount = 0,
		PRODUCT = 'Highcharts',
		VERSION = '4.1.4-modified',

		// some constants for frequently used strings
		DIV = 'div',
		ABSOLUTE = 'absolute',
		RELATIVE = 'relative',
		HIDDEN = 'hidden',
		PREFIX = 'highcharts-',
		VISIBLE = 'visible',
		PX = 'px',
		NONE = 'none',
		M = 'M',
		L = 'L',
		numRegex = /^[0-9]+$/,
		NORMAL_STATE = '',
		HOVER_STATE = 'hover',
		SELECT_STATE = 'select',
		marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
		
		// Object for extending Axis
		AxisPlotLineOrBandExtension,

		// constants for attributes
		STROKE_WIDTH = 'stroke-width',

		// time methods, changed based on whether or not UTC is used
		Date,  // Allow using a different Date class
		makeTime,
		timezoneOffset,
		getTimezoneOffset,
		getMinutes,
		getHours,
		getDay,
		getDate,
		getMonth,
		getFullYear,
		setMinutes,
		setHours,
		setDate,
		setMonth,
		setFullYear,


		// lookup over the types and the associated classes
		seriesTypes = {},
		Highcharts;

	// The Highcharts namespace
	Highcharts = win.Highcharts = win.Highcharts ? error(16, true) : {};

	Highcharts.seriesTypes = seriesTypes;

	/**
	 * Extend an object with the members of another
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to add to the first one
	 */
	var extend = Highcharts.extend = function (a, b) {
		var n;
		if (!a) {
			a = {};
		}
		for (n in b) {
			a[n] = b[n];
		}
		return a;
	};
		
	/**
	 * Deep merge two or more objects and return a third object. If the first argument is
	 * true, the contents of the second object is copied into the first object.
	 * Previously this function redirected to jQuery.extend(true), but this had two limitations.
	 * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
	 * it copied properties from extended prototypes. 
	 */
	function merge() {
		var i,
			args = arguments,
			len,
			ret = {},
			doCopy = function (copy, original) {
				var value, key;

				// An object is replacing a primitive
				if (typeof copy !== 'object') {
					copy = {};
				}

				for (key in original) {
					if (original.hasOwnProperty(key)) {
						value = original[key];

						// Copy the contents of objects, but not arrays or DOM nodes
						if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&
								key !== 'renderTo' && typeof value.nodeType !== 'number') {
							copy[key] = doCopy(copy[key] || {}, value);
					
						// Primitives and arrays are copied over directly
						} else {
							copy[key] = original[key];
						}
					}
				}
				return copy;
			};

		// If first argument is true, copy into the existing object. Used in setOptions.
		if (args[0] === true) {
			ret = args[1];
			args = Array.prototype.slice.call(args, 2);
		}

		// For each argument, extend the return
		len = args.length;
		for (i = 0; i < len; i++) {
			ret = doCopy(ret, args[i]);
		}

		return ret;
	}

	/**
	 * Shortcut for parseInt
	 * @param {Object} s
	 * @param {Number} mag Magnitude
	 */
	function pInt(s, mag) {
		return parseInt(s, mag || 10);
	}

	/**
	 * Check for string
	 * @param {Object} s
	 */
	function isString(s) {
		return typeof s === 'string';
	}

	/**
	 * Check for object
	 * @param {Object} obj
	 */
	function isObject(obj) {
		return obj && typeof obj === 'object';
	}

	/**
	 * Check for array
	 * @param {Object} obj
	 */
	function isArray(obj) {
		return Object.prototype.toString.call(obj) === '[object Array]';
	}

	/**
	 * Check for number
	 * @param {Object} n
	 */
	function isNumber(n) {
		return typeof n === 'number';
	}

	function log2lin(num) {
		return math.log(num) / math.LN10;
	}
	function lin2log(num) {
		return math.pow(10, num);
	}

	/**
	 * Remove last occurence of an item from an array
	 * @param {Array} arr
	 * @param {Mixed} item
	 */
	function erase(arr, item) {
		var i = arr.length;
		while (i--) {
			if (arr[i] === item) {
				arr.splice(i, 1);
				break;
			}
		}
		//return arr;
	}

	/**
	 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
	 * @param {Object} obj
	 */
	function defined(obj) {
		return obj !== UNDEFINED && obj !== null;
	}

	/**
	 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
	 * it attempts to set expando properties on the SVG element, which is not allowed.
	 *
	 * @param {Object} elem The DOM element to receive the attribute(s)
	 * @param {String|Object} prop The property or an abject of key-value pairs
	 * @param {String} value The value if a single property is set
	 */
	function attr(elem, prop, value) {
		var key,
			ret;

		// if the prop is a string
		if (isString(prop)) {
			// set the value
			if (defined(value)) {
				elem.setAttribute(prop, value);

			// get the value
			} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
				ret = elem.getAttribute(prop);
			}

		// else if prop is defined, it is a hash of key/value pairs
		} else if (defined(prop) && isObject(prop)) {
			for (key in prop) {
				elem.setAttribute(key, prop[key]);
			}
		}
		return ret;
	}
	/**
	 * Check if an element is an array, and if not, make it into an array. Like
	 * MooTools' $.splat.
	 */
	function splat(obj) {
		return isArray(obj) ? obj : [obj];
	}


	/**
	 * Return the first value that is defined. Like MooTools' $.pick.
	 */
	var pick = Highcharts.pick = function () {
		var args = arguments,
			i,
			arg,
			length = args.length;
		for (i = 0; i < length; i++) {
			arg = args[i];
			if (arg !== UNDEFINED && arg !== null) {
				return arg;
			}
		}
	};

	/**
	 * Set CSS on a given element
	 * @param {Object} el
	 * @param {Object} styles Style object with camel case property names
	 */
	function css(el, styles) {
		if (isIE && !hasSVG) { // #2686
			if (styles && styles.opacity !== UNDEFINED) {
				styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
			}
		}
		extend(el.style, styles);
	}

	/**
	 * Utility function to create element with attributes and styles
	 * @param {Object} tag
	 * @param {Object} attribs
	 * @param {Object} styles
	 * @param {Object} parent
	 * @param {Object} nopad
	 */
	function createElement(tag, attribs, styles, parent, nopad) {
		var el = doc.createElement(tag);
		if (attribs) {
			extend(el, attribs);
		}
		if (nopad) {
			css(el, {padding: 0, border: NONE, margin: 0});
		}
		if (styles) {
			css(el, styles);
		}
		if (parent) {
			parent.appendChild(el);
		}
		return el;
	}

	/**
	 * Extend a prototyped class by new members
	 * @param {Object} parent
	 * @param {Object} members
	 */
	function extendClass(parent, members) {
		var object = function () { return UNDEFINED; };
		object.prototype = new parent();
		extend(object.prototype, members);
		return object;
	}

	/**
	 * Pad a string to a given length by adding 0 to the beginning
	 * @param {Number} number
	 * @param {Number} length
	 */
	function pad(number, length) {
		// Create an array of the remaining length +1 and join it with 0's
		return new Array((length || 2) + 1 - String(number).length).join(0) + number;
	}

	/**
	 * Wrap a method with extended functionality, preserving the original function
	 * @param {Object} obj The context object that the method belongs to 
	 * @param {String} method The name of the method to extend
	 * @param {Function} func A wrapper function callback. This function is called with the same arguments
	 * as the original function, except that the original function is unshifted and passed as the first 
	 * argument. 
	 */
	var wrap = Highcharts.wrap = function (obj, method, func) {
		var proceed = obj[method];
		obj[method] = function () {
			var args = Array.prototype.slice.call(arguments);
			args.unshift(proceed);
			return func.apply(this, args);
		};
	};


	function getTZOffset(timestamp) {
		return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
	}

	/**
	 * Based on http://www.php.net/manual/en/function.strftime.php
	 * @param {String} format
	 * @param {Number} timestamp
	 * @param {Boolean} capitalize
	 */
	dateFormat = function (format, timestamp, capitalize) {
		if (!defined(timestamp) || isNaN(timestamp)) {
			return 'Invalid date';
		}
		format = pick(format, '%Y-%m-%d %H:%M:%S');

		var date = new Date(timestamp - getTZOffset(timestamp)),
			key, // used in for constuct below
			// get the basic time values
			hours = date[getHours](),
			day = date[getDay](),
			dayOfMonth = date[getDate](),
			month = date[getMonth](),
			fullYear = date[getFullYear](),
			lang = defaultOptions.lang,
			langWeekdays = lang.weekdays,

			// List all format keys. Custom formats can be added from the outside. 
			replacements = extend({

				// Day
				'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
				'A': langWeekdays[day], // Long weekday, like 'Monday'
				'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
				'e': dayOfMonth, // Day of the month, 1 through 31
				'w': day,

				// Week (none implemented)
				//'W': weekNumber(),

				// Month
				'b': lang.shortMonths[month], // Short month, like 'Jan'
				'B': lang.months[month], // Long month, like 'January'
				'm': pad(month + 1), // Two digit month number, 01 through 12

				// Year
				'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
				'Y': fullYear, // Four digits year, like 2009

				// Time
				'H': pad(hours), // Two digits hours in 24h format, 00 through 23
				'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
				'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
				'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
				'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
				'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
				'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
				'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
			}, Highcharts.dateFormats);


		// do the replaces
		for (key in replacements) {
			while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
				format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
			}
		}

		// Optionally capitalize the string and return
		return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
	};

	/** 
	 * Format a single variable. Similar to sprintf, without the % prefix.
	 */
	function formatSingle(format, val) {
		var floatRegex = /f$/,
			decRegex = /\.([0-9])/,
			lang = defaultOptions.lang,
			decimals;

		if (floatRegex.test(format)) { // float
			decimals = format.match(decRegex);
			decimals = decimals ? decimals[1] : -1;
			if (val !== null) {
				val = Highcharts.numberFormat(
					val,
					decimals,
					lang.decimalPoint,
					format.indexOf(',') > -1 ? lang.thousandsSep : ''
				);
			}
		} else {
			val = dateFormat(format, val);
		}
		return val;
	}

	/**
	 * Format a string according to a subset of the rules of Python's String.format method.
	 */
	function format(str, ctx) {
		var splitter = '{',
			isInside = false,
			segment,
			valueAndFormat,
			path,
			i,
			len,
			ret = [],
			val,
			index;
		
		while ((index = str.indexOf(splitter)) !== -1) {
			
			segment = str.slice(0, index);
			if (isInside) { // we're on the closing bracket looking back
				
				valueAndFormat = segment.split(':');
				path = valueAndFormat.shift().split('.'); // get first and leave format
				len = path.length;
				val = ctx;

				// Assign deeper paths
				for (i = 0; i < len; i++) {
					val = val[path[i]];
				}

				// Format the replacement
				if (valueAndFormat.length) {
					val = formatSingle(valueAndFormat.join(':'), val);
				}

				// Push the result and advance the cursor
				ret.push(val);
				
			} else {
				ret.push(segment);
				
			}
			str = str.slice(index + 1); // the rest
			isInside = !isInside; // toggle
			splitter = isInside ? '}' : '{'; // now look for next matching bracket
		}
		ret.push(str);
		return ret.join('');
	}

	/**
	 * Get the magnitude of a number
	 */
	function getMagnitude(num) {
		return math.pow(10, mathFloor(math.log(num) / math.LN10));
	}

	/**
	 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
	 * @param {Number} interval
	 * @param {Array} multiples
	 * @param {Number} magnitude
	 * @param {Object} options
	 */
	function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
		var normalized, 
			i,
			retInterval = interval;

		// round to a tenfold of 1, 2, 2.5 or 5
		magnitude = pick(magnitude, 1);
		normalized = interval / magnitude;

		// multiples for a linear scale
		if (!multiples) {
			multiples = [1, 2, 2.5, 5, 10];

			// the allowDecimals option
			if (allowDecimals === false) {
				if (magnitude === 1) {
					multiples = [1, 2, 5, 10];
				} else if (magnitude <= 0.1) {
					multiples = [1 / magnitude];
				}
			}
		}

		// normalize the interval to the nearest multiple
		for (i = 0; i < multiples.length; i++) {
			retInterval = multiples[i];
			if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
				(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
				break;
			}
		}

		// multiply back to the correct magnitude
		retInterval *= magnitude;
		
		return retInterval;
	}


	/**
	 * Utility method that sorts an object array and keeping the order of equal items.
	 * ECMA script standard does not specify the behaviour when items are equal.
	 */
	function stableSort(arr, sortFunction) {
		var length = arr.length,
			sortValue,
			i;

		// Add index to each item
		for (i = 0; i < length; i++) {
			arr[i].ss_i = i; // stable sort index
		}

		arr.sort(function (a, b) {
			sortValue = sortFunction(a, b);
			return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
		});

		// Remove index from items
		for (i = 0; i < length; i++) {
			delete arr[i].ss_i; // stable sort index
		}
	}

	/**
	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	 * method is slightly slower, but safe.
	 */
	function arrayMin(data) {
		var i = data.length,
			min = data[0];

		while (i--) {
			if (data[i] < min) {
				min = data[i];
			}
		}
		return min;
	}

	/**
	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	 * method is slightly slower, but safe.
	 */
	function arrayMax(data) {
		var i = data.length,
			max = data[0];

		while (i--) {
			if (data[i] > max) {
				max = data[i];
			}
		}
		return max;
	}

	/**
	 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
	 * It loops all properties and invokes destroy if there is a destroy method. The property is
	 * then delete'ed.
	 * @param {Object} The object to destroy properties on
	 * @param {Object} Exception, do not destroy this property, only delete it.
	 */
	function destroyObjectProperties(obj, except) {
		var n;
		for (n in obj) {
			// If the object is non-null and destroy is defined
			if (obj[n] && obj[n] !== except && obj[n].destroy) {
				// Invoke the destroy
				obj[n].destroy();
			}

			// Delete the property from the object.
			delete obj[n];
		}
	}


	/**
	 * Discard an element by moving it to the bin and delete
	 * @param {Object} The HTML node to discard
	 */
	function discardElement(element) {
		// create a garbage bin element, not part of the DOM
		if (!garbageBin) {
			garbageBin = createElement(DIV);
		}

		// move the node and empty bin
		if (element) {
			garbageBin.appendChild(element);
		}
		garbageBin.innerHTML = '';
	}

	/**
	 * Provide error messages for debugging, with links to online explanation 
	 */
	function error (code, stop) {
		var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
		if (stop) {
			throw msg;
		}
		// else ...
		if (win.console) {
			console.log(msg);
		}
	}

	/**
	 * Fix JS round off float errors
	 * @param {Number} num
	 */
	function correctFloat(num) {
		return parseFloat(
			num.toPrecision(14)
		);
	}

	/**
	 * Set the global animation to either a given value, or fall back to the
	 * given chart's animation option
	 * @param {Object} animation
	 * @param {Object} chart
	 */
	function setAnimation(animation, chart) {
		globalAnimation = pick(animation, chart.animation);
	}

	/**
	 * The time unit lookup
	 */
	timeUnits = {
		millisecond: 1,
		second: 1000,
		minute: 60000,
		hour: 3600000,
		day: 24 * 3600000,
		week: 7 * 24 * 3600000,
		month: 28 * 24 * 3600000,
		year: 364 * 24 * 3600000
	};


	/**
	 * Format a number and return a string based on input settings
	 * @param {Number} number The input number to format
	 * @param {Number} decimals The amount of decimals
	 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
	 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
	 */
	Highcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {
		var lang = defaultOptions.lang,
			// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
			n = +number || 0,
			c = decimals === -1 ?
				mathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).
				(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
			d = decPoint === undefined ? lang.decimalPoint : decPoint,
			t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
			s = n < 0 ? "-" : "",
			i = String(pInt(n = mathAbs(n).toFixed(c))),
			j = i.length > 3 ? i.length % 3 : 0;

		return (s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
				(c ? d + mathAbs(n - i).toFixed(c).slice(2) : ""));
	};
	/**
	 * Path interpolation algorithm used across adapters
	 */
	pathAnim = {
		/**
		 * Prepare start and end values so that the path can be animated one to one
		 */
		init: function (elem, fromD, toD) {
			fromD = fromD || '';
			var shift = elem.shift,
				bezier = fromD.indexOf('C') > -1,
				numParams = bezier ? 7 : 3,
				endLength,
				slice,
				i,
				start = fromD.split(' '),
				end = [].concat(toD), // copy
				startBaseLine,
				endBaseLine,
				sixify = function (arr) { // in splines make move points have six parameters like bezier curves
					i = arr.length;
					while (i--) {
						if (arr[i] === M) {
							arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
						}
					}
				};

			if (bezier) {
				sixify(start);
				sixify(end);
			}

			// pull out the base lines before padding
			if (elem.isArea) {
				startBaseLine = start.splice(start.length - 6, 6);
				endBaseLine = end.splice(end.length - 6, 6);
			}

			// if shifting points, prepend a dummy point to the end path
			if (shift <= end.length / numParams && start.length === end.length) {
				while (shift--) {
					end = [].concat(end).splice(0, numParams).concat(end);
				}
			}
			elem.shift = 0; // reset for following animations

			// copy and append last point until the length matches the end length
			if (start.length) {
				endLength = end.length;
				while (start.length < endLength) {

					//bezier && sixify(start);
					slice = [].concat(start).splice(start.length - numParams, numParams);
					if (bezier) { // disable first control point
						slice[numParams - 6] = slice[numParams - 2];
						slice[numParams - 5] = slice[numParams - 1];
					}
					start = start.concat(slice);
				}
			}

			if (startBaseLine) { // append the base lines for areas
				start = start.concat(startBaseLine);
				end = end.concat(endBaseLine);
			}
			return [start, end];
		},

		/**
		 * Interpolate each value of the path and return the array
		 */
		step: function (start, end, pos, complete) {
			var ret = [],
				i = start.length,
				startVal;

			if (pos === 1) { // land on the final path without adjustment points appended in the ends
				ret = complete;

			} else if (i === end.length && pos < 1) {
				while (i--) {
					startVal = parseFloat(start[i]);
					ret[i] =
						isNaN(startVal) ? // a letter instruction like M or L
							start[i] :
							pos * (parseFloat(end[i] - startVal)) + startVal;

				}
			} else { // if animation is finished or length not matching, land on right value
				ret = end;
			}
			return ret;
		}
	};

	(function ($) {
		/**
		 * The default HighchartsAdapter for jQuery
		 */
		win.HighchartsAdapter = win.HighchartsAdapter || ($ && {
			
			/**
			 * Initialize the adapter by applying some extensions to jQuery
			 */
			init: function (pathAnim) {
				
				// extend the animate function to allow SVG animations
				var Fx = $.fx;
				
				/*jslint unparam: true*//* allow unused param x in this function */
				$.extend($.easing, {
					easeOutQuad: function (x, t, b, c, d) {
						return -c * (t /= d) * (t - 2) + b;
					}
				});
				/*jslint unparam: false*/
			
				// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
				$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {
					var obj = Fx.step,
						base;
						
					// Handle different parent objects
					if (fn === 'cur') {
						obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype
					
					} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model
						obj = $.Tween.propHooks[fn];
						fn = 'set';
					}
			
					// Overwrite the method
					base = obj[fn];
					if (base) { // step.width and step.height don't exist in jQuery < 1.7
			
						// create the extended function replacement
						obj[fn] = function (fx) {

							var elem;
							
							// Fx.prototype.cur does not use fx argument
							fx = i ? fx : this;

							// Don't run animations on textual properties like align (#1821)
							if (fx.prop === 'align') {
								return;
							}
			
							// shortcut
							elem = fx.elem;
			
							// Fx.prototype.cur returns the current value. The other ones are setters
							// and returning a value has no effect.
							return elem.attr ? // is SVG element wrapper
								elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method
								base.apply(this, arguments); // use jQuery's built-in method
						};
					}
				});

				// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
				wrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {
					return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
				});
				
				// Define the setter function for d (path definitions)
				this.addAnimSetter('d', function (fx) {
					var elem = fx.elem,
						ends;
			
					// Normally start and end should be set in state == 0, but sometimes,
					// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
					// in these cases
					if (!fx.started) {
						ends = pathAnim.init(elem, elem.d, elem.toD);
						fx.start = ends[0];
						fx.end = ends[1];
						fx.started = true;
					}
			
					// Interpolate each value of the path
					elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
				});
				
				/**
				 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
				 * @param {Array} arr
				 * @param {Function} fn
				 */
				this.each = Array.prototype.forEach ?
					function (arr, fn) { // modern browsers
						return Array.prototype.forEach.call(arr, fn);
						
					} : 
					function (arr, fn) { // legacy
						var i, 
							len = arr.length;
						for (i = 0; i < len; i++) {
							if (fn.call(arr[i], arr[i], i, arr) === false) {
								return i;
							}
						}
					};
				
				/**
				 * Register Highcharts as a plugin in the respective framework
				 */
				$.fn.highcharts = function () {
					var constr = 'Chart', // default constructor
						args = arguments,
						options,
						ret,
						chart;

					if (this[0]) {

						if (isString(args[0])) {
							constr = args[0];
							args = Array.prototype.slice.call(args, 1); 
						}
						options = args[0];

						// Create the chart
						if (options !== UNDEFINED) {
							/*jslint unused:false*/
							options.chart = options.chart || {};
							options.chart.renderTo = this[0];
							chart = new Highcharts[constr](options, args[1]);
							ret = this;
							/*jslint unused:true*/
						}

						// When called without parameters or with the return argument, get a predefined chart
						if (options === UNDEFINED) {
							ret = charts[attr(this[0], 'data-highcharts-chart')];
						}
					}
					
					return ret;
				};

			},

			/**
			 * Add an animation setter for a specific property
			 */
			addAnimSetter: function (prop, setter) {
				// jQuery 1.8 style
				if ($.Tween) {
					$.Tween.propHooks[prop] = {
						set: setter
					};
				// pre 1.8
				} else {
					$.fx.step[prop] = setter;
				}
			},
			
			/**
			 * Downloads a script and executes a callback when done.
			 * @param {String} scriptLocation
			 * @param {Function} callback
			 */
			getScript: $.getScript,
			
			/**
			 * Return the index of an item in an array, or -1 if not found
			 */
			inArray: $.inArray,
			
			/**
			 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
			 * @param {Object} elem The HTML element
			 * @param {String} method Which method to run on the wrapped element
			 */
			adapterRun: function (elem, method) {
				return $(elem)[method]();
			},
		
			/**
			 * Filter an array
			 */
			grep: $.grep,
		
			/**
			 * Map an array
			 * @param {Array} arr
			 * @param {Function} fn
			 */
			map: function (arr, fn) {
				//return jQuery.map(arr, fn);
				var results = [],
					i = 0,
					len = arr.length;
				for (; i < len; i++) {
					results[i] = fn.call(arr[i], arr[i], i, arr);
				}
				return results;
		
			},
		
			/**
			 * Get the position of an element relative to the top left of the page
			 */
			offset: function (el) {
				return $(el).offset();
			},
		
			/**
			 * Add an event listener
			 * @param {Object} el A HTML element or custom object
			 * @param {String} event The event type
			 * @param {Function} fn The event handler
			 */
			addEvent: function (el, event, fn) {
				$(el).bind(event, fn);
			},
		
			/**
			 * Remove event added with addEvent
			 * @param {Object} el The object
			 * @param {String} eventType The event type. Leave blank to remove all events.
			 * @param {Function} handler The function to remove
			 */
			removeEvent: function (el, eventType, handler) {
				// workaround for jQuery issue with unbinding custom events:
				// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
				var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
				if (doc[func] && el && !el[func]) {
					el[func] = function () {};
				}
		
				$(el).unbind(eventType, handler);
			},
		
			/**
			 * Fire an event on a custom object
			 * @param {Object} el
			 * @param {String} type
			 * @param {Object} eventArguments
			 * @param {Function} defaultFunction
			 */
			fireEvent: function (el, type, eventArguments, defaultFunction) {
				var event = $.Event(type),
					detachedType = 'detached' + type,
					defaultPrevented;
		
				// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts
				// never uses these properties, Chrome includes them in the default click event and
				// raises the warning when they are copied over in the extend statement below.
				//
				// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
				// testing if they are there (warning in chrome) the only option is to test if running IE.
				if (!isIE && eventArguments) {
					delete eventArguments.layerX;
					delete eventArguments.layerY;
					delete eventArguments.returnValue;
				}
		
				extend(event, eventArguments);
		
				// Prevent jQuery from triggering the object method that is named the
				// same as the event. For example, if the event is 'select', jQuery
				// attempts calling el.select and it goes into a loop.
				if (el[type]) {
					el[detachedType] = el[type];
					el[type] = null;
				}
		
				// Wrap preventDefault and stopPropagation in try/catch blocks in
				// order to prevent JS errors when cancelling events on non-DOM
				// objects. #615.
				/*jslint unparam: true*/
				$.each(['preventDefault', 'stopPropagation'], function (i, fn) {
					var base = event[fn];
					event[fn] = function () {
						try {
							base.call(event);
						} catch (e) {
							if (fn === 'preventDefault') {
								defaultPrevented = true;
							}
						}
					};
				});
				/*jslint unparam: false*/
		
				// trigger it
				$(el).trigger(event);
		
				// attach the method
				if (el[detachedType]) {
					el[type] = el[detachedType];
					el[detachedType] = null;
				}
		
				if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
					defaultFunction(event);
				}
			},
			
			/**
			 * Extension method needed for MooTools
			 */
			washMouseEvent: function (e) {
				var ret = e.originalEvent || e;
				
				// computed by jQuery, needed by IE8
				if (ret.pageX === UNDEFINED) { // #1236
					ret.pageX = e.pageX;
					ret.pageY = e.pageY;
				}
				
				return ret;
			},
		
			/**
			 * Animate a HTML element or SVG element wrapper
			 * @param {Object} el
			 * @param {Object} params
			 * @param {Object} options jQuery-like animation options: duration, easing, callback
			 */
			animate: function (el, params, options) {
				var $el = $(el);
				if (!el.style) {
					el.style = {}; // #1881
				}
				if (params.d) {
					el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
					params.d = 1; // because in jQuery, animating to an array has a different meaning
				}
		
				$el.stop();
				if (params.opacity !== UNDEFINED && el.attr) {
					params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)
				}
				el.hasAnim = 1; // #3342
				$el.animate(params, options);
		
			},
			/**
			 * Stop running animation
			 */
			stop: function (el) {
				if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy
					$(el).stop();
				}
			}
		});
	}(win.jQuery));


	// check for a custom HighchartsAdapter defined prior to this file
	var globalAdapter = win.HighchartsAdapter,
		adapter = globalAdapter || {};
		
	// Initialize the adapter
	if (globalAdapter) {
		globalAdapter.init.call(globalAdapter, pathAnim);
	}


	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
	// and all the utility functions will be null. In that case they are populated by the
	// default adapters below.
	var adapterRun = adapter.adapterRun,
		getScript = adapter.getScript,
		inArray = adapter.inArray,
		each = Highcharts.each = adapter.each,
		grep = adapter.grep,
		offset = adapter.offset,
		map = adapter.map,
		addEvent = adapter.addEvent,
		removeEvent = adapter.removeEvent,
		fireEvent = adapter.fireEvent,
		washMouseEvent = adapter.washMouseEvent,
		animate = adapter.animate,
		stop = adapter.stop;



	/* ****************************************************************************
	 * Handle the options                                                         *
	 *****************************************************************************/
	defaultOptions = {
		colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', 
			    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
		symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
		lang: {
			loading: 'Loading...',
			months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
					'August', 'September', 'October', 'November', 'December'],
			shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
			weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
			decimalPoint: '.',
			numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
			resetZoom: 'Reset zoom',
			resetZoomTitle: 'Reset zoom level 1:1',
			thousandsSep: ' '
		},
		global: {
			useUTC: true,
			//timezoneOffset: 0,
			canvasToolsURL: 'http://code.highcharts.com/4.1.4-modified/modules/canvas-tools.js',
			VMLRadialGradientURL: 'http://code.highcharts.com/4.1.4-modified/gfx/vml-radial-gradient.png'
		},
		chart: {
			//animation: true,
			//alignTicks: false,
			//reflow: true,
			//className: null,
			//events: { load, selection },
			//margin: [null],
			//marginTop: null,
			//marginRight: null,
			//marginBottom: null,
			//marginLeft: null,
			borderColor: '#4572A7',
			//borderWidth: 0,
			borderRadius: 0,
			defaultSeriesType: 'line',
			ignoreHiddenSeries: true,
			//inverted: false,
			//shadow: false,
			spacing: [10, 10, 15, 10],
			//spacingTop: 10,
			//spacingRight: 10,
			//spacingBottom: 15,
			//spacingLeft: 10,
			//style: {
			//	fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
			//	fontSize: '12px'
			//},
			backgroundColor: '#FFFFFF',
			//plotBackgroundColor: null,
			plotBorderColor: '#C0C0C0',
			//plotBorderWidth: 0,
			//plotShadow: false,
			//zoomType: ''
			resetZoomButton: {
				theme: {
					zIndex: 20
				},
				position: {
					align: 'right',
					x: -10,
					//verticalAlign: 'top',
					y: 10
				}
				// relativeTo: 'plot'
			}
		},
		title: {
			text: 'Chart title',
			align: 'center',
			// floating: false,
			margin: 15,
			// x: 0,
			// verticalAlign: 'top',
			// y: null,
			style: {
				color: '#333333',
				fontSize: '18px'
			}

		},
		subtitle: {
			text: '',
			align: 'center',
			// floating: false
			// x: 0,
			// verticalAlign: 'top',
			// y: null,
			style: {
				color: '#555555'
			}
		},

		plotOptions: {
			line: { // base series options
				allowPointSelect: false,
				showCheckbox: false,
				animation: {
					duration: 1000
				},
				//connectNulls: false,
				//cursor: 'default',
				//clip: true,
				//dashStyle: null,
				//enableMouseTracking: true,
				events: {},
				//legendIndex: 0,
				//linecap: 'round',
				lineWidth: 2,
				//shadow: false,
				// stacking: null,
				marker: {
					//enabled: true,
					//symbol: null,
					lineWidth: 0,
					radius: 4,
					lineColor: '#FFFFFF',
					//fillColor: null,
					states: { // states for a single point
						hover: {
							enabled: true,
							lineWidthPlus: 1,
							radiusPlus: 2
						},
						select: {
							fillColor: '#FFFFFF',
							lineColor: '#000000',
							lineWidth: 2
						}
					}
				},
				point: {
					events: {}
				},
				dataLabels: {
					align: 'center',
					// defer: true,
					// enabled: false,
					formatter: function () {
						return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
					},
					style: {
						color: 'contrast',
						fontSize: '11px',
						fontWeight: 'bold',
						textShadow: '0 0 6px contrast, 0 0 3px contrast'
					},
					verticalAlign: 'bottom', // above singular point
					x: 0,
					y: 0,
					// backgroundColor: undefined,
					// borderColor: undefined,
					// borderRadius: undefined,
					// borderWidth: undefined,
					padding: 5
					// shadow: false
				},
				cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
				pointRange: 0,
				//pointStart: 0,
				//pointInterval: 1,
				//showInLegend: null, // auto: true for standalone series, false for linked series
				states: { // states for the entire series
					hover: {
						//enabled: false,
						lineWidthPlus: 1,
						marker: {
							// lineWidth: base + 1,
							// radius: base + 1
						},
						halo: {
							size: 10,
							opacity: 0.25
						}
					},
					select: {
						marker: {}
					}
				},
				stickyTracking: true,
				//tooltip: {
					//pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
					//valueDecimals: null,
					//xDateFormat: '%A, %b %e, %Y',
					//valuePrefix: '',
					//ySuffix: ''				
				//}
				turboThreshold: 1000
				// zIndex: null
			}
		},
		labels: {
			//items: [],
			style: {
				//font: defaultFont,
				position: ABSOLUTE,
				color: '#3E576F'
			}
		},
		legend: {
			enabled: true,
			align: 'center',
			//floating: false,
			layout: 'horizontal',
			labelFormatter: function () {
				return this.name;
			},
			//borderWidth: 0,
			borderColor: '#909090',
			borderRadius: 0,
			navigation: {
				// animation: true,
				activeColor: '#274b6d',
				// arrowSize: 12
				inactiveColor: '#CCC'
				// style: {} // text styles
			},
			// margin: 20,
			// reversed: false,
			shadow: false,
			// backgroundColor: null,
			/*style: {
				padding: '5px'
			},*/
			itemStyle: {			
				color: '#333333',
				fontSize: '12px',
				fontWeight: 'bold'
			},
			itemHoverStyle: {
				//cursor: 'pointer', removed as of #601
				color: '#000'
			},
			itemHiddenStyle: {
				color: '#CCC'
			},
			itemCheckboxStyle: {
				position: ABSOLUTE,
				width: '13px', // for IE precision
				height: '13px'
			},
			// itemWidth: undefined,
			// symbolRadius: 0,
			// symbolWidth: 16,
			symbolPadding: 5,
			verticalAlign: 'bottom',
			// width: undefined,
			x: 0,
			y: 0,
			title: {
				//text: null,
				style: {
					fontWeight: 'bold'
				}
			}			
		},

		loading: {
			// hideDuration: 100,
			labelStyle: {
				fontWeight: 'bold',
				position: RELATIVE,
				top: '45%'
			},
			// showDuration: 0,
			style: {
				position: ABSOLUTE,
				backgroundColor: 'white',
				opacity: 0.5,
				textAlign: 'center'
			}
		},

		tooltip: {
			enabled: true,
			animation: hasSVG,
			//crosshairs: null,
			backgroundColor: 'rgba(249, 249, 249, .85)',
			borderWidth: 1,
			borderRadius: 3,
			dateTimeLabelFormats: { 
				millisecond: '%A, %b %e, %H:%M:%S.%L',
				second: '%A, %b %e, %H:%M:%S',
				minute: '%A, %b %e, %H:%M',
				hour: '%A, %b %e, %H:%M',
				day: '%A, %b %e, %Y',
				week: 'Week from %A, %b %e, %Y',
				month: '%B %Y',
				year: '%Y'
			},
			footerFormat: '',
			//formatter: defaultFormatter,
			headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
			pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
			shadow: true,
			//shape: 'callout',
			//shared: false,
			snap: isTouchDevice ? 25 : 10,
			style: {
				color: '#333333',
				cursor: 'default',
				fontSize: '12px',
				padding: '8px',
				whiteSpace: 'nowrap'
			}
			//xDateFormat: '%A, %b %e, %Y',
			//valueDecimals: null,
			//valuePrefix: '',
			//valueSuffix: ''
		},

		credits: {
			enabled: true,
			text: 'Highcharts.com',
			href: 'http://www.highcharts.com',
			position: {
				align: 'right',
				x: -10,
				verticalAlign: 'bottom',
				y: -5
			},
			style: {
				cursor: 'pointer',
				color: '#909090',
				fontSize: '9px'
			}
		}
	};




	// Series defaults
	var defaultPlotOptions = defaultOptions.plotOptions,
		defaultSeriesOptions = defaultPlotOptions.line;

	// set the default time methods
	setTimeMethods();



	/**
	 * Set the time methods globally based on the useUTC option. Time method can be either
	 * local time or UTC (default).
	 */
	function setTimeMethods() {
		var globalOptions = defaultOptions.global,
			useUTC = globalOptions.useUTC,
			GET = useUTC ? 'getUTC' : 'get',
			SET = useUTC ? 'setUTC' : 'set';


		Date = globalOptions.Date || window.Date;
		timezoneOffset = useUTC && globalOptions.timezoneOffset;
		getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
		makeTime = function (year, month, date, hours, minutes, seconds) {
			var d;
			if (useUTC) {
				d = Date.UTC.apply(0, arguments);
				d += getTZOffset(d);
			} else {
				d = new Date(
					year,
					month,
					pick(date, 1),
					pick(hours, 0),
					pick(minutes, 0),
					pick(seconds, 0)
				).getTime();
			}
			return d;
		};
		getMinutes =  GET + 'Minutes';
		getHours =    GET + 'Hours';
		getDay =      GET + 'Day';
		getDate =     GET + 'Date';
		getMonth =    GET + 'Month';
		getFullYear = GET + 'FullYear';
		setMinutes =  SET + 'Minutes';
		setHours =    SET + 'Hours';
		setDate =     SET + 'Date';
		setMonth =    SET + 'Month';
		setFullYear = SET + 'FullYear';

	}

	/**
	 * Merge the default options with custom options and return the new options structure
	 * @param {Object} options The new custom options
	 */
	function setOptions(options) {
		
		// Copy in the default options
		defaultOptions = merge(true, defaultOptions, options);
		
		// Apply UTC
		setTimeMethods();

		return defaultOptions;
	}

	/**
	 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
	 * wasn't enough because the setOptions method created a new object.
	 */
	function getOptions() {
		return defaultOptions;
	}


	/**
	 * Handle color operations. The object methods are chainable.
	 * @param {String} input The input color in either rbga or hex format
	 */
	var rgbaRegEx = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
		hexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
		rgbRegEx = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;

	var Color = function (input) {
		// declare variables
		var rgba = [], result, stops;

		/**
		 * Parse the input color to rgba array
		 * @param {String} input
		 */
		function init(input) {

			// Gradients
			if (input && input.stops) {
				stops = map(input.stops, function (stop) {
					return Color(stop[1]);
				});

			// Solid colors
			} else {
				// rgba
				result = rgbaRegEx.exec(input);
				if (result) {
					rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
				} else { 
					// hex
					result = hexRegEx.exec(input);
					if (result) {
						rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
					} else {
						// rgb
						result = rgbRegEx.exec(input);
						if (result) {
							rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
						}
					}
				}
			}		

		}
		/**
		 * Return the color a specified format
		 * @param {String} format
		 */
		function get(format) {
			var ret;

			if (stops) {
				ret = merge(input);
				ret.stops = [].concat(ret.stops);
				each(stops, function (stop, i) {
					ret.stops[i] = [ret.stops[i][0], stop.get(format)];
				});

			// it's NaN if gradient colors on a column chart
			} else if (rgba && !isNaN(rgba[0])) {
				if (format === 'rgb') {
					ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
				} else if (format === 'a') {
					ret = rgba[3];
				} else {
					ret = 'rgba(' + rgba.join(',') + ')';
				}
			} else {
				ret = input;
			}
			return ret;
		}

		/**
		 * Brighten the color
		 * @param {Number} alpha
		 */
		function brighten(alpha) {
			if (stops) {
				each(stops, function (stop) {
					stop.brighten(alpha);
				});
			
			} else if (isNumber(alpha) && alpha !== 0) {
				var i;
				for (i = 0; i < 3; i++) {
					rgba[i] += pInt(alpha * 255);

					if (rgba[i] < 0) {
						rgba[i] = 0;
					}
					if (rgba[i] > 255) {
						rgba[i] = 255;
					}
				}
			}
			return this;
		}
		/**
		 * Set the color's opacity to a given alpha value
		 * @param {Number} alpha
		 */
		function setOpacity(alpha) {
			rgba[3] = alpha;
			return this;
		}

		// initialize: parse the input
		init(input);

		// public methods
		return {
			get: get,
			brighten: brighten,
			rgba: rgba,
			setOpacity: setOpacity,
			raw: input
		};
	};


	/**
	 * A wrapper object for SVG elements
	 */
	function SVGElement() {}

	SVGElement.prototype = {
		
		// Default base for animation
		opacity: 1,
		// For labels, these CSS properties are applied to the <text> node directly
		textProps: ['fontSize', 'fontWeight', 'fontFamily', 'color', 
			'lineHeight', 'width', 'textDecoration', 'textShadow'],
		
		/**
		 * Initialize the SVG renderer
		 * @param {Object} renderer
		 * @param {String} nodeName
		 */
		init: function (renderer, nodeName) {
			var wrapper = this;
			wrapper.element = nodeName === 'span' ?
				createElement(nodeName) :
				doc.createElementNS(SVG_NS, nodeName);
			wrapper.renderer = renderer;
		},
		
		/**
		 * Animate a given attribute
		 * @param {Object} params
		 * @param {Number} options The same options as in jQuery animation
		 * @param {Function} complete Function to perform at the end of animation
		 */
		animate: function (params, options, complete) {
			var animOptions = pick(options, globalAnimation, true);
			stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
			if (animOptions) {
				animOptions = merge(animOptions, {}); //#2625
				if (complete) { // allows using a callback with the global animation without overwriting it
					animOptions.complete = complete;
				}
				animate(this, params, animOptions);
			} else {
				this.attr(params);
				if (complete) {
					complete();
				}
			}
			return this;
		},

		/**
		 * Build an SVG gradient out of a common JavaScript configuration object
		 */
		colorGradient: function (color, prop, elem) {
			var renderer = this.renderer,
				colorObject,
				gradName,
				gradAttr,
				gradients,
				gradientObject,
				stops,
				stopColor,
				stopOpacity,
				radialReference,
				n,
				id,
				key = [];

			// Apply linear or radial gradients
			if (color.linearGradient) {
				gradName = 'linearGradient';
			} else if (color.radialGradient) {
				gradName = 'radialGradient';
			}

			if (gradName) {
				gradAttr = color[gradName];
				gradients = renderer.gradients;
				stops = color.stops;
				radialReference = elem.radialReference;

				// Keep < 2.2 kompatibility
				if (isArray(gradAttr)) {
					color[gradName] = gradAttr = {
						x1: gradAttr[0],
						y1: gradAttr[1],
						x2: gradAttr[2],
						y2: gradAttr[3],
						gradientUnits: 'userSpaceOnUse'
					};
				}

				// Correct the radial gradient for the radial reference system
				if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
					gradAttr = merge(gradAttr, {
						cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
						cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
						r: gradAttr.r * radialReference[2],
						gradientUnits: 'userSpaceOnUse'
					});
				}

				// Build the unique key to detect whether we need to create a new element (#1282)
				for (n in gradAttr) {
					if (n !== 'id') {
						key.push(n, gradAttr[n]);
					}
				}
				for (n in stops) {
					key.push(stops[n]);
				}
				key = key.join(',');

				// Check if a gradient object with the same config object is created within this renderer
				if (gradients[key]) {
					id = gradients[key].attr('id');

				} else {

					// Set the id and create the element
					gradAttr.id = id = PREFIX + idCounter++;
					gradients[key] = gradientObject = renderer.createElement(gradName)
						.attr(gradAttr)
						.add(renderer.defs);


					// The gradient needs to keep a list of stops to be able to destroy them
					gradientObject.stops = [];
					each(stops, function (stop) {
						var stopObject;
						if (stop[1].indexOf('rgba') === 0) {
							colorObject = Color(stop[1]);
							stopColor = colorObject.get('rgb');
							stopOpacity = colorObject.get('a');
						} else {
							stopColor = stop[1];
							stopOpacity = 1;
						}
						stopObject = renderer.createElement('stop').attr({
							offset: stop[0],
							'stop-color': stopColor,
							'stop-opacity': stopOpacity
						}).add(gradientObject);

						// Add the stop element to the gradient
						gradientObject.stops.push(stopObject);
					});
				}

				// Set the reference to the gradient object
				elem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');
			} 
		},

		/**
		 * Apply a polyfill to the text-stroke CSS property, by copying the text element
		 * and apply strokes to the copy.
		 *
		 * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color
		 * TODO: 
		 * - update defaults
		 */
		applyTextShadow: function (textShadow) {
			var elem = this.element,
				tspans,
				hasContrast = textShadow.indexOf('contrast') !== -1,
				// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
				// this again with new IE release. In exports, the rendering is passed to PhantomJS. 
				supports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);

			// When the text shadow is set to contrast, use dark stroke for light text and vice versa
			if (hasContrast) {
				textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
			}

			/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
			if (elem.textContent.indexOf('2.') === 0) {
				elem.style['text-shadow'] = 'none';
				supports = false;
			}
			// */

			// No reason to polyfill, we've got native support
			if (supports) {
				if (hasContrast) { // Apply the altered style
					css(elem, {
						textShadow: textShadow
					});
				}
			} else {

				this.fakeTS = true; // Fake text shadow

				// In order to get the right y position of the clones, 
				// copy over the y setter
				this.ySetter = this.xSetter;

				tspans = [].slice.call(elem.getElementsByTagName('tspan'));
				each(textShadow.split(/\s?,\s?/g), function (textShadow) {
					var firstChild = elem.firstChild,
						color,
						strokeWidth;
					
					textShadow = textShadow.split(' ');
					color = textShadow[textShadow.length - 1];

					// Approximately tune the settings to the text-shadow behaviour
					strokeWidth = textShadow[textShadow.length - 2];

					if (strokeWidth) {
						each(tspans, function (tspan, y) {
							var clone;

							// Let the first line start at the correct X position
							if (y === 0) {
								tspan.setAttribute('x', elem.getAttribute('x'));
								y = elem.getAttribute('y');
								tspan.setAttribute('y', y || 0);
								if (y === null) {
									elem.setAttribute('y', 0);
								}
							}

							// Create the clone and apply shadow properties
							clone = tspan.cloneNode(1);
							attr(clone, {
								'class': PREFIX + 'text-shadow',
								'fill': color,
								'stroke': color,
								'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
								'stroke-width': strokeWidth,
								'stroke-linejoin': 'round'
							});
							elem.insertBefore(clone, firstChild);
						});
					}
				});
			}
		},

		/**
		 * Set or get a given attribute
		 * @param {Object|String} hash
		 * @param {Mixed|Undefined} val
		 */
		attr: function (hash, val) {
			var key,
				value,
				element = this.element,
				hasSetSymbolSize,
				ret = this,
				skipAttr;

			// single key-value pair
			if (typeof hash === 'string' && val !== UNDEFINED) {
				key = hash;
				hash = {};
				hash[key] = val;
			}

			// used as a getter: first argument is a string, second is undefined
			if (typeof hash === 'string') {
				ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);
			
			// setter
			} else {

				for (key in hash) {
					value = hash[key];
					skipAttr = false;



					if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
						if (!hasSetSymbolSize) {
							this.symbolAttr(hash);
							hasSetSymbolSize = true;
						}
						skipAttr = true;
					}

					if (this.rotation && (key === 'x' || key === 'y')) {
						this.doTransform = true;
					}
					
					if (!skipAttr) {
						(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);
					}

					// Let the shadow follow the main element
					if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
						this.updateShadows(key, value);
					}
				}

				// Update transform. Do this outside the loop to prevent redundant updating for batch setting
				// of attributes.
				if (this.doTransform) {
					this.updateTransform();
					this.doTransform = false;
				}

			}

			return ret;
		},

		updateShadows: function (key, value) {
			var shadows = this.shadows,
				i = shadows.length;
			while (i--) {
				shadows[i].setAttribute(
					key,
					key === 'height' ?
						mathMax(value - (shadows[i].cutHeight || 0), 0) :
						key === 'd' ? this.d : value
				);
			}
		},

		/**
		 * Add a class name to an element
		 */
		addClass: function (className) {
			var element = this.element,
				currentClassName = attr(element, 'class') || '';

			if (currentClassName.indexOf(className) === -1) {
				attr(element, 'class', currentClassName + ' ' + className);
			}
			return this;
		},
		/* hasClass and removeClass are not (yet) needed
		hasClass: function (className) {
			return attr(this.element, 'class').indexOf(className) !== -1;
		},
		removeClass: function (className) {
			attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
			return this;
		},
		*/

		/**
		 * If one of the symbol size affecting parameters are changed,
		 * check all the others only once for each call to an element's
		 * .attr() method
		 * @param {Object} hash
		 */
		symbolAttr: function (hash) {
			var wrapper = this;

			each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
				wrapper[key] = pick(hash[key], wrapper[key]);
			});

			wrapper.attr({
				d: wrapper.renderer.symbols[wrapper.symbolName](
					wrapper.x,
					wrapper.y,
					wrapper.width,
					wrapper.height,
					wrapper
				)
			});
		},

		/**
		 * Apply a clipping path to this object
		 * @param {String} id
		 */
		clip: function (clipRect) {
			return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
		},

		/**
		 * Calculate the coordinates needed for drawing a rectangle crisply and return the
		 * calculated attributes
		 * @param {Number} strokeWidth
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		crisp: function (rect) {

			var wrapper = this,
				key,
				attribs = {},
				normalizer,
				strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;

			normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

			// normalize for crisp edges
			rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
			rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
			rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
			rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
			rect.strokeWidth = strokeWidth;

			for (key in rect) {
				if (wrapper[key] !== rect[key]) { // only set attribute if changed
					wrapper[key] = attribs[key] = rect[key];
				}
			}

			return attribs;
		},

		/**
		 * Set styles for the element
		 * @param {Object} styles
		 */
		css: function (styles) {
			var elemWrapper = this,
				oldStyles = elemWrapper.styles,
				newStyles = {},
				elem = elemWrapper.element,
				textWidth,
				n,
				serializedCss = '',
				hyphenate,
				hasNew = !oldStyles;

			// convert legacy
			if (styles && styles.color) {
				styles.fill = styles.color;
			}

			// Filter out existing styles to increase performance (#2640)
			if (oldStyles) {
				for (n in styles) {
					if (styles[n] !== oldStyles[n]) {
						newStyles[n] = styles[n];
						hasNew = true;
					}
				}
			}
			if (hasNew) {
				textWidth = elemWrapper.textWidth = 
					(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || 
					elemWrapper.textWidth; // #3501

				// Merge the new styles with the old ones
				if (oldStyles) {
					styles = extend(
						oldStyles,
						newStyles
					);
				}		

				// store object
				elemWrapper.styles = styles;

				if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
					delete styles.width;
				}

				// serialize and set style attribute
				if (isIE && !hasSVG) {
					css(elemWrapper.element, styles);
				} else {
					/*jslint unparam: true*/
					hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
					/*jslint unparam: false*/
					for (n in styles) {
						serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
					}
					attr(elem, 'style', serializedCss); // #1881
				}


				// re-build text
				if (textWidth && elemWrapper.added) {
					elemWrapper.renderer.buildText(elemWrapper);
				}
			}

			return elemWrapper;
		},

		/**
		 * Add an event listener
		 * @param {String} eventType
		 * @param {Function} handler
		 */
		on: function (eventType, handler) {
			var svgElement = this,
				element = svgElement.element;
			
			// touch
			if (hasTouch && eventType === 'click') {
				element.ontouchstart = function (e) {			
					svgElement.touchEventFired = Date.now();				
					e.preventDefault();
					handler.call(element, e);
				};
				element.onclick = function (e) {												
					if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
						handler.call(element, e);
					}
				};			
			} else {
				// simplest possible event model for internal use
				element['on' + eventType] = handler;
			}
			return this;
		},

		/**
		 * Set the coordinates needed to draw a consistent radial gradient across
		 * pie slices regardless of positioning inside the chart. The format is
		 * [centerX, centerY, diameter] in pixels.
		 */
		setRadialReference: function (coordinates) {
			this.element.radialReference = coordinates;
			return this;
		},

		/**
		 * Move an object and its children by x and y values
		 * @param {Number} x
		 * @param {Number} y
		 */
		translate: function (x, y) {
			return this.attr({
				translateX: x,
				translateY: y
			});
		},

		/**
		 * Invert a group, rotate and flip
		 */
		invert: function () {
			var wrapper = this;
			wrapper.inverted = true;
			wrapper.updateTransform();
			return wrapper;
		},

		/**
		 * Private method to update the transform attribute based on internal
		 * properties
		 */
		updateTransform: function () {
			var wrapper = this,
				translateX = wrapper.translateX || 0,
				translateY = wrapper.translateY || 0,
				scaleX = wrapper.scaleX,
				scaleY = wrapper.scaleY,
				inverted = wrapper.inverted,
				rotation = wrapper.rotation,
				element = wrapper.element,
				transform;

			// flipping affects translate as adjustment for flipping around the group's axis
			if (inverted) {
				translateX += wrapper.attr('width');
				translateY += wrapper.attr('height');
			}

			// Apply translate. Nearly all transformed elements have translation, so instead
			// of checking for translate = 0, do it always (#1767, #1846).
			transform = ['translate(' + translateX + ',' + translateY + ')'];

			// apply rotation
			if (inverted) {
				transform.push('rotate(90) scale(-1,1)');
			} else if (rotation) { // text rotation
				transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');
				
				// Delete bBox memo when the rotation changes
				//delete wrapper.bBox;
			}

			// apply scale
			if (defined(scaleX) || defined(scaleY)) {
				transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
			}

			if (transform.length) {
				element.setAttribute('transform', transform.join(' '));
			}
		},
		/**
		 * Bring the element to the front
		 */
		toFront: function () {
			var element = this.element;
			element.parentNode.appendChild(element);
			return this;
		},


		/**
		 * Break down alignment options like align, verticalAlign, x and y
		 * to x and y relative to the chart.
		 *
		 * @param {Object} alignOptions
		 * @param {Boolean} alignByTranslate
		 * @param {String[Object} box The box to align to, needs a width and height. When the
		 *		box is a string, it refers to an object in the Renderer. For example, when
		 *		box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
		 *		x and y properties.
		 *
		 */
		align: function (alignOptions, alignByTranslate, box) {
			var align,
				vAlign,
				x,
				y,
				attribs = {},
				alignTo,
				renderer = this.renderer,
				alignedObjects = renderer.alignedObjects;

			// First call on instanciate
			if (alignOptions) {
				this.alignOptions = alignOptions;
				this.alignByTranslate = alignByTranslate;
				if (!box || isString(box)) { // boxes other than renderer handle this internally
					this.alignTo = alignTo = box || 'renderer';
					erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
					alignedObjects.push(this);
					box = null; // reassign it below
				}

			// When called on resize, no arguments are supplied
			} else {
				alignOptions = this.alignOptions;
				alignByTranslate = this.alignByTranslate;
				alignTo = this.alignTo;
			}

			box = pick(box, renderer[alignTo], renderer);

			// Assign variables
			align = alignOptions.align;
			vAlign = alignOptions.verticalAlign;
			x = (box.x || 0) + (alignOptions.x || 0); // default: left align
			y = (box.y || 0) + (alignOptions.y || 0); // default: top align

			// Align
			if (align === 'right' || align === 'center') {
				x += (box.width - (alignOptions.width || 0)) /
						{ right: 1, center: 2 }[align];
			}
			attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


			// Vertical align
			if (vAlign === 'bottom' || vAlign === 'middle') {
				y += (box.height - (alignOptions.height || 0)) /
						({ bottom: 1, middle: 2 }[vAlign] || 1);

			}
			attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

			// Animate only if already placed
			this[this.placed ? 'animate' : 'attr'](attribs);
			this.placed = true;
			this.alignAttr = attribs;

			return this;
		},

		/**
		 * Get the bounding box (width, height, x and y) for the element
		 */
		getBBox: function (reload) {
			var wrapper = this,
				bBox,// = wrapper.bBox,
				renderer = wrapper.renderer,
				width,
				height,
				rotation = wrapper.rotation,
				element = wrapper.element,
				styles = wrapper.styles,
				rad = rotation * deg2rad,
				textStr = wrapper.textStr,
				textShadow,
				elemStyle = element.style,
				toggleTextShadowShim,
				cacheKey;

			if (textStr !== UNDEFINED) {

				// Properties that affect bounding box
				cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

				// Since numbers are monospaced, and numerical labels appear a lot in a chart,
				// we assume that a label of n characters has the same bounding box as others 
				// of the same length.
				if (textStr === '' || numRegex.test(textStr)) {
					cacheKey = 'num:' + textStr.toString().length + cacheKey;

				// Caching all strings reduces rendering time by 4-5%.
				} else {
					cacheKey = textStr + cacheKey;
				}
			}

			if (cacheKey && !reload) {
				bBox = renderer.cache[cacheKey];
			}

			// No cache found
			if (!bBox) {

				// SVG elements
				if (element.namespaceURI === SVG_NS || renderer.forExport) {
					try { // Fails in Firefox if the container has display: none.

						// When the text shadow shim is used, we need to hide the fake shadows
						// to get the correct bounding box (#3872)
						toggleTextShadowShim = this.fakeTS && function (display) {
							each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
								tspan.style.display = display;
							});
						};

						// Workaround for #3842, Firefox reporting wrong bounding box for shadows
						if (isFirefox && elemStyle.textShadow) {
							textShadow = elemStyle.textShadow;
							elemStyle.textShadow = '';
						} else if (toggleTextShadowShim) {
							toggleTextShadowShim(NONE);
						}

						bBox = element.getBBox ?
							// SVG: use extend because IE9 is not allowed to change width and height in case
							// of rotation (below)
							extend({}, element.getBBox()) :
							// Canvas renderer and legacy IE in export mode
							{
								width: element.offsetWidth,
								height: element.offsetHeight
							};

						// #3842
						if (textShadow) {
							elemStyle.textShadow = textShadow;
						} else if (toggleTextShadowShim) {
							toggleTextShadowShim('');
						}
					} catch (e) {}

					// If the bBox is not set, the try-catch block above failed. The other condition
					// is for Opera that returns a width of -Infinity on hidden elements.
					if (!bBox || bBox.width < 0) {
						bBox = { width: 0, height: 0 };
					}


				// VML Renderer or useHTML within SVG
				} else {

					bBox = wrapper.htmlGetBBox();

				}

				// True SVG elements as well as HTML elements in modern browsers using the .useHTML option
				// need to compensated for rotation
				if (renderer.isSVG) {
					width = bBox.width;
					height = bBox.height;

					// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
					if (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
						bBox.height = height = 14;
					}

					// Adjust for rotated text
					if (rotation) {
						bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
						bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
					}
				}

				// Cache it
				renderer.cache[cacheKey] = bBox;
			}
			return bBox;
		},

		/**
		 * Show the element
		 */
		show: function (inherit) {
			// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881)
			if (inherit && this.element.namespaceURI === SVG_NS) {
				this.element.removeAttribute('visibility');
			} else {
				this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
			}
			return this;
		},

		/**
		 * Hide the element
		 */
		hide: function () {
			return this.attr({ visibility: HIDDEN });
		},

		fadeOut: function (duration) {
			var elemWrapper = this;
			elemWrapper.animate({
				opacity: 0
			}, {
				duration: duration || 150,
				complete: function () {
					elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
				}
			});
		},

		/**
		 * Add the element
		 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
		 *	to append the element to the renderer.box.
		 */
		add: function (parent) {

			var renderer = this.renderer,
				element = this.element,
				inserted;

			if (parent) {
				this.parentGroup = parent;
			}

			// mark as inverted
			this.parentInverted = parent && parent.inverted;

			// build formatted text
			if (this.textStr !== undefined) {
				renderer.buildText(this);
			}

			// Mark as added
			this.added = true;

			// If we're adding to renderer root, or other elements in the group 
			// have a z index, we need to handle it
			if (!parent || parent.handleZ || this.zIndex) {
				inserted = this.zIndexSetter();
			}

			// If zIndex is not handled, append at the end
			if (!inserted) {
				(parent ? parent.element : renderer.box).appendChild(element);
			}

			// fire an event for internal hooks
			if (this.onAdd) {
				this.onAdd();
			}

			return this;
		},

		/**
		 * Removes a child either by removeChild or move to garbageBin.
		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
		 */
		safeRemoveChild: function (element) {
			var parentNode = element.parentNode;
			if (parentNode) {
				parentNode.removeChild(element);
			}
		},

		/**
		 * Destroy the element and element wrapper
		 */
		destroy: function () {
			var wrapper = this,
				element = wrapper.element || {},
				shadows = wrapper.shadows,
				parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
				grandParent,
				key,
				i;

			// remove events
			element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
			stop(wrapper); // stop running animations

			if (wrapper.clipPath) {
				wrapper.clipPath = wrapper.clipPath.destroy();
			}

			// Destroy stops in case this is a gradient object
			if (wrapper.stops) {
				for (i = 0; i < wrapper.stops.length; i++) {
					wrapper.stops[i] = wrapper.stops[i].destroy();
				}
				wrapper.stops = null;
			}

			// remove element
			wrapper.safeRemoveChild(element);

			// destroy shadows
			if (shadows) {
				each(shadows, function (shadow) {
					wrapper.safeRemoveChild(shadow);
				});
			}

			// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
			while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
				grandParent = parentToClean.parentGroup;
				wrapper.safeRemoveChild(parentToClean.div);
				delete parentToClean.div;
				parentToClean = grandParent;
			}

			// remove from alignObjects
			if (wrapper.alignTo) {
				erase(wrapper.renderer.alignedObjects, wrapper);
			}

			for (key in wrapper) {
				delete wrapper[key];
			}

			return null;
		},

		/**
		 * Add a shadow to the element. Must be done after the element is added to the DOM
		 * @param {Boolean|Object} shadowOptions
		 */
		shadow: function (shadowOptions, group, cutOff) {
			var shadows = [],
				i,
				shadow,
				element = this.element,
				strokeWidth,
				shadowWidth,
				shadowElementOpacity,

				// compensate for inverted plot area
				transform;


			if (shadowOptions) {
				shadowWidth = pick(shadowOptions.width, 3);
				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
				transform = this.parentInverted ?
					'(-1,-1)' :
					'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
				for (i = 1; i <= shadowWidth; i++) {
					shadow = element.cloneNode(0);
					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
					attr(shadow, {
						'isShadow': 'true',
						'stroke': shadowOptions.color || 'black',
						'stroke-opacity': shadowElementOpacity * i,
						'stroke-width': strokeWidth,
						'transform': 'translate' + transform,
						'fill': NONE
					});
					if (cutOff) {
						attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
						shadow.cutHeight = strokeWidth;
					}

					if (group) {
						group.element.appendChild(shadow);
					} else {
						element.parentNode.insertBefore(shadow, element);
					}

					shadows.push(shadow);
				}

				this.shadows = shadows;
			}
			return this;

		},

		xGetter: function (key) {
			if (this.element.nodeName === 'circle') {
				key = { x: 'cx', y: 'cy' }[key] || key;
			}
			return this._defaultGetter(key);
		},

		/** 
		 * Get the current value of an attribute or pseudo attribute, used mainly
		 * for animation.
		 */
		_defaultGetter: function (key) {
			var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

			if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
				ret = parseFloat(ret);
			}
			return ret;
		},


		dSetter: function (value, key, element) {
			if (value && value.join) { // join path
				value = value.join(' ');
			}
			if (/(NaN| {2}|^$)/.test(value)) {
				value = 'M 0 0';
			}
			element.setAttribute(key, value);

			this[key] = value;
		},
		dashstyleSetter: function (value) {
			var i;
			value = value && value.toLowerCase();
			if (value) {
				value = value
					.replace('shortdashdotdot', '3,1,1,1,1,1,')
					.replace('shortdashdot', '3,1,1,1')
					.replace('shortdot', '1,1,')
					.replace('shortdash', '3,1,')
					.replace('longdash', '8,3,')
					.replace(/dot/g, '1,3,')
					.replace('dash', '4,3,')
					.replace(/,$/, '')
					.split(','); // ending comma

				i = value.length;
				while (i--) {
					value[i] = pInt(value[i]) * this['stroke-width'];
				}
				value = value.join(',')
					.replace('NaN', 'none'); // #3226
				this.element.setAttribute('stroke-dasharray', value);
			}
		},
		alignSetter: function (value) {
			this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
		},
		opacitySetter: function (value, key, element) {
			this[key] = value;
			element.setAttribute(key, value);
		},
		titleSetter: function (value) {
			var titleNode = this.element.getElementsByTagName('title')[0];
			if (!titleNode) {
				titleNode = doc.createElementNS(SVG_NS, 'title');
				this.element.appendChild(titleNode);
			}
			titleNode.textContent = (String(pick(value), '')).replace(/<[^>]*>/g, ''); // #3276 #3895
		},
		textSetter: function (value) {
			if (value !== this.textStr) {
				// Delete bBox memo when the text changes
				delete this.bBox;
			
				this.textStr = value;
				if (this.added) {
					this.renderer.buildText(this);
				}
			}
		},
		fillSetter: function (value, key, element) {
			if (typeof value === 'string') {
				element.setAttribute(key, value);
			} else if (value) {
				this.colorGradient(value, key, element);
			}
		},
		zIndexSetter: function (value, key) {
			var renderer = this.renderer,
				parentGroup = this.parentGroup,
				parentWrapper = parentGroup || renderer,
				parentNode = parentWrapper.element || renderer.box,
				childNodes,
				otherElement,
				otherZIndex,
				element = this.element,
				inserted,
				run = this.added,
				i;
			
			if (defined(value)) {
				element.setAttribute(key, value); // So we can read it for other elements in the group
				value = +value;
				if (this[key] === value) { // Only update when needed (#3865)
					run = false;
				}
				this[key] = value;
			}

			// Insert according to this and other elements' zIndex. Before .add() is called,
			// nothing is done. Then on add, or by later calls to zIndexSetter, the node
			// is placed on the right place in the DOM.
			if (run) {
				value = this.zIndex;

				if (value && parentGroup) {
					parentGroup.handleZ = true;
				}
			
				childNodes = parentNode.childNodes;
				for (i = 0; i < childNodes.length && !inserted; i++) {
					otherElement = childNodes[i];
					otherZIndex = attr(otherElement, 'zIndex');
					if (otherElement !== element && (
							// Insert before the first element with a higher zIndex
							pInt(otherZIndex) > value ||
							// If no zIndex given, insert before the first element with a zIndex
							(!defined(value) && defined(otherZIndex))

							)) {
						parentNode.insertBefore(element, otherElement);
						inserted = true;
					}
				}
				if (!inserted) {
					parentNode.appendChild(element);
				}
			}
			return inserted;
		},
		_defaultSetter: function (value, key, element) {
			element.setAttribute(key, value);
		}
	};

	// Some shared setters and getters
	SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
	SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = 
			SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = 
			SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
		this[key] = value;
		this.doTransform = true;
	};

	// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
	// stroke attribute altogether. #1270, #1369, #3065, #3072.
	SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
		this[key] = value;
		// Only apply the stroke attribute if the stroke width is defined and larger than 0
		if (this.stroke && this['stroke-width']) {
			this.strokeWidth = this['stroke-width'];
			SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
			element.setAttribute('stroke-width', this['stroke-width']);
			this.hasStroke = true;
		} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
			element.removeAttribute('stroke');
			this.hasStroke = false;
		}
	};


	/**
	 * The default SVG renderer
	 */
	var SVGRenderer = function () {
		this.init.apply(this, arguments);
	};
	SVGRenderer.prototype = {
		Element: SVGElement,

		/**
		 * Initialize the SVGRenderer
		 * @param {Object} container
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Boolean} forExport
		 */
		init: function (container, width, height, style, forExport) {
			var renderer = this,
				loc = location,
				boxWrapper,
				element,
				desc;

			boxWrapper = renderer.createElement('svg')
				.attr({
					version: '1.1'
				})
				.css(this.getStyle(style));
			element = boxWrapper.element;
			container.appendChild(element);

			// For browsers other than IE, add the namespace attribute (#1978)
			if (container.innerHTML.indexOf('xmlns') === -1) {
				attr(element, 'xmlns', SVG_NS);
			}

			// object properties
			renderer.isSVG = true;
			renderer.box = element;
			renderer.boxWrapper = boxWrapper;
			renderer.alignedObjects = [];

			// Page url used for internal references. #24, #672, #1070
			renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
				loc.href
					.replace(/#.*?$/, '') // remove the hash
					.replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
					.replace(/ /g, '%20') : // replace spaces (needed for Safari only)
				'';

			// Add description
			desc = this.createElement('desc').add();
			desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


			renderer.defs = this.createElement('defs').add();
			renderer.forExport = forExport;
			renderer.gradients = {}; // Object where gradient SvgElements are stored
			renderer.cache = {}; // Cache for numerical bounding boxes

			renderer.setSize(width, height, false);



			// Issue 110 workaround:
			// In Firefox, if a div is positioned by percentage, its pixel position may land
			// between pixels. The container itself doesn't display this, but an SVG element
			// inside this container will be drawn at subpixel precision. In order to draw
			// sharp lines, this must be compensated for. This doesn't seem to work inside
			// iframes though (like in jsFiddle).
			var subPixelFix, rect;
			if (isFirefox && container.getBoundingClientRect) {
				renderer.subPixelFix = subPixelFix = function () {
					css(container, { left: 0, top: 0 });
					rect = container.getBoundingClientRect();
					css(container, {
						left: (mathCeil(rect.left) - rect.left) + PX,
						top: (mathCeil(rect.top) - rect.top) + PX
					});
				};

				// run the fix now
				subPixelFix();

				// run it on resize
				addEvent(win, 'resize', subPixelFix);
			}
		},

		getStyle: function (style) {
			return (this.style = extend({
				fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
				fontSize: '12px'
			}, style));
		},

		/**
		 * Detect whether the renderer is hidden. This happens when one of the parent elements
		 * has display: none. #608.
		 */
		isHidden: function () {
			return !this.boxWrapper.getBBox().width;
		},

		/**
		 * Destroys the renderer and its allocated members.
		 */
		destroy: function () {
			var renderer = this,
				rendererDefs = renderer.defs;
			renderer.box = null;
			renderer.boxWrapper = renderer.boxWrapper.destroy();

			// Call destroy on all gradient elements
			destroyObjectProperties(renderer.gradients || {});
			renderer.gradients = null;

			// Defs are null in VMLRenderer
			// Otherwise, destroy them here.
			if (rendererDefs) {
				renderer.defs = rendererDefs.destroy();
			}

			// Remove sub pixel fix handler
			// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
			// See issue #982
			if (renderer.subPixelFix) {
				removeEvent(win, 'resize', renderer.subPixelFix);
			}

			renderer.alignedObjects = null;

			return null;
		},

		/**
		 * Create a wrapper for an SVG element
		 * @param {Object} nodeName
		 */
		createElement: function (nodeName) {
			var wrapper = new this.Element();
			wrapper.init(this, nodeName);
			return wrapper;
		},

		/**
		 * Dummy function for use in canvas renderer
		 */
		draw: function () {},

		/**
		 * Parse a simple HTML string into SVG tspans
		 *
		 * @param {Object} textNode The parent text SVG node
		 */
		buildText: function (wrapper) {
			var textNode = wrapper.element,
				renderer = this,
				forExport = renderer.forExport,
				textStr = pick(wrapper.textStr, '').toString(),
				hasMarkup = textStr.indexOf('<') !== -1,
				lines,
				childNodes = textNode.childNodes,
				styleRegex,
				hrefRegex,
				parentX = attr(textNode, 'x'),
				textStyles = wrapper.styles,
				width = wrapper.textWidth,
				textLineHeight = textStyles && textStyles.lineHeight,
				textShadow = textStyles && textStyles.textShadow,
				ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
				i = childNodes.length,
				tempParent = width && !wrapper.added && this.box,
				getLineHeight = function (tspan) {
					return textLineHeight ? 
						pInt(textLineHeight) :
						renderer.fontMetrics(
							/(px|em)$/.test(tspan && tspan.style.fontSize) ?
								tspan.style.fontSize :
								((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
							tspan
						).h;
				},
				unescapeAngleBrackets = function (inputStr) {
					return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
				};

			/// remove old text
			while (i--) {
				textNode.removeChild(childNodes[i]);
			}

			// Skip tspans, add text directly to text node. The forceTSpan is a hook 
			// used in text outline hack.
			if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {
				textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
				return;

			// Complex strings, add more logic
			} else {

				styleRegex = /<.*style="([^"]+)".*>/;
				hrefRegex = /<.*href="(http[^"]+)".*>/;

				if (tempParent) {
					tempParent.appendChild(textNode); // attach it to the DOM to read offset width
				}

				if (hasMarkup) {
					lines = textStr
						.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
						.replace(/<(i|em)>/g, '<span style="font-style:italic">')
						.replace(/<a/g, '<span')
						.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
						.split(/<br.*?>/g);

				} else {
					lines = [textStr];
				}


				// remove empty line at end
				if (lines[lines.length - 1] === '') {
					lines.pop();
				}

				
				// build the lines
				each(lines, function (line, lineNo) {
					var spans, spanNo = 0;

					line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
					spans = line.split('|||');

					each(spans, function (span) {
						if (span !== '' || spans.length === 1) {
							var attributes = {},
								tspan = doc.createElementNS(SVG_NS, 'tspan'),
								spanStyle; // #390
							if (styleRegex.test(span)) {
								spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
								attr(tspan, 'style', spanStyle);
							}
							if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
								attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
								css(tspan, { cursor: 'pointer' });
							}

							span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

							// Nested tags aren't supported, and cause crash in Safari (#1596)
							if (span !== ' ') {

								// add the text node
								tspan.appendChild(doc.createTextNode(span));

								if (!spanNo) { // first span in a line, align it to the left
									if (lineNo && parentX !== null) {
										attributes.x = parentX;
									}
								} else {
									attributes.dx = 0; // #16
								}

								// add attributes
								attr(tspan, attributes);

								// Append it
								textNode.appendChild(tspan);

								// first span on subsequent line, add the line height
								if (!spanNo && lineNo) {

									// allow getting the right offset height in exporting in IE
									if (!hasSVG && forExport) {
										css(tspan, { display: 'block' });
									}

									// Set the line height based on the font size of either
									// the text element or the tspan element
									attr(
										tspan,
										'dy',
										getLineHeight(tspan)
									);
								}

								/*if (width) {
									renderer.breakText(wrapper, width);
								}*/

								// Check width and apply soft breaks or ellipsis
								if (width) {
									var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
										hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
										tooLong,
										wasTooLong,
										actualWidth,
										rest = [],
										dy = getLineHeight(tspan),
										softLineNo = 1,
										rotation = wrapper.rotation,
										wordStr = span, // for ellipsis
										cursor = wordStr.length, // binary search cursor
										bBox;

									while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
										wrapper.rotation = 0; // discard rotation when computing box
										bBox = wrapper.getBBox(true);
										actualWidth = bBox.width;

										// Old IE cannot measure the actualWidth for SVG elements (#2314)
										if (!hasSVG && renderer.forExport) {
											actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
										}

										tooLong = actualWidth > width;

										// For ellipsis, do a binary search for the correct string length
										if (wasTooLong === undefined) {
											wasTooLong = tooLong; // First time
										}
										if (ellipsis && wasTooLong) {
											cursor /= 2;

											if (wordStr === '' || (!tooLong && cursor < 0.5)) {
												words = []; // All ok, break out
											} else {
												if (tooLong) {
													wasTooLong = true;
												}
												wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
												words = [wordStr + '\u2026'];
												tspan.removeChild(tspan.firstChild);
											}

										// Looping down, this is the first word sequence that is not too long,
										// so we can move on to build the next line.
										} else if (!tooLong || words.length === 1) {
											words = rest;
											rest = [];
													
											if (words.length) {
												softLineNo++;
												
												tspan = doc.createElementNS(SVG_NS, 'tspan');
												attr(tspan, {
													dy: dy,
													x: parentX
												});
												if (spanStyle) { // #390
													attr(tspan, 'style', spanStyle);
												}
												textNode.appendChild(tspan);
											}
											if (actualWidth > width) { // a single word is pressing it out
												width = actualWidth;
											}
										} else { // append to existing line tspan
											tspan.removeChild(tspan.firstChild);
											rest.unshift(words.pop());
										}
										if (words.length) {
											tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
										}
									}
									if (wasTooLong) {
										wrapper.attr('title', wrapper.textStr);
									}
									wrapper.rotation = rotation;
								}

								spanNo++;
							}
						}
					});
				});
				if (tempParent) {
					tempParent.removeChild(textNode); // attach it to the DOM to read offset width
				}

				// Apply the text shadow
				if (textShadow && wrapper.applyTextShadow) {
					wrapper.applyTextShadow(textShadow);
				}
			}
		},

		

		/*
		breakText: function (wrapper, width) {
			var bBox = wrapper.getBBox(),
				node = wrapper.element,
				textLength = node.textContent.length,
				pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
				increment = 0,
				finalPos;

			if (bBox.width > width) {
				while (finalPos === undefined) {
					textLength = node.getSubStringLength(0, pos);

					if (textLength <= width) {
						if (increment === -1) {
							finalPos = pos;
						} else {
							increment = 1;
						}
					} else {
						if (increment === 1) {
							finalPos = pos - 1;
						} else {
							increment = -1;
						}
					}
					pos += increment;
				}
			}
			console.log(finalPos, node.getSubStringLength(0, finalPos))
		},
		*/

		/** 
		 * Returns white for dark colors and black for bright colors
		 */
		getContrast: function (color) {
			color = Color(color).rgba;
			return color[0] + color[1] + color[2] > 384 ? '#000' : '#FFF';
		},

		/**
		 * Create a button with preset states
		 * @param {String} text
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Function} callback
		 * @param {Object} normalState
		 * @param {Object} hoverState
		 * @param {Object} pressedState
		 */
		button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
			var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
				curState = 0,
				stateOptions,
				stateStyle,
				normalStyle,
				hoverStyle,
				pressedStyle,
				disabledStyle,
				verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

			// Normal state - prepare the attributes
			normalState = merge({
				'stroke-width': 1,
				stroke: '#CCCCCC',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#FEFEFE'],
						[1, '#F6F6F6']
					]
				},
				r: 2,
				padding: 5,
				style: {
					color: 'black'
				}
			}, normalState);
			normalStyle = normalState.style;
			delete normalState.style;

			// Hover state
			hoverState = merge(normalState, {
				stroke: '#68A',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#FFF'],
						[1, '#ACF']
					]
				}
			}, hoverState);
			hoverStyle = hoverState.style;
			delete hoverState.style;

			// Pressed state
			pressedState = merge(normalState, {
				stroke: '#68A',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#9BD'],
						[1, '#CDF']
					]
				}
			}, pressedState);
			pressedStyle = pressedState.style;
			delete pressedState.style;

			// Disabled state
			disabledState = merge(normalState, {
				style: {
					color: '#CCC'
				}
			}, disabledState);
			disabledStyle = disabledState.style;
			delete disabledState.style;

			// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
			addEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {
				if (curState !== 3) {
					label.attr(hoverState)
						.css(hoverStyle);
				}
			});
			addEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {
				if (curState !== 3) {
					stateOptions = [normalState, hoverState, pressedState][curState];
					stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
					label.attr(stateOptions)
						.css(stateStyle);
				}
			});

			label.setState = function (state) {
				label.state = curState = state;
				if (!state) {
					label.attr(normalState)
						.css(normalStyle);
				} else if (state === 2) {
					label.attr(pressedState)
						.css(pressedStyle);
				} else if (state === 3) {
					label.attr(disabledState)
						.css(disabledStyle);
				}
			};

			return label
				.on('click', function () {
					if (curState !== 3) {
						callback.call(label);
					}
				})
				.attr(normalState)
				.css(extend({ cursor: 'default' }, normalStyle));
		},

		/**
		 * Make a straight line crisper by not spilling out to neighbour pixels
		 * @param {Array} points
		 * @param {Number} width
		 */
		crispLine: function (points, width) {
			// points format: [M, 0, 0, L, 100, 0]
			// normalize to a crisp line
			if (points[1] === points[4]) {
				// Substract due to #1129. Now bottom and left axis gridlines behave the same.
				points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
			}
			if (points[2] === points[5]) {
				points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
			}
			return points;
		},


		/**
		 * Draw a path
		 * @param {Array} path An SVG path in array form
		 */
		path: function (path) {
			var attr = {
				fill: NONE
			};
			if (isArray(path)) {
				attr.d = path;
			} else if (isObject(path)) { // attributes
				extend(attr, path);
			}
			return this.createElement('path').attr(attr);
		},

		/**
		 * Draw and return an SVG circle
		 * @param {Number} x The x position
		 * @param {Number} y The y position
		 * @param {Number} r The radius
		 */
		circle: function (x, y, r) {
			var attr = isObject(x) ?
				x :
				{
					x: x,
					y: y,
					r: r
				},
				wrapper = this.createElement('circle');

			wrapper.xSetter = function (value) {
				this.element.setAttribute('cx', value);
			};
			wrapper.ySetter = function (value) {
				this.element.setAttribute('cy', value);
			};
			return wrapper.attr(attr);
		},

		/**
		 * Draw and return an arc
		 * @param {Number} x X position
		 * @param {Number} y Y position
		 * @param {Number} r Radius
		 * @param {Number} innerR Inner radius like used in donut charts
		 * @param {Number} start Starting angle
		 * @param {Number} end Ending angle
		 */
		arc: function (x, y, r, innerR, start, end) {
			var arc;

			if (isObject(x)) {
				y = x.y;
				r = x.r;
				innerR = x.innerR;
				start = x.start;
				end = x.end;
				x = x.x;
			}

			// Arcs are defined as symbols for the ability to set
			// attributes in attr and animate
			arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
				innerR: innerR || 0,
				start: start || 0,
				end: end || 0
			});
			arc.r = r; // #959
			return arc;
		},

		/**
		 * Draw and return a rectangle
		 * @param {Number} x Left position
		 * @param {Number} y Top position
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Number} r Border corner radius
		 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
		 */
		rect: function (x, y, width, height, r, strokeWidth) {

			r = isObject(x) ? x.r : r;

			var wrapper = this.createElement('rect'),
				attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
					x: x,
					y: y,
					width: mathMax(width, 0),
					height: mathMax(height, 0)
				};

			if (strokeWidth !== UNDEFINED) {
				attribs.strokeWidth = strokeWidth;
				attribs = wrapper.crisp(attribs);
			}

			if (r) {
				attribs.r = r;
			}

			wrapper.rSetter = function (value) {
				attr(this.element, {
					rx: value,
					ry: value
				});
			};
			
			return wrapper.attr(attribs);
		},

		/**
		 * Resize the box and re-align all aligned elements
		 * @param {Object} width
		 * @param {Object} height
		 * @param {Boolean} animate
		 *
		 */
		setSize: function (width, height, animate) {
			var renderer = this,
				alignedObjects = renderer.alignedObjects,
				i = alignedObjects.length;

			renderer.width = width;
			renderer.height = height;

			renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
				width: width,
				height: height
			});

			while (i--) {
				alignedObjects[i].align();
			}
		},

		/**
		 * Create a group
		 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
		 *	 This can be used for styling and scripting.
		 */
		g: function (name) {
			var elem = this.createElement('g');
			return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
		},

		/**
		 * Display an image
		 * @param {String} src
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		image: function (src, x, y, width, height) {
			var attribs = {
					preserveAspectRatio: NONE
				},
				elemWrapper;

			// optional properties
			if (arguments.length > 1) {
				extend(attribs, {
					x: x,
					y: y,
					width: width,
					height: height
				});
			}

			elemWrapper = this.createElement('image').attr(attribs);

			// set the href in the xlink namespace
			if (elemWrapper.element.setAttributeNS) {
				elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
					'href', src);
			} else {
				// could be exporting in IE
				// using href throws "not supported" in ie7 and under, requries regex shim to fix later
				elemWrapper.element.setAttribute('hc-svg-href', src);
			}
			return elemWrapper;
		},

		/**
		 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
		 *
		 * @param {Object} symbol
		 * @param {Object} x
		 * @param {Object} y
		 * @param {Object} radius
		 * @param {Object} options
		 */
		symbol: function (symbol, x, y, width, height, options) {

			var obj,

				// get the symbol definition function
				symbolFn = this.symbols[symbol],

				// check if there's a path defined for this symbol
				path = symbolFn && symbolFn(
					mathRound(x),
					mathRound(y),
					width,
					height,
					options
				),

				imageElement,
				imageRegex = /^url\((.*?)\)$/,
				imageSrc,
				imageSize,
				centerImage;

			if (path) {

				obj = this.path(path);
				// expando properties for use in animate and attr
				extend(obj, {
					symbolName: symbol,
					x: x,
					y: y,
					width: width,
					height: height
				});
				if (options) {
					extend(obj, options);
				}


			// image symbols
			} else if (imageRegex.test(symbol)) {

				// On image load, set the size and position
				centerImage = function (img, size) {
					if (img.element) { // it may be destroyed in the meantime (#1390)
						img.attr({
							width: size[0],
							height: size[1]
						});

						if (!img.alignByTranslate) { // #185
							img.translate(
								mathRound((width - size[0]) / 2), // #1378
								mathRound((height - size[1]) / 2)
							);
						}
					}
				};

				imageSrc = symbol.match(imageRegex)[1];
				imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

				// Ireate the image synchronously, add attribs async
				obj = this.image(imageSrc)
					.attr({
						x: x,
						y: y
					});
				obj.isImg = true;

				if (imageSize) {
					centerImage(obj, imageSize);
				} else {
					// Initialize image to be 0 size so export will still function if there's no cached sizes.
					obj.attr({ width: 0, height: 0 });

					// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
					// the created element must be assigned to a variable in order to load (#292).
					imageElement = createElement('img', {
						onload: function () {
							centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);
						},
						src: imageSrc
					});
				}
			}

			return obj;
		},

		/**
		 * An extendable collection of functions for defining symbol paths.
		 */
		symbols: {
			'circle': function (x, y, w, h) {
				var cpw = 0.166 * w;
				return [
					M, x + w / 2, y,
					'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
					'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
					'Z'
				];
			},

			'square': function (x, y, w, h) {
				return [
					M, x, y,
					L, x + w, y,
					x + w, y + h,
					x, y + h,
					'Z'
				];
			},

			'triangle': function (x, y, w, h) {
				return [
					M, x + w / 2, y,
					L, x + w, y + h,
					x, y + h,
					'Z'
				];
			},

			'triangle-down': function (x, y, w, h) {
				return [
					M, x, y,
					L, x + w, y,
					x + w / 2, y + h,
					'Z'
				];
			},
			'diamond': function (x, y, w, h) {
				return [
					M, x + w / 2, y,
					L, x + w, y + h / 2,
					x + w / 2, y + h,
					x, y + h / 2,
					'Z'
				];
			},
			'arc': function (x, y, w, h, options) {
				var start = options.start,
					radius = options.r || w || h,
					end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
					innerRadius = options.innerR,
					open = options.open,
					cosStart = mathCos(start),
					sinStart = mathSin(start),
					cosEnd = mathCos(end),
					sinEnd = mathSin(end),
					longArc = options.end - start < mathPI ? 0 : 1;

				return [
					M,
					x + radius * cosStart,
					y + radius * sinStart,
					'A', // arcTo
					radius, // x radius
					radius, // y radius
					0, // slanting
					longArc, // long or short arc
					1, // clockwise
					x + radius * cosEnd,
					y + radius * sinEnd,
					open ? M : L,
					x + innerRadius * cosEnd,
					y + innerRadius * sinEnd,
					'A', // arcTo
					innerRadius, // x radius
					innerRadius, // y radius
					0, // slanting
					longArc, // long or short arc
					0, // clockwise
					x + innerRadius * cosStart,
					y + innerRadius * sinStart,

					open ? '' : 'Z' // close
				];
			},

			/**
			 * Callout shape used for default tooltips, also used for rounded rectangles in VML
			 */
			callout: function (x, y, w, h, options) {
				var arrowLength = 6,
					halfDistance = 6,
					r = mathMin((options && options.r) || 0, w, h),
					safeDistance = r + halfDistance,
					anchorX = options && options.anchorX,
					anchorY = options && options.anchorY,
					path,
					normalizer = mathRound(options.strokeWidth || 0) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors;

				x += normalizer;
				y += normalizer;
				path = [
					'M', x + r, y, 
					'L', x + w - r, y, // top side
					'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
					'L', x + w, y + h - r, // right side
					'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
					'L', x + r, y + h, // bottom side
					'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
					'L', x, y + r, // left side
					'C', x, y, x, y, x + r, y // top-right corner
				];
				
				if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
					path.splice(13, 3,
						'L', x + w, anchorY - halfDistance, 
						x + w + arrowLength, anchorY,
						x + w, anchorY + halfDistance,
						x + w, y + h - r
					);
				} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
					path.splice(33, 3, 
						'L', x, anchorY + halfDistance, 
						x - arrowLength, anchorY,
						x, anchorY - halfDistance,
						x, y + r
					);
				} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
					path.splice(23, 3,
						'L', anchorX + halfDistance, y + h,
						anchorX, y + h + arrowLength,
						anchorX - halfDistance, y + h,
						x + r, y + h
					);
				} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
					path.splice(3, 3,
						'L', anchorX - halfDistance, y,
						anchorX, y - arrowLength,
						anchorX + halfDistance, y,
						w - r, y
					);
				}
				return path;
			}
		},

		/**
		 * Define a clipping rectangle
		 * @param {String} id
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		clipRect: function (x, y, width, height) {
			var wrapper,
				id = PREFIX + idCounter++,

				clipPath = this.createElement('clipPath').attr({
					id: id
				}).add(this.defs);

			wrapper = this.rect(x, y, width, height, 0).add(clipPath);
			wrapper.id = id;
			wrapper.clipPath = clipPath;
			wrapper.count = 0;

			return wrapper;
		},


		


		/**
		 * Add text to the SVG object
		 * @param {String} str
		 * @param {Number} x Left position
		 * @param {Number} y Top position
		 * @param {Boolean} useHTML Use HTML to render the text
		 */
		text: function (str, x, y, useHTML) {

			// declare variables
			var renderer = this,
				fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
				wrapper,
				attr = {};

			if (useHTML && !renderer.forExport) {
				return renderer.html(str, x, y);
			}

			attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
			if (y) {
				attr.y = Math.round(y);
			}
			if (str || str === 0) {
				attr.text = str;
			}

			wrapper = renderer.createElement('text')
				.attr(attr);

			// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
			if (fakeSVG) {
				wrapper.css({
					position: ABSOLUTE
				});
			}

			if (!useHTML) {
				wrapper.xSetter = function (value, key, element) {
					var tspans = element.getElementsByTagName('tspan'),
						tspan,
						parentVal = element.getAttribute(key),
						i;
					for (i = 0; i < tspans.length; i++) {
						tspan = tspans[i];
						// If the x values are equal, the tspan represents a linebreak
						if (tspan.getAttribute(key) === parentVal) {
							tspan.setAttribute(key, value);
						}
					}
					element.setAttribute(key, value);
				};
			}
			
			return wrapper;
		},

		/**
		 * Utility to return the baseline offset and total line height from the font size
		 */
		fontMetrics: function (fontSize, elem) {
			fontSize = fontSize || this.style.fontSize;
			if (elem && win.getComputedStyle) {
				elem = elem.element || elem; // SVGElement
				fontSize = win.getComputedStyle(elem, "").fontSize;
			}
			fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

			// Empirical values found by comparing font size and bounding box height.
			// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
			var lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2),
				baseline = mathRound(lineHeight * 0.8);

			return {
				h: lineHeight,
				b: baseline,
				f: fontSize
			};
		},

		/**
		 * Correct X and Y positioning of a label for rotation (#1764)
		 */
		rotCorr: function (baseline, rotation, alterY) {
			var y = baseline;
			if (rotation && alterY) {
				y = mathMax(y * mathCos(rotation * deg2rad), 4);
			}
			return {
				x: (-baseline / 3) * mathSin(rotation * deg2rad),
				y: y
			};
		},

		/**
		 * Add a label, a text item that can hold a colored or gradient background
		 * as well as a border and shadow.
		 * @param {string} str
		 * @param {Number} x
		 * @param {Number} y
		 * @param {String} shape
		 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
		 *	coordinates it should be pinned to
		 * @param {Number} anchorY
		 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
		 *	like renderer.text, or to the upper border of the rectangle.
		 * @param {String} className Class name for the group
		 */
		label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

			var renderer = this,
				wrapper = renderer.g(className),
				text = renderer.text('', 0, 0, useHTML)
					.attr({
						zIndex: 1
					}),
					//.add(wrapper),
				box,
				bBox,
				alignFactor = 0,
				padding = 3,
				paddingLeft = 0,
				width,
				height,
				wrapperX,
				wrapperY,
				crispAdjust = 0,
				deferredAttr = {},
				baselineOffset,
				needsBox;

			/**
			 * This function runs after the label is added to the DOM (when the bounding box is
			 * available), and after the text of the label is updated to detect the new bounding
			 * box and reflect it in the border box.
			 */
			function updateBoxSize() {
				var boxX,
					boxY,
					style = text.element.style;

				bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && 
					text.getBBox(); //#3295 && 3514 box failure when string equals 0
				wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
				wrapper.height = (height || bBox.height || 0) + 2 * padding;

				// update the label-scoped y offset
				baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;

				
				if (needsBox) {

					// create the border box if it is not already present
					if (!box) {
						boxX = mathRound(-alignFactor * padding);
						boxY = baseline ? -baselineOffset : 0;

						wrapper.box = box = shape ?
							renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
							renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
						box.attr('fill', NONE).add(wrapper);
					}

					// apply the box attributes
					if (!box.isImg) { // #1630
						box.attr(extend({
							width: mathRound(wrapper.width),
							height: mathRound(wrapper.height)
						}, deferredAttr));
					}
					deferredAttr = null;
				}
			}

			/**
			 * This function runs after setting text or padding, but only if padding is changed
			 */
			function updateTextPadding() {
				var styles = wrapper.styles,
					textAlign = styles && styles.textAlign,
					x = paddingLeft + padding * (1 - alignFactor),
					y;

				// determin y based on the baseline
				y = baseline ? 0 : baselineOffset;

				// compensate for alignment
				if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
					x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
				}

				// update if anything changed
				if (x !== text.x || y !== text.y) {
					text.attr('x', x);
					if (y !== UNDEFINED) {
						// As a workaround for #3649, use translation instead of y attribute. #3649
						// is a rendering bug in WebKit for Retina (Mac, iOS, PhantomJS) that 
						// results in duplicated text when an y attribute is used in combination 
						// with a CSS text-style.
						text.attr(text.element.nodeName === 'SPAN' ? 'y' : 'translateY', y);
					}
				}

				// record current values
				text.x = x;
				text.y = y;
			}

			/**
			 * Set a box attribute, or defer it if the box is not yet created
			 * @param {Object} key
			 * @param {Object} value
			 */
			function boxAttr(key, value) {
				if (box) {
					box.attr(key, value);
				} else {
					deferredAttr[key] = value;
				}
			}

			/**
			 * After the text element is added, get the desired size of the border box
			 * and add it before the text in the DOM.
			 */
			wrapper.onAdd = function () {
				text.add(wrapper);
				wrapper.attr({
					text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
					x: x,
					y: y
				});

				if (box && defined(anchorX)) {
					wrapper.attr({
						anchorX: anchorX,
						anchorY: anchorY
					});
				}
			};

			/*
			 * Add specific attribute setters.
			 */

			// only change local variables
			wrapper.widthSetter = function (value) {
				width = value;
			};
			wrapper.heightSetter = function (value) {
				height = value;
			};
			wrapper.paddingSetter =  function (value) {
				if (defined(value) && value !== padding) {
					padding = wrapper.padding = value;
					updateTextPadding();
				}
			};
			wrapper.paddingLeftSetter =  function (value) {
				if (defined(value) && value !== paddingLeft) {
					paddingLeft = value;
					updateTextPadding();
				}
			};


			// change local variable and prevent setting attribute on the group
			wrapper.alignSetter = function (value) {
				alignFactor = { left: 0, center: 0.5, right: 1 }[value];
			};

			// apply these to the box and the text alike
			wrapper.textSetter = function (value) {
				if (value !== UNDEFINED) {
					text.textSetter(value);
				}
				updateBoxSize();
				updateTextPadding();
			};

			// apply these to the box but not to the text
			wrapper['stroke-widthSetter'] = function (value, key) {
				if (value) {
					needsBox = true;
				}
				crispAdjust = value % 2 / 2;
				boxAttr(key, value);
			};
			wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
				if (key === 'fill' && value) {
					needsBox = true;
				}
				boxAttr(key, value);
			};
			wrapper.anchorXSetter = function (value, key) {
				anchorX = value;
				boxAttr(key, value + crispAdjust - wrapperX);
			};
			wrapper.anchorYSetter = function (value, key) {
				anchorY = value;
				boxAttr(key, value - wrapperY);
			};

			// rename attributes
			wrapper.xSetter = function (value) {
				wrapper.x = value; // for animation getter
				if (alignFactor) {
					value -= alignFactor * ((width || bBox.width) + padding);
				}
				wrapperX = mathRound(value);
				wrapper.attr('translateX', wrapperX);
			};
			wrapper.ySetter = function (value) {
				wrapperY = wrapper.y = mathRound(value);
				wrapper.attr('translateY', wrapperY);
			};

			// Redirect certain methods to either the box or the text
			var baseCss = wrapper.css;
			return extend(wrapper, {
				/**
				 * Pick up some properties and apply them to the text instead of the wrapper
				 */
				css: function (styles) {
					if (styles) {
						var textStyles = {};
						styles = merge(styles); // create a copy to avoid altering the original object (#537)
						each(wrapper.textProps, function (prop) {
							if (styles[prop] !== UNDEFINED) {
								textStyles[prop] = styles[prop];
								delete styles[prop];
							}
						});
						text.css(textStyles);
					}
					return baseCss.call(wrapper, styles);
				},
				/**
				 * Return the bounding box of the box, not the group
				 */
				getBBox: function () {
					return {
						width: bBox.width + 2 * padding,
						height: bBox.height + 2 * padding,
						x: bBox.x - padding,
						y: bBox.y - padding
					};
				},
				/**
				 * Apply the shadow to the box
				 */
				shadow: function (b) {
					if (box) {
						box.shadow(b);
					}
					return wrapper;
				},
				/**
				 * Destroy and release memory.
				 */
				destroy: function () {

					// Added by button implementation
					removeEvent(wrapper.element, 'mouseenter');
					removeEvent(wrapper.element, 'mouseleave');

					if (text) {
						text = text.destroy();
					}
					if (box) {
						box = box.destroy();
					}
					// Call base implementation to destroy the rest
					SVGElement.prototype.destroy.call(wrapper);

					// Release local pointers (#1298)
					wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
				}
			});
		}
	}; // end SVGRenderer


	// general renderer
	Renderer = SVGRenderer;
	// extend SvgElement for useHTML option
	extend(SVGElement.prototype, {
		/**
		 * Apply CSS to HTML elements. This is used in text within SVG rendering and
		 * by the VML renderer
		 */
		htmlCss: function (styles) {
			var wrapper = this,
				element = wrapper.element,
				textWidth = styles && element.tagName === 'SPAN' && styles.width;

			if (textWidth) {
				delete styles.width;
				wrapper.textWidth = textWidth;
				wrapper.updateTransform();
			}
			if (styles && styles.textOverflow === 'ellipsis') {
				styles.whiteSpace = 'nowrap';
				styles.overflow = 'hidden';
			}
			wrapper.styles = extend(wrapper.styles, styles);
			css(wrapper.element, styles);

			return wrapper;
		},

		/**
		 * VML and useHTML method for calculating the bounding box based on offsets
		 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
		 * use the cached value
		 *
		 * @return {Object} A hash containing values for x, y, width and height
		 */

		htmlGetBBox: function () {
			var wrapper = this,
				element = wrapper.element;

			// faking getBBox in exported SVG in legacy IE
			// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
			if (element.nodeName === 'text') {
				element.style.position = ABSOLUTE;
			}

			return {
				x: element.offsetLeft,
				y: element.offsetTop,
				width: element.offsetWidth,
				height: element.offsetHeight
			};
		},

		/**
		 * VML override private method to update elements based on internal
		 * properties based on SVG transform
		 */
		htmlUpdateTransform: function () {
			// aligning non added elements is expensive
			if (!this.added) {
				this.alignOnAdd = true;
				return;
			}

			var wrapper = this,
				renderer = wrapper.renderer,
				elem = wrapper.element,
				translateX = wrapper.translateX || 0,
				translateY = wrapper.translateY || 0,
				x = wrapper.x || 0,
				y = wrapper.y || 0,
				align = wrapper.textAlign || 'left',
				alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
				shadows = wrapper.shadows,
				styles = wrapper.styles;

			// apply translate
			css(elem, {
				marginLeft: translateX,
				marginTop: translateY
			});
			if (shadows) { // used in labels/tooltip
				each(shadows, function (shadow) {
					css(shadow, {
						marginLeft: translateX + 1,
						marginTop: translateY + 1
					});
				});
			}

			// apply inversion
			if (wrapper.inverted) { // wrapper is a group
				each(elem.childNodes, function (child) {
					renderer.invertChild(child, elem);
				});
			}

			if (elem.tagName === 'SPAN') {

				var width,
					rotation = wrapper.rotation,
					baseline,
					textWidth = pInt(wrapper.textWidth),
					currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

				if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


					baseline = renderer.fontMetrics(elem.style.fontSize).b;

					// Renderer specific handling of span rotation
					if (defined(rotation)) {
						wrapper.setSpanRotation(rotation, alignCorrection, baseline);
					}

					width = pick(wrapper.elemWidth, elem.offsetWidth);

					// Update textWidth
					if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
						css(elem, {
							width: textWidth + PX,
							display: 'block',
							whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331
						});
						width = textWidth;
					}

					wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);
				}

				// apply position with correction
				css(elem, {
					left: (x + (wrapper.xCorr || 0)) + PX,
					top: (y + (wrapper.yCorr || 0)) + PX
				});

				// force reflow in webkit to apply the left and top on useHTML element (#1249)
				if (isWebKit) {
					baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose
				}

				// record current text transform
				wrapper.cTT = currentTextTransform;
			}
		},

		/**
		 * Set the rotation of an individual HTML span
		 */
		setSpanRotation: function (rotation, alignCorrection, baseline) {
			var rotationStyle = {},
				cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

			rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
			rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
			css(this.element, rotationStyle);
		},

		/**
		 * Get the correction in X and Y positioning as the element is rotated.
		 */
		getSpanCorrection: function (width, baseline, alignCorrection) {
			this.xCorr = -width * alignCorrection;
			this.yCorr = -baseline;
		}
	});

	// Extend SvgRenderer for useHTML option.
	extend(SVGRenderer.prototype, {
		/**
		 * Create HTML text node. This is used by the VML renderer as well as the SVG
		 * renderer through the useHTML option.
		 *
		 * @param {String} str
		 * @param {Number} x
		 * @param {Number} y
		 */
		html: function (str, x, y) {
			var wrapper = this.createElement('span'),
				element = wrapper.element,
				renderer = wrapper.renderer;

			// Text setter
			wrapper.textSetter = function (value) {
				if (value !== element.innerHTML) {
					delete this.bBox;
				}
				element.innerHTML = this.textStr = value;
			};

			// Various setters which rely on update transform
			wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
				if (key === 'align') {
					key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
				}
				wrapper[key] = value;
				wrapper.htmlUpdateTransform();
			};

			// Set the default attributes
			wrapper.attr({
					text: str,
					x: mathRound(x),
					y: mathRound(y)
				})
				.css({
					position: ABSOLUTE,
					fontFamily: this.style.fontFamily,
					fontSize: this.style.fontSize
				});

			// Keep the whiteSpace style outside the wrapper.styles collection
			element.style.whiteSpace = 'nowrap';

			// Use the HTML specific .css method
			wrapper.css = wrapper.htmlCss;

			// This is specific for HTML within SVG
			if (renderer.isSVG) {
				wrapper.add = function (svgGroupWrapper) {

					var htmlGroup,
						container = renderer.box.parentNode,
						parentGroup,
						parents = [];

					this.parentGroup = svgGroupWrapper;

					// Create a mock group to hold the HTML elements
					if (svgGroupWrapper) {
						htmlGroup = svgGroupWrapper.div;
						if (!htmlGroup) {

							// Read the parent chain into an array and read from top down
							parentGroup = svgGroupWrapper;
							while (parentGroup) {

								parents.push(parentGroup);

								// Move up to the next parent group
								parentGroup = parentGroup.parentGroup;
							}

							// Ensure dynamically updating position when any parent is translated
							each(parents.reverse(), function (parentGroup) {
								var htmlGroupStyle;

								// Create a HTML div and append it to the parent div to emulate
								// the SVG group structure
								htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {
									className: attr(parentGroup.element, 'class')
								}, {
									position: ABSOLUTE,
									left: (parentGroup.translateX || 0) + PX,
									top: (parentGroup.translateY || 0) + PX
								}, htmlGroup || container); // the top group is appended to container

								// Shortcut
								htmlGroupStyle = htmlGroup.style;

								// Set listeners to update the HTML div's position whenever the SVG group
								// position is changed
								extend(parentGroup, {
									translateXSetter: function (value, key) {
										htmlGroupStyle.left = value + PX;
										parentGroup[key] = value;
										parentGroup.doTransform = true;
									},
									translateYSetter: function (value, key) {
										htmlGroupStyle.top = value + PX;
										parentGroup[key] = value;
										parentGroup.doTransform = true;
									},
									visibilitySetter: function (value, key) {
										htmlGroupStyle[key] = value;
									}
								});
							});

						}
					} else {
						htmlGroup = container;
					}

					htmlGroup.appendChild(element);

					// Shared with VML:
					wrapper.added = true;
					if (wrapper.alignOnAdd) {
						wrapper.htmlUpdateTransform();
					}

					return wrapper;
				};
			}
			return wrapper;
		}
	});

	/* ****************************************************************************
	 *                                                                            *
	 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
	 *                                                                            *
	 * For applications and websites that don't need IE support, like platform    *
	 * targeted mobile apps and web apps, this code can be removed.               *
	 *                                                                            *
	 *****************************************************************************/

	/**
	 * @constructor
	 */
	var VMLRenderer, VMLElement;
	if (!hasSVG && !useCanVG) {

	/**
	 * The VML element wrapper.
	 */
	VMLElement = {

		/**
		 * Initialize a new VML element wrapper. It builds the markup as a string
		 * to minimize DOM traffic.
		 * @param {Object} renderer
		 * @param {Object} nodeName
		 */
		init: function (renderer, nodeName) {
			var wrapper = this,
				markup =  ['<', nodeName, ' filled="f" stroked="f"'],
				style = ['position: ', ABSOLUTE, ';'],
				isDiv = nodeName === DIV;

			// divs and shapes need size
			if (nodeName === 'shape' || isDiv) {
				style.push('left:0;top:0;width:1px;height:1px;');
			}
			style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

			markup.push(' style="', style.join(''), '"/>');

			// create element with default attributes and style
			if (nodeName) {
				markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
					markup.join('')
					: renderer.prepVML(markup);
				wrapper.element = createElement(markup);
			}

			wrapper.renderer = renderer;
		},

		/**
		 * Add the node to the given parent
		 * @param {Object} parent
		 */
		add: function (parent) {
			var wrapper = this,
				renderer = wrapper.renderer,
				element = wrapper.element,
				box = renderer.box,
				inverted = parent && parent.inverted,

				// get the parent node
				parentNode = parent ?
					parent.element || parent :
					box;


			// if the parent group is inverted, apply inversion on all children
			if (inverted) { // only on groups
				renderer.invertChild(element, parentNode);
			}

			// append it
			parentNode.appendChild(element);

			// align text after adding to be able to read offset
			wrapper.added = true;
			if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
				wrapper.updateTransform();
			}

			// fire an event for internal hooks
			if (wrapper.onAdd) {
				wrapper.onAdd();
			}

			return wrapper;
		},

		/**
		 * VML always uses htmlUpdateTransform
		 */
		updateTransform: SVGElement.prototype.htmlUpdateTransform,

		/**
		 * Set the rotation of a span with oldIE's filter
		 */
		setSpanRotation: function () {
			// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
			// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
			// has support for CSS3 transform. The getBBox method also needs to be updated
			// to compensate for the rotation, like it currently does for SVG.
			// Test case: http://jsfiddle.net/highcharts/Ybt44/

			var rotation = this.rotation,
				costheta = mathCos(rotation * deg2rad),
				sintheta = mathSin(rotation * deg2rad);
						
			css(this.element, {
				filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
					', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
					', sizingMethod=\'auto expand\')'].join('') : NONE
			});
		},

		/**
		 * Get the positioning correction for the span after rotating. 
		 */
		getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

			var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
				sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
				height = pick(this.elemHeight, this.element.offsetHeight),
				quad,
				nonLeft = align && align !== 'left';

			// correct x and y
			this.xCorr = costheta < 0 && -width;
			this.yCorr = sintheta < 0 && -height;

			// correct for baseline and corners spilling out after rotation
			quad = costheta * sintheta < 0;
			this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
			this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
			// correct for the length/height of the text
			if (nonLeft) {
				this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
				if (rotation) {
					this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
				}
				css(this.element, {
					textAlign: align
				});
			}
		},

		/**
		 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
		 * as the parameter and returns a string.
		 */
		pathToVML: function (value) {
			// convert paths
			var i = value.length,
				path = [];

			while (i--) {

				// Multiply by 10 to allow subpixel precision.
				// Substracting half a pixel seems to make the coordinates
				// align with SVG, but this hasn't been tested thoroughly
				if (isNumber(value[i])) {
					path[i] = mathRound(value[i] * 10) - 5;
				} else if (value[i] === 'Z') { // close the path
					path[i] = 'x';
				} else {
					path[i] = value[i];

					// When the start X and end X coordinates of an arc are too close,
					// they are rounded to the same value above. In this case, substract or 
					// add 1 from the end X and Y positions. #186, #760, #1371, #1410.
					if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
						// Start and end X
						if (path[i + 5] === path[i + 7]) {
							path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
						}
						// Start and end Y
						if (path[i + 6] === path[i + 8]) {
							path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
						}
					}
				}
			}

			
			// Loop up again to handle path shortcuts (#2132)
			/*while (i++ < path.length) {
				if (path[i] === 'H') { // horizontal line to
					path[i] = 'L';
					path.splice(i + 2, 0, path[i - 1]);
				} else if (path[i] === 'V') { // vertical line to
					path[i] = 'L';
					path.splice(i + 1, 0, path[i - 2]);
				}
			}*/
			return path.join(' ') || 'x';
		},

		/**
		 * Set the element's clipping to a predefined rectangle
		 *
		 * @param {String} id The id of the clip rectangle
		 */
		clip: function (clipRect) {
			var wrapper = this,
				clipMembers,
				cssRet;

			if (clipRect) {
				clipMembers = clipRect.members;
				erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
				clipMembers.push(wrapper);
				wrapper.destroyClip = function () {
					erase(clipMembers, wrapper);
				};
				cssRet = clipRect.getCSS(wrapper);

			} else {
				if (wrapper.destroyClip) {
					wrapper.destroyClip();
				}
				cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
			}

			return wrapper.css(cssRet);

		},

		/**
		 * Set styles for the element
		 * @param {Object} styles
		 */
		css: SVGElement.prototype.htmlCss,

		/**
		 * Removes a child either by removeChild or move to garbageBin.
		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
		 */
		safeRemoveChild: function (element) {
			// discardElement will detach the node from its parent before attaching it
			// to the garbage bin. Therefore it is important that the node is attached and have parent.
			if (element.parentNode) {
				discardElement(element);
			}
		},

		/**
		 * Extend element.destroy by removing it from the clip members array
		 */
		destroy: function () {
			if (this.destroyClip) {
				this.destroyClip();
			}

			return SVGElement.prototype.destroy.apply(this);
		},

		/**
		 * Add an event listener. VML override for normalizing event parameters.
		 * @param {String} eventType
		 * @param {Function} handler
		 */
		on: function (eventType, handler) {
			// simplest possible event model for internal use
			this.element['on' + eventType] = function () {
				var evt = win.event;
				evt.target = evt.srcElement;
				handler(evt);
			};
			return this;
		},

		/**
		 * In stacked columns, cut off the shadows so that they don't overlap
		 */
		cutOffPath: function (path, length) {

			var len;

			path = path.split(/[ ,]/);
			len = path.length;

			if (len === 9 || len === 11) {
				path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
			}
			return path.join(' ');
		},

		/**
		 * Apply a drop shadow by copying elements and giving them different strokes
		 * @param {Boolean|Object} shadowOptions
		 */
		shadow: function (shadowOptions, group, cutOff) {
			var shadows = [],
				i,
				element = this.element,
				renderer = this.renderer,
				shadow,
				elemStyle = element.style,
				markup,
				path = element.path,
				strokeWidth,
				modifiedPath,
				shadowWidth,
				shadowElementOpacity;

			// some times empty paths are not strings
			if (path && typeof path.value !== 'string') {
				path = 'x';
			}
			modifiedPath = path;

			if (shadowOptions) {
				shadowWidth = pick(shadowOptions.width, 3);
				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
				for (i = 1; i <= 3; i++) {

					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

					// Cut off shadows for stacked column items
					if (cutOff) {
						modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
					}

					markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
						'" filled="false" path="', modifiedPath,
						'" coordsize="10 10" style="', element.style.cssText, '" />'];

					shadow = createElement(renderer.prepVML(markup),
						null, {
							left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
							top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
						}
					);
					if (cutOff) {
						shadow.cutOff = strokeWidth + 1;
					}

					// apply the opacity
					markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
					createElement(renderer.prepVML(markup), null, null, shadow);


					// insert it
					if (group) {
						group.element.appendChild(shadow);
					} else {
						element.parentNode.insertBefore(shadow, element);
					}

					// record it
					shadows.push(shadow);

				}

				this.shadows = shadows;
			}
			return this;
		},
		updateShadows: noop, // Used in SVG only

		setAttr: function (key, value) {
			if (docMode8) { // IE8 setAttribute bug
				this.element[key] = value;
			} else {
				this.element.setAttribute(key, value);
			}
		},
		classSetter: function (value) {
			// IE8 Standards mode has problems retrieving the className unless set like this
			this.element.className = value;
		},
		dashstyleSetter: function (value, key, element) {
			var strokeElem = element.getElementsByTagName('stroke')[0] ||
				createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
			strokeElem[key] = value || 'solid';
			this[key] = value; /* because changing stroke-width will change the dash length
				and cause an epileptic effect */
		},
		dSetter: function (value, key, element) {
			var i,
				shadows = this.shadows;
			value = value || [];
			this.d = value.join && value.join(' '); // used in getter for animation

			element.path = value = this.pathToVML(value);

			// update shadows
			if (shadows) {
				i = shadows.length;
				while (i--) {
					shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
				}
			}
			this.setAttr(key, value);
		},
		fillSetter: function (value, key, element) {
			var nodeName = element.nodeName;
			if (nodeName === 'SPAN') { // text color
				element.style.color = value;
			} else if (nodeName !== 'IMG') { // #1336
				element.filled = value !== NONE;
				this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
			}
		},
		opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
		rotationSetter: function (value, key, element) {
			var style = element.style;
			this[key] = style[key] = value; // style is for #1873

			// Correction for the 1x1 size of the shape container. Used in gauge needles.
			style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
			style.top = mathRound(mathCos(value * deg2rad)) + PX;
		},
		strokeSetter: function (value, key, element) {
			this.setAttr('strokecolor', this.renderer.color(value, element, key));
		},
		'stroke-widthSetter': function (value, key, element) {
			element.stroked = !!value; // VML "stroked" attribute
			this[key] = value; // used in getter, issue #113
			if (isNumber(value)) {
				value += PX;
			}
			this.setAttr('strokeweight', value);
		},
		titleSetter: function (value, key) {
			this.setAttr(key, value);
		},
		visibilitySetter: function (value, key, element) {

			// Handle inherited visibility
			if (value === 'inherit') {
				value = VISIBLE;
			}
			
			// Let the shadow follow the main element
			if (this.shadows) {
				each(this.shadows, function (shadow) {
					shadow.style[key] = value;
				});
			}

			// Instead of toggling the visibility CSS property, move the div out of the viewport.
			// This works around #61 and #586
			if (element.nodeName === 'DIV') {
				value = value === HIDDEN ? '-999em' : 0;

				// In order to redraw, IE7 needs the div to be visible when tucked away
				// outside the viewport. So the visibility is actually opposite of
				// the expected value. This applies to the tooltip only.
				if (!docMode8) {
					element.style[key] = value ? VISIBLE : HIDDEN;
				}
				key = 'top';
			}
			element.style[key] = value;
		},
		xSetter: function (value, key, element) {
			this[key] = value; // used in getter

			if (key === 'x') {
				key = 'left';
			} else if (key === 'y') {
				key = 'top';
			}/* else {
				value = mathMax(0, value); // don't set width or height below zero (#311)
			}*/

			// clipping rectangle special
			if (this.updateClipping) {
				this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
				this.updateClipping();
			} else {
				// normal
				element.style[key] = value;
			}
		},
		zIndexSetter: function (value, key, element) {
			element.style[key] = value;
		}
	};
	Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

	// Some shared setters
	VMLElement.prototype.ySetter =
		VMLElement.prototype.widthSetter = 
		VMLElement.prototype.heightSetter = 
		VMLElement.prototype.xSetter;


	/**
	 * The VML renderer
	 */
	var VMLRendererExtension = { // inherit SVGRenderer

		Element: VMLElement,
		isIE8: userAgent.indexOf('MSIE 8.0') > -1,


		/**
		 * Initialize the VMLRenderer
		 * @param {Object} container
		 * @param {Number} width
		 * @param {Number} height
		 */
		init: function (container, width, height, style) {
			var renderer = this,
				boxWrapper,
				box,
				css;

			renderer.alignedObjects = [];

			boxWrapper = renderer.createElement(DIV)
				.css(extend(this.getStyle(style), { position: RELATIVE}));
			box = boxWrapper.element;
			container.appendChild(boxWrapper.element);


			// generate the containing box
			renderer.isVML = true;
			renderer.box = box;
			renderer.boxWrapper = boxWrapper;
			renderer.cache = {};


			renderer.setSize(width, height, false);

			// The only way to make IE6 and IE7 print is to use a global namespace. However,
			// with IE8 the only way to make the dynamic shapes visible in screen and print mode
			// seems to be to add the xmlns attribute and the behaviour style inline.
			if (!doc.namespaces.hcv) {

				doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

				// Setup default CSS (#2153, #2368, #2384)
				css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
					'{ behavior:url(#default#VML); display: inline-block; } ';
				try {
					doc.createStyleSheet().cssText = css;
				} catch (e) {
					doc.styleSheets[0].cssText += css;
				}

			}
		},


		/**
		 * Detect whether the renderer is hidden. This happens when one of the parent elements
		 * has display: none
		 */
		isHidden: function () {
			return !this.box.offsetWidth;
		},

		/**
		 * Define a clipping rectangle. In VML it is accomplished by storing the values
		 * for setting the CSS style to all associated members.
		 *
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		clipRect: function (x, y, width, height) {

			// create a dummy element
			var clipRect = this.createElement(),
				isObj = isObject(x);

			// mimic a rectangle with its style object for automatic updating in attr
			return extend(clipRect, {
				members: [],
				count: 0,
				left: (isObj ? x.x : x) + 1,
				top: (isObj ? x.y : y) + 1,
				width: (isObj ? x.width : width) - 1,
				height: (isObj ? x.height : height) - 1,
				getCSS: function (wrapper) {
					var element = wrapper.element,
						nodeName = element.nodeName,
						isShape = nodeName === 'shape',
						inverted = wrapper.inverted,
						rect = this,
						top = rect.top - (isShape ? element.offsetTop : 0),
						left = rect.left,
						right = left + rect.width,
						bottom = top + rect.height,
						ret = {
							clip: 'rect(' +
								mathRound(inverted ? left : top) + 'px,' +
								mathRound(inverted ? bottom : right) + 'px,' +
								mathRound(inverted ? right : bottom) + 'px,' +
								mathRound(inverted ? top : left) + 'px)'
						};

					// issue 74 workaround
					if (!inverted && docMode8 && nodeName === 'DIV') {
						extend(ret, {
							width: right + PX,
							height: bottom + PX
						});
					}
					return ret;
				},

				// used in attr and animation to update the clipping of all members
				updateClipping: function () {
					each(clipRect.members, function (member) {
						if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
							member.css(clipRect.getCSS(member));
						}
					});
				}
			});

		},


		/**
		 * Take a color and return it if it's a string, make it a gradient if it's a
		 * gradient configuration object, and apply opacity.
		 *
		 * @param {Object} color The color or config object
		 */
		color: function (color, elem, prop, wrapper) {
			var renderer = this,
				colorObject,
				regexRgba = /^rgba/,
				markup,
				fillType,
				ret = NONE;

			// Check for linear or radial gradient
			if (color && color.linearGradient) {
				fillType = 'gradient';
			} else if (color && color.radialGradient) {
				fillType = 'pattern';
			}


			if (fillType) {

				var stopColor,
					stopOpacity,
					gradient = color.linearGradient || color.radialGradient,
					x1,
					y1,
					x2,
					y2,
					opacity1,
					opacity2,
					color1,
					color2,
					fillAttr = '',
					stops = color.stops,
					firstStop,
					lastStop,
					colors = [],
					addFillNode = function () {
						// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
						// are reversed.
						markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
							'" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
						createElement(renderer.prepVML(markup), null, null, elem);
					};

				// Extend from 0 to 1
				firstStop = stops[0];
				lastStop = stops[stops.length - 1];
				if (firstStop[0] > 0) {
					stops.unshift([
						0,
						firstStop[1]
					]);
				}
				if (lastStop[0] < 1) {
					stops.push([
						1,
						lastStop[1]
					]);
				}

				// Compute the stops
				each(stops, function (stop, i) {
					if (regexRgba.test(stop[1])) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}

					// Build the color attribute
					colors.push((stop[0] * 100) + '% ' + stopColor);

					// Only start and end opacities are allowed, so we use the first and the last
					if (!i) {
						opacity1 = stopOpacity;
						color2 = stopColor;
					} else {
						opacity2 = stopOpacity;
						color1 = stopColor;
					}
				});

				// Apply the gradient to fills only.
				if (prop === 'fill') {

					// Handle linear gradient angle
					if (fillType === 'gradient') {
						x1 = gradient.x1 || gradient[0] || 0;
						y1 = gradient.y1 || gradient[1] || 0;
						x2 = gradient.x2 || gradient[2] || 0;
						y2 = gradient.y2 || gradient[3] || 0;
						fillAttr = 'angle="' + (90  - math.atan(
							(y2 - y1) / // y vector
							(x2 - x1) // x vector
							) * 180 / mathPI) + '"';

						addFillNode();

					// Radial (circular) gradient
					} else {

						var r = gradient.r,
							sizex = r * 2,
							sizey = r * 2,
							cx = gradient.cx,
							cy = gradient.cy,
							radialReference = elem.radialReference,
							bBox,
							applyRadialGradient = function () {
								if (radialReference) {
									bBox = wrapper.getBBox();
									cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
									cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
									sizex *= radialReference[2] / bBox.width;
									sizey *= radialReference[2] / bBox.height;
								}
								fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
									'size="' + sizex + ',' + sizey + '" ' +
									'origin="0.5,0.5" ' +
									'position="' + cx + ',' + cy + '" ' +
									'color2="' + color2 + '" ';

								addFillNode();
							};

						// Apply radial gradient
						if (wrapper.added) {
							applyRadialGradient();
						} else {
							// We need to know the bounding box to get the size and position right
							wrapper.onAdd = applyRadialGradient;
						}

						// The fill element's color attribute is broken in IE8 standards mode, so we
						// need to set the parent shape's fillcolor attribute instead.
						ret = color1;
					}

				// Gradients are not supported for VML stroke, return the first color. #722.
				} else {
					ret = stopColor;
				}

			// if the color is an rgba color, split it and add a fill node
			// to hold the opacity component
			} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

				colorObject = Color(color);

				markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
				createElement(this.prepVML(markup), null, null, elem);

				ret = colorObject.get('rgb');


			} else {
				var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
				if (propNodes.length) {
					propNodes[0].opacity = 1;
					propNodes[0].type = 'solid';
				}
				ret = color;
			}

			return ret;
		},

		/**
		 * Take a VML string and prepare it for either IE8 or IE6/IE7.
		 * @param {Array} markup A string array of the VML markup to prepare
		 */
		prepVML: function (markup) {
			var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
				isIE8 = this.isIE8;

			markup = markup.join('');

			if (isIE8) { // add xmlns and style inline
				markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
				if (markup.indexOf('style="') === -1) {
					markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
				} else {
					markup = markup.replace('style="', 'style="' + vmlStyle);
				}

			} else { // add namespace
				markup = markup.replace('<', '<hcv:');
			}

			return markup;
		},

		/**
		 * Create rotated and aligned text
		 * @param {String} str
		 * @param {Number} x
		 * @param {Number} y
		 */
		text: SVGRenderer.prototype.html,

		/**
		 * Create and return a path element
		 * @param {Array} path
		 */
		path: function (path) {
			var attr = {
				// subpixel precision down to 0.1 (width and height = 1px)
				coordsize: '10 10'
			};
			if (isArray(path)) {
				attr.d = path;
			} else if (isObject(path)) { // attributes
				extend(attr, path);
			}
			// create the shape
			return this.createElement('shape').attr(attr);
		},

		/**
		 * Create and return a circle element. In VML circles are implemented as
		 * shapes, which is faster than v:oval
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} r
		 */
		circle: function (x, y, r) {
			var circle = this.symbol('circle');
			if (isObject(x)) {
				r = x.r;
				y = x.y;
				x = x.x;
			}
			circle.isCircle = true; // Causes x and y to mean center (#1682)
			circle.r = r;
			return circle.attr({ x: x, y: y });
		},

		/**
		 * Create a group using an outer div and an inner v:group to allow rotating
		 * and flipping. A simple v:group would have problems with positioning
		 * child HTML elements and CSS clip.
		 *
		 * @param {String} name The name of the group
		 */
		g: function (name) {
			var wrapper,
				attribs;

			// set the class name
			if (name) {
				attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
			}

			// the div to hold HTML and clipping
			wrapper = this.createElement(DIV).attr(attribs);

			return wrapper;
		},

		/**
		 * VML override to create a regular HTML image
		 * @param {String} src
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		image: function (src, x, y, width, height) {
			var obj = this.createElement('img')
				.attr({ src: src });

			if (arguments.length > 1) {
				obj.attr({
					x: x,
					y: y,
					width: width,
					height: height
				});
			}
			return obj;
		},

		/**
		 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
		 */
		createElement: function (nodeName) {
			return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);	
		},

		/**
		 * In the VML renderer, each child of an inverted div (group) is inverted
		 * @param {Object} element
		 * @param {Object} parentNode
		 */
		invertChild: function (element, parentNode) {
			var ren = this,
				parentStyle = parentNode.style,
				imgStyle = element.tagName === 'IMG' && element.style; // #1111

			css(element, {
				flip: 'x',
				left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
				top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
				rotation: -90
			});

			// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
			each(element.childNodes, function (child) {
				ren.invertChild(child, element);
			});
		},

		/**
		 * Symbol definitions that override the parent SVG renderer's symbols
		 *
		 */
		symbols: {
			// VML specific arc function
			arc: function (x, y, w, h, options) {
				var start = options.start,
					end = options.end,
					radius = options.r || w || h,
					innerRadius = options.innerR,
					cosStart = mathCos(start),
					sinStart = mathSin(start),
					cosEnd = mathCos(end),
					sinEnd = mathSin(end),
					ret;

				if (end - start === 0) { // no angle, don't show it.
					return ['x'];
				}

				ret = [
					'wa', // clockwise arc to
					x - radius, // left
					y - radius, // top
					x + radius, // right
					y + radius, // bottom
					x + radius * cosStart, // start x
					y + radius * sinStart, // start y
					x + radius * cosEnd, // end x
					y + radius * sinEnd  // end y
				];

				if (options.open && !innerRadius) {
					ret.push(
						'e',
						M,
						x,// - innerRadius,
						y// - innerRadius
					);
				}

				ret.push(
					'at', // anti clockwise arc to
					x - innerRadius, // left
					y - innerRadius, // top
					x + innerRadius, // right
					y + innerRadius, // bottom
					x + innerRadius * cosEnd, // start x
					y + innerRadius * sinEnd, // start y
					x + innerRadius * cosStart, // end x
					y + innerRadius * sinStart, // end y
					'x', // finish path
					'e' // close
				);

				ret.isArc = true;
				return ret;

			},
			// Add circle symbol path. This performs significantly faster than v:oval.
			circle: function (x, y, w, h, wrapper) {

				if (wrapper) {
					w = h = 2 * wrapper.r;
				}

				// Center correction, #1682
				if (wrapper && wrapper.isCircle) {
					x -= w / 2;
					y -= h / 2;
				}

				// Return the path
				return [
					'wa', // clockwisearcto
					x, // left
					y, // top
					x + w, // right
					y + h, // bottom
					x + w, // start x
					y + h / 2,     // start y
					x + w, // end x
					y + h / 2,     // end y
					//'x', // finish path
					'e' // close
				];
			},
			/**
			 * Add rectangle symbol path which eases rotation and omits arcsize problems
			 * compared to the built-in VML roundrect shape. When borders are not rounded,
			 * use the simpler square path, else use the callout path without the arrow.
			 */
			rect: function (x, y, w, h, options) {
				return SVGRenderer.prototype.symbols[
					!defined(options) || !options.r ? 'square' : 'callout'
				].call(0, x, y, w, h, options);
			}
		}
	};
	Highcharts.VMLRenderer = VMLRenderer = function () {
		this.init.apply(this, arguments);
	};
	VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

		// general renderer
		Renderer = VMLRenderer;
	}

	// This method is used with exporting in old IE, when emulating SVG (see #2314)
	SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
		var measuringSpan = doc.createElement('span'),
			offsetWidth,
		textNode = doc.createTextNode(text);

		measuringSpan.appendChild(textNode);
		css(measuringSpan, styles);
		this.box.appendChild(measuringSpan);
		offsetWidth = measuringSpan.offsetWidth;
		discardElement(measuringSpan); // #2463
		return offsetWidth;
	};


	/* ****************************************************************************
	 *                                                                            *
	 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
	 *                                                                            *
	 *****************************************************************************/
	/* ****************************************************************************
	 *                                                                            *
	 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
	 * TARGETING THAT SYSTEM.                                                     *
	 *                                                                            *
	 *****************************************************************************/
	var CanVGRenderer,
		CanVGController;

	if (useCanVG) {
		/**
		 * The CanVGRenderer is empty from start to keep the source footprint small.
		 * When requested, the CanVGController downloads the rest of the source packaged
		 * together with the canvg library.
		 */
		Highcharts.CanVGRenderer = CanVGRenderer = function () {
			// Override the global SVG namespace to fake SVG/HTML that accepts CSS
			SVG_NS = 'http://www.w3.org/1999/xhtml';
		};

		/**
		 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
		 * the implementation from SvgRenderer will not be merged in until first render.
		 */
		CanVGRenderer.prototype.symbols = {};

		/**
		 * Handles on demand download of canvg rendering support.
		 */
		CanVGController = (function () {
			// List of renderering calls
			var deferredRenderCalls = [];

			/**
			 * When downloaded, we are ready to draw deferred charts.
			 */
			function drawDeferred() {
				var callLength = deferredRenderCalls.length,
					callIndex;

				// Draw all pending render calls
				for (callIndex = 0; callIndex < callLength; callIndex++) {
					deferredRenderCalls[callIndex]();
				}
				// Clear the list
				deferredRenderCalls = [];
			}

			return {
				push: function (func, scriptLocation) {
					// Only get the script once
					if (deferredRenderCalls.length === 0) {
						getScript(scriptLocation, drawDeferred);
					}
					// Register render call
					deferredRenderCalls.push(func);
				}
			};
		}());

		Renderer = CanVGRenderer;
	} // end CanVGRenderer

	/* ****************************************************************************
	 *                                                                            *
	 * END OF ANDROID < 3 SPECIFIC CODE                                           *
	 *                                                                            *
	 *****************************************************************************/

	/**
	 * The Tick class
	 */
	function Tick(axis, pos, type, noLabel) {
		this.axis = axis;
		this.pos = pos;
		this.type = type || '';
		this.isNew = true;

		if (!type && !noLabel) {
			this.addLabel();
		}
	}

	Tick.prototype = {
		/**
		 * Write the tick label
		 */
		addLabel: function () {
			var tick = this,
				axis = tick.axis,
				options = axis.options,
				chart = axis.chart,
				categories = axis.categories,
				names = axis.names,
				pos = tick.pos,
				labelOptions = options.labels,
				str,
				tickPositions = axis.tickPositions,
				isFirst = pos === tickPositions[0],
				isLast = pos === tickPositions[tickPositions.length - 1],
				value = categories ?
					pick(categories[pos], names[pos], pos) :
					pos,
				label = tick.label,
				tickPositionInfo = tickPositions.info,
				dateTimeLabelFormat;

			// Set the datetime label format. If a higher rank is set for this position, use that. If not,
			// use the general format.
			if (axis.isDatetimeAxis && tickPositionInfo) {
				dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
			}
			// set properties for access in render method
			tick.isFirst = isFirst;
			tick.isLast = isLast;

			// get the string
			str = axis.labelFormatter.call({
				axis: axis,
				chart: chart,
				isFirst: isFirst,
				isLast: isLast,
				dateTimeLabelFormat: dateTimeLabelFormat,
				value: axis.isLog ? correctFloat(lin2log(value)) : value
			});

			// prepare CSS
			//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
			
			// first call
			if (!defined(label)) {

				tick.label = label =
					defined(str) && labelOptions.enabled ?
						chart.renderer.text(
								str,
								0,
								0,
								labelOptions.useHTML
							)
							//.attr(attr)
							// without position absolute, IE export sometimes is wrong
							.css(merge(labelOptions.style))
							.add(axis.labelGroup) :
						null;
				tick.labelLength = label && label.getBBox().width; // Un-rotated length
				tick.rotation = 0; // Base value to detect change for new calls to getBBox

			// update
			} else if (label) {
				label.attr({ text: str });
			}
		},

		/**
		 * Get the offset height or width of the label
		 */
		getLabelSize: function () {
			return this.label ?
				this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
				0;
		},

		/**
		 * Handle the label overflow by adjusting the labels to the left and right edge, or
		 * hide them if they collide into the neighbour label.
		 */
		handleOverflow: function (xy) {
			var axis = this.axis,
				pxPos = xy.x,
				chartWidth = axis.chart.chartWidth,
				spacing = axis.chart.spacing,
				leftBound = pick(axis.labelLeft, spacing[3]),
				rightBound = pick(axis.labelRight, chartWidth - spacing[1]),
				label = this.label,
				rotation = this.rotation,
				factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
				labelWidth = label.getBBox().width,
				slotWidth = axis.slotWidth,
				leftPos,
				rightPos,
				textWidth;

			// Check if the label overshoots the chart spacing box. If it does, move it.
			// If it now overshoots the slotWidth, add ellipsis.
			if (!rotation) {
				leftPos = pxPos - factor * labelWidth;
				rightPos = pxPos + factor * labelWidth;

				if (leftPos < leftBound) {
					slotWidth -= leftBound - leftPos;
					xy.x = leftBound;
					label.attr({ align: 'left' });				
				} else if (rightPos > rightBound) {
					slotWidth -= rightPos - rightBound;
					xy.x = rightBound;
					label.attr({ align: 'right' });
				}

				if (labelWidth > slotWidth) {
					textWidth = slotWidth;
				}
			

			// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
			} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
				textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
			} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
				textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
			}

			if (textWidth) {
				label.css({
					width: textWidth,
					textOverflow: 'ellipsis'
				});
			}
		},

		/**
		 * Get the x and y position for ticks and labels
		 */
		getPosition: function (horiz, pos, tickmarkOffset, old) {
			var axis = this.axis,
				chart = axis.chart,
				cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

			return {
				x: horiz ?
					axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
					axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

				y: horiz ?
					cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
					cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
			};

		},

		/**
		 * Get the x, y position of the tick label
		 */
		getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
			var axis = this.axis,
				transA = axis.transA,
				reversed = axis.reversed,
				staggerLines = axis.staggerLines,
				rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
				yOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),
				line;

			x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
				tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
			y = y + yOffset - (tickmarkOffset && !horiz ?
				tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

			// Correct for staggered labels
			if (staggerLines) {
				line = (index / (step || 1) % staggerLines);
				y += line * (axis.labelOffset / staggerLines);
			}

			return {
				x: x,
				y: mathRound(y)
			};
		},

		/**
		 * Extendible method to return the path of the marker
		 */
		getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
			return renderer.crispLine([
					M,
					x,
					y,
					L,
					x + (horiz ? 0 : -tickLength),
					y + (horiz ? tickLength : 0)
				], tickWidth);
		},

		/**
		 * Put everything in place
		 *
		 * @param index {Number}
		 * @param old {Boolean} Use old coordinates to prepare an animation into new position
		 */
		render: function (index, old, opacity) {
			var tick = this,
				axis = tick.axis,
				options = axis.options,
				chart = axis.chart,
				renderer = chart.renderer,
				horiz = axis.horiz,
				type = tick.type,
				label = tick.label,
				pos = tick.pos,
				labelOptions = options.labels,
				gridLine = tick.gridLine,
				gridPrefix = type ? type + 'Grid' : 'grid',
				tickPrefix = type ? type + 'Tick' : 'tick',
				gridLineWidth = options[gridPrefix + 'LineWidth'],
				gridLineColor = options[gridPrefix + 'LineColor'],
				dashStyle = options[gridPrefix + 'LineDashStyle'],
				tickLength = options[tickPrefix + 'Length'],
				tickWidth = options[tickPrefix + 'Width'] || 0,
				tickColor = options[tickPrefix + 'Color'],
				tickPosition = options[tickPrefix + 'Position'],
				gridLinePath,
				mark = tick.mark,
				markPath,
				step = /*axis.labelStep || */labelOptions.step,
				attribs,
				show = true,
				tickmarkOffset = axis.tickmarkOffset,
				xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
				x = xy.x,
				y = xy.y,
				reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

			opacity = pick(opacity, 1);
			this.isActive = true;

			// create the grid line
			if (gridLineWidth) {
				gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

				if (gridLine === UNDEFINED) {
					attribs = {
						stroke: gridLineColor,
						'stroke-width': gridLineWidth
					};
					if (dashStyle) {
						attribs.dashstyle = dashStyle;
					}
					if (!type) {
						attribs.zIndex = 1;
					}
					if (old) {
						attribs.opacity = 0;
					}
					tick.gridLine = gridLine =
						gridLineWidth ?
							renderer.path(gridLinePath)
								.attr(attribs).add(axis.gridGroup) :
							null;
				}

				// If the parameter 'old' is set, the current call will be followed
				// by another call, therefore do not do any animations this time
				if (!old && gridLine && gridLinePath) {
					gridLine[tick.isNew ? 'attr' : 'animate']({
						d: gridLinePath,
						opacity: opacity
					});
				}
			}

			// create the tick mark
			if (tickWidth && tickLength) {

				// negate the length
				if (tickPosition === 'inside') {
					tickLength = -tickLength;
				}
				if (axis.opposite) {
					tickLength = -tickLength;
				}

				markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
				if (mark) { // updating
					mark.animate({
						d: markPath,
						opacity: opacity
					});
				} else { // first time
					tick.mark = renderer.path(
						markPath
					).attr({
						stroke: tickColor,
						'stroke-width': tickWidth,
						opacity: opacity
					}).add(axis.axisGroup);
				}
			}

			// the label is created on init - now move it into place
			if (label && !isNaN(x)) {
				label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

				// Apply show first and show last. If the tick is both first and last, it is
				// a single centered tick, in which case we show the label anyway (#2100).
				if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
						(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
					show = false;

				// Handle label overflow and show or hide accordingly
				} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
					tick.handleOverflow(xy);
				}

				// apply step
				if (step && index % step) {
					// show those indices dividable by step
					show = false;
				}

				// Set the new position, and show or hide
				if (show && !isNaN(xy.y)) {
					xy.opacity = opacity;
					label[tick.isNew ? 'attr' : 'animate'](xy);
					tick.isNew = false;
				} else {
					label.attr('y', -9999); // #1338
				}
			}
		},

		/**
		 * Destructor for the tick prototype
		 */
		destroy: function () {
			destroyObjectProperties(this, this.axis);
		}
	};

	/**
	 * The object wrapper for plot lines and plot bands
	 * @param {Object} options
	 */
	Highcharts.PlotLineOrBand = function (axis, options) {
		this.axis = axis;

		if (options) {
			this.options = options;
			this.id = options.id;
		}
	};

	Highcharts.PlotLineOrBand.prototype = {
		
		/**
		 * Render the plot line or plot band. If it is already existing,
		 * move it.
		 */
		render: function () {
			var plotLine = this,
				axis = plotLine.axis,
				horiz = axis.horiz,
				options = plotLine.options,
				optionsLabel = options.label,
				label = plotLine.label,
				width = options.width,
				to = options.to,
				from = options.from,
				isBand = defined(from) && defined(to),
				value = options.value,
				dashStyle = options.dashStyle,
				svgElem = plotLine.svgElem,
				path = [],
				addEvent,
				eventType,
				xs,
				ys,
				x,
				y,
				color = options.color,
				zIndex = options.zIndex,
				events = options.events,
				attribs = {},
				renderer = axis.chart.renderer;

			// logarithmic conversion
			if (axis.isLog) {
				from = log2lin(from);
				to = log2lin(to);
				value = log2lin(value);
			}

			// plot line
			if (width) {
				path = axis.getPlotLinePath(value, width);
				attribs = {
					stroke: color,
					'stroke-width': width
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
			} else if (isBand) { // plot band

				path = axis.getPlotBandPath(from, to, options);
				if (color) {
					attribs.fill = color;
				}
				if (options.borderWidth) {
					attribs.stroke = options.borderColor;
					attribs['stroke-width'] = options.borderWidth;
				}
			} else {
				return;
			}
			// zIndex
			if (defined(zIndex)) {
				attribs.zIndex = zIndex;
			}

			// common for lines and bands
			if (svgElem) {
				if (path) {
					svgElem.animate({
						d: path
					}, null, svgElem.onGetPath);
				} else {
					svgElem.hide();
					svgElem.onGetPath = function () {
						svgElem.show();
					};
					if (label) {
						plotLine.label = label = label.destroy();
					}
				}
			} else if (path && path.length) {
				plotLine.svgElem = svgElem = renderer.path(path)
					.attr(attribs).add();

				// events
				if (events) {
					addEvent = function (eventType) {
						svgElem.on(eventType, function (e) {
							events[eventType].apply(plotLine, [e]);
						});
					};
					for (eventType in events) {
						addEvent(eventType);
					}
				}
			}

			// the plot band/line label
			if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
				// apply defaults
				optionsLabel = merge({
					align: horiz && isBand && 'center',
					x: horiz ? !isBand && 4 : 10,
					verticalAlign : !horiz && isBand && 'middle',
					y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
					rotation: horiz && !isBand && 90
				}, optionsLabel);

				// add the SVG element
				if (!label) {
					attribs = {
						align: optionsLabel.textAlign || optionsLabel.align,
						rotation: optionsLabel.rotation
					};
					if (defined(zIndex)) {
						attribs.zIndex = zIndex;
					}
					plotLine.label = label = renderer.text(
							optionsLabel.text,
							0,
							0,
							optionsLabel.useHTML
						)
						.attr(attribs)
						.css(optionsLabel.style)
						.add();
				}

				// get the bounding box and align the label
				// #3000 changed to better handle choice between plotband or plotline
				xs = [path[1], path[4], (isBand ? path[6] : path[1])];
				ys = [path[2], path[5], (isBand ? path[7] : path[2])];
				x = arrayMin(xs);
				y = arrayMin(ys);

				label.align(optionsLabel, false, {
					x: x,
					y: y,
					width: arrayMax(xs) - x,
					height: arrayMax(ys) - y
				});
				label.show();

			} else if (label) { // move out of sight
				label.hide();
			}

			// chainable
			return plotLine;
		},

		/**
		 * Remove the plot line or band
		 */
		destroy: function () {
			// remove it from the lookup
			erase(this.axis.plotLinesAndBands, this);
			
			delete this.axis;
			destroyObjectProperties(this);
		}
	};

	/**
	 * Object with members for extending the Axis prototype
	 */

	AxisPlotLineOrBandExtension = {

		/**
		 * Create the path for a plot band
		 */ 
		getPlotBandPath: function (from, to) {
			var toPath = this.getPlotLinePath(to, null, null, true),
				path = this.getPlotLinePath(from, null, null, true);

			if (path && toPath && path.toString() !== toPath.toString()) { // #3836
				path.push(
					toPath[4],
					toPath[5],
					toPath[1],
					toPath[2]
				);
			} else { // outside the axis area
				path = null;
			}
			
			return path;
		},

		addPlotBand: function (options) {
			return this.addPlotBandOrLine(options, 'plotBands');
		},
		
		addPlotLine: function (options) {
			return this.addPlotBandOrLine(options, 'plotLines');
		},

		/**
		 * Add a plot band or plot line after render time
		 *
		 * @param options {Object} The plotBand or plotLine configuration object
		 */
		addPlotBandOrLine: function (options, coll) {
			var obj = new Highcharts.PlotLineOrBand(this, options).render(),
				userOptions = this.userOptions;

			if (obj) { // #2189
				// Add it to the user options for exporting and Axis.update
				if (coll) {
					userOptions[coll] = userOptions[coll] || [];
					userOptions[coll].push(options); 
				}
				this.plotLinesAndBands.push(obj); 
			}
			
			return obj;
		},

		/**
		 * Remove a plot band or plot line from the chart by id
		 * @param {Object} id
		 */
		removePlotBandOrLine: function (id) {
			var plotLinesAndBands = this.plotLinesAndBands,
				options = this.options,
				userOptions = this.userOptions,
				i = plotLinesAndBands.length;
			while (i--) {
				if (plotLinesAndBands[i].id === id) {
					plotLinesAndBands[i].destroy();
				}
			}
			each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
				i = arr.length;
				while (i--) {
					if (arr[i].id === id) {
						erase(arr, arr[i]);
					}
				}
			});
		}
	};

	/**
	 * Create a new axis object
	 * @param {Object} chart
	 * @param {Object} options
	 */
	var Axis = Highcharts.Axis = function () {
		this.init.apply(this, arguments);
	};

	Axis.prototype = {

		/**
		 * Default options for the X axis - the Y axis has extended defaults
		 */
		defaultOptions: {
			// allowDecimals: null,
			// alternateGridColor: null,
			// categories: [],
			dateTimeLabelFormats: {
				millisecond: '%H:%M:%S.%L',
				second: '%H:%M:%S',
				minute: '%H:%M',
				hour: '%H:%M',
				day: '%e. %b',
				week: '%e. %b',
				month: '%b \'%y',
				year: '%Y'
			},
			endOnTick: false,
			gridLineColor: '#D8D8D8',
			// gridLineDashStyle: 'solid',
			// gridLineWidth: 0,
			// reversed: false,

			labels: {
				enabled: true,
				// rotation: 0,
				// align: 'center',
				// step: null,
				style: {
					color: '#606060',
					cursor: 'default',
					fontSize: '11px'
				},
				x: 0,
				y: 15
				/*formatter: function () {
					return this.value;
				},*/
			},
			lineColor: '#C0D0E0',
			lineWidth: 1,
			//linkedTo: null,
			//max: undefined,
			//min: undefined,
			minPadding: 0.01,
			maxPadding: 0.01,
			//minRange: null,
			minorGridLineColor: '#E0E0E0',
			// minorGridLineDashStyle: null,
			minorGridLineWidth: 1,
			minorTickColor: '#A0A0A0',
			//minorTickInterval: null,
			minorTickLength: 2,
			minorTickPosition: 'outside', // inside or outside
			//minorTickWidth: 0,
			//opposite: false,
			//offset: 0,
			//plotBands: [{
			//	events: {},
			//	zIndex: 1,
			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
			//}],
			//plotLines: [{
			//	events: {}
			//  dashStyle: {}
			//	zIndex:
			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
			//}],
			//reversed: false,
			// showFirstLabel: true,
			// showLastLabel: true,
			startOfWeek: 1,
			startOnTick: false,
			tickColor: '#C0D0E0',
			//tickInterval: null,
			tickLength: 10,
			tickmarkPlacement: 'between', // on or between
			tickPixelInterval: 100,
			tickPosition: 'outside',
			tickWidth: 1,
			title: {
				//text: null,
				align: 'middle', // low, middle or high
				//margin: 0 for horizontal, 10 for vertical axes,
				//rotation: 0,
				//side: 'outside',
				style: {
					color: '#707070'
				}
				//x: 0,
				//y: 0
			},
			type: 'linear' // linear, logarithmic or datetime
		},

		/**
		 * This options set extends the defaultOptions for Y axes
		 */
		defaultYAxisOptions: {
			endOnTick: true,
			gridLineWidth: 1,
			tickPixelInterval: 72,
			showLastLabel: true,
			labels: {
				x: -8,
				y: 3
			},
			lineWidth: 0,
			maxPadding: 0.05,
			minPadding: 0.05,
			startOnTick: true,
			tickWidth: 0,
			title: {
				rotation: 270,
				text: 'Values'
			},
			stackLabels: {
				enabled: false,
				//align: dynamic,
				//y: dynamic,
				//x: dynamic,
				//verticalAlign: dynamic,
				//textAlign: dynamic,
				//rotation: 0,
				formatter: function () {
					return Highcharts.numberFormat(this.total, -1);
				},
				style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
			}
		},

		/**
		 * These options extend the defaultOptions for left axes
		 */
		defaultLeftAxisOptions: {
			labels: {
				x: -15,
				y: null
			},
			title: {
				rotation: 270
			}
		},

		/**
		 * These options extend the defaultOptions for right axes
		 */
		defaultRightAxisOptions: {
			labels: {
				x: 15,
				y: null
			},
			title: {
				rotation: 90
			}
		},

		/**
		 * These options extend the defaultOptions for bottom axes
		 */
		defaultBottomAxisOptions: {
			labels: {
				autoRotation: [-45],
				x: 0,
				y: null // based on font size
				// overflow: undefined,
				// staggerLines: null
			},
			title: {
				rotation: 0
			}
		},
		/**
		 * These options extend the defaultOptions for top axes
		 */
		defaultTopAxisOptions: {
			labels: {
				autoRotation: [-45],
				x: 0,
				y: -15
				// overflow: undefined
				// staggerLines: null
			},
			title: {
				rotation: 0
			}
		},

		/**
		 * Initialize the axis
		 */
		init: function (chart, userOptions) {


			var isXAxis = userOptions.isX,
				axis = this;

			// Flag, is the axis horizontal
			axis.horiz = chart.inverted ? !isXAxis : isXAxis;

			// Flag, isXAxis
			axis.isXAxis = isXAxis;
			axis.coll = isXAxis ? 'xAxis' : 'yAxis';

			axis.opposite = userOptions.opposite; // needed in setOptions
			axis.side = userOptions.side || (axis.horiz ?
					(axis.opposite ? 0 : 2) : // top : bottom
					(axis.opposite ? 1 : 3));  // right : left

			axis.setOptions(userOptions);


			var options = this.options,
				type = options.type,
				isDatetimeAxis = type === 'datetime';

			axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


			// Flag, stagger lines or not
			axis.userOptions = userOptions;

			//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
			axis.minPixelPadding = 0;
			//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series
			//axis.ignoreMaxPadding = UNDEFINED;

			axis.chart = chart;
			axis.reversed = options.reversed;
			axis.zoomEnabled = options.zoomEnabled !== false;

			// Initial categories
			axis.categories = options.categories || type === 'category';
			axis.names = axis.names || []; // Preserve on update (#3830)

			// Elements
			//axis.axisGroup = UNDEFINED;
			//axis.gridGroup = UNDEFINED;
			//axis.axisTitle = UNDEFINED;
			//axis.axisLine = UNDEFINED;

			// Shorthand types
			axis.isLog = type === 'logarithmic';
			axis.isDatetimeAxis = isDatetimeAxis;

			// Flag, if axis is linked to another axis
			axis.isLinked = defined(options.linkedTo);
			// Linked axis.
			//axis.linkedParent = UNDEFINED;

			// Tick positions
			//axis.tickPositions = UNDEFINED; // array containing predefined positions
			// Tick intervals
			//axis.tickInterval = UNDEFINED;
			//axis.minorTickInterval = UNDEFINED;

			
			// Major ticks
			axis.ticks = {};
			axis.labelEdge = [];
			// Minor ticks
			axis.minorTicks = {};

			// List of plotLines/Bands
			axis.plotLinesAndBands = [];

			// Alternate bands
			axis.alternateBands = {};

			// Axis metrics
			//axis.left = UNDEFINED;
			//axis.top = UNDEFINED;
			//axis.width = UNDEFINED;
			//axis.height = UNDEFINED;
			//axis.bottom = UNDEFINED;
			//axis.right = UNDEFINED;
			//axis.transA = UNDEFINED;
			//axis.transB = UNDEFINED;
			//axis.oldTransA = UNDEFINED;
			axis.len = 0;
			//axis.oldMin = UNDEFINED;
			//axis.oldMax = UNDEFINED;
			//axis.oldUserMin = UNDEFINED;
			//axis.oldUserMax = UNDEFINED;
			//axis.oldAxisLength = UNDEFINED;
			axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
			axis.range = options.range;
			axis.offset = options.offset || 0;


			// Dictionary for stacks
			axis.stacks = {};
			axis.oldStacks = {};
			
			// Min and max in the data
			//axis.dataMin = UNDEFINED,
			//axis.dataMax = UNDEFINED,

			// The axis range
			axis.max = null;
			axis.min = null;

			// User set min and max
			//axis.userMin = UNDEFINED,
			//axis.userMax = UNDEFINED,

			// Crosshair options
			axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
			// Run Axis

			var eventType,
				events = axis.options.events;

			// Register
			if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
				if (isXAxis && !this.isColorAxis) { // #2713
					chart.axes.splice(chart.xAxis.length, 0, axis);
				} else {
					chart.axes.push(axis);
				}

				chart[axis.coll].push(axis);
			}

			axis.series = axis.series || []; // populated by Series

			// inverted charts have reversed xAxes as default
			if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
				axis.reversed = true;
			}

			axis.removePlotBand = axis.removePlotBandOrLine;
			axis.removePlotLine = axis.removePlotBandOrLine;


			// register event listeners
			for (eventType in events) {
				addEvent(axis, eventType, events[eventType]);
			}

			// extend logarithmic axis
			if (axis.isLog) {
				axis.val2lin = log2lin;
				axis.lin2val = lin2log;
			}
		},

		/**
		 * Merge and set options
		 */
		setOptions: function (userOptions) {
			this.options = merge(
				this.defaultOptions,
				this.isXAxis ? {} : this.defaultYAxisOptions,
				[this.defaultTopAxisOptions, this.defaultRightAxisOptions,
					this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
				merge(
					defaultOptions[this.coll], // if set in setOptions (#1053)
					userOptions
				)
			);
		},

		/**
		 * The default label formatter. The context is a special config object for the label.
		 */
		defaultLabelFormatter: function () {
			var axis = this.axis,
				value = this.value,
				categories = axis.categories,
				dateTimeLabelFormat = this.dateTimeLabelFormat,
				numericSymbols = defaultOptions.lang.numericSymbols,
				i = numericSymbols && numericSymbols.length,
				multi,
				ret,
				formatOption = axis.options.labels.format,

				// make sure the same symbol is added for all labels on a linear axis
				numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

			if (formatOption) {
				ret = format(formatOption, this);

			} else if (categories) {
				ret = value;

			} else if (dateTimeLabelFormat) { // datetime axis
				ret = dateFormat(dateTimeLabelFormat, value);

			} else if (i && numericSymbolDetector >= 1000) {
				// Decide whether we should add a numeric symbol like k (thousands) or M (millions).
				// If we are to enable this in tooltip or other places as well, we can move this
				// logic to the numberFormatter and enable it by a parameter.
				while (i-- && ret === UNDEFINED) {
					multi = Math.pow(1000, i + 1);
					if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {
						ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
					}
				}
			}

			if (ret === UNDEFINED) {
				if (mathAbs(value) >= 10000) { // add thousands separators
					ret = Highcharts.numberFormat(value, 0);

				} else { // small numbers
					ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
				}
			}

			return ret;
		},

		/**
		 * Get the minimum and maximum for the series of each axis
		 */
		getSeriesExtremes: function () {
			var axis = this,
				chart = axis.chart;

			axis.hasVisibleSeries = false;

			// Reset properties in case we're redrawing (#3353)
			axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;
			
			if (axis.buildStacks) {
				axis.buildStacks();
			}

			// loop through this axis' series
			each(axis.series, function (series) {

				if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

					var seriesOptions = series.options,
						xData,
						threshold = seriesOptions.threshold,
						seriesDataMin,
						seriesDataMax;

					axis.hasVisibleSeries = true;

					// Validate threshold in logarithmic axes
					if (axis.isLog && threshold <= 0) {
						threshold = null;
					}

					// Get dataMin and dataMax for X axes
					if (axis.isXAxis) {
						xData = series.xData;
						if (xData.length) {
							axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
							axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
						}

					// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
					} else {

						// Get this particular series extremes
						series.getExtremes();
						seriesDataMax = series.dataMax;
						seriesDataMin = series.dataMin;

						// Get the dataMin and dataMax so far. If percentage is used, the min and max are
						// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
						// doesn't have active y data, we continue with nulls
						if (defined(seriesDataMin) && defined(seriesDataMax)) {
							axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
							axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
						}

						// Adjust to threshold
						if (defined(threshold)) {
							if (axis.dataMin >= threshold) {
								axis.dataMin = threshold;
								axis.ignoreMinPadding = true;
							} else if (axis.dataMax < threshold) {
								axis.dataMax = threshold;
								axis.ignoreMaxPadding = true;
							}
						}
					}
				}
			});
		},

		/**
		 * Translate from axis value to pixel position on the chart, or back
		 *
		 */
		translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
			var axis = this,
				sign = 1,
				cvsOffset = 0,
				localA = old ? axis.oldTransA : axis.transA,
				localMin = old ? axis.oldMin : axis.min,
				returnValue,
				minPixelPadding = axis.minPixelPadding,
				doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;

			if (!localA) {
				localA = axis.transA;
			}

			// In vertical axes, the canvas coordinates start from 0 at the top like in
			// SVG.
			if (cvsCoord) {
				sign *= -1; // canvas coordinates inverts the value
				cvsOffset = axis.len;
			}

			// Handle reversed axis
			if (axis.reversed) {
				sign *= -1;
				cvsOffset -= sign * (axis.sector || axis.len);
			}

			// From pixels to value
			if (backwards) { // reverse translation

				val = val * sign + cvsOffset;
				val -= minPixelPadding;
				returnValue = val / localA + localMin; // from chart pixel to value
				if (doPostTranslate) { // log and ordinal axes
					returnValue = axis.lin2val(returnValue);
				}

			// From value to pixels
			} else {
				if (doPostTranslate) { // log and ordinal axes
					val = axis.val2lin(val);
				}
				if (pointPlacement === 'between') {
					pointPlacement = 0.5;
				}
				returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
					(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
			}

			return returnValue;
		},

		/**
		 * Utility method to translate an axis value to pixel position.
		 * @param {Number} value A value in terms of axis units
		 * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
		 *        or just the axis/pane itself.
		 */
		toPixels: function (value, paneCoordinates) {
			return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
		},

		/*
		 * Utility method to translate a pixel position in to an axis value
		 * @param {Number} pixel The pixel value coordinate
		 * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
		 *        axis/pane itself.
		 */
		toValue: function (pixel, paneCoordinates) {
			return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
		},

		/**
		 * Create the path for a plot line that goes from the given value on
		 * this axis, across the plot to the opposite side
		 * @param {Number} value
		 * @param {Number} lineWidth Used for calculation crisp line
		 * @param {Number] old Use old coordinates (for resizing and rescaling)
		 */
		getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
			var axis = this,
				chart = axis.chart,
				axisLeft = axis.left,
				axisTop = axis.top,
				x1,
				y1,
				x2,
				y2,
				cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
				cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
				skip,
				transB = axis.transB,
				/**
				 * Check if x is between a and b. If not, either move to a/b or skip, 
				 * depending on the force parameter.
				 */
				between = function (x, a, b) {
					if (x < a || x > b) {
						if (force) {
							x = mathMin(mathMax(a, x), b);
						} else {
							skip = true;
						}
					}
					return x;
				};

			translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
			x1 = x2 = mathRound(translatedValue + transB);
			y1 = y2 = mathRound(cHeight - translatedValue - transB);

			if (isNaN(translatedValue)) { // no min or max
				skip = true;

			} else if (axis.horiz) {
				y1 = axisTop;
				y2 = cHeight - axis.bottom;
				x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
			} else {
				x1 = axisLeft;
				x2 = cWidth - axis.right;
				y1 = y2 = between(y1, axisTop, axisTop + axis.height);
			}
			return skip && !force ?
				null :
				chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
		},

		/**
		 * Set the tick positions of a linear axis to round values like whole tens or every five.
		 */
		getLinearTickPositions: function (tickInterval, min, max) {
			var pos,
				lastPos,
				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
				tickPositions = [];

			// For single points, add a tick regardless of the relative position (#2662)
			if (min === max && isNumber(min)) {
				return [min];
			}

			// Populate the intermediate values
			pos = roundedMin;
			while (pos <= roundedMax) {

				// Place the tick on the rounded value
				tickPositions.push(pos);

				// Always add the raw tickInterval, not the corrected one.
				pos = correctFloat(pos + tickInterval);

				// If the interval is not big enough in the current min - max range to actually increase
				// the loop variable, we need to break out to prevent endless loop. Issue #619
				if (pos === lastPos) {
					break;
				}

				// Record the last value
				lastPos = pos;
			}
			return tickPositions;
		},

		/**
		 * Return the minor tick positions. For logarithmic axes, reuse the same logic
		 * as for major ticks.
		 */
		getMinorTickPositions: function () {
			var axis = this,
				options = axis.options,
				tickPositions = axis.tickPositions,
				minorTickInterval = axis.minorTickInterval,
				minorTickPositions = [],
				pos,
				i,
				min = axis.min,
				max = axis.max,
				range = max - min,
				len;

			// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
			if (range && range / minorTickInterval < axis.len / 3) { // #3875

				if (axis.isLog) {
					len = tickPositions.length;
					for (i = 1; i < len; i++) {
						minorTickPositions = minorTickPositions.concat(
							axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
						);
					}
				} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
					minorTickPositions = minorTickPositions.concat(
						axis.getTimeTicks(
							axis.normalizeTimeTickInterval(minorTickInterval),
							min,
							max,
							options.startOfWeek
						)
					);
				} else {
					for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
						minorTickPositions.push(pos);
					}
				}
			}

			axis.trimTicks(minorTickPositions); // #3652 #3743
			return minorTickPositions;
		},

		/**
		 * Adjust the min and max for the minimum range. Keep in mind that the series data is
		 * not yet processed, so we don't have information on data cropping and grouping, or
		 * updated axis.pointRange or series.pointRange. The data can't be processed until
		 * we have finally established min and max.
		 */
		adjustForMinRange: function () {
			var axis = this,
				options = axis.options,
				min = axis.min,
				max = axis.max,
				zoomOffset,
				spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
				closestDataRange,
				i,
				distance,
				xData,
				loopLength,
				minArgs,
				maxArgs;

			// Set the automatic minimum range based on the closest point distance
			if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

				if (defined(options.min) || defined(options.max)) {
					axis.minRange = null; // don't do this again

				} else {

					// Find the closest distance between raw data points, as opposed to
					// closestPointRange that applies to processed points (cropped and grouped)
					each(axis.series, function (series) {
						xData = series.xData;
						loopLength = series.xIncrement ? 1 : xData.length - 1;
						for (i = loopLength; i > 0; i--) {
							distance = xData[i] - xData[i - 1];
							if (closestDataRange === UNDEFINED || distance < closestDataRange) {
								closestDataRange = distance;
							}
						}
					});
					axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
				}
			}

			// if minRange is exceeded, adjust
			if (max - min < axis.minRange) {
				var minRange = axis.minRange;
				zoomOffset = (minRange - max + min) / 2;

				// if min and max options have been set, don't go beyond it
				minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
				if (spaceAvailable) { // if space is available, stay within the data range
					minArgs[2] = axis.dataMin;
				}
				min = arrayMax(minArgs);

				maxArgs = [min + minRange, pick(options.max, min + minRange)];
				if (spaceAvailable) { // if space is availabe, stay within the data range
					maxArgs[2] = axis.dataMax;
				}

				max = arrayMin(maxArgs);

				// now if the max is adjusted, adjust the min back
				if (max - min < minRange) {
					minArgs[0] = max - minRange;
					minArgs[1] = pick(options.min, max - minRange);
					min = arrayMax(minArgs);
				}
			}

			// Record modified extremes
			axis.min = min;
			axis.max = max;
		},

		/**
		 * Update translation information
		 */
		setAxisTranslation: function (saveOld) {
			var axis = this,
				range = axis.max - axis.min,
				pointRange = axis.axisPointRange || 0,
				closestPointRange,
				minPointOffset = 0,
				pointRangePadding = 0,
				linkedParent = axis.linkedParent,
				ordinalCorrection,
				hasCategories = !!axis.categories,
				transA = axis.transA,
				isXAxis = axis.isXAxis;

			// Adjust translation for padding. Y axis with categories need to go through the same (#1784).
			if (isXAxis || hasCategories || pointRange) {
				if (linkedParent) {
					minPointOffset = linkedParent.minPointOffset;
					pointRangePadding = linkedParent.pointRangePadding;

				} else {
					each(axis.series, function (series) {
						var seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806
							pointPlacement = series.options.pointPlacement,
							seriesClosestPointRange = series.closestPointRange;

						if (seriesPointRange > range) { // #1446
							seriesPointRange = 0;
						}
						pointRange = mathMax(pointRange, seriesPointRange);

						if (!axis.single) {
							// minPointOffset is the value padding to the left of the axis in order to make
							// room for points with a pointRange, typically columns. When the pointPlacement option
							// is 'between' or 'on', this padding does not apply.
							minPointOffset = mathMax(
								minPointOffset,
								isString(pointPlacement) ? 0 : seriesPointRange / 2
							);

							// Determine the total padding needed to the length of the axis to make room for the
							// pointRange. If the series' pointPlacement is 'on', no padding is added.
							pointRangePadding = mathMax(
								pointRangePadding,
								pointPlacement === 'on' ? 0 : seriesPointRange
							);
						}

						// Set the closestPointRange
						if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
							closestPointRange = defined(closestPointRange) ?
								mathMin(closestPointRange, seriesClosestPointRange) :
								seriesClosestPointRange;
						}
					});
				}

				// Record minPointOffset and pointRangePadding
				ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
				axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
				axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

				// pointRange means the width reserved for each point, like in a column chart
				axis.pointRange = mathMin(pointRange, range);

				// closestPointRange means the closest distance between points. In columns
				// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
				// is some other value
				if (isXAxis) {
					axis.closestPointRange = closestPointRange;
				}
			}

			// Secondary values
			if (saveOld) {
				axis.oldTransA = transA;
			}
			axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
			axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
			axis.minPixelPadding = transA * minPointOffset;
		},

		/**
		 * Set the tick positions to round values and optionally extend the extremes
		 * to the nearest tick
		 */
		setTickInterval: function (secondPass) {
			var axis = this,
				chart = axis.chart,
				options = axis.options,
				isLog = axis.isLog,
				isDatetimeAxis = axis.isDatetimeAxis,
				isXAxis = axis.isXAxis,
				isLinked = axis.isLinked,
				maxPadding = options.maxPadding,
				minPadding = options.minPadding,
				length,
				linkedParentExtremes,
				tickIntervalOption = options.tickInterval,
				minTickInterval,
				tickPixelIntervalOption = options.tickPixelInterval,
				categories = axis.categories;

			if (!isDatetimeAxis && !categories && !isLinked) {
				this.getTickAmount();
			}

			// linked axis gets the extremes from the parent axis
			if (isLinked) {
				axis.linkedParent = chart[axis.coll][options.linkedTo];
				linkedParentExtremes = axis.linkedParent.getExtremes();
				axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
				axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
				if (options.type !== axis.linkedParent.options.type) {
					error(11, 1); // Can't link axes of different type
				}
			} else { // initial min and max from the extreme data values
				axis.min = pick(axis.userMin, options.min, axis.dataMin);
				axis.max = pick(axis.userMax, options.max, axis.dataMax);
			}

			if (isLog) {
				if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
					error(10, 1); // Can't plot negative values on log axis
				}
				axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934
				axis.max = correctFloat(log2lin(axis.max));
			}

			// handle zoomed range
			if (axis.range && defined(axis.max)) {
				axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618
				axis.userMax = axis.max;

				axis.range = null;  // don't use it when running setExtremes
			}

			// Hook for adjusting this.min and this.max. Used by bubble series.
			if (axis.beforePadding) {
				axis.beforePadding();
			}

			// adjust min and max for the minimum range
			axis.adjustForMinRange();

			// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
			// into account, we do this after computing tick interval (#1337).
			if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
				length = axis.max - axis.min;
				if (length) {
					if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
						axis.min -= length * minPadding;
					}
					if (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
						axis.max += length * maxPadding;
					}
				}
			}

			// Stay within floor and ceiling
			if (isNumber(options.floor)) {
				axis.min = mathMax(axis.min, options.floor);
			}
			if (isNumber(options.ceiling)) {
				axis.max = mathMin(axis.max, options.ceiling);
			}

			// get tickInterval
			if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
				axis.tickInterval = 1;
			} else if (isLinked && !tickIntervalOption &&
					tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
				axis.tickInterval = axis.linkedParent.tickInterval;
			} else {
				axis.tickInterval = pick(
					tickIntervalOption,
					this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
					categories ? // for categoried axis, 1 is default, for linear axis use tickPix
						1 :
						// don't let it be more than the data range
						(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
				);
			}

			// Now we're finished detecting min and max, crop and group series data. This
			// is in turn needed in order to find tick positions in ordinal axes.
			if (isXAxis && !secondPass) {
				each(axis.series, function (series) {
					series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
				});
			}

			// set the translation factor used in translate function
			axis.setAxisTranslation(true);

			// hook for ordinal axes and radial axes
			if (axis.beforeSetTickPositions) {
				axis.beforeSetTickPositions();
			}

			// hook for extensions, used in Highstock ordinal axes
			if (axis.postProcessTickInterval) {
				axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
			}

			// In column-like charts, don't cramp in more ticks than there are points (#1943)
			if (axis.pointRange) {
				axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
			}

			// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
			minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
			if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
				axis.tickInterval = minTickInterval;
			}

			// for linear axes, get magnitude and normalize the interval
			if (!isDatetimeAxis && !isLog) { // linear
				if (!tickIntervalOption) {
					axis.tickInterval = normalizeTickInterval(
						axis.tickInterval, 
						null, 
						getMagnitude(axis.tickInterval), 
						// If the tick interval is between 0.5 and 5 and the axis max is in the order of
						// thousands, chances are we are dealing with years. Don't allow decimals. #3363.
						pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
						!!this.tickAmount
					);
				}
			}

			// Prevent ticks from getting so close that we can't draw the labels
			if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
				axis.tickInterval = axis.unsquish();
			}

			this.setTickPositions();
		},

		/**
		 * Now we have computed the normalized tickInterval, get the tick positions
		 */
		setTickPositions: function () {

			var options = this.options,
				tickPositions,
				tickPositionsOption = options.tickPositions,
				tickPositioner = options.tickPositioner,
				startOnTick = options.startOnTick,
				endOnTick = options.endOnTick,
				single;

			// Set the tickmarkOffset
			this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && 
				this.tickInterval === 1) ? 0.5 : 0; // #3202


			// get minorTickInterval
			this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
				this.tickInterval / 5 : options.minorTickInterval;

			// Find the tick positions
			this.tickPositions = tickPositions = options.tickPositions && options.tickPositions.slice(); // Work on a copy (#1565)
			if (!tickPositions) {

				if (this.isDatetimeAxis) {
					tickPositions = this.getTimeTicks(
						this.normalizeTimeTickInterval(this.tickInterval, options.units),
						this.min,
						this.max,
						options.startOfWeek,
						this.ordinalPositions,
						this.closestPointRange,
						true
					);
				} else if (this.isLog) {
					tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
				} else {
					tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
				}

				this.tickPositions = tickPositions;

				// Run the tick positioner callback, that allows modifying auto tick positions.
				if (tickPositioner) {
					tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
					if (tickPositioner) {
						this.tickPositions = tickPositions = tickPositioner;
					}
				}

			}

			if (!this.isLinked) {

				// reset min/max or remove extremes based on start/end on tick
				this.trimTicks(tickPositions, startOnTick, endOnTick);

				// When there is only one point, or all points have the same value on this axis, then min
				// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
				// in order to center the point, but leave it with one tick. #1337.
				if (this.min === this.max && defined(this.min) && !this.tickAmount) {
					// Substract half a unit (#2619, #2846, #2515, #3390)
					single = true;
					this.min -= 0.5;
					this.max += 0.5;
				}
				this.single = single;

				if (!tickPositionsOption && !tickPositioner) {
					this.adjustTickAmount();
				}
			}
		},

		/**
		 * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
		 */
		trimTicks: function (tickPositions, startOnTick, endOnTick) {
			var roundedMin = tickPositions[0],
				roundedMax = tickPositions[tickPositions.length - 1],
				minPointOffset = this.minPointOffset || 0;
				
			if (startOnTick) {
				this.min = roundedMin;
			} else if (this.min - minPointOffset > roundedMin) {
				tickPositions.shift();
			}

			if (endOnTick) {
				this.max = roundedMax;
			} else if (this.max + minPointOffset < roundedMax) {
				tickPositions.pop();
			}

			// If no tick are left, set one tick in the middle (#3195) 
			if (tickPositions.length === 0 && defined(roundedMin)) {
				tickPositions.push((roundedMax + roundedMin) / 2);
			}		
		},

		/**
		 * Set the max ticks of either the x and y axis collection
		 */
		getTickAmount: function () {
			var others = {}, // Whether there is another axis to pair with this one
				hasOther,
				options = this.options,
				tickAmount = options.tickAmount,
				tickPixelInterval = options.tickPixelInterval;

			if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
					!this.isLog && options.startOnTick && options.endOnTick) {
				tickAmount = 2;
			}

			if (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
				// Check if there are multiple axes in the same pane
				each(this.chart[this.coll], function (axis) {
					var options = axis.options,
						horiz = axis.horiz,
						key = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');
					
					if (others[key]) {
						hasOther = true;
					} else {
						others[key] = 1;
					}
				});

				if (hasOther) {
					// Add 1 because 4 tick intervals require 5 ticks (including first and last)
					tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
				}
			}

			// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
			// prevents the axis from adding ticks that are too far away from the data extremes.
			if (tickAmount < 4) {
				this.finalTickAmt = tickAmount;
				tickAmount = 5;
			}
			
			this.tickAmount = tickAmount;
		},

		/**
		 * When using multiple axes, adjust the number of ticks to match the highest
		 * number of ticks in that group
		 */
		adjustTickAmount: function () {
			var tickInterval = this.tickInterval,
				tickPositions = this.tickPositions,
				tickAmount = this.tickAmount,
				finalTickAmt = this.finalTickAmt,
				currentTickAmount = tickPositions && tickPositions.length,
				i,
				len;

			if (currentTickAmount < tickAmount) { // TODO: Check #3411
				while (tickPositions.length < tickAmount) {
					tickPositions.push(correctFloat(
						tickPositions[tickPositions.length - 1] + tickInterval
					));
				}
				this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
				this.max = tickPositions[tickPositions.length - 1];

			// We have too many ticks, run second pass to try to reduce ticks
			} else if (currentTickAmount > tickAmount) {
				this.tickInterval *= 2;
				this.setTickPositions();
			}

			// The finalTickAmt property is set in getTickAmount
			if (defined(finalTickAmt)) {
				i = len = tickPositions.length;
				while (i--) {
					if (
						(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
						(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
					) {
						tickPositions.splice(i, 1);
					}	
				}
				this.finalTickAmt = UNDEFINED;
			}
		},

		/**
		 * Set the scale based on data min and max, user set min and max or options
		 *
		 */
		setScale: function () {
			var axis = this,
				stacks = axis.stacks,
				type,
				i,
				isDirtyData,
				isDirtyAxisLength;

			axis.oldMin = axis.min;
			axis.oldMax = axis.max;
			axis.oldAxisLength = axis.len;

			// set the new axisLength
			axis.setAxisSize();
			//axisLength = horiz ? axisWidth : axisHeight;
			isDirtyAxisLength = axis.len !== axis.oldAxisLength;

			// is there new data?
			each(axis.series, function (series) {
				if (series.isDirtyData || series.isDirty ||
						series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
					isDirtyData = true;
				}
			});

			// do we really need to go through all this?
			if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
				axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {

				// reset stacks
				if (!axis.isXAxis) {
					for (type in stacks) {
						for (i in stacks[type]) {
							stacks[type][i].total = null;
							stacks[type][i].cum = 0;
						}
					}
				}

				axis.forceRedraw = false;

				// get data extremes if needed
				axis.getSeriesExtremes();

				// get fixed positions based on tickInterval
				axis.setTickInterval();

				// record old values to decide whether a rescale is necessary later on (#540)
				axis.oldUserMin = axis.userMin;
				axis.oldUserMax = axis.userMax;

				// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
				if (!axis.isDirty) {
					axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
				}
			} else if (!axis.isXAxis) {
				if (axis.oldStacks) {
					stacks = axis.stacks = axis.oldStacks;
				}

				// reset stacks
				for (type in stacks) {
					for (i in stacks[type]) {
						stacks[type][i].cum = stacks[type][i].total;
					}
				}
			}
		},

		/**
		 * Set the extremes and optionally redraw
		 * @param {Number} newMin
		 * @param {Number} newMax
		 * @param {Boolean} redraw
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 * @param {Object} eventArguments
		 *
		 */
		setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
			var axis = this,
				chart = axis.chart;

			redraw = pick(redraw, true); // defaults to true

			each(axis.series, function (serie) {
				delete serie.kdTree;
			});

			// Extend the arguments with min and max
			eventArguments = extend(eventArguments, {
				min: newMin,
				max: newMax
			});

			// Fire the event
			fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

				axis.userMin = newMin;
				axis.userMax = newMax;
				axis.eventArgs = eventArguments;

				// Mark for running afterSetExtremes
				axis.isDirtyExtremes = true;

				// redraw
				if (redraw) {
					chart.redraw(animation);
				}
			});
		},

		/**
		 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
		 * in stock charts.
		 */
		zoom: function (newMin, newMax) {
			var dataMin = this.dataMin,
				dataMax = this.dataMax,
				options = this.options;

			// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
			if (!this.allowZoomOutside) {
				if (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {
					newMin = UNDEFINED;
				}
				if (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {
					newMax = UNDEFINED;
				}
			}

			// In full view, displaying the reset zoom button is not required
			this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

			// Do it
			this.setExtremes(
				newMin,
				newMax,
				false,
				UNDEFINED,
				{ trigger: 'zoom' }
			);
			return true;
		},

		/**
		 * Update the axis metrics
		 */
		setAxisSize: function () {
			var chart = this.chart,
				options = this.options,
				offsetLeft = options.offsetLeft || 0,
				offsetRight = options.offsetRight || 0,
				horiz = this.horiz,
				width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
				height = pick(options.height, chart.plotHeight),
				top = pick(options.top, chart.plotTop),
				left = pick(options.left, chart.plotLeft + offsetLeft),
				percentRegex = /%$/;

			// Check for percentage based input values
			if (percentRegex.test(height)) {
				height = parseFloat(height) / 100 * chart.plotHeight;
			}
			if (percentRegex.test(top)) {
				top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;
			}

			// Expose basic values to use in Series object and navigator
			this.left = left;
			this.top = top;
			this.width = width;
			this.height = height;
			this.bottom = chart.chartHeight - height - top;
			this.right = chart.chartWidth - width - left;

			// Direction agnostic properties
			this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
			this.pos = horiz ? left : top; // distance from SVG origin
		},

		/**
		 * Get the actual axis extremes
		 */
		getExtremes: function () {
			var axis = this,
				isLog = axis.isLog;

			return {
				min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
				max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
				dataMin: axis.dataMin,
				dataMax: axis.dataMax,
				userMin: axis.userMin,
				userMax: axis.userMax
			};
		},

		/**
		 * Get the zero plane either based on zero or on the min or max value.
		 * Used in bar and area plots
		 */
		getThreshold: function (threshold) {
			var axis = this,
				isLog = axis.isLog;

			var realMin = isLog ? lin2log(axis.min) : axis.min,
				realMax = isLog ? lin2log(axis.max) : axis.max;

			if (realMin > threshold || threshold === null) {
				threshold = realMin;
			} else if (realMax < threshold) {
				threshold = realMax;
			}

			return axis.translate(threshold, 0, 1, 0, 1);
		},

		/**
		 * Compute auto alignment for the axis label based on which side the axis is on
		 * and the given rotation for the label
		 */
		autoLabelAlign: function (rotation) {
			var ret,
				angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

			if (angle > 15 && angle < 165) {
				ret = 'right';
			} else if (angle > 195 && angle < 345) {
				ret = 'left';
			} else {
				ret = 'center';
			}
			return ret;
		},

		/**
		 * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
		 * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. 
		 * On a vertical axis remove ticks and add ellipsis.
		 */
		unsquish: function () {
			var chart = this.chart,
				ticks = this.ticks,
				labelOptions = this.options.labels,
				horiz = this.horiz,
				tickInterval = this.tickInterval,
				newTickInterval = tickInterval,
				slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
				rotation,
				rotationOption = labelOptions.rotation,
				labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
				step,
				bestScore = Number.MAX_VALUE,
				autoRotation,
				// Return the multiple of tickInterval that is needed to avoid collision
				getStep = function (spaceNeeded) {
					var step = spaceNeeded / (slotSize || 1);
					step = step > 1 ? mathCeil(step) : 1;
					return step * tickInterval;
				};
			
			if (horiz) {
				autoRotation = defined(rotationOption) ? 
					[rotationOption] :
					slotSize < 80 && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;

				if (autoRotation) {

					// Loop over the given autoRotation options, and determine which gives the best score. The 
					// best score is that with the lowest number of steps and a rotation closest to horizontal.
					each(autoRotation, function (rot) {
						var score;

						if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891
						
							step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

							score = step + mathAbs(rot / 360);

							if (score < bestScore) {
								bestScore = score;
								rotation = rot;
								newTickInterval = step;
							}
						}
					});
				}

			} else {
				newTickInterval = getStep(labelMetrics.h);
			}

			this.autoRotation = autoRotation;
			this.labelRotation = rotation;

			return newTickInterval;
		},

		renderUnsquish: function () {
			var chart = this.chart,
				renderer = chart.renderer,
				tickPositions = this.tickPositions,
				ticks = this.ticks,
				labelOptions = this.options.labels,
				horiz = this.horiz,
				margin = chart.margin,
				slotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&
					((this.staggerLines || 1) * chart.plotWidth) / tickPositions.length) ||
					(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,
				innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
				attr = {},
				labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
				css,
				labelLength = 0,
				label,
				i,
				pos;

			// Set rotation option unless it is "auto", like in gauges
			if (!isString(labelOptions.rotation)) {
				attr.rotation = labelOptions.rotation;
			}
			
			// Handle auto rotation on horizontal axis
			if (this.autoRotation) {

				// Get the longest label length
				each(tickPositions, function (tick) {
					tick = ticks[tick];
					if (tick && tick.labelLength > labelLength) {
						labelLength = tick.labelLength;
					}
				});
				
				// Apply rotation only if the label is too wide for the slot, and
				// the label is wider than its height.
				if (labelLength > innerWidth && labelLength > labelMetrics.h) {
					attr.rotation = this.labelRotation;
				} else {
					this.labelRotation = 0;
				}

			// Handle word-wrap or ellipsis on vertical axis
			} else if (slotWidth) {
				// For word-wrap or ellipsis
				css = { width: innerWidth + PX, textOverflow: 'clip' };

				// On vertical axis, only allow word wrap if there is room for more lines.
				i = tickPositions.length;
				while (!horiz && i--) {
					pos = tickPositions[i];
					label = ticks[pos].label;
					if (label) {
						if (this.len / tickPositions.length - 4 < label.getBBox().height) {
							label.specCss = { textOverflow: 'ellipsis' };
						}
					}
				}
			}


			// Add ellipsis if the label length is significantly longer than ideal
			if (attr.rotation) {
				css = { 
					width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX,
					textOverflow: 'ellipsis'
				};
			}

			// Set the explicit or automatic label alignment
			this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);

			// Apply general and specific CSS
			each(tickPositions, function (pos) {
				var tick = ticks[pos],
					label = tick && tick.label;
				if (label) {
					if (css) {
						label.css(merge(css, label.specCss));
					}
					delete label.specCss;
					label.attr(attr);
					tick.rotation = attr.rotation;
				}
			});

			// TODO: Why not part of getLabelPosition?
			this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);
		},

		/**
		 * Render the tick labels to a preliminary position to get their sizes
		 */
		getOffset: function () {
			var axis = this,
				chart = axis.chart,
				renderer = chart.renderer,
				options = axis.options,
				tickPositions = axis.tickPositions,
				ticks = axis.ticks,
				horiz = axis.horiz,
				side = axis.side,
				invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
				hasData,
				showAxis,
				titleOffset = 0,
				titleOffsetOption,
				titleMargin = 0,
				axisTitleOptions = options.title,
				labelOptions = options.labels,
				labelOffset = 0, // reset
				labelOffsetPadded,
				axisOffset = chart.axisOffset,
				clipOffset = chart.clipOffset,
				directionFactor = [-1, 1, 1, -1][side],
				n,
				lineHeightCorrection;

			// For reuse in Axis.render
			axis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) && defined(axis.max) && !!tickPositions));
			axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

			// Set/reset staggerLines
			axis.staggerLines = axis.horiz && labelOptions.staggerLines;

			// Create the axisGroup and gridGroup elements on first iteration
			if (!axis.axisGroup) {
				axis.gridGroup = renderer.g('grid')
					.attr({ zIndex: options.gridZIndex || 1 })
					.add();
				axis.axisGroup = renderer.g('axis')
					.attr({ zIndex: options.zIndex || 2 })
					.add();
				axis.labelGroup = renderer.g('axis-labels')
					.attr({ zIndex: labelOptions.zIndex || 7 })
					.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
					.add();
			}

			if (hasData || axis.isLinked) {
				
				// Generate ticks
				each(tickPositions, function (pos) {
					if (!ticks[pos]) {
						ticks[pos] = new Tick(axis, pos);
					} else {
						ticks[pos].addLabel(); // update labels depending on tick interval
					}
				});

				axis.renderUnsquish();

				each(tickPositions, function (pos) {
					// left side must be align: right and right side must have align: left for labels
					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {

						// get the highest offset
						labelOffset = mathMax(
							ticks[pos].getLabelSize(),
							labelOffset
						);
					}
				});

				if (axis.staggerLines) {
					labelOffset *= axis.staggerLines;
					axis.labelOffset = labelOffset;
				}


			} else { // doesn't have data
				for (n in ticks) {
					ticks[n].destroy();
					delete ticks[n];
				}
			}

			if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
				if (!axis.axisTitle) {
					axis.axisTitle = renderer.text(
						axisTitleOptions.text,
						0,
						0,
						axisTitleOptions.useHTML
					)
					.attr({
						zIndex: 7,
						rotation: axisTitleOptions.rotation || 0,
						align:
							axisTitleOptions.textAlign ||
							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
					})
					.addClass(PREFIX + this.coll.toLowerCase() + '-title')
					.css(axisTitleOptions.style)
					.add(axis.axisGroup);
					axis.axisTitle.isNew = true;
				}

				if (showAxis) {
					titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
					titleOffsetOption = axisTitleOptions.offset;
					titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
				}

				// hide or show the title depending on whether showEmpty is set
				axis.axisTitle[showAxis ? 'show' : 'hide']();
			}

			// handle automatic or user set offset
			axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

			axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
			lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;
			labelOffsetPadded = labelOffset + titleMargin +
				(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));
			axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

			axisOffset[side] = mathMax(
				axisOffset[side],
				axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
				labelOffsetPadded // #3027
			);
			clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);
		},

		/**
		 * Get the path for the axis line
		 */
		getLinePath: function (lineWidth) {
			var chart = this.chart,
				opposite = this.opposite,
				offset = this.offset,
				horiz = this.horiz,
				lineLeft = this.left + (opposite ? this.width : 0) + offset,
				lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

			if (opposite) {
				lineWidth *= -1; // crispify the other way - #1480, #1687
			}

			return chart.renderer.crispLine([
					M,
					horiz ?
						this.left :
						lineLeft,
					horiz ?
						lineTop :
						this.top,
					L,
					horiz ?
						chart.chartWidth - this.right :
						lineLeft,
					horiz ?
						lineTop :
						chart.chartHeight - this.bottom
				], lineWidth);
		},

		/**
		 * Position the title
		 */
		getTitlePosition: function () {
			// compute anchor points for each of the title align options
			var horiz = this.horiz,
				axisLeft = this.left,
				axisTop = this.top,
				axisLength = this.len,
				axisTitleOptions = this.options.title,
				margin = horiz ? axisLeft : axisTop,
				opposite = this.opposite,
				offset = this.offset,
				fontSize = pInt(axisTitleOptions.style.fontSize || 12),

				// the position in the length direction of the axis
				alongAxis = {
					low: margin + (horiz ? 0 : axisLength),
					middle: margin + axisLength / 2,
					high: margin + (horiz ? axisLength : 0)
				}[axisTitleOptions.align],

				// the position in the perpendicular direction of the axis
				offAxis = (horiz ? axisTop + this.height : axisLeft) +
					(horiz ? 1 : -1) * // horizontal axis reverses the margin
					(opposite ? -1 : 1) * // so does opposite axes
					this.axisTitleMargin +
					(this.side === 2 ? fontSize : 0);

			return {
				x: horiz ?
					alongAxis :
					offAxis + (opposite ? this.width : 0) + offset +
						(axisTitleOptions.x || 0), // x
				y: horiz ?
					offAxis - (opposite ? this.height : 0) + offset :
					alongAxis + (axisTitleOptions.y || 0) // y
			};
		},

		/**
		 * Render the axis
		 */
		render: function () {
			var axis = this,
				chart = axis.chart,
				renderer = chart.renderer,
				options = axis.options,
				isLog = axis.isLog,
				isLinked = axis.isLinked,
				tickPositions = axis.tickPositions,
				axisTitle = axis.axisTitle,			
				ticks = axis.ticks,
				minorTicks = axis.minorTicks,
				alternateBands = axis.alternateBands,
				stackLabelOptions = options.stackLabels,
				alternateGridColor = options.alternateGridColor,
				tickmarkOffset = axis.tickmarkOffset,
				lineWidth = options.lineWidth,
				linePath,
				hasRendered = chart.hasRendered,
				slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
				hasData = axis.hasData,
				showAxis = axis.showAxis,
				from,
				to;

			// Reset
			axis.labelEdge.length = 0;
			//axis.justifyToPlot = overflow === 'justify';
			axis.overlap = false;

			// Mark all elements inActive before we go over and mark the active ones
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos;
				for (pos in coll) {
					coll[pos].isActive = false;
				}
			});

			// If the series has data draw the ticks. Else only the line and title
			if (hasData || isLinked) {

				// minor ticks
				if (axis.minorTickInterval && !axis.categories) {
					each(axis.getMinorTickPositions(), function (pos) {
						if (!minorTicks[pos]) {
							minorTicks[pos] = new Tick(axis, pos, 'minor');
						}

						// render new ticks in old position
						if (slideInTicks && minorTicks[pos].isNew) {
							minorTicks[pos].render(null, true);
						}

						minorTicks[pos].render(null, false, 1);
					});
				}

				// Major ticks. Pull out the first item and render it last so that
				// we can get the position of the neighbour label. #808.
				if (tickPositions.length) { // #1300
					each(tickPositions, function (pos, i) {

						// linked axes need an extra check to find out if
						if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

							if (!ticks[pos]) {
								ticks[pos] = new Tick(axis, pos);
							}

							// render new ticks in old position
							if (slideInTicks && ticks[pos].isNew) {
								ticks[pos].render(i, true, 0.1);
							}

							ticks[pos].render(i);
						}

					});
					// In a categorized axis, the tick marks are displayed between labels. So
					// we need to add a tick mark and grid line at the left edge of the X axis.
					if (tickmarkOffset && (axis.min === 0 || axis.single)) {
						if (!ticks[-1]) {
							ticks[-1] = new Tick(axis, -1, null, true);
						}
						ticks[-1].render(-1);
					}

				}

				// alternate grid color
				if (alternateGridColor) {
					each(tickPositions, function (pos, i) {
						if (i % 2 === 0 && pos < axis.max) {
							if (!alternateBands[pos]) {
								alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
							}
							from = pos + tickmarkOffset; // #949
							to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
							alternateBands[pos].options = {
								from: isLog ? lin2log(from) : from,
								to: isLog ? lin2log(to) : to,
								color: alternateGridColor
							};
							alternateBands[pos].render();
							alternateBands[pos].isActive = true;
						}
					});
				}

				// custom plot lines and bands
				if (!axis._addedPlotLB) { // only first time
					each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
						axis.addPlotBandOrLine(plotLineOptions);
					});
					axis._addedPlotLB = true;
				}

			} // end if hasData

			// Remove inactive ticks
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos,
					i,
					forDestruction = [],
					delay = globalAnimation ? globalAnimation.duration || 500 : 0,
					destroyInactiveItems = function () {
						i = forDestruction.length;
						while (i--) {
							// When resizing rapidly, the same items may be destroyed in different timeouts,
							// or the may be reactivated
							if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
								coll[forDestruction[i]].destroy();
								delete coll[forDestruction[i]];
							}
						}

					};

				for (pos in coll) {

					if (!coll[pos].isActive) {
						// Render to zero opacity
						coll[pos].render(pos, false, 0);
						coll[pos].isActive = false;
						forDestruction.push(pos);
					}
				}

				// When the objects are finished fading out, destroy them
				if (coll === alternateBands || !chart.hasRendered || !delay) {
					destroyInactiveItems();
				} else if (delay) {
					setTimeout(destroyInactiveItems, delay);
				}
			});

			// Static items. As the axis group is cleared on subsequent calls
			// to render, these items are added outside the group.
			// axis line
			if (lineWidth) {
				linePath = axis.getLinePath(lineWidth);
				if (!axis.axisLine) {
					axis.axisLine = renderer.path(linePath)
						.attr({
							stroke: options.lineColor,
							'stroke-width': lineWidth,
							zIndex: 7
						})
						.add(axis.axisGroup);
				} else {
					axis.axisLine.animate({ d: linePath });
				}

				// show or hide the line depending on options.showEmpty
				axis.axisLine[showAxis ? 'show' : 'hide']();
			}

			if (axisTitle && showAxis) {

				axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
					axis.getTitlePosition()
				);
				axisTitle.isNew = false;
			}

			// Stacked totals:
			if (stackLabelOptions && stackLabelOptions.enabled) {
				axis.renderStackTotals();
			}
			// End stacked totals

			axis.isDirty = false;
		},

		/**
		 * Redraw the axis to reflect changes in the data or axis extremes
		 */
		redraw: function () {
			
			// render the axis
			this.render();

			// move plot lines and bands
			each(this.plotLinesAndBands, function (plotLine) {
				plotLine.render();
			});

			// mark associated series as dirty and ready for redraw
			each(this.series, function (series) {
				series.isDirty = true;
			});

		},

		/**
		 * Destroys an Axis instance.
		 */
		destroy: function (keepEvents) {
			var axis = this,
				stacks = axis.stacks,
				stackKey,
				plotLinesAndBands = axis.plotLinesAndBands,
				i;

			// Remove the events
			if (!keepEvents) {
				removeEvent(axis);
			}

			// Destroy each stack total
			for (stackKey in stacks) {
				destroyObjectProperties(stacks[stackKey]);

				stacks[stackKey] = null;
			}

			// Destroy collections
			each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
				destroyObjectProperties(coll);
			});
			i = plotLinesAndBands.length;
			while (i--) { // #1975
				plotLinesAndBands[i].destroy();
			}

			// Destroy local variables
			each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {
				if (axis[prop]) {
					axis[prop] = axis[prop].destroy();
				}
			});

			// Destroy crosshair
			if (this.cross) {
				this.cross.destroy();
			}
		},

		/**
		 * Draw the crosshair
		 */
		drawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.

			var path,
				options = this.crosshair,
				animation = options.animation,
				pos,
				attribs,
				categorized;
			
			if (
				// Disabled in options
				!this.crosshair || 
				// Snap
				((defined(point) || !pick(this.crosshair.snap, true)) === false)
			) {
				this.hideCrosshair();
			
			} else {			

				// Get the path
				if (!pick(options.snap, true)) {
					pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
				} else if (defined(point)) {
					/*jslint eqeq: true*/
					pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
					/*jslint eqeq: false*/
				}

				if (this.isRadial) {
					path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
				} else {
					path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
				}

				if (path === null) {
					this.hideCrosshair();
					return;
				}

				// Draw the cross
				if (this.cross) {
					this.cross
						.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);
				} else {
					categorized = this.categories && !this.isRadial;
					attribs = {
						'stroke-width': options.width || (categorized ? this.transA : 1),
						stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
						zIndex: options.zIndex || 2
					};
					if (options.dashStyle) {
						attribs.dashstyle = options.dashStyle;
					}
					this.cross = this.chart.renderer.path(path).attr(attribs).add();
				}

			}

		},

		/**
		 *	Hide the crosshair.
		 */
		hideCrosshair: function () {
			if (this.cross) {
				this.cross.hide();
			}
		}
	}; // end Axis

	extend(Axis.prototype, AxisPlotLineOrBandExtension);

	/**
	 * Set the tick positions to a time unit that makes sense, for example
	 * on the first of each month or on every Monday. Return an array
	 * with the time positions. Used in datetime axes as well as for grouping
	 * data on a datetime axis.
	 *
	 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
	 * @param {Number} min The minimum in axis values
	 * @param {Number} max The maximum in axis values
	 * @param {Number} startOfWeek
	 */
	Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
		var tickPositions = [],
			i,
			higherRanks = {},
			useUTC = defaultOptions.global.useUTC,
			minYear, // used in months and years as a basis for Date.UTC()
			minDate = new Date(min - getTZOffset(min)),
			interval = normalizedInterval.unitRange,
			count = normalizedInterval.count;

		if (defined(min)) { // #1300
			minDate.setMilliseconds(interval >= timeUnits.second ? 0 :
				count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

			if (interval >= timeUnits.second) { // second
				minDate.setSeconds(interval >= timeUnits.minute ? 0 :
					count * mathFloor(minDate.getSeconds() / count));
			}
		
			if (interval >= timeUnits.minute) { // minute
				minDate[setMinutes](interval >= timeUnits.hour ? 0 :
					count * mathFloor(minDate[getMinutes]() / count));
			}
		
			if (interval >= timeUnits.hour) { // hour
				minDate[setHours](interval >= timeUnits.day ? 0 :
					count * mathFloor(minDate[getHours]() / count));
			}
		
			if (interval >= timeUnits.day) { // day
				minDate[setDate](interval >= timeUnits.month ? 1 :
					count * mathFloor(minDate[getDate]() / count));
			}
		
			if (interval >= timeUnits.month) { // month
				minDate[setMonth](interval >= timeUnits.year ? 0 :
					count * mathFloor(minDate[getMonth]() / count));
				minYear = minDate[getFullYear]();
			}
		
			if (interval >= timeUnits.year) { // year
				minYear -= minYear % count;
				minDate[setFullYear](minYear);
			}
		
			// week is a special case that runs outside the hierarchy
			if (interval === timeUnits.week) {
				// get start of current week, independent of count
				minDate[setDate](minDate[getDate]() - minDate[getDay]() +
					pick(startOfWeek, 1));
			}
		
		
			// get tick positions
			i = 1;
			if (timezoneOffset || getTimezoneOffset) {
				minDate = minDate.getTime();
				minDate = new Date(minDate + getTZOffset(minDate));
			}
			minYear = minDate[getFullYear]();
			var time = minDate.getTime(),
				minMonth = minDate[getMonth](),
				minDateDate = minDate[getDate](),
				localTimezoneOffset = (timeUnits.day + 
						(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
					) % timeUnits.day; // #950, #3359
		
			// iterate and add tick positions at appropriate values
			while (time < max) {
				tickPositions.push(time);
		
				// if the interval is years, use Date.UTC to increase years
				if (interval === timeUnits.year) {
					time = makeTime(minYear + i * count, 0);
		
				// if the interval is months, use Date.UTC to increase months
				} else if (interval === timeUnits.month) {
					time = makeTime(minYear, minMonth + i * count);
		
				// if we're using global time, the interval is not fixed as it jumps
				// one hour at the DST crossover
				} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {
					time = makeTime(minYear, minMonth, minDateDate +
						i * count * (interval === timeUnits.day ? 1 : 7));
		
				// else, the interval is fixed and we use simple addition
				} else {
					time += interval * count;
				}
		
				i++;
			}
		
			// push the last time
			tickPositions.push(time);


			// mark new days if the time is dividible by day (#1649, #1760)
			each(grep(tickPositions, function (time) {
				return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
			}), function (time) {
				higherRanks[time] = 'day';
			});
		}


		// record information on the chosen unit - for dynamic label formatter
		tickPositions.info = extend(normalizedInterval, {
			higherRanks: higherRanks,
			totalRange: interval * count
		});

		return tickPositions;
	};

	/**
	 * Get a normalized tick interval for dates. Returns a configuration object with
	 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
	 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
	 * of segments in stock charts, the normalizing logic was extracted in order to 
	 * prevent it for running over again for each segment having the same interval. 
	 * #662, #697.
	 */
	Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
		var units = unitsOption || [[
					'millisecond', // unit name
					[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
				], [
					'second',
					[1, 2, 5, 10, 15, 30]
				], [
					'minute',
					[1, 2, 5, 10, 15, 30]
				], [
					'hour',
					[1, 2, 3, 4, 6, 8, 12]
				], [
					'day',
					[1, 2]
				], [
					'week',
					[1, 2]
				], [
					'month',
					[1, 2, 3, 4, 6]
				], [
					'year',
					null
				]],
			unit = units[units.length - 1], // default unit is years
			interval = timeUnits[unit[0]],
			multiples = unit[1],
			count,
			i;
			
		// loop through the units to find the one that best fits the tickInterval
		for (i = 0; i < units.length; i++) {
			unit = units[i];
			interval = timeUnits[unit[0]];
			multiples = unit[1];


			if (units[i + 1]) {
				// lessThan is in the middle between the highest multiple and the next unit.
				var lessThan = (interval * multiples[multiples.length - 1] +
							timeUnits[units[i + 1][0]]) / 2;

				// break and keep the current unit
				if (tickInterval <= lessThan) {
					break;
				}
			}
		}

		// prevent 2.5 years intervals, though 25, 250 etc. are allowed
		if (interval === timeUnits.year && tickInterval < 5 * interval) {
			multiples = [1, 2, 5];
		}

		// get the count
		count = normalizeTickInterval(
			tickInterval / interval, 
			multiples,
			unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
		);
		
		return {
			unitRange: interval,
			count: count,
			unitName: unit[0]
		};
	};/**
	 * Methods defined on the Axis prototype
	 */

	/**
	 * Set the tick positions of a logarithmic axis
	 */
	Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
		var axis = this,
			options = axis.options,
			axisLength = axis.len,
			// Since we use this method for both major and minor ticks,
			// use a local variable and return the result
			positions = []; 
		
		// Reset
		if (!minor) {
			axis._minorAutoInterval = null;
		}
		
		// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
		if (interval >= 0.5) {
			interval = mathRound(interval);
			positions = axis.getLinearTickPositions(interval, min, max);
			
		// Second case: We need intermediary ticks. For example 
		// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
		} else if (interval >= 0.08) {
			var roundedMin = mathFloor(min),
				intermediate,
				i,
				j,
				len,
				pos,
				lastPos,
				break2;
				
			if (interval > 0.3) {
				intermediate = [1, 2, 4];
			} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 4, 6, 8];
			} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
			}
			
			for (i = roundedMin; i < max + 1 && !break2; i++) {
				len = intermediate.length;
				for (j = 0; j < len && !break2; j++) {
					pos = log2lin(lin2log(i) * intermediate[j]);
					if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
						positions.push(lastPos);
					}
					
					if (lastPos > max) {
						break2 = true;
					}
					lastPos = pos;
				}
			}
			
		// Third case: We are so deep in between whole logarithmic values that
		// we might as well handle the tick positions like a linear axis. For
		// example 1.01, 1.02, 1.03, 1.04.
		} else {
			var realMin = lin2log(min),
				realMax = lin2log(max),
				tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
				filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
				tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
				totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
			
			interval = pick(
				filteredTickIntervalOption,
				axis._minorAutoInterval,
				(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
			);
			
			interval = normalizeTickInterval(
				interval, 
				null, 
				getMagnitude(interval)
			);
			
			positions = map(axis.getLinearTickPositions(
				interval, 
				realMin,
				realMax	
			), log2lin);
			
			if (!minor) {
				axis._minorAutoInterval = interval / 5;
			}
		}
		
		// Set the axis-level tickInterval variable 
		if (!minor) {
			axis.tickInterval = interval;
		}
		return positions;
	};/**
	 * The tooltip object
	 * @param {Object} chart The chart instance
	 * @param {Object} options Tooltip options
	 */
	var Tooltip = Highcharts.Tooltip = function () {
		this.init.apply(this, arguments);
	};

	Tooltip.prototype = {

		init: function (chart, options) {

			var borderWidth = options.borderWidth,
				style = options.style,
				padding = pInt(style.padding);

			// Save the chart and options
			this.chart = chart;
			this.options = options;

			// Keep track of the current series
			//this.currentSeries = UNDEFINED;

			// List of crosshairs
			this.crosshairs = [];

			// Current values of x and y when animating
			this.now = { x: 0, y: 0 };

			// The tooltip is initially hidden
			this.isHidden = true;


			// create the label		
			this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
				.attr({
					padding: padding,
					fill: options.backgroundColor,
					'stroke-width': borderWidth,
					r: options.borderRadius,
					zIndex: 8
				})
				.css(style)
				.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
				.add()
				.attr({ y: -9999 }); // #2301, #2657

			// When using canVG the shadow shows up as a gray circle
			// even if the tooltip is hidden.
			if (!useCanVG) {
				this.label.shadow(options.shadow);
			}

			// Public property for getting the shared state.
			this.shared = options.shared;
		},

		/**
		 * Destroy the tooltip and its elements.
		 */
		destroy: function () {
			// Destroy and clear local variables
			if (this.label) {
				this.label = this.label.destroy();
			}
			clearTimeout(this.hideTimer);
			clearTimeout(this.tooltipTimeout);
		},

		/**
		 * Provide a soft movement for the tooltip
		 *
		 * @param {Number} x
		 * @param {Number} y
		 * @private
		 */
		move: function (x, y, anchorX, anchorY) {
			var tooltip = this,
				now = tooltip.now,
				animate = tooltip.options.animation !== false && !tooltip.isHidden && 
					// When we get close to the target position, abort animation and land on the right place (#3056)
					(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
				skipAnchor = tooltip.followPointer || tooltip.len > 1;

			// Get intermediate values for animation
			extend(now, {
				x: animate ? (2 * now.x + x) / 3 : x,
				y: animate ? (now.y + y) / 2 : y,
				anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
				anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
			});

			// Move to the intermediate value
			tooltip.label.attr(now);

			
			// Run on next tick of the mouse tracker
			if (animate) {
			
				// Never allow two timeouts
				clearTimeout(this.tooltipTimeout);
				
				// Set the fixed interval ticking for the smooth tooltip
				this.tooltipTimeout = setTimeout(function () {
					// The interval function may still be running during destroy, so check that the chart is really there before calling.
					if (tooltip) {
						tooltip.move(x, y, anchorX, anchorY);
					}
				}, 32);
				
			}
		},

		/**
		 * Hide the tooltip
		 */
		hide: function (delay) {
			var tooltip = this,
				hoverPoints;
			
			clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
			if (!this.isHidden) {
				hoverPoints = this.chart.hoverPoints;

				this.hideTimer = setTimeout(function () {
					tooltip.label.fadeOut();
					tooltip.isHidden = true;
				}, pick(delay, this.options.hideDelay, 500));

				// hide previous hoverPoints and set new
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}

				this.chart.hoverPoints = null;
				this.chart.hoverSeries = null;
			}
		},
		
		/** 
		 * Extendable method to get the anchor position of the tooltip
		 * from a point or set of points
		 */
		getAnchor: function (points, mouseEvent) {
			var ret,
				chart = this.chart,
				inverted = chart.inverted,
				plotTop = chart.plotTop,
				plotLeft = chart.plotLeft,
				plotX = 0,
				plotY = 0,
				yAxis,
				xAxis;
			
			points = splat(points);
			
			// Pie uses a special tooltipPos
			ret = points[0].tooltipPos;
			
			// When tooltip follows mouse, relate the position to the mouse
			if (this.followPointer && mouseEvent) {
				if (mouseEvent.chartX === UNDEFINED) {
					mouseEvent = chart.pointer.normalize(mouseEvent);
				}
				ret = [
					mouseEvent.chartX - chart.plotLeft,
					mouseEvent.chartY - plotTop
				];
			}
			// When shared, use the average position
			if (!ret) {
				each(points, function (point) {
					yAxis = point.series.yAxis;
					xAxis = point.series.xAxis;
					plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); 
					plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
						(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
				});
				
				plotX /= points.length;
				plotY /= points.length;
				
				ret = [
					inverted ? chart.plotWidth - plotY : plotX,
					this.shared && !inverted && points.length > 1 && mouseEvent ? 
						mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
						inverted ? chart.plotHeight - plotX : plotY
				];
			}

			return map(ret, mathRound);
		},
		
		/**
		 * Place the tooltip in a chart without spilling over
		 * and not covering the point it self.
		 */
		getPosition: function (boxWidth, boxHeight, point) {
			
			var chart = this.chart,
				distance = this.distance,
				ret = {},
				h = point.h,
				swapped,
				first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],
				second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],
				// The far side is right or bottom
				preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),
				/**
				 * Handle the preferred dimension. When the preferred dimension is tooltip
				 * on top or bottom of the point, it will look for space there.
				 */
				firstDimension = function (dim, outerSize, innerSize, point) {
					var roomLeft = innerSize < point - distance,
						roomRight = point + distance + innerSize < outerSize,
						alignedLeft = point - distance - innerSize,
						alignedRight = point + distance;

					if (preferFarSide && roomRight) {
						ret[dim] = alignedRight;
					} else if (!preferFarSide && roomLeft) {
						ret[dim] = alignedLeft;
					} else if (roomLeft) {
						ret[dim] = alignedLeft - h < 0 ? alignedLeft : alignedLeft - h;
					} else if (roomRight) {
						ret[dim] = alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h;
					} else {
						return false;
					}
				},
				/**
				 * Handle the secondary dimension. If the preferred dimension is tooltip
				 * on top or bottom of the point, the second dimension is to align the tooltip
				 * above the point, trying to align center but allowing left or right
				 * align within the chart box.
				 */
				secondDimension = function (dim, outerSize, innerSize, point) {
					// Too close to the edge, return false and swap dimensions
					if (point < distance || point > outerSize - distance) {
						return false;
					
					// Align left/top
					} else if (point < innerSize / 2) {
						ret[dim] = 1;
					// Align right/bottom
					} else if (point > outerSize - innerSize / 2) {
						ret[dim] = outerSize - innerSize - 2;
					// Align center
					} else {
						ret[dim] = point - innerSize / 2;
					}
				},
				/**
				 * Swap the dimensions 
				 */
				swap = function (count) {
					var temp = first;
					first = second;
					second = temp;
					swapped = count;
				},
				run = function () {
					if (firstDimension.apply(0, first) !== false) {
						if (secondDimension.apply(0, second) === false && !swapped) {
							swap(true);
							run();
						}
					} else if (!swapped) {
						swap(true);
						run();
					} else {
						ret.x = ret.y = 0;
					}
				};

			// Under these conditions, prefer the tooltip on the side of the point
			if (chart.inverted || this.len > 1) {
				swap();
			}
			run();

			return ret;
		
		},

		/**
		 * In case no user defined formatter is given, this will be used. Note that the context
		 * here is an object holding point, series, x, y etc.
		 */
		defaultFormatter: function (tooltip) {
			var items = this.points || splat(this),
				s;

			// build the header
			s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

			// build the values
			s = s.concat(tooltip.bodyFormatter(items));

			// footer
			s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

			return s.join('');
		},

		/**
		 * Refresh the tooltip's text and position.
		 * @param {Object} point
		 */
		refresh: function (point, mouseEvent) {
			var tooltip = this,
				chart = tooltip.chart,
				label = tooltip.label,
				options = tooltip.options,
				x,
				y,
				anchor,
				textConfig = {},
				text,
				pointConfig = [],
				formatter = options.formatter || tooltip.defaultFormatter,
				hoverPoints = chart.hoverPoints,
				borderColor,
				shared = tooltip.shared,
				currentSeries;
				
			clearTimeout(this.hideTimer);
			
			// get the reference point coordinates (pie charts use tooltipPos)
			tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
			anchor = tooltip.getAnchor(point, mouseEvent);
			x = anchor[0];
			y = anchor[1];

			// shared tooltip, array is sent over
			if (shared && !(point.series && point.series.noSharedTooltip)) {
				
				// hide previous hoverPoints and set new
				
				chart.hoverPoints = point;
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}

				each(point, function (item) {
					item.setState(HOVER_STATE);

					pointConfig.push(item.getLabelConfig());
				});

				textConfig = {
					x: point[0].category,
					y: point[0].y
				};
				textConfig.points = pointConfig;
				this.len = pointConfig.length;
				point = point[0];

			// single point tooltip
			} else {
				textConfig = point.getLabelConfig();
			}
			text = formatter.call(textConfig, tooltip);

			// register the current series
			currentSeries = point.series;
			this.distance = pick(currentSeries.tooltipOptions.distance, 16);

			// update the inner HTML
			if (text === false) {
				this.hide();
			} else {

				// show it
				if (tooltip.isHidden) {
					stop(label);
					label.attr('opacity', 1).show();
				}

				// update text
				label.attr({
					text: text
				});

				// set the stroke color of the box
				borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
				label.attr({
					stroke: borderColor
				});
				tooltip.updatePosition({ 
					plotX: x, 
					plotY: y, 
					negative: point.negative, 
					ttBelow: point.ttBelow, 
					h: (point.shapeArgs && point.shapeArgs.height) || 0
				});
			
				this.isHidden = false;
			}
			fireEvent(chart, 'tooltipRefresh', {
					text: text,
					x: x + chart.plotLeft,
					y: y + chart.plotTop,
					borderColor: borderColor
				});
		},
		
		/**
		 * Find the new position and perform the move
		 */
		updatePosition: function (point) {
			var chart = this.chart,
				label = this.label, 
				pos = (this.options.positioner || this.getPosition).call(
					this,
					label.width,
					label.height,
					point
				);

			// do the move
			this.move(
				mathRound(pos.x), 
				mathRound(pos.y), 
				point.plotX + chart.plotLeft, 
				point.plotY + chart.plotTop
			);
		},

		/** 
		 * Get the best X date format based on the closest point range on the axis.
		 */
		getXDateFormat: function (point, options, xAxis) {
			var xDateFormat,
				dateTimeLabelFormats = options.dateTimeLabelFormats,
				closestPointRange = xAxis && xAxis.closestPointRange,
				n,
				blank = '01-01 00:00:00.000',
				strpos = {
					millisecond: 15,
					second: 12,
					minute: 9,
					hour: 6,
					day: 3
				},
				date,
				lastN;

			if (closestPointRange) {
				date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
				for (n in timeUnits) {

					// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
					if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && 
							date.substr(6) === blank.substr(6)) {
						n = 'week';
						break;

					// The first format that is too great for the range
					} else if (timeUnits[n] > closestPointRange) {
						n = lastN;
						break;
					
					// If the point is placed every day at 23:59, we need to show
					// the minutes as well. #2637.
					} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
						break;
					}

					// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
					if (n !== 'week') {
						lastN = n;
					}
				}
				
				if (n) {
					xDateFormat = dateTimeLabelFormats[n];
				}
			} else {
				xDateFormat = dateTimeLabelFormats.day;
			}

			return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
		},

		/**
		 * Format the footer/header of the tooltip
		 * #3397: abstraction to enable formatting of footer and header
		 */
		tooltipFooterHeaderFormatter: function (point, isFooter) {
			var footOrHead = isFooter ? 'footer' : 'header',
				series = point.series,
				tooltipOptions = series.tooltipOptions,
				xDateFormat = tooltipOptions.xDateFormat,
				xAxis = series.xAxis,
				isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),
				formatString = tooltipOptions[footOrHead+'Format'];

			// Guess the best date format based on the closest point distance (#568, #3418)
			if (isDateTime && !xDateFormat) {
				xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);
			}

			// Insert the footer date format if any
			if (isDateTime && xDateFormat) {
				formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
			}

			return format(formatString, {
				point: point,
				series: series
			});
		},

		/**
	     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
	     * abstracting this functionality allows to easily overwrite and extend it. 
		 */
		bodyFormatter: function (items) {
	        return map(items, function (item) {
	            var tooltipOptions = item.series.tooltipOptions;
	            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
	        });
	    }
	    
	};

	var hoverChartIndex;

	// Global flag for touch support
	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED;

	/**
	 * The mouse tracker object. All methods starting with "on" are primary DOM event handlers. 
	 * Subsequent methods should be named differently from what they are doing.
	 * @param {Object} chart The Chart instance
	 * @param {Object} options The root options object
	 */
	var Pointer = Highcharts.Pointer = function (chart, options) {
		this.init(chart, options);
	};

	Pointer.prototype = {
		/**
		 * Initialize Pointer
		 */
		init: function (chart, options) {
			
			var chartOptions = options.chart,
				chartEvents = chartOptions.events,
				zoomType = useCanVG ? '' : chartOptions.zoomType,
				inverted = chart.inverted,
				zoomX,
				zoomY;

			// Store references
			this.options = options;
			this.chart = chart;
			
			// Zoom status
			this.zoomX = zoomX = /x/.test(zoomType);
			this.zoomY = zoomY = /y/.test(zoomType);
			this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
			this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
			this.hasZoom = zoomX || zoomY;

			// Do we need to handle click on a touch device?
			this.runChartClick = chartEvents && !!chartEvents.click;

			this.pinchDown = [];
			this.lastValidTouch = {};

			if (Highcharts.Tooltip && options.tooltip.enabled) {
				chart.tooltip = new Tooltip(chart, options.tooltip);
				this.followTouchMove = pick(options.tooltip.followTouchMove, true);
			}

			this.setDOMEvents();
		}, 

		/**
		 * Add crossbrowser support for chartX and chartY
		 * @param {Object} e The event object in standard browsers
		 */
		normalize: function (e, chartPosition) {
			var chartX,
				chartY,
				ePos;

			// common IE normalizing
			e = e || window.event;

			// Framework specific normalizing (#1165)
			e = washMouseEvent(e);

			// More IE normalizing, needs to go after washMouseEvent
			if (!e.target) {
				e.target = e.srcElement;
			}
			
			// iOS (#2757)
			ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

			// Get mouse position
			if (!chartPosition) {
				this.chartPosition = chartPosition = offset(this.chart.container);
			}

			// chartX and chartY
			if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
				chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
					// for IE10 quirks mode within framesets
				chartY = e.y;
			} else {
				chartX = ePos.pageX - chartPosition.left;
				chartY = ePos.pageY - chartPosition.top;
			}

			return extend(e, {
				chartX: mathRound(chartX),
				chartY: mathRound(chartY)
			});
		},

		/**
		 * Get the click position in terms of axis values.
		 *
		 * @param {Object} e A pointer event
		 */
		getCoordinates: function (e) {
			var coordinates = {
					xAxis: [],
					yAxis: []
				};

			each(this.chart.axes, function (axis) {
				coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
					axis: axis,
					value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
				});
			});
			return coordinates;
		},
		
		/**
		 * With line type charts with a single tracker, get the point closest to the mouse.
		 * Run Point.onMouseOver and display tooltip for the point or points.
		 */
		runPointActions: function (e) {

			var pointer = this,
				chart = pointer.chart,
				series = chart.series,
				tooltip = chart.tooltip,
				shared = tooltip ? tooltip.shared : false,
				followPointer,
				//point,
				//points,
				hoverPoint = chart.hoverPoint,
				hoverSeries = chart.hoverSeries,
				i,
				//j,
				distance = chart.chartWidth,
				rdistance = chart.chartWidth,
				anchor,
				noSharedTooltip,
				kdpoints = [],
				kdpoint,
				kdpointT;

			// For hovering over the empty parts of the plot area (hoverSeries is undefined). 
			// If there is one series with point tracking (combo chart), don't go to nearest neighbour.
			if (!shared && !hoverSeries) {
				for (i = 0; i < series.length; i++) {
					if (series[i].directTouch || !series[i].options.stickyTracking) {
						series = [];
					}
				}
			}

			// Handle shared tooltip or cases where a series is not yet hovered
			if (!(hoverSeries && hoverSeries.noSharedTooltip) && (shared || !hoverSeries)) { // #3821 
				// Find nearest points on all series
				each(series, function (s) {
					// Skip hidden series
					noSharedTooltip = s.noSharedTooltip && shared;
					if (s.visible && !noSharedTooltip && pick(s.options.enableMouseTracking, true)) { // #3821
						kdpointT = s.searchPoint(e); // #3828
						if (kdpointT) {
							kdpoints.push(kdpointT);
						}
					}
				});
				// Find absolute nearest point
				each(kdpoints, function (p) {
					if (p && defined(p.plotX) && defined(p.plotY)) {
						if ((p.dist.distX < distance) || ((p.dist.distX === distance || p.series.kdDimensions > 1) && p.dist.distR < rdistance)) {
							distance = p.dist.distX;
							rdistance = p.dist.distR;
							kdpoint = p;
						}
					}
				});	

			// Handle non-shared tooltips
			} else {
				// If it has a hoverPoint and that series requires direct touch (like columns), use the hoverPoint (#3899).
				// Otherwise, search the k-d tree (like scatter).
				kdpoint = (hoverSeries.directTouch && hoverPoint) || (hoverSeries && hoverSeries.searchPoint(e));
			}

			// Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926
			if (kdpoint && (kdpoint !== hoverPoint || (tooltip && tooltip.isHidden))) {
				// Draw tooltip if necessary
				if (shared && !kdpoint.series.noSharedTooltip) {
					i = kdpoints.length;
					while (i--) {
						if (kdpoints[i].clientX !== kdpoint.clientX || (kdpoints[i].series.noSharedTooltip || false)) {
							kdpoints.splice(i, 1);
						}
					}
					if (kdpoints.length && tooltip) {
						tooltip.refresh(kdpoints, e);
					}

					// do mouseover on all points except the closest
					each(kdpoints, function (point) {
						if (point !== kdpoint) { 
							point.onMouseOver(e);
						}
					});				
					kdpoint.onMouseOver(e); // #3919 do mouseover on the closest point last to ensure it is the hoverpoint
				} else {
					if (tooltip) { 
						tooltip.refresh(kdpoint, e);
					}
					kdpoint.onMouseOver(e); 
				}
			
			// Update positions (regardless of kdpoint or hoverPoint)
			} else {
				followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
				if (tooltip && followPointer && !tooltip.isHidden) {
					anchor = tooltip.getAnchor([{}], e);
					tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });			
				}
			}

			// Start the event listener to pick up the tooltip 
			if (tooltip && !pointer._onDocumentMouseMove) {
				pointer._onDocumentMouseMove = function (e) {
					if (charts[hoverChartIndex]) {
						charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
					}
				};
				addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
			}
			
			// Crosshair
			each(chart.axes, function (axis) {
				axis.drawCrosshair(e, pick(kdpoint, hoverPoint));
			});	
					
		},



		/**
		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
		 * 
		 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
		 */
		reset: function (allowMove, delay) {
			var pointer = this,
				chart = pointer.chart,
				hoverSeries = chart.hoverSeries,
				hoverPoint = chart.hoverPoint,
				tooltip = chart.tooltip,
				tooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;
				
			// Narrow in allowMove
			allowMove = allowMove && tooltip && tooltipPoints;
				
			// Check if the points have moved outside the plot area, #1003		
			if (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {
				allowMove = false;
			}	
			// Just move the tooltip, #349
			if (allowMove) {
				tooltip.refresh(tooltipPoints);
				if (hoverPoint) { // #2500
					hoverPoint.setState(hoverPoint.state, true);
					each(chart.axes, function (axis) {
						if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {
							axis.drawCrosshair(null, allowMove);
						}  else {
							axis.hideCrosshair();
						}
					});
					
				}

			// Full reset
			} else {

				if (hoverPoint) {
					hoverPoint.onMouseOut();
				}

				if (hoverSeries) {
					hoverSeries.onMouseOut();
				}

				if (tooltip) {
					tooltip.hide(delay);
				}

				if (pointer._onDocumentMouseMove) {
					removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
					pointer._onDocumentMouseMove = null;
				}

				// Remove crosshairs
				each(chart.axes, function (axis) {
					axis.hideCrosshair();
				});
				
				pointer.hoverX = null;

			}
		},

		/**
		 * Scale series groups to a certain scale and translation
		 */
		scaleGroups: function (attribs, clip) {

			var chart = this.chart,
				seriesAttribs;

			// Scale each series
			each(chart.series, function (series) {
				seriesAttribs = attribs || series.getPlotBox(); // #1701
				if (series.xAxis && series.xAxis.zoomEnabled) {
					series.group.attr(seriesAttribs);
					if (series.markerGroup) {
						series.markerGroup.attr(seriesAttribs);
						series.markerGroup.clip(clip ? chart.clipRect : null);
					}
					if (series.dataLabelsGroup) {
						series.dataLabelsGroup.attr(seriesAttribs);
					}
				}
			});
			
			// Clip
			chart.clipRect.attr(clip || chart.clipBox);
		},

		/**
		 * Start a drag operation
		 */
		dragStart: function (e) {
			var chart = this.chart;

			// Record the start position
			chart.mouseIsDown = e.type;
			chart.cancelClick = false;
			chart.mouseDownX = this.mouseDownX = e.chartX;
			chart.mouseDownY = this.mouseDownY = e.chartY;
		},

		/**
		 * Perform a drag operation in response to a mousemove event while the mouse is down
		 */
		drag: function (e) {

			var chart = this.chart,
				chartOptions = chart.options.chart,
				chartX = e.chartX,
				chartY = e.chartY,
				zoomHor = this.zoomHor,
				zoomVert = this.zoomVert,
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop,
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				clickedInside,
				size,
				mouseDownX = this.mouseDownX,
				mouseDownY = this.mouseDownY,
				panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

			// If the mouse is outside the plot area, adjust to cooordinates
			// inside to prevent the selection marker from going outside
			if (chartX < plotLeft) {
				chartX = plotLeft;
			} else if (chartX > plotLeft + plotWidth) {
				chartX = plotLeft + plotWidth;
			}

			if (chartY < plotTop) {
				chartY = plotTop;
			} else if (chartY > plotTop + plotHeight) {
				chartY = plotTop + plotHeight;
			}
			
			// determine if the mouse has moved more than 10px
			this.hasDragged = Math.sqrt(
				Math.pow(mouseDownX - chartX, 2) +
				Math.pow(mouseDownY - chartY, 2)
			);
			
			if (this.hasDragged > 10) {
				clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

				// make a selection
				if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
					if (!this.selectionMarker) {
						this.selectionMarker = chart.renderer.rect(
							plotLeft,
							plotTop,
							zoomHor ? 1 : plotWidth,
							zoomVert ? 1 : plotHeight,
							0
						)
						.attr({
							fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
							zIndex: 7
						})
						.add();
					}
				}

				// adjust the width of the selection marker
				if (this.selectionMarker && zoomHor) {
					size = chartX - mouseDownX;
					this.selectionMarker.attr({
						width: mathAbs(size),
						x: (size > 0 ? 0 : size) + mouseDownX
					});
				}
				// adjust the height of the selection marker
				if (this.selectionMarker && zoomVert) {
					size = chartY - mouseDownY;
					this.selectionMarker.attr({
						height: mathAbs(size),
						y: (size > 0 ? 0 : size) + mouseDownY
					});
				}

				// panning
				if (clickedInside && !this.selectionMarker && chartOptions.panning) {
					chart.pan(e, chartOptions.panning);
				}
			}
		},

		/**
		 * On mouse up or touch end across the entire document, drop the selection.
		 */
		drop: function (e) {
			var pointer = this,
				chart = this.chart,
				hasPinched = this.hasPinched;

			if (this.selectionMarker) {
				var selectionData = {
						xAxis: [],
						yAxis: [],
						originalEvent: e.originalEvent || e
					},
					selectionBox = this.selectionMarker,
					selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
					selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
					selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
					selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
					runZoom;

				// a selection has been made
				if (this.hasDragged || hasPinched) {

					// record each axis' min and max
					each(chart.axes, function (axis) {
						if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
							var horiz = axis.horiz,
								minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075
								selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
								selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

							selectionData[axis.coll].push({
								axis: axis,
								min: mathMin(selectionMin, selectionMax), // for reversed axes
								max: mathMax(selectionMin, selectionMax)
							});
							runZoom = true;
						}
					});
					if (runZoom) {
						fireEvent(chart, 'selection', selectionData, function (args) { 
							chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
						});
					}

				}
				this.selectionMarker = this.selectionMarker.destroy();

				// Reset scaling preview
				if (hasPinched) {
					this.scaleGroups();
				}
			}

			// Reset all
			if (chart) { // it may be destroyed on mouse up - #877
				css(chart.container, { cursor: chart._cursor });
				chart.cancelClick = this.hasDragged > 10; // #370
				chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
				this.pinchDown = [];
			}
		},

		onContainerMouseDown: function (e) {

			e = this.normalize(e);

			// issue #295, dragging not always working in Firefox
			if (e.preventDefault) {
				e.preventDefault();
			}
			
			this.dragStart(e);
		},

		

		onDocumentMouseUp: function (e) {
			if (charts[hoverChartIndex]) {
				charts[hoverChartIndex].pointer.drop(e);
			}
		},

		/**
		 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
		 * Issue #149 workaround. The mouseleave event does not always fire. 
		 */
		onDocumentMouseMove: function (e) {
			var chart = this.chart,
				chartPosition = this.chartPosition;

			e = this.normalize(e, chartPosition);

			// If we're outside, hide the tooltip
			if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
					!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
				this.reset();
			}
		},

		/**
		 * When mouse leaves the container, hide the tooltip.
		 */
		onContainerMouseLeave: function () {
			var chart = charts[hoverChartIndex];
			if (chart) {
				chart.pointer.reset();
				chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
			}
		},

		// The mousemove, touchmove and touchstart event handler
		onContainerMouseMove: function (e) {

			var chart = this.chart;

			hoverChartIndex = chart.index;

			e = this.normalize(e);		
			e.returnValue = false; // #2251, #3224
			
			if (chart.mouseIsDown === 'mousedown') {
				this.drag(e);
			} 
			
			// Show the tooltip and run mouse over events (#977)
			if ((this.inClass(e.target, 'highcharts-tracker') || 
					chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
				this.runPointActions(e);
			}
		},

		/**
		 * Utility to detect whether an element has, or has a parent with, a specific
		 * class name. Used on detection of tracker objects and on deciding whether
		 * hovering the tooltip should cause the active series to mouse out.
		 */
		inClass: function (element, className) {
			var elemClassName;
			while (element) {
				elemClassName = attr(element, 'class');
				if (elemClassName) {
					if (elemClassName.indexOf(className) !== -1) {
						return true;
					} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
						return false;
					}
				}
				element = element.parentNode;
			}		
		},

		onTrackerMouseOut: function (e) {
			var series = this.chart.hoverSeries,
				relatedTarget = e.relatedTarget || e.toElement,
				relatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499
			
			if (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&
					relatedSeries !== series) {
				series.onMouseOut();
			}
		},

		onContainerClick: function (e) {
			var chart = this.chart,
				hoverPoint = chart.hoverPoint, 
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop;
			
			e = this.normalize(e);
			e.originalEvent = e; // #3913
			e.cancelBubble = true; // IE specific

			if (!chart.cancelClick) {
				
				// On tracker click, fire the series and point events. #783, #1583
				if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

					// the series click event
					fireEvent(hoverPoint.series, 'click', extend(e, {
						point: hoverPoint
					}));

					// the point click event
					if (chart.hoverPoint) { // it may be destroyed (#1844)
						hoverPoint.firePointEvent('click', e);
					}

				// When clicking outside a tracker, fire a chart event
				} else {
					extend(e, this.getCoordinates(e));

					// fire a click event in the chart
					if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
						fireEvent(chart, 'click', e);
					}
				}


			}
		},

		/**
		 * Set the JS DOM events on the container and document. This method should contain
		 * a one-to-one assignment between methods and their handlers. Any advanced logic should
		 * be moved to the handler reflecting the event's name.
		 */
		setDOMEvents: function () {

			var pointer = this,
				container = pointer.chart.container;

			container.onmousedown = function (e) {
				pointer.onContainerMouseDown(e);
			};
			container.onmousemove = function (e) {
				pointer.onContainerMouseMove(e);
			};
			container.onclick = function (e) {
				pointer.onContainerClick(e);
			};
			addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
			if (chartCount === 1) {
				addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
			}
			if (hasTouch) {
				container.ontouchstart = function (e) {
					pointer.onContainerTouchStart(e);
				};
				container.ontouchmove = function (e) {
					pointer.onContainerTouchMove(e);
				};
				if (chartCount === 1) {
					addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
				}
			}
			
		},

		/**
		 * Destroys the Pointer object and disconnects DOM events.
		 */
		destroy: function () {
			var prop;

			removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
			if (!chartCount) {
				removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
				removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
			}

			// memory and CPU leak
			clearInterval(this.tooltipTimeout);

			for (prop in this) {
				this[prop] = null;
			}
		}
	};


	/* Support for touch devices */
	extend(Highcharts.Pointer.prototype, {

		/**
		 * Run translation operations
		 */
		pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
			if (this.zoomHor || this.pinchHor) {
				this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
			if (this.zoomVert || this.pinchVert) {
				this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
		},

		/**
		 * Run translation operations for each direction (horizontal and vertical) independently
		 */
		pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
			var chart = this.chart,
				xy = horiz ? 'x' : 'y',
				XY = horiz ? 'X' : 'Y',
				sChartXY = 'chart' + XY,
				wh = horiz ? 'width' : 'height',
				plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
				selectionWH,
				selectionXY,
				clipXY,
				scale = forcedScale || 1,
				inverted = chart.inverted,
				bounds = chart.bounds[horiz ? 'h' : 'v'],
				singleTouch = pinchDown.length === 1,
				touch0Start = pinchDown[0][sChartXY],
				touch0Now = touches[0][sChartXY],
				touch1Start = !singleTouch && pinchDown[1][sChartXY],
				touch1Now = !singleTouch && touches[1][sChartXY],
				outOfBounds,
				transformScale,
				scaleKey,
				setScale = function () {
					if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
						scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); 
					}
					
					clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
					selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
				};

			// Set the scale, first pass
			setScale();

			selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

			// Out of bounds
			if (selectionXY < bounds.min) {
				selectionXY = bounds.min;
				outOfBounds = true;
			} else if (selectionXY + selectionWH > bounds.max) {
				selectionXY = bounds.max - selectionWH;
				outOfBounds = true;
			}
			
			// Is the chart dragged off its bounds, determined by dataMin and dataMax?
			if (outOfBounds) {

				// Modify the touchNow position in order to create an elastic drag movement. This indicates
				// to the user that the chart is responsive but can't be dragged further.
				touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
				if (!singleTouch) {
					touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
				}

				// Set the scale, second pass to adapt to the modified touchNow positions
				setScale();

			} else {
				lastValidTouch[xy] = [touch0Now, touch1Now];
			}

			// Set geometry for clipping, selection and transformation
			if (!inverted) { // TODO: implement clipping for inverted charts
				clip[xy] = clipXY - plotLeftTop;
				clip[wh] = selectionWH;
			}
			scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
			transformScale = inverted ? 1 / scale : scale;

			selectionMarker[wh] = selectionWH;
			selectionMarker[xy] = selectionXY;
			transform[scaleKey] = scale;
			transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
		},
		
		/**
		 * Handle touch events with two touches
		 */
		pinch: function (e) {

			var self = this,
				chart = self.chart,
				pinchDown = self.pinchDown,
				touches = e.touches,
				touchesLength = touches.length,
				lastValidTouch = self.lastValidTouch,
				hasZoom = self.hasZoom,
				selectionMarker = self.selectionMarker,
				transform = {},
				fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && 
					chart.runTrackerClick) || self.runChartClick),
				clip = {};

			// On touch devices, only proceed to trigger click if a handler is defined
			if (hasZoom && !fireClickEvent) {
				e.preventDefault();
			}
			
			// Normalize each touch
			map(touches, function (e) {
				return self.normalize(e);
			});
			
			// Register the touch start position
			if (e.type === 'touchstart') {
				each(touches, function (e, i) {
					pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
				});
				lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
				lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

				// Identify the data bounds in pixels
				each(chart.axes, function (axis) {
					if (axis.zoomEnabled) {
						var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
							minPixelPadding = axis.minPixelPadding,
							min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
							max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
							absMin = mathMin(min, max),
							absMax = mathMax(min, max);

						// Store the bounds for use in the touchmove handler
						bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
						bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
					}
				});
				self.res = true; // reset on next move
			
			// Event type is touchmove, handle panning and pinching
			} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first
				

				// Set the marker
				if (!selectionMarker) {
					self.selectionMarker = selectionMarker = extend({
						destroy: noop
					}, chart.plotBox);
				}
				
				self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

				self.hasPinched = hasZoom;

				// Scale and translate the groups to provide visual feedback during pinching
				self.scaleGroups(transform, clip);
				
				// Optionally move the tooltip on touchmove
				if (!hasZoom && self.followTouchMove && touchesLength === 1) {
					this.runPointActions(self.normalize(e));
				} else if (self.res) {
					self.res = false;
					this.reset(false, 0);
				}
			}
		},

		onContainerTouchStart: function (e) {
			var chart = this.chart;

			hoverChartIndex = chart.index;

			if (e.touches.length === 1) {

				e = this.normalize(e);

				if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

					// Run mouse events and display tooltip etc
					this.runPointActions(e);

					this.pinch(e);

				} else {
					// Hide the tooltip on touching outside the plot area (#1203)
					this.reset();
				}

			} else if (e.touches.length === 2) {
				this.pinch(e);
			}   
		},

		onContainerTouchMove: function (e) {
			if (e.touches.length === 1 || e.touches.length === 2) {
				this.pinch(e);
			}
		},

		onDocumentTouchEnd: function (e) {
			if (charts[hoverChartIndex]) {
				charts[hoverChartIndex].pointer.drop(e);
			}
		}

	});
	if (win.PointerEvent || win.MSPointerEvent) {
		
		// The touches object keeps track of the points being touched at all times
		var touches = {},
			hasPointerEvent = !!win.PointerEvent,
			getWebkitTouches = function () {
				var key, fake = [];
				fake.item = function (i) { return this[i]; };
				for (key in touches) {
					if (touches.hasOwnProperty(key)) {
						fake.push({
							pageX: touches[key].pageX,
							pageY: touches[key].pageY,
							target: touches[key].target
						});
					}
				}
				return fake;
			},
			translateMSPointer = function (e, method, wktype, callback) {
				var p;
				e = e.originalEvent || e;
				if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
					callback(e);
					p = charts[hoverChartIndex].pointer;
					p[method]({
						type: wktype,
						target: e.currentTarget,
						preventDefault: noop,
						touches: getWebkitTouches()
					});				
				}
			};

		/**
		 * Extend the Pointer prototype with methods for each event handler and more
		 */
		extend(Pointer.prototype, {
			onContainerPointerDown: function (e) {
				translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
				});
			},
			onContainerPointerMove: function (e) {
				translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
					if (!touches[e.pointerId].target) {
						touches[e.pointerId].target = e.currentTarget;
					}
				});
			},
			onDocumentPointerUp: function (e) {
				translateMSPointer(e, 'onContainerTouchEnd', 'touchend', function (e) {
					delete touches[e.pointerId];
				});
			},

			/**
			 * Add or remove the MS Pointer specific events
			 */
			batchMSEvents: function (fn) {
				fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
				fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
				fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
			}
		});

		// Disable default IE actions for pinch and such on chart element
		wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
			proceed.call(this, chart, options);
			if (this.hasZoom || this.followTouchMove) {
				css(chart.container, {
					'-ms-touch-action': NONE,
					'touch-action': NONE
				});
			}
		});

		// Add IE specific touch events to chart
		wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
			proceed.apply(this);
			if (this.hasZoom || this.followTouchMove) {
				this.batchMSEvents(addEvent);
			}
		});
		// Destroy MS events also
		wrap(Pointer.prototype, 'destroy', function (proceed) {
			this.batchMSEvents(removeEvent);
			proceed.call(this);
		});
	}
	/**
	 * The overview of the chart's series
	 */
	var Legend = Highcharts.Legend = function (chart, options) {
		this.init(chart, options);
	};

	Legend.prototype = {
		
		/**
		 * Initialize the legend
		 */
		init: function (chart, options) {
			
			var legend = this,
				itemStyle = options.itemStyle,
				padding,
				itemMarginTop = options.itemMarginTop || 0;
		
			this.options = options;

			if (!options.enabled) {
				return;
			}
		
			legend.itemStyle = itemStyle;
			legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
			legend.itemMarginTop = itemMarginTop;
			legend.padding = padding = pick(options.padding, 8);
			legend.initialItemX = padding;
			legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
			legend.maxItemWidth = 0;
			legend.chart = chart;
			legend.itemHeight = 0;
			legend.symbolWidth = pick(options.symbolWidth, 16);
			legend.pages = [];


			// Render it
			legend.render();

			// move checkboxes
			addEvent(legend.chart, 'endResize', function () { 
				legend.positionCheckboxes();
			});

		},

		/**
		 * Set the colors for the legend item
		 * @param {Object} item A Series or Point instance
		 * @param {Object} visible Dimmed or colored
		 */
		colorizeItem: function (item, visible) {
			var legend = this,
				options = legend.options,
				legendItem = item.legendItem,
				legendLine = item.legendLine,
				legendSymbol = item.legendSymbol,
				hiddenColor = legend.itemHiddenStyle.color,
				textColor = visible ? options.itemStyle.color : hiddenColor,
				symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
				markerOptions = item.options && item.options.marker,
				symbolAttr = { fill: symbolColor },
				key,
				val;
			
			if (legendItem) {
				legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
			}
			if (legendLine) {
				legendLine.attr({ stroke: symbolColor });
			}
			
			if (legendSymbol) {
				
				// Apply marker options
				if (markerOptions && legendSymbol.isMarker) { // #585
					symbolAttr.stroke = symbolColor;
					markerOptions = item.convertAttribs(markerOptions);
					for (key in markerOptions) {
						val = markerOptions[key];
						if (val !== UNDEFINED) {
							symbolAttr[key] = val;
						}
					}
				}

				legendSymbol.attr(symbolAttr);
			}
		},

		/**
		 * Position the legend item
		 * @param {Object} item A Series or Point instance
		 */
		positionItem: function (item) {
			var legend = this,
				options = legend.options,
				symbolPadding = options.symbolPadding,
				ltr = !options.rtl,
				legendItemPos = item._legendItemPos,
				itemX = legendItemPos[0],
				itemY = legendItemPos[1],
				checkbox = item.checkbox;

			if (item.legendGroup) {
				item.legendGroup.translate(
					ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
					itemY
				);
			}

			if (checkbox) {
				checkbox.x = itemX;
				checkbox.y = itemY;
			}
		},

		/**
		 * Destroy a single legend item
		 * @param {Object} item The series or point
		 */
		destroyItem: function (item) {
			var checkbox = item.checkbox;

			// destroy SVG elements
			each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
				if (item[key]) {
					item[key] = item[key].destroy();
				}
			});

			if (checkbox) {
				discardElement(item.checkbox);
			}
		},

		/**
		 * Destroy all items.
		 */
		clearItems: function () {
			var legend = this;
			each(legend.getAllItems(), function (item) {
				legend.destroyItem(item); 
			});		
		},

		/**
		 * Destroys the legend.
		 */
		destroy: function () {
			var legend = this,
				legendGroup = legend.group,
				box = legend.box;

			if (box) {
				legend.box = box.destroy();
			}

			if (legendGroup) {
				legend.group = legendGroup.destroy();
			}
		},

		/**
		 * Position the checkboxes after the width is determined
		 */
		positionCheckboxes: function (scrollOffset) {
			var alignAttr = this.group.alignAttr,
				translateY,
				clipHeight = this.clipHeight || this.legendHeight;

			if (alignAttr) {
				translateY = alignAttr.translateY;
				each(this.allItems, function (item) {
					var checkbox = item.checkbox,
						top;
					
					if (checkbox) {
						top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
						css(checkbox, {
							left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
							top: top + PX,
							display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
						});
					}
				});
			}
		},
		
		/**
		 * Render the legend title on top of the legend
		 */
		renderTitle: function () {
			var options = this.options,
				padding = this.padding,
				titleOptions = options.title,
				titleHeight = 0,
				bBox;
			
			if (titleOptions.text) {
				if (!this.title) {
					this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
						.attr({ zIndex: 1 })
						.css(titleOptions.style)
						.add(this.group);
				}
				bBox = this.title.getBBox();
				titleHeight = bBox.height;
				this.offsetWidth = bBox.width; // #1717
				this.contentGroup.attr({ translateY: titleHeight });
			}
			this.titleHeight = titleHeight;
		},

		/**
		 * Render a single specific legend item
		 * @param {Object} item A series or point
		 */
		renderItem: function (item) {
			var legend = this,
				chart = legend.chart,
				renderer = chart.renderer,
				options = legend.options,
				horizontal = options.layout === 'horizontal',
				symbolWidth = legend.symbolWidth,
				symbolPadding = options.symbolPadding,
				itemStyle = legend.itemStyle,
				itemHiddenStyle = legend.itemHiddenStyle,
				padding = legend.padding,
				itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
				ltr = !options.rtl,
				itemHeight,
				widthOption = options.width,
				itemMarginBottom = options.itemMarginBottom || 0,
				itemMarginTop = legend.itemMarginTop,
				initialItemX = legend.initialItemX,
				bBox,
				itemWidth,
				li = item.legendItem,
				series = item.series && item.series.drawLegendSymbol ? item.series : item,
				seriesOptions = series.options,
				showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
				useHTML = options.useHTML;

			if (!li) { // generate it once, later move it

				// Generate the group box
				// A group to hold the symbol and text. Text is to be appended in Legend class.
				item.legendGroup = renderer.g('legend-item')
					.attr({ zIndex: 1 })
					.add(legend.scrollGroup);

				// Generate the list item text and add it to the group
				item.legendItem = li = renderer.text(
						options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item),
						ltr ? symbolWidth + symbolPadding : -symbolPadding,
						legend.baseline || 0,
						useHTML
					)
					.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
					.attr({
						align: ltr ? 'left' : 'right',
						zIndex: 2
					})
					.add(item.legendGroup);

				// Get the baseline for the first item - the font size is equal for all
				if (!legend.baseline) {
					legend.baseline = renderer.fontMetrics(itemStyle.fontSize, li).f + 3 + itemMarginTop;
					li.attr('y', legend.baseline);
				}

				// Draw the legend symbol inside the group box
				series.drawLegendSymbol(legend, item);

				if (legend.setItemEvents) {
					legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
				}			

				// Colorize the items
				legend.colorizeItem(item, item.visible);

				// add the HTML checkbox on top
				if (showCheckbox) {
					legend.createCheckboxForItem(item);				
				}
			}

			// calculate the positions for the next line
			bBox = li.getBBox();

			itemWidth = item.checkboxOffset = 
				options.itemWidth || 
				item.legendItemWidth || 
				symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
			legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

			// if the item exceeds the width, start a new line
			if (horizontal && legend.itemX - initialItemX + itemWidth >
					(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
				legend.itemX = initialItemX;
				legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
			}

			// If the item exceeds the height, start a new column
			/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
				legend.itemY = legend.initialItemY;
				legend.itemX += legend.maxItemWidth;
				legend.maxItemWidth = 0;
			}*/

			// Set the edge positions
			legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
			legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
			legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

			// cache the position of the newly generated or reordered items
			item._legendItemPos = [legend.itemX, legend.itemY];

			// advance
			if (horizontal) {
				legend.itemX += itemWidth;

			} else {
				legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
				legend.lastLineHeight = itemHeight;
			}

			// the width of the widest item
			legend.offsetWidth = widthOption || mathMax(
				(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
				legend.offsetWidth
			);
		},

		/**
		 * Get all items, which is one item per series for normal series and one item per point
		 * for pie series.
		 */
		getAllItems: function () {
			var allItems = [];
			each(this.chart.series, function (series) {
				var seriesOptions = series.options;

				// Handle showInLegend. If the series is linked to another series, defaults to false.
				if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
					return;
				}

				// use points or series for the legend item depending on legendType
				allItems = allItems.concat(
						series.legendItems ||
						(seriesOptions.legendType === 'point' ?
								series.data :
								series)
				);
			});
			return allItems;
		},

		/**
		 * Adjust the chart margins by reserving space for the legend on only one side
		 * of the chart. If the position is set to a corner, top or bottom is reserved
		 * for horizontal legends and left or right for vertical ones.
		 */
		adjustMargins: function (margin, spacing) {
			var chart = this.chart, 
				options = this.options,
				// Use the first letter of each alignment option in order to detect the side 
				alignment = options.align[0] + options.verticalAlign[0] + options.layout[0];
				
			if (this.display && !options.floating) {

				each([
					/(lth|ct|rth)/,
					/(rtv|rm|rbv)/,
					/(rbh|cb|lbh)/,
					/(lbv|lm|ltv)/
				], function (alignments, side) {
					if (alignments.test(alignment) && !defined(margin[side])) {
						// Now we have detected on which side of the chart we should reserve space for the legend
						chart[marginNames[side]] = mathMax(
							chart[marginNames[side]],
							chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + 
								[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + 
								pick(options.margin, 12) +
								spacing[side]
						);
					}
				});
			}
		},

		/**
		 * Render the legend. This method can be called both before and after
		 * chart.render. If called after, it will only rearrange items instead
		 * of creating new ones.
		 */
		render: function () {
			var legend = this,
				chart = legend.chart,
				renderer = chart.renderer,
				legendGroup = legend.group,
				allItems,
				display,
				legendWidth,
				legendHeight,
				box = legend.box,
				options = legend.options,
				padding = legend.padding,
				legendBorderWidth = options.borderWidth,
				legendBackgroundColor = options.backgroundColor;

			legend.itemX = legend.initialItemX;
			legend.itemY = legend.initialItemY;
			legend.offsetWidth = 0;
			legend.lastItemY = 0;

			if (!legendGroup) {
				legend.group = legendGroup = renderer.g('legend')
					.attr({ zIndex: 7 }) 
					.add();
				legend.contentGroup = renderer.g()
					.attr({ zIndex: 1 }) // above background
					.add(legendGroup);
				legend.scrollGroup = renderer.g()
					.add(legend.contentGroup);
			}
			
			legend.renderTitle();

			// add each series or point
			allItems = legend.getAllItems();

			// sort by legendIndex
			stableSort(allItems, function (a, b) {
				return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
			});

			// reversed legend
			if (options.reversed) {
				allItems.reverse();
			}

			legend.allItems = allItems;
			legend.display = display = !!allItems.length;

			// render the items
			legend.lastLineHeight = 0;
			each(allItems, function (item) {
				legend.renderItem(item); 
			});

			// Get the box
			legendWidth = (options.width || legend.offsetWidth) + padding;
			legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
			legendHeight = legend.handleOverflow(legendHeight);
			legendHeight += padding;

			// Draw the border and/or background
			if (legendBorderWidth || legendBackgroundColor) {

				if (!box) {
					legend.box = box = renderer.rect(
						0,
						0,
						legendWidth,
						legendHeight,
						options.borderRadius,
						legendBorderWidth || 0
					).attr({
						stroke: options.borderColor,
						'stroke-width': legendBorderWidth || 0,
						fill: legendBackgroundColor || NONE
					})
					.add(legendGroup)
					.shadow(options.shadow);
					box.isNew = true;

				} else if (legendWidth > 0 && legendHeight > 0) {
					box[box.isNew ? 'attr' : 'animate'](
						box.crisp({ width: legendWidth, height: legendHeight })
					);
					box.isNew = false;
				}

				// hide the border if no items
				box[display ? 'show' : 'hide']();
			}
			
			legend.legendWidth = legendWidth;
			legend.legendHeight = legendHeight;

			// Now that the legend width and height are established, put the items in the 
			// final position
			each(allItems, function (item) {
				legend.positionItem(item);
			});

			// 1.x compatibility: positioning based on style
			/*var props = ['left', 'right', 'top', 'bottom'],
				prop,
				i = 4;
			while (i--) {
				prop = props[i];
				if (options.style[prop] && options.style[prop] !== 'auto') {
					options[i < 2 ? 'align' : 'verticalAlign'] = prop;
					options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
				}
			}*/

			if (display) {
				legendGroup.align(extend({
					width: legendWidth,
					height: legendHeight
				}, options), true, 'spacingBox');
			}

			if (!chart.isResizing) {
				this.positionCheckboxes();
			}
		},
		
		/**
		 * Set up the overflow handling by adding navigation with up and down arrows below the
		 * legend.
		 */
		handleOverflow: function (legendHeight) {
			var legend = this,
				chart = this.chart,
				renderer = chart.renderer,
				options = this.options,
				optionsY = options.y,
				alignTop = options.verticalAlign === 'top',
				spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
				maxHeight = options.maxHeight,
				clipHeight,
				clipRect = this.clipRect,
				navOptions = options.navigation,
				animation = pick(navOptions.animation, true),
				arrowSize = navOptions.arrowSize || 12,
				nav = this.nav,
				pages = this.pages,
				lastY,
				allItems = this.allItems;
				
			// Adjust the height
			if (options.layout === 'horizontal') {
				spaceHeight /= 2;
			}
			if (maxHeight) {
				spaceHeight = mathMin(spaceHeight, maxHeight);
			}
			
			// Reset the legend height and adjust the clipping rectangle
			pages.length = 0;
			if (legendHeight > spaceHeight && !options.useHTML) {

				this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - this.padding, 0);
				this.currentPage = pick(this.currentPage, 1);
				this.fullHeight = legendHeight;
				
				// Fill pages with Y positions so that the top of each a legend item defines
				// the scroll top for each page (#2098)
				each(allItems, function (item, i) {
					var y = item._legendItemPos[1],
						h = mathRound(item.legendItem.getBBox().height),
						len = pages.length;
					
					if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
						pages.push(lastY || y);
						len++;
					}
					
					if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
						pages.push(y);
					}
					if (y !== lastY) {
						lastY = y;
					}
				});

				// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
				if (!clipRect) {
					clipRect = legend.clipRect = renderer.clipRect(0, this.padding, 9999, 0);
					legend.contentGroup.clip(clipRect);
				}
				clipRect.attr({
					height: clipHeight
				});
				
				// Add navigation elements
				if (!nav) {
					this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
					this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
						.on('click', function () {
							legend.scroll(-1, animation);
						})
						.add(nav);
					this.pager = renderer.text('', 15, 10)
						.css(navOptions.style)
						.add(nav);
					this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
						.on('click', function () {
							legend.scroll(1, animation);
						})
						.add(nav);
				}
				
				// Set initial position
				legend.scroll(0);
				
				legendHeight = spaceHeight;
				
			} else if (nav) {
				clipRect.attr({
					height: chart.chartHeight
				});
				nav.hide();
				this.scrollGroup.attr({
					translateY: 1
				});
				this.clipHeight = 0; // #1379
			}
			
			return legendHeight;
		},
		
		/**
		 * Scroll the legend by a number of pages
		 * @param {Object} scrollBy
		 * @param {Object} animation
		 */
		scroll: function (scrollBy, animation) {
			var pages = this.pages,
				pageCount = pages.length,
				currentPage = this.currentPage + scrollBy,
				clipHeight = this.clipHeight,
				navOptions = this.options.navigation,
				activeColor = navOptions.activeColor,
				inactiveColor = navOptions.inactiveColor,
				pager = this.pager,
				padding = this.padding,
				scrollOffset;
			
			// When resizing while looking at the last page
			if (currentPage > pageCount) {
				currentPage = pageCount;
			}
			
			if (currentPage > 0) {
				
				if (animation !== UNDEFINED) {
					setAnimation(animation, this.chart);
				}
				
				this.nav.attr({
					translateX: padding,
					translateY: clipHeight + this.padding + 7 + this.titleHeight,
					visibility: VISIBLE
				});
				this.up.attr({
						fill: currentPage === 1 ? inactiveColor : activeColor
					})
					.css({
						cursor: currentPage === 1 ? 'default' : 'pointer'
					});
				pager.attr({
					text: currentPage + '/' + pageCount
				});
				this.down.attr({
						x: 18 + this.pager.getBBox().width, // adjust to text width
						fill: currentPage === pageCount ? inactiveColor : activeColor
					})
					.css({
						cursor: currentPage === pageCount ? 'default' : 'pointer'
					});
				
				scrollOffset = -pages[currentPage - 1] + this.initialItemY;

				this.scrollGroup.animate({
					translateY: scrollOffset
				});			
				
				this.currentPage = currentPage;
				this.positionCheckboxes(scrollOffset);
			}
				
		}
		
	};

	/*
	 * LegendSymbolMixin
	 */ 

	var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

		/**
		 * Get the series' symbol in the legend
		 * 
		 * @param {Object} legend The legend object
		 * @param {Object} item The series (this) or point
		 */
		drawRectangle: function (legend, item) {
			var symbolHeight = legend.options.symbolHeight || 12;
			
			item.legendSymbol = this.chart.renderer.rect(
				0,
				legend.baseline - 5 - (symbolHeight / 2),
				legend.symbolWidth,
				symbolHeight,
				legend.options.symbolRadius || 0
			).attr({
				zIndex: 3
			}).add(item.legendGroup);		
			
		},

		/**
		 * Get the series' symbol in the legend. This method should be overridable to create custom 
		 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
		 * 
		 * @param {Object} legend The legend object
		 */
		drawLineMarker: function (legend) {

			var options = this.options,
				markerOptions = options.marker,
				radius,
				legendOptions = legend.options,
				legendSymbol,
				symbolWidth = legend.symbolWidth,
				renderer = this.chart.renderer,
				legendItemGroup = this.legendGroup,
				verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize, this.legendItem).b * 0.3),
				attr;

			// Draw the line
			if (options.lineWidth) {
				attr = {
					'stroke-width': options.lineWidth
				};
				if (options.dashStyle) {
					attr.dashstyle = options.dashStyle;
				}
				this.legendLine = renderer.path([
					M,
					0,
					verticalCenter,
					L,
					symbolWidth,
					verticalCenter
				])
				.attr(attr)
				.add(legendItemGroup);
			}
			
			// Draw the marker
			if (markerOptions && markerOptions.enabled !== false) {
				radius = markerOptions.radius;
				this.legendSymbol = legendSymbol = renderer.symbol(
					this.symbol,
					(symbolWidth / 2) - radius,
					verticalCenter - radius,
					2 * radius,
					2 * radius
				)
				.add(legendItemGroup);
				legendSymbol.isMarker = true;
			}
		}
	};

	// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
	// and for #2580, a similar drawing flaw in Firefox 26.
	// TODO: Explore if there's a general cause for this. The problem may be related 
	// to nested group elements, as the legend item texts are within 4 group elements.
	if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
		wrap(Legend.prototype, 'positionItem', function (proceed, item) {
			var legend = this,
				runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
					if (item._legendItemPos) {
						proceed.call(legend, item);
					}
				};

			// Do it now, for export and to get checkbox placement
			runPositionItem();
			
			// Do it after to work around the core issue
			setTimeout(runPositionItem);
		});
	}
	/**
	 * The chart class
	 * @param {Object} options
	 * @param {Function} callback Function to run when the chart has loaded
	 */
	var Chart = Highcharts.Chart = function () {
		this.init.apply(this, arguments);
	};

	Chart.prototype = {

		/**
		 * Hook for modules
		 */
		callbacks: [],

		/**
		 * Initialize the chart
		 */
		init: function (userOptions, callback) {

			// Handle regular options
			var options,
				seriesOptions = userOptions.series; // skip merging data points to increase performance

			userOptions.series = null;
			options = merge(defaultOptions, userOptions); // do the merge
			options.series = userOptions.series = seriesOptions; // set back the series data
			this.userOptions = userOptions;

			var optionsChart = options.chart;
			
			// Create margin & spacing array
			this.margin = this.splashArray('margin', optionsChart);
			this.spacing = this.splashArray('spacing', optionsChart);

			var chartEvents = optionsChart.events;

			//this.runChartClick = chartEvents && !!chartEvents.click;
			this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

			this.callback = callback;
			this.isResizing = 0;
			this.options = options;
			//chartTitleOptions = UNDEFINED;
			//chartSubtitleOptions = UNDEFINED;

			this.axes = [];
			this.series = [];
			this.hasCartesianSeries = optionsChart.showAxes;
			//this.axisOffset = UNDEFINED;
			//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
			//this.inverted = UNDEFINED;
			//this.loadingShown = UNDEFINED;
			//this.container = UNDEFINED;
			//this.chartWidth = UNDEFINED;
			//this.chartHeight = UNDEFINED;
			//this.marginRight = UNDEFINED;
			//this.marginBottom = UNDEFINED;
			//this.containerWidth = UNDEFINED;
			//this.containerHeight = UNDEFINED;
			//this.oldChartWidth = UNDEFINED;
			//this.oldChartHeight = UNDEFINED;

			//this.renderTo = UNDEFINED;
			//this.renderToClone = UNDEFINED;

			//this.spacingBox = UNDEFINED

			//this.legend = UNDEFINED;

			// Elements
			//this.chartBackground = UNDEFINED;
			//this.plotBackground = UNDEFINED;
			//this.plotBGImage = UNDEFINED;
			//this.plotBorder = UNDEFINED;
			//this.loadingDiv = UNDEFINED;
			//this.loadingSpan = UNDEFINED;

			var chart = this,
				eventType;

			// Add the chart to the global lookup
			chart.index = charts.length;
			charts.push(chart);
			chartCount++;

			// Set up auto resize
			if (optionsChart.reflow !== false) {
				addEvent(chart, 'load', function () {
					chart.initReflow();
				});
			}

			// Chart event handlers
			if (chartEvents) {
				for (eventType in chartEvents) {
					addEvent(chart, eventType, chartEvents[eventType]);
				}
			}

			chart.xAxis = [];
			chart.yAxis = [];

			// Expose methods and variables
			chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
			chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

			chart.firstRender();
		},

		/**
		 * Initialize an individual series, called internally before render time
		 */
		initSeries: function (options) {
			var chart = this,
				optionsChart = chart.options.chart,
				type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
				series,
				constr = seriesTypes[type];

			// No such series type
			if (!constr) {
				error(17, true);
			}

			series = new constr();
			series.init(this, options);
			return series;
		},

		/**
		 * Check whether a given point is within the plot area
		 *
		 * @param {Number} plotX Pixel x relative to the plot area
		 * @param {Number} plotY Pixel y relative to the plot area
		 * @param {Boolean} inverted Whether the chart is inverted
		 */
		isInsidePlot: function (plotX, plotY, inverted) {
			var x = inverted ? plotY : plotX,
				y = inverted ? plotX : plotY;
				
			return x >= 0 &&
				x <= this.plotWidth &&
				y >= 0 &&
				y <= this.plotHeight;
		},

		/**
		 * Redraw legend, axes or series based on updated data
		 *
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		redraw: function (animation) {
			var chart = this,
				axes = chart.axes,
				series = chart.series,
				pointer = chart.pointer,
				legend = chart.legend,
				redrawLegend = chart.isDirtyLegend,
				hasStackedSeries,
				hasDirtyStacks,
				hasCartesianSeries = chart.hasCartesianSeries,
				isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
				seriesLength = series.length,
				i = seriesLength,
				serie,
				renderer = chart.renderer,
				isHiddenChart = renderer.isHidden(),
				afterRedraw = [];
				
			setAnimation(animation, chart);
			
			if (isHiddenChart) {
				chart.cloneRenderTo();
			}

			// Adjust title layout (reflow multiline text)
			chart.layOutTitles();

			// link stacked series
			while (i--) {
				serie = series[i];

				if (serie.options.stacking) {
					hasStackedSeries = true;
					
					if (serie.isDirty) {
						hasDirtyStacks = true;
						break;
					}
				}
			}
			if (hasDirtyStacks) { // mark others as dirty
				i = seriesLength;
				while (i--) {
					serie = series[i];
					if (serie.options.stacking) {
						serie.isDirty = true;
					}
				}
			}

			// handle updated data in the series
			each(series, function (serie) {
				if (serie.isDirty) { // prepare the data so axis can read it
					if (serie.options.legendType === 'point') {
						redrawLegend = true;
					}
				}
			});

			// handle added or removed series
			if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
				// draw legend graphics
				legend.render();

				chart.isDirtyLegend = false;
			}

			// reset stacks
			if (hasStackedSeries) {
				chart.getStacks();
			}


			if (hasCartesianSeries) {
				if (!chart.isResizing) {

					// reset maxTicks
					chart.maxTicks = null;

					// set axes scales
					each(axes, function (axis) {
						axis.setScale();
					});
				}
			}

			chart.getMargins(); // #3098

			if (hasCartesianSeries) {
				// If one axis is dirty, all axes must be redrawn (#792, #2169)
				each(axes, function (axis) {
					if (axis.isDirty) {
						isDirtyBox = true;
					}
				});

				// redraw axes
				each(axes, function (axis) {
					
					// Fire 'afterSetExtremes' only if extremes are set
					if (axis.isDirtyExtremes) { // #821
						axis.isDirtyExtremes = false;
						afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
							fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
							delete axis.eventArgs;
						});
					}
					
					if (isDirtyBox || hasStackedSeries) {
						axis.redraw();
					}
				});
			}
			
			// the plot areas size has changed
			if (isDirtyBox) {
				chart.drawChartBox();
			}


			// redraw affected series
			each(series, function (serie) {
				if (serie.isDirty && serie.visible &&
						(!serie.isCartesian || serie.xAxis)) { // issue #153
					serie.redraw();
				}
			});

			// move tooltip or reset
			if (pointer) {
				pointer.reset(true);
			}

			// redraw if canvas
			renderer.draw();

			// fire the event
			fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
			
			if (isHiddenChart) {
				chart.cloneRenderTo(true);
			}
			
			// Fire callbacks that are put on hold until after the redraw
			each(afterRedraw, function (callback) {
				callback.call();
			});
		},

		/**
		 * Get an axis, series or point object by id.
		 * @param id {String} The id as given in the configuration options
		 */
		get: function (id) {
			var chart = this,
				axes = chart.axes,
				series = chart.series;

			var i,
				j,
				points;

			// search axes
			for (i = 0; i < axes.length; i++) {
				if (axes[i].options.id === id) {
					return axes[i];
				}
			}

			// search series
			for (i = 0; i < series.length; i++) {
				if (series[i].options.id === id) {
					return series[i];
				}
			}

			// search points
			for (i = 0; i < series.length; i++) {
				points = series[i].points || [];
				for (j = 0; j < points.length; j++) {
					if (points[j].id === id) {
						return points[j];
					}
				}
			}
			return null;
		},

		/**
		 * Create the Axis instances based on the config options
		 */
		getAxes: function () {
			var chart = this,
				options = this.options,
				xAxisOptions = options.xAxis = splat(options.xAxis || {}),
				yAxisOptions = options.yAxis = splat(options.yAxis || {}),
				optionsArray,
				axis;

			// make sure the options are arrays and add some members
			each(xAxisOptions, function (axis, i) {
				axis.index = i;
				axis.isX = true;
			});

			each(yAxisOptions, function (axis, i) {
				axis.index = i;
			});

			// concatenate all axis options into one array
			optionsArray = xAxisOptions.concat(yAxisOptions);

			each(optionsArray, function (axisOptions) {
				axis = new Axis(chart, axisOptions);
			});
		},


		/**
		 * Get the currently selected points from all series
		 */
		getSelectedPoints: function () {
			var points = [];
			each(this.series, function (serie) {
				points = points.concat(grep(serie.points || [], function (point) {
					return point.selected;
				}));
			});
			return points;
		},

		/**
		 * Get the currently selected series
		 */
		getSelectedSeries: function () {
			return grep(this.series, function (serie) {
				return serie.selected;
			});
		},

		/**
		 * Generate stacks for each series and calculate stacks total values
		 */
		getStacks: function () {
			var chart = this;

			// reset stacks for each yAxis
			each(chart.yAxis, function (axis) {
				if (axis.stacks && axis.hasVisibleSeries) {
					axis.oldStacks = axis.stacks;
				}
			});

			each(chart.series, function (series) {
				if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
					series.stackKey = series.type + pick(series.options.stack, '');
				}
			});
		},	

		/**
		 * Show the title and subtitle of the chart
		 *
		 * @param titleOptions {Object} New title options
		 * @param subtitleOptions {Object} New subtitle options
		 *
		 */
		setTitle: function (titleOptions, subtitleOptions, redraw) {
			var chart = this,
				options = chart.options,
				chartTitleOptions,
				chartSubtitleOptions;

			chartTitleOptions = options.title = merge(options.title, titleOptions);
			chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

			// add title and subtitle
			each([
				['title', titleOptions, chartTitleOptions],
				['subtitle', subtitleOptions, chartSubtitleOptions]
			], function (arr) {
				var name = arr[0],
					title = chart[name],
					titleOptions = arr[1],
					chartTitleOptions = arr[2];

				if (title && titleOptions) {
					chart[name] = title = title.destroy(); // remove old
				}
				
				if (chartTitleOptions && chartTitleOptions.text && !title) {
					chart[name] = chart.renderer.text(
						chartTitleOptions.text,
						0,
						0,
						chartTitleOptions.useHTML
					)
					.attr({
						align: chartTitleOptions.align,
						'class': PREFIX + name,
						zIndex: chartTitleOptions.zIndex || 4
					})
					.css(chartTitleOptions.style)
					.add();
				}	
			});
			chart.layOutTitles(redraw);
		},

		/**
		 * Lay out the chart titles and cache the full offset height for use in getMargins
		 */
		layOutTitles: function (redraw) {
			var titleOffset = 0,
				title = this.title,
				subtitle = this.subtitle,
				options = this.options,
				titleOptions = options.title,
				subtitleOptions = options.subtitle,
				requiresDirtyBox,
				renderer = this.renderer,
				autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

			if (title) {
				title
					.css({ width: (titleOptions.width || autoWidth) + PX })
					.align(extend({ 
						y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
					}, titleOptions), false, 'spacingBox');
				
				if (!titleOptions.floating && !titleOptions.verticalAlign) {
					titleOffset = title.getBBox().height;
				}
			}
			if (subtitle) {
				subtitle
					.css({ width: (subtitleOptions.width || autoWidth) + PX })
					.align(extend({ 
						y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b 
					}, subtitleOptions), false, 'spacingBox');
				
				if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
					titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
				}
			}

			requiresDirtyBox = this.titleOffset !== titleOffset;				
			this.titleOffset = titleOffset; // used in getMargins

			if (!this.isDirtyBox && requiresDirtyBox) {
				this.isDirtyBox = requiresDirtyBox;
				// Redraw if necessary (#2719, #2744)		
				if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
					this.redraw();
				}
			}
		},

		/**
		 * Get chart width and height according to options and container size
		 */
		getChartSize: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				widthOption = optionsChart.width,
				heightOption = optionsChart.height,
				renderTo = chart.renderToClone || chart.renderTo;

			// get inner width and height from jQuery (#824)
			if (!defined(widthOption)) {
				chart.containerWidth = adapterRun(renderTo, 'width');
			}
			if (!defined(heightOption)) {
				chart.containerHeight = adapterRun(renderTo, 'height');
			}
			
			chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
			chart.chartHeight = mathMax(0, pick(heightOption,
				// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
				chart.containerHeight > 19 ? chart.containerHeight : 400));
		},

		/**
		 * Create a clone of the chart's renderTo div and place it outside the viewport to allow
		 * size computation on chart.render and chart.redraw
		 */
		cloneRenderTo: function (revert) {
			var clone = this.renderToClone,
				container = this.container;
			
			// Destroy the clone and bring the container back to the real renderTo div
			if (revert) {
				if (clone) {
					this.renderTo.appendChild(container);
					discardElement(clone);
					delete this.renderToClone;
				}
			
			// Set up the clone
			} else {
				if (container && container.parentNode === this.renderTo) {
					this.renderTo.removeChild(container); // do not clone this
				}
				this.renderToClone = clone = this.renderTo.cloneNode(0);
				css(clone, {
					position: ABSOLUTE,
					top: '-9999px',
					display: 'block' // #833
				});
				if (clone.style.setProperty) { // #2631
					clone.style.setProperty('display', 'block', 'important');
				}
				doc.body.appendChild(clone);
				if (container) {
					clone.appendChild(container);
				}
			}
		},

		/**
		 * Get the containing element, determine the size and create the inner container
		 * div to hold the chart
		 */
		getContainer: function () {
			var chart = this,
				container,
				optionsChart = chart.options.chart,
				chartWidth,
				chartHeight,
				renderTo,
				indexAttrName = 'data-highcharts-chart',
				oldChartIndex,
				containerId;

			chart.renderTo = renderTo = optionsChart.renderTo;
			containerId = PREFIX + idCounter++;

			if (isString(renderTo)) {
				chart.renderTo = renderTo = doc.getElementById(renderTo);
			}
			
			// Display an error if the renderTo is wrong
			if (!renderTo) {
				error(13, true);
			}
			
			// If the container already holds a chart, destroy it. The check for hasRendered is there
			// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
			// attribute and the SVG contents, but not an interactive chart. So in this case,
			// charts[oldChartIndex] will point to the wrong chart if any (#2609).
			oldChartIndex = pInt(attr(renderTo, indexAttrName));
			if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
				charts[oldChartIndex].destroy();
			}		
			
			// Make a reference to the chart from the div
			attr(renderTo, indexAttrName, chart.index);

			// remove previous chart
			renderTo.innerHTML = '';

			// If the container doesn't have an offsetWidth, it has or is a child of a node
			// that has display:none. We need to temporarily move it out to a visible
			// state to determine the size, else the legend and tooltips won't render
			// properly. The allowClone option is used in sparklines as a micro optimization,
			// saving about 1-2 ms each chart.
			if (!optionsChart.skipClone && !renderTo.offsetWidth) {
				chart.cloneRenderTo();
			}

			// get the width and height
			chart.getChartSize();
			chartWidth = chart.chartWidth;
			chartHeight = chart.chartHeight;

			// create the inner container
			chart.container = container = createElement(DIV, {
					className: PREFIX + 'container' +
						(optionsChart.className ? ' ' + optionsChart.className : ''),
					id: containerId
				}, extend({
					position: RELATIVE,
					overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
						// content overflow in IE
					width: chartWidth + PX,
					height: chartHeight + PX,
					textAlign: 'left',
					lineHeight: 'normal', // #427
					zIndex: 0, // #1072
					'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
				}, optionsChart.style),
				chart.renderToClone || renderTo
			);

			// cache the cursor (#1650)
			chart._cursor = container.style.cursor;

			// Initialize the renderer
			chart.renderer =
				optionsChart.forExport ? // force SVG, used for SVG export
					new SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :
					new Renderer(container, chartWidth, chartHeight, optionsChart.style);

			if (useCanVG) {
				// If we need canvg library, extend and configure the renderer
				// to get the tracker for translating mouse events
				chart.renderer.create(chart, container, chartWidth, chartHeight);
			}
			// Add a reference to the charts index
			chart.renderer.chartIndex = chart.index;
		},

		/**
		 * Calculate margins by rendering axis labels in a preliminary position. Title,
		 * subtitle and legend have already been rendered at this stage, but will be
		 * moved into their final positions
		 */
		getMargins: function (skipAxes) {
			var chart = this,
				spacing = chart.spacing,
				margin = chart.margin,
				titleOffset = chart.titleOffset;

			chart.resetMargins();

			// Adjust for title and subtitle
			if (titleOffset && !defined(margin[0])) {
				chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
			}
			
			// Adjust for legend
			chart.legend.adjustMargins(margin, spacing);

			// adjust for scroller
			if (chart.extraBottomMargin) {
				chart.marginBottom += chart.extraBottomMargin;
			}
			if (chart.extraTopMargin) {
				chart.plotTop += chart.extraTopMargin;
			}
			if (!skipAxes) {
				this.getAxisMargins();
			}
		},

		getAxisMargins: function () {

			var chart = this,
				axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
				margin = chart.margin;
			
			// pre-render axes to get labels offset width
			if (chart.hasCartesianSeries) {
				each(chart.axes, function (axis) {
					axis.getOffset();
				});
			}

			// Add the axis offsets
			each(marginNames, function (m, side) {
				if (!defined(margin[side])) {
					chart[m] += axisOffset[side];
				}		
			});

			chart.setChartSize();

		},

		/**
		 * Resize the chart to its container if size is not explicitly set
		 */
		reflow: function (e) {
			var chart = this,
				optionsChart = chart.options.chart,
				renderTo = chart.renderTo,
				width = optionsChart.width || adapterRun(renderTo, 'width'),
				height = optionsChart.height || adapterRun(renderTo, 'height'),
				target = e ? e.target : win, // #805 - MooTools doesn't supply e
				doReflow = function () {
					if (chart.container) { // It may have been destroyed in the meantime (#1257)
						chart.setSize(width, height, false);
						chart.hasUserSize = null;
					}
				};
				
			// Width and height checks for display:none. Target is doc in IE8 and Opera,
			// win in Firefox, Chrome and IE9.
			if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093
				if (width !== chart.containerWidth || height !== chart.containerHeight) {
					clearTimeout(chart.reflowTimeout);
					if (e) { // Called from window.resize
						chart.reflowTimeout = setTimeout(doReflow, 100);
					} else { // Called directly (#2224)
						doReflow();
					}
				}
				chart.containerWidth = width;
				chart.containerHeight = height;
			}
		},

		/**
		 * Add the event handlers necessary for auto resizing
		 */
		initReflow: function () {
			var chart = this,
				reflow = function (e) {
					chart.reflow(e);
				};
				
			
			addEvent(win, 'resize', reflow);
			addEvent(chart, 'destroy', function () {
				removeEvent(win, 'resize', reflow);
			});
		},

		/**
		 * Resize the chart to a given width and height
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Object|Boolean} animation
		 */
		setSize: function (width, height, animation) {
			var chart = this,
				chartWidth,
				chartHeight,
				fireEndResize;

			// Handle the isResizing counter
			chart.isResizing += 1;
			fireEndResize = function () {
				if (chart) {
					fireEvent(chart, 'endResize', null, function () {
						chart.isResizing -= 1;
					});
				}
			};

			// set the animation for the current process
			setAnimation(animation, chart);

			chart.oldChartHeight = chart.chartHeight;
			chart.oldChartWidth = chart.chartWidth;
			if (defined(width)) {
				chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
				chart.hasUserSize = !!chartWidth;
			}
			if (defined(height)) {
				chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
			}

			// Resize the container with the global animation applied if enabled (#2503)
			(globalAnimation ? animate : css)(chart.container, {
				width: chartWidth + PX,
				height: chartHeight + PX
			}, globalAnimation);

			chart.setChartSize(true);
			chart.renderer.setSize(chartWidth, chartHeight, animation);

			// handle axes
			chart.maxTicks = null;
			each(chart.axes, function (axis) {
				axis.isDirty = true;
				axis.setScale();
			});

			// make sure non-cartesian series are also handled
			each(chart.series, function (serie) {
				serie.isDirty = true;
			});

			chart.isDirtyLegend = true; // force legend redraw
			chart.isDirtyBox = true; // force redraw of plot and chart border

			chart.layOutTitles(); // #2857
			chart.getMargins();

			chart.redraw(animation);


			chart.oldChartHeight = null;
			fireEvent(chart, 'resize');

			// fire endResize and set isResizing back
			// If animation is disabled, fire without delay
			if (globalAnimation === false) {
				fireEndResize();
			} else { // else set a timeout with the animation duration
				setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
			}
		},

		/**
		 * Set the public chart properties. This is done before and after the pre-render
		 * to determine margin sizes
		 */
		setChartSize: function (skipAxes) {
			var chart = this,
				inverted = chart.inverted,
				renderer = chart.renderer,
				chartWidth = chart.chartWidth,
				chartHeight = chart.chartHeight,
				optionsChart = chart.options.chart,
				spacing = chart.spacing,
				clipOffset = chart.clipOffset,
				clipX,
				clipY,
				plotLeft,
				plotTop,
				plotWidth,
				plotHeight,
				plotBorderWidth;

			chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
			chart.plotTop = plotTop = mathRound(chart.plotTop);
			chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
			chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

			chart.plotSizeX = inverted ? plotHeight : plotWidth;
			chart.plotSizeY = inverted ? plotWidth : plotHeight;
			
			chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

			// Set boxes used for alignment
			chart.spacingBox = renderer.spacingBox = {
				x: spacing[3],
				y: spacing[0],
				width: chartWidth - spacing[3] - spacing[1],
				height: chartHeight - spacing[0] - spacing[2]
			};
			chart.plotBox = renderer.plotBox = {
				x: plotLeft,
				y: plotTop,
				width: plotWidth,
				height: plotHeight
			};

			plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
			clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
			clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
			chart.clipBox = {
				x: clipX, 
				y: clipY, 
				width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), 
				height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
			};

			if (!skipAxes) {
				each(chart.axes, function (axis) {
					axis.setAxisSize();
					axis.setAxisTranslation();
				});
			}
		},

		/**
		 * Initial margins before auto size margins are applied
		 */
		resetMargins: function () {
			var chart = this;

			each(marginNames, function (m, side) {
				chart[m] = pick(chart.margin[side], chart.spacing[side]);
			});
			chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
			chart.clipOffset = [0, 0, 0, 0];
		},

		/**
		 * Draw the borders and backgrounds for chart and plot area
		 */
		drawChartBox: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				renderer = chart.renderer,
				chartWidth = chart.chartWidth,
				chartHeight = chart.chartHeight,
				chartBackground = chart.chartBackground,
				plotBackground = chart.plotBackground,
				plotBorder = chart.plotBorder,
				plotBGImage = chart.plotBGImage,
				chartBorderWidth = optionsChart.borderWidth || 0,
				chartBackgroundColor = optionsChart.backgroundColor,
				plotBackgroundColor = optionsChart.plotBackgroundColor,
				plotBackgroundImage = optionsChart.plotBackgroundImage,
				plotBorderWidth = optionsChart.plotBorderWidth || 0,
				mgn,
				bgAttr,
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop,
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				plotBox = chart.plotBox,
				clipRect = chart.clipRect,
				clipBox = chart.clipBox;

			// Chart area
			mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

			if (chartBorderWidth || chartBackgroundColor) {
				if (!chartBackground) {
					
					bgAttr = {
						fill: chartBackgroundColor || NONE
					};
					if (chartBorderWidth) { // #980
						bgAttr.stroke = optionsChart.borderColor;
						bgAttr['stroke-width'] = chartBorderWidth;
					}
					chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
							optionsChart.borderRadius, chartBorderWidth)
						.attr(bgAttr)
						.addClass(PREFIX + 'background')
						.add()
						.shadow(optionsChart.shadow);

				} else { // resize
					chartBackground.animate(
						chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
					);
				}
			}


			// Plot background
			if (plotBackgroundColor) {
				if (!plotBackground) {
					chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
						.attr({
							fill: plotBackgroundColor
						})
						.add()
						.shadow(optionsChart.plotShadow);
				} else {
					plotBackground.animate(plotBox);
				}
			}
			if (plotBackgroundImage) {
				if (!plotBGImage) {
					chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
						.add();
				} else {
					plotBGImage.animate(plotBox);
				}
			}
			
			// Plot clip
			if (!clipRect) {
				chart.clipRect = renderer.clipRect(clipBox);
			} else {
				clipRect.animate({
					width: clipBox.width,
					height: clipBox.height
				});
			}

			// Plot area border
			if (plotBorderWidth) {
				if (!plotBorder) {
					chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
						.attr({
							stroke: optionsChart.plotBorderColor,
							'stroke-width': plotBorderWidth,
							fill: NONE,
							zIndex: 1
						})
						.add();
				} else {
					plotBorder.animate(
						plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative
					);
				}
			}

			// reset
			chart.isDirtyBox = false;
		},

		/**
		 * Detect whether a certain chart property is needed based on inspecting its options
		 * and series. This mainly applies to the chart.invert property, and in extensions to 
		 * the chart.angular and chart.polar properties.
		 */
		propFromSeries: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				klass,
				seriesOptions = chart.options.series,
				i,
				value;
				
				
			each(['inverted', 'angular', 'polar'], function (key) {
				
				// The default series type's class
				klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
				
				// Get the value from available chart-wide properties
				value = (
					chart[key] || // 1. it is set before
					optionsChart[key] || // 2. it is set in the options
					(klass && klass.prototype[key]) // 3. it's default series class requires it
				);
		
				// 4. Check if any the chart's series require it
				i = seriesOptions && seriesOptions.length;
				while (!value && i--) {
					klass = seriesTypes[seriesOptions[i].type];
					if (klass && klass.prototype[key]) {
						value = true;
					}
				}
		
				// Set the chart property
				chart[key] = value;	
			});
			
		},

		/**
		 * Link two or more series together. This is done initially from Chart.render,
		 * and after Chart.addSeries and Series.remove.
		 */
		linkSeries: function () {
			var chart = this,
				chartSeries = chart.series;

			// Reset links
			each(chartSeries, function (series) {
				series.linkedSeries.length = 0;
			});

			// Apply new links
			each(chartSeries, function (series) {
				var linkedTo = series.options.linkedTo;
				if (isString(linkedTo)) {
					if (linkedTo === ':previous') {
						linkedTo = chart.series[series.index - 1];
					} else {
						linkedTo = chart.get(linkedTo);
					}
					if (linkedTo) {
						linkedTo.linkedSeries.push(series);
						series.linkedParent = linkedTo;
					}
				}
			});
		},

		/**
		 * Render series for the chart
		 */
		renderSeries: function () {
			each(this.series, function (serie) {
				serie.translate();
				serie.render();
			});
		},
			
		/**
		 * Render labels for the chart
		 */
		renderLabels: function () {
			var chart = this,
				labels = chart.options.labels;
			if (labels.items) {
				each(labels.items, function (label) {
					var style = extend(labels.style, label.style),
						x = pInt(style.left) + chart.plotLeft,
						y = pInt(style.top) + chart.plotTop + 12;

					// delete to prevent rewriting in IE
					delete style.left;
					delete style.top;

					chart.renderer.text(
						label.html,
						x,
						y
					)
					.attr({ zIndex: 2 })
					.css(style)
					.add();

				});
			}
		},

		/**
		 * Render all graphics for the chart
		 */
		render: function () {
			var chart = this,
				axes = chart.axes,
				renderer = chart.renderer,
				options = chart.options,
				tempWidth,
				tempHeight,
				redoHorizontal,
				redoVertical;

			// Title
			chart.setTitle();


			// Legend
			chart.legend = new Legend(chart, options.legend);

			chart.getStacks(); // render stacks

			// Get chart margins
			chart.getMargins(true);
			chart.setChartSize();

			// Record preliminary dimensions for later comparison
			tempWidth = chart.plotWidth;
			tempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels

			// Get margins by pre-rendering axes
			each(axes, function (axis) {
				axis.setScale();
			});
			chart.getAxisMargins();

			// If the plot area size has changed significantly, calculate tick positions again
			redoHorizontal = tempWidth / chart.plotWidth > 1.2;
			redoVertical = tempHeight / chart.plotHeight > 1.1;

			if (redoHorizontal || redoVertical) {

				chart.maxTicks = null; // reset for second pass
				each(axes, function (axis) {
					if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
						axis.setTickInterval(true); // update to reflect the new margins
					}
				});
				chart.getMargins(); // second pass to check for new labels
			}

			// Draw the borders and backgrounds
			chart.drawChartBox();		


			// Axes
			if (chart.hasCartesianSeries) {
				each(axes, function (axis) {
					axis.render();
				});
			}

			// The series
			if (!chart.seriesGroup) {
				chart.seriesGroup = renderer.g('series-group')
					.attr({ zIndex: 3 })
					.add();
			}
			chart.renderSeries();

			// Labels
			chart.renderLabels();

			// Credits
			chart.showCredits(options.credits);

			// Set flag
			chart.hasRendered = true;

		},

		/**
		 * Show chart credits based on config options
		 */
		showCredits: function (credits) {
			if (credits.enabled && !this.credits) {
				this.credits = this.renderer.text(
					credits.text,
					0,
					0
				)
				.on('click', function () {
					if (credits.href) {
						location.href = credits.href;
					}
				})
				.attr({
					align: credits.position.align,
					zIndex: 8
				})
				.css(credits.style)
				.add()
				.align(credits.position);
			}
		},

		/**
		 * Clean up memory usage
		 */
		destroy: function () {
			var chart = this,
				axes = chart.axes,
				series = chart.series,
				container = chart.container,
				i,
				parentNode = container && container.parentNode;
				
			// fire the chart.destoy event
			fireEvent(chart, 'destroy');
			
			// Delete the chart from charts lookup array
			charts[chart.index] = UNDEFINED;
			chartCount--;
			chart.renderTo.removeAttribute('data-highcharts-chart');

			// remove events
			removeEvent(chart);

			// ==== Destroy collections:
			// Destroy axes
			i = axes.length;
			while (i--) {
				axes[i] = axes[i].destroy();
			}

			// Destroy each series
			i = series.length;
			while (i--) {
				series[i] = series[i].destroy();
			}

			// ==== Destroy chart properties:
			each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 
					'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', 
					'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
				var prop = chart[name];

				if (prop && prop.destroy) {
					chart[name] = prop.destroy();
				}
			});

			// remove container and all SVG
			if (container) { // can break in IE when destroyed before finished loading
				container.innerHTML = '';
				removeEvent(container);
				if (parentNode) {
					discardElement(container);
				}

			}

			// clean it all up
			for (i in chart) {
				delete chart[i];
			}

		},


		/**
		 * VML namespaces can't be added until after complete. Listening
		 * for Perini's doScroll hack is not enough.
		 */
		isReadyToRender: function () {
			var chart = this;

			// Note: in spite of JSLint's complaints, win == win.top is required
			/*jslint eqeq: true*/
			if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {
			/*jslint eqeq: false*/
				if (useCanVG) {
					// Delay rendering until canvg library is downloaded and ready
					CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
				} else {
					doc.attachEvent('onreadystatechange', function () {
						doc.detachEvent('onreadystatechange', chart.firstRender);
						if (doc.readyState === 'complete') {
							chart.firstRender();
						}
					});
				}
				return false;
			}
			return true;
		},

		/**
		 * Prepare for first rendering after all data are loaded
		 */
		firstRender: function () {
			var chart = this,
				options = chart.options,
				callback = chart.callback;

			// Check whether the chart is ready to render
			if (!chart.isReadyToRender()) {
				return;
			}

			// Create the container
			chart.getContainer();

			// Run an early event after the container and renderer are established
			fireEvent(chart, 'init');

			
			chart.resetMargins();
			chart.setChartSize();

			// Set the common chart properties (mainly invert) from the given series
			chart.propFromSeries();

			// get axes
			chart.getAxes();

			// Initialize the series
			each(options.series || [], function (serieOptions) {
				chart.initSeries(serieOptions);
			});

			chart.linkSeries();

			// Run an event after axes and series are initialized, but before render. At this stage,
			// the series data is indexed and cached in the xData and yData arrays, so we can access
			// those before rendering. Used in Highstock. 
			fireEvent(chart, 'beforeRender'); 

			// depends on inverted and on margins being set
			if (Highcharts.Pointer) {
				chart.pointer = new Pointer(chart, options);
			}

			chart.render();

			// add canvas
			chart.renderer.draw();
			// run callbacks
			if (callback) {
				callback.apply(chart, [chart]);
			}
			each(chart.callbacks, function (fn) {
				if (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)
					fn.apply(chart, [chart]);
				}
			});
			
			// Fire the load event
			fireEvent(chart, 'load');		
			
			// If the chart was rendered outside the top container, put it back in (#3679)
			chart.cloneRenderTo(true);

		},

		/**
		* Creates arrays for spacing and margin from given options.
		*/
		splashArray: function (target, options) {
			var oVar = options[target],
				tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

			return [pick(options[target + 'Top'], tArray[0]),
					pick(options[target + 'Right'], tArray[1]),
					pick(options[target + 'Bottom'], tArray[2]),
					pick(options[target + 'Left'], tArray[3])];
		}
	}; // end Chart

	var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
		/**
		 * Get the center of the pie based on the size and center options relative to the  
		 * plot area. Borrowed by the polar and gauge series types.
		 */
		getCenter: function () {
			
			var options = this.options,
				chart = this.chart,
				slicingRoom = 2 * (options.slicedOffset || 0),
				handleSlicingRoom,
				plotWidth = chart.plotWidth - 2 * slicingRoom,
				plotHeight = chart.plotHeight - 2 * slicingRoom,
				centerOption = options.center,
				positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
				smallestSize = mathMin(plotWidth, plotHeight),
				isPercent,
				i,
				value;

			for (i = 0; i < 4; ++i) {
				value = positions[i];
				isPercent = /%$/.test(value);
				handleSlicingRoom = i < 2 || (i === 2 && isPercent);
				positions[i] = (isPercent ?
					// i == 0: centerX, relative to width
					// i == 1: centerY, relative to height
					// i == 2: size, relative to smallestSize
					// i == 3: innerSize, relative to size
					[plotWidth, plotHeight, smallestSize, positions[2]][i] *
						pInt(value) / 100 :
					pInt(value)) + (handleSlicingRoom ? slicingRoom : 0);
			}
			return positions;
		}
	};

	/**
	 * The Point object and prototype. Inheritable and used as base for PiePoint
	 */
	var Point = function () {};
	Point.prototype = {

		/**
		 * Initialize the point
		 * @param {Object} series The series object containing this point
		 * @param {Object} options The data in either number, array or object format
		 */
		init: function (series, options, x) {

			var point = this,
				colors;
			point.series = series;
			point.color = series.color; // #3445
			point.applyOptions(options, x);
			point.pointAttr = {};

			if (series.options.colorByPoint) {
				colors = series.options.colors || series.chart.options.colors;
				point.color = point.color || colors[series.colorCounter++];
				// loop back to zero
				if (series.colorCounter === colors.length) {
					series.colorCounter = 0;
				}
			}

			series.chart.pointCount++;
			return point;
		},
		/**
		 * Apply the options containing the x and y data and possible some extra properties.
		 * This is called on point init or from point.update.
		 *
		 * @param {Object} options
		 */
		applyOptions: function (options, x) {
			var point = this,
				series = point.series,
				pointValKey = series.options.pointValKey || series.pointValKey;

			options = Point.prototype.optionsToObject.call(this, options);

			// copy options directly to point
			extend(point, options);
			point.options = point.options ? extend(point.options, options) : options;

			// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
			if (pointValKey) {
				point.y = point[pointValKey];
			}

			// If no x is set by now, get auto incremented value. All points must have an
			// x value, however the y value can be null to create a gap in the series
			if (point.x === UNDEFINED && series) {
				point.x = x === UNDEFINED ? series.autoIncrement() : x;
			}

			return point;
		},

		/**
		 * Transform number or array configs into objects
		 */
		optionsToObject: function (options) {
			var ret = {},
				series = this.series,
				pointArrayMap = series.pointArrayMap || ['y'],
				valueCount = pointArrayMap.length,
				firstItemType,
				i = 0,
				j = 0;

			if (typeof options === 'number' || options === null) {
				ret[pointArrayMap[0]] = options;

			} else if (isArray(options)) {
				// with leading x value
				if (options.length > valueCount) {
					firstItemType = typeof options[0];
					if (firstItemType === 'string') {
						ret.name = options[0];
					} else if (firstItemType === 'number') {
						ret.x = options[0];
					}
					i++;
				}
				while (j < valueCount) {
					ret[pointArrayMap[j++]] = options[i++];
				}
			} else if (typeof options === 'object') {
				ret = options;

				// This is the fastest way to detect if there are individual point dataLabels that need
				// to be considered in drawDataLabels. These can only occur in object configs.
				if (options.dataLabels) {
					series._hasPointLabels = true;
				}

				// Same approach as above for markers
				if (options.marker) {
					series._hasPointMarkers = true;
				}
			}
			return ret;
		},

		/**
		 * Destroy a point to clear memory. Its reference still stays in series.data.
		 */
		destroy: function () {
			var point = this,
				series = point.series,
				chart = series.chart,
				hoverPoints = chart.hoverPoints,
				prop;

			chart.pointCount--;

			if (hoverPoints) {
				point.setState();
				erase(hoverPoints, point);
				if (!hoverPoints.length) {
					chart.hoverPoints = null;
				}

			}
			if (point === chart.hoverPoint) {
				point.onMouseOut();
			}

			// remove all events
			if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
				removeEvent(point);
				point.destroyElements();
			}

			if (point.legendItem) { // pies have legend items
				chart.legend.destroyItem(point);
			}

			for (prop in point) {
				point[prop] = null;
			}


		},

		/**
		 * Destroy SVG elements associated with the point
		 */
		destroyElements: function () {
			var point = this,
				props = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],
				prop,
				i = 6;
			while (i--) {
				prop = props[i];
				if (point[prop]) {
					point[prop] = point[prop].destroy();
				}
			}
		},

		/**
		 * Return the configuration hash needed for the data label and tooltip formatters
		 */
		getLabelConfig: function () {
			var point = this;
			return {
				x: point.category,
				y: point.y,
				key: point.name || point.category,
				series: point.series,
				point: point,
				percentage: point.percentage,
				total: point.total || point.stackTotal
			};
		},	

		/**
		 * Extendable method for formatting each point's tooltip line
		 *
		 * @return {String} A string to be concatenated in to the common tooltip text
		 */
		tooltipFormatter: function (pointFormat) {

			// Insert options for valueDecimals, valuePrefix, and valueSuffix
			var series = this.series,
				seriesTooltipOptions = series.tooltipOptions,
				valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
				valuePrefix = seriesTooltipOptions.valuePrefix || '',
				valueSuffix = seriesTooltipOptions.valueSuffix || '';

			// Loop over the point array map and replace unformatted values with sprintf formatting markup
			each(series.pointArrayMap || ['y'], function (key) {
				key = '{point.' + key; // without the closing bracket
				if (valuePrefix || valueSuffix) {
					pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
				}
				pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
			});

			return format(pointFormat, {
				point: this,
				series: this.series
			});
		},

		/**
		 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
		 * causes a name clash in MooTools
		 * @param {String} eventType
		 * @param {Object} eventArgs Additional event arguments
		 * @param {Function} defaultFunction Default event handler
		 */
		firePointEvent: function (eventType, eventArgs, defaultFunction) {
			var point = this,
				series = this.series,
				seriesOptions = series.options;

			// load event handlers on demand to save time on mouseover/out
			if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
				this.importEvents();
			}

			// add default handler if in selection mode
			if (eventType === 'click' && seriesOptions.allowPointSelect) {
				defaultFunction = function (event) {
					// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
					point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
				};
			}

			fireEvent(this, eventType, eventArgs, defaultFunction);
		}
	};/**
	 * @classDescription The base function which all other series types inherit from. The data in the series is stored
	 * in various arrays.
	 *
	 * - First, series.options.data contains all the original config options for
	 * each point whether added by options or methods like series.addPoint.
	 * - Next, series.data contains those values converted to points, but in case the series data length
	 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
	 * only contains the points that have been created on demand.
	 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
	 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
	 * compared to series.data and series.options.data. If however the series data is grouped, these can't
	 * be correlated one to one.
	 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
	 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
	 *
	 * @param {Object} chart
	 * @param {Object} options
	 */
	var Series = Highcharts.Series = function () {};

	Series.prototype = {

		isCartesian: true,
		type: 'line',
		pointClass: Point,
		sorted: true, // requires the data to be sorted
		requireSorting: true,
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'lineColor',
			'stroke-width': 'lineWidth',
			fill: 'fillColor',
			r: 'radius'
		},
		axisTypes: ['xAxis', 'yAxis'],
		colorCounter: 0,
		parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
		init: function (chart, options) {
			var series = this,
				eventType,
				events,
				chartSeries = chart.series,
				sortByIndex = function (a, b) {
					return pick(a.options.index, a._i) - pick(b.options.index, b._i);
				};

			series.chart = chart;
			series.options = options = series.setOptions(options); // merge with plotOptions
			series.linkedSeries = [];

			// bind the axes
			series.bindAxes();

			// set some variables
			extend(series, {
				name: options.name,
				state: NORMAL_STATE,
				pointAttr: {},
				visible: options.visible !== false, // true by default
				selected: options.selected === true // false by default
			});

			// special
			if (useCanVG) {
				options.animation = false;
			}

			// register event listeners
			events = options.events;
			for (eventType in events) {
				addEvent(series, eventType, events[eventType]);
			}
			if (
				(events && events.click) ||
				(options.point && options.point.events && options.point.events.click) ||
				options.allowPointSelect
			) {
				chart.runTrackerClick = true;
			}

			series.getColor();
			series.getSymbol();

			// Set the data
			each(series.parallelArrays, function (key) {
				series[key + 'Data'] = [];
			});
			series.setData(options.data, false);

			// Mark cartesian
			if (series.isCartesian) {
				chart.hasCartesianSeries = true;
			}

			// Register it in the chart
			chartSeries.push(series);
			series._i = chartSeries.length - 1;

			// Sort series according to index option (#248, #1123, #2456)
			stableSort(chartSeries, sortByIndex);
			if (this.yAxis) {
				stableSort(this.yAxis.series, sortByIndex);
			}

			each(chartSeries, function (series, i) {
				series.index = i;
				series.name = series.name || 'Series ' + (i + 1);
			});

		},

		/**
		 * Set the xAxis and yAxis properties of cartesian series, and register the series
		 * in the axis.series array
		 */
		bindAxes: function () {
			var series = this,
				seriesOptions = series.options,
				chart = series.chart,
				axisOptions;

			each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

				each(chart[AXIS], function (axis) { // loop through the chart's axis objects
					axisOptions = axis.options;

					// apply if the series xAxis or yAxis option mathches the number of the
					// axis, or if undefined, use the first axis
					if ((seriesOptions[AXIS] === axisOptions.index) ||
							(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

						// register this series in the axis.series lookup
						axis.series.push(series);

						// set this series.xAxis or series.yAxis reference
						series[AXIS] = axis;

						// mark dirty for redraw
						axis.isDirty = true;
					}
				});

				// The series needs an X and an Y axis
				if (!series[AXIS] && series.optionalAxis !== AXIS) {
					error(18, true);
				}

			});
		},

		/**
		 * For simple series types like line and column, the data values are held in arrays like
		 * xData and yData for quick lookup to find extremes and more. For multidimensional series
		 * like bubble and map, this can be extended with arrays like zData and valueData by
		 * adding to the series.parallelArrays array.
		 */
		updateParallelArrays: function (point, i) {
			var series = point.series,
				args = arguments,
				fn = typeof i === 'number' ?
					 // Insert the value in the given position
					function (key) {
						var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
						series[key + 'Data'][i] = val;
					} :
					// Apply the method specified in i with the following arguments as arguments
					function (key) {
						Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
					};

			each(series.parallelArrays, fn);
		},

		/**
		 * Return an auto incremented x value based on the pointStart and pointInterval options.
		 * This is only used if an x value is not given for the point that calls autoIncrement.
		 */
		autoIncrement: function () {

			var options = this.options,
				xIncrement = this.xIncrement,
				date,
				pointInterval,
				pointIntervalUnit = options.pointIntervalUnit;
			
			xIncrement = pick(xIncrement, options.pointStart, 0);
			
			this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
			
			// Added code for pointInterval strings
			if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {
				date = new Date(xIncrement);
				date = (pointIntervalUnit === 'month') ?
					+date[setMonth](date[getMonth]() + pointInterval) :
					+date[setFullYear](date[getFullYear]() + pointInterval);
				pointInterval = date - xIncrement;
			}
			
			this.xIncrement = xIncrement + pointInterval;
			return xIncrement;
		},

		/**
		 * Divide the series data into segments divided by null values.
		 */
		getSegments: function () {
			var series = this,
				lastNull = -1,
				segments = [],
				i,
				points = series.points,
				pointsLength = points.length;

			if (pointsLength) { // no action required for []

				// if connect nulls, just remove null points
				if (series.options.connectNulls) {
					i = pointsLength;
					while (i--) {
						if (points[i].y === null) {
							points.splice(i, 1);
						}
					}
					if (points.length) {
						segments = [points];
					}

				// else, split on null points
				} else {
					each(points, function (point, i) {
						if (point.y === null) {
							if (i > lastNull + 1) {
								segments.push(points.slice(lastNull + 1, i));
							}
							lastNull = i;
						} else if (i === pointsLength - 1) { // last value
							segments.push(points.slice(lastNull + 1, i + 1));
						}
					});
				}
			}

			// register it
			series.segments = segments;
		},

		/**
		 * Set the series options by merging from the options tree
		 * @param {Object} itemOptions
		 */
		setOptions: function (itemOptions) {
			var chart = this.chart,
				chartOptions = chart.options,
				plotOptions = chartOptions.plotOptions,
				userOptions = chart.userOptions || {},
				userPlotOptions = userOptions.plotOptions || {},
				typeOptions = plotOptions[this.type],
				options,
				zones;

			this.userOptions = itemOptions;

			// General series options take precedence over type options because otherwise, default
			// type options like column.animation would be overwritten by the general option.
			// But issues have been raised here (#3881), and the solution may be to distinguish 
			// between default option and userOptions like in the tooltip below.
			options = merge(
				typeOptions,
				plotOptions.series,
				itemOptions
			);

			// The tooltip options are merged between global and series specific options
			this.tooltipOptions = merge(
				defaultOptions.tooltip,
				defaultOptions.plotOptions[this.type].tooltip,
				userOptions.tooltip,
				userPlotOptions.series && userPlotOptions.series.tooltip,
				userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
				itemOptions.tooltip
			);

			// Delete marker object if not allowed (#1125)
			if (typeOptions.marker === null) {
				delete options.marker;
			}

			// Handle color zones
			this.zoneAxis = options.zoneAxis;
			zones = this.zones = (options.zones || []).slice();
			if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
				zones.push({
					value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
					color: options.negativeColor,
					fillColor: options.negativeFillColor
				});
			}
			if (zones.length) { // Push one extra zone for the rest
				if (defined(zones[zones.length - 1].value)) {
					zones.push({
						color: this.color,
						fillColor: this.fillColor
					});
				}
			}
			return options;
		},

		getCyclic: function (prop, value, defaults) {
			var i,
				userOptions = this.userOptions,
				indexName = '_' + prop + 'Index',
				counterName = prop + 'Counter';

			if (!value) {
				if (defined(userOptions[indexName])) { // after Series.update()
					i = userOptions[indexName];
				} else {
					userOptions[indexName] = i = this.chart[counterName] % defaults.length;
					this.chart[counterName] += 1;
				}
				value = defaults[i];
			}
			this[prop] = value;
		},

		/**
		 * Get the series' color
		 */
		getColor: function () {
			if (!this.options.colorByPoint) {
				this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
			}
		},
		/**
		 * Get the series' symbol
		 */
		getSymbol: function () {
			var seriesMarkerOption = this.options.marker;

			this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

			// don't substract radius in image symbols (#604)
			if (/^url/.test(this.symbol)) {
				seriesMarkerOption.radius = 0;
			}
		},

		drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

		/**
		 * Replace the series data with a new set of data
		 * @param {Object} data
		 * @param {Object} redraw
		 */
		setData: function (data, redraw, animation, updatePoints) {
			var series = this,
				oldData = series.points,
				oldDataLength = (oldData && oldData.length) || 0,
				dataLength,
				options = series.options,
				chart = series.chart,
				firstPoint = null,
				xAxis = series.xAxis,
				hasCategories = xAxis && !!xAxis.categories,
				i,
				turboThreshold = options.turboThreshold,
				pt,
				xData = this.xData,
				yData = this.yData,
				pointArrayMap = series.pointArrayMap,
				valueCount = pointArrayMap && pointArrayMap.length;

			data = data || [];
			dataLength = data.length;
			redraw = pick(redraw, true);

			// If the point count is the same as is was, just run Point.update which is
			// cheaper, allows animation, and keeps references to points.
			if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
				each(data, function (point, i) {
					oldData[i].update(point, false, null, false);
				});

			} else {

				// Reset properties
				series.xIncrement = null;
				series.pointRange = hasCategories ? 1 : options.pointRange;

				series.colorCounter = 0; // for series with colorByPoint (#1547)
				
				// Update parallel arrays
				each(this.parallelArrays, function (key) {
					series[key + 'Data'].length = 0;
				});

				// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
				// first value is tested, and we assume that all the rest are defined the same
				// way. Although the 'for' loops are similar, they are repeated inside each
				// if-else conditional for max performance.
				if (turboThreshold && dataLength > turboThreshold) {

					// find the first non-null point
					i = 0;
					while (firstPoint === null && i < dataLength) {
						firstPoint = data[i];
						i++;
					}


					if (isNumber(firstPoint)) { // assume all points are numbers
						var x = pick(options.pointStart, 0),
							pointInterval = pick(options.pointInterval, 1);

						for (i = 0; i < dataLength; i++) {
							xData[i] = x;
							yData[i] = data[i];
							x += pointInterval;
						}
						series.xIncrement = x;
					} else if (isArray(firstPoint)) { // assume all points are arrays
						if (valueCount) { // [x, low, high] or [x, o, h, l, c]
							for (i = 0; i < dataLength; i++) {
								pt = data[i];
								xData[i] = pt[0];
								yData[i] = pt.slice(1, valueCount + 1);
							}
						} else { // [x, y]
							for (i = 0; i < dataLength; i++) {
								pt = data[i];
								xData[i] = pt[0];
								yData[i] = pt[1];
							}
						}
					} else {
						error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
					}
				} else {
					for (i = 0; i < dataLength; i++) {
						if (data[i] !== UNDEFINED) { // stray commas in oldIE
							pt = { series: series };
							series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
							series.updateParallelArrays(pt, i);
							if (hasCategories && pt.name) {
								xAxis.names[pt.x] = pt.name; // #2046
							}
						}
					}
				}

				// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
				if (isString(yData[0])) {
					error(14, true);
				}

				series.data = [];
				series.options.data = data;
				//series.zData = zData;

				// destroy old points
				i = oldDataLength;
				while (i--) {
					if (oldData[i] && oldData[i].destroy) {
						oldData[i].destroy();
					}
				}

				// reset minRange (#878)
				if (xAxis) {
					xAxis.minRange = xAxis.userMinRange;
				}

				// redraw
				series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
				animation = false;
			}

			if (redraw) {
				chart.redraw(animation);
			}
		},

		/**
		 * Process the data by cropping away unused data points if the series is longer
		 * than the crop threshold. This saves computing time for lage series.
		 */
		processData: function (force) {
			var series = this,
				processedXData = series.xData, // copied during slice operation below
				processedYData = series.yData,
				dataLength = processedXData.length,
				croppedData,
				cropStart = 0,
				cropped,
				distance,
				closestPointRange,
				xAxis = series.xAxis,
				i, // loop variable
				options = series.options,
				cropThreshold = options.cropThreshold,
				isCartesian = series.isCartesian,
				xExtremes,
				min,
				max;

			// If the series data or axes haven't changed, don't go through this. Return false to pass
			// the message on to override methods like in data grouping.
			if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
				return false;
			}

			if (xAxis) {
				xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
				min = xExtremes.min;
				max = xExtremes.max;
			}

			// optionally filter out points outside the plot area
			if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
				
				// it's outside current extremes
				if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
					processedXData = [];
					processedYData = [];

				// only crop if it's actually spilling out
				} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
					croppedData = this.cropData(series.xData, series.yData, min, max);
					processedXData = croppedData.xData;
					processedYData = croppedData.yData;
					cropStart = croppedData.start;
					cropped = true;
				}
			}


			// Find the closest distance between processed points
			for (i = processedXData.length - 1; i >= 0; i--) {
				distance = processedXData[i] - processedXData[i - 1];
				
				if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
					closestPointRange = distance;

				// Unsorted data is not supported by the line tooltip, as well as data grouping and
				// navigation in Stock charts (#725) and width calculation of columns (#1900)
				} else if (distance < 0 && series.requireSorting) {
					error(15);
				}
			}

			// Record the properties
			series.cropped = cropped; // undefined or true
			series.cropStart = cropStart;
			series.processedXData = processedXData;
			series.processedYData = processedYData;

			if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
				series.pointRange = closestPointRange || 1;
			}
			series.closestPointRange = closestPointRange;

		},

		/**
		 * Iterate over xData and crop values between min and max. Returns object containing crop start/end
		 * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
		 */
		cropData: function (xData, yData, min, max) {
			var dataLength = xData.length,
				cropStart = 0,
				cropEnd = dataLength,
				cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
				i;

			// iterate up to find slice start
			for (i = 0; i < dataLength; i++) {
				if (xData[i] >= min) {
					cropStart = mathMax(0, i - cropShoulder);
					break;
				}
			}

			// proceed to find slice end
			for (; i < dataLength; i++) {
				if (xData[i] > max) {
					cropEnd = i + cropShoulder;
					break;
				}
			}

			return {
				xData: xData.slice(cropStart, cropEnd),
				yData: yData.slice(cropStart, cropEnd),
				start: cropStart,
				end: cropEnd
			};
		},


		/**
		 * Generate the data point after the data has been processed by cropping away
		 * unused points and optionally grouped in Highcharts Stock.
		 */
		generatePoints: function () {
			var series = this,
				options = series.options,
				dataOptions = options.data,
				data = series.data,
				dataLength,
				processedXData = series.processedXData,
				processedYData = series.processedYData,
				pointClass = series.pointClass,
				processedDataLength = processedXData.length,
				cropStart = series.cropStart || 0,
				cursor,
				hasGroupedData = series.hasGroupedData,
				point,
				points = [],
				i;

			if (!data && !hasGroupedData) {
				var arr = [];
				arr.length = dataOptions.length;
				data = series.data = arr;
			}

			for (i = 0; i < processedDataLength; i++) {
				cursor = cropStart + i;
				if (!hasGroupedData) {
					if (data[cursor]) {
						point = data[cursor];
					} else if (dataOptions[cursor] !== UNDEFINED) { // #970
						data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
					}
					points[i] = point;
				} else {
					// splat the y data in case of ohlc data array
					points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
				}
				points[i].index = cursor; // For faster access in Point.update
			}

			// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
			// swithching view from non-grouped data to grouped data (#637)
			if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
				for (i = 0; i < dataLength; i++) {
					if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
						i += processedDataLength;
					}
					if (data[i]) {
						data[i].destroyElements();
						data[i].plotX = UNDEFINED; // #1003
					}
				}
			}

			series.data = data;
			series.points = points;
		},

		/**
		 * Calculate Y extremes for visible data
		 */
		getExtremes: function (yData) {
			var xAxis = this.xAxis,
				yAxis = this.yAxis,
				xData = this.processedXData,
				yDataLength,
				activeYData = [],
				activeCounter = 0,
				xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
				xMin = xExtremes.min,
				xMax = xExtremes.max,
				validValue,
				withinRange,
				dataMin,
				dataMax,
				x,
				y,
				i,
				j;

			yData = yData || this.stackedYData || this.processedYData;
			yDataLength = yData.length;

			for (i = 0; i < yDataLength; i++) {

				x = xData[i];
				y = yData[i];

				// For points within the visible range, including the first point outside the
				// visible range, consider y extremes
				validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
				withinRange = this.getExtremesFromAll || this.cropped || ((xData[i + 1] || x) >= xMin &&
					(xData[i - 1] || x) <= xMax);

				if (validValue && withinRange) {

					j = y.length;
					if (j) { // array, like ohlc or range data
						while (j--) {
							if (y[j] !== null) {
								activeYData[activeCounter++] = y[j];
							}
						}
					} else {
						activeYData[activeCounter++] = y;
					}
				}
			}
			this.dataMin = pick(dataMin, arrayMin(activeYData));
			this.dataMax = pick(dataMax, arrayMax(activeYData));
		},

		/**
		 * Translate data points from raw data values to chart specific positioning data
		 * needed later in drawPoints, drawGraph and drawTracker.
		 */
		translate: function () {
			if (!this.processedXData) { // hidden series
				this.processData();
			}
			this.generatePoints();
			var series = this,
				options = series.options,
				stacking = options.stacking,
				xAxis = series.xAxis,
				categories = xAxis.categories,
				yAxis = series.yAxis,
				points = series.points,
				dataLength = points.length,
				hasModifyValue = !!series.modifyValue,
				i,
				pointPlacement = options.pointPlacement,
				dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
				threshold = options.threshold,
				plotX,
				plotY,
				lastPlotX,
				closestPointRangePx = Number.MAX_VALUE;

			// Translate each point
			for (i = 0; i < dataLength; i++) {
				var point = points[i],
					xValue = point.x,
					yValue = point.y,
					yBottom = point.low,
					stack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey],
					pointStack,
					stackValues;

				// Discard disallowed y values for log axes (#3434)
				if (yAxis.isLog && yValue !== null && yValue <= 0) {
					point.y = yValue = null;
					error(10);
				}

				// Get the plotX translation
				point.plotX = plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags'); // Math.round fixes #591


				// Calculate the bottom y value for stacked series
				if (stacking && series.visible && stack && stack[xValue]) {

					pointStack = stack[xValue];
					stackValues = pointStack.points[series.index + ',' + i];
					yBottom = stackValues[0];
					yValue = stackValues[1];

					if (yBottom === 0) {
						yBottom = pick(threshold, yAxis.min);
					}
					if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
						yBottom = null;
					}

					point.total = point.stackTotal = pointStack.total;
					point.percentage = pointStack.total && (point.y / pointStack.total * 100);
					point.stackY = yValue;

					// Place the stack label
					pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

				}

				// Set translated yBottom or remove it
				point.yBottom = defined(yBottom) ?
					yAxis.translate(yBottom, 0, 1, 0, 1) :
					null;

				// general hook, used for Highstock compare mode
				if (hasModifyValue) {
					yValue = series.modifyValue(yValue, point);
				}

				// Set the the plotY value, reset it for redraws
				point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
					mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
					UNDEFINED;
				point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
					plotX >= 0 && plotX <= xAxis.len;


				// Set client related positions for mouse tracking
				point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514

				point.negative = point.y < (threshold || 0);

				// some API data
				point.category = categories && categories[point.x] !== UNDEFINED ?
					categories[point.x] : point.x;

				// Determine auto enabling of markers (#3635)
				if (i) {
					closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
				}
				lastPlotX = plotX;

			}

			series.closestPointRangePx = closestPointRangePx;

			// now that we have the cropped data, build the segments
			series.getSegments();
		},

		/**
		 * Set the clipping for the series. For animated series it is called twice, first to initiate
		 * animating the clip then the second time without the animation to set the final clip.
		 */
		setClip: function (animation) {
			var chart = this.chart,
				renderer = chart.renderer,
				inverted = chart.inverted,
				seriesClipBox = this.clipBox,
				clipBox = seriesClipBox || chart.clipBox,
				sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),
				clipRect = chart[sharedClipKey],
				markerClipRect = chart[sharedClipKey + 'm'];

			// If a clipping rectangle with the same properties is currently present in the chart, use that.
			if (!clipRect) {

				// When animation is set, prepare the initial positions
				if (animation) { 
					clipBox.width = 0;

					chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
						-99, // include the width of the first marker
						inverted ? -chart.plotLeft : -chart.plotTop,
						99,
						inverted ? chart.chartWidth : chart.chartHeight
					);
				}
				chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
				
			}
			if (animation) {
				clipRect.count += 1;
			}

			if (this.options.clip !== false) {
				this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
				this.markerGroup.clip(markerClipRect);
				this.sharedClipKey = sharedClipKey;
			}

			// Remove the shared clipping rectancgle when all series are shown
			if (!animation) {
				clipRect.count -= 1;
				if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {
					if (!seriesClipBox) {
						chart[sharedClipKey] = chart[sharedClipKey].destroy();
					}
					if (chart[sharedClipKey + 'm']) {
						chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
					}
				}
			}
		},

		/**
		 * Animate in the series
		 */
		animate: function (init) {
			var series = this,
				chart = series.chart,
				clipRect,
				animation = series.options.animation,
				sharedClipKey;

			// Animation option is set to true
			if (animation && !isObject(animation)) {
				animation = defaultPlotOptions[series.type].animation;
			}

			// Initialize the animation. Set up the clipping rectangle.
			if (init) {

				series.setClip(animation);

			// Run the animation
			} else {
				sharedClipKey = this.sharedClipKey;
				clipRect = chart[sharedClipKey];
				if (clipRect) {
					clipRect.animate({
						width: chart.plotSizeX
					}, animation);
				}
				if (chart[sharedClipKey + 'm']) {
					chart[sharedClipKey + 'm'].animate({
						width: chart.plotSizeX + 99
					}, animation);
				}

				// Delete this function to allow it only once
				series.animate = null;
	 
			}
		},

		/**
		 * This runs after animation to land on the final plot clipping
		 */
		afterAnimate: function () {
			this.setClip();
			fireEvent(this, 'afterAnimate');
		},

		/**
		 * Draw the markers
		 */
		drawPoints: function () {
			var series = this,
				pointAttr,
				points = series.points,
				chart = series.chart,
				plotX,
				plotY,
				i,
				point,
				radius,
				symbol,
				isImage,
				graphic,
				options = series.options,
				seriesMarkerOptions = options.marker,
				seriesPointAttr = series.pointAttr[''],
				pointMarkerOptions,
				hasPointMarker,
				enabled,
				isInside,
				markerGroup = series.markerGroup,
				xAxis = series.xAxis,
				globallyEnabled = pick(
					seriesMarkerOptions.enabled, 
					xAxis.isRadial,
					series.closestPointRangePx > 2 * seriesMarkerOptions.radius
				);

			if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

				i = points.length;
				while (i--) {
					point = points[i];
					plotX = mathFloor(point.plotX); // #1843
					plotY = point.plotY;
					graphic = point.graphic;
					pointMarkerOptions = point.marker || {};
					hasPointMarker = !!point.marker;
					enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
					isInside = point.isInside;

					// only draw the point if y is defined
					if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

						// shortcuts
						pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
						radius = pointAttr.r;
						symbol = pick(pointMarkerOptions.symbol, series.symbol);
						isImage = symbol.indexOf('url') === 0;

						if (graphic) { // update
							graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
								.animate(extend({
									x: plotX - radius,
									y: plotY - radius
								}, graphic.symbolName ? { // don't apply to image symbols #507
									width: 2 * radius,
									height: 2 * radius
								} : {}));
						} else if (isInside && (radius > 0 || isImage)) {
							point.graphic = graphic = chart.renderer.symbol(
								symbol,
								plotX - radius,
								plotY - radius,
								2 * radius,
								2 * radius,
								hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
							)
							.attr(pointAttr)
							.add(markerGroup);
						}

					} else if (graphic) {
						point.graphic = graphic.destroy(); // #1269
					}
				}
			}

		},

		/**
		 * Convert state properties from API naming conventions to SVG attributes
		 *
		 * @param {Object} options API options object
		 * @param {Object} base1 SVG attribute object to inherit from
		 * @param {Object} base2 Second level SVG attribute object to inherit from
		 */
		convertAttribs: function (options, base1, base2, base3) {
			var conversion = this.pointAttrToOptions,
				attr,
				option,
				obj = {};

			options = options || {};
			base1 = base1 || {};
			base2 = base2 || {};
			base3 = base3 || {};

			for (attr in conversion) {
				option = conversion[attr];
				obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
			}
			return obj;
		},

		/**
		 * Get the state attributes. Each series type has its own set of attributes
		 * that are allowed to change on a point's state change. Series wide attributes are stored for
		 * all series, and additionally point specific attributes are stored for all
		 * points with individual marker options. If such options are not defined for the point,
		 * a reference to the series wide attributes is stored in point.pointAttr.
		 */
		getAttribs: function () {
			var series = this,
				seriesOptions = series.options,
				normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
				stateOptions = normalOptions.states,
				stateOptionsHover = stateOptions[HOVER_STATE],
				pointStateOptionsHover,
				seriesColor = series.color,
				seriesNegativeColor = series.options.negativeColor,
				normalDefaults = {
					stroke: seriesColor,
					fill: seriesColor
				},
				points = series.points || [], // #927
				i,
				point,
				seriesPointAttr = [],
				pointAttr,
				pointAttrToOptions = series.pointAttrToOptions,
				hasPointSpecificOptions = series.hasPointSpecificOptions,
				defaultLineColor = normalOptions.lineColor,
				defaultFillColor = normalOptions.fillColor,
				turboThreshold = seriesOptions.turboThreshold,
				zones = series.zones,
				zoneAxis = series.zoneAxis || 'y',
				attr,
				key;

			// series type specific modifications
			if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

				// if no hover radius is given, default to normal radius + 2
				stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
				stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

			} else { // column, bar, pie

				// if no hover color is given, brighten the normal color
				stateOptionsHover.color = stateOptionsHover.color ||
					Color(stateOptionsHover.color || seriesColor)
						.brighten(stateOptionsHover.brightness).get();

				// if no hover negativeColor is given, brighten the normal negativeColor
				stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
					Color(stateOptionsHover.negativeColor || seriesNegativeColor)
						.brighten(stateOptionsHover.brightness).get();
			}

			// general point attributes for the series normal state
			seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

			// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
			each([HOVER_STATE, SELECT_STATE], function (state) {
				seriesPointAttr[state] =
						series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
			});

			// set it
			series.pointAttr = seriesPointAttr;


			// Generate the point-specific attribute collections if specific point
			// options are given. If not, create a referance to the series wide point
			// attributes
			i = points.length;
			if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
				while (i--) {
					point = points[i];
					normalOptions = (point.options && point.options.marker) || point.options;
					if (normalOptions && normalOptions.enabled === false) {
						normalOptions.radius = 0;
					}

					if (zones.length) {
						var j = 0,
							threshold = zones[j];
						while (point[zoneAxis] >= threshold.value) {				
							threshold = zones[++j];
						}
						
						point.color = point.fillColor = threshold.color;
					}

					hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

					// check if the point has specific visual options
					if (point.options) {
						for (key in pointAttrToOptions) {
							if (defined(normalOptions[pointAttrToOptions[key]])) {
								hasPointSpecificOptions = true;
							}
						}
					}

					// a specific marker config object is defined for the individual point:
					// create it's own attribute collection
					if (hasPointSpecificOptions) {
						normalOptions = normalOptions || {};
						pointAttr = [];
						stateOptions = normalOptions.states || {}; // reassign for individual point
						pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

						// Handle colors for column and pies
						if (!seriesOptions.marker) { // column, bar, point
							// If no hover color is given, brighten the normal color. #1619, #2579
							pointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
								Color(point.color)
									.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
									.get();
						}

						// normal point state inherits series wide normal state
						attr = { color: point.color }; // #868
						if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
							attr.fillColor = point.color;
						}
						if (!defaultLineColor) {
							attr.lineColor = point.color; // Bubbles take point color, line markers use white
						}
						pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

						// inherit from point normal and series hover
						pointAttr[HOVER_STATE] = series.convertAttribs(
							stateOptions[HOVER_STATE],
							seriesPointAttr[HOVER_STATE],
							pointAttr[NORMAL_STATE]
						);

						// inherit from point normal and series hover
						pointAttr[SELECT_STATE] = series.convertAttribs(
							stateOptions[SELECT_STATE],
							seriesPointAttr[SELECT_STATE],
							pointAttr[NORMAL_STATE]
						);


					// no marker config object is created: copy a reference to the series-wide
					// attribute collection
					} else {
						pointAttr = seriesPointAttr;
					}

					point.pointAttr = pointAttr;
				}
			}
		},

		/**
		 * Clear DOM objects and free up memory
		 */
		destroy: function () {
			var series = this,
				chart = series.chart,
				issue134 = /AppleWebKit\/533/.test(userAgent),
				destroy,
				i,
				data = series.data || [],
				point,
				prop,
				axis;

			// add event hook
			fireEvent(series, 'destroy');

			// remove all events
			removeEvent(series);

			// erase from axes
			each(series.axisTypes || [], function (AXIS) {
				axis = series[AXIS];
				if (axis) {
					erase(axis.series, series);
					axis.isDirty = axis.forceRedraw = true;
				}
			});

			// remove legend items
			if (series.legendItem) {
				series.chart.legend.destroyItem(series);
			}

			// destroy all points with their elements
			i = data.length;
			while (i--) {
				point = data[i];
				if (point && point.destroy) {
					point.destroy();
				}
			}
			series.points = null;

			// Clear the animation timeout if we are destroying the series during initial animation
			clearTimeout(series.animationTimeout);

			// destroy all SVGElements associated to the series
			each(['area', 'graph', 'dataLabelsGroup', 'group', 'markerGroup', 'tracker',
					'graphNeg', 'areaNeg', 'posClip', 'negClip'], function (prop) {
				if (series[prop]) {

					// issue 134 workaround
					destroy = issue134 && prop === 'group' ?
						'hide' :
						'destroy';

					series[prop][destroy]();
				}
			});

			// remove from hoverSeries
			if (chart.hoverSeries === series) {
				chart.hoverSeries = null;
			}
			erase(chart.series, series);

			// clear all members
			for (prop in series) {
				delete series[prop];
			}
		},

		/**
		 * Return the graph path of a segment
		 */
		getSegmentPath: function (segment) {
			var series = this,
				segmentPath = [],
				step = series.options.step;

			// build the segment line
			each(segment, function (point, i) {

				var plotX = point.plotX,
					plotY = point.plotY,
					lastPoint;

				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

				} else {

					// moveTo or lineTo
					segmentPath.push(i ? L : M);

					// step line?
					if (step && i) {
						lastPoint = segment[i - 1];
						if (step === 'right') {
							segmentPath.push(
								lastPoint.plotX,
								plotY
							);

						} else if (step === 'center') {
							segmentPath.push(
								(lastPoint.plotX + plotX) / 2,
								lastPoint.plotY,
								(lastPoint.plotX + plotX) / 2,
								plotY
							);

						} else {
							segmentPath.push(
								plotX,
								lastPoint.plotY
							);
						}
					}

					// normal line to next point
					segmentPath.push(
						point.plotX,
						point.plotY
					);
				}
			});

			return segmentPath;
		},

		/**
		 * Get the graph path
		 */
		getGraphPath: function () {
			var series = this,
				graphPath = [],
				segmentPath,
				singlePoints = []; // used in drawTracker

			// Divide into segments and build graph and area paths
			each(series.segments, function (segment) {

				segmentPath = series.getSegmentPath(segment);

				// add the segment to the graph, or a single point for tracking
				if (segment.length > 1) {
					graphPath = graphPath.concat(segmentPath);
				} else {
					singlePoints.push(segment[0]);
				}
			});

			// Record it for use in drawGraph and drawTracker, and return graphPath
			series.singlePoints = singlePoints;
			series.graphPath = graphPath;

			return graphPath;

		},

		/**
		 * Draw the actual graph
		 */
		drawGraph: function () {
			var series = this,
				options = this.options,
				props = [['graph', options.lineColor || this.color, options.dashStyle]],
				lineWidth = options.lineWidth,
				roundCap = options.linecap !== 'square',
				graphPath = this.getGraphPath(),
				fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph
				zones = this.zones;

			each(zones, function (threshold, i) {
				props.push(['colorGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
			});
			
			// Draw the graph
			each(props, function (prop, i) {
				var graphKey = prop[0],
					graph = series[graphKey],
					attribs;

				if (graph) {
					stop(graph); // cancel running animations, #459
					graph.animate({ d: graphPath });

				} else if ((lineWidth || fillColor) && graphPath.length) { // #1487
					attribs = {
						stroke: prop[1],
						'stroke-width': lineWidth,
						fill: fillColor,
						zIndex: 1 // #1069
					};
					if (prop[2]) {
						attribs.dashstyle = prop[2];
					} else if (roundCap) {
						attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
					}

					series[graphKey] = series.chart.renderer.path(graphPath)
						.attr(attribs)
						.add(series.group)
						.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
				}
			});
		},

		/**
		 * Clip the graphs into the positive and negative coloured graphs
		 */
		applyZones: function () {
			var series = this,
				chart = this.chart,
				renderer = chart.renderer,
				zones = this.zones,
				translatedFrom,
				translatedTo,
				clips = this.clips || [],
				clipAttr,
				graph = this.graph,
				area = this.area,
				chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
				zoneAxis = this.zoneAxis || 'y',
				axis = this[zoneAxis + 'Axis'],
				reversed = axis.reversed,
				horiz = axis.horiz,
				ignoreZones = false;

			if (zones.length && (graph || area)) {
				// The use of the Color Threshold assumes there are no gaps
				// so it is safe to hide the original graph and area
				graph.hide();
				if (area) { area.hide(); }

				// Create the clips
				each(zones, function (threshold, i) {
					translatedFrom = pick(translatedTo, (reversed ? (horiz ? chart.plotWidth : 0) : (horiz ? 0 : axis.toPixels(axis.min))));
					translatedTo = mathRound(axis.toPixels(pick(threshold.value, axis.max), true));

					if (ignoreZones) {
						translatedFrom = translatedTo = axis.toPixels(axis.max);
					}

					if (axis.isXAxis) {
						clipAttr = {
							x: reversed ? translatedTo : translatedFrom,
							y: 0,
							width: Math.abs(translatedFrom - translatedTo), 
							height: chartSizeMax
						};
						if (!horiz) {
							clipAttr.x = chart.plotHeight - clipAttr.x;
						}
					} else {
						clipAttr = {
							x: 0,
							y: reversed ? translatedFrom : translatedTo,
							width: chartSizeMax, 
							height: Math.abs(translatedFrom - translatedTo)
						};
						if (horiz) {
							clipAttr.y = chart.plotWidth - clipAttr.y;
						}
					} 

					/// VML SUPPPORT
					if (chart.inverted && renderer.isVML) {
						if (axis.isXAxis) {			
							clipAttr = {
								x: 0,
								y: reversed ? translatedFrom : translatedTo,
								height: clipAttr.width,
								width: chart.chartWidth
							};		
						} else {				
							clipAttr = {
								x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
								y: 0,
								width: clipAttr.height,
								height: chart.chartHeight
							};	
						}				
					}
					/// END OF VML SUPPORT

					if (clips[i]) {
						clips[i].animate(clipAttr);
					} else {
						clips[i] = renderer.clipRect(clipAttr);

						series['colorGraph' + i].clip(clips[i]);

						if (area) {
							series['colorArea' + i].clip(clips[i]);
						}
					}
					// if this zone extends out of the axis, ignore the others
					ignoreZones = threshold.value > axis.max;
				});
				this.clips = clips;
			}
		},

		/**
		 * Initialize and perform group inversion on series.group and series.markerGroup
		 */
		invertGroups: function () {
			var series = this,
				chart = series.chart;

			// Pie, go away (#1736)
			if (!series.xAxis) {
				return;
			}

			// A fixed size is needed for inversion to work
			function setInvert() {
				var size = {
					width: series.yAxis.len,
					height: series.xAxis.len
				};

				each(['group', 'markerGroup'], function (groupName) {
					if (series[groupName]) {
						series[groupName].attr(size).invert();
					}
				});
			}

			addEvent(chart, 'resize', setInvert); // do it on resize
			addEvent(series, 'destroy', function () {
				removeEvent(chart, 'resize', setInvert);
			});

			// Do it now
			setInvert(); // do it now

			// On subsequent render and redraw, just do setInvert without setting up events again
			series.invertGroups = setInvert;
		},

		/**
		 * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
		 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
		 */
		plotGroup: function (prop, name, visibility, zIndex, parent) {
			var group = this[prop],
				isNew = !group;

			// Generate it on first call
			if (isNew) {
				this[prop] = group = this.chart.renderer.g(name)
					.attr({
						visibility: visibility,
						zIndex: zIndex || 0.1 // IE8 needs this
					})
					.add(parent);
			}
			// Place it on first and subsequent (redraw) calls
			group[isNew ? 'attr' : 'animate'](this.getPlotBox());
			return group;
		},

		/**
		 * Get the translation and scale for the plot area of this series
		 */
		getPlotBox: function () {
			var chart = this.chart,
				xAxis = this.xAxis,
				yAxis = this.yAxis;

			// Swap axes for inverted (#2339)
			if (chart.inverted) {
				xAxis = yAxis;
				yAxis = this.xAxis;
			}
			return {
				translateX: xAxis ? xAxis.left : chart.plotLeft,
				translateY: yAxis ? yAxis.top : chart.plotTop,
				scaleX: 1, // #1623
				scaleY: 1
			};
		},

		/**
		 * Render the graph and markers
		 */
		render: function () {
			var series = this,
				chart = series.chart,
				group,
				options = series.options,
				animation = options.animation,
				// Animation doesn't work in IE8 quirks when the group div is hidden,
				// and looks bad in other oldIE
				animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,
				visibility = series.visible ? VISIBLE : HIDDEN,
				zIndex = options.zIndex,
				hasRendered = series.hasRendered,
				chartSeriesGroup = chart.seriesGroup;

			// the group
			group = series.plotGroup(
				'group',
				'series',
				visibility,
				zIndex,
				chartSeriesGroup
			);

			series.markerGroup = series.plotGroup(
				'markerGroup',
				'markers',
				visibility,
				zIndex,
				chartSeriesGroup
			);

			// initiate the animation
			if (animDuration) {
				series.animate(true);
			}

			// cache attributes for shapes
			series.getAttribs();

			// SVGRenderer needs to know this before drawing elements (#1089, #1795)
			group.inverted = series.isCartesian ? chart.inverted : false;

			// draw the graph if any
			if (series.drawGraph) {
				series.drawGraph();
				series.applyZones();
			}

			each(series.points, function (point) {
				if (point.redraw) {
					point.redraw();
				}
			});

			// draw the data labels (inn pies they go before the points)
			if (series.drawDataLabels) {
				series.drawDataLabels();
			}

			// draw the points
			if (series.visible) {
				series.drawPoints();
			}


			// draw the mouse tracking area
			if (series.drawTracker && series.options.enableMouseTracking !== false) {
				series.drawTracker();
			}

			// Handle inverted series and tracker groups
			if (chart.inverted) {
				series.invertGroups();
			}

			// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
			if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
				group.clip(chart.clipRect);
			}

			// Run the animation
			if (animDuration) {
				series.animate();
			} 

			// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
			// which should be available to the user).
			if (!hasRendered) {
				if (animDuration) {
					series.animationTimeout = setTimeout(function () {
						series.afterAnimate();
					}, animDuration);
				} else {
					series.afterAnimate();
				}
			}

			series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
			// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
			series.hasRendered = true;
		},

		/**
		 * Redraw the series after an update in the axes.
		 */
		redraw: function () {
			var series = this,
				chart = series.chart,
				wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
				wasDirty = series.isDirty,
				group = series.group,
				xAxis = series.xAxis,
				yAxis = series.yAxis;

			// reposition on resize
			if (group) {
				if (chart.inverted) {
					group.attr({
						width: chart.plotWidth,
						height: chart.plotHeight
					});
				}

				group.animate({
					translateX: pick(xAxis && xAxis.left, chart.plotLeft),
					translateY: pick(yAxis && yAxis.top, chart.plotTop)
				});
			}

			series.translate();
			series.render();
			if (wasDirtyData) {
				fireEvent(series, 'updatedData');
			}
			if (wasDirty || wasDirtyData) {			// #3945 recalculate the kdtree when dirty
				delete this.kdTree; // #3868 recalculate the kdtree with dirty data
			}
		},

		/**
		 * KD Tree && PointSearching Implementation
		 */

		kdDimensions: 1,
		kdTree: null,
		kdAxisArray: ['clientX', 'plotY'],
		kdComparer: 'distX',

		searchPoint: function (e) {
			var series = this,
				xAxis = series.xAxis,
				yAxis = series.yAxis,
				inverted = series.chart.inverted;
			
			return this.searchKDTree({
				clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
				plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
			});
		},

		buildKDTree: function () {
			var series = this,
				dimensions = series.kdDimensions;

			// Internal function
			function _kdtree(points, depth, dimensions) {
				var axis, median, length = points && points.length;

				if (length) {

					// alternate between the axis
					axis = series.kdAxisArray[depth % dimensions];

					// sort point array
					points.sort(function(a, b) {
						return a[axis] - b[axis];
					});
				
					median = Math.floor(length / 2);
					
					// build and return node
					return {
						point: points[median],
						left: _kdtree(points.slice(0, median), depth + 1, dimensions),
						right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
					};
				
				}
			}

			// Start the recursive build process with a clone of the points array and null points filtered out (#3873)
			function startRecursive() {
				var points = grep(series.points, function (point) {
					return point.y !== null;
				});
				series.kdTree = _kdtree(points, dimensions, dimensions);		
			}

			delete series.kdTree;
			
			if (series.options.kdSync) {  // For testing tooltips, don't build async
				startRecursive();
			} else {
				setTimeout(startRecursive);
			}
		},

		searchKDTree: function (point) {
			var series = this,
				kdComparer = this.kdComparer,
				kdX = this.kdAxisArray[0],
				kdY = this.kdAxisArray[1];

			// Internal function
			function _distance(p1, p2) {
				var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
					y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
					r = (x || 0) + (y || 0);
					
				return {
					distX: defined(x) ? Math.sqrt(x) : Number.MAX_VALUE,
					distY: defined(y) ? Math.sqrt(y) : Number.MAX_VALUE,
					distR: defined(r) ? Math.sqrt(r) : Number.MAX_VALUE
				};
			}
			function _search(search, tree, depth, dimensions) {
				var point = tree.point,
					axis = series.kdAxisArray[depth % dimensions],
					tdist,
					sideA,
					sideB,
					ret = point,
					nPoint1,
					nPoint2;
				point.dist = _distance(search, point);

				// Pick side based on distance to splitting point
				tdist = search[axis] - point[axis];
				sideA = tdist < 0 ? 'left' : 'right';

				// End of tree
				if (tree[sideA]) {
					nPoint1 =_search(search, tree[sideA], depth + 1, dimensions);

					ret = (nPoint1.dist[kdComparer] < ret.dist[kdComparer] ? nPoint1 : point);

					sideB = tdist < 0 ? 'right' : 'left';
					if (tree[sideB]) {
						// compare distance to current best to splitting point to decide wether to check side B or not
						if (Math.sqrt(tdist*tdist) < ret.dist[kdComparer]) {
							nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
							ret = (nPoint2.dist[kdComparer] < ret.dist[kdComparer] ? nPoint2 : ret);
						}
					}
				}
				return ret;
			}

			if (!this.kdTree) {
				this.buildKDTree();
			}

			if (this.kdTree) {
				return _search(point, 
					this.kdTree, this.kdDimensions, this.kdDimensions);
			}
		}

	}; // end Series prototype

	/**
	 * The class for stack items
	 */
	function StackItem(axis, options, isNegative, x, stackOption) {
		
		var inverted = axis.chart.inverted;

		this.axis = axis;

		// Tells if the stack is negative
		this.isNegative = isNegative;

		// Save the options to be able to style the label
		this.options = options;

		// Save the x value to be able to position the label later
		this.x = x;

		// Initialize total value
		this.total = null;

		// This will keep each points' extremes stored by series.index and point index
		this.points = {};

		// Save the stack option on the series configuration object, and whether to treat it as percent
		this.stack = stackOption;

		// The align options and text align varies on whether the stack is negative and
		// if the chart is inverted or not.
		// First test the user supplied value, then use the dynamic.
		this.alignOptions = {
			align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
			verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
			y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
			x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
		};

		this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
	}

	StackItem.prototype = {
		destroy: function () {
			destroyObjectProperties(this, this.axis);
		},

		/**
		 * Renders the stack total label and adds it to the stack label group.
		 */
		render: function (group) {
			var options = this.options,
				formatOption = options.format,
				str = formatOption ?
					format(formatOption, this) : 
					options.formatter.call(this);  // format the text in the label

			// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
			if (this.label) {
				this.label.attr({text: str, visibility: HIDDEN});
			// Create new label
			} else {
				this.label =
					this.axis.chart.renderer.text(str, null, null, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries
						.css(options.style)				// apply style
						.attr({
							align: this.textAlign,				// fix the text-anchor
							rotation: options.rotation,	// rotation
							visibility: HIDDEN					// hidden until setOffset is called
						})				
						.add(group);							// add to the labels-group
			}
		},

		/**
		 * Sets the offset that the stack has from the x value and repositions the label.
		 */
		setOffset: function (xOffset, xWidth) {
			var stackItem = this,
				axis = stackItem.axis,
				chart = axis.chart,
				inverted = chart.inverted,
				neg = this.isNegative,							// special treatment is needed for negative stacks
				y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
				yZero = axis.translate(0),						// stack origin
				h = mathAbs(y - yZero),							// stack height
				x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position
				plotHeight = chart.plotHeight,
				stackBox = {	// this is the box for the complete stack
					x: inverted ? (neg ? y : y - h) : x,
					y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
					width: inverted ? h : xWidth,
					height: inverted ? xWidth : h
				},
				label = this.label,
				alignAttr;
			
			if (label) {
				label.align(this.alignOptions, null, stackBox);	// align the label to the box
					
				// Set visibility (#678)
				alignAttr = label.alignAttr;
				label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
			}
		}
	};


	// Stacking methods defined on the Axis prototype

	/**
	 * Build the stacks from top down
	 */
	Axis.prototype.buildStacks = function () {
		var series = this.series,
			reversedStacks = pick(this.options.reversedStacks, true),
			i = series.length;
		if (!this.isXAxis) {
			this.usePercentage = false;
			while (i--) {
				series[reversedStacks ? i : series.length - i - 1].setStackedPoints();
			}
			// Loop up again to compute percent stack
			if (this.usePercentage) {
				for (i = 0; i < series.length; i++) {
					series[i].setPercentStacks();
				}
			}
		}
	};

	Axis.prototype.renderStackTotals = function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			stacks = axis.stacks,
			stackKey, 
			oneStack, 
			stackCategory,
			stackTotalGroup = axis.stackTotalGroup;

		// Create a separate group for the stack total labels
		if (!stackTotalGroup) {
			axis.stackTotalGroup = stackTotalGroup =
				renderer.g('stack-labels')
					.attr({
						visibility: VISIBLE,
						zIndex: 6
					})
					.add();
		}

		// plotLeft/Top will change when y axis gets wider so we need to translate the
		// stackTotalGroup at every render call. See bug #506 and #516
		stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

		// Render each stack total
		for (stackKey in stacks) {
			oneStack = stacks[stackKey];
			for (stackCategory in oneStack) {
				oneStack[stackCategory].render(stackTotalGroup);
			}
		}
	};


	// Stacking methods defnied for Series prototype

	/**
	 * Adds series' points value to corresponding stack
	 */
	Series.prototype.setStackedPoints = function () {
		if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
			return;
		}

		var series = this,
			xData = series.processedXData,
			yData = series.processedYData,
			stackedYData = [],
			yDataLength = yData.length,
			seriesOptions = series.options,
			threshold = seriesOptions.threshold,
			stackOption = seriesOptions.stack,
			stacking = seriesOptions.stacking,
			stackKey = series.stackKey,
			negKey = '-' + stackKey,
			negStacks = series.negStacks,
			yAxis = series.yAxis,
			stacks = yAxis.stacks,
			oldStacks = yAxis.oldStacks,
			isNegative,
			stack,
			other,
			key,
			pointKey,
			i,
			x,
			y;

		// loop over the non-null y values and read them into a local array
		for (i = 0; i < yDataLength; i++) {
			x = xData[i];
			y = yData[i];
			pointKey = series.index + ',' + i;

			// Read stacked values into a stack based on the x value,
			// the sign of y and the stack key. Stacking is also handled for null values (#739)
			isNegative = negStacks && y < threshold;
			key = isNegative ? negKey : stackKey;

			// Create empty object for this stack if it doesn't exist yet
			if (!stacks[key]) {
				stacks[key] = {};
			}

			// Initialize StackItem for this x
			if (!stacks[key][x]) {
				if (oldStacks[key] && oldStacks[key][x]) {
					stacks[key][x] = oldStacks[key][x];
					stacks[key][x].total = null;
				} else {
					stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
				}
			}

			// If the StackItem doesn't exist, create it first
			stack = stacks[key][x];
			stack.points[pointKey] = [stack.cum || 0];

			// Add value to the stack total
			if (stacking === 'percent') {

				// Percent stacked column, totals are the same for the positive and negative stacks
				other = isNegative ? stackKey : negKey;
				if (negStacks && stacks[other] && stacks[other][x]) {
					other = stacks[other][x];
					stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

				// Percent stacked areas
				} else {
					stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
				}
			} else {
				stack.total = correctFloat(stack.total + (y || 0));
			}

			stack.cum = (stack.cum || 0) + (y || 0);

			stack.points[pointKey].push(stack.cum);
			stackedYData[i] = stack.cum;

		}

		if (stacking === 'percent') {
			yAxis.usePercentage = true;
		}

		this.stackedYData = stackedYData; // To be used in getExtremes

		// Reset old stacks
		yAxis.oldStacks = {};
	};

	/**
	 * Iterate over all stacks and compute the absolute values to percent
	 */
	Series.prototype.setPercentStacks = function () {
		var series = this,
			stackKey = series.stackKey,
			stacks = series.yAxis.stacks,
			processedXData = series.processedXData;

		each([stackKey, '-' + stackKey], function (key) {
			var i = processedXData.length,
				x,
				stack,
				pointExtremes,
				totalFactor;

			while (i--) {
				x = processedXData[i];
				stack = stacks[key] && stacks[key][x];
				pointExtremes = stack && stack.points[series.index + ',' + i];
				if (pointExtremes) {
					totalFactor = stack.total ? 100 / stack.total : 0;
					pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
					pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
					series.stackedYData[i] = pointExtremes[1];
				}
			}
		});
	};

	// Extend the Chart prototype for dynamic methods
	extend(Chart.prototype, {

		/**
		 * Add a series dynamically after  time
		 *
		 * @param {Object} options The config options
		 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 *
		 * @return {Object} series The newly created series object
		 */
		addSeries: function (options, redraw, animation) {
			var series,
				chart = this;

			if (options) {
				redraw = pick(redraw, true); // defaults to true

				fireEvent(chart, 'addSeries', { options: options }, function () {
					series = chart.initSeries(options);

					chart.isDirtyLegend = true; // the series array is out of sync with the display
					chart.linkSeries();
					if (redraw) {
						chart.redraw(animation);
					}
				});
			}

			return series;
		},

		/**
	     * Add an axis to the chart
	     * @param {Object} options The axis option
	     * @param {Boolean} isX Whether it is an X axis or a value axis
	     */
		addAxis: function (options, isX, redraw, animation) {
			var key = isX ? 'xAxis' : 'yAxis',
				chartOptions = this.options,
				axis;

			/*jslint unused: false*/
			axis = new Axis(this, merge(options, {
				index: this[key].length,
				isX: isX
			}));
			/*jslint unused: true*/

			// Push the new axis options to the chart options
			chartOptions[key] = splat(chartOptions[key] || {});
			chartOptions[key].push(options);

			if (pick(redraw, true)) {
				this.redraw(animation);
			}
		},

		/**
		 * Dim the chart and show a loading text or symbol
		 * @param {String} str An optional text to show in the loading label instead of the default one
		 */
		showLoading: function (str) {
			var chart = this,
				options = chart.options,
				loadingDiv = chart.loadingDiv,
				loadingOptions = options.loading,
				setLoadingSize = function () {
					if (loadingDiv) {
						css(loadingDiv, {
							left: chart.plotLeft + PX,
							top: chart.plotTop + PX,
							width: chart.plotWidth + PX,
							height: chart.plotHeight + PX
						});
					}
				};

			// create the layer at the first call
			if (!loadingDiv) {
				chart.loadingDiv = loadingDiv = createElement(DIV, {
					className: PREFIX + 'loading'
				}, extend(loadingOptions.style, {
					zIndex: 10,
					display: NONE
				}), chart.container);

				chart.loadingSpan = createElement(
					'span',
					null,
					loadingOptions.labelStyle,
					loadingDiv
				);
				addEvent(chart, 'redraw', setLoadingSize); // #1080
			}

			// update text
			chart.loadingSpan.innerHTML = str || options.lang.loading;

			// show it
			if (!chart.loadingShown) {
				css(loadingDiv, {
					opacity: 0,
					display: ''				
				});
				animate(loadingDiv, {
					opacity: loadingOptions.style.opacity
				}, {
					duration: loadingOptions.showDuration || 0
				});
				chart.loadingShown = true;
			}
			setLoadingSize();
		},

		/**
		 * Hide the loading layer
		 */
		hideLoading: function () {
			var options = this.options,
				loadingDiv = this.loadingDiv;

			if (loadingDiv) {
				animate(loadingDiv, {
					opacity: 0
				}, {
					duration: options.loading.hideDuration || 100,
					complete: function () {
						css(loadingDiv, { display: NONE });
					}
				});
			}
			this.loadingShown = false;
		}
	});

	// extend the Point prototype for dynamic methods
	extend(Point.prototype, {
		/**
		 * Update the point with new options (typically x/y data) and optionally redraw the series.
		 *
		 * @param {Object} options Point options as defined in the series.data array
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 *
		 */
		update: function (options, redraw, animation, runEvent) {
			var point = this,
				series = point.series,
				graphic = point.graphic,
				i,
				chart = series.chart,
				seriesOptions = series.options,
				names = series.xAxis && series.xAxis.names;

			redraw = pick(redraw, true);

			function update() {

				point.applyOptions(options);

				// Update visuals
				if (isObject(options) && !isArray(options)) {
					// Defer the actual redraw until getAttribs has been called (#3260)
					point.redraw = function () {
						if (graphic) {
							if (options && options.marker && options.marker.symbol) {
								point.graphic = graphic.destroy();
							} else {
								graphic.attr(point.pointAttr[point.state || '']);
							}
						}
						if (options && options.dataLabels && point.dataLabel) { // #2468
							point.dataLabel = point.dataLabel.destroy();
						}
						point.redraw = null;
					};
				}

				// record changes in the parallel arrays
				i = point.index;
				series.updateParallelArrays(point, i);
				if (names && point.name) {
					names[point.x] = point.name;
				}

				seriesOptions.data[i] = point.options;

				// redraw
				series.isDirty = series.isDirtyData = true;
				if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
					chart.isDirtyBox = true;
				}

				if (chart.legend.display && seriesOptions.legendType === 'point') { // #1831, #1885, #3934
					series.updateTotals();
					chart.legend.clearItems();
				}
				if (redraw) {
					chart.redraw(animation);
				}
			}

			// Fire the event with a default handler of doing the update
			if (runEvent === false) { // When called from setData
				update();
			} else {
				point.firePointEvent('update', { options: options }, update);
			}
		},

		/**
		 * Remove a point and optionally redraw the series and if necessary the axes
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		remove: function (redraw, animation) {
			this.series.removePoint(inArray(this, this.series.data), redraw, animation);
		}
	});

	// Extend the series prototype for dynamic methods
	extend(Series.prototype, {
		/**
		 * Add a point dynamically after chart load time
		 * @param {Object} options Point options as given in series.data
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean} shift If shift is true, a point is shifted off the start
		 *    of the series as one is appended to the end.
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		addPoint: function (options, redraw, shift, animation) {
			var series = this,
				seriesOptions = series.options,
				data = series.data,
				graph = series.graph,
				area = series.area,
				chart = series.chart,
				names = series.xAxis && series.xAxis.names,
				currentShift = (graph && graph.shift) || 0,
				dataOptions = seriesOptions.data,
				point,
				isInTheMiddle,
				xData = series.xData,
				x,
				i;

			setAnimation(animation, chart);

			// Make graph animate sideways
			if (shift) {
				each([graph, area, series.graphNeg, series.areaNeg], function (shape) {
					if (shape) {
						shape.shift = currentShift + 1;
					}
				});
			}
			if (area) {
				area.isArea = true; // needed in animation, both with and without shift
			}

			// Optional redraw, defaults to true
			redraw = pick(redraw, true);

			// Get options and push the point to xData, yData and series.options. In series.generatePoints
			// the Point instance will be created on demand and pushed to the series.data array.
			point = { series: series };
			series.pointClass.prototype.applyOptions.apply(point, [options]);
			x = point.x;

			// Get the insertion point
			i = xData.length;
			if (series.requireSorting && x < xData[i - 1]) {
				isInTheMiddle = true;
				while (i && xData[i - 1] > x) {
					i--;
				}
			}

			series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
			series.updateParallelArrays(point, i); // update it

			if (names && point.name) {
				names[x] = point.name;
			}
			dataOptions.splice(i, 0, options);

			if (isInTheMiddle) {
				series.data.splice(i, 0, null);
				series.processData();
			}

			// Generate points to be added to the legend (#1329)
			if (seriesOptions.legendType === 'point') {
				series.generatePoints();
			}

			// Shift the first point off the parallel arrays
			// todo: consider series.removePoint(i) method
			if (shift) {
				if (data[0] && data[0].remove) {
					data[0].remove(false);
				} else {
					data.shift();
					series.updateParallelArrays(point, 'shift');

					dataOptions.shift();
				}
			}

			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				series.getAttribs(); // #1937
				chart.redraw();
			}
		},

		/**
		 * Remove a point (rendered or not), by index
		 */
		removePoint: function (i, redraw, animation) {

			var series = this,
				data = series.data,
				point = data[i],
				points = series.points,
				chart = series.chart,
				remove = function () {

					if (data.length === points.length) {
						points.splice(i, 1);
					}
					data.splice(i, 1);
					series.options.data.splice(i, 1);
					series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

					if (point) {
						point.destroy();
					}

					// redraw
					series.isDirty = true;
					series.isDirtyData = true;
					if (redraw) {
						chart.redraw();
					}
				};

			setAnimation(animation, chart);
			redraw = pick(redraw, true);

			// Fire the event with a default handler of removing the point
			if (point) {
				point.firePointEvent('remove', null, remove);
			} else {
				remove();
			}
		},

		/**
		 * Remove a series and optionally redraw the chart
		 *
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */

		remove: function (redraw, animation) {
			var series = this,
				chart = series.chart;
			redraw = pick(redraw, true);

			if (!series.isRemoving) {  /* prevent triggering native event in jQuery
					(calling the remove function from the remove event) */
				series.isRemoving = true;

				// fire the event with a default handler of removing the point
				fireEvent(series, 'remove', null, function () {


					// destroy elements
					series.destroy();


					// redraw
					chart.isDirtyLegend = chart.isDirtyBox = true;
					chart.linkSeries();

					if (redraw) {
						chart.redraw(animation);
					}
				});

			}
			series.isRemoving = false;
		},

		/**
		 * Update the series with a new set of options
		 */
		update: function (newOptions, redraw) {
			var series = this,
				chart = this.chart,
				// must use user options when changing type because this.options is merged
				// in with type specific plotOptions
				oldOptions = this.userOptions,
				oldType = this.type,
				proto = seriesTypes[oldType].prototype,
				preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
				n;

			// If we're changing type or zIndex, create new groups (#3380, #3404)
			if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
				preserve.length = 0;
			}

			// Make sure groups are not destroyed (#3094)
			each(preserve, function (prop) {
				preserve[prop] = series[prop];
				delete series[prop];
			});

			// Do the merge, with some forced options
			newOptions = merge(oldOptions, {
				animation: false,
				index: this.index,
				pointStart: this.xData[0] // when updating after addPoint
			}, { data: this.options.data }, newOptions);

			// Destroy the series and delete all properties. Reinsert all methods 
			// and properties from the new type prototype (#2270, #3719)
			this.remove(false);
			for (n in proto) {
				this[n] = UNDEFINED;
			}
			extend(this, seriesTypes[newOptions.type || oldType].prototype);

			// Re-register groups (#3094)
			each(preserve, function (prop) {
				series[prop] = preserve[prop];
			});

			this.init(chart, newOptions);
			chart.linkSeries(); // Links are lost in this.remove (#3028)
			if (pick(redraw, true)) {
				chart.redraw(false);
			}
		}
	});

	// Extend the Axis.prototype for dynamic methods
	extend(Axis.prototype, {

		/**
		 * Update the axis with a new options structure
		 */
		update: function (newOptions, redraw) {
			var chart = this.chart;

			newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

			this.destroy(true);
			this._addedPlotLB = UNDEFINED; // #1611, #2887

			this.init(chart, extend(newOptions, { events: UNDEFINED }));

			chart.isDirtyBox = true;
			if (pick(redraw, true)) {
				chart.redraw();
			}
		},

		/**
	     * Remove the axis from the chart
	     */
		remove: function (redraw) {
			var chart = this.chart,
				key = this.coll, // xAxis or yAxis
				axisSeries = this.series,
				i = axisSeries.length;

			// Remove associated series (#2687)
			while (i--) {
				if (axisSeries[i]) {
					axisSeries[i].remove(false);
				}
			}

			// Remove the axis
			erase(chart.axes, this);
			erase(chart[key], this);
			chart.options[key].splice(this.options.index, 1);
			each(chart[key], function (axis, i) { // Re-index, #1706
				axis.options.index = i;
			});
			this.destroy();
			chart.isDirtyBox = true;

			if (pick(redraw, true)) {
				chart.redraw();
			}
		},

		/**
		 * Update the axis title by options
		 */
		setTitle: function (newTitleOptions, redraw) {
			this.update({ title: newTitleOptions }, redraw);
		},

		/**
		 * Set new axis categories and optionally redraw
		 * @param {Array} categories
		 * @param {Boolean} redraw
		 */
		setCategories: function (categories, redraw) {
			this.update({ categories: categories }, redraw);
		}

	});


	/**
	 * LineSeries object
	 */
	var LineSeries = extendClass(Series);
	seriesTypes.line = LineSeries;

	/**
	 * Set the default options for area
	 */
	defaultPlotOptions.area = merge(defaultSeriesOptions, {
		threshold: 0
		// trackByArea: false,
		// lineColor: null, // overrides color, but lets fillColor be unaltered
		// fillOpacity: 0.75,
		// fillColor: null
	});

	/**
	 * AreaSeries object
	 */
	var AreaSeries = extendClass(Series, {
		type: 'area',
		/**
		 * For stacks, don't split segments on null values. Instead, draw null values with 
		 * no marker. Also insert dummy points for any X position that exists in other series
		 * in the stack.
		 */ 
		getSegments: function () {
			var series = this,
				segments = [],
				segment = [],
				keys = [],
				xAxis = this.xAxis,
				yAxis = this.yAxis,
				stack = yAxis.stacks[this.stackKey],
				pointMap = {},
				plotX,
				plotY,
				points = this.points,
				connectNulls = this.options.connectNulls,
				i,
				x;

			if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue
				// Create a map where we can quickly look up the points by their X value.
				for (i = 0; i < points.length; i++) {
					pointMap[points[i].x] = points[i];
				}

				// Sort the keys (#1651)
				for (x in stack) {
					if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
						keys.push(+x);
					}
				}
				keys.sort(function (a, b) {
					return a - b;
				});

				each(keys, function (x) {
					var y = 0,
						stackPoint;

					if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836
						return;

					// The point exists, push it to the segment
					} else if (pointMap[x]) {
						segment.push(pointMap[x]);

					// There is no point for this X value in this series, so we 
					// insert a dummy point in order for the areas to be drawn
					// correctly.
					} else {

						// Loop down the stack to find the series below this one that has
						// a value (#1991)
						for (i = series.index; i <= yAxis.series.length; i++) {
							stackPoint = stack[x].points[i + ',' + x];
							if (stackPoint) {
								y = stackPoint[1];
								break;
							}
						}

						plotX = xAxis.translate(x);
						plotY = yAxis.toPixels(y, true);
						segment.push({ 
							y: null, 
							plotX: plotX,
							clientX: plotX, 
							plotY: plotY, 
							yBottom: plotY,
							onMouseOver: noop
						});
					}
				});

				if (segment.length) {
					segments.push(segment);
				}

			} else {
				Series.prototype.getSegments.call(this);
				segments = this.segments;
			}

			this.segments = segments;
		},
		
		/**
		 * Extend the base Series getSegmentPath method by adding the path for the area.
		 * This path is pushed to the series.areaPath property.
		 */
		getSegmentPath: function (segment) {
			
			var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
				areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
				i,
				options = this.options,
				segLength = segmentPath.length,
				translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
				yBottom;
			
			if (segLength === 3) { // for animation from 1 to two points
				areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
			}
			if (options.stacking && !this.closedStacks) {
				
				// Follow stack back. Todo: implement areaspline. A general solution could be to 
				// reverse the entire graphPath of the previous series, though may be hard with
				// splines and with series with different extremes
				for (i = segment.length - 1; i >= 0; i--) {

					yBottom = pick(segment[i].yBottom, translatedThreshold);
				
					// step line?
					if (i < segment.length - 1 && options.step) {
						areaSegmentPath.push(segment[i + 1].plotX, yBottom);
					}
					
					areaSegmentPath.push(segment[i].plotX, yBottom);
				}

			} else { // follow zero line back
				this.closeSegment(areaSegmentPath, segment, translatedThreshold);
			}
			this.areaPath = this.areaPath.concat(areaSegmentPath);
			return segmentPath;
		},
		
		/**
		 * Extendable method to close the segment path of an area. This is overridden in polar 
		 * charts.
		 */
		closeSegment: function (path, segment, translatedThreshold) {
			path.push(
				L,
				segment[segment.length - 1].plotX,
				translatedThreshold,
				L,
				segment[0].plotX,
				translatedThreshold
			);
		},
		
		/**
		 * Draw the graph and the underlying area. This method calls the Series base
		 * function and adds the area. The areaPath is calculated in the getSegmentPath
		 * method called from Series.prototype.drawGraph.
		 */
		drawGraph: function () {
			
			// Define or reset areaPath
			this.areaPath = [];
			
			// Call the base method
			Series.prototype.drawGraph.apply(this);
			
			// Define local variables
			var series = this,
				areaPath = this.areaPath,
				options = this.options,
				zones = this.zones,
				props = [['area', this.color, options.fillColor]]; // area name, main color, fill color
			
			each(zones, function (threshold, i) {
				props.push(['colorArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
			});
			each(props, function (prop) {
				var areaKey = prop[0],
					area = series[areaKey];
					
				// Create or update the area
				if (area) { // update
					area.animate({ d: areaPath });
		
				} else { // create
					series[areaKey] = series.chart.renderer.path(areaPath)
						.attr({
							fill: pick(
								prop[2],
								Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
							),
							zIndex: 0 // #1069
						}).add(series.group);
				}
			});
		},

		drawLegendSymbol: LegendSymbolMixin.drawRectangle
	});

	seriesTypes.area = AreaSeries;
	/**
	 * Set the default options for spline
	 */
	defaultPlotOptions.spline = merge(defaultSeriesOptions);

	/**
	 * SplineSeries object
	 */
	var SplineSeries = extendClass(Series, {
		type: 'spline',

		/**
		 * Get the spline segment from a given point's previous neighbour to the given point
		 */
		getPointSpline: function (segment, point, i) {
			var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
				denom = smoothing + 1,
				plotX = point.plotX,
				plotY = point.plotY,
				lastPoint = segment[i - 1],
				nextPoint = segment[i + 1],
				leftContX,
				leftContY,
				rightContX,
				rightContY,
				ret;

			// find control points
			if (lastPoint && nextPoint) {
			
				var lastX = lastPoint.plotX,
					lastY = lastPoint.plotY,
					nextX = nextPoint.plotX,
					nextY = nextPoint.plotY,
					correction;

				leftContX = (smoothing * plotX + lastX) / denom;
				leftContY = (smoothing * plotY + lastY) / denom;
				rightContX = (smoothing * plotX + nextX) / denom;
				rightContY = (smoothing * plotY + nextY) / denom;

				// have the two control points make a straight line through main point
				correction = ((rightContY - leftContY) * (rightContX - plotX)) /
					(rightContX - leftContX) + plotY - rightContY;

				leftContY += correction;
				rightContY += correction;

				// to prevent false extremes, check that control points are between
				// neighbouring points' y values
				if (leftContY > lastY && leftContY > plotY) {
					leftContY = mathMax(lastY, plotY);
					rightContY = 2 * plotY - leftContY; // mirror of left control point
				} else if (leftContY < lastY && leftContY < plotY) {
					leftContY = mathMin(lastY, plotY);
					rightContY = 2 * plotY - leftContY;
				}
				if (rightContY > nextY && rightContY > plotY) {
					rightContY = mathMax(nextY, plotY);
					leftContY = 2 * plotY - rightContY;
				} else if (rightContY < nextY && rightContY < plotY) {
					rightContY = mathMin(nextY, plotY);
					leftContY = 2 * plotY - rightContY;
				}

				// record for drawing in next point
				point.rightContX = rightContX;
				point.rightContY = rightContY;

			}
			
			// Visualize control points for debugging
			/*
			if (leftContX) {
				this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
					.attr({
						stroke: 'red',
						'stroke-width': 1,
						fill: 'none'
					})
					.add();
				this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
					.attr({
						stroke: 'red',
						'stroke-width': 1
					})
					.add();
				this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
					.attr({
						stroke: 'green',
						'stroke-width': 1,
						fill: 'none'
					})
					.add();
				this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
					.attr({
						stroke: 'green',
						'stroke-width': 1
					})
					.add();
			}
			*/

			// moveTo or lineTo
			if (!i) {
				ret = [M, plotX, plotY];
			} else { // curve from last point to this
				ret = [
					'C',
					lastPoint.rightContX || lastPoint.plotX,
					lastPoint.rightContY || lastPoint.plotY,
					leftContX || plotX,
					leftContY || plotY,
					plotX,
					plotY
				];
				lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
			}
			return ret;
		}
	});
	seriesTypes.spline = SplineSeries;

	/**
	 * Set the default options for areaspline
	 */
	defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

	/**
	 * AreaSplineSeries object
	 */
	var areaProto = AreaSeries.prototype,
		AreaSplineSeries = extendClass(SplineSeries, {
			type: 'areaspline',
			closedStacks: true, // instead of following the previous graph back, follow the threshold back
			
			// Mix in methods from the area series
			getSegmentPath: areaProto.getSegmentPath,
			closeSegment: areaProto.closeSegment,
			drawGraph: areaProto.drawGraph,
			drawLegendSymbol: LegendSymbolMixin.drawRectangle
		});

	seriesTypes.areaspline = AreaSplineSeries;

	/**
	 * Set the default options for column
	 */
	defaultPlotOptions.column = merge(defaultSeriesOptions, {
		borderColor: '#FFFFFF',
		//borderWidth: 1,
		borderRadius: 0,
		//colorByPoint: undefined,
		groupPadding: 0.2,
		//grouping: true,
		marker: null, // point options are specified in the base options
		pointPadding: 0.1,
		//pointWidth: null,
		minPointLength: 0,
		cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
		pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
		states: {
			hover: {
				brightness: 0.1,
				shadow: false,
				halo: false
			},
			select: {
				color: '#C0C0C0',
				borderColor: '#000000',
				shadow: false
			}
		},
		dataLabels: {
			align: null, // auto
			verticalAlign: null, // auto
			y: null
		},
		stickyTracking: false,
		tooltip: {
			distance: 6
		},
		threshold: 0
	});

	/**
	 * ColumnSeries object
	 */
	var ColumnSeries = extendClass(Series, {
		type: 'column',
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'borderColor',
			fill: 'color',
			r: 'borderRadius'
		},
		cropShoulder: 0,
		directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
		trackerGroups: ['group', 'dataLabelsGroup'],
		negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
			// point is substracted from previous (#1910)
		
		/**
		 * Initialize the series
		 */
		init: function () {
			Series.prototype.init.apply(this, arguments);

			var series = this,
				chart = series.chart;

			// if the series is added dynamically, force redraw of other
			// series affected by a new column
			if (chart.hasRendered) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.type === series.type) {
						otherSeries.isDirty = true;
					}
				});
			}
		},

		/**
		 * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
		 * pointWidth etc. 
		 */
		getColumnMetrics: function () {

			var series = this,
				options = series.options,
				xAxis = series.xAxis,
				yAxis = series.yAxis,
				reversedXAxis = xAxis.reversed,
				stackKey,
				stackGroups = {},
				columnIndex,
				columnCount = 0;

			// Get the total number of column type series.
			// This is called on every series. Consider moving this logic to a
			// chart.orderStacks() function and call it on init, addSeries and removeSeries
			if (options.grouping === false) {
				columnCount = 1;
			} else {
				each(series.chart.series, function (otherSeries) {
					var otherOptions = otherSeries.options,
						otherYAxis = otherSeries.yAxis;
					if (otherSeries.type === series.type && otherSeries.visible &&
							yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
						if (otherOptions.stacking) {
							stackKey = otherSeries.stackKey;
							if (stackGroups[stackKey] === UNDEFINED) {
								stackGroups[stackKey] = columnCount++;
							}
							columnIndex = stackGroups[stackKey];
						} else if (otherOptions.grouping !== false) { // #1162
							columnIndex = columnCount++;
						}
						otherSeries.columnIndex = columnIndex;
					}
				});
			}

			var categoryWidth = mathMin(
					mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
					xAxis.len // #1535
				),
				groupPadding = categoryWidth * options.groupPadding,
				groupWidth = categoryWidth - 2 * groupPadding,
				pointOffsetWidth = groupWidth / columnCount,
				optionPointWidth = options.pointWidth,
				pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
					pointOffsetWidth * options.pointPadding,
				pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts
				colIndex = (reversedXAxis ? 
					columnCount - (series.columnIndex || 0) : // #1251
					series.columnIndex) || 0,
				pointXOffset = pointPadding + (groupPadding + colIndex *
					pointOffsetWidth - (categoryWidth / 2)) *
					(reversedXAxis ? -1 : 1);

			// Save it for reading in linked series (Error bars particularly)
			return (series.columnMetrics = { 
				width: pointWidth, 
				offset: pointXOffset 
			});
				
		},

		/**
		 * Translate each point to the plot area coordinate system and find shape positions
		 */
		translate: function () {
			var series = this,
				chart = series.chart,
				options = series.options,
				borderWidth = series.borderWidth = pick(
					options.borderWidth, 
					series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
				),
				yAxis = series.yAxis,
				threshold = options.threshold,
				translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
				minPointLength = pick(options.minPointLength, 5),
				metrics = series.getColumnMetrics(),
				pointWidth = metrics.width,
				seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
				pointXOffset = series.pointXOffset = metrics.offset,
				xCrisp = -(borderWidth % 2 ? 0.5 : 0),
				yCrisp = borderWidth % 2 ? 0.5 : 1;

			if (chart.renderer.isVML && chart.inverted) {
				yCrisp += 1;
			}

			// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
			// columns to have individual sizes. When pointPadding is greater, we strive for equal-width
			// columns (#2694).
			if (options.pointPadding) {
				seriesBarW = mathCeil(seriesBarW);
			}

			Series.prototype.translate.apply(series);

			// Record the new values
			each(series.points, function (point) {
				var yBottom = pick(point.yBottom, translatedThreshold),
					plotY = mathMin(mathMax(-999 - yBottom, point.plotY), yAxis.len + 999 + yBottom), // Don't draw too far outside plot area (#1303, #2241)
					barX = point.plotX + pointXOffset,
					barW = seriesBarW,
					barY = mathMin(plotY, yBottom),
					right,
					bottom,
					fromTop,
					barH = mathMax(plotY, yBottom) - barY;

				// Handle options.minPointLength
				if (mathAbs(barH) < minPointLength) {
					if (minPointLength) {
						barH = minPointLength;
						barY =
							mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
								yBottom - minPointLength : // keep position
								translatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0)); // use exact yAxis.translation (#1485)
					}
				}

				// Cache for access in polar
				point.barX = barX;
				point.pointWidth = pointWidth;

				// Fix the tooltip on center of grouped columns (#1216, #424, #3648)
				point.tooltipPos = chart.inverted ? 
					[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2] : 
					[barX + barW / 2, plotY + yAxis.pos - chart.plotTop];

				// Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)
				right = mathRound(barX + barW) + xCrisp;
				barX = mathRound(barX) + xCrisp;
				barW = right - barX;

				fromTop = mathAbs(barY) < 0.5;
				bottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575
				barY = mathRound(barY) + yCrisp;
				barH = bottom - barY;

				// Top edges are exceptions
				if (fromTop) {
					barY -= 1;
					barH += 1;
				}

				// Register shape type and arguments to be used in drawPoints
				point.shapeType = 'rect';
				point.shapeArgs = {
					x: barX,
					y: barY,
					width: barW,
					height: barH
				};

			});

		},

		getSymbol: noop,
		
		/**
		 * Use a solid rectangle like the area series types
		 */
		drawLegendSymbol: LegendSymbolMixin.drawRectangle,
		
		
		/**
		 * Columns have no graph
		 */
		drawGraph: noop,

		/**
		 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
		 * apply for columns and bars. This method is inherited by scatter series.
		 *
		 */
		drawPoints: function () {
			var series = this,
				chart = this.chart,
				options = series.options,
				renderer = chart.renderer,
				animationLimit = options.animationLimit || 250,
				shapeArgs,
				pointAttr;

			// draw the columns
			each(series.points, function (point) {
				var plotY = point.plotY,
					graphic = point.graphic,
					borderAttr;

				if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
					shapeArgs = point.shapeArgs;

					borderAttr = defined(series.borderWidth) ? {
						'stroke-width': series.borderWidth
					} : {};

					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];
					
					if (graphic) { // update
						stop(graphic);
						graphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));

					} else {
						point.graphic = graphic = renderer[point.shapeType](shapeArgs)
							.attr(borderAttr)
							.attr(pointAttr)
							.add(series.group)
							.shadow(options.shadow, null, options.stacking && !options.borderRadius);
					}

				} else if (graphic) {
					point.graphic = graphic.destroy(); // #1269
				}
			});
		},

		/**
		 * Animate the column heights one by one from zero
		 * @param {Boolean} init Whether to initialize the animation or run it
		 */
		animate: function (init) {
			var series = this,
				yAxis = this.yAxis,
				options = series.options,
				inverted = this.chart.inverted,
				attr = {},
				translatedThreshold;

			if (hasSVG) { // VML is too slow anyway
				if (init) {
					attr.scaleY = 0.001;
					translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
					if (inverted) {
						attr.translateX = translatedThreshold - yAxis.len;
					} else {
						attr.translateY = translatedThreshold;
					}
					series.group.attr(attr);

				} else { // run the animation
					
					attr.scaleY = 1;
					attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
					series.group.animate(attr, series.options.animation);

					// delete this function to allow it only once
					series.animate = null;
				}
			}
		},
		
		/**
		 * Remove this series from the chart
		 */
		remove: function () {
			var series = this,
				chart = series.chart;

			// column and bar series affects other series of the same type
			// as they are either stacked or grouped
			if (chart.hasRendered) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.type === series.type) {
						otherSeries.isDirty = true;
					}
				});
			}

			Series.prototype.remove.apply(series, arguments);
		}
	});
	seriesTypes.column = ColumnSeries;
	/**
	 * Set the default options for bar
	 */
	defaultPlotOptions.bar = merge(defaultPlotOptions.column);
	/**
	 * The Bar series class
	 */
	var BarSeries = extendClass(ColumnSeries, {
		type: 'bar',
		inverted: true
	});
	seriesTypes.bar = BarSeries;

	/**
	 * Set the default options for scatter
	 */
	defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
		lineWidth: 0,
		marker: {
			enabled: true // Overrides auto-enabling in line series (#3647)
		},
		tooltip: {
			headerFormat: '<span style="color:{series.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
			pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
		}
	});

	/**
	 * The scatter series class
	 */
	var ScatterSeries = extendClass(Series, {
		type: 'scatter',
		sorted: false,
		requireSorting: false,
		noSharedTooltip: true,
		trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
		takeOrdinalPosition: false, // #2342
		kdDimensions: 2,
		kdComparer: 'distR',
		drawGraph: function () {
			if (this.options.lineWidth) {
				Series.prototype.drawGraph.call(this);
			}
		}
	});

	seriesTypes.scatter = ScatterSeries;

	/**
	 * Set the default options for pie
	 */
	defaultPlotOptions.pie = merge(defaultSeriesOptions, {
		borderColor: '#FFFFFF',
		borderWidth: 1,
		center: [null, null],
		clip: false,
		colorByPoint: true, // always true for pies
		dataLabels: {
			// align: null,
			// connectorWidth: 1,
			// connectorColor: point.color,
			// connectorPadding: 5,
			distance: 30,
			enabled: true,
			formatter: function () { // #2945
				return this.point.name;
			},
			// softConnector: true,
			x: 0
			// y: 0
		},
		ignoreHiddenPoint: true,
		//innerSize: 0,
		legendType: 'point',
		marker: null, // point options are specified in the base options
		size: null,
		showInLegend: false,
		slicedOffset: 10,
		states: {
			hover: {
				brightness: 0.1,
				shadow: false
			}
		},
		stickyTracking: false,
		tooltip: {
			followPointer: true
		}
	});

	/**
	 * Extended point object for pies
	 */
	var PiePoint = extendClass(Point, {
		/**
		 * Initiate the pie slice
		 */
		init: function () {

			Point.prototype.init.apply(this, arguments);

			var point = this,
				toggleSlice;

			extend(point, {
				visible: point.visible !== false,
				name: pick(point.name, 'Slice')
			});

			// add event listener for select
			toggleSlice = function (e) {
				point.slice(e.type === 'select');
			};
			addEvent(point, 'select', toggleSlice);
			addEvent(point, 'unselect', toggleSlice);

			return point;
		},

		/**
		 * Toggle the visibility of the pie slice
		 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
		 *    visibility is toggled
		 */
		setVisible: function (vis) {
			var point = this,
				series = point.series,
				chart = series.chart,
				doRedraw = !series.isDirty && series.options.ignoreHiddenPoint;

			// if called without an argument, toggle visibility
			point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

			// Show and hide associated elements
			each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
				if (point[key]) {
					point[key][vis ? 'show' : 'hide'](true);
				}
			});

			if (point.legendItem) {
				if (chart.hasRendered) {
					series.updateTotals();
					chart.legend.clearItems();
					if (!doRedraw) {
						chart.legend.render();
					}
				}
				chart.legend.colorizeItem(point, vis);
			}

			// Handle ignore hidden slices
			if (doRedraw) {
				series.isDirty = true;
				chart.redraw();
			}
		},

		/**
		 * Set or toggle whether the slice is cut out from the pie
		 * @param {Boolean} sliced When undefined, the slice state is toggled
		 * @param {Boolean} redraw Whether to redraw the chart. True by default.
		 */
		slice: function (sliced, redraw, animation) {
			var point = this,
				series = point.series,
				chart = series.chart,
				translation;

			setAnimation(animation, chart);

			// redraw is true by default
			redraw = pick(redraw, true);

			// if called without an argument, toggle
			point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

			translation = sliced ? point.slicedTranslation : {
				translateX: 0,
				translateY: 0
			};

			point.graphic.animate(translation);
			
			if (point.shadowGroup) {
				point.shadowGroup.animate(translation);
			}

		},

		haloPath: function (size) {
			var shapeArgs = this.shapeArgs,
				chart = this.series.chart;

			return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
				innerR: this.shapeArgs.r,
				start: shapeArgs.start,
				end: shapeArgs.end
			});
		}
	});

	/**
	 * The Pie series class
	 */
	var PieSeries = {
		type: 'pie',
		isCartesian: false,
		pointClass: PiePoint,
		requireSorting: false,
		noSharedTooltip: true,
		trackerGroups: ['group', 'dataLabelsGroup'],
		axisTypes: [],
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'borderColor',
			'stroke-width': 'borderWidth',
			fill: 'color'
		},

		/**
		 * Pies have one color each point
		 */
		getColor: noop,

		/**
		 * Animate the pies in
		 */
		animate: function (init) {
			var series = this,
				points = series.points,
				startAngleRad = series.startAngleRad;

			if (!init) {
				each(points, function (point) {
					var graphic = point.graphic,
						args = point.shapeArgs;

					if (graphic) {
						// start values
						graphic.attr({
							r: series.center[3] / 2, // animate from inner radius (#779)
							start: startAngleRad,
							end: startAngleRad
						});

						// animate
						graphic.animate({
							r: args.r,
							start: args.start,
							end: args.end
						}, series.options.animation);
					}
				});

				// delete this function to allow it only once
				series.animate = null;
			}
		},

		/**
		 * Extend the basic setData method by running processData and generatePoints immediately,
		 * in order to access the points from the legend.
		 */
		setData: function (data, redraw, animation, updatePoints) {
			Series.prototype.setData.call(this, data, false, animation, updatePoints);
			this.processData();
			this.generatePoints();
			if (pick(redraw, true)) {
				this.chart.redraw(animation);
			} 
		},

		/**
		 * Recompute total chart sum and update percentages of points.
		 */
		updateTotals: function () {
			var i,
				total = 0,
				points,
				len,
				point,
				ignoreHiddenPoint = this.options.ignoreHiddenPoint;

			// Populate local vars
			points = this.points;
			len = points.length;
			
			// Get the total sum
			for (i = 0; i < len; i++) {
				point = points[i];

				// Disallow negative values (#1530, #3623)
				if (point.y < 0) {
					point.y = null;
				}
				
				total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
			}
			this.total = total;

			// Set each point's properties
			for (i = 0; i < len; i++) {
				point = points[i];
				//point.percentage = (total <= 0 || ignoreHiddenPoint && !point.visible) ? 0 : point.y / total * 100;
				point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
				point.total = total;
			}
		},

		/**
		 * Extend the generatePoints method by adding total and percentage properties to each point
		 */
		generatePoints: function () {
			Series.prototype.generatePoints.call(this);
			this.updateTotals();
		},
		
		/**
		 * Do translation for pie slices
		 */
		translate: function (positions) {
			this.generatePoints();
			
			var series = this,
				cumulative = 0,
				precision = 1000, // issue #172
				options = series.options,
				slicedOffset = options.slicedOffset,
				connectorOffset = slicedOffset + options.borderWidth,
				start,
				end,
				angle,
				startAngle = options.startAngle || 0,
				startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
				endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
				circ = endAngleRad - startAngleRad, //2 * mathPI,
				points = series.points,
				radiusX, // the x component of the radius vector for a given point
				radiusY,
				labelDistance = options.dataLabels.distance,
				ignoreHiddenPoint = options.ignoreHiddenPoint,
				i,
				len = points.length,
				point;

			// Get positions - either an integer or a percentage string must be given.
			// If positions are passed as a parameter, we're in a recursive loop for adjusting
			// space for data labels.
			if (!positions) {
				series.center = positions = series.getCenter();
			}

			// utility for getting the x value from a given y, used for anticollision logic in data labels
			series.getX = function (y, left) {

				angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

				return positions[0] +
					(left ? -1 : 1) *
					(mathCos(angle) * (positions[2] / 2 + labelDistance));
			};

			// Calculate the geometry for each point
			for (i = 0; i < len; i++) {
				
				point = points[i];
				
				// set start and end angle
				start = startAngleRad + (cumulative * circ);
				if (!ignoreHiddenPoint || point.visible) {
					cumulative += point.percentage / 100;
				}
				end = startAngleRad + (cumulative * circ);

				// set the shape
				point.shapeType = 'arc';
				point.shapeArgs = {
					x: positions[0],
					y: positions[1],
					r: positions[2] / 2,
					innerR: positions[3] / 2,
					start: mathRound(start * precision) / precision,
					end: mathRound(end * precision) / precision
				};

				// The angle must stay within -90 and 270 (#2645)
				angle = (end + start) / 2;
				if (angle > 1.5 * mathPI) {
					angle -= 2 * mathPI;
				} else if (angle < -mathPI / 2) {
					angle += 2 * mathPI;
				}

				// Center for the sliced out slice
				point.slicedTranslation = {
					translateX: mathRound(mathCos(angle) * slicedOffset),
					translateY: mathRound(mathSin(angle) * slicedOffset)
				};

				// set the anchor point for tooltips
				radiusX = mathCos(angle) * positions[2] / 2;
				radiusY = mathSin(angle) * positions[2] / 2;
				point.tooltipPos = [
					positions[0] + radiusX * 0.7,
					positions[1] + radiusY * 0.7
				];
				
				point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
				point.angle = angle;

				// set the anchor point for data labels
				connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
				point.labelPos = [
					positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
					positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
					positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
					positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
					positions[0] + radiusX, // landing point for connector
					positions[1] + radiusY, // a/a
					labelDistance < 0 ? // alignment
						'center' :
						point.half ? 'right' : 'left', // alignment
					angle // center angle
				];

			}
		},
		
		drawGraph: null,

		/**
		 * Draw the data points
		 */
		drawPoints: function () {
			var series = this,
				chart = series.chart,
				renderer = chart.renderer,
				groupTranslation,
				//center,
				graphic,
				//group,
				shadow = series.options.shadow,
				shadowGroup,
				shapeArgs;

			if (shadow && !series.shadowGroup) {
				series.shadowGroup = renderer.g('shadow')
					.add(series.group);
			}

			// draw the slices
			each(series.points, function (point) {
				graphic = point.graphic;
				shapeArgs = point.shapeArgs;
				shadowGroup = point.shadowGroup;

				// put the shadow behind all points
				if (shadow && !shadowGroup) {
					shadowGroup = point.shadowGroup = renderer.g('shadow')
						.add(series.shadowGroup);
				}

				// if the point is sliced, use special translation, else use plot area traslation
				groupTranslation = point.sliced ? point.slicedTranslation : {
					translateX: 0,
					translateY: 0
				};

				//group.translate(groupTranslation[0], groupTranslation[1]);
				if (shadowGroup) {
					shadowGroup.attr(groupTranslation);
				}

				// draw the slice
				if (graphic) {
					graphic.animate(extend(shapeArgs, groupTranslation));
				} else {
					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.setRadialReference(series.center)
						.attr(
							point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
						)
						.attr({ 
							'stroke-linejoin': 'round'
							//zIndex: 1 // #2722 (reversed)
						})
						.attr(groupTranslation)
						.add(series.group)
						.shadow(shadow, shadowGroup);	
				}

				// detect point specific visibility (#2430)
				if (point.visible !== undefined) {
					point.setVisible(point.visible);
				}

			});

		},


		searchPoint: noop,

		/**
		 * Utility for sorting data labels
		 */
		sortByAngle: function (points, sign) {
			points.sort(function (a, b) {
				return a.angle !== undefined && (b.angle - a.angle) * sign;
			});
		},		

		/**
		 * Use a simple symbol from LegendSymbolMixin
		 */
		drawLegendSymbol: LegendSymbolMixin.drawRectangle,

		/**
		 * Use the getCenter method from drawLegendSymbol
		 */
		getCenter: CenteredSeriesMixin.getCenter,

		/**
		 * Pies don't have point marker symbols
		 */
		getSymbol: noop

	};
	PieSeries = extendClass(Series, PieSeries);
	seriesTypes.pie = PieSeries;

	/**
	 * Draw the data labels
	 */
	Series.prototype.drawDataLabels = function () {

		var series = this,
			seriesOptions = series.options,
			cursor = seriesOptions.cursor,
			options = seriesOptions.dataLabels,
			points = series.points,
			pointOptions,
			generalOptions,
			hasRendered = series.hasRendered || 0,
			str,
			dataLabelsGroup,
			renderer = series.chart.renderer;

		if (options.enabled || series._hasPointLabels) {

			// Process default alignment of data labels for columns
			if (series.dlProcessOptions) {
				series.dlProcessOptions(options);
			}

			// Create a separate group for the data labels to avoid rotation
			dataLabelsGroup = series.plotGroup(
				'dataLabelsGroup',
				'data-labels',
				options.defer ? HIDDEN : VISIBLE,
				options.zIndex || 6
			);

			if (pick(options.defer, true)) {
				dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
				if (!hasRendered) {
					addEvent(series, 'afterAnimate', function () {
						if (series.visible) { // #3023, #3024
							dataLabelsGroup.show();
						}
						dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
					});
				}
			}

			// Make the labels for each point
			generalOptions = options;
			each(points, function (point) {

				var enabled,
					dataLabel = point.dataLabel,
					labelConfig,
					attr,
					name,
					rotation,
					connector = point.connector,
					isNew = true,
					style,
					moreStyle = {};

				// Determine if each data label is enabled
				pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
				enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282


				// If the point is outside the plot area, destroy it. #678, #820
				if (dataLabel && !enabled) {
					point.dataLabel = dataLabel.destroy();

				// Individual labels are disabled if the are explicitly disabled
				// in the point options, or if they fall outside the plot area.
				} else if (enabled) {

					// Create individual options structure that can be extended without
					// affecting others
					options = merge(generalOptions, pointOptions);
					style = options.style;

					rotation = options.rotation;

					// Get the string
					labelConfig = point.getLabelConfig();
					str = options.format ?
						format(options.format, labelConfig) :
						options.formatter.call(labelConfig, options);

					// Determine the color
					style.color = pick(options.color, style.color, series.color, 'black');


					// update existing label
					if (dataLabel) {

						if (defined(str)) {
							dataLabel
								.attr({
									text: str
								});
							isNew = false;

						} else { // #1437 - the label is shown conditionally
							point.dataLabel = dataLabel = dataLabel.destroy();
							if (connector) {
								point.connector = connector.destroy();
							}
						}

					// create new label
					} else if (defined(str)) {
						attr = {
							//align: align,
							fill: options.backgroundColor,
							stroke: options.borderColor,
							'stroke-width': options.borderWidth,
							r: options.borderRadius || 0,
							rotation: rotation,
							padding: options.padding,
							zIndex: 1
						};
						
						// Get automated contrast color
						if (style.color === 'contrast') {
							moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? 
								renderer.getContrast(point.color || series.color) : 
								'#000000';
						}
						if (cursor) {
							moreStyle.cursor = cursor;
						}
						

						// Remove unused attributes (#947)
						for (name in attr) {
							if (attr[name] === UNDEFINED) {
								delete attr[name];
							}
						}

						dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
							str,
							0,
							-999,
							options.shape,
							null,
							null,
							options.useHTML
						)
						.attr(attr)
						.css(extend(style, moreStyle))
						.add(dataLabelsGroup)
						.shadow(options.shadow);

					}

					if (dataLabel) {
						// Now the data label is created and placed at 0,0, so we need to align it
						series.alignDataLabel(point, dataLabel, options, null, isNew);
					}
				}
			});
		}
	};

	/**
	 * Align each individual data label
	 */
	Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
		var chart = this.chart,
			inverted = chart.inverted,
			plotX = pick(point.plotX, -999),
			plotY = pick(point.plotY, -999),
			bBox = dataLabel.getBBox(),
			baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
			rotCorr, // rotation correction
			// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
			visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
				(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
			alignAttr; // the final position;

		if (visible) {

			// The alignment box is a singular point
			alignTo = extend({
				x: inverted ? chart.plotWidth - plotY : plotX,
				y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
				width: 0,
				height: 0
			}, alignTo);

			// Add the text size for alignment calculation
			extend(options, {
				width: bBox.width,
				height: bBox.height
			});

			// Allow a hook for changing alignment in the last moment, then do the alignment
			if (options.rotation) { // Fancy box alignment isn't supported for rotated text
				rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723
				dataLabel[isNew ? 'attr' : 'animate']({
						x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
						y: alignTo.y + options.y + alignTo.height / 2
					})
					.attr({ // #3003
						align: options.align
					});
			} else {
				dataLabel.align(options, null, alignTo);
				alignAttr = dataLabel.alignAttr;

				// Handle justify or crop
				if (pick(options.overflow, 'justify') === 'justify') {
					this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);

				} else if (pick(options.crop, true)) {
					// Now check that the data label is within the plot area
					visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);

				}

				// When we're using a shape, make it possible with a connector or an arrow pointing to thie point
				if (options.shape) {
					dataLabel.attr({
						anchorX: point.plotX,
						anchorY: point.plotY
					});
				}

			}
		}

		// Show or hide based on the final aligned position
		if (!visible) {
			dataLabel.attr({ y: -999 });
			dataLabel.placed = false; // don't animate back in
		}

	};

	/**
	 * If data labels fall partly outside the plot area, align them back in, in a way that
	 * doesn't hide the point.
	 */
	Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
		var chart = this.chart,
			align = options.align,
			verticalAlign = options.verticalAlign,
			off,
			justified,
			padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

		// Off left
		off = alignAttr.x + padding;
		if (off < 0) {
			if (align === 'right') {
				options.align = 'left';
			} else {
				options.x = -off;
			}
			justified = true;
		}

		// Off right
		off = alignAttr.x + bBox.width - padding;
		if (off > chart.plotWidth) {
			if (align === 'left') {
				options.align = 'right';
			} else {
				options.x = chart.plotWidth - off;
			}
			justified = true;
		}

		// Off top
		off = alignAttr.y + padding;
		if (off < 0) {
			if (verticalAlign === 'bottom') {
				options.verticalAlign = 'top';
			} else {
				options.y = -off;
			}
			justified = true;
		}

		// Off bottom
		off = alignAttr.y + bBox.height - padding;
		if (off > chart.plotHeight) {
			if (verticalAlign === 'top') {
				options.verticalAlign = 'bottom';
			} else {
				options.y = chart.plotHeight - off;
			}
			justified = true;
		}

		if (justified) {
			dataLabel.placed = !isNew;
			dataLabel.align(options, null, alignTo);
		}
	};

	/**
	 * Override the base drawDataLabels method by pie specific functionality
	 */
	if (seriesTypes.pie) {
		seriesTypes.pie.prototype.drawDataLabels = function () {
			var series = this,
				data = series.data,
				point,
				chart = series.chart,
				options = series.options.dataLabels,
				connectorPadding = pick(options.connectorPadding, 10),
				connectorWidth = pick(options.connectorWidth, 1),
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				connector,
				connectorPath,
				softConnector = pick(options.softConnector, true),
				distanceOption = options.distance,
				seriesCenter = series.center,
				radius = seriesCenter[2] / 2,
				centerY = seriesCenter[1],
				outside = distanceOption > 0,
				dataLabel,
				dataLabelWidth,
				labelPos,
				labelHeight,
				halves = [// divide the points into right and left halves for anti collision
					[], // right
					[]  // left
				],
				x,
				y,
				visibility,
				rankArr,
				i,
				j,
				overflow = [0, 0, 0, 0], // top, right, bottom, left
				sort = function (a, b) {
					return b.y - a.y;
				};

			// get out if not enabled
			if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
				return;
			}

			// run parent method
			Series.prototype.drawDataLabels.apply(series);

			// arrange points for detection collision
			each(data, function (point) {
				if (point.dataLabel && point.visible) { // #407, #2510
					halves[point.half].push(point);
				}
			});

			/* Loop over the points in each half, starting from the top and bottom
			 * of the pie to detect overlapping labels.
			 */
			i = 2;
			while (i--) {

				var slots = [],
					slotsLength,
					usedSlots = [],
					points = halves[i],
					pos,
					bottom,
					length = points.length,
					slotIndex;

				if (!length) {
					continue;
				}

				// Sort by angle
				series.sortByAngle(points, i - 0.5);

				// Assume equal label heights on either hemisphere (#2630)
				j = labelHeight = 0;
				while (!labelHeight && points[j]) { // #1569
					labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
					j++;
				}

				// Only do anti-collision when we are outside the pie and have connectors (#856)
				if (distanceOption > 0) {

					// Build the slots
					bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
					for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {
						slots.push(pos);
					}
					slotsLength = slots.length;


					/* Visualize the slots
					if (!series.slotElements) {
						series.slotElements = [];
					}
					if (i === 1) {
						series.slotElements.forEach(function (elem) {
							elem.destroy();
						});
						series.slotElements.length = 0;
					}
						
					slots.forEach(function (pos, no) {
						var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
							slotY = pos + chart.plotTop;
						
						if (!isNaN(slotX)) {
							series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
								.attr({
									'stroke-width': 1,
									stroke: 'silver',
									fill: 'rgba(0,0,255,0.1)'
								})
								.add());
							series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
								.attr({
									fill: 'silver'
								}).add());
						}
					});
					// */

					// if there are more values than available slots, remove lowest values
					if (length > slotsLength) {
						// create an array for sorting and ranking the points within each quarter
						rankArr = [].concat(points);
						rankArr.sort(sort);
						j = length;
						while (j--) {
							rankArr[j].rank = j;
						}
						j = length;
						while (j--) {
							if (points[j].rank >= slotsLength) {
								points.splice(j, 1);
							}
						}
						length = points.length;
					}

					// The label goes to the nearest open slot, but not closer to the edge than
					// the label's index.
					for (j = 0; j < length; j++) {

						point = points[j];
						labelPos = point.labelPos;

						var closest = 9999,
							distance,
							slotI;

						// find the closest slot index
						for (slotI = 0; slotI < slotsLength; slotI++) {
							distance = mathAbs(slots[slotI] - labelPos[1]);
							if (distance < closest) {
								closest = distance;
								slotIndex = slotI;
							}
						}

						// if that slot index is closer to the edges of the slots, move it
						// to the closest appropriate slot
						if (slotIndex < j && slots[j] !== null) { // cluster at the top
							slotIndex = j;
						} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
							slotIndex = slotsLength - length + j;
							while (slots[slotIndex] === null) { // make sure it is not taken
								slotIndex++;
							}
						} else {
							// Slot is taken, find next free slot below. In the next run, the next slice will find the
							// slot above these, because it is the closest one
							while (slots[slotIndex] === null) { // make sure it is not taken
								slotIndex++;
							}
						}

						usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
						slots[slotIndex] = null; // mark as taken
					}
					// sort them in order to fill in from the top
					usedSlots.sort(sort);
				}

				// now the used slots are sorted, fill them up sequentially
				for (j = 0; j < length; j++) {

					var slot, naturalY;

					point = points[j];
					labelPos = point.labelPos;
					dataLabel = point.dataLabel;
					visibility = point.visible === false ? HIDDEN : VISIBLE;
					naturalY = labelPos[1];

					if (distanceOption > 0) {
						slot = usedSlots.pop();
						slotIndex = slot.i;

						// if the slot next to currrent slot is free, the y value is allowed
						// to fall back to the natural position
						y = slot.y;
						if ((naturalY > y && slots[slotIndex + 1] !== null) ||
								(naturalY < y &&  slots[slotIndex - 1] !== null)) {
							y = mathMin(mathMax(0, naturalY), chart.plotHeight);
						}

					} else {
						y = naturalY;
					}

					// get the x - use the natural x position for first and last slot, to prevent the top
					// and botton slice connectors from touching each other on either side
					x = options.justify ?
						seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
						series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


					// Record the placement and visibility
					dataLabel._attr = {
						visibility: visibility,
						align: labelPos[6]
					};
					dataLabel._pos = {
						x: x + options.x +
							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
						y: y + options.y - 10 // 10 is for the baseline (label vs text)
					};
					dataLabel.connX = x;
					dataLabel.connY = y;


					// Detect overflowing data labels
					if (this.options.size === null) {
						dataLabelWidth = dataLabel.width;
						// Overflow left
						if (x - dataLabelWidth < connectorPadding) {
							overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

						// Overflow right
						} else if (x + dataLabelWidth > plotWidth - connectorPadding) {
							overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
						}

						// Overflow top
						if (y - labelHeight / 2 < 0) {
							overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

						// Overflow left
						} else if (y + labelHeight / 2 > plotHeight) {
							overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
						}
					}
				} // for each point
			} // for each half

			// Do not apply the final placement and draw the connectors until we have verified
			// that labels are not spilling over.
			if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

				// Place the labels in the final position
				this.placeDataLabels();

				// Draw the connectors
				if (outside && connectorWidth) {
					each(this.points, function (point) {
						connector = point.connector;
						labelPos = point.labelPos;
						dataLabel = point.dataLabel;

						if (dataLabel && dataLabel._pos) {
							visibility = dataLabel._attr.visibility;
							x = dataLabel.connX;
							y = dataLabel.connY;
							connectorPath = softConnector ? [
								M,
								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
								'C',
								x, y, // first break, next to the label
								2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
								labelPos[2], labelPos[3], // second break
								L,
								labelPos[4], labelPos[5] // base
							] : [
								M,
								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
								L,
								labelPos[2], labelPos[3], // second break
								L,
								labelPos[4], labelPos[5] // base
							];

							if (connector) {
								connector.animate({ d: connectorPath });
								connector.attr('visibility', visibility);

							} else {
								point.connector = connector = series.chart.renderer.path(connectorPath).attr({
									'stroke-width': connectorWidth,
									stroke: options.connectorColor || point.color || '#606060',
									visibility: visibility
									//zIndex: 0 // #2722 (reversed)
								})
								.add(series.dataLabelsGroup);
							}
						} else if (connector) {
							point.connector = connector.destroy();
						}
					});
				}
			}
		};
		/**
		 * Perform the final placement of the data labels after we have verified that they
		 * fall within the plot area.
		 */
		seriesTypes.pie.prototype.placeDataLabels = function () {
			each(this.points, function (point) {
				var dataLabel = point.dataLabel,
					_pos;

				if (dataLabel) {
					_pos = dataLabel._pos;
					if (_pos) {
						dataLabel.attr(dataLabel._attr);
						dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
						dataLabel.moved = true;
					} else if (dataLabel) {
						dataLabel.attr({ y: -999 });
					}
				}
			});
		};

		seriesTypes.pie.prototype.alignDataLabel =  noop;

		/**
		 * Verify whether the data labels are allowed to draw, or we should run more translation and data
		 * label positioning to keep them inside the plot area. Returns true when data labels are ready
		 * to draw.
		 */
		seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

			var center = this.center,
				options = this.options,
				centerOption = options.center,
				minSize = options.minSize || 80,
				newSize = minSize,
				ret;

			// Handle horizontal size and center
			if (centerOption[0] !== null) { // Fixed center
				newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

			} else { // Auto center
				newSize = mathMax(
					center[2] - overflow[1] - overflow[3], // horizontal overflow
					minSize
				);
				center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
			}

			// Handle vertical size and center
			if (centerOption[1] !== null) { // Fixed center
				newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

			} else { // Auto center
				newSize = mathMax(
					mathMin(
						newSize,
						center[2] - overflow[0] - overflow[2] // vertical overflow
					),
					minSize
				);
				center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
			}

			// If the size must be decreased, we need to run translate and drawDataLabels again
			if (newSize < center[2]) {
				center[2] = newSize;
				this.translate(center);
				each(this.points, function (point) {
					if (point.dataLabel) {
						point.dataLabel._pos = null; // reset
					}
				});

				if (this.drawDataLabels) {
					this.drawDataLabels();
				}
			// Else, return true to indicate that the pie and its labels is within the plot area
			} else {
				ret = true;
			}
			return ret;
		};
	}

	if (seriesTypes.column) {

		/**
		 * Override the basic data label alignment by adjusting for the position of the column
		 */
		seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
			var inverted = this.chart.inverted,
				series = point.series,
				dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
				below = point.below || (point.plotY > pick(this.translatedThreshold, series.yAxis.len)),
				inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?

			// Align to the column itself, or the top of it
			if (dlBox) { // Area range uses this method but not alignTo
				alignTo = merge(dlBox);

				if (inverted) {
					alignTo = {
						x: series.yAxis.len - alignTo.y - alignTo.height,
						y: series.xAxis.len - alignTo.x - alignTo.width,
						width: alignTo.height,
						height: alignTo.width
					};
				}

				// Compute the alignment box
				if (!inside) {
					if (inverted) {
						alignTo.x += below ? 0 : alignTo.width;
						alignTo.width = 0;
					} else {
						alignTo.y += below ? alignTo.height : 0;
						alignTo.height = 0;
					}
				}
			}


			// When alignment is undefined (typically columns and bars), display the individual
			// point below or above the point depending on the threshold
			options.align = pick(
				options.align,
				!inverted || inside ? 'center' : below ? 'right' : 'left'
			);
			options.verticalAlign = pick(
				options.verticalAlign,
				inverted || inside ? 'middle' : below ? 'top' : 'bottom'
			);

			// Call the parent method
			Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
		};
	}



	/**
	 * Highcharts JS v4.1.4-modified ()
	 * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.
	 *
	 * (c) 2010-2014 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	/*global Highcharts, HighchartsAdapter */
	(function (H) {
		var Chart = H.Chart,
			each = H.each,
			addEvent = HighchartsAdapter.addEvent;

		// Collect potensial overlapping data labels. Stack labels probably don't need to be 
		// considered because they are usually accompanied by data labels that lie inside the columns.
		Chart.prototype.callbacks.push(function (chart) {
			function collectAndHide() {
				var labels = [];

				each(chart.series, function (series) {
					var dlOptions = series.options.dataLabels;
					if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
						each(series.points, function (point) { 
							if (point.dataLabel) {
								point.dataLabel.labelrank = point.labelrank;
								labels.push(point.dataLabel);
							}
						});
					}
				});
				chart.hideOverlappingLabels(labels);
			}

			// Do it now ...
			collectAndHide();

			// ... and after each chart redraw
			addEvent(chart, 'redraw', collectAndHide);

		});

		/**
		 * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
		 * visual imression.
		 */		
		Chart.prototype.hideOverlappingLabels = function (labels) {

			var len = labels.length,
				label,
				i,
				j,
				label1,
				label2,
				intersectRect = function (pos1, pos2, size1, size2) {
					return !(
						pos2.x > pos1.x + size1.width ||
						pos2.x + size2.width < pos1.x ||
						pos2.y > pos1.y + size1.height ||
						pos2.y + size2.height < pos1.y
					);
				};
		
			// Mark with initial opacity
			for (i = 0; i < len; i++) {
				label = labels[i];
				if (label) {
					label.oldOpacity = label.opacity;
					label.newOpacity = 1;
				}
			}

			// Detect overlapping labels
			for (i = 0; i < len; i++) {
				label1 = labels[i];

				for (j = i + 1; j < len; ++j) {
					label2 = labels[j];
					if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0 && 
							intersectRect(label1.alignAttr, label2.alignAttr, label1, label2)) {
						(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
					}
				}
			}

			// Hide or show
			for (i = 0; i < len; i++) {
				label = labels[i];
				if (label) {
					if (label.oldOpacity !== label.newOpacity && label.placed) {
						label.alignAttr.opacity = label.newOpacity;
						label[label.isOld && label.newOpacity ? 'animate' : 'attr'](label.alignAttr);
					}
					label.isOld = true;
				}
			}
		};

	}(Highcharts));/**
	 * TrackerMixin for points and graphs
	 */

	var TrackerMixin = Highcharts.TrackerMixin = {

		drawTrackerPoint: function () {
			var series = this,
				chart = series.chart,
				pointer = chart.pointer,
				cursor = series.options.cursor,
				css = cursor && { cursor: cursor },
				onMouseOver = function (e) {
					var target = e.target,
					point;

					while (target && !point) {
						point = target.point;
						target = target.parentNode;
					}

					if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
						point.onMouseOver(e);
					}
				};

			// Add reference to the point
			each(series.points, function (point) {
				if (point.graphic) {
					point.graphic.element.point = point;
				}
				if (point.dataLabel) {
					point.dataLabel.element.point = point;
				}
			});

			// Add the event listeners, we need to do this only once
			if (!series._hasTracking) {
				each(series.trackerGroups, function (key) {
					if (series[key]) { // we don't always have dataLabelsGroup
						series[key]
							.addClass(PREFIX + 'tracker')
							.on('mouseover', onMouseOver)
							.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
							.css(css);
						if (hasTouch) {
							series[key].on('touchstart', onMouseOver);
						}
					}
				});
				series._hasTracking = true;
			}
		},

		/**
		 * Draw the tracker object that sits above all data labels and markers to
		 * track mouse events on the graph or points. For the line type charts
		 * the tracker uses the same graphPath, but with a greater stroke width
		 * for better control.
		 */
		drawTrackerGraph: function () {
			var series = this,
				options = series.options,
				trackByArea = options.trackByArea,
				trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
				trackerPathLength = trackerPath.length,
				chart = series.chart,
				pointer = chart.pointer,
				renderer = chart.renderer,
				snap = chart.options.tooltip.snap,
				tracker = series.tracker,
				cursor = options.cursor,
				css = cursor && { cursor: cursor },
				singlePoints = series.singlePoints,
				singlePoint,
				i,
				onMouseOver = function () {
					if (chart.hoverSeries !== series) {
						series.onMouseOver();
					}
				},
				/*
				 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
				 * IE6: 0.002
				 * IE7: 0.002
				 * IE8: 0.002
				 * IE9: 0.00000000001 (unlimited)
				 * IE10: 0.0001 (exporting only)
				 * FF: 0.00000000001 (unlimited)
				 * Chrome: 0.000001
				 * Safari: 0.000001
				 * Opera: 0.00000000001 (unlimited)
				 */
				TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

			// Extend end points. A better way would be to use round linecaps,
			// but those are not clickable in VML.
			if (trackerPathLength && !trackByArea) {
				i = trackerPathLength + 1;
				while (i--) {
					if (trackerPath[i] === M) { // extend left side
						trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
					}
					if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
						trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
					}
				}
			}

			// handle single points
			for (i = 0; i < singlePoints.length; i++) {
				singlePoint = singlePoints[i];
				trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
				L, singlePoint.plotX + snap, singlePoint.plotY);
			}

			// draw the tracker
			if (tracker) {
				tracker.attr({ d: trackerPath });
			} else { // create

				series.tracker = renderer.path(trackerPath)
				.attr({
					'stroke-linejoin': 'round', // #1225
					visibility: series.visible ? VISIBLE : HIDDEN,
					stroke: TRACKER_FILL,
					fill: trackByArea ? TRACKER_FILL : NONE,
					'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),
					zIndex: 2
				})
				.add(series.group);

				// The tracker is added to the series group, which is clipped, but is covered
				// by the marker group. So the marker group also needs to capture events.
				each([series.tracker, series.markerGroup], function (tracker) {
					tracker.addClass(PREFIX + 'tracker')
						.on('mouseover', onMouseOver)
						.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
						.css(css);

					if (hasTouch) {
						tracker.on('touchstart', onMouseOver);
					}
				});
			}
		}
	};
	/* End TrackerMixin */


	/**
	 * Add tracking event listener to the series group, so the point graphics
	 * themselves act as trackers
	 */ 

	if (seriesTypes.column) {
		ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;	
	}

	if (seriesTypes.pie) {
		seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	}

	if (seriesTypes.scatter) {
		ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	}

	/* 
	 * Extend Legend for item events 
	 */ 
	extend(Legend.prototype, {

		setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
		var legend = this;
		// Set the events on the item group, or in case of useHTML, the item itself (#1249)
		(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
				item.setState(HOVER_STATE);
				legendItem.css(legend.options.itemHoverStyle);
			})
			.on('mouseout', function () {
				legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
				item.setState();
			})
			.on('click', function (event) {
				var strLegendItemClick = 'legendItemClick',
					fnLegendItemClick = function () {
						item.setVisible();
					};
					
				// Pass over the click/touch event. #4.
				event = {
					browserEvent: event
				};

				// click the name or symbol
				if (item.firePointEvent) { // point
					item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
				} else {
					fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
				}
			});
		},

		createCheckboxForItem: function (item) {
			var legend = this;

			item.checkbox = createElement('input', {
				type: 'checkbox',
				checked: item.selected,
				defaultChecked: item.selected // required by IE7
			}, legend.options.itemCheckboxStyle, legend.chart.container);

			addEvent(item.checkbox, 'click', function (event) {
				var target = event.target;
				fireEvent(item.series || item, 'checkboxClick', { // #3712
						checked: target.checked,
						item: item
					},
					function () {
						item.select();
					}
				);
			});
		}	
	});

	/* 
	 * Add pointer cursor to legend itemstyle in defaultOptions
	 */
	defaultOptions.legend.itemStyle.cursor = 'pointer';


	/* 
	 * Extend the Chart object with interaction
	 */

	extend(Chart.prototype, {
		/**
		 * Display the zoom button
		 */
		showResetZoom: function () {
			var chart = this,
				lang = defaultOptions.lang,
				btnOptions = chart.options.chart.resetZoomButton,
				theme = btnOptions.theme,
				states = theme.states,
				alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';
				
			this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)
				.attr({
					align: btnOptions.position.align,
					title: lang.resetZoomTitle
				})
				.add()
				.align(btnOptions.position, false, alignTo);
				
		},

		/**
		 * Zoom out to 1:1
		 */
		zoomOut: function () {
			var chart = this;
			fireEvent(chart, 'selection', { resetSelection: true }, function () { 
				chart.zoom();
			});
		},

		/**
		 * Zoom into a given portion of the chart given by axis coordinates
		 * @param {Object} event
		 */
		zoom: function (event) {
			var chart = this,
				hasZoomed,
				pointer = chart.pointer,
				displayButton = false,
				resetZoomButton;

			// If zoom is called with no arguments, reset the axes
			if (!event || event.resetSelection) {
				each(chart.axes, function (axis) {
					hasZoomed = axis.zoom();
				});
			} else { // else, zoom in on all axes
				each(event.xAxis.concat(event.yAxis), function (axisData) {
					var axis = axisData.axis,
						isXAxis = axis.isXAxis;

					// don't zoom more than minRange
					if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
						hasZoomed = axis.zoom(axisData.min, axisData.max);
						if (axis.displayBtn) {
							displayButton = true;
						}
					}
				});
			}
			
			// Show or hide the Reset zoom button
			resetZoomButton = chart.resetZoomButton;
			if (displayButton && !resetZoomButton) {
				chart.showResetZoom();
			} else if (!displayButton && isObject(resetZoomButton)) {
				chart.resetZoomButton = resetZoomButton.destroy();
			}
			

			// Redraw
			if (hasZoomed) {
				chart.redraw(
					pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
				);
			}
		},

		/**
		 * Pan the chart by dragging the mouse across the pane. This function is called
		 * on mouse move, and the distance to pan is computed from chartX compared to
		 * the first chartX position in the dragging operation.
		 */
		pan: function (e, panning) {

			var chart = this,
				hoverPoints = chart.hoverPoints,
				doRedraw;

			// remove active points for shared tooltip
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
				var mousePos = e[isX ? 'chartX' : 'chartY'],
					axis = chart[isX ? 'xAxis' : 'yAxis'][0],
					startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],
					halfPointRange = (axis.pointRange || 0) / 2,
					extremes = axis.getExtremes(),
					newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
					newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,
					goingLeft = startPos > mousePos; // #3613

				if (axis.series.length && 
						(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && 
						(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
					axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
					doRedraw = true;
				}

				chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run
			});

			if (doRedraw) {
				chart.redraw(false);
			}
			css(chart.container, { cursor: 'move' });
		}
	});

	/*
	 * Extend the Point object with interaction
	 */
	extend(Point.prototype, {
		/**
		 * Toggle the selection status of a point
		 * @param {Boolean} selected Whether to select or unselect the point.
		 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
		 *		 this happens if the control key (Cmd on Mac) was pressed during clicking.
		 */
		select: function (selected, accumulate) {
			var point = this,
				series = point.series,
				chart = series.chart;

			selected = pick(selected, !point.selected);

			// fire the event with the defalut handler
			point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
				point.selected = point.options.selected = selected;
				series.options.data[inArray(point, series.data)] = point.options;

				point.setState(selected && SELECT_STATE);

				// unselect all other points unless Ctrl or Cmd + click
				if (!accumulate) {
					each(chart.getSelectedPoints(), function (loopPoint) {
						if (loopPoint.selected && loopPoint !== point) {
							loopPoint.selected = loopPoint.options.selected = false;
							series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
							loopPoint.setState(NORMAL_STATE);
								loopPoint.firePointEvent('unselect');
						}
					});
				}
			});
		},

		/**
		 * Runs on mouse over the point
		 */
		onMouseOver: function (e) {
			var point = this,
				series = point.series,
				chart = series.chart,
				tooltip = chart.tooltip,
				hoverPoint = chart.hoverPoint;

			if (chart.hoverSeries !== series) {
				series.onMouseOver();
			}		

			// set normal state to previous series
			if (hoverPoint && hoverPoint !== point) {
				hoverPoint.onMouseOut();
			}

			// trigger the event
			point.firePointEvent('mouseOver');

			// update the tooltip
			if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
				tooltip.refresh(point, e);
			}

			// hover this
			point.setState(HOVER_STATE);
			chart.hoverPoint = point;
		},

		/**
		 * Runs on mouse out from the point
		 */
		onMouseOut: function () {
			var chart = this.series.chart,
				hoverPoints = chart.hoverPoints;

			this.firePointEvent('mouseOut');

			if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
				this.setState();
				chart.hoverPoint = null;
			}
		},

		/**
		 * Import events from the series' and point's options. Only do it on
		 * demand, to save processing time on hovering.
		 */
		importEvents: function () {
			if (!this.hasImportedEvents) {
				var point = this,
					options = merge(point.series.options.point, point.options),
					events = options.events,
					eventType;

				point.events = events;

				for (eventType in events) {
					addEvent(point, eventType, events[eventType]);
				}
				this.hasImportedEvents = true;

			}
		},

		/**
		 * Set the point's state
		 * @param {String} state
		 */
		setState: function (state, move) {
			var point = this,
				plotX = point.plotX,
				plotY = point.plotY,
				series = point.series,
				stateOptions = series.options.states,
				markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
				normalDisabled = markerOptions && !markerOptions.enabled,
				markerStateOptions = markerOptions && markerOptions.states[state],
				stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
				stateMarkerGraphic = series.stateMarkerGraphic,
				pointMarker = point.marker || {},
				chart = series.chart,
				radius,
				halo = series.halo,
				haloOptions,
				newSymbol,
				pointAttr;

			state = state || NORMAL_STATE; // empty string
			pointAttr = point.pointAttr[state] || series.pointAttr[state];

			if (
					// already has this state
					(state === point.state && !move) ||
					// selected points don't respond to hover
					(point.selected && state !== SELECT_STATE) ||
					// series' state options is disabled
					(stateOptions[state] && stateOptions[state].enabled === false) ||
					// general point marker's state options is disabled
					(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
					// individual point marker's state options is disabled
					(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

				) {
				return;
			}

			// apply hover styles to the existing point
			if (point.graphic) {
				radius = markerOptions && point.graphic.symbolName && pointAttr.r;
				point.graphic.attr(merge(
					pointAttr,
					radius ? { // new symbol attributes (#507, #612)
						x: plotX - radius,
						y: plotY - radius,
						width: 2 * radius,
						height: 2 * radius
					} : {}
				));

				// Zooming in from a range with no markers to a range with markers
				if (stateMarkerGraphic) {
					stateMarkerGraphic.hide();
				}
			} else {
				// if a graphic is not applied to each point in the normal state, create a shared
				// graphic for the hover state
				if (state && markerStateOptions) {
					radius = markerStateOptions.radius;
					newSymbol = pointMarker.symbol || series.symbol;

					// If the point has another symbol than the previous one, throw away the
					// state marker graphic and force a new one (#1459)
					if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
						stateMarkerGraphic = stateMarkerGraphic.destroy();
					}

					// Add a new state marker graphic
					if (!stateMarkerGraphic) {
						if (newSymbol) {
							series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
								newSymbol,
								plotX - radius,
								plotY - radius,
								2 * radius,
								2 * radius
							)
							.attr(pointAttr)
							.add(series.markerGroup);
							stateMarkerGraphic.currentSymbol = newSymbol;
						}

					// Move the existing graphic
					} else {
						stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
							x: plotX - radius,
							y: plotY - radius
						});
					}
				}

				if (stateMarkerGraphic) {
					stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
				}
			}

			// Show me your halo
			haloOptions = stateOptions[state] && stateOptions[state].halo;
			if (haloOptions && haloOptions.size) {
				if (!halo) {
					series.halo = halo = chart.renderer.path()
						.add(chart.seriesGroup);
				}
				halo.attr(extend({
					fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()
				}, haloOptions.attributes))[move ? 'animate' : 'attr']({
					d: point.haloPath(haloOptions.size)
				});
			} else if (halo) {
				halo.attr({ d: [] });
			}

			point.state = state;
		},

		haloPath: function (size) {
			var series = this.series,
				chart = series.chart,
				plotBox = series.getPlotBox(),
				inverted = chart.inverted;

			return chart.renderer.symbols.circle(
				plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, 
				plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, 
				size * 2, 
				size * 2
			);
		}
	});

	/*
	 * Extend the Series object with interaction
	 */

	extend(Series.prototype, {
		/**
		 * Series mouse over handler
		 */
		onMouseOver: function () {
			var series = this,
				chart = series.chart,
				hoverSeries = chart.hoverSeries;

			// set normal state to previous series
			if (hoverSeries && hoverSeries !== series) {
				hoverSeries.onMouseOut();
			}

			// trigger the event, but to save processing time,
			// only if defined
			if (series.options.events.mouseOver) {
				fireEvent(series, 'mouseOver');
			}

			// hover this
			series.setState(HOVER_STATE);
			chart.hoverSeries = series;
		},

		/**
		 * Series mouse out handler
		 */
		onMouseOut: function () {
			// trigger the event only if listeners exist
			var series = this,
				options = series.options,
				chart = series.chart,
				tooltip = chart.tooltip,
				hoverPoint = chart.hoverPoint;

			// trigger mouse out on the point, which must be in this series
			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			// fire the mouse out event
			if (series && options.events.mouseOut) {
				fireEvent(series, 'mouseOut');
			}


			// hide the tooltip
			if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
				tooltip.hide();
			}

			// set normal state
			series.setState();
			chart.hoverSeries = null;
		},

		/**
		 * Set the state of the graph
		 */
		setState: function (state) {
			var series = this,
				options = series.options,
				graph = series.graph,
				graphNeg = series.graphNeg,
				stateOptions = options.states,
				lineWidth = options.lineWidth,
				attribs;

			state = state || NORMAL_STATE;

			if (series.state !== state) {
				series.state = state;

				if (stateOptions[state] && stateOptions[state].enabled === false) {
					return;
				}

				if (state) {
					lineWidth = (stateOptions[state].lineWidth || lineWidth) + (stateOptions[state].lineWidthPlus || 0);
				}

				if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
					attribs = {
						'stroke-width': lineWidth
					};
					// use attr because animate will cause any other animation on the graph to stop
					graph.attr(attribs);
					if (graphNeg) {
						graphNeg.attr(attribs);
					}
				}
			}
		},

		/**
		 * Set the visibility of the graph
		 *
		 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
		 *				the visibility is toggled.
		 */
		setVisible: function (vis, redraw) {
			var series = this,
				chart = series.chart,
				legendItem = series.legendItem,
				showOrHide,
				ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
				oldVisibility = series.visible;

			// if called without an argument, toggle visibility
			series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
			showOrHide = vis ? 'show' : 'hide';

			// show or hide elements
			each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
				if (series[key]) {
					series[key][showOrHide]();
				}
			});


			// hide tooltip (#1361)
			if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
				series.onMouseOut();
			}


			if (legendItem) {
				chart.legend.colorizeItem(series, vis);
			}


			// rescale or adapt to resized chart
			series.isDirty = true;
			// in a stack, all other series are affected
			if (series.options.stacking) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.options.stacking && otherSeries.visible) {
						otherSeries.isDirty = true;
					}
				});
			}

			// show or hide linked series
			each(series.linkedSeries, function (otherSeries) {
				otherSeries.setVisible(vis, false);
			});

			if (ignoreHiddenSeries) {
				chart.isDirtyBox = true;
			}
			if (redraw !== false) {
				chart.redraw();
			}

			fireEvent(series, showOrHide);
		},

		/**
		 * Show the graph
		 */
		show: function () {
			this.setVisible(true);
		},

		/**
		 * Hide the graph
		 */
		hide: function () {
			this.setVisible(false);
		},


		/**
		 * Set the selected state of the graph
		 *
		 * @param selected {Boolean} True to select the series, false to unselect. If
		 *				UNDEFINED, the selection state is toggled.
		 */
		select: function (selected) {
			var series = this;
			// if called without an argument, toggle
			series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

			if (series.checkbox) {
				series.checkbox.checked = selected;
			}

			fireEvent(series, selected ? 'select' : 'unselect');
		},

		drawTracker: TrackerMixin.drawTrackerGraph
	});
	// global variables
	extend(Highcharts, {
		
		// Constructors
		Color: Color,
		Point: Point,
		Tick: Tick,	
		Renderer: Renderer,
		SVGElement: SVGElement,
		SVGRenderer: SVGRenderer,
		
		// Various
		arrayMin: arrayMin,
		arrayMax: arrayMax,
		charts: charts,
		dateFormat: dateFormat,
		error: error,
		format: format,
		pathAnim: pathAnim,
		getOptions: getOptions,
		hasBidiBug: hasBidiBug,
		isTouchDevice: isTouchDevice,
		setOptions: setOptions,
		addEvent: addEvent,
		removeEvent: removeEvent,
		createElement: createElement,
		discardElement: discardElement,
		css: css,
		each: each,
		map: map,
		merge: merge,
		splat: splat,
		extendClass: extendClass,
		pInt: pInt,
		svg: hasSVG,
		canvas: useCanVG,
		vml: !hasSVG && !useCanVG,
		product: PRODUCT,
		version: VERSION
	});

	}());


	/*** EXPORTS FROM exports-loader ***/
	module.exports = Highcharts

/***/ }
/******/ ])
});

},{"react":184,"react/addons":9}],9:[function(require,module,exports){
var warning = require('./lib/warning');
warning(
  false,
  'require("react/addons") is deprecated. ' +
  'Access using require("react/addons/{addon}") instead.'
);

module.exports = require('./lib/ReactWithAddons');

},{"./lib/ReactWithAddons":111,"./lib/warning":183}],10:[function(require,module,exports){
module.exports = require('../lib/ReactCSSTransitionGroup');

},{"../lib/ReactCSSTransitionGroup":42}],11:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AutoFocusMixin
 * @typechecks static-only
 */

'use strict';

var findDOMNode = require("./findDOMNode");
var focusNode = require("./focusNode");

var AutoFocusMixin = {
  componentDidMount: function () {
    if (this.props.autoFocus) {
      focusNode(findDOMNode(this));
    }
  }
};

module.exports = AutoFocusMixin;
},{"./findDOMNode":142,"./focusNode":144}],12:[function(require,module,exports){
/**
 * Copyright 2013-2015 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var FallbackCompositionState = require("./FallbackCompositionState");
var SyntheticCompositionEvent = require("./SyntheticCompositionEvent");
var SyntheticInputEvent = require("./SyntheticInputEvent");

var keyOf = require("./keyOf");

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBeforeInput: null }),
      captured: keyOf({ onBeforeInputCapture: null })
    },
    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionEnd: null }),
      captured: keyOf({ onCompositionEndCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionStart: null }),
      captured: keyOf({ onCompositionStartCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionUpdate: null }),
      captured: keyOf({ onCompositionUpdateCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionEnd:
      return getDataFromCustomEvent(nativeEvent);
    case topLevelTypes.topKeyPress:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case topLevelTypes.topTextInput:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  if (currentComposition) {
    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case topLevelTypes.topPaste:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case topLevelTypes.topKeyPress:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case topLevelTypes.topCompositionEnd:
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventConstants":25,"./EventPropagators":30,"./ExecutionEnvironment":31,"./FallbackCompositionState":32,"./SyntheticCompositionEvent":117,"./SyntheticInputEvent":121,"./keyOf":166}],13:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSCore
 * @typechecks
 */

'use strict';

var invariant = require("./invariant");

/**
 * The CSSCore module specifies the API (and implements most of the methods)
 * that should be used when dealing with the display of elements (via their
 * CSS classes and visibility on screen. It is an API focused on mutating the
 * display and not reading it as no logical state should be encoded in the
 * display of elements.
 */

var CSSCore = {

  /**
   * Adds the class passed in to the element if it doesn't already have it.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  addClass: function (element, className) {
    !!/\s/.test(className) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'CSSCore.addClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;

    if (className) {
      if (element.classList) {
        element.classList.add(className);
      } else if (!CSSCore.hasClass(element, className)) {
        element.className = element.className + ' ' + className;
      }
    }
    return element;
  },

  /**
   * Removes the class passed in from the element
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  removeClass: function (element, className) {
    !!/\s/.test(className) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'CSSCore.removeClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;

    if (className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (CSSCore.hasClass(element, className)) {
        element.className = element.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ') // multiple spaces to one
        .replace(/^\s*|\s*$/g, ''); // trim the ends
      }
    }
    return element;
  },

  /**
   * Helper to add or remove a class from an element based on a condition.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @param {*} bool condition to whether to add or remove the class
   * @return {DOMElement} the element passed in
   */
  conditionClass: function (element, className, bool) {
    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
  },

  /**
   * Tests whether the element has the class specified.
   *
   * @param {DOMNode|DOMWindow} element the element to set the class on
   * @param {string} className the CSS className
   * @return {boolean} true if the element has the class, false if not
   */
  hasClass: function (element, className) {
    !!/\s/.test(className) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'CSS.hasClass takes only a single class name.') : invariant(false) : undefined;
    if (element.classList) {
      return !!className && element.classList.contains(className);
    }
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
  }

};

module.exports = CSSCore;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],14:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  boxFlex: true,
  boxFlexGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundImage: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundColor: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],15:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require("./CSSProperty");
var ExecutionEnvironment = require("./ExecutionEnvironment");

var camelizeStyleName = require("./camelizeStyleName");
var dangerousStyleValue = require("./dangerousStyleValue");
var hyphenateStyleName = require("./hyphenateStyleName");
var memoizeStringOnly = require("./memoizeStringOnly");
var warning = require("./warning");

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if ('production' !== process.env.NODE_ENV) {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    'production' !== process.env.NODE_ENV ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    'production' !== process.env.NODE_ENV ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    'production' !== process.env.NODE_ENV ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
  };

  /**
   * @param {string} name
   * @param {*} value
   */
  var warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function (styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if ('production' !== process.env.NODE_ENV) {
        warnValidStyle(styleName, styleValue);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function (node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if ('production' !== process.env.NODE_ENV) {
        warnValidStyle(styleName, styles[styleName]);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleName === 'float') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;
}).call(this,require('_process'))

},{"./CSSProperty":14,"./ExecutionEnvironment":31,"./camelizeStyleName":132,"./dangerousStyleValue":138,"./hyphenateStyleName":157,"./memoizeStringOnly":168,"./warning":183,"_process":2}],16:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CallbackQueue
 */

'use strict';

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var invariant = require("./invariant");

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

assign(CallbackQueue.prototype, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function (callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function () {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      !(callbacks.length === contexts.length) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function () {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function () {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;
}).call(this,require('_process'))

},{"./Object.assign":37,"./PooledClass":38,"./invariant":159,"_process":2}],17:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ChangeEventPlugin
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var isEventSupported = require("./isEventSupported");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onChange: null }),
      captured: keyOf({ onChangeCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  return elem.nodeName === 'SELECT' || elem.nodeName === 'INPUT' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue();
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName === 'INPUT' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
      if (targetID) {
        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"./EventConstants":25,"./EventPluginHub":27,"./EventPropagators":30,"./ExecutionEnvironment":31,"./ReactUpdates":110,"./SyntheticEvent":119,"./isEventSupported":160,"./isTextInputElement":162,"./keyOf":166}],18:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

'use strict';

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function () {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;
},{}],19:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

'use strict';

var Danger = require("./Danger");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var setTextContent = require("./setTextContent");
var invariant = require("./invariant");

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.

  // fix render order error in safari
  // IE8 will throw error when index out of list size.
  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

  parentNode.insertBefore(childNode, beforeChild);
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: setTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function (updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; i < updates.length; i++) {
      update = updates[i];
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        !updatedChild ? 'production' !== process.env.NODE_ENV ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; k < updates.length; k++) {
      update = updates[k];
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          setTextContent(update.parentNode, update.textContent);
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;
}).call(this,require('_process'))

},{"./Danger":22,"./ReactMultiChildUpdateTypes":90,"./invariant":159,"./setTextContent":175,"_process":2}],20:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

'use strict';

var invariant = require("./invariant");

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 1,
  MUST_USE_PROPERTY: 2,
  HAS_SIDE_EFFECTS: 4,
  HAS_BOOLEAN_VALUE: 8,
  HAS_NUMERIC_VALUE: 16,
  HAS_POSITIVE_NUMERIC_VALUE: 32 | 16,
  HAS_OVERLOADED_BOOLEAN_VALUE: 64,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.isStandardName.hasOwnProperty(propName) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

      DOMProperty.isStandardName[propName] = true;

      var lowerCased = propName.toLowerCase();
      DOMProperty.getPossibleStandardName[lowerCased] = propName;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        DOMProperty.getPossibleStandardName[attributeName] = propName;
        DOMProperty.getAttributeName[propName] = attributeName;
      } else {
        DOMProperty.getAttributeName[propName] = lowerCased;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        DOMProperty.getAttributeNamespace[propName] = DOMAttributeNamespaces[propName];
      } else {
        DOMProperty.getAttributeNamespace[propName] = null;
      }

      DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName;

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
      } else {
        DOMProperty.getMutationMethod[propName] = null;
      }

      var propConfig = Properties[propName];
      DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
      DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
      DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
      DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
      DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
      DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
      DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);

      !(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
      !(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
      !(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Checks whether a property name is a standard property.
   * @type {Object}
   */
  isStandardName: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties.
   * @type {Object}
   */
  getPossibleStandardName: {},

  /**
   * Mapping from normalized names to attribute names that differ. Attribute
   * names are used when rendering markup or with `*Attribute()`.
   * @type {Object}
   */
  getAttributeName: {},

  /**
   * Mapping from normalized names to namespaces.
   * @type {Object}
   */
  getAttributeNamespace: {},

  /**
   * Mapping from normalized names to properties on DOM node instances.
   * (This includes properties that mutate due to external factors.)
   * @type {Object}
   */
  getPropertyName: {},

  /**
   * Mapping from normalized names to mutation methods. This will only exist if
   * mutation cannot be set simply by the property or `setAttribute()`.
   * @type {Object}
   */
  getMutationMethod: {},

  /**
   * Whether the property must be accessed and mutated as an object property.
   * @type {Object}
   */
  mustUseAttribute: {},

  /**
   * Whether the property must be accessed and mutated using `*Attribute()`.
   * (This includes anything that fails `<propName> in <element>`.)
   * @type {Object}
   */
  mustUseProperty: {},

  /**
   * Whether or not setting a value causes side effects such as triggering
   * resources to be loaded or text selection changes. We must ensure that
   * the value is only set if it has changed.
   * @type {Object}
   */
  hasSideEffects: {},

  /**
   * Whether the property should be removed when set to a falsey value.
   * @type {Object}
   */
  hasBooleanValue: {},

  /**
   * Whether the property must be numeric or parse as a
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasNumericValue: {},

  /**
   * Whether the property must be positive numeric or parse as a positive
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasPositiveNumericValue: {},

  /**
   * Whether the property can be used as a flag as well as with a value. Removed
   * when strictly equal to false; present without a value when strictly equal
   * to true; present with a value otherwise.
   * @type {Object}
   */
  hasOverloadedBooleanValue: {},

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function (nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],21:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require("./DOMProperty");

var quoteAttributeValueForBrowser = require("./quoteAttributeValueForBrowser");
var warning = require("./warning");

function shouldIgnoreValue(name, value) {
  return value == null || DOMProperty.hasBooleanValue[name] && !value || DOMProperty.hasNumericValue[name] && isNaN(value) || DOMProperty.hasPositiveNumericValue[name] && value < 1 || DOMProperty.hasOverloadedBooleanValue[name] && value === false;
}

if ('production' !== process.env.NODE_ENV) {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function (name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    'production' !== process.env.NODE_ENV ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
      if (shouldIgnoreValue(name, value)) {
        return '';
      }
      var attributeName = DOMProperty.getAttributeName[name];
      if (DOMProperty.hasBooleanValue[name] || DOMProperty.hasOverloadedBooleanValue[name] && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    } else if ('production' !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(name, value)) {
        this.deleteValueForProperty(node, name);
      } else if (DOMProperty.mustUseAttribute[name]) {
        var attributeName = DOMProperty.getAttributeName[name];
        var namespace = DOMProperty.getAttributeNamespace[name];
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      } else {
        var propName = DOMProperty.getPropertyName[name];
        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
        // property type before comparing; only `value` does and is string.
        if (!DOMProperty.hasSideEffects[name] || '' + node[propName] !== '' + value) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        node.removeAttribute(name);
      } else {
        node.setAttribute(name, '' + value);
      }
    } else if ('production' !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (DOMProperty.mustUseAttribute[name]) {
        node.removeAttribute(DOMProperty.getAttributeName[name]);
      } else {
        var propName = DOMProperty.getPropertyName[name];
        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
        if (!DOMProperty.hasSideEffects[name] || '' + node[propName] !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if ('production' !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  }

};

module.exports = DOMPropertyOperations;
}).call(this,require('_process'))

},{"./DOMProperty":20,"./quoteAttributeValueForBrowser":172,"./warning":183,"_process":2}],22:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createNodesFromMarkup = require("./createNodesFromMarkup");
var emptyFunction = require("./emptyFunction");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function (markupList) {
    !ExecutionEnvironment.canUseDOM ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(false) : undefined;
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      !markupList[i] ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      var resultIndex;
      for (resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
          // This index will be parsed back out below.
          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
      );

      for (var j = 0; j < renderNodes.length; ++j) {
        var renderNode = renderNodes[j];
        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          !!resultList.hasOwnProperty(resultIndex) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;
        } else if ('production' !== process.env.NODE_ENV) {
          console.error('Danger: Discarding unexpected node:', renderNode);
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    !(resultListAssignmentCount === resultList.length) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

    !(resultList.length === markupList.length) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(false) : undefined;
    !markup ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
    !(oldChild.tagName.toLowerCase() !== 'html') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See React.renderToString().') : invariant(false) : undefined;

    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":31,"./createNodesFromMarkup":137,"./emptyFunction":139,"./getMarkupWrap":152,"./invariant":159,"_process":2}],23:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultEventPluginOrder
 */

'use strict';

var keyOf = require("./keyOf");

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null }), keyOf({ AnalyticsEventPlugin: null })];

module.exports = DefaultEventPluginOrder;
},{"./keyOf":166}],24:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");

var ReactMount = require("./ReactMount");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({ onMouseEnter: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  },
  mouseLeave: {
    registrationName: keyOf({ onMouseLeave: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from, to;
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
    } else {
      from = win;
      to = topLevelTarget;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromID = from ? ReactMount.getID(from) : '';
    var toID = to ? ReactMount.getID(to) : '';

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;
},{"./EventConstants":25,"./EventPropagators":30,"./ReactMount":88,"./SyntheticMouseEvent":123,"./keyOf":166}],25:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

'use strict';

var keyMirror = require("./keyMirror");

var PropagationPhases = keyMirror({ bubbled: null, captured: null });

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topBlur: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topReset: null,
  topScroll: null,
  topSelectionChange: null,
  topSubmit: null,
  topTextInput: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;
},{"./keyMirror":165}],26:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventListener
 * @typechecks
 */

'use strict';

var emptyFunction = require("./emptyFunction");

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function (target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function () {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function (target, eventType, callback) {
    if (!target.addEventListener) {
      if ('production' !== process.env.NODE_ENV) {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    } else {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, true);
        }
      };
    }
  },

  registerDefault: function () {}
};

module.exports = EventListener;
}).call(this,require('_process'))

},{"./emptyFunction":139,"_process":2}],27:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

'use strict';

var EventPluginRegistry = require("./EventPluginRegistry");
var EventPluginUtils = require("./EventPluginUtils");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");
var warning = require("./warning");

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */
var executeDispatchesAndRelease = function (event) {
  if (event) {
    var executeDispatch = EventPluginUtils.executeDispatch;
    // Plugins can provide custom behavior when dispatching events.
    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
    if (PluginModule && PluginModule.executeDispatch) {
      executeDispatch = PluginModule.executeDispatch;
    }
    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
  'production' !== process.env.NODE_ENV ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function (InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if ('production' !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function () {
      if ('production' !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function (id, registrationName, listener) {
    !(typeof listener === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;

    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(id, registrationName, listener);
    }
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (id, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(id, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function (id) {
    for (var registrationName in listenerBank) {
      if (!listenerBank[registrationName][id]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(id, registrationName);
      }

      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function () {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
    !!eventQueue ? 'production' !== process.env.NODE_ENV ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
}).call(this,require('_process'))

},{"./EventPluginRegistry":28,"./EventPluginUtils":29,"./accumulateInto":129,"./forEachAccumulated":145,"./invariant":159,"./warning":183,"_process":2}],28:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

'use strict';

var invariant = require("./invariant");

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !PluginModule.extractEvents ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (InjectedEventPluginOrder) {
    !!EventPluginOrder ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
        !!namesToPlugins[pluginName] ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],29:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

'use strict';

var EventConstants = require("./EventConstants");

var invariant = require("./invariant");
var warning = require("./warning");

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function (InjectedMount) {
    injection.Mount = InjectedMount;
    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
}

var validateEventDispatches;
if ('production' !== process.env.NODE_ENV) {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    'production' !== process.env.NODE_ENV ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
  };
}

/**
 * Invokes `cb(event, listener, id)`. Avoids using call if no scope is
 * provided. The `(listener,id)` pair effectively forms the "dispatch" but are
 * kept separate to conserve memory.
 */
function forEachEventDispatch(event, cb) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ('production' !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      cb(event, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    cb(event, dispatchListeners, dispatchIDs);
  }
}

/**
 * Default implementation of PluginModule.executeDispatch().
 * @param {SyntheticEvent} SyntheticEvent to handle
 * @param {function} Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, listener, domID) {
  event.currentTarget = injection.Mount.getNode(domID);
  var returnValue = listener(event, domID);
  event.currentTarget = null;
  return returnValue;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, cb) {
  forEachEventDispatch(event, cb);
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return id of the first dispatch execution who's listener returns true, or
 * null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ('production' !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ('production' !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  !!Array.isArray(dispatchListener) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {bool} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatch: executeDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getNode: function (id) {
    return injection.Mount.getNode(id);
  },
  getID: function (node) {
    return injection.Mount.getID(node);
  },

  injection: injection
};

module.exports = EventPluginUtils;
}).call(this,require('_process'))

},{"./EventConstants":25,"./invariant":159,"./warning":183,"_process":2}],30:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");

var warning = require("./warning");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(domID, 'Dispatching id must not be null') : undefined;
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We can not perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
}).call(this,require('_process'))

},{"./EventConstants":25,"./EventPluginHub":27,"./accumulateInto":129,"./forEachAccumulated":145,"./warning":183,"_process":2}],31:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],32:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FallbackCompositionState
 * @typechecks static-only
 */

'use strict';

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var getTextContentAccessor = require("./getTextContentAccessor");

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

assign(FallbackCompositionState.prototype, {
  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./Object.assign":37,"./PooledClass":38,"./getTextContentAccessor":154}],33:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

'use strict';

var DOMProperty = require("./DOMProperty");
var ExecutionEnvironment = require("./ExecutionEnvironment");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
}

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    acceptCharset: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusMixin
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    classID: MUST_USE_ATTRIBUTE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formAction: MUST_USE_ATTRIBUTE,
    formEncType: MUST_USE_ATTRIBUTE,
    formMethod: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: MUST_USE_ATTRIBUTE,
    frameBorder: MUST_USE_ATTRIBUTE,
    headers: null,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    high: null,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    label: null,
    lang: null,
    list: MUST_USE_ATTRIBUTE,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    low: null,
    manifest: MUST_USE_ATTRIBUTE,
    marginHeight: null,
    marginWidth: null,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    media: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    minLength: MUST_USE_ATTRIBUTE,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: null,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: null,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    sizes: MUST_USE_ATTRIBUTE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcSet: MUST_USE_ATTRIBUTE,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: null,
    autoCorrect: null,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: MUST_USE_ATTRIBUTE,
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    itemType: MUST_USE_ATTRIBUTE,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: MUST_USE_ATTRIBUTE,
    itemRef: MUST_USE_ATTRIBUTE,
    // property is supported for OpenGraph in meta tags.
    property: null,
    // IE-only attribute that controls focus behavior
    unselectable: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoCapitalize: 'autocapitalize',
    autoComplete: 'autocomplete',
    autoCorrect: 'autocorrect',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
    encType: 'encoding',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":20,"./ExecutionEnvironment":31}],34:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedStateMixin
 * @typechecks static-only
 */

'use strict';

var ReactLink = require("./ReactLink");
var ReactStateSetters = require("./ReactStateSetters");

/**
 * A simple mixin around ReactLink.forState().
 */
var LinkedStateMixin = {
  /**
   * Create a ReactLink that's linked to part of this component's state. The
   * ReactLink will have the current value of this.state[key] and will call
   * setState() when a change is requested.
   *
   * @param {string} key state key to update. Note: you may want to use keyOf()
   * if you're using Google Closure Compiler advanced mode.
   * @return {ReactLink} ReactLink instance linking to the state.
   */
  linkState: function (key) {
    return new ReactLink(this.state[key], ReactStateSetters.createStateKeySetter(this, key));
  }
};

module.exports = LinkedStateMixin;
},{"./ReactLink":86,"./ReactStateSetters":104}],35:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

'use strict';

var ReactPropTypes = require("./ReactPropTypes");

var invariant = require("./invariant");

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
}

/**
 * @param {SyntheticEvent} e change event to handle
 */
function _handleLinkedValueChange(e) {
  /*jshint validthis:true */
  this.props.valueLink.requestChange(e.target.value);
}

/**
  * @param {SyntheticEvent} e change event to handle
  */
function _handleLinkedCheckChange(e) {
  /*jshint validthis:true */
  this.props.checkedLink.requestChange(e.target.checked);
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  Mixin: {
    propTypes: {
      value: function (props, propName, componentName) {
        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      checked: function (props, propName, componentName) {
        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      onChange: ReactPropTypes.func
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {function} change callback either from onChange prop or link.
   */
  getOnChange: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return _handleLinkedValueChange;
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return _handleLinkedCheckChange;
    }
    return inputProps.onChange;
  }
};

module.exports = LinkedValueUtils;
}).call(this,require('_process'))

},{"./ReactPropTypes":97,"./invariant":159,"_process":2}],36:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LocalEventTrapMixin
 */

'use strict';

var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");

var accumulateInto = require("./accumulateInto");
var findDOMNode = require("./findDOMNode");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");

function remove(event) {
  event.remove();
}

var LocalEventTrapMixin = {
  trapBubbledEvent: function (topLevelType, handlerBaseName) {
    !this.isMounted() ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
    // If a component renders to null or if another component fatals and causes
    // the state of the tree to be corrupted, `node` here can be null.
    var node = findDOMNode(this);
    !node ? 'production' !== process.env.NODE_ENV ? invariant(false, 'LocalEventTrapMixin.trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
    var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, node);
    this._localEventListeners = accumulateInto(this._localEventListeners, listener);
  },

  // trapCapturedEvent would look nearly identical. We don't implement that
  // method because it isn't currently needed.

  componentWillUnmount: function () {
    if (this._localEventListeners) {
      forEachAccumulated(this._localEventListeners, remove);
    }
  }
};

module.exports = LocalEventTrapMixin;
}).call(this,require('_process'))

},{"./ReactBrowserEventEmitter":41,"./accumulateInto":129,"./findDOMNode":142,"./forEachAccumulated":145,"./invariant":159,"_process":2}],37:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;
},{}],38:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

'use strict';

var invariant = require("./invariant");

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
  if (instance.destructor) {
    instance.destructor();
  }
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],39:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

var ReactDOMClient = require("./ReactDOMClient");
var ReactDOMServer = require("./ReactDOMServer");
var ReactIsomorphic = require("./ReactIsomorphic");

var assign = require("./Object.assign");

var React = {};

assign(React, ReactIsomorphic);
assign(React, ReactDOMClient);
assign(React, ReactDOMServer);

React.version = '0.14.0-alpha3';

module.exports = React;
},{"./Object.assign":37,"./ReactDOMClient":56,"./ReactDOMServer":66,"./ReactIsomorphic":84}],40:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserComponentMixin
 */

'use strict';

var ReactInstanceMap = require("./ReactInstanceMap");

var findDOMNode = require("./findDOMNode");
var warning = require("./warning");

var didWarnKey = '_getDOMNodeDidWarn';

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function () {
    'production' !== process.env.NODE_ENV ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'React.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
    this.constructor[didWarnKey] = true;
    return findDOMNode(this);
  }
};

module.exports = ReactBrowserComponentMixin;
}).call(this,require('_process'))

},{"./ReactInstanceMap":83,"./findDOMNode":142,"./warning":183,"_process":2}],41:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPluginRegistry = require("./EventPluginRegistry");
var ReactEventEmitterMixin = require("./ReactEventEmitterMixin");
var ViewportMetrics = require("./ViewportMetrics");

var assign = require("./Object.assign");
var isEventSupported = require("./isEventSupported");

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topBlur: 'blur',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topScroll: 'scroll',
  topSelectionChange: 'selectionchange',
  topTextInput: 'textInput',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

module.exports = ReactBrowserEventEmitter;
},{"./EventConstants":25,"./EventPluginHub":27,"./EventPluginRegistry":28,"./Object.assign":37,"./ReactEventEmitterMixin":77,"./ViewportMetrics":128,"./isEventSupported":160}],42:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroup
 */

'use strict';

var React = require("./React");

var assign = require("./Object.assign");

var ReactTransitionGroup = React.createFactory(require("./ReactTransitionGroup"));
var ReactCSSTransitionGroupChild = React.createFactory(require("./ReactCSSTransitionGroupChild"));

var ReactCSSTransitionGroup = React.createClass({
  displayName: 'ReactCSSTransitionGroup',

  propTypes: {
    transitionName: React.PropTypes.string.isRequired,
    transitionAppear: React.PropTypes.bool,
    transitionEnter: React.PropTypes.bool,
    transitionLeave: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      transitionAppear: false,
      transitionEnter: true,
      transitionLeave: true
    };
  },

  _wrapChild: function (child) {
    // We need to provide this childFactory so that
    // ReactCSSTransitionGroupChild can receive updates to name, enter, and
    // leave while it is leaving.
    return ReactCSSTransitionGroupChild({
      name: this.props.transitionName,
      appear: this.props.transitionAppear,
      enter: this.props.transitionEnter,
      leave: this.props.transitionLeave
    }, child);
  },

  render: function () {
    return ReactTransitionGroup(assign({}, this.props, { childFactory: this._wrapChild }));
  }
});

module.exports = ReactCSSTransitionGroup;
},{"./Object.assign":37,"./React":39,"./ReactCSSTransitionGroupChild":43,"./ReactTransitionGroup":108}],43:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroupChild
 */

'use strict';

var React = require("./React");

var CSSCore = require("./CSSCore");
var ReactTransitionEvents = require("./ReactTransitionEvents");

var onlyChild = require("./onlyChild");
var warning = require("./warning");

// We don't remove the element from the DOM until we receive an animationend or
// transitionend event. If the user screws up and forgets to add an animation
// their node will be stuck in the DOM forever, so we detect if an animation
// does not start and if it doesn't, we just call the end listener immediately.
var TICK = 17;
var NO_EVENT_TIMEOUT = 5000;

var noEventListener = null;

if ('production' !== process.env.NODE_ENV) {
  noEventListener = function () {
    'production' !== process.env.NODE_ENV ? warning(false, 'transition(): tried to perform an animation without ' + 'an animationend or transitionend event after timeout (' + '%sms). You should either disable this ' + 'transition in JS or add a CSS animation/transition.', NO_EVENT_TIMEOUT) : undefined;
  };
}

var ReactCSSTransitionGroupChild = React.createClass({
  displayName: 'ReactCSSTransitionGroupChild',

  transition: function (animationType, finishCallback) {
    var node = React.findDOMNode(this);
    var className = this.props.name + '-' + animationType;
    var activeClassName = className + '-active';
    var noEventTimeout = null;

    var endListener = function (e) {
      if (e && e.target !== node) {
        return;
      }
      if ('production' !== process.env.NODE_ENV) {
        clearTimeout(noEventTimeout);
      }

      CSSCore.removeClass(node, className);
      CSSCore.removeClass(node, activeClassName);

      ReactTransitionEvents.removeEndEventListener(node, endListener);

      // Usually this optional callback is used for informing an owner of
      // a leave animation and telling it to remove the child.
      if (finishCallback) {
        finishCallback();
      }
    };

    ReactTransitionEvents.addEndEventListener(node, endListener);

    CSSCore.addClass(node, className);

    // Need to do this to actually trigger a transition.
    this.queueClass(activeClassName);

    if ('production' !== process.env.NODE_ENV) {
      noEventTimeout = setTimeout(noEventListener, NO_EVENT_TIMEOUT);
    }
  },

  queueClass: function (className) {
    this.classNameQueue.push(className);

    if (!this.timeout) {
      this.timeout = setTimeout(this.flushClassNameQueue, TICK);
    }
  },

  flushClassNameQueue: function () {
    if (this.isMounted()) {
      this.classNameQueue.forEach(CSSCore.addClass.bind(CSSCore, React.findDOMNode(this)));
    }
    this.classNameQueue.length = 0;
    this.timeout = null;
  },

  componentWillMount: function () {
    this.classNameQueue = [];
  },

  componentWillUnmount: function () {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
  },

  componentWillAppear: function (done) {
    if (this.props.appear) {
      this.transition('appear', done);
    } else {
      done();
    }
  },

  componentWillEnter: function (done) {
    if (this.props.enter) {
      this.transition('enter', done);
    } else {
      done();
    }
  },

  componentWillLeave: function (done) {
    if (this.props.leave) {
      this.transition('leave', done);
    } else {
      done();
    }
  },

  render: function () {
    return onlyChild(this.props.children);
  }
});

module.exports = ReactCSSTransitionGroupChild;
}).call(this,require('_process'))

},{"./CSSCore":13,"./React":39,"./ReactTransitionEvents":107,"./onlyChild":169,"./warning":183,"_process":2}],44:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildReconciler
 * @typechecks static-only
 */

'use strict';

var ReactReconciler = require("./ReactReconciler");

var flattenChildren = require("./flattenChildren");
var instantiateReactComponent = require("./instantiateReactComponent");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {

  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context) {
    var children = flattenChildren(nestedChildNodes);
    for (var name in children) {
      if (children.hasOwnProperty(name)) {
        var child = children[name];
        // The rendered children must be turned into instances as they're
        // mounted.
        var childInstance = instantiateReactComponent(child, null);
        children[name] = childInstance;
      }
    }
    return children;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextNestedChildNodes Nested child maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextNestedChildNodes, transaction, context) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    var nextChildren = flattenChildren(nextNestedChildNodes);
    if (!nextChildren && !prevChildren) {
      return null;
    }
    var name;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      var prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          ReactReconciler.unmountComponent(prevChild, name);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, null);
        nextChildren[name] = nextChildInstance;
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        ReactReconciler.unmountComponent(prevChildren[name]);
      }
    }
    return nextChildren;
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild);
      }
    }
  }

};

module.exports = ReactChildReconciler;
},{"./ReactReconciler":99,"./flattenChildren":143,"./instantiateReactComponent":158,"./shouldUpdateReactComponent":178}],45:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

'use strict';

var PooledClass = require("./PooledClass");
var ReactFragment = require("./ReactFragment");

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var threeArgumentPooler = PooledClass.threeArgumentPooler;

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(traverseContext, child, name) {
  var bookKeeping = traverseContext;
  bookKeeping.func.call(bookKeeping.context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc.
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }

  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, mapFunction, mapContext) {
  this.result = mapResult;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);

function mapSingleChildIntoContext(traverseContext, child, name) {
  var bookKeeping = traverseContext;
  var mapResult = bookKeeping.result;

  var keyUnique = mapResult[name] === undefined;
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(keyUnique, 'ReactChildren.map(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }

  if (keyUnique) {
    var mappedChild = bookKeeping.func.call(bookKeeping.context, child, bookKeeping.count++);
    mapResult[name] = mappedChild;
  }
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * TODO: This may likely break any calls to `ReactChildren.map` that were
 * previously relying on the fact that we guarded against null children.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} mapFunction.
 * @param {*} mapContext Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var mapResult = {};
  var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
  return ReactFragment.create(mapResult);
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  count: countChildren
};

module.exports = ReactChildren;
}).call(this,require('_process'))

},{"./PooledClass":38,"./ReactFragment":79,"./traverseAllChildren":180,"./warning":183,"_process":2}],46:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */

'use strict';

var ReactComponent = require("./ReactComponent");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactErrorUtils = require("./ReactErrorUtils");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactLifeCycle = require("./ReactLifeCycle");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactUpdateQueue = require("./ReactUpdateQueue");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var keyMirror = require("./keyMirror");
var keyOf = require("./keyOf");
var warning = require("./warning");

var MIXINS_KEY = keyOf({ mixins: null });

/**
 * Policies that describe methods in `ReactClassInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});

var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if ('production' !== process.env.NODE_ENV) {
      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if ('production' !== process.env.NODE_ENV) {
      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if ('production' !== process.env.NODE_ENV) {
      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  }
};

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but not in __DEV__
      'production' !== process.env.NODE_ENV ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  !(typeof spec !== 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
  !!ReactElement.isValidElement(spec) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

  var proto = Constructor.prototype;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if ('production' !== process.env.NODE_ENV) {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = (name in RESERVED_SPEC_KEYS);
    !!isReserved ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

    var isInherited = (name in Constructor);
    !!isInherited ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if ('production' !== process.env.NODE_ENV) {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    /* eslint-disable block-scoped-var, no-undef */
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        'production' !== process.env.NODE_ENV ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
      } else if (!args.length) {
        'production' !== process.env.NODE_ENV ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
      /* eslint-enable */
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  for (var autoBindKey in component.__reactAutoBindMap) {
    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
      var method = component.__reactAutoBindMap[autoBindKey];
      component[autoBindKey] = bindAutoBindMethod(component, ReactErrorUtils.guard(method, component.constructor.displayName + '.' + autoBindKey));
    }
  }
}

var typeDeprecationDescriptor = {
  enumerable: false,
  get: function () {
    var displayName = this.displayName || this.name || 'Component';
    'production' !== process.env.NODE_ENV ? warning(false, '%s.type is deprecated. Use %s directly to access the class.', displayName, displayName) : undefined;
    Object.defineProperty(this, 'type', {
      value: this
    });
    return this;
  }
};

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    ReactUpdateQueue.enqueueReplaceState(this, newState);
    if (callback) {
      ReactUpdateQueue.enqueueCallback(this, callback);
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    if ('production' !== process.env.NODE_ENV) {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        'production' !== process.env.NODE_ENV ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(this);
    if (internalInstance) {
      return internalInstance !== ReactLifeCycle.currentlyMountingInstance;
    } else {
      return false;
    }
  },

  /**
   * Sets a subset of the props.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  setProps: function (partialProps, callback) {
    ReactUpdateQueue.enqueueSetProps(this, partialProps);
    if (callback) {
      ReactUpdateQueue.enqueueCallback(this, callback);
    }
  },

  /**
   * Replace all the props.
   *
   * @param {object} newProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  replaceProps: function (newProps, callback) {
    ReactUpdateQueue.enqueueReplaceProps(this, newProps);
    if (callback) {
      ReactUpdateQueue.enqueueCallback(this, callback);
    }
  }
};

var ReactClassComponent = function () {};
assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    var Constructor = function (props, context) {
      // This constructor is overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if ('production' !== process.env.NODE_ENV) {
        'production' !== process.env.NODE_ENV ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindMap) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if ('production' !== process.env.NODE_ENV) {
        // We allow auto-mocks to proceed as if they're returning null.
        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

      this.state = initialState;
    };
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if ('production' !== process.env.NODE_ENV) {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? 'production' !== process.env.NODE_ENV ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    // Legacy hook
    Constructor.type = Constructor;
    if ('production' !== process.env.NODE_ENV) {
      try {
        Object.defineProperty(Constructor, 'type', typeDeprecationDescriptor);
      } catch (x) {}
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;

// IE will fail on defineProperty (es5-shim/sham too)
}).call(this,require('_process'))

},{"./Object.assign":37,"./ReactComponent":47,"./ReactCurrentOwner":53,"./ReactElement":73,"./ReactErrorUtils":76,"./ReactInstanceMap":83,"./ReactLifeCycle":85,"./ReactPropTypeLocationNames":95,"./ReactPropTypeLocations":96,"./ReactUpdateQueue":109,"./invariant":159,"./keyMirror":165,"./keyOf":166,"./warning":183,"_process":2}],47:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

'use strict';

var ReactUpdateQueue = require("./ReactUpdateQueue");

var invariant = require("./invariant");
var warning = require("./warning");

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context) {
  this.props = props;
  this.context = context;
}

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
  }
  ReactUpdateQueue.enqueueSetState(this, partialState);
  if (callback) {
    ReactUpdateQueue.enqueueCallback(this, callback);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  ReactUpdateQueue.enqueueForceUpdate(this);
  if (callback) {
    ReactUpdateQueue.enqueueCallback(this, callback);
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if ('production' !== process.env.NODE_ENV) {
  var deprecatedAPIs = {
    getDOMNode: ['getDOMNode', 'Use React.findDOMNode(component) instead.'],
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceProps: ['replaceProps', 'Instead, call React.render again at the top level.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
    setProps: ['setProps', 'Instead, call React.render again at the top level.']
  };
  var defineDeprecationWarning = function (methodName, info) {
    try {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          'production' !== process.env.NODE_ENV ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
          return undefined;
        }
      });
    } catch (x) {}
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;

// IE will fail on defineProperty (es5-shim/sham too)
}).call(this,require('_process'))

},{"./ReactUpdateQueue":109,"./invariant":159,"./warning":183,"_process":2}],48:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

'use strict';

var ReactDOMIDOperations = require("./ReactDOMIDOperations");
var ReactMount = require("./ReactMount");

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function (rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  }

};

module.exports = ReactComponentBrowserEnvironment;
},{"./ReactDOMIDOperations":59,"./ReactMount":88}],49:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentEnvironment
 */

'use strict';

var invariant = require("./invariant");

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable environment dependent cleanup hook. (server vs.
   * browser etc). Example: A browser system caches DOM nodes based on component
   * ID and must remove that cache entry when this instance is unmounted.
   */
  unmountIDFromEnvironment: null,

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkupByID: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],50:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule ReactComponentWithPureRenderMixin
*/

'use strict';

var shallowCompare = require("./shallowCompare");

/**
 * If your React component's render function is "pure", e.g. it will render the
 * same result given the same props and state, provide this Mixin for a
 * considerable performance boost.
 *
 * Most React components have pure render functions.
 *
 * Example:
 *
 *   var ReactComponentWithPureRenderMixin =
 *     require('ReactComponentWithPureRenderMixin');
 *   React.createClass({
 *     mixins: [ReactComponentWithPureRenderMixin],
 *
 *     render: function() {
 *       return <div className={this.props.className}>foo</div>;
 *     }
 *   });
 *
 * Note: This only checks shallow equality for props and state. If these contain
 * complex data structures this mixin may have false-negatives for deeper
 * differences. Only mixin to components which have simple props and state, or
 * use `forceUpdate()` when you know deep data structures have changed.
 */
var ReactComponentWithPureRenderMixin = {
  shouldComponentUpdate: function (nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }
};

module.exports = ReactComponentWithPureRenderMixin;
},{"./shallowCompare":176}],51:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

'use strict';

var ReactComponentEnvironment = require("./ReactComponentEnvironment");
var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactLifeCycle = require("./ReactLifeCycle");
var ReactNativeComponent = require("./ReactNativeComponent");
var ReactPerf = require("./ReactPerf");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactReconciler = require("./ReactReconciler");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var emptyObject = require("./emptyObject");
var invariant = require("./invariant");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var warning = require("./warning");

function getDeclarationErrorAddendum(component) {
  var owner = component._currentElement._owner || null;
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = null;
    this._instance = null;

    // See ReactUpdateQueue
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedComponent = null;

    this._context = null;
    this._mountOrder = 0;
    this._isTopLevel = false;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    this._context = context;
    this._mountOrder = nextMountID++;
    this._rootNodeID = rootID;

    var publicProps = this._processProps(this._currentElement.props);
    var publicContext = this._processContext(context);

    var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);

    // Initialize the public class
    var inst = new Component(publicProps, publicContext);

    if ('production' !== process.env.NODE_ENV) {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      'production' !== process.env.NODE_ENV ? warning(inst.render != null, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render` in your ' + 'component or you may have accidentally tried to render an element ' + 'whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if ('production' !== process.env.NODE_ENV) {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      'production' !== process.env.NODE_ENV ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
      'production' !== process.env.NODE_ENV ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
      'production' !== process.env.NODE_ENV ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
      'production' !== process.env.NODE_ENV ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
      'production' !== process.env.NODE_ENV ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var renderedElement;

    var previouslyMounting = ReactLifeCycle.currentlyMountingInstance;
    ReactLifeCycle.currentlyMountingInstance = this;
    try {
      if (inst.componentWillMount) {
        inst.componentWillMount();
        // When mounting, calls to `setState` by `componentWillMount` will set
        // `this._pendingStateQueue` without triggering a re-render.
        if (this._pendingStateQueue) {
          inst.state = this._processPendingState(inst.props, inst.context);
        }
      }

      renderedElement = this._renderValidatedComponent();
    } finally {
      ReactLifeCycle.currentlyMountingInstance = previouslyMounting;
    }

    this._renderedComponent = this._instantiateReactComponent(renderedElement, this._currentElement.type // The wrapping type
    );

    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
    if (inst.componentDidMount) {
      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    }

    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function () {
    var inst = this._instance;

    if (inst.componentWillUnmount) {
      var previouslyUnmounting = ReactLifeCycle.currentlyUnmountingInstance;
      ReactLifeCycle.currentlyUnmountingInstance = this;
      try {
        inst.componentWillUnmount();
      } finally {
        ReactLifeCycle.currentlyUnmountingInstance = previouslyUnmounting;
      }
    }

    ReactReconciler.unmountComponent(this._renderedComponent);
    this._renderedComponent = null;

    // Reset pending fields
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Schedule a partial update to the props. Only used for internal testing.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @internal
   */
  _setPropsInternal: function (partialProps, callback) {
    // This is a deoptimized path. We optimize for always having an element.
    // This creates an extra internal element.
    var element = this._pendingElement || this._currentElement;
    this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));
    ReactUpdates.enqueueUpdate(this, callback);
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var maskedContext = null;
    var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if ('production' !== process.env.NODE_ENV) {
      var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
      if (Component.contextTypes) {
        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var inst = this._instance;
    var childContext = inst.getChildContext && inst.getChildContext();
    if (childContext) {
      !(typeof inst.constructor.childContextTypes === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
      if ('production' !== process.env.NODE_ENV) {
        this._checkPropTypes(inst.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);
      }
      for (var name in childContext) {
        !(name in inst.constructor.childContextTypes) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
      }
      return assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function (newProps) {
    if ('production' !== process.env.NODE_ENV) {
      var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
      if (Component.propTypes) {
        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
      }
    }
    return newProps;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function (propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the element
    // validation.
    var componentName = this.getName();
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error;
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof propTypes[propName] === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
          error = propTypes[propName](props, propName, componentName, location);
        } catch (ex) {
          error = ex;
        }
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // React.render calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);

          if (location === ReactPropTypeLocations.prop) {
            // Preface gives us something to blacklist in warning module
            'production' !== process.env.NODE_ENV ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
          } else {
            'production' !== process.env.NODE_ENV ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
          }
        }
      }
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
    }

    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      if ('production' !== process.env.NODE_ENV) {
        ReactElementValidator.checkAndWarnForMutatedProps(this._currentElement);
      }

      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;

    var nextContext = inst.context;
    var nextProps = inst.props;

    // Distinguish between a props update versus a simple state update
    if (prevParentElement !== nextParentElement) {
      nextContext = this._processContext(nextUnmaskedContext);
      nextProps = this._processProps(nextParentElement.props);

      // An update here will schedule an update but immediately set
      // _pendingStateQueue which will ensure that any state updates gets
      // immediately reconciled instead of waiting for the next batch.

      if (inst.componentWillReceiveProps) {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);

    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
    }

    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var inst = this._instance;

    var prevProps = inst.props;
    var prevState = inst.state;
    var prevContext = inst.context;

    if (inst.componentWillUpdate) {
      inst.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (inst.componentDidUpdate) {
      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();
    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      // These two IDs are actually the same! But nothing should rely on that.
      var thisID = this._rootNodeID;
      var prevComponentID = prevComponentInstance._rootNodeID;
      ReactReconciler.unmountComponent(prevComponentInstance);

      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement, this._currentElement.type);
      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
    }
  },

  /**
   * @protected
   */
  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedComponent = inst.render();
    if ('production' !== process.env.NODE_ENV) {
      // We allow auto-mocks to proceed as if they're returning null.
      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedComponent = null;
      }
    }

    return renderedComponent;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedComponent;
    var previousContext = ReactContext.current;
    ReactContext.current = this._processChildContext(this._currentElement._context);
    ReactCurrentOwner.current = this;
    try {
      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactContext.current = previousContext;
      ReactCurrentOwner.current = null;
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    (renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent))) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
    return renderedComponent;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = component.getPublicInstance();
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by React.render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    return this._instance;
  },

  // Stub
  _instantiateReactComponent: null

};

ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent',
  _renderValidatedComponent: '_renderValidatedComponent'
});

var ReactCompositeComponent = {

  Mixin: ReactCompositeComponentMixin

};

module.exports = ReactCompositeComponent;
}).call(this,require('_process'))

},{"./Object.assign":37,"./ReactComponentEnvironment":49,"./ReactContext":52,"./ReactCurrentOwner":53,"./ReactElement":73,"./ReactElementValidator":74,"./ReactInstanceMap":83,"./ReactLifeCycle":85,"./ReactNativeComponent":91,"./ReactPerf":93,"./ReactPropTypeLocationNames":95,"./ReactPropTypeLocations":96,"./ReactReconciler":99,"./ReactUpdates":110,"./emptyObject":140,"./invariant":159,"./shouldUpdateReactComponent":178,"./warning":183,"_process":2}],52:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactContext
 */

'use strict';

var emptyObject = require("./emptyObject");

/**
 * Keeps track of the current context.
 *
 * The context is automatically passed down the component ownership hierarchy
 * and is accessible via `this.context` on ReactCompositeComponents.
 */
var ReactContext = {

  /**
   * @internal
   * @type {object}
   */
  current: emptyObject

};

module.exports = ReactContext;
},{"./emptyObject":140}],53:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],54:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 * @typechecks static-only
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");

var mapObject = require("./mapObject");

/**
 * Create a factory that creates HTML tag elements.
 *
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMFactory(tag) {
  if ('production' !== process.env.NODE_ENV) {
    return ReactElementValidator.createFactory(tag);
  }
  return ReactElement.createFactory(tag);
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOM = mapObject({
  a: 'a',
  abbr: 'abbr',
  address: 'address',
  area: 'area',
  article: 'article',
  aside: 'aside',
  audio: 'audio',
  b: 'b',
  base: 'base',
  bdi: 'bdi',
  bdo: 'bdo',
  big: 'big',
  blockquote: 'blockquote',
  body: 'body',
  br: 'br',
  button: 'button',
  canvas: 'canvas',
  caption: 'caption',
  cite: 'cite',
  code: 'code',
  col: 'col',
  colgroup: 'colgroup',
  data: 'data',
  datalist: 'datalist',
  dd: 'dd',
  del: 'del',
  details: 'details',
  dfn: 'dfn',
  dialog: 'dialog',
  div: 'div',
  dl: 'dl',
  dt: 'dt',
  em: 'em',
  embed: 'embed',
  fieldset: 'fieldset',
  figcaption: 'figcaption',
  figure: 'figure',
  footer: 'footer',
  form: 'form',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  head: 'head',
  header: 'header',
  hgroup: 'hgroup',
  hr: 'hr',
  html: 'html',
  i: 'i',
  iframe: 'iframe',
  img: 'img',
  input: 'input',
  ins: 'ins',
  kbd: 'kbd',
  keygen: 'keygen',
  label: 'label',
  legend: 'legend',
  li: 'li',
  link: 'link',
  main: 'main',
  map: 'map',
  mark: 'mark',
  menu: 'menu',
  menuitem: 'menuitem',
  meta: 'meta',
  meter: 'meter',
  nav: 'nav',
  noscript: 'noscript',
  object: 'object',
  ol: 'ol',
  optgroup: 'optgroup',
  option: 'option',
  output: 'output',
  p: 'p',
  param: 'param',
  picture: 'picture',
  pre: 'pre',
  progress: 'progress',
  q: 'q',
  rp: 'rp',
  rt: 'rt',
  ruby: 'ruby',
  s: 's',
  samp: 'samp',
  script: 'script',
  section: 'section',
  select: 'select',
  small: 'small',
  source: 'source',
  span: 'span',
  strong: 'strong',
  style: 'style',
  sub: 'sub',
  summary: 'summary',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  textarea: 'textarea',
  tfoot: 'tfoot',
  th: 'th',
  thead: 'thead',
  time: 'time',
  title: 'title',
  tr: 'tr',
  track: 'track',
  u: 'u',
  ul: 'ul',
  'var': 'var',
  video: 'video',
  wbr: 'wbr',

  // SVG
  circle: 'circle',
  clipPath: 'clipPath',
  defs: 'defs',
  ellipse: 'ellipse',
  g: 'g',
  line: 'line',
  linearGradient: 'linearGradient',
  mask: 'mask',
  path: 'path',
  pattern: 'pattern',
  polygon: 'polygon',
  polyline: 'polyline',
  radialGradient: 'radialGradient',
  rect: 'rect',
  stop: 'stop',
  svg: 'svg',
  text: 'text',
  tspan: 'tspan'

}, createDOMFactory);

module.exports = ReactDOM;
}).call(this,require('_process'))

},{"./ReactElement":73,"./ReactElementValidator":74,"./mapObject":167,"_process":2}],55:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMButton
 */

'use strict';

var AutoFocusMixin = require("./AutoFocusMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var keyMirror = require("./keyMirror");

var button = ReactElement.createFactory('button');

var mouseListenerNames = keyMirror({
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,
  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
});

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = ReactClass.createClass({
  displayName: 'ReactDOMButton',
  tagName: 'BUTTON',

  mixins: [AutoFocusMixin, ReactBrowserComponentMixin],

  render: function () {
    var props = {};

    // Copy the props; except the mouse listeners if we're disabled
    for (var key in this.props) {
      if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
        props[key] = this.props[key];
      }
    }

    return button(props, this.props.children);
  }

});

module.exports = ReactDOMButton;
},{"./AutoFocusMixin":11,"./ReactBrowserComponentMixin":40,"./ReactClass":46,"./ReactElement":73,"./keyMirror":165}],56:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMClient
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactDOMTextComponent = require("./ReactDOMTextComponent");
var ReactDefaultInjection = require("./ReactDefaultInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");
var ReactReconciler = require("./ReactReconciler");

var findDOMNode = require("./findDOMNode");
var warning = require("./warning");

ReactDefaultInjection.inject();

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  constructAndRenderComponent: ReactMount.constructAndRenderComponent,
  constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
  findDOMNode: findDOMNode,
  render: render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    CurrentOwner: ReactCurrentOwner,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    Reconciler: ReactReconciler,
    TextComponent: ReactDOMTextComponent
  });
}

if ('production' !== process.env.NODE_ENV) {
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // If we're in Chrome, look for the devtools marker and provide a download
    // link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    // If we're in IE8, check to see if we are in combatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    'production' !== process.env.NODE_ENV ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

    // shams
    Object.create, Object.freeze];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
        break;
      }
    }
  }
}

module.exports = React;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":31,"./ReactCurrentOwner":53,"./ReactDOMTextComponent":67,"./ReactDefaultInjection":70,"./ReactInstanceHandles":82,"./ReactMount":88,"./ReactPerf":93,"./ReactReconciler":99,"./findDOMNode":142,"./warning":183,"_process":2}],57:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

/* global hasOwnProperty:true */

'use strict';

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMProperty = require("./DOMProperty");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
var ReactMount = require("./ReactMount");
var ReactMultiChild = require("./ReactMultiChild");
var ReactPerf = require("./ReactPerf");

var assign = require("./Object.assign");
var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
var invariant = require("./invariant");
var isEventSupported = require("./isEventSupported");
var keyOf = require("./keyOf");
var shallowEqual = require("./shallowEqual");
var validateDOMNesting = require("./validateDOMNesting");
var warning = require("./warning");

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = keyOf({ style: null });

var ELEMENT_NODE_TYPE = 1;

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  'production' !== process.env.NODE_ENV ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', JSON.stringify(style1), JSON.stringify(style2)) : undefined;
}

/**
 * Optionally injectable operations for mutating the DOM
 */
var BackendIDOperations = null;

/**
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if ('production' !== process.env.NODE_ENV) {
    if (voidElementTags[component._tag]) {
      'production' !== process.env.NODE_ENV ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.', component._tag) : undefined;
    }
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
    !(typeof props.dangerouslySetInnerHTML === 'object' && '__html' in props.dangerouslySetInnerHTML) ? 'production' !== process.env.NODE_ENV ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
  }
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
    'production' !== process.env.NODE_ENV ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
  }
  !(props.style == null || typeof props.style === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.') : invariant(false) : undefined;
}

function enqueuePutListener(id, registrationName, listener, transaction) {
  if ('production' !== process.env.NODE_ENV) {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    'production' !== process.env.NODE_ENV ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
  }
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
    listenTo(registrationName, doc);
  }
  transaction.getReactMountReady().enqueue(putListener, {
    id: id,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special cased tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
  // NOTE: menuitem's close tag should be omitted, but that causes problems.
};

var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = ({}).hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
    validatedTagCache[tag] = true;
  }
}

function processChildContext(context, inst) {
  if ('production' !== process.env.NODE_ENV) {
    // Pass down our tag name to child components for validation purposes
    context = assign({}, context);
    var info = context[validateDOMNesting.ancestorInfoContextKey];
    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
  }
  return context;
}

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag) {
  validateDangerousTag(tag);
  this._tag = tag;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._rootNodeID = null;
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  construct: function (element) {
    this._currentElement = element;
  },

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (rootID, transaction, context) {
    this._rootNodeID = rootID;

    assertValidProps(this, this._currentElement.props);
    if ('production' !== process.env.NODE_ENV) {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction);
    var tagContent = this._createContentMarkup(transaction, context);
    if (!tagContent && omittedCloseTags[this._tag]) {
      return tagOpen + '/>';
    }
    return tagOpen + '>' + tagContent + '</' + this._tag + '>';
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction) {
    var props = this._currentElement.props;
    var ret = '<' + this._tag;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if ('production' !== process.env.NODE_ENV) {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, context) {
    var ret = '';
    var props = this._currentElement.props;

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, processChildContext(context, this));
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    assertValidProps(this, this._currentElement.props);
    this._updateDOMProperties(prevElement.props, transaction);
    this._updateDOMChildren(prevElement.props, transaction, processChildContext(context, this));
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMProperties: function (lastProps, transaction) {
    var nextProps = this._currentElement.props;
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if ('production' !== process.env.NODE_ENV) {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp);
      }
    }
    if (styleUpdates) {
      BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMChildren: function (lastProps, transaction, context) {
    var nextProps = this._currentElement.props;

    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml);
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction, context);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function () {
    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    this._rootNodeID = null;
  }

};

ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent'
});

assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

ReactDOMComponent.injection = {
  injectIDOperations: function (IDOperations) {
    ReactDOMComponent.BackendIDOperations = BackendIDOperations = IDOperations;
  }
};

module.exports = ReactDOMComponent;
}).call(this,require('_process'))

},{"./CSSPropertyOperations":15,"./DOMProperty":20,"./DOMPropertyOperations":21,"./Object.assign":37,"./ReactBrowserEventEmitter":41,"./ReactComponentBrowserEnvironment":48,"./ReactMount":88,"./ReactMultiChild":89,"./ReactPerf":93,"./escapeTextContentForBrowser":141,"./invariant":159,"./isEventSupported":160,"./keyOf":166,"./shallowEqual":177,"./validateDOMNesting":182,"./warning":183,"_process":2}],58:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMForm
 */

'use strict';

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var form = ReactElement.createFactory('form');

/**
 * Since onSubmit doesn't bubble OR capture on the top level in IE8, we need
 * to capture it on the <form> element itself. There are lots of hacks we could
 * do to accomplish this, but the most reliable is to make <form> a
 * composite component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMForm = ReactClass.createClass({
  displayName: 'ReactDOMForm',
  tagName: 'FORM',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function () {
    // TODO: Instead of using `ReactDOM` directly, we should use JSX. However,
    // `jshint` fails to parse JSX so in order for linting to work in the open
    // source repo, we need to just use `ReactDOM.form`.
    return form(this.props);
  },

  componentDidMount: function () {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
  }
});

module.exports = ReactDOMForm;
},{"./EventConstants":25,"./LocalEventTrapMixin":36,"./ReactBrowserComponentMixin":40,"./ReactClass":46,"./ReactElement":73}],59:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

'use strict';

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMChildrenOperations = require("./DOMChildrenOperations");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");

/**
 * Errors for properties that should not be updated with `updatePropertyById()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes. This is made injectable via
 * `ReactDOMComponent.BackendIDOperations`.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: function (id, name, value) {
    var node = ReactMount.getNode(id);
    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

    // If we're updating to null or undefined, we should remove the property
    // from the DOM node instead of inadvertantly setting to a string. This
    // brings us in line with the same behavior we have on initial render.
    if (value != null) {
      DOMPropertyOperations.setValueForProperty(node, name, value);
    } else {
      DOMPropertyOperations.deleteValueForProperty(node, name);
    }
  },

  /**
   * Updates a DOM node to remove a property. This should only be used to remove
   * DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A property name to remove, see `DOMProperty`.
   * @internal
   */
  deletePropertyByID: function (id, name, value) {
    var node = ReactMount.getNode(id);
    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
    DOMPropertyOperations.deleteValueForProperty(node, name, value);
  },

  /**
   * Updates a DOM node with new style values. If a value is specified as '',
   * the corresponding style property will be unset.
   *
   * @param {string} id ID of the node to update.
   * @param {object} styles Mapping from styles to values.
   * @internal
   */
  updateStylesByID: function (id, styles) {
    var node = ReactMount.getNode(id);
    CSSPropertyOperations.setValueForStyles(node, styles);
  },

  /**
   * Updates a DOM node's innerHTML.
   *
   * @param {string} id ID of the node to update.
   * @param {string} html An HTML string.
   * @internal
   */
  updateInnerHTMLByID: function (id, html) {
    var node = ReactMount.getNode(id);
    setInnerHTML(node, html);
  },

  /**
   * Updates a DOM node's text content set by `props.content`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} content Text content.
   * @internal
   */
  updateTextContentByID: function (id, content) {
    var node = ReactMount.getNode(id);
    DOMChildrenOperations.updateTextContent(node, content);
  },

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
    var node = ReactMount.getNode(id);
    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
  },

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (updates, markup) {
    for (var i = 0; i < updates.length; i++) {
      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
    }
    DOMChildrenOperations.processUpdates(updates, markup);
  }
};

ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
  updatePropertyByID: 'updatePropertyByID',
  deletePropertyByID: 'deletePropertyByID',
  updateStylesByID: 'updateStylesByID',
  updateInnerHTMLByID: 'updateInnerHTMLByID',
  updateTextContentByID: 'updateTextContentByID',
  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
});

module.exports = ReactDOMIDOperations;
}).call(this,require('_process'))

},{"./CSSPropertyOperations":15,"./DOMChildrenOperations":19,"./DOMPropertyOperations":21,"./ReactMount":88,"./ReactPerf":93,"./invariant":159,"./setInnerHTML":174,"_process":2}],60:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIframe
 */

'use strict';

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var iframe = ReactElement.createFactory('iframe');

/**
 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
 * capture it on the <iframe> element itself. There are lots of hacks we could
 * do to accomplish this, but the most reliable is to make <iframe> a composite
 * component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMIframe = ReactClass.createClass({
  displayName: 'ReactDOMIframe',
  tagName: 'IFRAME',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function () {
    return iframe(this.props);
  },

  componentDidMount: function () {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
  }
});

module.exports = ReactDOMIframe;
},{"./EventConstants":25,"./LocalEventTrapMixin":36,"./ReactBrowserComponentMixin":40,"./ReactClass":46,"./ReactElement":73}],61:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMImg
 */

'use strict';

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var img = ReactElement.createFactory('img');

/**
 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
 * capture it on the <img> element itself. There are lots of hacks we could do
 * to accomplish this, but the most reliable is to make <img> a composite
 * component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMImg = ReactClass.createClass({
  displayName: 'ReactDOMImg',
  tagName: 'IMG',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function () {
    return img(this.props);
  },

  componentDidMount: function () {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
  }
});

module.exports = ReactDOMImg;
},{"./EventConstants":25,"./LocalEventTrapMixin":36,"./ReactBrowserComponentMixin":40,"./ReactClass":46,"./ReactElement":73}],62:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInput
 */

'use strict';

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var findDOMNode = require("./findDOMNode");
var invariant = require("./invariant");

var input = ReactElement.createFactory('input');

var instancesByReactID = {};

function forceUpdateIfMounted() {
  /*jshint validthis:true */
  if (this.isMounted()) {
    this.forceUpdate();
  }
}

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = ReactClass.createClass({
  displayName: 'ReactDOMInput',
  tagName: 'INPUT',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function () {
    var defaultValue = this.props.defaultValue;
    return {
      initialChecked: this.props.defaultChecked || false,
      initialValue: defaultValue != null ? defaultValue : null
    };
  },

  render: function () {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    props.defaultChecked = null;
    props.defaultValue = null;

    var value = LinkedValueUtils.getValue(this.props);
    props.value = value != null ? value : this.state.initialValue;

    var checked = LinkedValueUtils.getChecked(this.props);
    props.checked = checked != null ? checked : this.state.initialChecked;

    props.onChange = this._handleChange;

    return input(props, this.props.children);
  },

  componentDidMount: function () {
    var id = ReactMount.getID(findDOMNode(this));
    instancesByReactID[id] = this;
  },

  componentWillUnmount: function () {
    var rootNode = findDOMNode(this);
    var id = ReactMount.getID(rootNode);
    delete instancesByReactID[id];
  },

  componentDidUpdate: function (prevProps, prevState, prevContext) {
    var rootNode = findDOMNode(this);
    if (this.props.checked != null) {
      DOMPropertyOperations.setValueForProperty(rootNode, 'checked', this.props.checked || false);
    }

    var value = LinkedValueUtils.getValue(this.props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function (event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this.props);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }
    // Here we use asap to wait until all updates have propagated, which
    // is important when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    ReactUpdates.asap(forceUpdateIfMounted, this);

    var name = this.props.name;
    if (this.props.type === 'radio' && name != null) {
      var rootNode = findDOMNode(this);
      var queryRoot = rootNode;

      while (queryRoot.parentNode) {
        queryRoot = queryRoot.parentNode;
      }

      // If `rootNode.form` was non-null, then we could try `form.elements`,
      // but that sometimes behaves strangely in IE8. We could also try using
      // `form.getElementsByName`, but that will only return direct children
      // and won't include inputs that use the HTML5 `form=` attribute. Since
      // the input might not even be in a form, let's just use the global
      // `querySelectorAll` to ensure we don't miss anything.
      var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

      for (var i = 0; i < group.length; i++) {
        var otherNode = group[i];
        if (otherNode === rootNode || otherNode.form !== rootNode.form) {
          continue;
        }
        var otherID = ReactMount.getID(otherNode);
        !otherID ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
        var otherInstance = instancesByReactID[otherID];
        !otherInstance ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
        // If this is a controlled radio button group, forcing the input that
        // was previously checked to update will cause it to be come re-checked
        // as appropriate.
        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
      }
    }

    return returnValue;
  }

});

module.exports = ReactDOMInput;
}).call(this,require('_process'))

},{"./AutoFocusMixin":11,"./DOMPropertyOperations":21,"./LinkedValueUtils":35,"./Object.assign":37,"./ReactBrowserComponentMixin":40,"./ReactClass":46,"./ReactElement":73,"./ReactMount":88,"./ReactUpdates":110,"./findDOMNode":142,"./invariant":159,"_process":2}],63:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMOption
 */

'use strict';

var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactChildren = require("./ReactChildren");
var ReactClass = require("./ReactClass");
var ReactDOMSelect = require("./ReactDOMSelect");
var ReactElement = require("./ReactElement");
var ReactPropTypes = require("./ReactPropTypes");

var assign = require("./Object.assign");
var warning = require("./warning");

var option = ReactElement.createFactory('option');

var valueContextKey = ReactDOMSelect.valueContextKey;

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = ReactClass.createClass({
  displayName: 'ReactDOMOption',
  tagName: 'OPTION',

  mixins: [ReactBrowserComponentMixin],

  getInitialState: function () {
    return { selected: null };
  },

  contextTypes: (function () {
    var obj = {};
    obj[valueContextKey] = ReactPropTypes.any;
    return obj;
  })(),

  componentWillMount: function () {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(this.props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
    }

    // Look up whether this option is 'selected' via parent-based context
    var context = this.context;
    var selectValue = context[valueContextKey];

    // If context key is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>) skip props
    if (selectValue != null) {
      var selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === '' + this.props.value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === '' + this.props.value;
      }
      this.setState({ selected: selected });
    }
  },

  render: function () {
    var props = this.props;

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (this.state.selected != null) {
      props = assign({}, props, { selected: this.state.selected });
    }

    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    ReactChildren.forEach(this.props.children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else {
        'production' !== process.env.NODE_ENV ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
      }
    });

    return option(props, content);
  }

});

module.exports = ReactDOMOption;
}).call(this,require('_process'))

},{"./Object.assign":37,"./ReactBrowserComponentMixin":40,"./ReactChildren":45,"./ReactClass":46,"./ReactDOMSelect":64,"./ReactElement":73,"./ReactPropTypes":97,"./warning":183,"_process":2}],64:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelect
 */

'use strict';

var AutoFocusMixin = require("./AutoFocusMixin");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");
var ReactUpdates = require("./ReactUpdates");
var ReactPropTypes = require("./ReactPropTypes");

var assign = require("./Object.assign");
var findDOMNode = require("./findDOMNode");

var select = ReactElement.createFactory('select');

var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

function updateOptionsIfPendingUpdateAndMounted() {
  /*jshint validthis:true */
  if (this._pendingUpdate) {
    this._pendingUpdate = false;
    var value = LinkedValueUtils.getValue(this.props);
    if (value != null && this.isMounted()) {
      updateOptions(this, value);
    }
  }
}

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function selectValueType(props, propName, componentName) {
  if (props[propName] == null) {
    return null;
  }
  if (props.multiple) {
    if (!Array.isArray(props[propName])) {
      return new Error('The `' + propName + '` prop supplied to <select> must be an array if ' + '`multiple` is true.');
    }
  } else {
    if (Array.isArray(props[propName])) {
      return new Error('The `' + propName + '` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.');
    }
  }
}

/**
 * @param {ReactComponent} component Instance of ReactDOMSelect
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(component, propValue) {
  var selectedValue, i;
  var options = findDOMNode(component).options;

  if (component.props.multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = ReactClass.createClass({
  displayName: 'ReactDOMSelect',
  tagName: 'SELECT',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  statics: {
    valueContextKey: valueContextKey
  },

  propTypes: {
    defaultValue: selectValueType,
    value: selectValueType
  },

  getInitialState: function () {
    // Pass down initial value so initial generated markup has correct
    // `selected` attributes
    var value = LinkedValueUtils.getValue(this.props);
    if (value != null) {
      return { initialValue: value };
    } else {
      return { initialValue: this.props.defaultValue };
    }
  },

  childContextTypes: (function () {
    var obj = {};
    obj[valueContextKey] = ReactPropTypes.any;
    return obj;
  })(),

  getChildContext: function () {
    var obj = {};
    obj[valueContextKey] = this.state.initialValue;
    return obj;
  },

  render: function () {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    props.onChange = this._handleChange;
    props.value = null;

    return select(props, this.props.children);
  },

  componentWillMount: function () {
    this._pendingUpdate = false;
  },

  componentWillReceiveProps: function (nextProps) {
    // After the initial mount, we control selected-ness manually so don't pass
    // the context value down
    this.setState({ initialValue: null });
  },

  componentDidUpdate: function (prevProps) {
    var value = LinkedValueUtils.getValue(this.props);
    if (value != null) {
      this._pendingUpdate = false;
      updateOptions(this, value);
    } else if (!prevProps.multiple !== !this.props.multiple) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (this.props.defaultValue != null) {
        updateOptions(this, this.props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(this, this.props.multiple ? [] : '');
      }
    }
  },

  _handleChange: function (event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this.props);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }

    this._pendingUpdate = true;
    ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
    return returnValue;
  }

});

module.exports = ReactDOMSelect;
},{"./AutoFocusMixin":11,"./LinkedValueUtils":35,"./Object.assign":37,"./ReactBrowserComponentMixin":40,"./ReactClass":46,"./ReactElement":73,"./ReactPropTypes":97,"./ReactUpdates":110,"./findDOMNode":142}],65:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelection
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var getNodeForCharacterOffset = require("./getNodeForCharacterOffset");
var getTextContentAccessor = require("./getTextContentAccessor");

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./ExecutionEnvironment":31,"./getNodeForCharacterOffset":153,"./getTextContentAccessor":154}],66:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMServer
 */

'use strict';

var ReactDefaultInjection = require("./ReactDefaultInjection");
var ReactServerRendering = require("./ReactServerRendering");

ReactDefaultInjection.inject();

var ReactDOMServer = {
  renderToString: ReactServerRendering.renderToString,
  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup
};

module.exports = ReactDOMServer;
},{"./ReactDefaultInjection":70,"./ReactServerRendering":102}],67:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextComponent
 * @typechecks static-only
 */

'use strict';

var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
var ReactDOMComponent = require("./ReactDOMComponent");

var assign = require("./Object.assign");
var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
var validateDOMNesting = require("./validateDOMNesting");

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (props) {};

assign(ReactDOMTextComponent.prototype, {

  /**
   * @param {ReactText} text
   * @internal
   */
  construct: function (text) {
    // TODO: This is really a ReactText (ReactNode), not a ReactElement
    this._currentElement = text;
    this._stringText = '' + text;

    // Properties
    this._rootNodeID = null;
    this._mountIndex = 0;
  },

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    if ('production' !== process.env.NODE_ENV) {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    this._rootNodeID = rootID;
    var escapedText = escapeTextContentForBrowser(this._stringText);

    if (transaction.renderToStaticMarkup) {
      // Normally we'd wrap this in a `span` for the reasons stated above, but
      // since this is a situation where React won't take over (static pages),
      // we can simply return the text as it is.
      return escapedText;
    }

    return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        ReactDOMComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextStringText);
      }
    }
  },

  unmountComponent: function () {
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
  }

});

module.exports = ReactDOMTextComponent;

// This constructor and its argument is currently used by mocks.
}).call(this,require('_process'))

},{"./DOMPropertyOperations":21,"./Object.assign":37,"./ReactComponentBrowserEnvironment":48,"./ReactDOMComponent":57,"./escapeTextContentForBrowser":141,"./validateDOMNesting":182,"_process":2}],68:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextarea
 */

'use strict';

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var findDOMNode = require("./findDOMNode");
var invariant = require("./invariant");

var warning = require("./warning");

var textarea = ReactElement.createFactory('textarea');

function forceUpdateIfMounted() {
  /*jshint validthis:true */
  if (this.isMounted()) {
    this.forceUpdate();
  }
}

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = ReactClass.createClass({
  displayName: 'ReactDOMTextarea',
  tagName: 'TEXTAREA',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function () {
    var defaultValue = this.props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = this.props.children;
    if (children != null) {
      if ('production' !== process.env.NODE_ENV) {
        'production' !== process.env.NODE_ENV ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
      }
      !(defaultValue == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? 'production' !== process.env.NODE_ENV ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(this.props);
    return {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue)
    };
  },

  render: function () {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    !(props.dangerouslySetInnerHTML == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

    props.defaultValue = null;
    props.value = null;
    props.onChange = this._handleChange;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    return textarea(props, this.state.initialValue);
  },

  componentDidUpdate: function (prevProps, prevState, prevContext) {
    var value = LinkedValueUtils.getValue(this.props);
    if (value != null) {
      var rootNode = findDOMNode(this);
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function (event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this.props);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }
    ReactUpdates.asap(forceUpdateIfMounted, this);
    return returnValue;
  }

});

module.exports = ReactDOMTextarea;
}).call(this,require('_process'))

},{"./AutoFocusMixin":11,"./DOMPropertyOperations":21,"./LinkedValueUtils":35,"./Object.assign":37,"./ReactBrowserComponentMixin":40,"./ReactClass":46,"./ReactElement":73,"./ReactUpdates":110,"./findDOMNode":142,"./invariant":159,"./warning":183,"_process":2}],69:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

'use strict';

var ReactUpdates = require("./ReactUpdates");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./Object.assign":37,"./ReactUpdates":110,"./Transaction":127,"./emptyFunction":139}],70:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultInjection
 */

'use strict';

var BeforeInputEventPlugin = require("./BeforeInputEventPlugin");
var ChangeEventPlugin = require("./ChangeEventPlugin");
var ClientReactRootIndex = require("./ClientReactRootIndex");
var DefaultEventPluginOrder = require("./DefaultEventPluginOrder");
var EnterLeaveEventPlugin = require("./EnterLeaveEventPlugin");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var HTMLDOMPropertyConfig = require("./HTMLDOMPropertyConfig");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
var ReactDefaultBatchingStrategy = require("./ReactDefaultBatchingStrategy");
var ReactDOMComponent = require("./ReactDOMComponent");
var ReactDOMButton = require("./ReactDOMButton");
var ReactDOMForm = require("./ReactDOMForm");
var ReactDOMImg = require("./ReactDOMImg");
var ReactDOMIDOperations = require("./ReactDOMIDOperations");
var ReactDOMIframe = require("./ReactDOMIframe");
var ReactDOMInput = require("./ReactDOMInput");
var ReactDOMOption = require("./ReactDOMOption");
var ReactDOMSelect = require("./ReactDOMSelect");
var ReactDOMTextarea = require("./ReactDOMTextarea");
var ReactDOMTextComponent = require("./ReactDOMTextComponent");
var ReactElement = require("./ReactElement");
var ReactEventListener = require("./ReactEventListener");
var ReactInjection = require("./ReactInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactMount = require("./ReactMount");
var ReactReconcileTransaction = require("./ReactReconcileTransaction");
var SelectEventPlugin = require("./SelectEventPlugin");
var ServerReactRootIndex = require("./ServerReactRootIndex");
var SimpleEventPlugin = require("./SimpleEventPlugin");
var SVGDOMPropertyConfig = require("./SVGDOMPropertyConfig");

var createFullPageComponent = require("./createFullPageComponent");

function autoGenerateWrapperClass(type) {
  return ReactClass.createClass({
    tagName: type.toUpperCase(),
    render: function () {
      // Copy owner down for debugging info
      var internalInstance = ReactInstanceMap.get(this);
      return new ReactElement(type, null, // key
      null, // ref
      internalInstance._currentElement._owner, // owner
      null, // context
      this.props);
    }
  });
}

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.NativeComponent.injectAutoWrapper(autoGenerateWrapperClass);

  // This needs to happen before createFullPageComponent() otherwise the mixin
  // won't be included.
  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.NativeComponent.injectComponentClasses({
    'button': ReactDOMButton,
    'form': ReactDOMForm,
    'iframe': ReactDOMIframe,
    'img': ReactDOMImg,
    'input': ReactDOMInput,
    'option': ReactDOMOption,
    'select': ReactDOMSelect,
    'textarea': ReactDOMTextarea,

    'html': createFullPageComponent('html'),
    'head': createFullPageComponent('head'),
    'body': createFullPageComponent('body')
  });

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
  ReactInjection.DOMComponent.injectIDOperations(ReactDOMIDOperations);

  if ('production' !== process.env.NODE_ENV) {
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
      var ReactDefaultPerf = require("./ReactDefaultPerf");
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};
}).call(this,require('_process'))

},{"./BeforeInputEventPlugin":12,"./ChangeEventPlugin":17,"./ClientReactRootIndex":18,"./DefaultEventPluginOrder":23,"./EnterLeaveEventPlugin":24,"./ExecutionEnvironment":31,"./HTMLDOMPropertyConfig":33,"./ReactBrowserComponentMixin":40,"./ReactClass":46,"./ReactComponentBrowserEnvironment":48,"./ReactDOMButton":55,"./ReactDOMComponent":57,"./ReactDOMForm":58,"./ReactDOMIDOperations":59,"./ReactDOMIframe":60,"./ReactDOMImg":61,"./ReactDOMInput":62,"./ReactDOMOption":63,"./ReactDOMSelect":64,"./ReactDOMTextComponent":67,"./ReactDOMTextarea":68,"./ReactDefaultBatchingStrategy":69,"./ReactDefaultPerf":71,"./ReactElement":73,"./ReactEventListener":78,"./ReactInjection":80,"./ReactInstanceHandles":82,"./ReactInstanceMap":83,"./ReactMount":88,"./ReactReconcileTransaction":98,"./SVGDOMPropertyConfig":112,"./SelectEventPlugin":113,"./ServerReactRootIndex":114,"./SimpleEventPlugin":115,"./createFullPageComponent":136,"_process":2}],71:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require("./DOMProperty");
var ReactDefaultPerfAnalysis = require("./ReactDefaultPerfAnalysis");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var performanceNow = require("./performanceNow");

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function () {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function () {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function () {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  getMeasurementsSummaryMap: function (measurements) {
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
    return summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    });
  },

  printWasted: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  printDOM: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function (item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result['type'] = item.type;
      result['args'] = JSON.stringify(item.args);
      return result;
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  _recordWrite: function (id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function (moduleName, fnName, func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
        return rv;
      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactDOMIDOperations') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === '_mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function (update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
          });
        } else {
          // basic format
          ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
      fnName === '_renderValidatedComponent')) {

        if (typeof this._currentElement.type === 'string') {
          return func.apply(this, args);
        }

        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.getName(),
          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;
},{"./DOMProperty":20,"./ReactDefaultPerfAnalysis":72,"./ReactMount":88,"./ReactPerf":93,"./performanceNow":171}],72:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

'use strict';

var assign = require("./Object.assign");

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  '_mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  TEXT_CONTENT: 'set textContent',
  'updatePropertyByID': 'update attribute',
  'deletePropertyByID': 'delete attribute',
  'updateStylesByID': 'update styles',
  'updateInnerHTMLByID': 'set innerHTML',
  'dangerouslyReplaceNodeWithMarkupByID': 'replace'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var id;

    for (id in measurement.writes) {
      measurement.writes[id].forEach(function (write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    }
  }
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function (a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function (a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggered
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;
},{"./Object.assign":37}],73:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

'use strict';

var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");

var assign = require("./Object.assign");
var warning = require("./warning");

var RESERVED_PROPS = {
  key: true,
  ref: true
};

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} object
 * @param {string} key
 */
function defineWarningProperty(object, key) {
  Object.defineProperty(object, key, {

    configurable: false,
    enumerable: true,

    get: function () {
      if (!this._store) {
        return null;
      }
      return this._store[key];
    },

    set: function (value) {
      'production' !== process.env.NODE_ENV ? warning(false, 'Don\'t set the %s property of the React element. Instead, ' + 'specify the correct value when initially creating the element.', key) : undefined;
      this._store[key] = value;
    }

  });
}

/**
 * This is updated to true if the membrane is successfully created.
 */
var useMutationMembrane = false;

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} element
 */
function defineMutationMembrane(prototype) {
  try {
    var pseudoFrozenProperties = {
      props: true
    };
    for (var key in pseudoFrozenProperties) {
      defineWarningProperty(prototype, key);
    }
    useMutationMembrane = true;
  } catch (x) {}
}

/**
 * Base constructor for all React elements. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @param {string|object} ref
 * @param {*} key
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, owner, context, props) {
  // Built-in properties that belong on the element
  this.type = type;
  this.key = key;
  this.ref = ref;

  // Record the component responsible for creating this element.
  this._owner = owner;

  if ('production' !== process.env.NODE_ENV) {
    // The validation flag and props are currently mutative. We put them on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    this._store = { props: props, originalProps: assign({}, props) };

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    try {
      Object.defineProperty(this._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true
      });
    } catch (x) {}
    this._store.validated = false;

    // We're not allowed to set props directly on the object so we early
    // return and rely on the prototype membrane to forward to the backing
    // store.
    if (useMutationMembrane) {
      Object.freeze(this);
      return;
    }
  }

  this.props = props;
};

// We intentionally don't expose the function on the constructor property.
// ReactElement should be indistinguishable from a plain object.
ReactElement.prototype = {
  _isReactElement: true
};

if ('production' !== process.env.NODE_ENV) {
  defineMutationMembrane(ReactElement.prototype);
}

ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;

  if (config != null) {
    ref = config.ref === undefined ? null : config.ref;
    key = config.key === undefined ? null : '' + config.key;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (typeof props[propName] === 'undefined') {
        props[propName] = defaultProps[propName];
      }
    }
  }

  return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props);
};

ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
  var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);

  if ('production' !== process.env.NODE_ENV) {
    // If the key on the original is valid, then the clone is valid
    newElement._store.validated = oldElement._store.validated;
  }
  return newElement;
};

ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (config.ref !== undefined) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (config.key !== undefined) {
      key = '' + config.key;
    }
    // Remaining properties override existing props
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return new ReactElement(element.type, key, ref, owner, element._context, props);
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  // ReactTestUtils is often used outside of beforeEach where as React is
  // within it. This leads to two different instances of React on the same
  // page. To identify a element from a different React instance we use
  // a flag instead of an instanceof check.
  var isElement = !!(object && object._isReactElement);
  // if (isElement && !(object instanceof ReactElement)) {
  // This is an indicator that you're using multiple versions of React at the
  // same time. This will screw with ownership and stuff. Fix it, please.
  // TODO: We could possibly warn here.
  // }
  return isElement;
};

module.exports = ReactElement;

// IE will fail on defineProperty
}).call(this,require('_process'))

},{"./Object.assign":37,"./ReactContext":52,"./ReactCurrentOwner":53,"./warning":183,"_process":2}],74:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactFragment = require("./ReactFragment");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactNativeComponent = require("./ReactNativeComponent");

var getIteratorFn = require("./getIteratorFn");
var invariant = require("./invariant");
var warning = require("./warning");

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

var loggedTypeFailures = {};

var NUMERIC_PROPERTY_REGEX = /^\d+$/;

/**
 * Gets the instance's name for use in warnings.
 *
 * @internal
 * @return {?string} Display name or undefined
 */
function getName(instance) {
  var publicInstance = instance && instance.getPublicInstance();
  if (!publicInstance) {
    return undefined;
  }
  var constructor = publicInstance.constructor;
  if (!constructor) {
    return undefined;
  }
  return constructor.displayName || constructor.name || undefined;
}

/**
 * Gets the current owner's displayName for use in warnings.
 *
 * @internal
 * @return {?string} Display name or undefined
 */
function getCurrentOwnerDisplayName() {
  var current = ReactCurrentOwner.current;
  return current && getName(current) || undefined;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  warnAndMonitorForKeyUse('Each child in an array or iterator should have a unique "key" prop.', element, parentType);
}

/**
 * Warn if the key is being defined as an object property but has an incorrect
 * value.
 *
 * @internal
 * @param {string} name Property name of the key.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validatePropertyKey(name, element, parentType) {
  if (!NUMERIC_PROPERTY_REGEX.test(name)) {
    return;
  }
  warnAndMonitorForKeyUse('Child objects should have non-numeric keys so ordering is preserved.', element, parentType);
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} message The base warning that gets output.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 */
function warnAndMonitorForKeyUse(message, element, parentType) {
  var ownerName = getCurrentOwnerDisplayName();
  var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

  var useName = ownerName || parentName;
  var memoizer = ownerHasKeyUseWarning[message] || (ownerHasKeyUseWarning[message] = {});
  if (memoizer.hasOwnProperty(useName)) {
    return;
  }
  memoizer[useName] = true;

  var parentOrOwnerAddendum = ownerName ? ' Check the render method of ' + ownerName + '.' : parentName ? ' Check the React.render call using <' + parentName + '>.' : '';

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwnerAddendum = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Name of the component that originally created this child.
    var childOwnerName = getName(element._owner);

    childOwnerAddendum = ' It was passed a child from ' + childOwnerName + '.';
  }

  'production' !== process.env.NODE_ENV ? warning(false, message + '%s%s See https://fb.me/react-warning-keys for more information.', parentOrOwnerAddendum, childOwnerAddendum) : undefined;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    node._store.validated = true;
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    } else if (typeof node === 'object') {
      var fragment = ReactFragment.extractIfFragment(node);
      for (var key in fragment) {
        if (fragment.hasOwnProperty(key)) {
          validatePropertyKey(key, fragment[key], parentType);
        }
      }
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof propTypes[propName] === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      'production' !== process.env.NODE_ENV ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum();
        'production' !== process.env.NODE_ENV ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
      }
    }
  }
}

var warnedPropsMutations = {};

/**
 * Warn about mutating props when setting `propName` on `element`.
 *
 * @param {string} propName The string key within props that was set
 * @param {ReactElement} element
 */
function warnForPropsMutation(propName, element) {
  var type = element.type;
  var elementName = typeof type === 'string' ? type : type.displayName;
  var ownerName = element._owner ? element._owner.getPublicInstance().constructor.displayName : null;

  var warningKey = propName + '|' + elementName + '|' + ownerName;
  if (warnedPropsMutations.hasOwnProperty(warningKey)) {
    return;
  }
  warnedPropsMutations[warningKey] = true;

  var elementInfo = '';
  if (elementName) {
    elementInfo = ' <' + elementName + ' />';
  }
  var ownerInfo = '';
  if (ownerName) {
    ownerInfo = ' The element was created by ' + ownerName + '.';
  }

  'production' !== process.env.NODE_ENV ? warning(false, 'Don\'t set .props.%s of the React component%s. Instead, specify the ' + 'correct value when initially creating the element or use ' + 'React.cloneElement to make a new element with updated props.%s', propName, elementInfo, ownerInfo) : undefined;
}

// Inline Object.is polyfill
function is(a, b) {
  if (a !== a) {
    // NaN
    return b !== b;
  }
  if (a === 0 && b === 0) {
    // +-0
    return 1 / a === 1 / b;
  }
  return a === b;
}

/**
 * Given an element, check if its props have been mutated since element
 * creation (or the last call to this function). In particular, check if any
 * new props have been added, which we can't directly catch by defining warning
 * properties on the props object.
 *
 * @param {ReactElement} element
 */
function checkAndWarnForMutatedProps(element) {
  if (!element._store) {
    // Element was created using `new ReactElement` directly or with
    // `ReactElement.createElement`; skip mutation checking
    return;
  }

  var originalProps = element._store.originalProps;
  var props = element.props;

  for (var propName in props) {
    if (props.hasOwnProperty(propName)) {
      if (!originalProps.hasOwnProperty(propName) || !is(originalProps[propName], props[propName])) {
        warnForPropsMutation(propName, element);

        // Copy over the new value so that the two props objects match again
        originalProps[propName] = props[propName];
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  if (!(typeof element.type === 'string' || typeof element.type === 'function')) {
    // This has already warned. Don't throw.
    return;
  }
  // Extract the component class from the element. Converts string types
  // to a composite class which may have propTypes.
  // TODO: Validating a string's propTypes is not decoupled from the
  // rendering target which is problematic.
  var componentClass = ReactNativeComponent.getComponentClassForElement(element);
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    'production' !== process.env.NODE_ENV ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
  }
}

var ReactElementValidator = {

  checkAndWarnForMutatedProps: checkAndWarnForMutatedProps,

  createElement: function (type, props, children) {
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    'production' !== process.env.NODE_ENV ? warning(typeof type === 'string' || typeof type === 'function', 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if ('production' !== process.env.NODE_ENV) {
      try {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            'production' !== process.env.NODE_ENV ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      } catch (x) {}
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;

// IE will fail on defineProperty (es5-shim/sham too)
}).call(this,require('_process'))

},{"./ReactCurrentOwner":53,"./ReactElement":73,"./ReactFragment":79,"./ReactNativeComponent":91,"./ReactPropTypeLocationNames":95,"./ReactPropTypeLocations":96,"./getIteratorFn":151,"./invariant":159,"./warning":183,"_process":2}],75:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponent
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactInstanceMap = require("./ReactInstanceMap");

var invariant = require("./invariant");

var component;
// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)
var nullComponentIDsRegistry = {};

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function (emptyComponent) {
    component = ReactElement.createFactory(emptyComponent);
  }
};

var ReactEmptyComponentType = function () {};
ReactEmptyComponentType.prototype.componentDidMount = function () {
  var internalInstance = ReactInstanceMap.get(this);
  // TODO: Make sure we run these methods in the correct order, we shouldn't
  // need this check. We're going to assume if we're here it means we ran
  // componentWillUnmount already so there is no internal instance (it gets
  // removed as part of the unmounting process).
  if (!internalInstance) {
    return;
  }
  registerNullComponentID(internalInstance._rootNodeID);
};
ReactEmptyComponentType.prototype.componentWillUnmount = function () {
  var internalInstance = ReactInstanceMap.get(this);
  // TODO: Get rid of this check. See TODO in componentDidMount.
  if (!internalInstance) {
    return;
  }
  deregisterNullComponentID(internalInstance._rootNodeID);
};
ReactEmptyComponentType.prototype.render = function () {
  !component ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Trying to return null from a render, but no null placeholder component ' + 'was injected.') : invariant(false) : undefined;
  return component();
};

var emptyElement = ReactElement.createElement(ReactEmptyComponentType);

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIDsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIDsRegistry[id];
}

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return !!nullComponentIDsRegistry[id];
}

var ReactEmptyComponent = {
  emptyElement: emptyElement,
  injection: ReactEmptyComponentInjection,
  isNullComponentID: isNullComponentID
};

module.exports = ReactEmptyComponent;
}).call(this,require('_process'))

},{"./ReactElement":73,"./ReactInstanceMap":83,"./invariant":159,"_process":2}],76:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

"use strict";

var ReactErrorUtils = {
  /**
   * Creates a guarded version of a function. This is supposed to make debugging
   * of event handlers easier. To aid debugging with the browser's debugger,
   * this currently simply returns the original function.
   *
   * @param {function} func Function to be executed
   * @param {string} name The name of the guard
   * @return {function}
   */
  guard: function (func, name) {
    return func;
  }
};

module.exports = ReactErrorUtils;
},{}],77:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventEmitterMixin
 */

'use strict';

var EventPluginHub = require("./EventPluginHub");

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue();
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);

    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":27}],78:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

'use strict';

var EventListener = require("./EventListener");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var PooledClass = require("./PooledClass");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var getEventTarget = require("./getEventTarget");
var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent);
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./EventListener":26,"./ExecutionEnvironment":31,"./Object.assign":37,"./PooledClass":38,"./ReactInstanceHandles":82,"./ReactMount":88,"./ReactUpdates":110,"./getEventTarget":150,"./getUnboundedScrollPosition":155}],79:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule ReactFragment
*/

'use strict';

var ReactElement = require("./ReactElement");

var warning = require("./warning");

/**
 * We used to allow keyed objects to serve as a collection of ReactElements,
 * or nested sets. This allowed us a way to explicitly key a set a fragment of
 * components. This is now being replaced with an opaque data structure.
 * The upgrade path is to call React.addons.createFragment({ key: value }) to
 * create a keyed fragment. The resulting data structure is opaque, for now.
 */

if ('production' !== process.env.NODE_ENV) {
  var fragmentKey = '_reactFragment';
  var didWarnKey = '_reactDidWarn';
  var canWarnForReactFragment = false;

  try {
    // Feature test. Don't even try to issue this warning if we can't use
    // enumerable: false.

    var dummy = function () {
      return 1;
    };

    Object.defineProperty({}, fragmentKey, { enumerable: false, value: true });

    Object.defineProperty({}, 'key', { enumerable: true, get: dummy });

    canWarnForReactFragment = true;
  } catch (x) {}

  var proxyPropertyAccessWithWarning = function (obj, key) {
    Object.defineProperty(obj, key, {
      enumerable: true,
      get: function () {
        'production' !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an opaque type. Accessing any of its ' + 'properties is deprecated. Pass it to one of the React.Children ' + 'helpers.') : undefined;
        this[didWarnKey] = true;
        return this[fragmentKey][key];
      },
      set: function (value) {
        'production' !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an immutable opaque type. Mutating its ' + 'properties is deprecated.') : undefined;
        this[didWarnKey] = true;
        this[fragmentKey][key] = value;
      }
    });
  };

  var issuedWarnings = {};

  var didWarnForFragment = function (fragment) {
    // We use the keys and the type of the value as a heuristic to dedupe the
    // warning to avoid spamming too much.
    var fragmentCacheKey = '';
    for (var key in fragment) {
      fragmentCacheKey += key + ':' + typeof fragment[key] + ',';
    }
    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];
    issuedWarnings[fragmentCacheKey] = true;
    return alreadyWarnedOnce;
  };
}

var ReactFragment = {
  // Wrap a keyed object in an opaque proxy that warns you if you access any
  // of its properties.
  create: function (object) {
    if ('production' !== process.env.NODE_ENV) {
      if (typeof object !== 'object' || !object || Array.isArray(object)) {
        'production' !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment only accepts a single object.', object) : undefined;
        return object;
      }
      if (ReactElement.isValidElement(object)) {
        'production' !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : undefined;
        return object;
      }
      if (canWarnForReactFragment) {
        var proxy = {};
        Object.defineProperty(proxy, fragmentKey, {
          enumerable: false,
          value: object
        });
        Object.defineProperty(proxy, didWarnKey, {
          writable: true,
          enumerable: false,
          value: false
        });
        for (var key in object) {
          proxyPropertyAccessWithWarning(proxy, key);
        }
        Object.preventExtensions(proxy);
        return proxy;
      }
    }
    return object;
  },
  // Extract the original keyed object from the fragment opaque type. Warn if
  // a plain object is passed here.
  extract: function (fragment) {
    if ('production' !== process.env.NODE_ENV) {
      if (canWarnForReactFragment) {
        if (!fragment[fragmentKey]) {
          'production' !== process.env.NODE_ENV ? warning(didWarnForFragment(fragment), 'Any use of a keyed object should be wrapped in ' + 'React.addons.createFragment(object) before being passed as a ' + 'child.') : undefined;
          return fragment;
        }
        return fragment[fragmentKey];
      }
    }
    return fragment;
  },
  // Check if this is a fragment and if so, extract the keyed object. If it
  // is a fragment-like object, warn that it should be wrapped. Ignore if we
  // can't determine what kind of object this is.
  extractIfFragment: function (fragment) {
    if ('production' !== process.env.NODE_ENV) {
      if (canWarnForReactFragment) {
        // If it is the opaque type, return the keyed object.
        if (fragment[fragmentKey]) {
          return fragment[fragmentKey];
        }
        // Otherwise, check each property if it has an element, if it does
        // it is probably meant as a fragment, so we can warn early. Defer,
        // the warning to extract.
        for (var key in fragment) {
          if (fragment.hasOwnProperty(key) && ReactElement.isValidElement(fragment[key])) {
            // This looks like a fragment object, we should provide an
            // early warning.
            return ReactFragment.extract(fragment);
          }
        }
      }
    }
    return fragment;
  }
};

module.exports = ReactFragment;
}).call(this,require('_process'))

},{"./ReactElement":73,"./warning":183,"_process":2}],80:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInjection
 */

'use strict';

var DOMProperty = require("./DOMProperty");
var EventPluginHub = require("./EventPluginHub");
var ReactComponentEnvironment = require("./ReactComponentEnvironment");
var ReactClass = require("./ReactClass");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactNativeComponent = require("./ReactNativeComponent");
var ReactDOMComponent = require("./ReactDOMComponent");
var ReactPerf = require("./ReactPerf");
var ReactRootIndex = require("./ReactRootIndex");
var ReactUpdates = require("./ReactUpdates");

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  Class: ReactClass.injection,
  DOMComponent: ReactDOMComponent.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  NativeComponent: ReactNativeComponent.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":20,"./EventPluginHub":27,"./ReactBrowserEventEmitter":41,"./ReactClass":46,"./ReactComponentEnvironment":49,"./ReactDOMComponent":57,"./ReactEmptyComponent":75,"./ReactNativeComponent":91,"./ReactPerf":93,"./ReactRootIndex":101,"./ReactUpdates":110}],81:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInputSelection
 */

'use strict';

var ReactDOMSelection = require("./ReactDOMSelection");

var containsNode = require("./containsNode");
var focusNode = require("./focusNode");
var getActiveElement = require("./getActiveElement");

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    return elem && (elem.nodeName === 'INPUT' && elem.type === 'text' || elem.nodeName === 'TEXTAREA' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName === 'INPUT') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName === 'INPUT') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":65,"./containsNode":134,"./focusNode":144,"./getActiveElement":146}],82:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

'use strict';

var ReactRootIndex = require("./ReactRootIndex");

var invariant = require("./invariant");

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 100;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  !(isValidID(ancestorID) && isValidID(destinationID)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
  !isAncestorIDOf(ancestorID, destinationID) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  var i;
  for (i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  !isValidID(longestCommonID) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  !(start !== stop) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
  var traverseUp = isAncestorIDOf(stop, start);
  !(traverseUp || isAncestorIDOf(start, stop)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start;; id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    !(depth++ < MAX_TREE_DEPTH) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop) : invariant(false) : undefined;
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function () {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function (rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function (id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Same as `traverseTwoPhase` but skips the `targetID`.
   */
  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, true);
      traverseParentPath(targetID, '', cb, arg, true, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function (targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;
/* until break */
}).call(this,require('_process'))

},{"./ReactRootIndex":101,"./invariant":159,"_process":2}],83:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceMap
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],84:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactIsomorphic
 */

'use strict';

var ReactChildren = require("./ReactChildren");
var ReactComponent = require("./ReactComponent");
var ReactClass = require("./ReactClass");
var ReactDOM = require("./ReactDOM");
var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactPropTypes = require("./ReactPropTypes");

var assign = require("./Object.assign");
var onlyChild = require("./onlyChild");

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if ('production' !== process.env.NODE_ENV) {
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    only: onlyChild
  },

  Component: ReactComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOM,

  // Hook for JSX spread, don't use this for anything else.
  __spread: assign
};

module.exports = React;
}).call(this,require('_process'))

},{"./Object.assign":37,"./ReactChildren":45,"./ReactClass":46,"./ReactComponent":47,"./ReactDOM":54,"./ReactElement":73,"./ReactElementValidator":74,"./ReactPropTypes":97,"./onlyChild":169,"_process":2}],85:[function(require,module,exports){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactLifeCycle
 */

'use strict';

/**
 * This module manages the bookkeeping when a component is in the process
 * of being mounted or being unmounted. This is used as a way to enforce
 * invariants (or warnings) when it is not recommended to call
 * setState/forceUpdate.
 *
 * currentlyMountingInstance: During the construction phase, it is not possible
 * to trigger an update since the instance is not fully mounted yet. However, we
 * currently allow this as a convenience for mutating the initial state.
 *
 * currentlyUnmountingInstance: During the unmounting phase, the instance is
 * still mounted and can therefore schedule an update. However, this is not
 * recommended and probably an error since it's about to be unmounted.
 * Therefore we still want to trigger in an error for that case.
 */

var ReactLifeCycle = {
  currentlyMountingInstance: null,
  currentlyUnmountingInstance: null
};

module.exports = ReactLifeCycle;
},{}],86:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactLink
 * @typechecks static-only
 */

'use strict';

/**
 * ReactLink encapsulates a common pattern in which a component wants to modify
 * a prop received from its parent. ReactLink allows the parent to pass down a
 * value coupled with a callback that, when invoked, expresses an intent to
 * modify that value. For example:
 *
 * React.createClass({
 *   getInitialState: function() {
 *     return {value: ''};
 *   },
 *   render: function() {
 *     var valueLink = new ReactLink(this.state.value, this._handleValueChange);
 *     return <input valueLink={valueLink} />;
 *   },
 *   this._handleValueChange: function(newValue) {
 *     this.setState({value: newValue});
 *   }
 * });
 *
 * We have provided some sugary mixins to make the creation and
 * consumption of ReactLink easier; see LinkedValueUtils and LinkedStateMixin.
 */

var React = require("./React");

/**
 * @param {*} value current value of the link
 * @param {function} requestChange callback to request a change
 */
function ReactLink(value, requestChange) {
  this.value = value;
  this.requestChange = requestChange;
}

/**
 * Creates a PropType that enforces the ReactLink API and optionally checks the
 * type of the value being passed inside the link. Example:
 *
 * MyComponent.propTypes = {
 *   tabIndexLink: ReactLink.PropTypes.link(React.PropTypes.number)
 * }
 */
function createLinkTypeChecker(linkType) {
  var shapes = {
    value: typeof linkType === 'undefined' ? React.PropTypes.any.isRequired : linkType.isRequired,
    requestChange: React.PropTypes.func.isRequired
  };
  return React.PropTypes.shape(shapes);
}

ReactLink.PropTypes = {
  link: createLinkTypeChecker
};

module.exports = ReactLink;
},{"./React":39}],87:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMarkupChecksum
 */

'use strict';

var adler32 = require("./adler32");

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);
    return markup.replace('>', ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">');
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":130}],88:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMount
 */

'use strict';

var DOMProperty = require("./DOMProperty");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactPerf = require("./ReactPerf");
var ReactReconciler = require("./ReactReconciler");
var ReactUpdateQueue = require("./ReactUpdateQueue");
var ReactUpdates = require("./ReactUpdates");

var emptyObject = require("./emptyObject");
var containsNode = require("./containsNode");
var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var validateDOMNesting = require("./validateDOMNesting");
var warning = require("./warning");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if ('production' !== process.env.NODE_ENV) {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        !!isValid(cached, id) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * Finds the node with the supplied public React instance.
 *
 * @param {*} instance A public React instance.
 * @return {?DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNodeFromInstance(instance) {
  var id = ReactInstanceMap.get(instance)._rootNodeID;
  if (ReactEmptyComponent.isNullComponentID(id)) {
    return null;
  }
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    !(internalGetID(node) === id) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
  if ('production' !== process.env.NODE_ENV) {
    if (context === emptyObject) {
      context = {};
    }
    var tag = container.nodeName.toLowerCase();
    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
  }
  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
  componentInstance._isTopLevel = true;
  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container) {
  ReactReconciler.unmountComponent(instance);

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {
  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
    if ('production' !== process.env.NODE_ENV) {
      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
    }

    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    if ('production' !== process.env.NODE_ENV) {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function (nextComponent, container) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? 'production' !== process.env.NODE_ENV ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    'production' !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    var componentInstance = instantiateReactComponent(nextElement, null);
    var reactRootID = ReactMount._registerComponent(componentInstance, container);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

    if ('production' !== process.env.NODE_ENV) {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
    }

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !ReactElement.isValidElement(nextElement) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'React.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

    'production' !== process.env.NODE_ENV ? warning(container && container.tagName !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevElement = prevComponent._currentElement;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback).getPublicInstance();
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);

    if ('production' !== process.env.NODE_ENV) {
      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (ReactMount.isRenderedByReact(rootElementSibling)) {
            'production' !== process.env.NODE_ENV ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
            break;
          }

          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
    var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject).getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into the supplied `container`.
   *
   * @param {function} constructor React component constructor.
   * @param {?object} props Initial props of the component instance.
   * @param {DOMElement} container DOM element to render into.
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  constructAndRenderComponent: function (constructor, props, container) {
    var element = ReactElement.createElement(constructor, props);
    return ReactMount.render(element, container);
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into a container node identified by supplied `id`.
   *
   * @param {function} componentConstructor React component constructor
   * @param {?object} props Initial props of the component instance.
   * @param {string} id ID of the DOM element to render into.
   * @return {ReactComponent} Component instance rendered in the container node.
   */
  constructAndRenderComponentByID: function (constructor, props, id) {
    var domNode = document.getElementById(id);
    !domNode ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Tried to get element with id of "%s" but it is not present on the page.', id) : invariant(false) : undefined;
    return ReactMount.constructAndRenderComponent(constructor, props, domNode);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function (container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    'production' !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      return false;
    }
    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if ('production' !== process.env.NODE_ENV) {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function (id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if ('production' !== process.env.NODE_ENV) {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        'production' !== process.env.NODE_ENV ? warning(
        // Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
        var containerChild = container.firstChild;
        if (containerChild && reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          'production' !== process.env.NODE_ENV ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode) : undefined;
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function (id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * True if the supplied `node` is rendered by React.
   *
   * @param {*} node DOM Element to check.
   * @return {boolean} True if the DOM Element appears to be rendered by React.
   * @internal
   */
  isRenderedByReact: function (node) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      return false;
    }
    var id = ReactMount.getID(node);
    return id ? id.charAt(0) === SEPARATOR : false;
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function (node) {
    var current = node;
    while (current && current.parentNode !== current) {
      if (ReactMount.isRenderedByReact(current)) {
        return current;
      }
      current = current.parentNode;
    }
    return null;
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function (ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }
        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    !false ? 'production' !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
  },

  _mountImageIntoNode: function (markup, container, shouldReuseMarkup) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var diffIndex = firstDifferenceIndex(markup, rootMarkup);
        var difference = ' (client) ' + markup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

        if ('production' !== process.env.NODE_ENV) {
          'production' !== process.env.NODE_ENV ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See React.renderToString() for server rendering.') : invariant(false) : undefined;

    setInnerHTML(container, markup);
  },

  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  getNodeFromInstance: getNodeFromInstance,

  purgeID: purgeID
};

ReactPerf.measureMethods(ReactMount, 'ReactMount', {
  _renderNewRootComponent: '_renderNewRootComponent',
  _mountImageIntoNode: '_mountImageIntoNode'
});

module.exports = ReactMount;
}).call(this,require('_process'))

},{"./DOMProperty":20,"./ReactBrowserEventEmitter":41,"./ReactCurrentOwner":53,"./ReactElement":73,"./ReactElementValidator":74,"./ReactEmptyComponent":75,"./ReactInstanceHandles":82,"./ReactInstanceMap":83,"./ReactMarkupChecksum":87,"./ReactPerf":93,"./ReactReconciler":99,"./ReactUpdateQueue":109,"./ReactUpdates":110,"./containsNode":134,"./emptyObject":140,"./instantiateReactComponent":158,"./invariant":159,"./setInnerHTML":174,"./shouldUpdateReactComponent":178,"./validateDOMNesting":182,"./warning":183,"_process":2}],89:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

'use strict';

var ReactComponentEnvironment = require("./ReactComponentEnvironment");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var ReactReconciler = require("./ReactReconciler");
var ReactChildReconciler = require("./ReactChildReconciler");

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    textContent: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    textContent: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;
      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index;
          mountImages.push(mountImage);
          index++;
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        // TODO: The setTextContent operation should be enough
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildren, transaction, context) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildren, transaction, context);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildren, transaction, context) {
      var prevChildren = this._renderedChildren;
      var nextChildren = ReactChildReconciler.updateChildren(prevChildren, nextNestedChildren, transaction, context);
      this._renderedChildren = nextChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChildByName(prevChild, name);
          }
          // The child must be instantiated before it's mounted.
          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          this._unmountChildByName(prevChildren[name], name);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function () {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, mountImage) {
      enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function (textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
      child._mountIndex = index;
      this.createChild(child, mountImage);
    },

    /**
     * Unmounts a rendered child by name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @param {string} name Name of the child in `this._renderedChildren`.
     * @private
     */
    _unmountChildByName: function (child, name) {
      this.removeChild(child);
      child._mountIndex = null;
    }

  }

};

module.exports = ReactMultiChild;
},{"./ReactChildReconciler":44,"./ReactComponentEnvironment":49,"./ReactMultiChildUpdateTypes":90,"./ReactReconciler":99}],90:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

'use strict';

var keyMirror = require("./keyMirror");

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;
},{"./keyMirror":165}],91:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeComponent
 */

'use strict';

var assign = require("./Object.assign");
var invariant = require("./invariant");

var autoGenerateWrapperClass = null;
var genericComponentClass = null;
// This registry keeps track of wrapper classes around native tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactNativeComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function (componentClasses) {
    assign(tagToComponentClass, componentClasses);
  },
  // Temporary hack since we expect DOM refs to behave like composites,
  // for this release.
  injectAutoWrapper: function (wrapperFactory) {
    autoGenerateWrapperClass = wrapperFactory;
  }
};

/**
 * Get a composite component wrapper class for a specific tag.
 *
 * @param {ReactElement} element The tag for which to get the class.
 * @return {function} The React class constructor function.
 */
function getComponentClassForElement(element) {
  if (typeof element.type === 'function') {
    return element.type;
  }
  var tag = element.type;
  var componentClass = tagToComponentClass[tag];
  if (componentClass == null) {
    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
  }
  return componentClass;
}

/**
 * Get a native internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? 'production' !== process.env.NODE_ENV ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
  return new genericComponentClass(element.type, element.props);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactNativeComponent = {
  getComponentClassForElement: getComponentClassForElement,
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactNativeComponentInjection
};

module.exports = ReactNativeComponent;
}).call(this,require('_process'))

},{"./Object.assign":37,"./invariant":159,"_process":2}],92:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactOwner
 */

'use strict';

var invariant = require("./invariant");

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function (object) {
    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to add a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(false) : undefined;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to remove a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(false) : undefined;
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],93:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

'use strict';

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */
var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * @param {object} object
   * @param {string} objectName
   * @param {object<string>} methodNames
   */
  measureMethods: function (object, objectName, methodNames) {
    if ('production' !== process.env.NODE_ENV) {
      for (var key in methodNames) {
        if (!methodNames.hasOwnProperty(key)) {
          continue;
        }
        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
      }
    }
  },

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function (objName, fnName, func) {
    if ('production' !== process.env.NODE_ENV) {
      var measuredFunc = null;
      var wrapper = function () {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
      wrapper.displayName = objName + '_' + fnName;
      return wrapper;
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function (measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;
}).call(this,require('_process'))

},{"_process":2}],94:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTransferer
 */

'use strict';

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var joinClasses = require("./joinClasses");

/**
 * Creates a transfer strategy that will merge prop values using the supplied
 * `mergeStrategy`. If a prop was previously unset, this just sets it.
 *
 * @param {function} mergeStrategy
 * @return {function}
 */
function createTransferStrategy(mergeStrategy) {
  return function (props, key, value) {
    if (!props.hasOwnProperty(key)) {
      props[key] = value;
    } else {
      props[key] = mergeStrategy(props[key], value);
    }
  };
}

var transferStrategyMerge = createTransferStrategy(function (a, b) {
  // `merge` overrides the first object's (`props[key]` above) keys using the
  // second object's (`value`) keys. An object's style's existing `propA` would
  // get overridden. Flip the order here.
  return assign({}, b, a);
});

/**
 * Transfer strategies dictate how props are transferred by `transferPropsTo`.
 * NOTE: if you add any more exceptions to this list you should be sure to
 * update `cloneWithProps()` accordingly.
 */
var TransferStrategies = {
  /**
   * Never transfer `children`.
   */
  children: emptyFunction,
  /**
   * Transfer the `className` prop by merging them.
   */
  className: createTransferStrategy(joinClasses),
  /**
   * Transfer the `style` prop (which is an object) by merging them.
   */
  style: transferStrategyMerge
};

/**
 * Mutates the first argument by transferring the properties from the second
 * argument.
 *
 * @param {object} props
 * @param {object} newProps
 * @return {object}
 */
function transferInto(props, newProps) {
  for (var thisKey in newProps) {
    if (!newProps.hasOwnProperty(thisKey)) {
      continue;
    }

    var transferStrategy = TransferStrategies[thisKey];

    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
      transferStrategy(props, thisKey, newProps[thisKey]);
    } else if (!props.hasOwnProperty(thisKey)) {
      props[thisKey] = newProps[thisKey];
    }
  }
  return props;
}

/**
 * ReactPropTransferer are capable of transferring props to another component
 * using a `transferPropsTo` method.
 *
 * @class ReactPropTransferer
 */
var ReactPropTransferer = {

  /**
   * Merge two props objects using TransferStrategies.
   *
   * @param {object} oldProps original props (they take precedence)
   * @param {object} newProps new props to merge in
   * @return {object} a new object containing both sets of props merged.
   */
  mergeProps: function (oldProps, newProps) {
    return transferInto(assign({}, oldProps), newProps);
  }

};

module.exports = ReactPropTransferer;
},{"./Object.assign":37,"./emptyFunction":139,"./joinClasses":164}],95:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

'use strict';

var ReactPropTypeLocationNames = {};

if ('production' !== process.env.NODE_ENV) {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
}).call(this,require('_process'))

},{"_process":2}],96:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

'use strict';

var keyMirror = require("./keyMirror");

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;
},{"./keyMirror":165}],97:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactFragment = require("./ReactFragment");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");

var emptyFunction = require("./emptyFunction");

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, '' + propFullName + '[' + i + ']');
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!ReactElement.isValidElement(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, '' + propFullName + '.' + key);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, '' + propFullName + '.' + key);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }
      propValue = ReactFragment.extractIfFragment(propValue);
      for (var k in propValue) {
        if (!isNode(propValue[k])) {
          return false;
        }
      }
      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

module.exports = ReactPropTypes;
},{"./ReactElement":73,"./ReactFragment":79,"./ReactPropTypeLocationNames":95,"./emptyFunction":139}],98:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

'use strict';

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactInputSelection = require("./ReactInputSelection");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occured. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction() {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap proceedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":16,"./Object.assign":37,"./PooledClass":38,"./ReactBrowserEventEmitter":41,"./ReactInputSelection":81,"./Transaction":127}],99:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconciler
 */

'use strict';

var ReactRef = require("./ReactRef");
var ReactElementValidator = require("./ReactElementValidator");

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, rootID, transaction, context) {
    var markup = internalInstance.mountComponent(rootID, transaction, context);
    if ('production' !== process.env.NODE_ENV) {
      ReactElementValidator.checkAndWarnForMutatedProps(internalInstance._currentElement);
    }
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance) {
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent();
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && nextElement._owner != null) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.
      return;
    }

    if ('production' !== process.env.NODE_ENV) {
      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction) {
    internalInstance.performUpdateIfNecessary(transaction);
  }

};

module.exports = ReactReconciler;
}).call(this,require('_process'))

},{"./ReactElementValidator":74,"./ReactRef":100,"_process":2}],100:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRef
 */

'use strict';

var ReactOwner = require("./ReactOwner");

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  return nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref;
};

ReactRef.detachRefs = function (instance, element) {
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":92}],101:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

'use strict';

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function (_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;
},{}],102:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
'use strict';

var ReactElement = require("./ReactElement");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactServerRenderingTransaction = require("./ReactServerRenderingTransaction");

var emptyObject = require("./emptyObject");
var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup
 */
function renderToString(element) {
  !ReactElement.isValidElement(element) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup, without the extra React ID and checksum
 * (for generating static pages)
 */
function renderToStaticMarkup(element) {
  !ReactElement.isValidElement(element) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      return componentInstance.mountComponent(id, transaction, emptyObject);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

module.exports = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup
};
}).call(this,require('_process'))

},{"./ReactElement":73,"./ReactInstanceHandles":82,"./ReactMarkupChecksum":87,"./ReactServerRenderingTransaction":103,"./emptyObject":140,"./instantiateReactComponent":158,"./invariant":159,"_process":2}],103:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

'use strict';

var PooledClass = require("./PooledClass");
var CallbackQueue = require("./CallbackQueue");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap proceedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./CallbackQueue":16,"./Object.assign":37,"./PooledClass":38,"./Transaction":127,"./emptyFunction":139}],104:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactStateSetters
 */

'use strict';

var ReactStateSetters = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * @param {ReactCompositeComponent} component
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function (component, funcReturningState) {
    return function (a, b, c, d, e, f) {
      var partialState = funcReturningState.call(component, a, b, c, d, e, f);
      if (partialState) {
        component.setState(partialState);
      }
    };
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {ReactCompositeComponent} component
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function (component, key) {
    // Memoize the setters.
    var cache = component.__keySetters || (component.__keySetters = {});
    return cache[key] || (cache[key] = createStateKeySetter(component, key));
  }
};

function createStateKeySetter(component, key) {
  // Partial state is allocated outside of the function closure so it can be
  // reused with every call, avoiding memory allocation when this function
  // is called.
  var partialState = {};
  return function stateKeySetter(value) {
    partialState[key] = value;
    component.setState(partialState);
  };
}

ReactStateSetters.Mixin = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateSetter(function(xValue) {
   *     return {x: xValue};
   *   })(1);
   *
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function (funcReturningState) {
    return ReactStateSetters.createStateSetter(this, funcReturningState);
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateKeySetter('x')(1);
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function (key) {
    return ReactStateSetters.createStateKeySetter(this, key);
  }
};

module.exports = ReactStateSetters;
},{}],105:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTestUtils
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var React = require("./React");
var ReactElement = require("./ReactElement");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var assign = require("./Object.assign");
var emptyObject = require("./emptyObject");
var findDOMNode = require("./findDOMNode");

var topLevelTypes = EventConstants.topLevelTypes;

function Event(suffix) {}

/**
 * @class ReactTestUtils
 */

/**
 * Todo: Support the entire DOM.scry query syntax. For now, these simple
 * utilities will suffice for testing purposes.
 * @lends ReactTestUtils
 */
var ReactTestUtils = {
  renderIntoDocument: function (instance) {
    var div = document.createElement('div');
    // None of our tests actually require attaching the container to the
    // DOM, and doing so creates a mess that we rely on test isolation to
    // clean up, so we're going to stop honoring the name of this method
    // (and probably rename it eventually) if no problems arise.
    // document.documentElement.appendChild(div);
    return React.render(instance, div);
  },

  isElement: function (element) {
    return ReactElement.isValidElement(element);
  },

  isElementOfType: function (inst, convenienceConstructor) {
    return ReactElement.isValidElement(inst) && inst.type === convenienceConstructor;
  },

  isDOMComponent: function (inst) {
    // TODO: Fix this heuristic. It's just here because composites can currently
    // pretend to be DOM components.
    return !!(inst && inst.tagName && inst.getDOMNode);
  },

  isDOMComponentElement: function (inst) {
    return !!(inst && ReactElement.isValidElement(inst) && !!inst.tagName);
  },

  isCompositeComponent: function (inst) {
    return typeof inst.render === 'function' && typeof inst.setState === 'function';
  },

  isCompositeComponentWithType: function (inst, type) {
    return !!(ReactTestUtils.isCompositeComponent(inst) && inst.constructor === type);
  },

  isCompositeComponentElement: function (inst) {
    if (!ReactElement.isValidElement(inst)) {
      return false;
    }
    // We check the prototype of the type that will get mounted, not the
    // instance itself. This is a future proof way of duck typing.
    var prototype = inst.type.prototype;
    return typeof prototype.render === 'function' && typeof prototype.setState === 'function';
  },

  isCompositeComponentElementWithType: function (inst, type) {
    return !!(ReactTestUtils.isCompositeComponentElement(inst) && inst.constructor === type);
  },

  getRenderedChildOfCompositeComponent: function (inst) {
    if (!ReactTestUtils.isCompositeComponent(inst)) {
      return null;
    }
    var internalInstance = ReactInstanceMap.get(inst);
    return internalInstance._renderedComponent.getPublicInstance();
  },

  findAllInRenderedTree: function (inst, test) {
    if (!inst) {
      return [];
    }
    var ret = test(inst) ? [inst] : [];
    if (ReactTestUtils.isDOMComponent(inst)) {
      var internalInstance = ReactInstanceMap.get(inst);
      var renderedChildren = internalInstance._renderedComponent._renderedChildren;
      var key;
      for (key in renderedChildren) {
        if (!renderedChildren.hasOwnProperty(key)) {
          continue;
        }
        if (!renderedChildren[key].getPublicInstance) {
          continue;
        }
        ret = ret.concat(ReactTestUtils.findAllInRenderedTree(renderedChildren[key].getPublicInstance(), test));
      }
    } else if (ReactTestUtils.isCompositeComponent(inst)) {
      ret = ret.concat(ReactTestUtils.findAllInRenderedTree(ReactTestUtils.getRenderedChildOfCompositeComponent(inst), test));
    }
    return ret;
  },

  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the class name matching `className`.
   * @return an array of all the matches.
   */
  scryRenderedDOMComponentsWithClass: function (root, className) {
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      var instClassName = inst.props.className;
      return ReactTestUtils.isDOMComponent(inst) && (instClassName && (' ' + instClassName + ' ').indexOf(' ' + className + ' ') !== -1);
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithClass: function (root, className) {
    var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match ' + '(found: ' + all.length + ') for class:' + className);
    }
    return all[0];
  },

  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the tag name matching `tagName`.
   * @return an array of all the matches.
   */
  scryRenderedDOMComponentsWithTag: function (root, tagName) {
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      return ReactTestUtils.isDOMComponent(inst) && inst.tagName === tagName.toUpperCase();
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithTag: function (root, tagName) {
    var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for tag:' + tagName);
    }
    return all[0];
  },

  /**
   * Finds all instances of components with type equal to `componentType`.
   * @return an array of all the matches.
   */
  scryRenderedComponentsWithType: function (root, componentType) {
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
    });
  },

  /**
   * Same as `scryRenderedComponentsWithType` but expects there to be one result
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactComponent} The one match.
   */
  findRenderedComponentWithType: function (root, componentType) {
    var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for componentType:' + componentType);
    }
    return all[0];
  },

  /**
   * Pass a mocked component module to this method to augment it with
   * useful methods that allow it to be used as a dummy React component.
   * Instead of rendering as usual, the component will become a simple
   * <div> containing any provided children.
   *
   * @param {object} module the mock function object exported from a
   *                        module that defines the component to be mocked
   * @param {?string} mockTagName optional dummy root tag name to return
   *                              from render method (overrides
   *                              module.mockTagName if provided)
   * @return {object} the ReactTestUtils object (for chaining)
   */
  mockComponent: function (module, mockTagName) {
    mockTagName = mockTagName || module.mockTagName || 'div';

    module.prototype.render.mockImplementation(function () {
      return React.createElement(mockTagName, null, this.props.children);
    });

    return this;
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occured
   * on an `Element` node.
   * @param topLevelType {Object} A type from `EventConstants.topLevelTypes`
   * @param {!Element} node The dom to simulate an event occurring on.
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnNode: function (topLevelType, node, fakeNativeEvent) {
    fakeNativeEvent.target = node;
    ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(topLevelType, fakeNativeEvent);
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occured
   * on the `ReactDOMComponent` `comp`.
   * @param topLevelType {Object} A type from `EventConstants.topLevelTypes`.
   * @param comp {!ReactDOMComponent}
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnDOMComponent: function (topLevelType, comp, fakeNativeEvent) {
    ReactTestUtils.simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
  },

  nativeTouchData: function (x, y) {
    return {
      touches: [{ pageX: x, pageY: y }]
    };
  },

  createRenderer: function () {
    return new ReactShallowRenderer();
  },

  Simulate: null,
  SimulateNative: {}
};

/**
 * @class ReactShallowRenderer
 */
var ReactShallowRenderer = function () {
  this._instance = null;
};

ReactShallowRenderer.prototype.getRenderOutput = function () {
  return this._instance && this._instance._renderedComponent && this._instance._renderedComponent._renderedOutput || null;
};

var NoopInternalComponent = function (element) {
  this._renderedOutput = element;
  this._currentElement = element === null || element === false ? ReactEmptyComponent.emptyElement : element;
};

NoopInternalComponent.prototype = {

  mountComponent: function () {},

  receiveComponent: function (element) {
    this._renderedOutput = element;
    this._currentElement = element === null || element === false ? ReactEmptyComponent.emptyElement : element;
  },

  unmountComponent: function () {}

};

var ShallowComponentWrapper = function () {};
assign(ShallowComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: function (element) {
    return new NoopInternalComponent(element);
  },
  _replaceNodeWithMarkupByID: function () {},
  _renderValidatedComponent: ReactCompositeComponent.Mixin._renderValidatedComponentWithoutOwnerOrContext
});

ReactShallowRenderer.prototype.render = function (element, context) {
  if (!context) {
    context = emptyObject;
  }
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
  this._render(element, transaction, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
};

ReactShallowRenderer.prototype.unmount = function () {
  if (this._instance) {
    this._instance.unmountComponent();
  }
};

ReactShallowRenderer.prototype._render = function (element, transaction, context) {
  if (!this._instance) {
    var rootID = ReactInstanceHandles.createReactRootID();
    var instance = new ShallowComponentWrapper(element.type);
    instance.construct(element);

    instance.mountComponent(rootID, transaction, context);

    this._instance = instance;
  } else {
    this._instance.receiveComponent(element, transaction, context);
  }
};

/**
 * Exports:
 *
 * - `ReactTestUtils.Simulate.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.change(Element/ReactDOMComponent)`
 * - ... (All keys from event plugin `eventTypes` objects)
 */
function makeSimulator(eventType) {
  return function (domComponentOrNode, eventData) {
    var node;
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      node = findDOMNode(domComponentOrNode);
    } else if (domComponentOrNode.tagName) {
      node = domComponentOrNode;
    }

    var dispatchConfig = ReactBrowserEventEmitter.eventNameDispatchConfigs[eventType];

    var fakeNativeEvent = new Event();
    fakeNativeEvent.target = node;
    // We don't use SyntheticEvent.getPooled in order to not have to worry about
    // properly destroying any properties assigned from `eventData` upon release
    var event = new SyntheticEvent(dispatchConfig, ReactMount.getID(node), fakeNativeEvent);
    assign(event, eventData);

    if (dispatchConfig.phasedRegistrationNames) {
      EventPropagators.accumulateTwoPhaseDispatches(event);
    } else {
      EventPropagators.accumulateDirectDispatches(event);
    }

    ReactUpdates.batchedUpdates(function () {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    });
  };
}

function buildSimulators() {
  ReactTestUtils.Simulate = {};

  var eventType;
  for (eventType in ReactBrowserEventEmitter.eventNameDispatchConfigs) {
    /**
     * @param {!Element || ReactDOMComponent} domComponentOrNode
     * @param {?object} eventData Fake event data to use in SyntheticEvent.
     */
    ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
  }
}

// Rebuild ReactTestUtils.Simulate whenever event plugins are injected
var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
EventPluginHub.injection.injectEventPluginOrder = function () {
  oldInjectEventPluginOrder.apply(this, arguments);
  buildSimulators();
};
var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
EventPluginHub.injection.injectEventPluginsByName = function () {
  oldInjectEventPlugins.apply(this, arguments);
  buildSimulators();
};

buildSimulators();

/**
 * Exports:
 *
 * - `ReactTestUtils.SimulateNative.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseIn/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseOut(Element/ReactDOMComponent)`
 * - ... (All keys from `EventConstants.topLevelTypes`)
 *
 * Note: Top level event types are a subset of the entire set of handler types
 * (which include a broader set of "synthetic" events). For example, onDragDone
 * is a synthetic event. Except when testing an event plugin or React's event
 * handling code specifically, you probably want to use ReactTestUtils.Simulate
 * to dispatch synthetic events.
 */

function makeNativeSimulator(eventType) {
  return function (domComponentOrNode, nativeEventData) {
    var fakeNativeEvent = new Event(eventType);
    assign(fakeNativeEvent, nativeEventData);
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      ReactTestUtils.simulateNativeEventOnDOMComponent(eventType, domComponentOrNode, fakeNativeEvent);
    } else if (!!domComponentOrNode.tagName) {
      // Will allow on actual dom nodes.
      ReactTestUtils.simulateNativeEventOnNode(eventType, domComponentOrNode, fakeNativeEvent);
    }
  };
}

var eventType;
for (eventType in topLevelTypes) {
  // Event type is stored as 'topClick' - we transform that to 'click'
  var convenienceName = eventType.indexOf('top') === 0 ? eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;
  /**
   * @param {!Element || ReactDOMComponent} domComponentOrNode
   * @param {?Event} nativeEventData Fake native event to use in SyntheticEvent.
   */
  ReactTestUtils.SimulateNative[convenienceName] = makeNativeSimulator(eventType);
}

module.exports = ReactTestUtils;
},{"./EventConstants":25,"./EventPluginHub":27,"./EventPropagators":30,"./Object.assign":37,"./React":39,"./ReactBrowserEventEmitter":41,"./ReactCompositeComponent":51,"./ReactElement":73,"./ReactEmptyComponent":75,"./ReactInstanceHandles":82,"./ReactInstanceMap":83,"./ReactMount":88,"./ReactUpdates":110,"./SyntheticEvent":119,"./emptyObject":140,"./findDOMNode":142}],106:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactTransitionChildMapping
 */

'use strict';

var ReactChildren = require("./ReactChildren");
var ReactFragment = require("./ReactFragment");

var ReactTransitionChildMapping = {
  /**
   * Given `this.props.children`, return an object mapping key to child. Just
   * simple syntactic sugar around ReactChildren.map().
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */
  getChildMapping: function (children) {
    if (!children) {
      return children;
    }
    return ReactFragment.extract(ReactChildren.map(children, function (child) {
      return child;
    }));
  },

  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */
  mergeChildMappings: function (prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      if (next.hasOwnProperty(key)) {
        return next[key];
      } else {
        return prev[key];
      }
    }

    // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextKeysPending = {};

    var pendingKeys = [];
    for (var prevKey in prev) {
      if (next.hasOwnProperty(prevKey)) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending.hasOwnProperty(nextKey)) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }

    // Finally, add the keys which didn't appear before any key in `next`
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }
};

module.exports = ReactTransitionChildMapping;
},{"./ReactChildren":45,"./ReactFragment":79}],107:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTransitionEvents
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

/**
 * EVENT_NAME_MAP is used to determine which event fired when a
 * transition/animation ends, based on the style property used to
 * define that event.
 */
var EVENT_NAME_MAP = {
  transitionend: {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'mozTransitionEnd',
    'OTransition': 'oTransitionEnd',
    'msTransition': 'MSTransitionEnd'
  },

  animationend: {
    'animation': 'animationend',
    'WebkitAnimation': 'webkitAnimationEnd',
    'MozAnimation': 'mozAnimationEnd',
    'OAnimation': 'oAnimationEnd',
    'msAnimation': 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are useable, and if not remove them
  // from the map
  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    var baseEvents = EVENT_NAME_MAP[baseEventName];
    for (var styleName in baseEvents) {
      if (styleName in style) {
        endEvents.push(baseEvents[styleName]);
        break;
      }
    }
  }
}

if (ExecutionEnvironment.canUseDOM) {
  detectEvents();
}

// We use the raw {add|remove}EventListener() call because EventListener
// does not know how to remove event listeners and we really should
// clean up. Also, these events are not triggered in older browsers
// so we should be A-OK here.

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var ReactTransitionEvents = {
  addEndEventListener: function (node, eventListener) {
    if (endEvents.length === 0) {
      // If CSS transitions are not supported, trigger an "end animation"
      // event immediately.
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },

  removeEndEventListener: function (node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

module.exports = ReactTransitionEvents;
},{"./ExecutionEnvironment":31}],108:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTransitionGroup
 */

'use strict';

var React = require("./React");
var ReactTransitionChildMapping = require("./ReactTransitionChildMapping");

var assign = require("./Object.assign");
var cloneWithProps = require("./cloneWithProps");
var emptyFunction = require("./emptyFunction");

var ReactTransitionGroup = React.createClass({
  displayName: 'ReactTransitionGroup',

  propTypes: {
    component: React.PropTypes.any,
    childFactory: React.PropTypes.func
  },

  getDefaultProps: function () {
    return {
      component: 'span',
      childFactory: emptyFunction.thatReturnsArgument
    };
  },

  getInitialState: function () {
    return {
      children: ReactTransitionChildMapping.getChildMapping(this.props.children)
    };
  },

  componentWillMount: function () {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  },

  componentDidMount: function () {
    var initialChildMapping = this.state.children;
    for (var key in initialChildMapping) {
      if (initialChildMapping[key]) {
        this.performAppear(key);
      }
    }
  },

  componentWillReceiveProps: function (nextProps) {
    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(nextProps.children);
    var prevChildMapping = this.state.children;

    this.setState({
      children: ReactTransitionChildMapping.mergeChildMappings(prevChildMapping, nextChildMapping)
    });

    var key;

    for (key in nextChildMapping) {
      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
        this.keysToEnter.push(key);
      }
    }

    for (key in prevChildMapping) {
      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
      if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
        this.keysToLeave.push(key);
      }
    }

    // If we want to someday check for reordering, we could do it here.
  },

  componentDidUpdate: function () {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  },

  performAppear: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];

    if (component.componentWillAppear) {
      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
    } else {
      this._handleDoneAppearing(key);
    }
  },

  _handleDoneAppearing: function (key) {
    var component = this.refs[key];
    if (component.componentDidAppear) {
      component.componentDidAppear();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully appeared. Remove it.
      this.performLeave(key);
    }
  },

  performEnter: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];

    if (component.componentWillEnter) {
      component.componentWillEnter(this._handleDoneEntering.bind(this, key));
    } else {
      this._handleDoneEntering(key);
    }
  },

  _handleDoneEntering: function (key) {
    var component = this.refs[key];
    if (component.componentDidEnter) {
      component.componentDidEnter();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully entered. Remove it.
      this.performLeave(key);
    }
  },

  performLeave: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];
    if (component.componentWillLeave) {
      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
    } else {
      // Note that this is somewhat dangerous b/c it calls setState()
      // again, effectively mutating the component before all the work
      // is done.
      this._handleDoneLeaving(key);
    }
  },

  _handleDoneLeaving: function (key) {
    var component = this.refs[key];

    if (component.componentDidLeave) {
      component.componentDidLeave();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
      // This entered again before it fully left. Add it again.
      this.performEnter(key);
    } else {
      this.setState(function (state) {
        var newChildren = assign({}, state.children);
        delete newChildren[key];
        return { children: newChildren };
      });
    }
  },

  render: function () {
    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = [];
    for (var key in this.state.children) {
      var child = this.state.children[key];
      if (child) {
        // You may need to apply reactive updates to a child as it is leaving.
        // The normal React way to do it won't work since the child will have
        // already been removed. In case you need this behavior you can provide
        // a childFactory function to wrap every child, even the ones that are
        // leaving.
        childrenToRender.push(cloneWithProps(this.props.childFactory(child), { ref: key, key: key }));
      }
    }
    return React.createElement(this.props.component, this.props, childrenToRender);
  }
});

module.exports = ReactTransitionGroup;
},{"./Object.assign":37,"./React":39,"./ReactTransitionChildMapping":106,"./cloneWithProps":133,"./emptyFunction":139}],109:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdateQueue
 */

'use strict';

var ReactLifeCycle = require("./ReactLifeCycle");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var warning = require("./warning");

function enqueueUpdate(internalInstance) {
  if (internalInstance !== ReactLifeCycle.currentlyMountingInstance) {
    // If we're in a componentWillMount handler, don't enqueue a rerender
    // because ReactUpdates assumes we're in a browser context (which is
    // wrong for server rendering) and we're about to do a render anyway.
    // See bug in #1740.
    ReactUpdates.enqueueUpdate(internalInstance);
  }
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  !(ReactCurrentOwner.current == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : invariant(false) : undefined;

  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if ('production' !== process.env.NODE_ENV) {
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      'production' !== process.env.NODE_ENV ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted ' + 'component. This is a no-op.', callerName, callerName) : undefined;
    }
    return null;
  }

  if (internalInstance === ReactLifeCycle.currentlyUnmountingInstance) {
    return null;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {
    !(typeof callback === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance || internalInstance === ReactLifeCycle.currentlyMountingInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    !(typeof callback === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldUpdateComponent`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function (publicInstance, partialProps) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');

    if (!internalInstance) {
      return;
    }

    !internalInstance._isTopLevel ? 'production' !== process.env.NODE_ENV ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var element = internalInstance._pendingElement || internalInstance._currentElement;
    var props = assign({}, element.props, partialProps);
    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function (publicInstance, props) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');

    if (!internalInstance) {
      return;
    }

    !internalInstance._isTopLevel ? 'production' !== process.env.NODE_ENV ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var element = internalInstance._pendingElement || internalInstance._currentElement;
    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, newElement) {
    internalInstance._pendingElement = newElement;
    enqueueUpdate(internalInstance);
  }

};

module.exports = ReactUpdateQueue;
}).call(this,require('_process'))

},{"./Object.assign":37,"./ReactCurrentOwner":53,"./ReactElement":73,"./ReactInstanceMap":83,"./ReactLifeCycle":85,"./ReactUpdates":110,"./invariant":159,"./warning":183,"_process":2}],110:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdates
 */

'use strict';

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactPerf = require("./ReactPerf");
var ReactReconciler = require("./ReactReconciler");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var warning = require("./warning");

var dirtyComponents = [];
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();
}

assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};
flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)
  'production' !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'enqueueUpdate(): Render methods should be a pure function of props ' + 'and state; triggering nested component updates from render is not ' + 'allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : undefined;

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
}).call(this,require('_process'))

},{"./CallbackQueue":16,"./Object.assign":37,"./PooledClass":38,"./ReactCurrentOwner":53,"./ReactPerf":93,"./ReactReconciler":99,"./Transaction":127,"./invariant":159,"./warning":183,"_process":2}],111:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactWithAddons
 */

/**
 * This module exists purely in the open source project, and is meant as a way
 * to create a separate standalone build of React. This build has "addons", or
 * functionality we've built and think might be useful but doesn't have a good
 * place to live inside React core.
 */

'use strict';

var LinkedStateMixin = require("./LinkedStateMixin");
var React = require("./React");
var ReactComponentWithPureRenderMixin = require("./ReactComponentWithPureRenderMixin");
var ReactCSSTransitionGroup = require("./ReactCSSTransitionGroup");
var ReactFragment = require("./ReactFragment");
var ReactTransitionGroup = require("./ReactTransitionGroup");
var ReactUpdates = require("./ReactUpdates");

var cloneWithProps = require("./cloneWithProps");
var renderSubtreeIntoContainer = require("./renderSubtreeIntoContainer");
var shallowCompare = require("./shallowCompare");
var update = require("./update");

React.addons = {
  CSSTransitionGroup: ReactCSSTransitionGroup,
  LinkedStateMixin: LinkedStateMixin,
  PureRenderMixin: ReactComponentWithPureRenderMixin,
  TransitionGroup: ReactTransitionGroup,

  batchedUpdates: ReactUpdates.batchedUpdates,
  cloneWithProps: cloneWithProps,
  createFragment: ReactFragment.create,
  renderSubtreeIntoContainer: renderSubtreeIntoContainer,
  shallowCompare: shallowCompare,
  update: update
};

if ('production' !== process.env.NODE_ENV) {
  React.addons.Perf = require("./ReactDefaultPerf");
  React.addons.TestUtils = require("./ReactTestUtils");
}

module.exports = React;
}).call(this,require('_process'))

},{"./LinkedStateMixin":34,"./React":39,"./ReactCSSTransitionGroup":42,"./ReactComponentWithPureRenderMixin":50,"./ReactDefaultPerf":71,"./ReactFragment":79,"./ReactTestUtils":105,"./ReactTransitionGroup":108,"./ReactUpdates":110,"./cloneWithProps":133,"./renderSubtreeIntoContainer":173,"./shallowCompare":176,"./update":181,"_process":2}],112:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SVGDOMPropertyConfig
 */

'use strict';

var DOMProperty = require("./DOMProperty");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

var SVGDOMPropertyConfig = {
  Properties: {
    clipPath: MUST_USE_ATTRIBUTE,
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    xlinkActuate: MUST_USE_ATTRIBUTE,
    xlinkArcrole: MUST_USE_ATTRIBUTE,
    xlinkHref: MUST_USE_ATTRIBUTE,
    xlinkRole: MUST_USE_ATTRIBUTE,
    xlinkShow: MUST_USE_ATTRIBUTE,
    xlinkTitle: MUST_USE_ATTRIBUTE,
    xlinkType: MUST_USE_ATTRIBUTE,
    xmlBase: MUST_USE_ATTRIBUTE,
    xmlLang: MUST_USE_ATTRIBUTE,
    xmlSpace: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {
    clipPath: 'clip-path',
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space'
  }
};

module.exports = SVGDOMPropertyConfig;
},{"./DOMProperty":20}],113:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectEventPlugin
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ReactInputSelection = require("./ReactInputSelection");
var SyntheticEvent = require("./SyntheticEvent");

var getActiveElement = require("./getActiveElement");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");
var shallowEqual = require("./shallowEqual");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSelect: null }),
      captured: keyOf({ onSelectCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events.
var hasListener = false;
var ON_SELECT_KEY = keyOf({ onSelect: null });

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @param {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {

    if (!hasListener) {
      return null;
    }

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't).
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      case topLevelTypes.topSelectionChange:
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent);
    }

    return null;
  },

  didPutListener: function (id, registrationName, listener) {
    if (registrationName === ON_SELECT_KEY) {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventConstants":25,"./EventPropagators":30,"./ReactInputSelection":81,"./SyntheticEvent":119,"./getActiveElement":146,"./isTextInputElement":162,"./keyOf":166,"./shallowEqual":177}],114:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

'use strict';

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */
var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function () {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;
},{}],115:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SimpleEventPlugin
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventListener = require("./EventListener");
var EventPluginUtils = require("./EventPluginUtils");
var EventPropagators = require("./EventPropagators");
var ReactMount = require("./ReactMount");
var SyntheticClipboardEvent = require("./SyntheticClipboardEvent");
var SyntheticEvent = require("./SyntheticEvent");
var SyntheticFocusEvent = require("./SyntheticFocusEvent");
var SyntheticKeyboardEvent = require("./SyntheticKeyboardEvent");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");
var SyntheticDragEvent = require("./SyntheticDragEvent");
var SyntheticTouchEvent = require("./SyntheticTouchEvent");
var SyntheticUIEvent = require("./SyntheticUIEvent");
var SyntheticWheelEvent = require("./SyntheticWheelEvent");

var emptyFunction = require("./emptyFunction");
var getEventCharCode = require("./getEventCharCode");
var invariant = require("./invariant");
var keyOf = require("./keyOf");
var warning = require("./warning");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBlur: true }),
      captured: keyOf({ onBlurCapture: true })
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onClick: true }),
      captured: keyOf({ onClickCapture: true })
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onContextMenu: true }),
      captured: keyOf({ onContextMenuCapture: true })
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCopy: true }),
      captured: keyOf({ onCopyCapture: true })
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCut: true }),
      captured: keyOf({ onCutCapture: true })
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDoubleClick: true }),
      captured: keyOf({ onDoubleClickCapture: true })
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrag: true }),
      captured: keyOf({ onDragCapture: true })
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnd: true }),
      captured: keyOf({ onDragEndCapture: true })
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnter: true }),
      captured: keyOf({ onDragEnterCapture: true })
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragExit: true }),
      captured: keyOf({ onDragExitCapture: true })
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragLeave: true }),
      captured: keyOf({ onDragLeaveCapture: true })
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragOver: true }),
      captured: keyOf({ onDragOverCapture: true })
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragStart: true }),
      captured: keyOf({ onDragStartCapture: true })
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrop: true }),
      captured: keyOf({ onDropCapture: true })
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onFocus: true }),
      captured: keyOf({ onFocusCapture: true })
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onInput: true }),
      captured: keyOf({ onInputCapture: true })
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyDown: true }),
      captured: keyOf({ onKeyDownCapture: true })
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyPress: true }),
      captured: keyOf({ onKeyPressCapture: true })
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyUp: true }),
      captured: keyOf({ onKeyUpCapture: true })
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoad: true }),
      captured: keyOf({ onLoadCapture: true })
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onError: true }),
      captured: keyOf({ onErrorCapture: true })
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseDown: true }),
      captured: keyOf({ onMouseDownCapture: true })
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseMove: true }),
      captured: keyOf({ onMouseMoveCapture: true })
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOut: true }),
      captured: keyOf({ onMouseOutCapture: true })
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOver: true }),
      captured: keyOf({ onMouseOverCapture: true })
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseUp: true }),
      captured: keyOf({ onMouseUpCapture: true })
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPaste: true }),
      captured: keyOf({ onPasteCapture: true })
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onReset: true }),
      captured: keyOf({ onResetCapture: true })
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onScroll: true }),
      captured: keyOf({ onScrollCapture: true })
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSubmit: true }),
      captured: keyOf({ onSubmitCapture: true })
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchCancel: true }),
      captured: keyOf({ onTouchCancelCapture: true })
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchEnd: true }),
      captured: keyOf({ onTouchEndCapture: true })
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchMove: true }),
      captured: keyOf({ onTouchMoveCapture: true })
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchStart: true }),
      captured: keyOf({ onTouchStartCapture: true })
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWheel: true }),
      captured: keyOf({ onWheelCapture: true })
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topBlur: eventTypes.blur,
  topClick: eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy: eventTypes.copy,
  topCut: eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag: eventTypes.drag,
  topDragEnd: eventTypes.dragEnd,
  topDragEnter: eventTypes.dragEnter,
  topDragExit: eventTypes.dragExit,
  topDragLeave: eventTypes.dragLeave,
  topDragOver: eventTypes.dragOver,
  topDragStart: eventTypes.dragStart,
  topDrop: eventTypes.drop,
  topError: eventTypes.error,
  topFocus: eventTypes.focus,
  topInput: eventTypes.input,
  topKeyDown: eventTypes.keyDown,
  topKeyPress: eventTypes.keyPress,
  topKeyUp: eventTypes.keyUp,
  topLoad: eventTypes.load,
  topMouseDown: eventTypes.mouseDown,
  topMouseMove: eventTypes.mouseMove,
  topMouseOut: eventTypes.mouseOut,
  topMouseOver: eventTypes.mouseOver,
  topMouseUp: eventTypes.mouseUp,
  topPaste: eventTypes.paste,
  topReset: eventTypes.reset,
  topScroll: eventTypes.scroll,
  topSubmit: eventTypes.submit,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd: eventTypes.touchEnd,
  topTouchMove: eventTypes.touchMove,
  topTouchStart: eventTypes.touchStart,
  topWheel: eventTypes.wheel
};

for (var type in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[type].dependencies = [type];
}

var ON_CLICK_KEY = keyOf({ onClick: null });
var onClickListeners = {};

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * Same as the default implementation, except cancels the event when return
   * value is false. This behavior will be disabled in a future release.
   *
   * @param {object} Event to be dispatched.
   * @param {function} Application-level callback.
   * @param {string} domID DOM ID to pass to the callback.
   */
  executeDispatch: function (event, listener, domID) {
    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);

    'production' !== process.env.NODE_ENV ? warning(typeof returnValue !== 'boolean', 'Returning `false` from an event handler is deprecated and will be ' + 'ignored in a future release. Instead, manually call ' + 'e.stopPropagation() or e.preventDefault(), as appropriate.') : undefined;

    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  },

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topError:
      case topLevelTypes.topReset:
      case topLevelTypes.topSubmit:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? 'production' !== process.env.NODE_ENV ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (id, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    if (registrationName === ON_CLICK_KEY) {
      var node = ReactMount.getNode(id);
      if (!onClickListeners[id]) {
        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (id, registrationName) {
    if (registrationName === ON_CLICK_KEY) {
      onClickListeners[id].remove();
      delete onClickListeners[id];
    }
  }

};

module.exports = SimpleEventPlugin;
}).call(this,require('_process'))

},{"./EventConstants":25,"./EventListener":26,"./EventPluginUtils":29,"./EventPropagators":30,"./ReactMount":88,"./SyntheticClipboardEvent":116,"./SyntheticDragEvent":118,"./SyntheticEvent":119,"./SyntheticFocusEvent":120,"./SyntheticKeyboardEvent":122,"./SyntheticMouseEvent":123,"./SyntheticTouchEvent":124,"./SyntheticUIEvent":125,"./SyntheticWheelEvent":126,"./emptyFunction":139,"./getEventCharCode":147,"./invariant":159,"./keyOf":166,"./warning":183,"_process":2}],116:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":119}],117:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":119}],118:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":123}],119:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

'use strict';

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var getEventTarget = require("./getEventTarget");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: getEventTarget,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      this[propName] = nativeEvent[propName];
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);

module.exports = SyntheticEvent;
},{"./Object.assign":37,"./PooledClass":38,"./emptyFunction":139,"./getEventTarget":150}],120:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require("./SyntheticUIEvent");

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":125}],121:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":119}],122:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventCharCode = require("./getEventCharCode");
var getEventKey = require("./getEventKey");
var getEventModifierState = require("./getEventModifierState");

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":125,"./getEventCharCode":147,"./getEventKey":148,"./getEventModifierState":149}],123:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require("./SyntheticUIEvent");
var ViewportMetrics = require("./ViewportMetrics");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":125,"./ViewportMetrics":128,"./getEventModifierState":149}],124:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":125,"./getEventModifierState":149}],125:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require("./SyntheticEvent");

var getEventTarget = require("./getEventTarget");

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":119,"./getEventTarget":150}],126:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":123}],127:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Transaction
 */

'use strict';

var invariant = require("./invariant");

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (!this.wrapperInitData) {
      this.wrapperInitData = [];
    } else {
      this.wrapperInitData.length = 0;
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} args... Arguments to pass to the method (optional).
   *                           Helps prevent need to bind in many cases.
   * @return Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occured.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],128:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],129:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

'use strict';

var invariant = require("./invariant");

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],130:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adler32
 */

'use strict';

var MOD = 65521;

// This is a clean-room implementation of adler32 designed for detecting
// if markup is not what we expect it to be. It does not need to be
// cryptographically strong, only reasonably good at detecting if markup
// generated on the server is different than that on the client.
function adler32(data) {
  var a = 1;
  var b = 0;
  for (var i = 0; i < data.length; i++) {
    a = (a + data.charCodeAt(i)) % MOD;
    b = (b + a) % MOD;
  }
  return a | b << 16;
}

module.exports = adler32;
},{}],131:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelize
 * @typechecks
 */

"use strict";

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],132:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelizeStyleName
 * @typechecks
 */

'use strict';

var camelize = require("./camelize");

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":131}],133:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule cloneWithProps
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactPropTransferer = require("./ReactPropTransferer");

var keyOf = require("./keyOf");
var warning = require("./warning");

var CHILDREN_PROP = keyOf({ children: null });

/**
 * Sometimes you want to change the props of a child passed to you. Usually
 * this is to add a CSS class.
 *
 * @param {ReactElement} child child element you'd like to clone
 * @param {object} props props you'd like to modify. className and style will be
 * merged automatically.
 * @return {ReactElement} a clone of child with props merged in.
 */
function cloneWithProps(child, props) {
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(!child.ref, 'You are calling cloneWithProps() on a child with a ref. This is ' + 'dangerous because you\'re creating a new child which will not be ' + 'added as a ref to its parent.') : undefined;
  }

  var newProps = ReactPropTransferer.mergeProps(props, child.props);

  // Use `child.props.children` if it is provided.
  if (!newProps.hasOwnProperty(CHILDREN_PROP) && child.props.hasOwnProperty(CHILDREN_PROP)) {
    newProps.children = child.props.children;
  }

  // The current API doesn't retain _owner and _context, which is why this
  // doesn't use ReactElement.cloneAndReplaceProps.
  return ReactElement.createElement(child.type, newProps);
}

module.exports = cloneWithProps;
}).call(this,require('_process'))

},{"./ReactElement":73,"./ReactPropTransferer":94,"./keyOf":166,"./warning":183,"_process":2}],134:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule containsNode
 * @typechecks
 */

'use strict';

var isTextNode = require("./isTextNode");

/*jslint bitwise:true */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(_x, _x2) {
  var _again = true;

  _function: while (_again) {
    var outerNode = _x,
        innerNode = _x2;
    _again = false;

    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      _x = outerNode;
      _x2 = innerNode.parentNode;
      _again = true;
      continue _function;
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
}

module.exports = containsNode;
},{"./isTextNode":163}],135:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createArrayFromMixed
 * @typechecks
 */

'use strict';

var toArray = require("./toArray");

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj &&
    // not window
    !('setInterval' in obj) && typeof obj.nodeType != 'number' && (
    // a real array
    (Array.isArray(obj) || 'callee' in obj || 'item' in obj))
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;

// arrays are objects, NodeLists are functions in Safari

// quacks like an array

// no DOM node should be considered an array-like
// a 'select' element has 'length' and 'item' properties on IE8

// arguments

// HTMLCollection/NodeList
},{"./toArray":179}],136:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createFullPageComponent
 * @typechecks
 */

'use strict';

// Defeat circular references by requiring this directly.
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var invariant = require("./invariant");

/**
 * Create a component that will throw an exception when unmounted.
 *
 * Components like <html> <head> and <body> can't be removed or added
 * easily in a cross-browser way, however it's valuable to be able to
 * take advantage of React's reconciliation for styling and <title>
 * management. So we just document it and throw in dangerous cases.
 *
 * @param {string} tag The tag to wrap
 * @return {function} convenience constructor of new component
 */
function createFullPageComponent(tag) {
  var elementFactory = ReactElement.createFactory(tag);

  var FullPageComponent = ReactClass.createClass({
    tagName: tag.toUpperCase(),
    displayName: 'ReactFullPageComponent' + tag,

    componentWillUnmount: function () {
      !false ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, <head>, ' + 'and <body>) reliably and efficiently. To fix this, have a single ' + 'top-level component that never unmounts render these elements.', this.constructor.displayName) : invariant(false) : undefined;
    },

    render: function () {
      return elementFactory(this.props);
    }
  });

  return FullPageComponent;
}

module.exports = createFullPageComponent;
}).call(this,require('_process'))

},{"./ReactClass":46,"./ReactElement":73,"./invariant":159,"_process":2}],137:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*jslint evil: true, sub: true */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createArrayFromMixed = require("./createArrayFromMixed");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? 'production' !== process.env.NODE_ENV ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? 'production' !== process.env.NODE_ENV ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = createArrayFromMixed(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":31,"./createArrayFromMixed":135,"./getMarkupWrap":152,"./invariant":159,"_process":2}],138:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require("./CSSProperty");

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"./CSSProperty":14}],139:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

"use strict";

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],140:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyObject
 */

"use strict";

var emptyObject = {};

if ("production" !== process.env.NODE_ENV) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
}).call(this,require('_process'))

},{"_process":2}],141:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule escapeTextContentForBrowser
 */

'use strict';

var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;',
  '"': '&quot;',
  '\'': '&#x27;'
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextContentForBrowser;
},{}],142:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findDOMNode
 * @typechecks static-only
 */

'use strict';

var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactMount = require("./ReactMount");

var invariant = require("./invariant");
var isNode = require("./isNode");
var warning = require("./warning");

/**
 * Returns the DOM node rendered by this element.
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if ('production' !== process.env.NODE_ENV) {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      'production' !== process.env.NODE_ENV ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (isNode(componentOrElement)) {
    return componentOrElement;
  }
  if (ReactInstanceMap.has(componentOrElement)) {
    return ReactMount.getNodeFromInstance(componentOrElement);
  }
  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Component (with keys: %s) contains `render` method ' + 'but is not mounted in the DOM', Object.keys(componentOrElement)) : invariant(false) : undefined;
  !false ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
}

module.exports = findDOMNode;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":53,"./ReactInstanceMap":83,"./ReactMount":88,"./invariant":159,"./isNode":161,"./warning":183,"_process":2}],143:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule flattenChildren
 */

'use strict';

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = result[name] === undefined;
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))

},{"./traverseAllChildren":180,"./warning":183,"_process":2}],144:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule focusNode
 */

"use strict";

/**
 * @param {DOMElement} node input/textarea to focus
 */
function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],145:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

'use strict';

/**
 * @param {array} an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function (arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;
},{}],146:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document body is not yet defined.
 */
"use strict";

function getActiveElement() /*?DOMElement*/{
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],147:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventCharCode
 * @typechecks static-only
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],148:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

'use strict';

var getEventCharCode = require("./getEventCharCode");

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":147}],149:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  /*jshint validthis:true */
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],150:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],151:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getIteratorFn
 * @typechecks static-only
 */

'use strict';

/* global Symbol */
var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],152:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getMarkupWrap
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var invariant = require("./invariant");

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */
var shouldWrap = {
  // Force wrapping for SVG elements because if they get created inside a <div>,
  // they will be initialized in the wrong namespace (and will not display).
  'circle': true,
  'clipPath': true,
  'defs': true,
  'ellipse': true,
  'g': true,
  'line': true,
  'linearGradient': true,
  'path': true,
  'polygon': true,
  'polyline': true,
  'radialGradient': true,
  'rect': true,
  'stop': true,
  'text': true
};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg>', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap,

  'circle': svgWrap,
  'clipPath': svgWrap,
  'defs': svgWrap,
  'ellipse': svgWrap,
  'g': svgWrap,
  'line': svgWrap,
  'linearGradient': svgWrap,
  'path': svgWrap,
  'polygon': svgWrap,
  'polyline': svgWrap,
  'radialGradient': svgWrap,
  'rect': svgWrap,
  'stop': svgWrap,
  'text': svgWrap
};

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":31,"./invariant":159,"_process":2}],153:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNodeForCharacterOffset
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],154:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentAccessor
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"./ExecutionEnvironment":31}],155:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

"use strict";

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],156:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenate
 * @typechecks
 */

'use strict';

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],157:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

'use strict';

var hyphenate = require("./hyphenate");

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":156}],158:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

'use strict';

var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactNativeComponent = require("./ReactNativeComponent");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var warning = require("./warning");

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function () {};
assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: instantiateReactComponent
});

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {*} parentCompositeType The composite type that resolved this.
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, parentCompositeType) {
  var instance;

  if (node === null || node === false) {
    node = ReactEmptyComponent.emptyElement;
  }

  if (typeof node === 'object') {
    var element = node;
    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(element && (typeof element.type === 'function' || typeof element.type === 'string'), 'Only functions or strings can be mounted as React components.') : undefined;
    }

    // Special case string values
    if (parentCompositeType === element.type && typeof element.type === 'string') {
      // Avoid recursion if the wrapper renders itself.
      instance = ReactNativeComponent.createInternalComponent(element);
      // All native components are currently wrapped in a composite so we're
      // safe to assume that this is what we should instantiate.
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // represenations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);
    } else {
      instance = new ReactCompositeComponentWrapper();
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    !false ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
  }

  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
  }

  // Sets up the instance. This can probably just move into the constructor now.
  instance.construct(node);

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if ('production' !== process.env.NODE_ENV) {
    instance._isOwnerNecessary = false;
    instance._warnedAboutRefsInRender = false;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if ('production' !== process.env.NODE_ENV) {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
}).call(this,require('_process'))

},{"./Object.assign":37,"./ReactCompositeComponent":51,"./ReactEmptyComponent":75,"./ReactNativeComponent":91,"./invariant":159,"./warning":183,"_process":2}],159:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if ('production' !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":2}],160:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"./ExecutionEnvironment":31}],161:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
'use strict';

function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],162:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextInputElement
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  return elem && (elem.nodeName === 'INPUT' && supportedInputTypes[elem.type] || elem.nodeName === 'TEXTAREA');
}

module.exports = isTextInputElement;
},{}],163:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextNode
 * @typechecks
 */

'use strict';

var isNode = require("./isNode");

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":161}],164:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule joinClasses
 * @typechecks static-only
 */

'use strict';

/**
 * Combines multiple className strings into one.
 * http://jsperf.com/joinclasses-args-vs-array
 *
 * @param {...?string} classes
 * @return {string}
 */
function joinClasses(className /*, ... */) {
  if (!className) {
    className = '';
  }
  var nextClass;
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var ii = 1; ii < argLength; ii++) {
      nextClass = arguments[ii];
      if (nextClass) {
        className = (className ? className + ' ' : '') + nextClass;
      }
    }
  }
  return className;
}

module.exports = joinClasses;
},{}],165:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

'use strict';

var invariant = require("./invariant");

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function (obj) {
  var ret = {};
  var key;
  !(obj instanceof Object && !Array.isArray(obj)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],166:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without loosing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
"use strict";

var keyOf = function (oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};

module.exports = keyOf;
},{}],167:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule mapObject
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;
},{}],168:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */
function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],169:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
'use strict';

var ReactElement = require("./ReactElement");

var invariant = require("./invariant");

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
  return children;
}

module.exports = onlyChild;
}).call(this,require('_process'))

},{"./ReactElement":73,"./invariant":159,"_process":2}],170:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performance
 * @typechecks
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"./ExecutionEnvironment":31}],171:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performanceNow
 * @typechecks
 */

'use strict';

var performance = require("./performance");

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (!performance || !performance.now) {
  performance = Date;
}

var performanceNow = performance.now.bind(performance);

module.exports = performanceNow;
},{"./performance":170}],172:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule quoteAttributeValueForBrowser
 */

'use strict';

var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":141}],173:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule renderSubtreeIntoContainer
*/

'use strict';

var ReactMount = require("./ReactMount");

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":88}],174:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setInnerHTML
 */

/* globals MSApp */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function (node, html) {
  node.innerHTML = html;
};

// Win8 apps: Allow all html to be inserted
if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
  setInnerHTML = function (node, html) {
    MSApp.execUnsafeLocalFunction(function () {
      node.innerHTML = html;
    });
  };
}

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(65279) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;
},{"./ExecutionEnvironment":31}],175:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setTextContent
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");
var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
var setInnerHTML = require("./setInnerHTML");

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./ExecutionEnvironment":31,"./escapeTextContentForBrowser":141,"./setInnerHTML":174}],176:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require("./shallowEqual");

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
},{"./shallowEqual":177}],177:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shallowEqual
 */

'use strict';

/**
 * Performs equality by iterating through keys on an object and returning
 * false when any key has values which are not strictly equal between
 * objA and objB. Returns true when the values of all keys are strictly equal.
 *
 * @return {boolean}
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],178:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */
function shouldUpdateReactComponent(prevElement, nextElement) {
  if (prevElement != null && nextElement != null) {
    var prevType = typeof prevElement;
    var nextType = typeof nextElement;
    if (prevType === 'string' || prevType === 'number') {
      return nextType === 'string' || nextType === 'number';
    } else {
      return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
  }
  return false;
}

module.exports = shouldUpdateReactComponent;
},{}],179:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule toArray
 * @typechecks
 */

'use strict';

var invariant = require("./invariant");

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

  !(typeof length === 'number') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

  !(length === 0 || length - 1 in obj) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {}
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;

// IE < 9 does not support Array#slice on collections objects
}).call(this,require('_process'))

},{"./invariant":159,"_process":2}],180:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactFragment = require("./ReactFragment");
var ReactInstanceHandles = require("./ReactInstanceHandles");

var getIteratorFn = require("./getIteratorFn");
var invariant = require("./invariant");
var warning = require("./warning");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

var didWarnAboutMaps = false;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} key Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ('production' !== process.env.NODE_ENV) {
          'production' !== process.env.NODE_ENV ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      !(children.nodeType !== 1) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(false) : undefined;
      var fragment = ReactFragment.extract(children);
      for (var key in fragment) {
        if (fragment.hasOwnProperty(key)) {
          child = fragment[key];
          nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(child, 0);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
}).call(this,require('_process'))

},{"./ReactElement":73,"./ReactFragment":79,"./ReactInstanceHandles":82,"./getIteratorFn":151,"./invariant":159,"./warning":183,"_process":2}],181:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule update
 */

/* global hasOwnProperty:true */

'use strict';

var assign = require("./Object.assign");
var keyOf = require("./keyOf");
var invariant = require("./invariant");
var hasOwnProperty = ({}).hasOwnProperty;

function shallowCopy(x) {
  if (Array.isArray(x)) {
    return x.concat();
  } else if (x && typeof x === 'object') {
    return assign(new x.constructor(), x);
  } else {
    return x;
  }
}

var COMMAND_PUSH = keyOf({ $push: null });
var COMMAND_UNSHIFT = keyOf({ $unshift: null });
var COMMAND_SPLICE = keyOf({ $splice: null });
var COMMAND_SET = keyOf({ $set: null });
var COMMAND_MERGE = keyOf({ $merge: null });
var COMMAND_APPLY = keyOf({ $apply: null });

var ALL_COMMANDS_LIST = [COMMAND_PUSH, COMMAND_UNSHIFT, COMMAND_SPLICE, COMMAND_SET, COMMAND_MERGE, COMMAND_APPLY];

var ALL_COMMANDS_SET = {};

ALL_COMMANDS_LIST.forEach(function (command) {
  ALL_COMMANDS_SET[command] = true;
});

function invariantArrayCase(value, spec, command) {
  !Array.isArray(value) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected target of %s to be an array; got %s.', command, value) : invariant(false) : undefined;
  var specValue = spec[command];
  !Array.isArray(specValue) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected spec of %s to be an array; got %s. ' + 'Did you forget to wrap your parameter in an array?', command, specValue) : invariant(false) : undefined;
}

function update(value, spec) {
  !(typeof spec === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): You provided a key path to update() that did not contain one ' + 'of %s. Did you forget to include {%s: ...}?', ALL_COMMANDS_LIST.join(', '), COMMAND_SET) : invariant(false) : undefined;

  if (hasOwnProperty.call(spec, COMMAND_SET)) {
    !(Object.keys(spec).length === 1) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Cannot have more than one key in an object with %s', COMMAND_SET) : invariant(false) : undefined;

    return spec[COMMAND_SET];
  }

  var nextValue = shallowCopy(value);

  if (hasOwnProperty.call(spec, COMMAND_MERGE)) {
    var mergeObj = spec[COMMAND_MERGE];
    !(mergeObj && typeof mergeObj === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): %s expects a spec of type \'object\'; got %s', COMMAND_MERGE, mergeObj) : invariant(false) : undefined;
    !(nextValue && typeof nextValue === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): %s expects a target of type \'object\'; got %s', COMMAND_MERGE, nextValue) : invariant(false) : undefined;
    assign(nextValue, spec[COMMAND_MERGE]);
  }

  if (hasOwnProperty.call(spec, COMMAND_PUSH)) {
    invariantArrayCase(value, spec, COMMAND_PUSH);
    spec[COMMAND_PUSH].forEach(function (item) {
      nextValue.push(item);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_UNSHIFT)) {
    invariantArrayCase(value, spec, COMMAND_UNSHIFT);
    spec[COMMAND_UNSHIFT].forEach(function (item) {
      nextValue.unshift(item);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_SPLICE)) {
    !Array.isArray(value) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Expected %s target to be an array; got %s', COMMAND_SPLICE, value) : invariant(false) : undefined;
    !Array.isArray(spec[COMMAND_SPLICE]) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. ' + 'Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : invariant(false) : undefined;
    spec[COMMAND_SPLICE].forEach(function (args) {
      !Array.isArray(args) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. ' + 'Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : invariant(false) : undefined;
      nextValue.splice.apply(nextValue, args);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_APPLY)) {
    !(typeof spec[COMMAND_APPLY] === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected spec of %s to be a function; got %s.', COMMAND_APPLY, spec[COMMAND_APPLY]) : invariant(false) : undefined;
    nextValue = spec[COMMAND_APPLY](nextValue);
  }

  for (var k in spec) {
    if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {
      nextValue[k] = update(value[k], spec[k]);
    }
  }

  return nextValue;
}

module.exports = update;
}).call(this,require('_process'))

},{"./Object.assign":37,"./invariant":159,"./keyOf":166,"_process":2}],182:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule validateDOMNesting
 */

'use strict';

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var warning = require("./warning");

var validateDOMNesting = emptyFunction;

if ('production' !== process.env.NODE_ENV) {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    parentTag: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.parentTag = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    /*eslint-disable space-after-keywords */
    do {
      /*eslint-enable space-after-keywords */
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        'production' !== process.env.NODE_ENV ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
      } else {
        'production' !== process.env.NODE_ENV ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
      }
    }
  };

  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
}).call(this,require('_process'))

},{"./Object.assign":37,"./emptyFunction":139,"./warning":183,"_process":2}],183:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule warning
 */

'use strict';

var emptyFunction = require("./emptyFunction");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ('production' !== process.env.NODE_ENV) {
  warning = function (condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.length < 10 || /^[s\W]*$/.test(format)) {
      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
}).call(this,require('_process'))

},{"./emptyFunction":139,"_process":2}],184:[function(require,module,exports){
module.exports = require('./lib/React');

},{"./lib/React":39}],185:[function(require,module,exports){
var AppDispatcher = require('../dispatcher/AppDispatcher');

var InputActions = {

    upsert: function(input) {
        AppDispatcher.dispatch({
            actionType: input.actionType,
            modelKey: input.modelKey,
            modelValue: input.modelValue
        });
    }

};

module.exports = InputActions;

},{"../dispatcher/AppDispatcher":201}],186:[function(require,module,exports){
var React = require('react');
var MainComponent = require('./components/MainComponent');

React.render(React.createElement(MainComponent, null), document.getElementById('app'));

},{"./components/MainComponent":189,"react":184}],187:[function(require,module,exports){
var React = require('react');
var InputActions = require('../../actions/InputActions');

var InputComponent = React.createClass({displayName: "InputComponent",
    _onInputChange: function(){
        var input = React.findDOMNode(this.refs.input).value.trim();
        if(input === ''){
            input = undefined; //deleted their input; resort to undefined||defaults
        }
        if(this.props.isValid(input)){
            if(input !== undefined){
                input = this.props.convert(input);
            }
            InputActions.upsert({
                actionType: this.props.actionType,
                modelKey: this.props.id,
                modelValue: input
            });
        }
    },
    render: function() {
        var before, after;
        if(this.props.addOnBeforeInput === undefined || this.props.addOnBeforeInput){
            before = React.createElement("span", {className: "input-group-addon"}, this.props.addOn);
        }else{
            after = React.createElement("span", {className: "input-group-addon"}, this.props.addOn);
        }
        var required = this.props.required ? ' required' : '';
        return (
            React.createElement("div", null, 
                React.createElement("label", {className: "label label-default" + required, htmlFor: this.props.id}, this.props.label), 
                React.createElement("div", {className: "input-group"}, 
                    before, 
                    React.createElement("input", {
                        className: "form-control", 
                        id: this.props.id, 
                        type: this.props.type, 
                        name: this.props.id, 
                        placeholder: this.props.default, 
                        onChange: this._onInputChange, 
                        ref: "input"}
                    ), 
                    after
                )
            )
        );
    }
});

module.exports = InputComponent;

},{"../../actions/InputActions":185,"react":184}],188:[function(require,module,exports){
var React = require('react');
var InputComponent = require('./InputComponent');
var MonthlyCostInputDefinitions = require('../../defines/MonthlyCostInputDefinitions');
var ScenarioInputDefinitions = require('../../defines/ScenarioInputDefinitions');

var MainComponent = React.createClass({displayName: "MainComponent",
    render: function() {
        var inputs = ScenarioInputDefinitions.get();
        inputs = inputs.concat(MonthlyCostInputDefinitions.get());
        var inputComponents;
        if(inputs !== undefined && inputs.length > 0) {
            inputComponents = inputs.map(function (e) {
                return (
                    React.createElement(InputComponent, {
                        key: e.id, 
                        id: e.id, 
                        actionType: e.actionType, 
                        type: e.type, 
                        label: e.label, 
                        default: e.default, 
                        required: e.required, 
                        addOnBeforeInput: e.addOnBeforeInput||true, 
                        addOn: e.addOn, 
                        isValid: e.isValid, 
                        convert: e.convert}
                        )
                );
            });
        }
        return (
            React.createElement("div", {className: "inputList"}, 
                inputComponents
            )
        );
    }
});

module.exports = MainComponent;

},{"../../defines/MonthlyCostInputDefinitions":198,"../../defines/ScenarioInputDefinitions":199,"./InputComponent":187,"react":184}],189:[function(require,module,exports){
var React = require('react');
var TitleComponent = require('./TitleComponent/TitleComponent');
var InputListComponent = require('./InputListComponent/InputListComponent');
var ResultListComponent = require('./ResultListComponent/ResultListComponent');

var MainComponent = React.createClass({displayName: "MainComponent",
    render: function() {
        return (
            React.createElement("div", {className: "mainComponent"}, 
                React.createElement(TitleComponent, null), 
                React.createElement(InputListComponent, null), 
                React.createElement(ResultListComponent, null)
            )
        );
    }
});

module.exports = MainComponent;
},{"./InputListComponent/InputListComponent":188,"./ResultListComponent/ResultListComponent":194,"./TitleComponent/TitleComponent":195,"react":184}],190:[function(require,module,exports){
var React = require('react');
var Highcharts = require('react-highcharts');

var IncomeBreakdownComponent = React.createClass({displayName: "IncomeBreakdownComponent",
    render: function() {
        var incomeBreakDownChart;

        if(this.props.monthlyIncome > 0) {

            var breakdowns = [
                {
                    label: 'Take home',
                    value: (this.props.netIncome / this.props.monthlyIncome) * 100
                },
                {
                    label: 'Expenses',
                    value: (this.props.monthlyExpenses / this.props.monthlyIncome) * 100
                },
                {
                    label: 'Monthly Car Cost',
                    value: (this.props.monthlyCarCost / this.props.monthlyIncome) * 100
                }
            ];

            var data = [];
            breakdowns.forEach(function (e) {
                if (e.value > 0) {
                    data.push([e.label, e.value]);
                }
            });

            var config = {
                chart: {
                    plotBackgroundColor: null,
                    plotBorderWidth: 0,
                    plotShadow: false
                },
                title: {
                    text: 'Income<br>Breakdown',
                    align: 'center',
                    verticalAlign: 'middle',
                    y: 40
                },
                tooltip: {
                    pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'
                },
                plotOptions: {
                    pie: {
                        dataLabels: {
                            enabled: true,
                            distance: -50,
                            style: {
                                fontWeight: 'bold',
                                color: 'white',
                                textShadow: '0px 1px 2px black'
                            }
                        },
                        startAngle: -90,
                        endAngle: 90,
                        center: ['50%', '75%']
                    }
                },
                series: [{
                    type: 'pie',
                    name: 'Income Breakdown',
                    innerSize: '50%',
                    data: data
                }]
            };
            incomeBreakDownChart = React.createElement(Highcharts, {config: config});
        }
        return (
            React.createElement("div", null, 
                incomeBreakDownChart
            )
        );
    }
});

module.exports = IncomeBreakdownComponent;
},{"react":184,"react-highcharts":8}],191:[function(require,module,exports){
var React = require('react');

var NetIncomeTextComponent = React.createClass({displayName: "NetIncomeTextComponent",
    render: function() {
        return (
            React.createElement("div", null, 
                React.createElement("h2", {className: "well centerText"}, "Take Home Per Month After Expenses And Car Payment $", this.props.netIncome.toFixed(2)), ";"
            )
        );
    }
});

module.exports = NetIncomeTextComponent;

},{"react":184}],192:[function(require,module,exports){
var React = require('react');
var InputActionConstants = require('../../../../constants/InputActionConstants');
var InputStore = require('../../../../stores/InputStore');

var SafetyNetOverTimeComponent = React.createClass({displayName: "SafetyNetOverTimeComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        InputStore.addChangeListener(InputActionConstants.SAFETY_NET_CHANGE, this._onInputChange);
    },
    componentWillUnmount: function() {
        InputStore.removeChangeListener(InputActionConstants.SAFETY_NET_CHANGE, this._onInputChange);
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        var safetyNetEffectText;

        if(this.state.inputs.safetyNet > 0){
            var monthsOfSafetyNetEffect = 12;
            var overTime = [];
            for(var i=1; i<=monthsOfSafetyNetEffect; i++){
                overTime[i] = (this.state.inputs.safetyNet + (this.props.netIncome * i));
            }
            safetyNetEffectText = React.createElement("h2", {className: "well centerText"}, "After 6 Months Your Safety Net Would Be At $", overTime[6].toFixed(2));
        }

        return (
            React.createElement("div", null, 
                safetyNetEffectText
            )
        );
    }
});

module.exports = SafetyNetOverTimeComponent;

},{"../../../../constants/InputActionConstants":197,"../../../../stores/InputStore":202,"react":184}],193:[function(require,module,exports){
var React = require('react');

var InputActionConstants = require('../../../constants/InputActionConstants');
var InputStore = require('../../../stores/InputStore');
var Validators = require('../../../util/Validators');
var ScenarioInputDefinitions = require('../../../defines/ScenarioInputDefinitions');

var IncomeBreakdownComponent = require('./NetIncomeBasedComponents/IncomeBreakdownComponent');
var NetIncomeTextComponent = require('./NetIncomeBasedComponents/NetIncomeTextComponent');
var SafetyNetOverTimeComponent = require('./NetIncomeBasedComponents/SafetyNetOverTimeComponent');

var listenToActions = [
    InputActionConstants.MONTHLY_INCOME_CHANGE,
    InputActionConstants.MONTHLY_EXPENSES_CHANGE
];

var ResultListComponent = React.createClass({displayName: "ResultListComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        var self = this;
        listenToActions.forEach(function(actionTypeConstant){
            InputStore.addChangeListener(actionTypeConstant, self._onInputChange);
        });
    },
    componentWillUnmount: function() {
        var self = this;
        listenToActions.forEach(function(actionTypeConstant){
            InputStore.removeChangeListener(actionTypeConstant, self._onInputChange);
        });
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        var incomeBreakdownComponent;
        var netIncomeTextComponent;
        var safetyNetOverTimeComponent;

        if(Validators.validateRequiredInputsExist(ScenarioInputDefinitions.get(), this.state.inputs)){
            var netIncome = this.state.inputs.monthlyIncome - this.state.inputs.monthlyExpenses - this.props.monthlyCarCost;
            incomeBreakdownComponent = React.createElement(IncomeBreakdownComponent, {
                netIncome: netIncome, 
                monthlyIncome: this.state.inputs.monthlyIncome, 
                monthlyCarCost: this.props.monthlyCarCost, 
                monthlyExpenses: this.state.inputs.monthlyExpenses}
            );
            netIncomeTextComponent = React.createElement(NetIncomeTextComponent, {netIncome: netIncome});
            safetyNetOverTimeComponent = React.createElement(SafetyNetOverTimeComponent, {netIncome: netIncome});
        }
        return (
            React.createElement("div", null, 
                incomeBreakdownComponent, 
                netIncomeTextComponent, 
                safetyNetOverTimeComponent
            )
        );
    }
});

module.exports = ResultListComponent;
},{"../../../constants/InputActionConstants":197,"../../../defines/ScenarioInputDefinitions":199,"../../../stores/InputStore":202,"../../../util/Validators":204,"./NetIncomeBasedComponents/IncomeBreakdownComponent":190,"./NetIncomeBasedComponents/NetIncomeTextComponent":191,"./NetIncomeBasedComponents/SafetyNetOverTimeComponent":192,"react":184}],194:[function(require,module,exports){
var React = require('react');
var InputActionConstants = require('../../constants/InputActionConstants');
var InputStore = require('../../stores/InputStore');
var Validators = require('../../util/Validators');
var MonthlyCostInputDefinitions = require('../../defines/MonthlyCostInputDefinitions');
var Calculations = require('../../util/Calculations');
var NetIncomeBasedListComponent = require('./ResultComponents/NetIncomeBasedListComponent');

var ResultListComponent = React.createClass({displayName: "ResultListComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        InputStore.addChangeListener(InputActionConstants.MONTHLY_COST_INPUT_CHANGE, this._onInputChange);
    },
    componentWillUnmount: function() {
        InputStore.removeChangeListener(InputActionConstants.MONTHLY_COST_INPUT_CHANGE, this._onInputChange);
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        if(Validators.validateRequiredInputsExist(MonthlyCostInputDefinitions.get(), this.state.inputs)){
            var monthlyCarCost = Calculations.monthlyCost(
                this.state.inputs.vehiclePrice,
                this.state.inputs.downPayment,
                this.state.inputs.tradeIn,
                this.state.inputs.interestRate,
                this.state.inputs.salesTax,
                this.state.inputs.term
            );
            return (
                React.createElement("div", null, 
                    React.createElement("div", {id: "monthlyCost"}, 
                        React.createElement("h2", {className: "well centerText"}, "Car Payment $", monthlyCarCost, "/month")
                    ), 
                    React.createElement(NetIncomeBasedListComponent, {monthlyCarCost: monthlyCarCost})
                )
            );
        }
        return (
            React.createElement("div", null)
        );
    }
});

module.exports = ResultListComponent;
},{"../../constants/InputActionConstants":197,"../../defines/MonthlyCostInputDefinitions":198,"../../stores/InputStore":202,"../../util/Calculations":203,"../../util/Validators":204,"./ResultComponents/NetIncomeBasedListComponent":193,"react":184}],195:[function(require,module,exports){
var React = require('react');
var ReactCSSTransitionGroup = require('react/addons/CSSTransitionGroup');
var TitleDefinitions = require('../../defines/TitleDefinitions');
var titleIntervalTime = 10000;
var titleUpdateInterval;

// https://github.com/facebook/react/issues/1326
var InputComponent = React.createClass({displayName: "InputComponent",
    getInitialState: function(){
        var titles = TitleDefinitions.get();
        return {
            title: titles[Math.floor((Math.random() * (titles.length)))]
        };
    },
    componentDidMount: function(){
        var self = this;
        titleUpdateInterval = setInterval(function(){
            var titles = TitleDefinitions.get();
            self.setState({
                title: titles[Math.floor((Math.random() * (titles.length)))]
            });
        }, titleIntervalTime);
    },
    componentWillUnmount: function(){
        clearInterval(titleUpdateInterval);
    },
    render: function() {
        return (
            React.createElement("div", {className: "title"}, 
                React.createElement(ReactCSSTransitionGroup, {transitionName: "fadeIn", transitionAppear: true, transitionLeave: false}, 
                    React.createElement("div", {key: this.state.title}, 
                        React.createElement("h5", {key: "title", className: "centerText"}, this.state.title)
                    )
                )
            )
        );
    }
});

module.exports = InputComponent;
},{"../../defines/TitleDefinitions":200,"react":184,"react/addons/CSSTransitionGroup":10}],196:[function(require,module,exports){
module.exports = {
    MONTHLY_INCOME_DEFAULT: 0,
    MONTHLY_EXPENSES_DEFAULT: 0,
    SAFETY_NET_DEFAULT: 0,
    VEHICLE_PRICE_DEFAULT: undefined, //only required field for app to do basic func
    DOWN_PAYMENT_DEFAULT: 0,
    TRADE_IN_DEFAULT: 0,
    SALES_TAX_DEFAULT: 5.1,
    INTEREST_RATE_DEFAULT: 2.9,
    TERM_DEFAULT: 72
};

},{}],197:[function(require,module,exports){
var keyMirror = require('keymirror');

module.exports = keyMirror({
    MONTHLY_COST_INPUT_CHANGE: null,
    MONTHLY_INCOME_CHANGE: null,
    MONTHLY_EXPENSES_CHANGE: null,
    SAFETY_NET_CHANGE: null
});

},{"keymirror":6}],198:[function(require,module,exports){
module.exports.get = function(){
    var DefaultInputConstants = require('../constants/DefaultInputValueConstants');
    var InputActions = require('../constants/InputActionConstants');
    var Validators = require('../util/Validators');
    var inputs = [
        {
            id: 'vehiclePrice',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Vehicle Price',
            default: DefaultInputConstants.VEHICLE_PRICE_DEFAULT,
            required: DefaultInputConstants.VEHICLE_PRICE_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'downPayment',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Down Payment',
            default: DefaultInputConstants.DOWN_PAYMENT_DEFAULT,
            required: DefaultInputConstants.DOWN_PAYMENT_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'tradeIn',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Trade In',
            default: DefaultInputConstants.TRADE_IN_DEFAULT,
            required: DefaultInputConstants.TRADE_IN_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'salesTax',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Sales Tax',
            default: DefaultInputConstants.SALES_TAX_DEFAULT,
            required: DefaultInputConstants.SALES_TAX_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: '%',
            isValid: Validators.validatePercentInput,
            convert: function(e){ return parseFloat(e); }
        },
        {
            id: 'interestRate',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Interest Rate (APR)',
            default: DefaultInputConstants.INTEREST_RATE_DEFAULT,
            required: DefaultInputConstants.INTEREST_RATE_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: '%',
            isValid: Validators.validatePercentInput,
            convert: function(e){ return parseFloat(e); }
        },
        {
            id: 'term',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Term (Months)',
            default: DefaultInputConstants.TERM_DEFAULT,
            required: DefaultInputConstants.TERM_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: 'months',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        }
    ];
    return inputs;
};

},{"../constants/DefaultInputValueConstants":196,"../constants/InputActionConstants":197,"../util/Validators":204}],199:[function(require,module,exports){
module.exports.get = function(){
    var DefaultInputConstants = require('../constants/DefaultInputValueConstants');
    var InputActionConstants = require('../constants/InputActionConstants');
    var Validators = require('../util/Validators');
    var inputs = [
        {
            id: 'monthlyIncome',
            actionType: InputActionConstants.MONTHLY_INCOME_CHANGE,
            type: 'number',
            label: 'Monthly Income',
            default: DefaultInputConstants.MONTHLY_INCOME_DEFAULT,
            required: DefaultInputConstants.MONTHLY_INCOME_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'monthlyExpenses',
            actionType: InputActionConstants.MONTHLY_EXPENSES_CHANGE,
            type: 'number',
            label: 'Monthly Expenses',
            default: DefaultInputConstants.MONTHLY_EXPENSES_DEFAULT,
            required: DefaultInputConstants.MONTHLY_EXPENSES_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'safetyNet',
            actionType: InputActionConstants.SAFETY_NET_CHANGE,
            type: 'number',
            label: 'Savings / Safety Net',
            default: DefaultInputConstants.SAFETY_NET_DEFAULT,
            required: DefaultInputConstants.SAFETY_NET_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        }
    ];
    return inputs;
};

},{"../constants/DefaultInputValueConstants":196,"../constants/InputActionConstants":197,"../util/Validators":204}],200:[function(require,module,exports){
module.exports.get = function(){
    return [
        "It's Worth It. Sign. Trust Me.",
        "It's Only 5K Less Than A Mortgage.",
        "Can You Really Put A Price On Fun?",
        "Retirement Is Still 40 Years Out.",
        "When In Doubt Get A V8.",
        "Adrenaline Is Priceless.",
        "Life Is Too Short To Drive A Boring Car.",
        "Just Cut Back On Eating Out."
    ]
};
},{}],201:[function(require,module,exports){
var Dispatcher = require('flux').Dispatcher;

module.exports = new Dispatcher();

},{"flux":3}],202:[function(require,module,exports){
var AppDispatcher = require('../dispatcher/AppDispatcher');
var EventEmitter = require('events').EventEmitter;
var InputActionConstants = require('../constants/InputActionConstants');
var assign = require('object-assign');

var _inputs = {};

var InputStore = assign({}, EventEmitter.prototype, {

    get: function(key){
        return _inputs[key];
    },
    getAll: function() {
        return _inputs;
    },

    emitMonthlyCostInputChange: function() {
        this.emit(InputActionConstants.MONTHLY_COST_INPUT_CHANGE);
    },

    emitScenarioChange: function(scenarioActionTypeConstant) {
        this.emit(scenarioActionTypeConstant);
    },

    addChangeListener: function(TypeOfChange, callback) {
        this.on(TypeOfChange, callback);
    },
    removeChangeListener: function(TypeOfChange, callback) {
        this.removeListener(TypeOfChange, callback);
    }

});

AppDispatcher.register(function(action) {

    switch(action.actionType) {
        case InputActionConstants.MONTHLY_COST_INPUT_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitMonthlyCostInputChange();
            break;
        case InputActionConstants.MONTHLY_INCOME_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        case InputActionConstants.MONTHLY_EXPENSES_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        case InputActionConstants.SAFETY_NET_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        default:
        // no op
    }

});

module.exports = InputStore;

},{"../constants/InputActionConstants":197,"../dispatcher/AppDispatcher":201,"events":1,"object-assign":7}],203:[function(require,module,exports){
module.exports.monthlyCost = function(vehiclePrice, downPayment, tradeIn, interestRate, salesTax, term){
    var adjustedInterestRatePercent = interestRate * .01;
    var adjustedSalesTaxPercent = salesTax * .01; // 2.9 => .029
    var salesTaxAmount = vehiclePrice * adjustedSalesTaxPercent;
    var netCost = vehiclePrice + salesTaxAmount - downPayment - tradeIn;
    var rate = adjustedInterestRatePercent / 12;
    var rateCalc = (rate * Math.pow((1 + rate), term))/(Math.pow((1 + rate), term) - 1);
    return parseFloat((netCost * rateCalc).toFixed(2));
};

},{}],204:[function(require,module,exports){
/*
  undefined's are ok, defaults are set for inputs (and if no default, calc simply isn't made)
 */
module.exports.validateNumberInput = function(input){
    try{
        if(input === undefined){
            return true;
        }else{
            parseInt(input);
        }
        return true;
    }catch(e){
        return false;
    }
};
module.exports.validatePercentInput = function(percent){
    try{
        if(percent === undefined){
            return true;
        }else{
            return !isNaN(parseFloat(percent));
        }
    }catch(e){
        return false;
    }
};
module.exports.validateRequiredInputsExist = function(inputDefinitions, inputModels){
    var isValid = true;
    inputDefinitions.forEach(function(e){
        if(inputModels[e.id] === undefined){
            if(e.default !== undefined){
                inputModels[e.id] = e.default;
            }else{
                isValid = false;
            }
        }
    });
    return isValid;
};

},{}]},{},[186])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZmx1eC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9EaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9rZXltaXJyb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1oaWdoY2hhcnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2FkZG9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9hZGRvbnMvQ1NTVHJhbnNpdGlvbkdyb3VwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9BdXRvRm9jdXNNaXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTQ29yZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0NsaWVudFJlYWN0Um9vdEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0Rhbmdlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRDb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0xpbmtlZFN0YXRlTWl4aW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0xvY2FsRXZlbnRUcmFwTWl4aW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01DbGllbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUZvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlmcmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01JbWcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NSW5wdXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NT3B0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NU2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RnJhZ21lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEluc3RhbmNlSGFuZGxlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJc29tb3JwaGljLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdExpZmVDeWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RMaW5rLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE1vdW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RPd25lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQZXJmLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUcmFuc2ZlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSZWYuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Um9vdEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RTdGF0ZVNldHRlcnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VGVzdFV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkV2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RUcmFuc2l0aW9uR3JvdXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RXaXRoQWRkb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1NlcnZlclJlYWN0Um9vdEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9WaWV3cG9ydE1ldHJpY3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jYW1lbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2Nsb25lV2l0aFByb3BzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jb250YWluc05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jcmVhdGVGdWxsUGFnZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9lbXB0eU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9maW5kRE9NTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZmxhdHRlbkNoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9mb2N1c05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRUYXJnZXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldE1hcmt1cFdyYXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9oeXBoZW5hdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNUZXh0Tm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvam9pbkNsYXNzZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2tleU1pcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIva2V5T2YuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL21hcE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvcGVyZm9ybWFuY2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3NldElubmVySFRNTC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3NoYWxsb3dDb21wYXJlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaGFsbG93RXF1YWwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi90b0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi91cGRhdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvd2FybmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9yZWFjdC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxhY3Rpb25zXFxJbnB1dEFjdGlvbnMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcYXBwLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGNvbXBvbmVudHNcXElucHV0TGlzdENvbXBvbmVudFxcSW5wdXRDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcSW5wdXRMaXN0Q29tcG9uZW50XFxJbnB1dExpc3RDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcTWFpbkNvbXBvbmVudC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxSZXN1bHRMaXN0Q29tcG9uZW50XFxSZXN1bHRDb21wb25lbnRzXFxOZXRJbmNvbWVCYXNlZENvbXBvbmVudHNcXEluY29tZUJyZWFrZG93bkNvbXBvbmVudC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxSZXN1bHRMaXN0Q29tcG9uZW50XFxSZXN1bHRDb21wb25lbnRzXFxOZXRJbmNvbWVCYXNlZENvbXBvbmVudHNcXE5ldEluY29tZVRleHRDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcUmVzdWx0TGlzdENvbXBvbmVudFxcUmVzdWx0Q29tcG9uZW50c1xcTmV0SW5jb21lQmFzZWRDb21wb25lbnRzXFxTYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxSZXN1bHRMaXN0Q29tcG9uZW50XFxSZXN1bHRDb21wb25lbnRzXFxOZXRJbmNvbWVCYXNlZExpc3RDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcUmVzdWx0TGlzdENvbXBvbmVudFxcUmVzdWx0TGlzdENvbXBvbmVudC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxUaXRsZUNvbXBvbmVudFxcVGl0bGVDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29uc3RhbnRzXFxEZWZhdWx0SW5wdXRWYWx1ZUNvbnN0YW50cy5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb25zdGFudHNcXElucHV0QWN0aW9uQ29uc3RhbnRzLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGRlZmluZXNcXE1vbnRobHlDb3N0SW5wdXREZWZpbml0aW9ucy5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxkZWZpbmVzXFxTY2VuYXJpb0lucHV0RGVmaW5pdGlvbnMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcZGVmaW5lc1xcVGl0bGVEZWZpbml0aW9ucy5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxkaXNwYXRjaGVyXFxBcHBEaXNwYXRjaGVyLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXHN0b3Jlc1xcSW5wdXRTdG9yZS5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFx1dGlsXFxDYWxjdWxhdGlvbnMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcdXRpbFxcVmFsaWRhdG9ycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3lsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNweEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDellBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVEQTtBQUNBOztBQ0RBLElBQUksYUFBYSxHQUFHLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDOztBQUUzRCxJQUFJLFlBQVksR0FBRzs7SUFFZixNQUFNLEVBQUUsU0FBUyxLQUFLLEVBQUU7UUFDcEIsYUFBYSxDQUFDLFFBQVEsQ0FBQztZQUNuQixVQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVU7WUFDNUIsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO1lBQ3hCLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTtTQUMvQixDQUFDLENBQUM7QUFDWCxLQUFLOztBQUVMLENBQUMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFlBQVk7OztBQ2Q3QixJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLDRCQUE0QixDQUFDLENBQUM7O0FBRTFELEtBQUssQ0FBQyxNQUFNLENBQUMsb0JBQUMsYUFBYSxFQUFBLElBQUEsQ0FBRyxDQUFBLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7O0FDSC9ELElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsNEJBQTRCLENBQUMsQ0FBQzs7QUFFekQsSUFBSSxvQ0FBb0MsOEJBQUE7SUFDcEMsY0FBYyxFQUFFLFVBQVU7UUFDdEIsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUM1RCxHQUFHLEtBQUssS0FBSyxFQUFFLENBQUM7WUFDWixLQUFLLEdBQUcsU0FBUyxDQUFDO1NBQ3JCO1FBQ0QsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN6QixHQUFHLEtBQUssS0FBSyxTQUFTLENBQUM7Z0JBQ25CLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNyQztZQUNELFlBQVksQ0FBQyxNQUFNLENBQUM7Z0JBQ2hCLFVBQVUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVU7Z0JBQ2pDLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3ZCLFVBQVUsRUFBRSxLQUFLO2FBQ3BCLENBQUMsQ0FBQztTQUNOO0tBQ0o7SUFDRCxNQUFNLEVBQUUsV0FBVztRQUNmLElBQUksTUFBTSxFQUFFLEtBQUssQ0FBQztRQUNsQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUM7WUFDeEUsTUFBTSxHQUFHLG9CQUFBLE1BQUssRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsbUJBQW9CLENBQUEsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQWEsQ0FBQSxDQUFDO1NBQzFFLElBQUk7WUFDRCxLQUFLLEdBQUcsb0JBQUEsTUFBSyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxtQkFBb0IsQ0FBQSxFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBYSxDQUFBLENBQUM7U0FDekU7UUFDRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxXQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ3REO1lBQ0ksb0JBQUEsS0FBSSxFQUFBLElBQUMsRUFBQTtnQkFDRCxvQkFBQSxPQUFNLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFFLHFCQUFxQixHQUFHLFFBQVEsRUFBQyxDQUFDLE9BQUEsRUFBTyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBSSxDQUFBLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFjLENBQUEsRUFBQTtnQkFDdEcsb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxhQUFjLENBQUEsRUFBQTtvQkFDeEIsTUFBTSxFQUFDO29CQUNSLG9CQUFBLE9BQU0sRUFBQSxDQUFBO3dCQUNGLFNBQUEsRUFBUyxDQUFDLGNBQUEsRUFBYzt3QkFDeEIsRUFBQSxFQUFFLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUM7d0JBQ2xCLElBQUEsRUFBSSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFDO3dCQUN0QixJQUFBLEVBQUksQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBQzt3QkFDcEIsV0FBQSxFQUFXLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUM7d0JBQ2hDLFFBQUEsRUFBUSxDQUFFLElBQUksQ0FBQyxjQUFjLEVBQUM7d0JBQzlCLEdBQUEsRUFBRyxDQUFDLE9BQU8sQ0FBQTtvQkFDYixDQUFBLEVBQUE7b0JBQ0QsS0FBTTtnQkFDTCxDQUFBO1lBQ0osQ0FBQTtVQUNSO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLGNBQWM7OztBQ2pEL0IsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ2pELElBQUksMkJBQTJCLEdBQUcsT0FBTyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7QUFDdkYsSUFBSSx3QkFBd0IsR0FBRyxPQUFPLENBQUMsd0NBQXdDLENBQUMsQ0FBQzs7QUFFakYsSUFBSSxtQ0FBbUMsNkJBQUE7SUFDbkMsTUFBTSxFQUFFLFdBQVc7UUFDZixJQUFJLE1BQU0sR0FBRyx3QkFBd0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUM1QyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzFELElBQUksZUFBZSxDQUFDO1FBQ3BCLEdBQUcsTUFBTSxLQUFLLFNBQVMsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMxQyxlQUFlLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDdEM7b0JBQ0ksb0JBQUMsY0FBYyxFQUFBLENBQUE7d0JBQ1gsR0FBQSxFQUFHLENBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQzt3QkFDVixFQUFBLEVBQUUsQ0FBRSxDQUFDLENBQUMsRUFBRSxFQUFDO3dCQUNULFVBQUEsRUFBVSxDQUFFLENBQUMsQ0FBQyxVQUFVLEVBQUM7d0JBQ3pCLElBQUEsRUFBSSxDQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUM7d0JBQ2IsS0FBQSxFQUFLLENBQUUsQ0FBQyxDQUFDLEtBQUssRUFBQzt3QkFDZixPQUFBLEVBQU8sQ0FBRSxDQUFDLENBQUMsT0FBTyxFQUFDO3dCQUNuQixRQUFBLEVBQVEsQ0FBRSxDQUFDLENBQUMsUUFBUSxFQUFDO3dCQUNyQixnQkFBQSxFQUFnQixDQUFFLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLEVBQUM7d0JBQzNDLEtBQUEsRUFBSyxDQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUM7d0JBQ2YsT0FBQSxFQUFPLENBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBQzt3QkFDbkIsT0FBQSxFQUFPLENBQUUsQ0FBQyxDQUFDLE9BQVEsQ0FBQTt3QkFDakIsQ0FBQTtrQkFDUjthQUNMLENBQUMsQ0FBQztTQUNOO1FBQ0Q7WUFDSSxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLFdBQVksQ0FBQSxFQUFBO2dCQUN0QixlQUFnQjtZQUNmLENBQUE7VUFDUjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxhQUFhOzs7QUNyQzlCLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsaUNBQWlDLENBQUMsQ0FBQztBQUNoRSxJQUFJLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO0FBQzVFLElBQUksbUJBQW1CLEdBQUcsT0FBTyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7O0FBRS9FLElBQUksbUNBQW1DLDZCQUFBO0lBQ25DLE1BQU0sRUFBRSxXQUFXO1FBQ2Y7WUFDSSxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGVBQWdCLENBQUEsRUFBQTtnQkFDM0Isb0JBQUMsY0FBYyxFQUFBLElBQUEsQ0FBRyxDQUFBLEVBQUE7Z0JBQ2xCLG9CQUFDLGtCQUFrQixFQUFBLElBQUEsQ0FBRyxDQUFBLEVBQUE7Z0JBQ3RCLG9CQUFDLG1CQUFtQixFQUFBLElBQUEsQ0FBRyxDQUFBO1lBQ3JCLENBQUE7VUFDUjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxhQUFhLENBQUM7O0FDakIvQixJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7O0FBRTdDLElBQUksOENBQThDLHdDQUFBO0lBQzlDLE1BQU0sRUFBRSxXQUFXO0FBQ3ZCLFFBQVEsSUFBSSxvQkFBb0IsQ0FBQzs7QUFFakMsUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsRUFBRTs7WUFFN0IsSUFBSSxVQUFVLEdBQUc7Z0JBQ2I7b0JBQ0ksS0FBSyxFQUFFLFdBQVc7b0JBQ2xCLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxJQUFJLEdBQUc7aUJBQ2pFO2dCQUNEO29CQUNJLEtBQUssRUFBRSxVQUFVO29CQUNqQixLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsSUFBSSxHQUFHO2lCQUN2RTtnQkFDRDtvQkFDSSxLQUFLLEVBQUUsa0JBQWtCO29CQUN6QixLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsSUFBSSxHQUFHO2lCQUN0RTtBQUNqQixhQUFhLENBQUM7O1lBRUYsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO1lBQ2QsVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDNUIsSUFBSSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRTtvQkFDYixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDakM7QUFDakIsYUFBYSxDQUFDLENBQUM7O1lBRUgsSUFBSSxNQUFNLEdBQUc7Z0JBQ1QsS0FBSyxFQUFFO29CQUNILG1CQUFtQixFQUFFLElBQUk7b0JBQ3pCLGVBQWUsRUFBRSxDQUFDO29CQUNsQixVQUFVLEVBQUUsS0FBSztpQkFDcEI7Z0JBQ0QsS0FBSyxFQUFFO29CQUNILElBQUksRUFBRSxxQkFBcUI7b0JBQzNCLEtBQUssRUFBRSxRQUFRO29CQUNmLGFBQWEsRUFBRSxRQUFRO29CQUN2QixDQUFDLEVBQUUsRUFBRTtpQkFDUjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsV0FBVyxFQUFFLCtDQUErQztpQkFDL0Q7Z0JBQ0QsV0FBVyxFQUFFO29CQUNULEdBQUcsRUFBRTt3QkFDRCxVQUFVLEVBQUU7NEJBQ1IsT0FBTyxFQUFFLElBQUk7NEJBQ2IsUUFBUSxFQUFFLENBQUMsRUFBRTs0QkFDYixLQUFLLEVBQUU7Z0NBQ0gsVUFBVSxFQUFFLE1BQU07Z0NBQ2xCLEtBQUssRUFBRSxPQUFPO2dDQUNkLFVBQVUsRUFBRSxtQkFBbUI7NkJBQ2xDO3lCQUNKO3dCQUNELFVBQVUsRUFBRSxDQUFDLEVBQUU7d0JBQ2YsUUFBUSxFQUFFLEVBQUU7d0JBQ1osTUFBTSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQztxQkFDekI7aUJBQ0o7Z0JBQ0QsTUFBTSxFQUFFLENBQUM7b0JBQ0wsSUFBSSxFQUFFLEtBQUs7b0JBQ1gsSUFBSSxFQUFFLGtCQUFrQjtvQkFDeEIsU0FBUyxFQUFFLEtBQUs7b0JBQ2hCLElBQUksRUFBRSxJQUFJO2lCQUNiLENBQUM7YUFDTCxDQUFDO1lBQ0Ysb0JBQW9CLEdBQUcsb0JBQUMsVUFBVSxFQUFBLENBQUEsQ0FBQyxNQUFBLEVBQU0sR0FBSSxNQUFRLENBQWEsQ0FBQSxDQUFDO1NBQ3RFO1FBQ0Q7WUFDSSxvQkFBQSxLQUFJLEVBQUEsSUFBQyxFQUFBO2dCQUNBLG9CQUFxQjtZQUNwQixDQUFBO1VBQ1I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsd0JBQXdCLENBQUM7O0FDL0UxQyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRTdCLElBQUksNENBQTRDLHNDQUFBO0lBQzVDLE1BQU0sRUFBRSxXQUFXO1FBQ2Y7WUFDSSxvQkFBQSxLQUFJLEVBQUEsSUFBQyxFQUFBO2dCQUNELG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsaUJBQWtCLENBQUEsRUFBQSxzREFBQSxFQUFxRCxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFPLENBQUEsRUFBQSxHQUFBO0FBQUEsWUFDeEgsQ0FBQTtVQUNSO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLHNCQUFzQjs7O0FDWnZDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0FBQ2pGLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDOztBQUUxRCxJQUFJLGdEQUFnRCwwQ0FBQTtJQUNoRCxjQUFjLEVBQUUsV0FBVztRQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ1YsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLEVBQUU7U0FDOUIsQ0FBQyxDQUFDO0tBQ047SUFDRCxpQkFBaUIsRUFBRSxXQUFXO1FBQzFCLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxvQkFBb0IsQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDN0Y7SUFDRCxvQkFBb0IsRUFBRSxXQUFXO1FBQzdCLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxvQkFBb0IsQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDaEc7SUFDRCxlQUFlLEVBQUUsV0FBVztRQUN4QixPQUFPO1lBQ0gsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLEVBQUU7U0FDOUIsQ0FBQztLQUNMO0lBQ0QsTUFBTSxFQUFFLFdBQVc7QUFDdkIsUUFBUSxJQUFJLG1CQUFtQixDQUFDOztRQUV4QixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7WUFDL0IsSUFBSSx1QkFBdUIsR0FBRyxFQUFFLENBQUM7WUFDakMsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO1lBQ2xCLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSx1QkFBdUIsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDekMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzVFO1lBQ0QsbUJBQW1CLEdBQUcsb0JBQUEsSUFBRyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxpQkFBa0IsQ0FBQSxFQUFBLDhDQUFBLEVBQTZDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFPLENBQUEsQ0FBQztBQUM1SSxTQUFTOztRQUVEO1lBQ0ksb0JBQUEsS0FBSSxFQUFBLElBQUMsRUFBQTtnQkFDQSxtQkFBb0I7WUFDbkIsQ0FBQTtVQUNSO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLDBCQUEwQjs7O0FDekMzQyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRTdCLElBQUksb0JBQW9CLEdBQUcsT0FBTyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7QUFDOUUsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLDRCQUE0QixDQUFDLENBQUM7QUFDdkQsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLDBCQUEwQixDQUFDLENBQUM7QUFDckQsSUFBSSx3QkFBd0IsR0FBRyxPQUFPLENBQUMsMkNBQTJDLENBQUMsQ0FBQzs7QUFFcEYsSUFBSSx3QkFBd0IsR0FBRyxPQUFPLENBQUMscURBQXFELENBQUMsQ0FBQztBQUM5RixJQUFJLHNCQUFzQixHQUFHLE9BQU8sQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO0FBQzFGLElBQUksMEJBQTBCLEdBQUcsT0FBTyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7O0FBRWxHLElBQUksZUFBZSxHQUFHO0lBQ2xCLG9CQUFvQixDQUFDLHFCQUFxQjtJQUMxQyxvQkFBb0IsQ0FBQyx1QkFBdUI7QUFDaEQsQ0FBQyxDQUFDOztBQUVGLElBQUkseUNBQXlDLG1DQUFBO0lBQ3pDLGNBQWMsRUFBRSxXQUFXO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDVixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sRUFBRTtTQUM5QixDQUFDLENBQUM7S0FDTjtJQUNELGlCQUFpQixFQUFFLFdBQVc7UUFDMUIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLGVBQWUsQ0FBQyxPQUFPLENBQUMsU0FBUyxrQkFBa0IsQ0FBQztZQUNoRCxVQUFVLENBQUMsaUJBQWlCLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ3pFLENBQUMsQ0FBQztLQUNOO0lBQ0Qsb0JBQW9CLEVBQUUsV0FBVztRQUM3QixJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFDaEIsZUFBZSxDQUFDLE9BQU8sQ0FBQyxTQUFTLGtCQUFrQixDQUFDO1lBQ2hELFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxrQkFBa0IsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDNUUsQ0FBQyxDQUFDO0tBQ047SUFDRCxlQUFlLEVBQUUsV0FBVztRQUN4QixPQUFPO1lBQ0gsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNLEVBQUU7U0FDOUIsQ0FBQztLQUNMO0lBQ0QsTUFBTSxFQUFFLFdBQVc7UUFDZixJQUFJLHdCQUF3QixDQUFDO1FBQzdCLElBQUksc0JBQXNCLENBQUM7QUFDbkMsUUFBUSxJQUFJLDBCQUEwQixDQUFDOztRQUUvQixHQUFHLFVBQVUsQ0FBQywyQkFBMkIsQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3pGLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUM7WUFDaEgsd0JBQXdCLEdBQUcsb0JBQUMsd0JBQXdCLEVBQUEsQ0FBQTtnQkFDaEQsU0FBQSxFQUFTLENBQUUsU0FBUyxFQUFDO2dCQUNyQixhQUFBLEVBQWEsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUM7Z0JBQy9DLGNBQUEsRUFBYyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFDO2dCQUMxQyxlQUFBLEVBQWUsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxlQUFnQixDQUFBO1lBQ3JELENBQUEsQ0FBQztZQUNILHNCQUFzQixHQUFHLG9CQUFDLHNCQUFzQixFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBRSxTQUFVLENBQUEsQ0FBRyxDQUFBLENBQUM7WUFDMUUsMEJBQTBCLEdBQUcsb0JBQUMsMEJBQTBCLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFFLFNBQVUsQ0FBQSxDQUFHLENBQUEsQ0FBQztTQUNyRjtRQUNEO1lBQ0ksb0JBQUEsS0FBSSxFQUFBLElBQUMsRUFBQTtnQkFDQSx3QkFBd0IsRUFBQztnQkFDekIsc0JBQXNCLEVBQUM7Z0JBQ3ZCLDBCQUEyQjtZQUMxQixDQUFBO1VBQ1I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsbUJBQW1CLENBQUM7O0FDakVyQyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsSUFBSSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsc0NBQXNDLENBQUMsQ0FBQztBQUMzRSxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUNwRCxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUNsRCxJQUFJLDJCQUEyQixHQUFHLE9BQU8sQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO0FBQ3ZGLElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBQ3RELElBQUksMkJBQTJCLEdBQUcsT0FBTyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7O0FBRTVGLElBQUkseUNBQXlDLG1DQUFBO0lBQ3pDLGNBQWMsRUFBRSxXQUFXO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDVixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sRUFBRTtTQUM5QixDQUFDLENBQUM7S0FDTjtJQUNELGlCQUFpQixFQUFFLFdBQVc7UUFDMUIsVUFBVSxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixDQUFDLHlCQUF5QixFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUNyRztJQUNELG9CQUFvQixFQUFFLFdBQVc7UUFDN0IsVUFBVSxDQUFDLG9CQUFvQixDQUFDLG9CQUFvQixDQUFDLHlCQUF5QixFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUN4RztJQUNELGVBQWUsRUFBRSxXQUFXO1FBQ3hCLE9BQU87WUFDSCxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sRUFBRTtTQUM5QixDQUFDO0tBQ0w7SUFDRCxNQUFNLEVBQUUsV0FBVztRQUNmLEdBQUcsVUFBVSxDQUFDLDJCQUEyQixDQUFDLDJCQUEyQixDQUFDLEdBQUcsRUFBRSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDNUYsSUFBSSxjQUFjLEdBQUcsWUFBWSxDQUFDLFdBQVc7Z0JBQ3pDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFlBQVk7Z0JBQzlCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVc7Z0JBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU87Z0JBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFlBQVk7Z0JBQzlCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVE7Z0JBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUk7YUFDekIsQ0FBQztZQUNGO2dCQUNJLG9CQUFBLEtBQUksRUFBQSxJQUFDLEVBQUE7b0JBQ0Qsb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxFQUFBLEVBQUUsQ0FBQyxhQUFjLENBQUEsRUFBQTt3QkFDbEIsb0JBQUEsSUFBRyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxpQkFBa0IsQ0FBQSxFQUFBLGVBQUEsRUFBYyxjQUFjLEVBQUMsUUFBVyxDQUFBO29CQUN0RSxDQUFBLEVBQUE7b0JBQ04sb0JBQUMsMkJBQTJCLEVBQUEsQ0FBQSxDQUFDLGNBQUEsRUFBYyxDQUFFLGNBQWUsQ0FBQSxDQUFHLENBQUE7Z0JBQzdELENBQUE7Y0FDUjtTQUNMO1FBQ0Q7WUFDSSxvQkFBQSxLQUFJLEVBQUEsSUFBTyxDQUFBO1VBQ2I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsbUJBQW1CLENBQUM7O0FDbERyQyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsSUFBSSx1QkFBdUIsR0FBRyxPQUFPLENBQUMsaUNBQWlDLENBQUMsQ0FBQztBQUN6RSxJQUFJLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQ2pFLElBQUksaUJBQWlCLEdBQUcsS0FBSyxDQUFDO0FBQzlCLElBQUksbUJBQW1CLENBQUM7O0FBRXhCLGdEQUFnRDtBQUNoRCxJQUFJLG9DQUFvQyw4QkFBQTtJQUNwQyxlQUFlLEVBQUUsVUFBVTtRQUN2QixJQUFJLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNwQyxPQUFPO1lBQ0gsS0FBSyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztTQUMvRCxDQUFDO0tBQ0w7SUFDRCxpQkFBaUIsRUFBRSxVQUFVO1FBQ3pCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUNoQixtQkFBbUIsR0FBRyxXQUFXLENBQUMsVUFBVTtZQUN4QyxJQUFJLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUNWLEtBQUssRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7YUFDL0QsQ0FBQyxDQUFDO1NBQ04sRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0tBQ3pCO0lBQ0Qsb0JBQW9CLEVBQUUsVUFBVTtRQUM1QixhQUFhLENBQUMsbUJBQW1CLENBQUMsQ0FBQztLQUN0QztJQUNELE1BQU0sRUFBRSxXQUFXO1FBQ2Y7WUFDSSxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLE9BQVEsQ0FBQSxFQUFBO2dCQUNuQixvQkFBQyx1QkFBdUIsRUFBQSxDQUFBLENBQUMsY0FBQSxFQUFjLENBQUMsUUFBQSxFQUFRLENBQUMsZ0JBQUEsRUFBZ0IsQ0FBRSxJQUFJLEVBQUMsQ0FBQyxlQUFBLEVBQWUsQ0FBRSxLQUFPLENBQUEsRUFBQTtvQkFDN0Ysb0JBQUEsS0FBSSxFQUFBLENBQUEsQ0FBQyxHQUFBLEVBQUcsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQU8sQ0FBQSxFQUFBO3dCQUN4QixvQkFBQSxJQUFHLEVBQUEsQ0FBQSxDQUFDLEdBQUEsRUFBRyxDQUFDLE9BQUEsRUFBTyxDQUFDLFNBQUEsRUFBUyxDQUFDLFlBQWEsQ0FBQSxFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBVyxDQUFBO29CQUM1RCxDQUFBO2dCQUNnQixDQUFBO1lBQ3hCLENBQUE7VUFDUjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxjQUFjLENBQUM7O0FDdkNoQyxNQUFNLENBQUMsT0FBTyxHQUFHO0lBQ2Isc0JBQXNCLEVBQUUsQ0FBQztJQUN6Qix3QkFBd0IsRUFBRSxDQUFDO0lBQzNCLGtCQUFrQixFQUFFLENBQUM7SUFDckIscUJBQXFCLEVBQUUsU0FBUztJQUNoQyxvQkFBb0IsRUFBRSxDQUFDO0lBQ3ZCLGdCQUFnQixFQUFFLENBQUM7SUFDbkIsaUJBQWlCLEVBQUUsR0FBRztJQUN0QixxQkFBcUIsRUFBRSxHQUFHO0lBQzFCLFlBQVksRUFBRSxFQUFFO0NBQ25COzs7QUNWRCxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7O0FBRXJDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO0lBQ3ZCLHlCQUF5QixFQUFFLElBQUk7SUFDL0IscUJBQXFCLEVBQUUsSUFBSTtJQUMzQix1QkFBdUIsRUFBRSxJQUFJO0lBQzdCLGlCQUFpQixFQUFFLElBQUk7Q0FDMUIsQ0FBQzs7O0FDUEYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsVUFBVTtJQUMzQixJQUFJLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO0lBQy9FLElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0lBQ2hFLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQy9DLElBQUksTUFBTSxHQUFHO1FBQ1Q7WUFDSSxFQUFFLEVBQUUsY0FBYztZQUNsQixVQUFVLEVBQUUsWUFBWSxDQUFDLHlCQUF5QjtZQUNsRCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxlQUFlO1lBQ3RCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxxQkFBcUI7WUFDcEQsUUFBUSxFQUFFLHFCQUFxQixDQUFDLHFCQUFxQixLQUFLLFNBQVM7WUFDbkUsS0FBSyxFQUFFLEdBQUc7WUFDVixPQUFPLEVBQUUsVUFBVSxDQUFDLG1CQUFtQjtZQUN2QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQzlDO1FBQ0Q7WUFDSSxFQUFFLEVBQUUsYUFBYTtZQUNqQixVQUFVLEVBQUUsWUFBWSxDQUFDLHlCQUF5QjtZQUNsRCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxjQUFjO1lBQ3JCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxvQkFBb0I7WUFDbkQsUUFBUSxFQUFFLHFCQUFxQixDQUFDLG9CQUFvQixLQUFLLFNBQVM7WUFDbEUsS0FBSyxFQUFFLEdBQUc7WUFDVixPQUFPLEVBQUUsVUFBVSxDQUFDLG1CQUFtQjtZQUN2QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQzlDO1FBQ0Q7WUFDSSxFQUFFLEVBQUUsU0FBUztZQUNiLFVBQVUsRUFBRSxZQUFZLENBQUMseUJBQXlCO1lBQ2xELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLFVBQVU7WUFDakIsT0FBTyxFQUFFLHFCQUFxQixDQUFDLGdCQUFnQjtZQUMvQyxRQUFRLEVBQUUscUJBQXFCLENBQUMsZ0JBQWdCLEtBQUssU0FBUztZQUM5RCxLQUFLLEVBQUUsR0FBRztZQUNWLE9BQU8sRUFBRSxVQUFVLENBQUMsbUJBQW1CO1lBQ3ZDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDOUM7UUFDRDtZQUNJLEVBQUUsRUFBRSxVQUFVO1lBQ2QsVUFBVSxFQUFFLFlBQVksQ0FBQyx5QkFBeUI7WUFDbEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsV0FBVztZQUNsQixPQUFPLEVBQUUscUJBQXFCLENBQUMsaUJBQWlCO1lBQ2hELFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxpQkFBaUIsS0FBSyxTQUFTO1lBQy9ELGdCQUFnQixFQUFFLEtBQUs7WUFDdkIsS0FBSyxFQUFFLEdBQUc7WUFDVixPQUFPLEVBQUUsVUFBVSxDQUFDLG9CQUFvQjtZQUN4QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQ2hEO1FBQ0Q7WUFDSSxFQUFFLEVBQUUsY0FBYztZQUNsQixVQUFVLEVBQUUsWUFBWSxDQUFDLHlCQUF5QjtZQUNsRCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxxQkFBcUI7WUFDNUIsT0FBTyxFQUFFLHFCQUFxQixDQUFDLHFCQUFxQjtZQUNwRCxRQUFRLEVBQUUscUJBQXFCLENBQUMscUJBQXFCLEtBQUssU0FBUztZQUNuRSxnQkFBZ0IsRUFBRSxLQUFLO1lBQ3ZCLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxvQkFBb0I7WUFDeEMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUNoRDtRQUNEO1lBQ0ksRUFBRSxFQUFFLE1BQU07WUFDVixVQUFVLEVBQUUsWUFBWSxDQUFDLHlCQUF5QjtZQUNsRCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxlQUFlO1lBQ3RCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxZQUFZO1lBQzNDLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxZQUFZLEtBQUssU0FBUztZQUMxRCxnQkFBZ0IsRUFBRSxLQUFLO1lBQ3ZCLEtBQUssRUFBRSxRQUFRO1lBQ2YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxtQkFBbUI7WUFDdkMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUM5QztLQUNKLENBQUM7SUFDRixPQUFPLE1BQU0sQ0FBQztDQUNqQjs7O0FDNUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLFVBQVU7SUFDM0IsSUFBSSxxQkFBcUIsR0FBRyxPQUFPLENBQUMseUNBQXlDLENBQUMsQ0FBQztJQUMvRSxJQUFJLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0lBQ3hFLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQy9DLElBQUksTUFBTSxHQUFHO1FBQ1Q7WUFDSSxFQUFFLEVBQUUsZUFBZTtZQUNuQixVQUFVLEVBQUUsb0JBQW9CLENBQUMscUJBQXFCO1lBQ3RELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLGdCQUFnQjtZQUN2QixPQUFPLEVBQUUscUJBQXFCLENBQUMsc0JBQXNCO1lBQ3JELFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxzQkFBc0IsS0FBSyxTQUFTO1lBQ3BFLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxtQkFBbUI7WUFDdkMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUM5QztRQUNEO1lBQ0ksRUFBRSxFQUFFLGlCQUFpQjtZQUNyQixVQUFVLEVBQUUsb0JBQW9CLENBQUMsdUJBQXVCO1lBQ3hELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLGtCQUFrQjtZQUN6QixPQUFPLEVBQUUscUJBQXFCLENBQUMsd0JBQXdCO1lBQ3ZELFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyx3QkFBd0IsS0FBSyxTQUFTO1lBQ3RFLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxtQkFBbUI7WUFDdkMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUM5QztRQUNEO1lBQ0ksRUFBRSxFQUFFLFdBQVc7WUFDZixVQUFVLEVBQUUsb0JBQW9CLENBQUMsaUJBQWlCO1lBQ2xELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLHNCQUFzQjtZQUM3QixPQUFPLEVBQUUscUJBQXFCLENBQUMsa0JBQWtCO1lBQ2pELFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxrQkFBa0IsS0FBSyxTQUFTO1lBQ2hFLEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxtQkFBbUI7WUFDdkMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUM5QztLQUNKLENBQUM7SUFDRixPQUFPLE1BQU0sQ0FBQztDQUNqQjs7O0FDeENELE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLFVBQVU7SUFDM0IsT0FBTztRQUNILGdDQUFnQztRQUNoQyxvQ0FBb0M7UUFDcEMsb0NBQW9DO1FBQ3BDLG1DQUFtQztRQUNuQyx5QkFBeUI7UUFDekIsMEJBQTBCO1FBQzFCLDBDQUEwQztRQUMxQyw4QkFBOEI7S0FDakM7Q0FDSixDQUFDOztBQ1hGLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxVQUFVLENBQUM7O0FBRTVDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxVQUFVLEVBQUU7OztBQ0ZqQyxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsNkJBQTZCLENBQUMsQ0FBQztBQUMzRCxJQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDO0FBQ2xELElBQUksb0JBQW9CLEdBQUcsT0FBTyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7QUFDeEUsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDOztBQUV0QyxJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7O0FBRWpCLElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLFNBQVMsRUFBRTs7SUFFaEQsR0FBRyxFQUFFLFNBQVMsR0FBRyxDQUFDO1FBQ2QsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDdkI7SUFDRCxNQUFNLEVBQUUsV0FBVztRQUNmLE9BQU8sT0FBTyxDQUFDO0FBQ3ZCLEtBQUs7O0lBRUQsMEJBQTBCLEVBQUUsV0FBVztRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFDbEUsS0FBSzs7SUFFRCxrQkFBa0IsRUFBRSxTQUFTLDBCQUEwQixFQUFFO1FBQ3JELElBQUksQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUM5QyxLQUFLOztJQUVELGlCQUFpQixFQUFFLFNBQVMsWUFBWSxFQUFFLFFBQVEsRUFBRTtRQUNoRCxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxRQUFRLENBQUMsQ0FBQztLQUNuQztJQUNELG9CQUFvQixFQUFFLFNBQVMsWUFBWSxFQUFFLFFBQVEsRUFBRTtRQUNuRCxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxRQUFRLENBQUMsQ0FBQztBQUNwRCxLQUFLOztBQUVMLENBQUMsQ0FBQyxDQUFDOztBQUVILGFBQWEsQ0FBQyxRQUFRLENBQUMsU0FBUyxNQUFNLEVBQUU7O0lBRXBDLE9BQU8sTUFBTSxDQUFDLFVBQVU7UUFDcEIsS0FBSyxvQkFBb0IsQ0FBQyx5QkFBeUI7WUFDL0MsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1lBQzdDLFVBQVUsQ0FBQywwQkFBMEIsRUFBRSxDQUFDO1lBQ3hDLE1BQU07UUFDVixLQUFLLG9CQUFvQixDQUFDLHFCQUFxQjtZQUMzQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7WUFDN0MsVUFBVSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNqRCxNQUFNO1FBQ1YsS0FBSyxvQkFBb0IsQ0FBQyx1QkFBdUI7WUFDN0MsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1lBQzdDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDakQsTUFBTTtRQUNWLEtBQUssb0JBQW9CLENBQUMsaUJBQWlCO1lBQ3ZDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztZQUM3QyxVQUFVLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2pELE1BQU07QUFDbEIsUUFBUSxRQUFROztBQUVoQixLQUFLOztBQUVMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBVTs7O0FDMUQzQixNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxTQUFTLFlBQVksRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDO0lBQ25HLElBQUksMkJBQTJCLEdBQUcsWUFBWSxHQUFHLEdBQUcsQ0FBQztJQUNyRCxJQUFJLHVCQUF1QixHQUFHLFFBQVEsR0FBRyxHQUFHLENBQUM7SUFDN0MsSUFBSSxjQUFjLEdBQUcsWUFBWSxHQUFHLHVCQUF1QixDQUFDO0lBQzVELElBQUksT0FBTyxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsV0FBVyxHQUFHLE9BQU8sQ0FBQztJQUNwRSxJQUFJLElBQUksR0FBRywyQkFBMkIsR0FBRyxFQUFFLENBQUM7SUFDNUMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNwRixPQUFPLFVBQVUsQ0FBQyxDQUFDLE9BQU8sR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDdEQ7OztBQ1JEOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsR0FBRyxTQUFTLEtBQUssQ0FBQztJQUNoRCxHQUFHO1FBQ0MsR0FBRyxLQUFLLEtBQUssU0FBUyxDQUFDO1lBQ25CLE9BQU8sSUFBSSxDQUFDO1NBQ2YsSUFBSTtZQUNELFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNuQjtRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2YsTUFBTSxDQUFDLENBQUM7UUFDTCxPQUFPLEtBQUssQ0FBQztLQUNoQjtDQUNKLENBQUM7QUFDRixNQUFNLENBQUMsT0FBTyxDQUFDLG9CQUFvQixHQUFHLFNBQVMsT0FBTyxDQUFDO0lBQ25ELEdBQUc7UUFDQyxHQUFHLE9BQU8sS0FBSyxTQUFTLENBQUM7WUFDckIsT0FBTyxJQUFJLENBQUM7U0FDZixJQUFJO1lBQ0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztTQUN0QztLQUNKLE1BQU0sQ0FBQyxDQUFDO1FBQ0wsT0FBTyxLQUFLLENBQUM7S0FDaEI7Q0FDSixDQUFDO0FBQ0YsTUFBTSxDQUFDLE9BQU8sQ0FBQywyQkFBMkIsR0FBRyxTQUFTLGdCQUFnQixFQUFFLFdBQVcsQ0FBQztJQUNoRixJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUM7SUFDbkIsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2hDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxTQUFTLENBQUM7WUFDL0IsR0FBRyxDQUFDLENBQUMsT0FBTyxLQUFLLFNBQVMsQ0FBQztnQkFDdkIsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDO2FBQ2pDLElBQUk7Z0JBQ0QsT0FBTyxHQUFHLEtBQUssQ0FBQzthQUNuQjtTQUNKO0tBQ0osQ0FBQyxDQUFDO0lBQ0gsT0FBTyxPQUFPLENBQUM7Q0FDbEIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vbGliL0Rpc3BhdGNoZXInKVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEaXNwYXRjaGVyXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxudmFyIF9sYXN0SUQgPSAxO1xudmFyIF9wcmVmaXggPSAnSURfJztcblxuLyoqXG4gKiBEaXNwYXRjaGVyIGlzIHVzZWQgdG8gYnJvYWRjYXN0IHBheWxvYWRzIHRvIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLiBUaGlzIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSBnZW5lcmljIHB1Yi1zdWIgc3lzdGVtcyBpbiB0d28gd2F5czpcbiAqXG4gKiAgIDEpIENhbGxiYWNrcyBhcmUgbm90IHN1YnNjcmliZWQgdG8gcGFydGljdWxhciBldmVudHMuIEV2ZXJ5IHBheWxvYWQgaXNcbiAqICAgICAgZGlzcGF0Y2hlZCB0byBldmVyeSByZWdpc3RlcmVkIGNhbGxiYWNrLlxuICogICAyKSBDYWxsYmFja3MgY2FuIGJlIGRlZmVycmVkIGluIHdob2xlIG9yIHBhcnQgdW50aWwgb3RoZXIgY2FsbGJhY2tzIGhhdmVcbiAqICAgICAgYmVlbiBleGVjdXRlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgY29uc2lkZXIgdGhpcyBoeXBvdGhldGljYWwgZmxpZ2h0IGRlc3RpbmF0aW9uIGZvcm0sIHdoaWNoXG4gKiBzZWxlY3RzIGEgZGVmYXVsdCBjaXR5IHdoZW4gYSBjb3VudHJ5IGlzIHNlbGVjdGVkOlxuICpcbiAqICAgdmFyIGZsaWdodERpc3BhdGNoZXIgPSBuZXcgRGlzcGF0Y2hlcigpO1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY291bnRyeSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ291bnRyeVN0b3JlID0ge2NvdW50cnk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hpY2ggY2l0eSBpcyBzZWxlY3RlZFxuICogICB2YXIgQ2l0eVN0b3JlID0ge2NpdHk6IG51bGx9O1xuICpcbiAqICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGJhc2UgZmxpZ2h0IHByaWNlIG9mIHRoZSBzZWxlY3RlZCBjaXR5XG4gKiAgIHZhciBGbGlnaHRQcmljZVN0b3JlID0ge3ByaWNlOiBudWxsfVxuICpcbiAqIFdoZW4gYSB1c2VyIGNoYW5nZXMgdGhlIHNlbGVjdGVkIGNpdHksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NpdHktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENpdHk6ICdwYXJpcydcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGBDaXR5U3RvcmVgOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NpdHktdXBkYXRlJykge1xuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBwYXlsb2FkLnNlbGVjdGVkQ2l0eTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGNvdW50cnksIHdlIGRpc3BhdGNoIHRoZSBwYXlsb2FkOlxuICpcbiAqICAgZmxpZ2h0RGlzcGF0Y2hlci5kaXNwYXRjaCh7XG4gKiAgICAgYWN0aW9uVHlwZTogJ2NvdW50cnktdXBkYXRlJyxcbiAqICAgICBzZWxlY3RlZENvdW50cnk6ICdhdXN0cmFsaWEnXG4gKiAgIH0pO1xuICpcbiAqIFRoaXMgcGF5bG9hZCBpcyBkaWdlc3RlZCBieSBib3RoIHN0b3JlczpcbiAqXG4gKiAgICBDb3VudHJ5U3RvcmUuZGlzcGF0Y2hUb2tlbiA9IGZsaWdodERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24ocGF5bG9hZCkge1xuICogICAgIGlmIChwYXlsb2FkLmFjdGlvblR5cGUgPT09ICdjb3VudHJ5LXVwZGF0ZScpIHtcbiAqICAgICAgIENvdW50cnlTdG9yZS5jb3VudHJ5ID0gcGF5bG9hZC5zZWxlY3RlZENvdW50cnk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBXaGVuIHRoZSBjYWxsYmFjayB0byB1cGRhdGUgYENvdW50cnlTdG9yZWAgaXMgcmVnaXN0ZXJlZCwgd2Ugc2F2ZSBhIHJlZmVyZW5jZVxuICogdG8gdGhlIHJldHVybmVkIHRva2VuLiBVc2luZyB0aGlzIHRva2VuIHdpdGggYHdhaXRGb3IoKWAsIHdlIGNhbiBndWFyYW50ZWVcbiAqIHRoYXQgYENvdW50cnlTdG9yZWAgaXMgdXBkYXRlZCBiZWZvcmUgdGhlIGNhbGxiYWNrIHRoYXQgdXBkYXRlcyBgQ2l0eVN0b3JlYFxuICogbmVlZHMgdG8gcXVlcnkgaXRzIGRhdGEuXG4gKlxuICogICBDaXR5U3RvcmUuZGlzcGF0Y2hUb2tlbiA9IGZsaWdodERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24ocGF5bG9hZCkge1xuICogICAgIGlmIChwYXlsb2FkLmFjdGlvblR5cGUgPT09ICdjb3VudHJ5LXVwZGF0ZScpIHtcbiAqICAgICAgIC8vIGBDb3VudHJ5U3RvcmUuY291bnRyeWAgbWF5IG5vdCBiZSB1cGRhdGVkLlxuICogICAgICAgZmxpZ2h0RGlzcGF0Y2hlci53YWl0Rm9yKFtDb3VudHJ5U3RvcmUuZGlzcGF0Y2hUb2tlbl0pO1xuICogICAgICAgLy8gYENvdW50cnlTdG9yZS5jb3VudHJ5YCBpcyBub3cgZ3VhcmFudGVlZCB0byBiZSB1cGRhdGVkLlxuICpcbiAqICAgICAgIC8vIFNlbGVjdCB0aGUgZGVmYXVsdCBjaXR5IGZvciB0aGUgbmV3IGNvdW50cnlcbiAqICAgICAgIENpdHlTdG9yZS5jaXR5ID0gZ2V0RGVmYXVsdENpdHlGb3JDb3VudHJ5KENvdW50cnlTdG9yZS5jb3VudHJ5KTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSB1c2FnZSBvZiBgd2FpdEZvcigpYCBjYW4gYmUgY2hhaW5lZCwgZm9yIGV4YW1wbGU6XG4gKlxuICogICBGbGlnaHRQcmljZVN0b3JlLmRpc3BhdGNoVG9rZW4gPVxuICogICAgIGZsaWdodERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24ocGF5bG9hZCkge1xuICogICAgICAgc3dpdGNoIChwYXlsb2FkLmFjdGlvblR5cGUpIHtcbiAqICAgICAgICAgY2FzZSAnY291bnRyeS11cGRhdGUnOlxuICogICAgICAgICAgIGZsaWdodERpc3BhdGNoZXIud2FpdEZvcihbQ2l0eVN0b3JlLmRpc3BhdGNoVG9rZW5dKTtcbiAqICAgICAgICAgICBGbGlnaHRQcmljZVN0b3JlLnByaWNlID1cbiAqICAgICAgICAgICAgIGdldEZsaWdodFByaWNlU3RvcmUoQ291bnRyeVN0b3JlLmNvdW50cnksIENpdHlTdG9yZS5jaXR5KTtcbiAqICAgICAgICAgICBicmVhaztcbiAqXG4gKiAgICAgICAgIGNhc2UgJ2NpdHktdXBkYXRlJzpcbiAqICAgICAgICAgICBGbGlnaHRQcmljZVN0b3JlLnByaWNlID1cbiAqICAgICAgICAgICAgIEZsaWdodFByaWNlU3RvcmUoQ291bnRyeVN0b3JlLmNvdW50cnksIENpdHlTdG9yZS5jaXR5KTtcbiAqICAgICAgICAgICBicmVhaztcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBgY291bnRyeS11cGRhdGVgIHBheWxvYWQgd2lsbCBiZSBndWFyYW50ZWVkIHRvIGludm9rZSB0aGUgc3RvcmVzJ1xuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MgaW4gb3JkZXI6IGBDb3VudHJ5U3RvcmVgLCBgQ2l0eVN0b3JlYCwgdGhlblxuICogYEZsaWdodFByaWNlU3RvcmVgLlxuICovXG5cbiAgZnVuY3Rpb24gRGlzcGF0Y2hlcigpIHtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMuJERpc3BhdGNoZXJfaXNQZW5kaW5nID0ge307XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0hhbmRsZWQgPSB7fTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX3BlbmRpbmdQYXlsb2FkID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdpdGggZXZlcnkgZGlzcGF0Y2hlZCBwYXlsb2FkLiBSZXR1cm5zXG4gICAqIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGB3YWl0Rm9yKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IF9wcmVmaXggKyBfbGFzdElEKys7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2FsbGJhY2sgYmFzZWQgb24gaXRzIHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLnVucmVnaXN0ZXI9ZnVuY3Rpb24oaWQpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrc1tpZF0sXG4gICAgICAnRGlzcGF0Y2hlci51bnJlZ2lzdGVyKC4uLik6IGAlc2AgZG9lcyBub3QgbWFwIHRvIGEgcmVnaXN0ZXJlZCBjYWxsYmFjay4nLFxuICAgICAgaWRcbiAgICApO1xuICAgIGRlbGV0ZSB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrc1tpZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciB0aGUgY2FsbGJhY2tzIHNwZWNpZmllZCB0byBiZSBpbnZva2VkIGJlZm9yZSBjb250aW51aW5nIGV4ZWN1dGlvblxuICAgKiBvZiB0aGUgY3VycmVudCBjYWxsYmFjay4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSBhIGNhbGxiYWNrIGluXG4gICAqIHJlc3BvbnNlIHRvIGEgZGlzcGF0Y2hlZCBwYXlsb2FkLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IGlkc1xuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUud2FpdEZvcj1mdW5jdGlvbihpZHMpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICB0aGlzLiREaXNwYXRjaGVyX2lzRGlzcGF0Y2hpbmcsXG4gICAgICAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IE11c3QgYmUgaW52b2tlZCB3aGlsZSBkaXNwYXRjaGluZy4nXG4gICAgKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaWRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIGlkID0gaWRzW2lpXTtcbiAgICAgIGlmICh0aGlzLiREaXNwYXRjaGVyX2lzUGVuZGluZ1tpZF0pIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHRoaXMuJERpc3BhdGNoZXJfaXNIYW5kbGVkW2lkXSxcbiAgICAgICAgICAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IENpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgd2hpbGUgJyArXG4gICAgICAgICAgJ3dhaXRpbmcgZm9yIGAlc2AuJyxcbiAgICAgICAgICBpZFxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3NbaWRdLFxuICAgICAgICAnRGlzcGF0Y2hlci53YWl0Rm9yKC4uLik6IGAlc2AgZG9lcyBub3QgbWFwIHRvIGEgcmVnaXN0ZXJlZCBjYWxsYmFjay4nLFxuICAgICAgICBpZFxuICAgICAgKTtcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfaW52b2tlQ2FsbGJhY2soaWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIHBheWxvYWQgdG8gYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGF5bG9hZFxuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2g9ZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIGludmFyaWFudChcbiAgICAgICF0aGlzLiREaXNwYXRjaGVyX2lzRGlzcGF0Y2hpbmcsXG4gICAgICAnRGlzcGF0Y2guZGlzcGF0Y2goLi4uKTogQ2Fubm90IGRpc3BhdGNoIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC4nXG4gICAgKTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX3N0YXJ0RGlzcGF0Y2hpbmcocGF5bG9hZCk7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICh0aGlzLiREaXNwYXRjaGVyX2lzUGVuZGluZ1tpZF0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiREaXNwYXRjaGVyX2ludm9rZUNhbGxiYWNrKGlkKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9zdG9wRGlzcGF0Y2hpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgRGlzcGF0Y2hlciBjdXJyZW50bHkgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5pc0Rpc3BhdGNoaW5nPWZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiREaXNwYXRjaGVyX2lzRGlzcGF0Y2hpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNhbGxiYWNrIHN0b3JlZCB3aXRoIHRoZSBnaXZlbiBpZC4gQWxzbyBkbyBzb21lIGludGVybmFsXG4gICAqIGJvb2trZWVwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS4kRGlzcGF0Y2hlcl9pbnZva2VDYWxsYmFjaz1mdW5jdGlvbihpZCkge1xuICAgIHRoaXMuJERpc3BhdGNoZXJfaXNQZW5kaW5nW2lkXSA9IHRydWU7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3NbaWRdKHRoaXMuJERpc3BhdGNoZXJfcGVuZGluZ1BheWxvYWQpO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfaXNIYW5kbGVkW2lkXSA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB1cCBib29ra2VlcGluZyBuZWVkZWQgd2hlbiBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBheWxvYWRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS4kRGlzcGF0Y2hlcl9zdGFydERpc3BhdGNoaW5nPWZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrcykge1xuICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9pc1BlbmRpbmdbaWRdID0gZmFsc2U7XG4gICAgICB0aGlzLiREaXNwYXRjaGVyX2lzSGFuZGxlZFtpZF0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9wZW5kaW5nUGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgYm9va2tlZXBpbmcgdXNlZCBmb3IgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUuJERpc3BhdGNoZXJfc3RvcERpc3BhdGNoaW5nPWZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJERpc3BhdGNoZXJfcGVuZGluZ1BheWxvYWQgPSBudWxsO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICB9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKGZhbHNlKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludmFyaWFudCBWaW9sYXRpb246ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIFRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBvd25FbnVtZXJhYmxlS2V5cyhvYmopIHtcblx0dmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopO1xuXG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0a2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG5cdH1cblxuXHRyZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiBwcm9wSXNFbnVtZXJhYmxlLmNhbGwob2JqLCBrZXkpO1xuXHR9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIGtleXM7XG5cdHZhciB0byA9IFRvT2JqZWN0KHRhcmdldCk7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gYXJndW1lbnRzW3NdO1xuXHRcdGtleXMgPSBvd25FbnVtZXJhYmxlS2V5cyhPYmplY3QoZnJvbSkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QvYWRkb25zXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInJlYWN0XCIsIFwicmVhY3QvYWRkb25zXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkhpZ2hjaGFydHNcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSwgcmVxdWlyZShcInJlYWN0L2FkZG9uc1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiSGlnaGNoYXJ0c1wiXSA9IGZhY3Rvcnkocm9vdFtcInJlYWN0XCJdLCByb290W1wicmVhY3QvYWRkb25zXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge2dsb2JhbC5IaWdoY2hhcnRzQWRhcHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBIaWdoY2hhcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIFJlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMykuYWRkb25zLnVwZGF0ZTtcblx0bW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdCAgZGlzcGxheU5hbWU6ICdIaWdoY2hhcnRzJyxcblxuXHQgIHJlbmRlckNoYXJ0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMucHJvcHMuY29uZmlnKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlnIGhhcyB0byBiZSBzcGVjaWZpZWQsIGZvciB0aGUgSGlnaGNoYXJ0IGNvbXBvbmVudCcpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5wcm9wcy5jb25maWc7XG5cdCAgICB2YXIgbm9kZSA9IHRoaXMucmVmcy5jaGFydC5nZXRET01Ob2RlKCk7XG5cblx0ICAgIGlmICghY29uZmlnLmNoYXJ0KSB7XG5cdCAgICAgIGNvbmZpZyA9IHVwZGF0ZShjb25maWcsIHtjaGFydDogeyRzZXQ6IHt9fX0pXG5cdCAgICB9XG5cblx0ICAgIGNvbmZpZyA9IHVwZGF0ZShjb25maWcsIHtjaGFydDoge3JlbmRlclRvOiB7JHNldDogbm9kZX19fSk7XG5cblx0ICAgIG5ldyBIaWdoY2hhcnRzLkNoYXJ0KGNvbmZpZyk7XG5cdCAgfSxcblxuXHQgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XG5cdCAgfSxcblx0ICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJjaGFydFwiLCByZWY6IFwiY2hhcnRcIn0pXG5cdCAgfVxuXHR9KTtcblxuXHRtb2R1bGUuZXhwb3J0cy5IaWdoY2hhcnRzID0gSGlnaGNoYXJ0cztcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cbi8qKiovIH0sXG4vKiA0ICovLFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIEBsaWNlbnNlIEBwcm9kdWN0Lm5hbWVAIEpTIHZAcHJvZHVjdC52ZXJzaW9uQCAoQHByb2R1Y3QuZGF0ZUApXG5cdCAqXG5cdCAqIFN0YW5kYWxvbmUgSGlnaGNoYXJ0cyBGcmFtZXdvcmtcblx0ICpcblx0ICogTGljZW5zZTogTUlUIExpY2Vuc2Vcblx0ICovXG5cblxuXHQvKmdsb2JhbCBIaWdoY2hhcnRzICovXG5cdHZhciBIaWdoY2hhcnRzQWRhcHRlciA9IChmdW5jdGlvbiAoKSB7XG5cblx0dmFyIFVOREVGSU5FRCxcblx0XHRkb2MgPSBkb2N1bWVudCxcblx0XHRlbXB0eUFycmF5ID0gW10sXG5cdFx0dGltZXJzID0gW10sXG5cdFx0dGltZXJJZCxcblx0XHRhbmltU2V0dGVycyA9IHt9LFxuXHRcdEZ4O1xuXG5cdE1hdGguZWFzZUluT3V0U2luZSA9IGZ1bmN0aW9uICh0LCBiLCBjLCBkKSB7XG5cdFx0cmV0dXJuIC1jIC8gMiAqIChNYXRoLmNvcyhNYXRoLlBJICogdCAvIGQpIC0gMSkgKyBiO1xuXHR9O1xuXG5cblxuXHQvKipcblx0ICogRXh0ZW5kIGdpdmVuIG9iamVjdCB3aXRoIGN1c3RvbSBldmVudHNcblx0ICovXG5cdGZ1bmN0aW9uIGF1Z21lbnQob2JqKSB7XG5cdFx0ZnVuY3Rpb24gcmVtb3ZlT25lRXZlbnQoZWwsIHR5cGUsIGZuKSB7XG5cdFx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gSUVSZW1vdmVPbmVFdmVudChlbCwgdHlwZSwgZm4pIHtcblx0XHRcdGZuID0gZWwuSENQcm94aWVkTWV0aG9kc1tmbi50b1N0cmluZygpXTtcblx0XHRcdGVsLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBmbik7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlQWxsRXZlbnRzKGVsLCB0eXBlKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gZWwuSENFdmVudHMsXG5cdFx0XHRcdHJlbW92ZSxcblx0XHRcdFx0dHlwZXMsXG5cdFx0XHRcdGxlbixcblx0XHRcdFx0bjtcblxuXHRcdFx0aWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0cmVtb3ZlID0gcmVtb3ZlT25lRXZlbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRcdHJlbW92ZSA9IElFUmVtb3ZlT25lRXZlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47IC8vIGJyZWFrIG9uIG5vbi1ET00gZXZlbnRzXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKHR5cGUpIHtcblx0XHRcdFx0dHlwZXMgPSB7fTtcblx0XHRcdFx0dHlwZXNbdHlwZV0gPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZXMgPSBldmVudHM7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobiBpbiB0eXBlcykge1xuXHRcdFx0XHRpZiAoZXZlbnRzW25dKSB7XG5cdFx0XHRcdFx0bGVuID0gZXZlbnRzW25dLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAobGVuLS0pIHtcblx0XHRcdFx0XHRcdHJlbW92ZShlbCwgbiwgZXZlbnRzW25dW2xlbl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghb2JqLkhDRXh0ZW5kZWQpIHtcblx0XHRcdEhpZ2hjaGFydHMuZXh0ZW5kKG9iaiwge1xuXHRcdFx0XHRIQ0V4dGVuZGVkOiB0cnVlLFxuXG5cdFx0XHRcdEhDRXZlbnRzOiB7fSxcblxuXHRcdFx0XHRiaW5kOiBmdW5jdGlvbiAobmFtZSwgZm4pIHtcblx0XHRcdFx0XHR2YXIgZWwgPSB0aGlzLFxuXHRcdFx0XHRcdFx0ZXZlbnRzID0gdGhpcy5IQ0V2ZW50cyxcblx0XHRcdFx0XHRcdHdyYXBwZWRGbjtcblxuXHRcdFx0XHRcdC8vIGhhbmRsZSBET00gZXZlbnRzIGluIG1vZGVybiBicm93c2Vyc1xuXHRcdFx0XHRcdGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZuLCBmYWxzZSk7XG5cblx0XHRcdFx0XHQvLyBoYW5kbGUgb2xkIElFIGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlbC5hdHRhY2hFdmVudCkge1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR3cmFwcGVkRm4gPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRlLnRhcmdldCA9IGUuc3JjRWxlbWVudCB8fCB3aW5kb3c7IC8vICMyODIwXG5cdFx0XHRcdFx0XHRcdGZuLmNhbGwoZWwsIGUpO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKCFlbC5IQ1Byb3hpZWRNZXRob2RzKSB7XG5cdFx0XHRcdFx0XHRcdGVsLkhDUHJveGllZE1ldGhvZHMgPSB7fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gbGluayB3cmFwcGVkIGZuIHdpdGggb3JpZ2luYWwgZm4sIHNvIHdlIGNhbiBnZXQgdGhpcyBpbiByZW1vdmVFdmVudFxuXHRcdFx0XHRcdFx0ZWwuSENQcm94aWVkTWV0aG9kc1tmbi50b1N0cmluZygpXSA9IHdyYXBwZWRGbjtcblxuXHRcdFx0XHRcdFx0ZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIHdyYXBwZWRGbik7XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRpZiAoZXZlbnRzW25hbWVdID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdGV2ZW50c1tuYW1lXSA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGV2ZW50c1tuYW1lXS5wdXNoKGZuKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuXHRcdFx0XHRcdHZhciBldmVudHMsXG5cdFx0XHRcdFx0XHRpbmRleDtcblxuXHRcdFx0XHRcdGlmIChuYW1lKSB7XG5cdFx0XHRcdFx0XHRldmVudHMgPSB0aGlzLkhDRXZlbnRzW25hbWVdIHx8IFtdO1xuXHRcdFx0XHRcdFx0aWYgKGZuKSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gSGlnaGNoYXJ0c0FkYXB0ZXIuaW5BcnJheShmbiwgZXZlbnRzKTtcblx0XHRcdFx0XHRcdFx0aWYgKGluZGV4ID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLkhDRXZlbnRzW25hbWVdID0gZXZlbnRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRyZW1vdmVPbmVFdmVudCh0aGlzLCBuYW1lLCBmbik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5hdHRhY2hFdmVudCkge1xuXHRcdFx0XHRcdFx0XHRcdElFUmVtb3ZlT25lRXZlbnQodGhpcywgbmFtZSwgZm4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVBbGxFdmVudHModGhpcywgbmFtZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuSENFdmVudHNbbmFtZV0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVtb3ZlQWxsRXZlbnRzKHRoaXMpO1xuXHRcdFx0XHRcdFx0dGhpcy5IQ0V2ZW50cyA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuXHRcdFx0XHRcdHZhciBldmVudHMgPSB0aGlzLkhDRXZlbnRzW25hbWVdIHx8IFtdLFxuXHRcdFx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0XHRcdGxlbiA9IGV2ZW50cy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdFx0cHJldmVudERlZmF1bHQsXG5cdFx0XHRcdFx0XHRmbjtcblxuXHRcdFx0XHRcdC8vIEF0dGFjaCBhIHNpbXBsZSBwcmV2ZW50RGVmYXVsdCBmdW5jdGlvbiB0byBza2lwIGRlZmF1bHQgaGFuZGxlciBpZiBjYWxsZWRcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGFyZ3MuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGZuID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRcdFx0XHQvLyBhcmdzIGlzIG5ldmVyIG51bGwgaGVyZVxuXHRcdFx0XHRcdFx0aWYgKGFyZ3Muc3RvcHBlZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGFyZ3MucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcblx0XHRcdFx0XHRcdGFyZ3MudGFyZ2V0ID0gdGFyZ2V0O1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgdHlwZSBpcyBub3Qgc2V0LCB3ZSdyZSBydW5uaW5nIGEgY3VzdG9tIGV2ZW50ICgjMjI5NykuIElmIGl0IGlzIHNldCxcblx0XHRcdFx0XHRcdC8vIHdlJ3JlIHJ1bm5pbmcgYSBicm93c2VyIGV2ZW50LCBhbmQgc2V0dGluZyBpdCB3aWxsIGNhdXNlIGVuIGVycm9yIGluXG5cdFx0XHRcdFx0XHQvLyBJRTggKCMyNDY1KS5cblx0XHRcdFx0XHRcdGlmICghYXJncy50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdGFyZ3MudHlwZSA9IG5hbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaGFuZGxlciByZXR1cm4gZmFsc2UsIHByZXZlbnQgdGhlIGRlZmF1bHQgaGFuZGxlciBmcm9tIGV4ZWN1dGluZ1xuXHRcdFx0XHRcdFx0aWYgKGZuLmNhbGwodGhpcywgYXJncykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdGFyZ3MucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXG5cdHJldHVybiB7XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBhZGFwdGVyLiBUaGlzIGlzIHJ1biBvbmNlIGFzIEhpZ2hjaGFydHMgaXMgZmlyc3QgcnVuLlxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChwYXRoQW5pbSkge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIENvbXBhdGliaWxpdHkgc2VjdGlvbiB0byBhZGQgc3VwcG9ydCBmb3IgbGVnYWN5IElFLiBUaGlzIGNhbiBiZSByZW1vdmVkIGlmIG9sZCBJRSBcblx0XHRcdCAqIHN1cHBvcnQgaXMgbm90IG5lZWRlZC5cblx0XHRcdCAqL1xuXHRcdFx0aWYgKCFkb2MuZGVmYXVsdFZpZXcpIHtcblx0XHRcdFx0dGhpcy5fZ2V0U3R5bGUgPSBmdW5jdGlvbiAoZWwsIHByb3ApIHtcblx0XHRcdFx0XHR2YXIgdmFsO1xuXHRcdFx0XHRcdGlmIChlbC5zdHlsZVtwcm9wXSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsLnN0eWxlW3Byb3BdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAocHJvcCA9PT0gJ29wYWNpdHknKSB7XG5cdFx0XHRcdFx0XHRcdHByb3AgPSAnZmlsdGVyJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8qanNsaW50IHVucGFyYW06IHRydWUqL1xuXHRcdFx0XHRcdFx0dmFsID0gZWwuY3VycmVudFN0eWxlW3Byb3AucmVwbGFjZSgvXFwtKFxcdykvZywgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIudG9VcHBlckNhc2UoKTsgfSldO1xuXHRcdFx0XHRcdFx0aWYgKHByb3AgPT09ICdmaWx0ZXInKSB7XG5cdFx0XHRcdFx0XHRcdHZhbCA9IHZhbC5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0XHRcdC9hbHBoYVxcKG9wYWNpdHk9KFswLTldKylcXCkvLCBcblx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAoYSwgYikgeyBcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBiIC8gMTAwOyBcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiBmYWxzZSovXG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsID09PSAnJyA/IDEgOiB2YWw7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5hZGFwdGVyUnVuID0gZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCkge1xuXHRcdFx0XHRcdHZhciBhbGlhcyA9IHsgd2lkdGg6ICdjbGllbnRXaWR0aCcsIGhlaWdodDogJ2NsaWVudEhlaWdodCcgfVttZXRob2RdO1xuXG5cdFx0XHRcdFx0aWYgKGFsaWFzKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnN0eWxlLnpvb20gPSAxO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1bYWxpYXNdIC0gMiAqIHBhcnNlSW50KEhpZ2hjaGFydHNBZGFwdGVyLl9nZXRTdHlsZShlbGVtLCAncGFkZGluZycpLCAxMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG5cdFx0XHRcdHRoaXMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGZuKSB7IC8vIGxlZ2FjeVxuXHRcdFx0XHRcdHZhciBpID0gMCwgXG5cdFx0XHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0XHRcdFx0dGhpcy5pbkFycmF5ID0gZnVuY3Rpb24gKGl0ZW0sIGFycikge1xuXHRcdFx0XHRcdHZhciBsZW4sIFxuXHRcdFx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdFx0XHRpZiAoYXJyKSB7XG5cdFx0XHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhcnJbaV0gPT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG5cdFx0XHRcdHRoaXMuZ3JlcCA9IGZ1bmN0aW9uIChlbGVtZW50cywgY2FsbGJhY2spIHtcblx0XHRcdFx0XHR2YXIgcmV0ID0gW10sXG5cdFx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRcdFx0XHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmICghIWNhbGxiYWNrKGVsZW1lbnRzW2ldLCBpKSkge1xuXHRcdFx0XHRcdFx0XHRyZXQucHVzaChlbGVtZW50c1tpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8tLS0gRW5kIGNvbXBhdGliaWxpdHkgc2VjdGlvbiAtLS1cblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFN0YXJ0IG9mIGFuaW1hdGlvbiBzcGVjaWZpYyBjb2RlXG5cdFx0XHQgKi9cblx0XHRcdEZ4ID0gZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIHByb3ApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHRcdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHRcdH07XG5cdFx0XHRGeC5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgc3R5bGVzLFxuXHRcdFx0XHRcdFx0cGF0aHMgPSB0aGlzLnBhdGhzLFxuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXMuZWxlbSxcblx0XHRcdFx0XHRcdGVsZW1lbGVtID0gZWxlbS5lbGVtZW50OyAvLyBpZiBkZXN0cm95ZWQsIGl0IGlzIG51bGxcblxuXHRcdFx0XHRcdC8vIEFuaW1hdGlvbiBzZXR0ZXIgZGVmaW5lZCBmcm9tIG91dHNpZGVcblx0XHRcdFx0XHRpZiAoYW5pbVNldHRlcnNbdGhpcy5wcm9wXSkge1xuXHRcdFx0XHRcdFx0YW5pbVNldHRlcnNbdGhpcy5wcm9wXSh0aGlzKTtcblxuXHRcdFx0XHRcdC8vIEFuaW1hdGluZyBhIHBhdGggZGVmaW5pdGlvbiBvbiBTVkdFbGVtZW50XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwYXRocyAmJiBlbGVtZWxlbSkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hdHRyKCdkJywgcGF0aEFuaW0uc3RlcChwYXRoc1swXSwgcGF0aHNbMV0sIHRoaXMubm93LCB0aGlzLnRvRCkpO1xuXG5cdFx0XHRcdFx0Ly8gT3RoZXIgYW5pbWF0aW9ucyBvbiBTVkdFbGVtZW50XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlbGVtLmF0dHIpIHtcblx0XHRcdFx0XHRcdGlmIChlbGVtZWxlbSkge1xuXHRcdFx0XHRcdFx0XHRlbGVtLmF0dHIodGhpcy5wcm9wLCB0aGlzLm5vdyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBIVE1MIHN0eWxlc1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZXMgPSB7fTtcblx0XHRcdFx0XHRcdHN0eWxlc1t0aGlzLnByb3BdID0gdGhpcy5ub3cgKyB0aGlzLnVuaXQ7XG5cdFx0XHRcdFx0XHRIaWdoY2hhcnRzLmNzcyhlbGVtLCBzdHlsZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnN0ZXApIHtcblx0XHRcdFx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGN1c3RvbTogZnVuY3Rpb24gKGZyb20sIHRvLCB1bml0KSB7XG5cdFx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRcdFx0dCA9IGZ1bmN0aW9uIChnb3RvRW5kKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzZWxmLnN0ZXAoZ290b0VuZCk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aTtcblxuXHRcdFx0XHRcdHRoaXMuc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5zdGFydCA9IGZyb207XG5cdFx0XHRcdFx0dGhpcy5lbmQgPSB0bztcblx0XHRcdFx0XHR0aGlzLnVuaXQgPSB1bml0O1xuXHRcdFx0XHRcdHRoaXMubm93ID0gdGhpcy5zdGFydDtcblx0XHRcdFx0XHR0aGlzLnBvcyA9IHRoaXMuc3RhdGUgPSAwO1xuXG5cdFx0XHRcdFx0dC5lbGVtID0gdGhpcy5lbGVtO1xuXG5cdFx0XHRcdFx0aWYgKHQoKSAmJiB0aW1lcnMucHVzaCh0KSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGltZXJJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXRpbWVyc1tpXSgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCF0aW1lcnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgMTMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XG5cdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uIChnb3RvRW5kKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSArbmV3IERhdGUoKSxcblx0XHRcdFx0XHRcdHJldCxcblx0XHRcdFx0XHRcdGRvbmUsXG5cdFx0XHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXMuZWxlbSxcblx0XHRcdFx0XHRcdGk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGVsZW0uc3RvcEFuaW1hdGlvbiB8fCAoZWxlbS5hdHRyICYmICFlbGVtLmVsZW1lbnQpKSB7IC8vICMyNjE2LCBlbGVtZW50IGluY2x1ZGluZyBmbGFnIGlzIGRlc3Ryb3llZFxuXHRcdFx0XHRcdFx0cmV0ID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGdvdG9FbmQgfHwgdCA+PSBvcHRpb25zLmR1cmF0aW9uICsgdGhpcy5zdGFydFRpbWUpIHtcblx0XHRcdFx0XHRcdHRoaXMubm93ID0gdGhpcy5lbmQ7XG5cdFx0XHRcdFx0XHR0aGlzLnBvcyA9IHRoaXMuc3RhdGUgPSAxO1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5vcHRpb25zLmN1ckFuaW1bdGhpcy5wcm9wXSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Zm9yIChpIGluIG9wdGlvbnMuY3VyQW5pbSkge1xuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5jdXJBbmltW2ldICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChkb25lKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZS5jYWxsKGVsZW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgbiA9IHQgLSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUgPSBuIC8gb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdHRoaXMucG9zID0gb3B0aW9ucy5lYXNpbmcobiwgMCwgMSwgb3B0aW9ucy5kdXJhdGlvbik7XG5cdFx0XHRcdFx0XHR0aGlzLm5vdyA9IHRoaXMuc3RhcnQgKyAoKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0aGlzLnBvcyk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0cmV0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgYWRhcHRlciBhbmltYXRlIG1ldGhvZFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWwsIHByb3AsIG9wdCkge1xuXHRcdFx0XHR2YXIgc3RhcnQsXG5cdFx0XHRcdFx0dW5pdCA9ICcnLFxuXHRcdFx0XHRcdGVuZCxcblx0XHRcdFx0XHRmeCxcblx0XHRcdFx0XHRhcmdzLFxuXHRcdFx0XHRcdG5hbWU7XG5cblx0XHRcdFx0ZWwuc3RvcEFuaW1hdGlvbiA9IGZhbHNlOyAvLyByZWFkeSBmb3IgbmV3XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBvcHQgIT09ICdvYmplY3QnIHx8IG9wdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0b3B0ID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGFyZ3NbMl0sXG5cdFx0XHRcdFx0XHRlYXNpbmc6IGFyZ3NbM10sXG5cdFx0XHRcdFx0XHRjb21wbGV0ZTogYXJnc1s0XVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZiBvcHQuZHVyYXRpb24gIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0b3B0LmR1cmF0aW9uID0gNDAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdC5lYXNpbmcgPSBNYXRoW29wdC5lYXNpbmddIHx8IE1hdGguZWFzZUluT3V0U2luZTtcblx0XHRcdFx0b3B0LmN1ckFuaW0gPSBIaWdoY2hhcnRzLmV4dGVuZCh7fSwgcHJvcCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKG5hbWUgaW4gcHJvcCkge1xuXHRcdFx0XHRcdGZ4ID0gbmV3IEZ4KGVsLCBvcHQsIG5hbWUpO1xuXHRcdFx0XHRcdGVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdkJykge1xuXHRcdFx0XHRcdFx0ZngucGF0aHMgPSBwYXRoQW5pbS5pbml0KFxuXHRcdFx0XHRcdFx0XHRlbCxcblx0XHRcdFx0XHRcdFx0ZWwuZCxcblx0XHRcdFx0XHRcdFx0cHJvcC5kXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0ZngudG9EID0gcHJvcC5kO1xuXHRcdFx0XHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0XHRcdFx0ZW5kID0gMTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsLmF0dHIpIHtcblx0XHRcdFx0XHRcdHN0YXJ0ID0gZWwuYXR0cihuYW1lKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhcnQgPSBwYXJzZUZsb2F0KEhpZ2hjaGFydHNBZGFwdGVyLl9nZXRTdHlsZShlbCwgbmFtZSkpIHx8IDA7XG5cdFx0XHRcdFx0XHRpZiAobmFtZSAhPT0gJ29wYWNpdHknKSB7XG5cdFx0XHRcdFx0XHRcdHVuaXQgPSAncHgnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0XHRpZiAoIWVuZCkge1xuXHRcdFx0XHRcdFx0ZW5kID0gcHJvcFtuYW1lXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnguY3VzdG9tKHN0YXJ0LCBlbmQsIHVuaXQpO1xuXHRcdFx0XHR9XHRcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEludGVybmFsIG1ldGhvZCB0byByZXR1cm4gQ1NTIHZhbHVlIGZvciBnaXZlbiBlbGVtZW50IGFuZCBwcm9wZXJ0eVxuXHRcdCAqL1xuXHRcdF9nZXRTdHlsZTogZnVuY3Rpb24gKGVsLCBwcm9wKSB7XG5cdFx0XHRyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIHVuZGVmaW5lZCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGFuIGFuaW1hdGlvbiBzZXR0ZXIgZm9yIGEgc3BlY2lmaWMgcHJvcGVydHlcblx0XHQgKi9cblx0XHRhZGRBbmltU2V0dGVyOiBmdW5jdGlvbiAocHJvcCwgZm4pIHtcblx0XHRcdGFuaW1TZXR0ZXJzW3Byb3BdID0gZm47XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERvd25sb2FkcyBhIHNjcmlwdCBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayB3aGVuIGRvbmUuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHNjcmlwdExvY2F0aW9uXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0XHQgKi9cblx0XHRnZXRTY3JpcHQ6IGZ1bmN0aW9uIChzY3JpcHRMb2NhdGlvbiwgY2FsbGJhY2spIHtcblx0XHRcdC8vIFdlIGNhbm5vdCBhc3N1bWUgdGhhdCBBc3NldHMgY2xhc3MgZnJvbSBtb290b29scy1tb3JlIGlzIGF2YWlsYWJsZSBzbyBpbnN0ZWFkIGluc2VydCBhIHNjcmlwdCB0YWcgdG8gZG93bmxvYWQgc2NyaXB0LlxuXHRcdFx0dmFyIGhlYWQgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSxcblx0XHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0XHRzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuXHRcdFx0c2NyaXB0LnNyYyA9IHNjcmlwdExvY2F0aW9uO1xuXHRcdFx0c2NyaXB0Lm9ubG9hZCA9IGNhbGxiYWNrO1xuXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0aGUgaW5kZXggb2YgYW4gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgbm90IGZvdW5kXG5cdFx0ICovXG5cdFx0aW5BcnJheTogZnVuY3Rpb24gKGl0ZW0sIGFycikge1xuXHRcdFx0cmV0dXJuIGFyci5pbmRleE9mID8gYXJyLmluZGV4T2YoaXRlbSkgOiBlbXB0eUFycmF5LmluZGV4T2YuY2FsbChhcnIsIGl0ZW0pO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIEEgZGlyZWN0IGxpbmsgdG8gYWRhcHRlciBtZXRob2RzXG5cdFx0ICovXG5cdFx0YWRhcHRlclJ1bjogZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCkge1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KEhpZ2hjaGFydHNBZGFwdGVyLl9nZXRTdHlsZShlbGVtLCBtZXRob2QpLCAxMCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlciBhbiBhcnJheVxuXHRcdCAqL1xuXHRcdGdyZXA6IGZ1bmN0aW9uIChlbGVtZW50cywgY2FsbGJhY2spIHtcblx0XHRcdHJldHVybiBlbXB0eUFycmF5LmZpbHRlci5jYWxsKGVsZW1lbnRzLCBjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1hcCBhbiBhcnJheVxuXHRcdCAqL1xuXHRcdG1hcDogZnVuY3Rpb24gKGFyciwgZm4pIHtcblx0XHRcdHZhciByZXN1bHRzID0gW10sIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdHNbaV0gPSBmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBlbGVtZW50J3Mgb2Zmc2V0IHBvc2l0aW9uLCBjb3JyZWN0ZWQgYnkgb3ZlcmZsb3c6YXV0by4gTG9vc2VseSBiYXNlZCBvbiBqUXVlcnkncyBvZmZzZXQgbWV0aG9kLlxuXHRcdCAqL1xuXHRcdG9mZnNldDogZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHR2YXIgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0Ym94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogYm94LnRvcCAgKyAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsVG9wKSAgLSAoZG9jRWxlbS5jbGllbnRUb3AgIHx8IDApLFxuXHRcdFx0XHRsZWZ0OiBib3gubGVmdCArICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0KSAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMClcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdCAqL1xuXHRcdGFkZEV2ZW50OiBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuKSB7XG5cdFx0XHRhdWdtZW50KGVsKS5iaW5kKHR5cGUsIGZuKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGV2ZW50IGFkZGVkIHdpdGggYWRkRXZlbnRcblx0XHQgKi9cblx0XHRyZW1vdmVFdmVudDogZnVuY3Rpb24gKGVsLCB0eXBlLCBmbikge1xuXHRcdFx0YXVnbWVudChlbCkudW5iaW5kKHR5cGUsIGZuKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRmlyZSBhbiBldmVudCBvbiBhIGN1c3RvbSBvYmplY3Rcblx0XHQgKi9cblx0XHRmaXJlRXZlbnQ6IGZ1bmN0aW9uIChlbCwgdHlwZSwgZXZlbnRBcmd1bWVudHMsIGRlZmF1bHRGdW5jdGlvbikge1xuXHRcdFx0dmFyIGU7XG5cblx0XHRcdGlmIChkb2MuY3JlYXRlRXZlbnQgJiYgKGVsLmRpc3BhdGNoRXZlbnQgfHwgZWwuZmlyZUV2ZW50KSkge1xuXHRcdFx0XHRlID0gZG9jLmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcblx0XHRcdFx0ZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdGUudGFyZ2V0ID0gZWw7XG5cblx0XHRcdFx0SGlnaGNoYXJ0cy5leHRlbmQoZSwgZXZlbnRBcmd1bWVudHMpO1xuXG5cdFx0XHRcdGlmIChlbC5kaXNwYXRjaEV2ZW50KSB7XG5cdFx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbC5maXJlRXZlbnQodHlwZSwgZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmIChlbC5IQ0V4dGVuZGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdGV2ZW50QXJndW1lbnRzID0gZXZlbnRBcmd1bWVudHMgfHwge307XG5cdFx0XHRcdGVsLnRyaWdnZXIodHlwZSwgZXZlbnRBcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnRBcmd1bWVudHMgJiYgZXZlbnRBcmd1bWVudHMuZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRkZWZhdWx0RnVuY3Rpb24gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGVmYXVsdEZ1bmN0aW9uKSB7XG5cdFx0XHRcdGRlZmF1bHRGdW5jdGlvbihldmVudEFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHdhc2hNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0cmV0dXJuIGU7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU3RvcCBydW5uaW5nIGFuaW1hdGlvblxuXHRcdCAqL1xuXHRcdHN0b3A6IGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0ZWwuc3RvcEFuaW1hdGlvbiA9IHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFV0aWxpdHkgZm9yIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5LiBQYXJhbWV0ZXJzIGFyZSByZXZlcnNlZCBjb21wYXJlZCB0byBqUXVlcnkuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYXJyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHQgKi9cblx0XHRlYWNoOiBmdW5jdGlvbiAoYXJyLCBmbikgeyAvLyBtb2Rlcm4gYnJvd3NlcnNcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFyciwgZm4pO1xuXHRcdH1cblx0fTtcblx0fSgpKTtcblxuXG5cdC8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBIaWdoY2hhcnRzQWRhcHRlclxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuXHQvLyBAY29tcGlsYXRpb25fbGV2ZWwgU0lNUExFX09QVElNSVpBVElPTlNcblxuXHQvKipcblx0ICogQGxpY2Vuc2UgSGlnaGNoYXJ0cyBKUyB2NC4xLjQtbW9kaWZpZWQgKClcblx0ICpcblx0ICogKGMpIDIwMDktMjAxNCBUb3JzdGVpbiBIb25zaVxuXHQgKlxuXHQgKiBMaWNlbnNlOiB3d3cuaGlnaGNoYXJ0cy5jb20vbGljZW5zZVxuXHQgKi9cblxuXHQvLyBKU0xpbnQgb3B0aW9uczpcblx0LypnbG9iYWwgSGlnaGNoYXJ0cywgSGlnaGNoYXJ0c0FkYXB0ZXIsIGRvY3VtZW50LCB3aW5kb3csIG5hdmlnYXRvciwgc2V0SW50ZXJ2YWwsIGNsZWFySW50ZXJ2YWwsIGNsZWFyVGltZW91dCwgc2V0VGltZW91dCwgbG9jYXRpb24sIGpRdWVyeSwgJCwgY29uc29sZSwgZWFjaCwgZ3JlcCAqL1xuXHQvKmpzbGludCBhc3M6IHRydWUsIHNsb3BweTogdHJ1ZSwgZm9yaW46IHRydWUsIHBsdXNwbHVzOiB0cnVlLCBub21lbjogdHJ1ZSwgdmFyczogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBuZXdjYXA6IHRydWUsIGJyb3dzZXI6IHRydWUsIGNvbnRpbnVlOiB0cnVlLCB3aGl0ZTogdHJ1ZSAqL1xuXHQoZnVuY3Rpb24gKCkge1xuXHQvLyBlbmNhcHN1bGF0ZWQgdmFyaWFibGVzXG5cdHZhciBVTkRFRklORUQsXG5cdFx0ZG9jID0gZG9jdW1lbnQsXG5cdFx0d2luID0gd2luZG93LFxuXHRcdG1hdGggPSBNYXRoLFxuXHRcdG1hdGhSb3VuZCA9IG1hdGgucm91bmQsXG5cdFx0bWF0aEZsb29yID0gbWF0aC5mbG9vcixcblx0XHRtYXRoQ2VpbCA9IG1hdGguY2VpbCxcblx0XHRtYXRoTWF4ID0gbWF0aC5tYXgsXG5cdFx0bWF0aE1pbiA9IG1hdGgubWluLFxuXHRcdG1hdGhBYnMgPSBtYXRoLmFicyxcblx0XHRtYXRoQ29zID0gbWF0aC5jb3MsXG5cdFx0bWF0aFNpbiA9IG1hdGguc2luLFxuXHRcdG1hdGhQSSA9IG1hdGguUEksXG5cdFx0ZGVnMnJhZCA9IG1hdGhQSSAqIDIgLyAzNjAsXG5cblxuXHRcdC8vIHNvbWUgdmFyaWFibGVzXG5cdFx0dXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcblx0XHRpc09wZXJhID0gd2luLm9wZXJhLFxuXHRcdGlzSUUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KHVzZXJBZ2VudCkgJiYgIWlzT3BlcmEsXG5cdFx0ZG9jTW9kZTggPSBkb2MuZG9jdW1lbnRNb2RlID09PSA4LFxuXHRcdGlzV2ViS2l0ID0gL0FwcGxlV2ViS2l0Ly50ZXN0KHVzZXJBZ2VudCksXG5cdFx0aXNGaXJlZm94ID0gL0ZpcmVmb3gvLnRlc3QodXNlckFnZW50KSxcblx0XHRpc1RvdWNoRGV2aWNlID0gLyhNb2JpbGV8QW5kcm9pZHxXaW5kb3dzIFBob25lKS8udGVzdCh1c2VyQWdlbnQpLFxuXHRcdFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0aGFzU1ZHID0gISFkb2MuY3JlYXRlRWxlbWVudE5TICYmICEhZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICdzdmcnKS5jcmVhdGVTVkdSZWN0LFxuXHRcdGhhc0JpZGlCdWcgPSBpc0ZpcmVmb3ggJiYgcGFyc2VJbnQodXNlckFnZW50LnNwbGl0KCdGaXJlZm94LycpWzFdLCAxMCkgPCA0LCAvLyBpc3N1ZSAjMzhcblx0XHR1c2VDYW5WRyA9ICFoYXNTVkcgJiYgIWlzSUUgJiYgISFkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcblx0XHRSZW5kZXJlcixcblx0XHRoYXNUb3VjaCxcblx0XHRzeW1ib2xTaXplcyA9IHt9LFxuXHRcdGlkQ291bnRlciA9IDAsXG5cdFx0Z2FyYmFnZUJpbixcblx0XHRkZWZhdWx0T3B0aW9ucyxcblx0XHRkYXRlRm9ybWF0LCAvLyBmdW5jdGlvblxuXHRcdGdsb2JhbEFuaW1hdGlvbixcblx0XHRwYXRoQW5pbSxcblx0XHR0aW1lVW5pdHMsXG5cdFx0bm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFVOREVGSU5FRDsgfSxcblx0XHRjaGFydHMgPSBbXSxcblx0XHRjaGFydENvdW50ID0gMCxcblx0XHRQUk9EVUNUID0gJ0hpZ2hjaGFydHMnLFxuXHRcdFZFUlNJT04gPSAnNC4xLjQtbW9kaWZpZWQnLFxuXG5cdFx0Ly8gc29tZSBjb25zdGFudHMgZm9yIGZyZXF1ZW50bHkgdXNlZCBzdHJpbmdzXG5cdFx0RElWID0gJ2RpdicsXG5cdFx0QUJTT0xVVEUgPSAnYWJzb2x1dGUnLFxuXHRcdFJFTEFUSVZFID0gJ3JlbGF0aXZlJyxcblx0XHRISURERU4gPSAnaGlkZGVuJyxcblx0XHRQUkVGSVggPSAnaGlnaGNoYXJ0cy0nLFxuXHRcdFZJU0lCTEUgPSAndmlzaWJsZScsXG5cdFx0UFggPSAncHgnLFxuXHRcdE5PTkUgPSAnbm9uZScsXG5cdFx0TSA9ICdNJyxcblx0XHRMID0gJ0wnLFxuXHRcdG51bVJlZ2V4ID0gL15bMC05XSskLyxcblx0XHROT1JNQUxfU1RBVEUgPSAnJyxcblx0XHRIT1ZFUl9TVEFURSA9ICdob3ZlcicsXG5cdFx0U0VMRUNUX1NUQVRFID0gJ3NlbGVjdCcsXG5cdFx0bWFyZ2luTmFtZXMgPSBbJ3Bsb3RUb3AnLCAnbWFyZ2luUmlnaHQnLCAnbWFyZ2luQm90dG9tJywgJ3Bsb3RMZWZ0J10sXG5cdFx0XG5cdFx0Ly8gT2JqZWN0IGZvciBleHRlbmRpbmcgQXhpc1xuXHRcdEF4aXNQbG90TGluZU9yQmFuZEV4dGVuc2lvbixcblxuXHRcdC8vIGNvbnN0YW50cyBmb3IgYXR0cmlidXRlc1xuXHRcdFNUUk9LRV9XSURUSCA9ICdzdHJva2Utd2lkdGgnLFxuXG5cdFx0Ly8gdGltZSBtZXRob2RzLCBjaGFuZ2VkIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IFVUQyBpcyB1c2VkXG5cdFx0RGF0ZSwgIC8vIEFsbG93IHVzaW5nIGEgZGlmZmVyZW50IERhdGUgY2xhc3Ncblx0XHRtYWtlVGltZSxcblx0XHR0aW1lem9uZU9mZnNldCxcblx0XHRnZXRUaW1lem9uZU9mZnNldCxcblx0XHRnZXRNaW51dGVzLFxuXHRcdGdldEhvdXJzLFxuXHRcdGdldERheSxcblx0XHRnZXREYXRlLFxuXHRcdGdldE1vbnRoLFxuXHRcdGdldEZ1bGxZZWFyLFxuXHRcdHNldE1pbnV0ZXMsXG5cdFx0c2V0SG91cnMsXG5cdFx0c2V0RGF0ZSxcblx0XHRzZXRNb250aCxcblx0XHRzZXRGdWxsWWVhcixcblxuXG5cdFx0Ly8gbG9va3VwIG92ZXIgdGhlIHR5cGVzIGFuZCB0aGUgYXNzb2NpYXRlZCBjbGFzc2VzXG5cdFx0c2VyaWVzVHlwZXMgPSB7fSxcblx0XHRIaWdoY2hhcnRzO1xuXG5cdC8vIFRoZSBIaWdoY2hhcnRzIG5hbWVzcGFjZVxuXHRIaWdoY2hhcnRzID0gd2luLkhpZ2hjaGFydHMgPSB3aW4uSGlnaGNoYXJ0cyA/IGVycm9yKDE2LCB0cnVlKSA6IHt9O1xuXG5cdEhpZ2hjaGFydHMuc2VyaWVzVHlwZXMgPSBzZXJpZXNUeXBlcztcblxuXHQvKipcblx0ICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBtZW1iZXJzIG9mIGFub3RoZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGFkZCB0byB0aGUgZmlyc3Qgb25lXG5cdCAqL1xuXHR2YXIgZXh0ZW5kID0gSGlnaGNoYXJ0cy5leHRlbmQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRcdHZhciBuO1xuXHRcdGlmICghYSkge1xuXHRcdFx0YSA9IHt9O1xuXHRcdH1cblx0XHRmb3IgKG4gaW4gYikge1xuXHRcdFx0YVtuXSA9IGJbbl07XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXHRcdFxuXHQvKipcblx0ICogRGVlcCBtZXJnZSB0d28gb3IgbW9yZSBvYmplY3RzIGFuZCByZXR1cm4gYSB0aGlyZCBvYmplY3QuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpc1xuXHQgKiB0cnVlLCB0aGUgY29udGVudHMgb2YgdGhlIHNlY29uZCBvYmplY3QgaXMgY29waWVkIGludG8gdGhlIGZpcnN0IG9iamVjdC5cblx0ICogUHJldmlvdXNseSB0aGlzIGZ1bmN0aW9uIHJlZGlyZWN0ZWQgdG8galF1ZXJ5LmV4dGVuZCh0cnVlKSwgYnV0IHRoaXMgaGFkIHR3byBsaW1pdGF0aW9ucy5cblx0ICogRmlyc3QsIGl0IGRlZXAgbWVyZ2VkIGFycmF5cywgd2hpY2ggbGVhZCB0byB3b3JrYXJvdW5kcyBpbiBIaWdoY2hhcnRzLiBTZWNvbmQsXG5cdCAqIGl0IGNvcGllZCBwcm9wZXJ0aWVzIGZyb20gZXh0ZW5kZWQgcHJvdG90eXBlcy4gXG5cdCAqL1xuXHRmdW5jdGlvbiBtZXJnZSgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRsZW4sXG5cdFx0XHRyZXQgPSB7fSxcblx0XHRcdGRvQ29weSA9IGZ1bmN0aW9uIChjb3B5LCBvcmlnaW5hbCkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleTtcblxuXHRcdFx0XHQvLyBBbiBvYmplY3QgaXMgcmVwbGFjaW5nIGEgcHJpbWl0aXZlXG5cdFx0XHRcdGlmICh0eXBlb2YgY29weSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGtleSBpbiBvcmlnaW5hbCkge1xuXHRcdFx0XHRcdGlmIChvcmlnaW5hbC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG9yaWdpbmFsW2tleV07XG5cblx0XHRcdFx0XHRcdC8vIENvcHkgdGhlIGNvbnRlbnRzIG9mIG9iamVjdHMsIGJ1dCBub3QgYXJyYXlzIG9yIERPTSBub2Rlc1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0XHRcdFx0XHRcdGtleSAhPT0gJ3JlbmRlclRvJyAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlba2V5XSA9IGRvQ29weShjb3B5W2tleV0gfHwge30sIHZhbHVlKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIFByaW1pdGl2ZXMgYW5kIGFycmF5cyBhcmUgY29waWVkIG92ZXIgZGlyZWN0bHlcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlba2V5XSA9IG9yaWdpbmFsW2tleV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb3B5O1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIHRydWUsIGNvcHkgaW50byB0aGUgZXhpc3Rpbmcgb2JqZWN0LiBVc2VkIGluIHNldE9wdGlvbnMuXG5cdFx0aWYgKGFyZ3NbMF0gPT09IHRydWUpIHtcblx0XHRcdHJldCA9IGFyZ3NbMV07XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMik7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yIGVhY2ggYXJndW1lbnQsIGV4dGVuZCB0aGUgcmV0dXJuXG5cdFx0bGVuID0gYXJncy5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRyZXQgPSBkb0NvcHkocmV0LCBhcmdzW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IGZvciBwYXJzZUludFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbWFnIE1hZ25pdHVkZVxuXHQgKi9cblx0ZnVuY3Rpb24gcEludChzLCBtYWcpIHtcblx0XHRyZXR1cm4gcGFyc2VJbnQocywgbWFnIHx8IDEwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBmb3Igc3RyaW5nXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1N0cmluZyhzKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBmb3Igb2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuXHRcdHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgZm9yIGFycmF5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICovXG5cdGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGZvciBudW1iZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IG5cblx0ICovXG5cdGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcblx0XHRyZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9nMmxpbihudW0pIHtcblx0XHRyZXR1cm4gbWF0aC5sb2cobnVtKSAvIG1hdGguTE4xMDtcblx0fVxuXHRmdW5jdGlvbiBsaW4ybG9nKG51bSkge1xuXHRcdHJldHVybiBtYXRoLnBvdygxMCwgbnVtKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgbGFzdCBvY2N1cmVuY2Ugb2YgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyclxuXHQgKiBAcGFyYW0ge01peGVkfSBpdGVtXG5cdCAqL1xuXHRmdW5jdGlvbiBlcmFzZShhcnIsIGl0ZW0pIHtcblx0XHR2YXIgaSA9IGFyci5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0aWYgKGFycltpXSA9PT0gaXRlbSkge1xuXHRcdFx0XHRhcnIuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly9yZXR1cm4gYXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZC4gTGlrZSBNb29Ub29scycgJC5kZWZpbmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWZpbmVkKG9iaikge1xuXHRcdHJldHVybiBvYmogIT09IFVOREVGSU5FRCAmJiBvYmogIT09IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IG9yIGdldCBhbiBhdHRyaWJ1dGUgb3IgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMuIENhbid0IHVzZSBqUXVlcnkgYXR0ciBiZWNhdXNlXG5cdCAqIGl0IGF0dGVtcHRzIHRvIHNldCBleHBhbmRvIHByb3BlcnRpZXMgb24gdGhlIFNWRyBlbGVtZW50LCB3aGljaCBpcyBub3QgYWxsb3dlZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGVsZW0gVGhlIERPTSBlbGVtZW50IHRvIHJlY2VpdmUgdGhlIGF0dHJpYnV0ZShzKVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3AgVGhlIHByb3BlcnR5IG9yIGFuIGFiamVjdCBvZiBrZXktdmFsdWUgcGFpcnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSBpZiBhIHNpbmdsZSBwcm9wZXJ0eSBpcyBzZXRcblx0ICovXG5cdGZ1bmN0aW9uIGF0dHIoZWxlbSwgcHJvcCwgdmFsdWUpIHtcblx0XHR2YXIga2V5LFxuXHRcdFx0cmV0O1xuXG5cdFx0Ly8gaWYgdGhlIHByb3AgaXMgYSBzdHJpbmdcblx0XHRpZiAoaXNTdHJpbmcocHJvcCkpIHtcblx0XHRcdC8vIHNldCB0aGUgdmFsdWVcblx0XHRcdGlmIChkZWZpbmVkKHZhbHVlKSkge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG5cblx0XHRcdC8vIGdldCB0aGUgdmFsdWVcblx0XHRcdH0gZWxzZSBpZiAoZWxlbSAmJiBlbGVtLmdldEF0dHJpYnV0ZSkgeyAvLyBlbGVtIG5vdCBkZWZpbmVkIHdoZW4gcHJpbnRpbmcgcGllIGRlbW8uLi5cblx0XHRcdFx0cmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGUocHJvcCk7XG5cdFx0XHR9XG5cblx0XHQvLyBlbHNlIGlmIHByb3AgaXMgZGVmaW5lZCwgaXQgaXMgYSBoYXNoIG9mIGtleS92YWx1ZSBwYWlyc1xuXHRcdH0gZWxzZSBpZiAoZGVmaW5lZChwcm9wKSAmJiBpc09iamVjdChwcm9wKSkge1xuXHRcdFx0Zm9yIChrZXkgaW4gcHJvcCkge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZShrZXksIHByb3Bba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH1cblx0LyoqXG5cdCAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYW4gYXJyYXksIGFuZCBpZiBub3QsIG1ha2UgaXQgaW50byBhbiBhcnJheS4gTGlrZVxuXHQgKiBNb29Ub29scycgJC5zcGxhdC5cblx0ICovXG5cdGZ1bmN0aW9uIHNwbGF0KG9iaikge1xuXHRcdHJldHVybiBpc0FycmF5KG9iaikgPyBvYmogOiBbb2JqXTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgdGhhdCBpcyBkZWZpbmVkLiBMaWtlIE1vb1Rvb2xzJyAkLnBpY2suXG5cdCAqL1xuXHR2YXIgcGljayA9IEhpZ2hjaGFydHMucGljayA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdGksXG5cdFx0XHRhcmcsXG5cdFx0XHRsZW5ndGggPSBhcmdzLmxlbmd0aDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGFyZyA9IGFyZ3NbaV07XG5cdFx0XHRpZiAoYXJnICE9PSBVTkRFRklORUQgJiYgYXJnICE9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBhcmc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgQ1NTIG9uIGEgZ2l2ZW4gZWxlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZWxcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBTdHlsZSBvYmplY3Qgd2l0aCBjYW1lbCBjYXNlIHByb3BlcnR5IG5hbWVzXG5cdCAqL1xuXHRmdW5jdGlvbiBjc3MoZWwsIHN0eWxlcykge1xuXHRcdGlmIChpc0lFICYmICFoYXNTVkcpIHsgLy8gIzI2ODZcblx0XHRcdGlmIChzdHlsZXMgJiYgc3R5bGVzLm9wYWNpdHkgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRzdHlsZXMuZmlsdGVyID0gJ2FscGhhKG9wYWNpdHk9JyArIChzdHlsZXMub3BhY2l0eSAqIDEwMCkgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV4dGVuZChlbC5zdHlsZSwgc3R5bGVzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBlbGVtZW50IHdpdGggYXR0cmlidXRlcyBhbmQgc3R5bGVzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnNcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBub3BhZFxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJpYnMsIHN0eWxlcywgcGFyZW50LCBub3BhZCkge1xuXHRcdHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG5cdFx0aWYgKGF0dHJpYnMpIHtcblx0XHRcdGV4dGVuZChlbCwgYXR0cmlicyk7XG5cdFx0fVxuXHRcdGlmIChub3BhZCkge1xuXHRcdFx0Y3NzKGVsLCB7cGFkZGluZzogMCwgYm9yZGVyOiBOT05FLCBtYXJnaW46IDB9KTtcblx0XHR9XG5cdFx0aWYgKHN0eWxlcykge1xuXHRcdFx0Y3NzKGVsLCBzdHlsZXMpO1xuXHRcdH1cblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gZWw7XG5cdH1cblxuXHQvKipcblx0ICogRXh0ZW5kIGEgcHJvdG90eXBlZCBjbGFzcyBieSBuZXcgbWVtYmVyc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtZW1iZXJzXG5cdCAqL1xuXHRmdW5jdGlvbiBleHRlbmRDbGFzcyhwYXJlbnQsIG1lbWJlcnMpIHtcblx0XHR2YXIgb2JqZWN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gVU5ERUZJTkVEOyB9O1xuXHRcdG9iamVjdC5wcm90b3R5cGUgPSBuZXcgcGFyZW50KCk7XG5cdFx0ZXh0ZW5kKG9iamVjdC5wcm90b3R5cGUsIG1lbWJlcnMpO1xuXHRcdHJldHVybiBvYmplY3Q7XG5cdH1cblxuXHQvKipcblx0ICogUGFkIGEgc3RyaW5nIHRvIGEgZ2l2ZW4gbGVuZ3RoIGJ5IGFkZGluZyAwIHRvIHRoZSBiZWdpbm5pbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG5cdCAqL1xuXHRmdW5jdGlvbiBwYWQobnVtYmVyLCBsZW5ndGgpIHtcblx0XHQvLyBDcmVhdGUgYW4gYXJyYXkgb2YgdGhlIHJlbWFpbmluZyBsZW5ndGggKzEgYW5kIGpvaW4gaXQgd2l0aCAwJ3Ncblx0XHRyZXR1cm4gbmV3IEFycmF5KChsZW5ndGggfHwgMikgKyAxIC0gU3RyaW5nKG51bWJlcikubGVuZ3RoKS5qb2luKDApICsgbnVtYmVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyYXAgYSBtZXRob2Qgd2l0aCBleHRlbmRlZCBmdW5jdGlvbmFsaXR5LCBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBjb250ZXh0IG9iamVjdCB0aGF0IHRoZSBtZXRob2QgYmVsb25ncyB0byBcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGV4dGVuZFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIEEgd3JhcHBlciBmdW5jdGlvbiBjYWxsYmFjay4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcblx0ICogYXMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLCBleGNlcHQgdGhhdCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaXMgdW5zaGlmdGVkIGFuZCBwYXNzZWQgYXMgdGhlIGZpcnN0IFxuXHQgKiBhcmd1bWVudC4gXG5cdCAqL1xuXHR2YXIgd3JhcCA9IEhpZ2hjaGFydHMud3JhcCA9IGZ1bmN0aW9uIChvYmosIG1ldGhvZCwgZnVuYykge1xuXHRcdHZhciBwcm9jZWVkID0gb2JqW21ldGhvZF07XG5cdFx0b2JqW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRhcmdzLnVuc2hpZnQocHJvY2VlZCk7XG5cdFx0XHRyZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9O1xuXHR9O1xuXG5cblx0ZnVuY3Rpb24gZ2V0VFpPZmZzZXQodGltZXN0YW1wKSB7XG5cdFx0cmV0dXJuICgoZ2V0VGltZXpvbmVPZmZzZXQgJiYgZ2V0VGltZXpvbmVPZmZzZXQodGltZXN0YW1wKSkgfHwgdGltZXpvbmVPZmZzZXQgfHwgMCkgKiA2MDAwMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBCYXNlZCBvbiBodHRwOi8vd3d3LnBocC5uZXQvbWFudWFsL2VuL2Z1bmN0aW9uLnN0cmZ0aW1lLnBocFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXBcblx0ICogQHBhcmFtIHtCb29sZWFufSBjYXBpdGFsaXplXG5cdCAqL1xuXHRkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCwgdGltZXN0YW1wLCBjYXBpdGFsaXplKSB7XG5cdFx0aWYgKCFkZWZpbmVkKHRpbWVzdGFtcCkgfHwgaXNOYU4odGltZXN0YW1wKSkge1xuXHRcdFx0cmV0dXJuICdJbnZhbGlkIGRhdGUnO1xuXHRcdH1cblx0XHRmb3JtYXQgPSBwaWNrKGZvcm1hdCwgJyVZLSVtLSVkICVIOiVNOiVTJyk7XG5cblx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCAtIGdldFRaT2Zmc2V0KHRpbWVzdGFtcCkpLFxuXHRcdFx0a2V5LCAvLyB1c2VkIGluIGZvciBjb25zdHVjdCBiZWxvd1xuXHRcdFx0Ly8gZ2V0IHRoZSBiYXNpYyB0aW1lIHZhbHVlc1xuXHRcdFx0aG91cnMgPSBkYXRlW2dldEhvdXJzXSgpLFxuXHRcdFx0ZGF5ID0gZGF0ZVtnZXREYXldKCksXG5cdFx0XHRkYXlPZk1vbnRoID0gZGF0ZVtnZXREYXRlXSgpLFxuXHRcdFx0bW9udGggPSBkYXRlW2dldE1vbnRoXSgpLFxuXHRcdFx0ZnVsbFllYXIgPSBkYXRlW2dldEZ1bGxZZWFyXSgpLFxuXHRcdFx0bGFuZyA9IGRlZmF1bHRPcHRpb25zLmxhbmcsXG5cdFx0XHRsYW5nV2Vla2RheXMgPSBsYW5nLndlZWtkYXlzLFxuXG5cdFx0XHQvLyBMaXN0IGFsbCBmb3JtYXQga2V5cy4gQ3VzdG9tIGZvcm1hdHMgY2FuIGJlIGFkZGVkIGZyb20gdGhlIG91dHNpZGUuIFxuXHRcdFx0cmVwbGFjZW1lbnRzID0gZXh0ZW5kKHtcblxuXHRcdFx0XHQvLyBEYXlcblx0XHRcdFx0J2EnOiBsYW5nV2Vla2RheXNbZGF5XS5zdWJzdHIoMCwgMyksIC8vIFNob3J0IHdlZWtkYXksIGxpa2UgJ01vbidcblx0XHRcdFx0J0EnOiBsYW5nV2Vla2RheXNbZGF5XSwgLy8gTG9uZyB3ZWVrZGF5LCBsaWtlICdNb25kYXknXG5cdFx0XHRcdCdkJzogcGFkKGRheU9mTW9udGgpLCAvLyBUd28gZGlnaXQgZGF5IG9mIHRoZSBtb250aCwgMDEgdG8gMzFcblx0XHRcdFx0J2UnOiBkYXlPZk1vbnRoLCAvLyBEYXkgb2YgdGhlIG1vbnRoLCAxIHRocm91Z2ggMzFcblx0XHRcdFx0J3cnOiBkYXksXG5cblx0XHRcdFx0Ly8gV2VlayAobm9uZSBpbXBsZW1lbnRlZClcblx0XHRcdFx0Ly8nVyc6IHdlZWtOdW1iZXIoKSxcblxuXHRcdFx0XHQvLyBNb250aFxuXHRcdFx0XHQnYic6IGxhbmcuc2hvcnRNb250aHNbbW9udGhdLCAvLyBTaG9ydCBtb250aCwgbGlrZSAnSmFuJ1xuXHRcdFx0XHQnQic6IGxhbmcubW9udGhzW21vbnRoXSwgLy8gTG9uZyBtb250aCwgbGlrZSAnSmFudWFyeSdcblx0XHRcdFx0J20nOiBwYWQobW9udGggKyAxKSwgLy8gVHdvIGRpZ2l0IG1vbnRoIG51bWJlciwgMDEgdGhyb3VnaCAxMlxuXG5cdFx0XHRcdC8vIFllYXJcblx0XHRcdFx0J3knOiBmdWxsWWVhci50b1N0cmluZygpLnN1YnN0cigyLCAyKSwgLy8gVHdvIGRpZ2l0cyB5ZWFyLCBsaWtlIDA5IGZvciAyMDA5XG5cdFx0XHRcdCdZJzogZnVsbFllYXIsIC8vIEZvdXIgZGlnaXRzIHllYXIsIGxpa2UgMjAwOVxuXG5cdFx0XHRcdC8vIFRpbWVcblx0XHRcdFx0J0gnOiBwYWQoaG91cnMpLCAvLyBUd28gZGlnaXRzIGhvdXJzIGluIDI0aCBmb3JtYXQsIDAwIHRocm91Z2ggMjNcblx0XHRcdFx0J0knOiBwYWQoKGhvdXJzICUgMTIpIHx8IDEyKSwgLy8gVHdvIGRpZ2l0cyBob3VycyBpbiAxMmggZm9ybWF0LCAwMCB0aHJvdWdoIDExXG5cdFx0XHRcdCdsJzogKGhvdXJzICUgMTIpIHx8IDEyLCAvLyBIb3VycyBpbiAxMmggZm9ybWF0LCAxIHRocm91Z2ggMTJcblx0XHRcdFx0J00nOiBwYWQoZGF0ZVtnZXRNaW51dGVzXSgpKSwgLy8gVHdvIGRpZ2l0cyBtaW51dGVzLCAwMCB0aHJvdWdoIDU5XG5cdFx0XHRcdCdwJzogaG91cnMgPCAxMiA/ICdBTScgOiAnUE0nLCAvLyBVcHBlciBjYXNlIEFNIG9yIFBNXG5cdFx0XHRcdCdQJzogaG91cnMgPCAxMiA/ICdhbScgOiAncG0nLCAvLyBMb3dlciBjYXNlIEFNIG9yIFBNXG5cdFx0XHRcdCdTJzogcGFkKGRhdGUuZ2V0U2Vjb25kcygpKSwgLy8gVHdvIGRpZ2l0cyBzZWNvbmRzLCAwMCB0aHJvdWdoICA1OVxuXHRcdFx0XHQnTCc6IHBhZChtYXRoUm91bmQodGltZXN0YW1wICUgMTAwMCksIDMpIC8vIE1pbGxpc2Vjb25kcyAobmFtaW5nIGZyb20gUnVieSlcblx0XHRcdH0sIEhpZ2hjaGFydHMuZGF0ZUZvcm1hdHMpO1xuXG5cblx0XHQvLyBkbyB0aGUgcmVwbGFjZXNcblx0XHRmb3IgKGtleSBpbiByZXBsYWNlbWVudHMpIHtcblx0XHRcdHdoaWxlIChmb3JtYXQuaW5kZXhPZignJScgKyBrZXkpICE9PSAtMSkgeyAvLyByZWdleCB3b3VsZCBkbyBpdCBpbiBvbmUgbGluZSwgYnV0IHRoaXMgaXMgZmFzdGVyXG5cdFx0XHRcdGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCclJyArIGtleSwgdHlwZW9mIHJlcGxhY2VtZW50c1trZXldID09PSAnZnVuY3Rpb24nID8gcmVwbGFjZW1lbnRzW2tleV0odGltZXN0YW1wKSA6IHJlcGxhY2VtZW50c1trZXldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPcHRpb25hbGx5IGNhcGl0YWxpemUgdGhlIHN0cmluZyBhbmQgcmV0dXJuXG5cdFx0cmV0dXJuIGNhcGl0YWxpemUgPyBmb3JtYXQuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBmb3JtYXQuc3Vic3RyKDEpIDogZm9ybWF0O1xuXHR9O1xuXG5cdC8qKiBcblx0ICogRm9ybWF0IGEgc2luZ2xlIHZhcmlhYmxlLiBTaW1pbGFyIHRvIHNwcmludGYsIHdpdGhvdXQgdGhlICUgcHJlZml4LlxuXHQgKi9cblx0ZnVuY3Rpb24gZm9ybWF0U2luZ2xlKGZvcm1hdCwgdmFsKSB7XG5cdFx0dmFyIGZsb2F0UmVnZXggPSAvZiQvLFxuXHRcdFx0ZGVjUmVnZXggPSAvXFwuKFswLTldKS8sXG5cdFx0XHRsYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZyxcblx0XHRcdGRlY2ltYWxzO1xuXG5cdFx0aWYgKGZsb2F0UmVnZXgudGVzdChmb3JtYXQpKSB7IC8vIGZsb2F0XG5cdFx0XHRkZWNpbWFscyA9IGZvcm1hdC5tYXRjaChkZWNSZWdleCk7XG5cdFx0XHRkZWNpbWFscyA9IGRlY2ltYWxzID8gZGVjaW1hbHNbMV0gOiAtMTtcblx0XHRcdGlmICh2YWwgIT09IG51bGwpIHtcblx0XHRcdFx0dmFsID0gSGlnaGNoYXJ0cy5udW1iZXJGb3JtYXQoXG5cdFx0XHRcdFx0dmFsLFxuXHRcdFx0XHRcdGRlY2ltYWxzLFxuXHRcdFx0XHRcdGxhbmcuZGVjaW1hbFBvaW50LFxuXHRcdFx0XHRcdGZvcm1hdC5pbmRleE9mKCcsJykgPiAtMSA/IGxhbmcudGhvdXNhbmRzU2VwIDogJydcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsID0gZGF0ZUZvcm1hdChmb3JtYXQsIHZhbCk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0ICogRm9ybWF0IGEgc3RyaW5nIGFjY29yZGluZyB0byBhIHN1YnNldCBvZiB0aGUgcnVsZXMgb2YgUHl0aG9uJ3MgU3RyaW5nLmZvcm1hdCBtZXRob2QuXG5cdCAqL1xuXHRmdW5jdGlvbiBmb3JtYXQoc3RyLCBjdHgpIHtcblx0XHR2YXIgc3BsaXR0ZXIgPSAneycsXG5cdFx0XHRpc0luc2lkZSA9IGZhbHNlLFxuXHRcdFx0c2VnbWVudCxcblx0XHRcdHZhbHVlQW5kRm9ybWF0LFxuXHRcdFx0cGF0aCxcblx0XHRcdGksXG5cdFx0XHRsZW4sXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHZhbCxcblx0XHRcdGluZGV4O1xuXHRcdFxuXHRcdHdoaWxlICgoaW5kZXggPSBzdHIuaW5kZXhPZihzcGxpdHRlcikpICE9PSAtMSkge1xuXHRcdFx0XG5cdFx0XHRzZWdtZW50ID0gc3RyLnNsaWNlKDAsIGluZGV4KTtcblx0XHRcdGlmIChpc0luc2lkZSkgeyAvLyB3ZSdyZSBvbiB0aGUgY2xvc2luZyBicmFja2V0IGxvb2tpbmcgYmFja1xuXHRcdFx0XHRcblx0XHRcdFx0dmFsdWVBbmRGb3JtYXQgPSBzZWdtZW50LnNwbGl0KCc6Jyk7XG5cdFx0XHRcdHBhdGggPSB2YWx1ZUFuZEZvcm1hdC5zaGlmdCgpLnNwbGl0KCcuJyk7IC8vIGdldCBmaXJzdCBhbmQgbGVhdmUgZm9ybWF0XG5cdFx0XHRcdGxlbiA9IHBhdGgubGVuZ3RoO1xuXHRcdFx0XHR2YWwgPSBjdHg7XG5cblx0XHRcdFx0Ly8gQXNzaWduIGRlZXBlciBwYXRoc1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHR2YWwgPSB2YWxbcGF0aFtpXV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JtYXQgdGhlIHJlcGxhY2VtZW50XG5cdFx0XHRcdGlmICh2YWx1ZUFuZEZvcm1hdC5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YWwgPSBmb3JtYXRTaW5nbGUodmFsdWVBbmRGb3JtYXQuam9pbignOicpLCB2YWwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHVzaCB0aGUgcmVzdWx0IGFuZCBhZHZhbmNlIHRoZSBjdXJzb3Jcblx0XHRcdFx0cmV0LnB1c2godmFsKTtcblx0XHRcdFx0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXQucHVzaChzZWdtZW50KTtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRzdHIgPSBzdHIuc2xpY2UoaW5kZXggKyAxKTsgLy8gdGhlIHJlc3Rcblx0XHRcdGlzSW5zaWRlID0gIWlzSW5zaWRlOyAvLyB0b2dnbGVcblx0XHRcdHNwbGl0dGVyID0gaXNJbnNpZGUgPyAnfScgOiAneyc7IC8vIG5vdyBsb29rIGZvciBuZXh0IG1hdGNoaW5nIGJyYWNrZXRcblx0XHR9XG5cdFx0cmV0LnB1c2goc3RyKTtcblx0XHRyZXR1cm4gcmV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbWFnbml0dWRlIG9mIGEgbnVtYmVyXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRNYWduaXR1ZGUobnVtKSB7XG5cdFx0cmV0dXJuIG1hdGgucG93KDEwLCBtYXRoRmxvb3IobWF0aC5sb2cobnVtKSAvIG1hdGguTE4xMCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRha2UgYW4gaW50ZXJ2YWwgYW5kIG5vcm1hbGl6ZSBpdCB0byBtdWx0aXBsZXMgb2YgMSwgMiwgMi41IGFuZCA1XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBtdWx0aXBsZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1hZ25pdHVkZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplVGlja0ludGVydmFsKGludGVydmFsLCBtdWx0aXBsZXMsIG1hZ25pdHVkZSwgYWxsb3dEZWNpbWFscywgcHJldmVudEV4Y2VlZCkge1xuXHRcdHZhciBub3JtYWxpemVkLCBcblx0XHRcdGksXG5cdFx0XHRyZXRJbnRlcnZhbCA9IGludGVydmFsO1xuXG5cdFx0Ly8gcm91bmQgdG8gYSB0ZW5mb2xkIG9mIDEsIDIsIDIuNSBvciA1XG5cdFx0bWFnbml0dWRlID0gcGljayhtYWduaXR1ZGUsIDEpO1xuXHRcdG5vcm1hbGl6ZWQgPSBpbnRlcnZhbCAvIG1hZ25pdHVkZTtcblxuXHRcdC8vIG11bHRpcGxlcyBmb3IgYSBsaW5lYXIgc2NhbGVcblx0XHRpZiAoIW11bHRpcGxlcykge1xuXHRcdFx0bXVsdGlwbGVzID0gWzEsIDIsIDIuNSwgNSwgMTBdO1xuXG5cdFx0XHQvLyB0aGUgYWxsb3dEZWNpbWFscyBvcHRpb25cblx0XHRcdGlmIChhbGxvd0RlY2ltYWxzID09PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAobWFnbml0dWRlID09PSAxKSB7XG5cdFx0XHRcdFx0bXVsdGlwbGVzID0gWzEsIDIsIDUsIDEwXTtcblx0XHRcdFx0fSBlbHNlIGlmIChtYWduaXR1ZGUgPD0gMC4xKSB7XG5cdFx0XHRcdFx0bXVsdGlwbGVzID0gWzEgLyBtYWduaXR1ZGVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbm9ybWFsaXplIHRoZSBpbnRlcnZhbCB0byB0aGUgbmVhcmVzdCBtdWx0aXBsZVxuXHRcdGZvciAoaSA9IDA7IGkgPCBtdWx0aXBsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJldEludGVydmFsID0gbXVsdGlwbGVzW2ldO1xuXHRcdFx0aWYgKChwcmV2ZW50RXhjZWVkICYmIHJldEludGVydmFsICogbWFnbml0dWRlID49IGludGVydmFsKSB8fCAvLyBvbmx5IGFsbG93IHRpY2sgYW1vdW50cyBzbWFsbGVyIHRoYW4gbmF0dXJhbFxuXHRcdFx0XHQoIXByZXZlbnRFeGNlZWQgJiYgKG5vcm1hbGl6ZWQgPD0gKG11bHRpcGxlc1tpXSArIChtdWx0aXBsZXNbaSArIDFdIHx8IG11bHRpcGxlc1tpXSkpIC8gMikpKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG11bHRpcGx5IGJhY2sgdG8gdGhlIGNvcnJlY3QgbWFnbml0dWRlXG5cdFx0cmV0SW50ZXJ2YWwgKj0gbWFnbml0dWRlO1xuXHRcdFxuXHRcdHJldHVybiByZXRJbnRlcnZhbDtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgbWV0aG9kIHRoYXQgc29ydHMgYW4gb2JqZWN0IGFycmF5IGFuZCBrZWVwaW5nIHRoZSBvcmRlciBvZiBlcXVhbCBpdGVtcy5cblx0ICogRUNNQSBzY3JpcHQgc3RhbmRhcmQgZG9lcyBub3Qgc3BlY2lmeSB0aGUgYmVoYXZpb3VyIHdoZW4gaXRlbXMgYXJlIGVxdWFsLlxuXHQgKi9cblx0ZnVuY3Rpb24gc3RhYmxlU29ydChhcnIsIHNvcnRGdW5jdGlvbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnIubGVuZ3RoLFxuXHRcdFx0c29ydFZhbHVlLFxuXHRcdFx0aTtcblxuXHRcdC8vIEFkZCBpbmRleCB0byBlYWNoIGl0ZW1cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGFycltpXS5zc19pID0gaTsgLy8gc3RhYmxlIHNvcnQgaW5kZXhcblx0XHR9XG5cblx0XHRhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0c29ydFZhbHVlID0gc29ydEZ1bmN0aW9uKGEsIGIpO1xuXHRcdFx0cmV0dXJuIHNvcnRWYWx1ZSA9PT0gMCA/IGEuc3NfaSAtIGIuc3NfaSA6IHNvcnRWYWx1ZTtcblx0XHR9KTtcblxuXHRcdC8vIFJlbW92ZSBpbmRleCBmcm9tIGl0ZW1zXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkZWxldGUgYXJyW2ldLnNzX2k7IC8vIHN0YWJsZSBzb3J0IGluZGV4XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE5vbi1yZWN1cnNpdmUgbWV0aG9kIHRvIGZpbmQgdGhlIGxvd2VzdCBtZW1iZXIgb2YgYW4gYXJyYXkuIE1hdGgubWluIHJhaXNlcyBhIG1heGltdW1cblx0ICogY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkIGVycm9yIGluIENocm9tZSB3aGVuIHRyeWluZyB0byBhcHBseSBtb3JlIHRoYW4gMTUwLjAwMCBwb2ludHMuIFRoaXNcblx0ICogbWV0aG9kIGlzIHNsaWdodGx5IHNsb3dlciwgYnV0IHNhZmUuXG5cdCAqL1xuXHRmdW5jdGlvbiBhcnJheU1pbihkYXRhKSB7XG5cdFx0dmFyIGkgPSBkYXRhLmxlbmd0aCxcblx0XHRcdG1pbiA9IGRhdGFbMF07XG5cblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAoZGF0YVtpXSA8IG1pbikge1xuXHRcdFx0XHRtaW4gPSBkYXRhW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWluO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vbi1yZWN1cnNpdmUgbWV0aG9kIHRvIGZpbmQgdGhlIGxvd2VzdCBtZW1iZXIgb2YgYW4gYXJyYXkuIE1hdGgubWluIHJhaXNlcyBhIG1heGltdW1cblx0ICogY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkIGVycm9yIGluIENocm9tZSB3aGVuIHRyeWluZyB0byBhcHBseSBtb3JlIHRoYW4gMTUwLjAwMCBwb2ludHMuIFRoaXNcblx0ICogbWV0aG9kIGlzIHNsaWdodGx5IHNsb3dlciwgYnV0IHNhZmUuXG5cdCAqL1xuXHRmdW5jdGlvbiBhcnJheU1heChkYXRhKSB7XG5cdFx0dmFyIGkgPSBkYXRhLmxlbmd0aCxcblx0XHRcdG1heCA9IGRhdGFbMF07XG5cblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAoZGF0YVtpXSA+IG1heCkge1xuXHRcdFx0XHRtYXggPSBkYXRhW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF4O1xuXHR9XG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgbWV0aG9kIHRoYXQgZGVzdHJveXMgYW55IFNWR0VsZW1lbnQgb3IgVk1MRWxlbWVudCB0aGF0IGFyZSBwcm9wZXJ0aWVzIG9uIHRoZSBnaXZlbiBvYmplY3QuXG5cdCAqIEl0IGxvb3BzIGFsbCBwcm9wZXJ0aWVzIGFuZCBpbnZva2VzIGRlc3Ryb3kgaWYgdGhlcmUgaXMgYSBkZXN0cm95IG1ldGhvZC4gVGhlIHByb3BlcnR5IGlzXG5cdCAqIHRoZW4gZGVsZXRlJ2VkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gVGhlIG9iamVjdCB0byBkZXN0cm95IHByb3BlcnRpZXMgb25cblx0ICogQHBhcmFtIHtPYmplY3R9IEV4Y2VwdGlvbiwgZG8gbm90IGRlc3Ryb3kgdGhpcyBwcm9wZXJ0eSwgb25seSBkZWxldGUgaXQuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZXN0cm95T2JqZWN0UHJvcGVydGllcyhvYmosIGV4Y2VwdCkge1xuXHRcdHZhciBuO1xuXHRcdGZvciAobiBpbiBvYmopIHtcblx0XHRcdC8vIElmIHRoZSBvYmplY3QgaXMgbm9uLW51bGwgYW5kIGRlc3Ryb3kgaXMgZGVmaW5lZFxuXHRcdFx0aWYgKG9ialtuXSAmJiBvYmpbbl0gIT09IGV4Y2VwdCAmJiBvYmpbbl0uZGVzdHJveSkge1xuXHRcdFx0XHQvLyBJbnZva2UgdGhlIGRlc3Ryb3lcblx0XHRcdFx0b2JqW25dLmRlc3Ryb3koKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVsZXRlIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBvYmplY3QuXG5cdFx0XHRkZWxldGUgb2JqW25dO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIERpc2NhcmQgYW4gZWxlbWVudCBieSBtb3ZpbmcgaXQgdG8gdGhlIGJpbiBhbmQgZGVsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgSFRNTCBub2RlIHRvIGRpc2NhcmRcblx0ICovXG5cdGZ1bmN0aW9uIGRpc2NhcmRFbGVtZW50KGVsZW1lbnQpIHtcblx0XHQvLyBjcmVhdGUgYSBnYXJiYWdlIGJpbiBlbGVtZW50LCBub3QgcGFydCBvZiB0aGUgRE9NXG5cdFx0aWYgKCFnYXJiYWdlQmluKSB7XG5cdFx0XHRnYXJiYWdlQmluID0gY3JlYXRlRWxlbWVudChESVYpO1xuXHRcdH1cblxuXHRcdC8vIG1vdmUgdGhlIG5vZGUgYW5kIGVtcHR5IGJpblxuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRnYXJiYWdlQmluLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdH1cblx0XHRnYXJiYWdlQmluLmlubmVySFRNTCA9ICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb3ZpZGUgZXJyb3IgbWVzc2FnZXMgZm9yIGRlYnVnZ2luZywgd2l0aCBsaW5rcyB0byBvbmxpbmUgZXhwbGFuYXRpb24gXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvciAoY29kZSwgc3RvcCkge1xuXHRcdHZhciBtc2cgPSAnSGlnaGNoYXJ0cyBlcnJvciAjJyArIGNvZGUgKyAnOiB3d3cuaGlnaGNoYXJ0cy5jb20vZXJyb3JzLycgKyBjb2RlO1xuXHRcdGlmIChzdG9wKSB7XG5cdFx0XHR0aHJvdyBtc2c7XG5cdFx0fVxuXHRcdC8vIGVsc2UgLi4uXG5cdFx0aWYgKHdpbi5jb25zb2xlKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhtc2cpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBGaXggSlMgcm91bmQgb2ZmIGZsb2F0IGVycm9yc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtXG5cdCAqL1xuXHRmdW5jdGlvbiBjb3JyZWN0RmxvYXQobnVtKSB7XG5cdFx0cmV0dXJuIHBhcnNlRmxvYXQoXG5cdFx0XHRudW0udG9QcmVjaXNpb24oMTQpXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGdsb2JhbCBhbmltYXRpb24gdG8gZWl0aGVyIGEgZ2l2ZW4gdmFsdWUsIG9yIGZhbGwgYmFjayB0byB0aGVcblx0ICogZ2l2ZW4gY2hhcnQncyBhbmltYXRpb24gb3B0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0XG5cdCAqL1xuXHRmdW5jdGlvbiBzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCkge1xuXHRcdGdsb2JhbEFuaW1hdGlvbiA9IHBpY2soYW5pbWF0aW9uLCBjaGFydC5hbmltYXRpb24pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSB0aW1lIHVuaXQgbG9va3VwXG5cdCAqL1xuXHR0aW1lVW5pdHMgPSB7XG5cdFx0bWlsbGlzZWNvbmQ6IDEsXG5cdFx0c2Vjb25kOiAxMDAwLFxuXHRcdG1pbnV0ZTogNjAwMDAsXG5cdFx0aG91cjogMzYwMDAwMCxcblx0XHRkYXk6IDI0ICogMzYwMDAwMCxcblx0XHR3ZWVrOiA3ICogMjQgKiAzNjAwMDAwLFxuXHRcdG1vbnRoOiAyOCAqIDI0ICogMzYwMDAwMCxcblx0XHR5ZWFyOiAzNjQgKiAyNCAqIDM2MDAwMDBcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGb3JtYXQgYSBudW1iZXIgYW5kIHJldHVybiBhIHN0cmluZyBiYXNlZCBvbiBpbnB1dCBzZXR0aW5nc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIFRoZSBpbnB1dCBudW1iZXIgdG8gZm9ybWF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWNpbWFscyBUaGUgYW1vdW50IG9mIGRlY2ltYWxzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkZWNQb2ludCBUaGUgZGVjaW1hbCBwb2ludCwgZGVmYXVsdHMgdG8gdGhlIG9uZSBnaXZlbiBpbiB0aGUgbGFuZyBvcHRpb25zXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0aG91c2FuZHNTZXAgVGhlIHRob3VzYW5kcyBzZXBhcmF0b3IsIGRlZmF1bHRzIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gdGhlIGxhbmcgb3B0aW9uc1xuXHQgKi9cblx0SGlnaGNoYXJ0cy5udW1iZXJGb3JtYXQgPSBmdW5jdGlvbiAobnVtYmVyLCBkZWNpbWFscywgZGVjUG9pbnQsIHRob3VzYW5kc1NlcCkge1xuXHRcdHZhciBsYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZyxcblx0XHRcdC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0L3RlY2hibG9nL2FydGljbGUvamF2YXNjcmlwdF9lcXVpdmFsZW50X2Zvcl9waHBzX251bWJlcl9mb3JtYXQvXG5cdFx0XHRuID0gK251bWJlciB8fCAwLFxuXHRcdFx0YyA9IGRlY2ltYWxzID09PSAtMSA/XG5cdFx0XHRcdG1hdGhNaW4oKG4udG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdIHx8ICcnKS5sZW5ndGgsIDIwKSA6IC8vIFByZXNlcnZlIGRlY2ltYWxzLiBOb3QgaHVnZSBudW1iZXJzICgjMzc5MykuXG5cdFx0XHRcdChpc05hTihkZWNpbWFscyA9IG1hdGhBYnMoZGVjaW1hbHMpKSA/IDIgOiBkZWNpbWFscyksXG5cdFx0XHRkID0gZGVjUG9pbnQgPT09IHVuZGVmaW5lZCA/IGxhbmcuZGVjaW1hbFBvaW50IDogZGVjUG9pbnQsXG5cdFx0XHR0ID0gdGhvdXNhbmRzU2VwID09PSB1bmRlZmluZWQgPyBsYW5nLnRob3VzYW5kc1NlcCA6IHRob3VzYW5kc1NlcCxcblx0XHRcdHMgPSBuIDwgMCA/IFwiLVwiIDogXCJcIixcblx0XHRcdGkgPSBTdHJpbmcocEludChuID0gbWF0aEFicyhuKS50b0ZpeGVkKGMpKSksXG5cdFx0XHRqID0gaS5sZW5ndGggPiAzID8gaS5sZW5ndGggJSAzIDogMDtcblxuXHRcdHJldHVybiAocyArIChqID8gaS5zdWJzdHIoMCwgaikgKyB0IDogXCJcIikgKyBpLnN1YnN0cihqKS5yZXBsYWNlKC8oXFxkezN9KSg/PVxcZCkvZywgXCIkMVwiICsgdCkgK1xuXHRcdFx0XHQoYyA/IGQgKyBtYXRoQWJzKG4gLSBpKS50b0ZpeGVkKGMpLnNsaWNlKDIpIDogXCJcIikpO1xuXHR9O1xuXHQvKipcblx0ICogUGF0aCBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobSB1c2VkIGFjcm9zcyBhZGFwdGVyc1xuXHQgKi9cblx0cGF0aEFuaW0gPSB7XG5cdFx0LyoqXG5cdFx0ICogUHJlcGFyZSBzdGFydCBhbmQgZW5kIHZhbHVlcyBzbyB0aGF0IHRoZSBwYXRoIGNhbiBiZSBhbmltYXRlZCBvbmUgdG8gb25lXG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKGVsZW0sIGZyb21ELCB0b0QpIHtcblx0XHRcdGZyb21EID0gZnJvbUQgfHwgJyc7XG5cdFx0XHR2YXIgc2hpZnQgPSBlbGVtLnNoaWZ0LFxuXHRcdFx0XHRiZXppZXIgPSBmcm9tRC5pbmRleE9mKCdDJykgPiAtMSxcblx0XHRcdFx0bnVtUGFyYW1zID0gYmV6aWVyID8gNyA6IDMsXG5cdFx0XHRcdGVuZExlbmd0aCxcblx0XHRcdFx0c2xpY2UsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHN0YXJ0ID0gZnJvbUQuc3BsaXQoJyAnKSxcblx0XHRcdFx0ZW5kID0gW10uY29uY2F0KHRvRCksIC8vIGNvcHlcblx0XHRcdFx0c3RhcnRCYXNlTGluZSxcblx0XHRcdFx0ZW5kQmFzZUxpbmUsXG5cdFx0XHRcdHNpeGlmeSA9IGZ1bmN0aW9uIChhcnIpIHsgLy8gaW4gc3BsaW5lcyBtYWtlIG1vdmUgcG9pbnRzIGhhdmUgc2l4IHBhcmFtZXRlcnMgbGlrZSBiZXppZXIgY3VydmVzXG5cdFx0XHRcdFx0aSA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdFx0aWYgKGFycltpXSA9PT0gTSkge1xuXHRcdFx0XHRcdFx0XHRhcnIuc3BsaWNlKGkgKyAxLCAwLCBhcnJbaSArIDFdLCBhcnJbaSArIDJdLCBhcnJbaSArIDFdLCBhcnJbaSArIDJdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdGlmIChiZXppZXIpIHtcblx0XHRcdFx0c2l4aWZ5KHN0YXJ0KTtcblx0XHRcdFx0c2l4aWZ5KGVuZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHB1bGwgb3V0IHRoZSBiYXNlIGxpbmVzIGJlZm9yZSBwYWRkaW5nXG5cdFx0XHRpZiAoZWxlbS5pc0FyZWEpIHtcblx0XHRcdFx0c3RhcnRCYXNlTGluZSA9IHN0YXJ0LnNwbGljZShzdGFydC5sZW5ndGggLSA2LCA2KTtcblx0XHRcdFx0ZW5kQmFzZUxpbmUgPSBlbmQuc3BsaWNlKGVuZC5sZW5ndGggLSA2LCA2KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgc2hpZnRpbmcgcG9pbnRzLCBwcmVwZW5kIGEgZHVtbXkgcG9pbnQgdG8gdGhlIGVuZCBwYXRoXG5cdFx0XHRpZiAoc2hpZnQgPD0gZW5kLmxlbmd0aCAvIG51bVBhcmFtcyAmJiBzdGFydC5sZW5ndGggPT09IGVuZC5sZW5ndGgpIHtcblx0XHRcdFx0d2hpbGUgKHNoaWZ0LS0pIHtcblx0XHRcdFx0XHRlbmQgPSBbXS5jb25jYXQoZW5kKS5zcGxpY2UoMCwgbnVtUGFyYW1zKS5jb25jYXQoZW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxlbS5zaGlmdCA9IDA7IC8vIHJlc2V0IGZvciBmb2xsb3dpbmcgYW5pbWF0aW9uc1xuXG5cdFx0XHQvLyBjb3B5IGFuZCBhcHBlbmQgbGFzdCBwb2ludCB1bnRpbCB0aGUgbGVuZ3RoIG1hdGNoZXMgdGhlIGVuZCBsZW5ndGhcblx0XHRcdGlmIChzdGFydC5sZW5ndGgpIHtcblx0XHRcdFx0ZW5kTGVuZ3RoID0gZW5kLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKHN0YXJ0Lmxlbmd0aCA8IGVuZExlbmd0aCkge1xuXG5cdFx0XHRcdFx0Ly9iZXppZXIgJiYgc2l4aWZ5KHN0YXJ0KTtcblx0XHRcdFx0XHRzbGljZSA9IFtdLmNvbmNhdChzdGFydCkuc3BsaWNlKHN0YXJ0Lmxlbmd0aCAtIG51bVBhcmFtcywgbnVtUGFyYW1zKTtcblx0XHRcdFx0XHRpZiAoYmV6aWVyKSB7IC8vIGRpc2FibGUgZmlyc3QgY29udHJvbCBwb2ludFxuXHRcdFx0XHRcdFx0c2xpY2VbbnVtUGFyYW1zIC0gNl0gPSBzbGljZVtudW1QYXJhbXMgLSAyXTtcblx0XHRcdFx0XHRcdHNsaWNlW251bVBhcmFtcyAtIDVdID0gc2xpY2VbbnVtUGFyYW1zIC0gMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQuY29uY2F0KHNsaWNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3RhcnRCYXNlTGluZSkgeyAvLyBhcHBlbmQgdGhlIGJhc2UgbGluZXMgZm9yIGFyZWFzXG5cdFx0XHRcdHN0YXJ0ID0gc3RhcnQuY29uY2F0KHN0YXJ0QmFzZUxpbmUpO1xuXHRcdFx0XHRlbmQgPSBlbmQuY29uY2F0KGVuZEJhc2VMaW5lKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbc3RhcnQsIGVuZF07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEludGVycG9sYXRlIGVhY2ggdmFsdWUgb2YgdGhlIHBhdGggYW5kIHJldHVybiB0aGUgYXJyYXlcblx0XHQgKi9cblx0XHRzdGVwOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcG9zLCBjb21wbGV0ZSkge1xuXHRcdFx0dmFyIHJldCA9IFtdLFxuXHRcdFx0XHRpID0gc3RhcnQubGVuZ3RoLFxuXHRcdFx0XHRzdGFydFZhbDtcblxuXHRcdFx0aWYgKHBvcyA9PT0gMSkgeyAvLyBsYW5kIG9uIHRoZSBmaW5hbCBwYXRoIHdpdGhvdXQgYWRqdXN0bWVudCBwb2ludHMgYXBwZW5kZWQgaW4gdGhlIGVuZHNcblx0XHRcdFx0cmV0ID0gY29tcGxldGU7XG5cblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gZW5kLmxlbmd0aCAmJiBwb3MgPCAxKSB7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRzdGFydFZhbCA9IHBhcnNlRmxvYXQoc3RhcnRbaV0pO1xuXHRcdFx0XHRcdHJldFtpXSA9XG5cdFx0XHRcdFx0XHRpc05hTihzdGFydFZhbCkgPyAvLyBhIGxldHRlciBpbnN0cnVjdGlvbiBsaWtlIE0gb3IgTFxuXHRcdFx0XHRcdFx0XHRzdGFydFtpXSA6XG5cdFx0XHRcdFx0XHRcdHBvcyAqIChwYXJzZUZsb2F0KGVuZFtpXSAtIHN0YXJ0VmFsKSkgKyBzdGFydFZhbDtcblxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgeyAvLyBpZiBhbmltYXRpb24gaXMgZmluaXNoZWQgb3IgbGVuZ3RoIG5vdCBtYXRjaGluZywgbGFuZCBvbiByaWdodCB2YWx1ZVxuXHRcdFx0XHRyZXQgPSBlbmQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcblxuXHQoZnVuY3Rpb24gKCQpIHtcblx0XHQvKipcblx0XHQgKiBUaGUgZGVmYXVsdCBIaWdoY2hhcnRzQWRhcHRlciBmb3IgalF1ZXJ5XG5cdFx0ICovXG5cdFx0d2luLkhpZ2hjaGFydHNBZGFwdGVyID0gd2luLkhpZ2hjaGFydHNBZGFwdGVyIHx8ICgkICYmIHtcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbml0aWFsaXplIHRoZSBhZGFwdGVyIGJ5IGFwcGx5aW5nIHNvbWUgZXh0ZW5zaW9ucyB0byBqUXVlcnlcblx0XHRcdCAqL1xuXHRcdFx0aW5pdDogZnVuY3Rpb24gKHBhdGhBbmltKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBleHRlbmQgdGhlIGFuaW1hdGUgZnVuY3Rpb24gdG8gYWxsb3cgU1ZHIGFuaW1hdGlvbnNcblx0XHRcdFx0dmFyIEZ4ID0gJC5meDtcblx0XHRcdFx0XG5cdFx0XHRcdC8qanNsaW50IHVucGFyYW06IHRydWUqLy8qIGFsbG93IHVudXNlZCBwYXJhbSB4IGluIHRoaXMgZnVuY3Rpb24gKi9cblx0XHRcdFx0JC5leHRlbmQoJC5lYXNpbmcsIHtcblx0XHRcdFx0XHRlYXNlT3V0UXVhZDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcblx0XHRcdFx0XHRcdHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogZmFsc2UqL1xuXHRcdFx0XG5cdFx0XHRcdC8vIGV4dGVuZCBzb21lIG1ldGhvZHMgdG8gY2hlY2sgZm9yIGVsZW0uYXR0ciwgd2hpY2ggbWVhbnMgaXQgaXMgYSBIaWdoY2hhcnRzIFNWRyBvYmplY3Rcblx0XHRcdFx0JC5lYWNoKFsnY3VyJywgJ19kZWZhdWx0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdvcGFjaXR5J10sIGZ1bmN0aW9uIChpLCBmbikge1xuXHRcdFx0XHRcdHZhciBvYmogPSBGeC5zdGVwLFxuXHRcdFx0XHRcdFx0YmFzZTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEhhbmRsZSBkaWZmZXJlbnQgcGFyZW50IG9iamVjdHNcblx0XHRcdFx0XHRpZiAoZm4gPT09ICdjdXInKSB7XG5cdFx0XHRcdFx0XHRvYmogPSBGeC5wcm90b3R5cGU7IC8vICdjdXInLCB0aGUgZ2V0dGVyLCByZWxhdGVzIHRvIEZ4LnByb3RvdHlwZVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZm4gPT09ICdfZGVmYXVsdCcgJiYgJC5Ud2VlbikgeyAvLyBqUXVlcnkgMS44IG1vZGVsXG5cdFx0XHRcdFx0XHRvYmogPSAkLlR3ZWVuLnByb3BIb29rc1tmbl07XG5cdFx0XHRcdFx0XHRmbiA9ICdzZXQnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHRcdC8vIE92ZXJ3cml0ZSB0aGUgbWV0aG9kXG5cdFx0XHRcdFx0YmFzZSA9IG9ialtmbl07XG5cdFx0XHRcdFx0aWYgKGJhc2UpIHsgLy8gc3RlcC53aWR0aCBhbmQgc3RlcC5oZWlnaHQgZG9uJ3QgZXhpc3QgaW4galF1ZXJ5IDwgMS43XG5cdFx0XHRcblx0XHRcdFx0XHRcdC8vIGNyZWF0ZSB0aGUgZXh0ZW5kZWQgZnVuY3Rpb24gcmVwbGFjZW1lbnRcblx0XHRcdFx0XHRcdG9ialtmbl0gPSBmdW5jdGlvbiAoZngpIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZWxlbTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIEZ4LnByb3RvdHlwZS5jdXIgZG9lcyBub3QgdXNlIGZ4IGFyZ3VtZW50XG5cdFx0XHRcdFx0XHRcdGZ4ID0gaSA/IGZ4IDogdGhpcztcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCBydW4gYW5pbWF0aW9ucyBvbiB0ZXh0dWFsIHByb3BlcnRpZXMgbGlrZSBhbGlnbiAoIzE4MjEpXG5cdFx0XHRcdFx0XHRcdGlmIChmeC5wcm9wID09PSAnYWxpZ24nKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gc2hvcnRjdXRcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGZ4LmVsZW07XG5cdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gRngucHJvdG90eXBlLmN1ciByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLiBUaGUgb3RoZXIgb25lcyBhcmUgc2V0dGVyc1xuXHRcdFx0XHRcdFx0XHQvLyBhbmQgcmV0dXJuaW5nIGEgdmFsdWUgaGFzIG5vIGVmZmVjdC5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uYXR0ciA/IC8vIGlzIFNWRyBlbGVtZW50IHdyYXBwZXJcblx0XHRcdFx0XHRcdFx0XHRlbGVtLmF0dHIoZngucHJvcCwgZm4gPT09ICdjdXInID8gVU5ERUZJTkVEIDogZngubm93KSA6IC8vIGFwcGx5IHRoZSBTVkcgd3JhcHBlcidzIG1ldGhvZFxuXHRcdFx0XHRcdFx0XHRcdGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gdXNlIGpRdWVyeSdzIGJ1aWx0LWluIG1ldGhvZFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIEV4dGVuZCB0aGUgb3BhY2l0eSBnZXR0ZXIsIG5lZWRlZCBmb3IgZmFkaW5nIG9wYWNpdHkgd2l0aCBJRTkgYW5kIGpRdWVyeSAxLjEwK1xuXHRcdFx0XHR3cmFwKCQuY3NzSG9va3Mub3BhY2l0eSwgJ2dldCcsIGZ1bmN0aW9uIChwcm9jZWVkLCBlbGVtLCBjb21wdXRlZCkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLmF0dHIgPyAoZWxlbS5vcGFjaXR5IHx8IDApIDogcHJvY2VlZC5jYWxsKHRoaXMsIGVsZW0sIGNvbXB1dGVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBEZWZpbmUgdGhlIHNldHRlciBmdW5jdGlvbiBmb3IgZCAocGF0aCBkZWZpbml0aW9ucylcblx0XHRcdFx0dGhpcy5hZGRBbmltU2V0dGVyKCdkJywgZnVuY3Rpb24gKGZ4KSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBmeC5lbGVtLFxuXHRcdFx0XHRcdFx0ZW5kcztcblx0XHRcdFxuXHRcdFx0XHRcdC8vIE5vcm1hbGx5IHN0YXJ0IGFuZCBlbmQgc2hvdWxkIGJlIHNldCBpbiBzdGF0ZSA9PSAwLCBidXQgc29tZXRpbWVzLFxuXHRcdFx0XHRcdC8vIGZvciByZWFzb25zIHVua25vd24sIHRoaXMgZG9lc24ndCBoYXBwZW4uIFBlcmhhcHMgc3RhdGUgPT0gMCBpcyBza2lwcGVkXG5cdFx0XHRcdFx0Ly8gaW4gdGhlc2UgY2FzZXNcblx0XHRcdFx0XHRpZiAoIWZ4LnN0YXJ0ZWQpIHtcblx0XHRcdFx0XHRcdGVuZHMgPSBwYXRoQW5pbS5pbml0KGVsZW0sIGVsZW0uZCwgZWxlbS50b0QpO1xuXHRcdFx0XHRcdFx0Znguc3RhcnQgPSBlbmRzWzBdO1xuXHRcdFx0XHRcdFx0ZnguZW5kID0gZW5kc1sxXTtcblx0XHRcdFx0XHRcdGZ4LnN0YXJ0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHRcdC8vIEludGVycG9sYXRlIGVhY2ggdmFsdWUgb2YgdGhlIHBhdGhcblx0XHRcdFx0XHRlbGVtLmF0dHIoJ2QnLCBwYXRoQW5pbS5zdGVwKGZ4LnN0YXJ0LCBmeC5lbmQsIGZ4LnBvcywgZWxlbS50b0QpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVXRpbGl0eSBmb3IgaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkuIFBhcmFtZXRlcnMgYXJlIHJldmVyc2VkIGNvbXBhcmVkIHRvIGpRdWVyeS5cblx0XHRcdFx0ICogQHBhcmFtIHtBcnJheX0gYXJyXG5cdFx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLmVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA/XG5cdFx0XHRcdFx0ZnVuY3Rpb24gKGFyciwgZm4pIHsgLy8gbW9kZXJuIGJyb3dzZXJzXG5cdFx0XHRcdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhcnIsIGZuKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH0gOiBcblx0XHRcdFx0XHRmdW5jdGlvbiAoYXJyLCBmbikgeyAvLyBsZWdhY3lcblx0XHRcdFx0XHRcdHZhciBpLCBcblx0XHRcdFx0XHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAoZm4uY2FsbChhcnJbaV0sIGFycltpXSwgaSwgYXJyKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogUmVnaXN0ZXIgSGlnaGNoYXJ0cyBhcyBhIHBsdWdpbiBpbiB0aGUgcmVzcGVjdGl2ZSBmcmFtZXdvcmtcblx0XHRcdFx0ICovXG5cdFx0XHRcdCQuZm4uaGlnaGNoYXJ0cyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgY29uc3RyID0gJ0NoYXJ0JywgLy8gZGVmYXVsdCBjb25zdHJ1Y3RvclxuXHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdG9wdGlvbnMsXG5cdFx0XHRcdFx0XHRyZXQsXG5cdFx0XHRcdFx0XHRjaGFydDtcblxuXHRcdFx0XHRcdGlmICh0aGlzWzBdKSB7XG5cblx0XHRcdFx0XHRcdGlmIChpc1N0cmluZyhhcmdzWzBdKSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdHIgPSBhcmdzWzBdO1xuXHRcdFx0XHRcdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSk7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b3B0aW9ucyA9IGFyZ3NbMF07XG5cblx0XHRcdFx0XHRcdC8vIENyZWF0ZSB0aGUgY2hhcnRcblx0XHRcdFx0XHRcdGlmIChvcHRpb25zICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdFx0Lypqc2xpbnQgdW51c2VkOmZhbHNlKi9cblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5jaGFydCA9IG9wdGlvbnMuY2hhcnQgfHwge307XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuY2hhcnQucmVuZGVyVG8gPSB0aGlzWzBdO1xuXHRcdFx0XHRcdFx0XHRjaGFydCA9IG5ldyBIaWdoY2hhcnRzW2NvbnN0cl0ob3B0aW9ucywgYXJnc1sxXSk7XG5cdFx0XHRcdFx0XHRcdHJldCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRcdC8qanNsaW50IHVudXNlZDp0cnVlKi9cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gV2hlbiBjYWxsZWQgd2l0aG91dCBwYXJhbWV0ZXJzIG9yIHdpdGggdGhlIHJldHVybiBhcmd1bWVudCwgZ2V0IGEgcHJlZGVmaW5lZCBjaGFydFxuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHRyZXQgPSBjaGFydHNbYXR0cih0aGlzWzBdLCAnZGF0YS1oaWdoY2hhcnRzLWNoYXJ0JyldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFkZCBhbiBhbmltYXRpb24gc2V0dGVyIGZvciBhIHNwZWNpZmljIHByb3BlcnR5XG5cdFx0XHQgKi9cblx0XHRcdGFkZEFuaW1TZXR0ZXI6IGZ1bmN0aW9uIChwcm9wLCBzZXR0ZXIpIHtcblx0XHRcdFx0Ly8galF1ZXJ5IDEuOCBzdHlsZVxuXHRcdFx0XHRpZiAoJC5Ud2Vlbikge1xuXHRcdFx0XHRcdCQuVHdlZW4ucHJvcEhvb2tzW3Byb3BdID0ge1xuXHRcdFx0XHRcdFx0c2V0OiBzZXR0ZXJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBwcmUgMS44XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5meC5zdGVwW3Byb3BdID0gc2V0dGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIERvd25sb2FkcyBhIHNjcmlwdCBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayB3aGVuIGRvbmUuXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc2NyaXB0TG9jYXRpb25cblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0XHQgKi9cblx0XHRcdGdldFNjcmlwdDogJC5nZXRTY3JpcHQsXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJuIHRoZSBpbmRleCBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZiBub3QgZm91bmRcblx0XHRcdCAqL1xuXHRcdFx0aW5BcnJheTogJC5pbkFycmF5LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEEgZGlyZWN0IGxpbmsgdG8galF1ZXJ5IG1ldGhvZHMuIE1vb1Rvb2xzIGFuZCBQcm90b3R5cGUgYWRhcHRlcnMgbXVzdCBiZSBpbXBsZW1lbnRlZCBmb3IgZWFjaCBjYXNlIG9mIG1ldGhvZC5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIFRoZSBIVE1MIGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgV2hpY2ggbWV0aG9kIHRvIHJ1biBvbiB0aGUgd3JhcHBlZCBlbGVtZW50XG5cdFx0XHQgKi9cblx0XHRcdGFkYXB0ZXJSdW46IGZ1bmN0aW9uIChlbGVtLCBtZXRob2QpIHtcblx0XHRcdFx0cmV0dXJuICQoZWxlbSlbbWV0aG9kXSgpO1xuXHRcdFx0fSxcblx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRmlsdGVyIGFuIGFycmF5XG5cdFx0XHQgKi9cblx0XHRcdGdyZXA6ICQuZ3JlcCxcblx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogTWFwIGFuIGFycmF5XG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdFx0XHQgKi9cblx0XHRcdG1hcDogZnVuY3Rpb24gKGFyciwgZm4pIHtcblx0XHRcdFx0Ly9yZXR1cm4galF1ZXJ5Lm1hcChhcnIsIGZuKTtcblx0XHRcdFx0dmFyIHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGZuLmNhbGwoYXJyW2ldLCBhcnJbaV0sIGksIGFycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XG5cdFx0XHR9LFxuXHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBHZXQgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IG9mIHRoZSBwYWdlXG5cdFx0XHQgKi9cblx0XHRcdG9mZnNldDogZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRcdHJldHVybiAkKGVsKS5vZmZzZXQoKTtcblx0XHRcdH0sXG5cdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsIEEgSFRNTCBlbGVtZW50IG9yIGN1c3RvbSBvYmplY3Rcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgdHlwZVxuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGV2ZW50IGhhbmRsZXJcblx0XHRcdCAqL1xuXHRcdFx0YWRkRXZlbnQ6IGZ1bmN0aW9uIChlbCwgZXZlbnQsIGZuKSB7XG5cdFx0XHRcdCQoZWwpLmJpbmQoZXZlbnQsIGZuKTtcblx0XHRcdH0sXG5cdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlbW92ZSBldmVudCBhZGRlZCB3aXRoIGFkZEV2ZW50XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWwgVGhlIG9iamVjdFxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBUaGUgZXZlbnQgdHlwZS4gTGVhdmUgYmxhbmsgdG8gcmVtb3ZlIGFsbCBldmVudHMuXG5cdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBmdW5jdGlvbiB0byByZW1vdmVcblx0XHRcdCAqL1xuXHRcdFx0cmVtb3ZlRXZlbnQ6IGZ1bmN0aW9uIChlbCwgZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG5cdFx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGpRdWVyeSBpc3N1ZSB3aXRoIHVuYmluZGluZyBjdXN0b20gZXZlbnRzOlxuXHRcdFx0XHQvLyBodHRwOi8vZm9ydW0ualF1ZXJ5LmNvbS90b3BpYy9qYXZhc2NyaXB0LWVycm9yLXdoZW4tdW5iaW5kaW5nLWEtY3VzdG9tLWV2ZW50LXVzaW5nLWpRdWVyeS0xLTQtMlxuXHRcdFx0XHR2YXIgZnVuYyA9IGRvYy5yZW1vdmVFdmVudExpc3RlbmVyID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50Jztcblx0XHRcdFx0aWYgKGRvY1tmdW5jXSAmJiBlbCAmJiAhZWxbZnVuY10pIHtcblx0XHRcdFx0XHRlbFtmdW5jXSA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdCQoZWwpLnVuYmluZChldmVudFR5cGUsIGhhbmRsZXIpO1xuXHRcdFx0fSxcblx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRmlyZSBhbiBldmVudCBvbiBhIGN1c3RvbSBvYmplY3Rcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbFxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEFyZ3VtZW50c1xuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdEZ1bmN0aW9uXG5cdFx0XHQgKi9cblx0XHRcdGZpcmVFdmVudDogZnVuY3Rpb24gKGVsLCB0eXBlLCBldmVudEFyZ3VtZW50cywgZGVmYXVsdEZ1bmN0aW9uKSB7XG5cdFx0XHRcdHZhciBldmVudCA9ICQuRXZlbnQodHlwZSksXG5cdFx0XHRcdFx0ZGV0YWNoZWRUeXBlID0gJ2RldGFjaGVkJyArIHR5cGUsXG5cdFx0XHRcdFx0ZGVmYXVsdFByZXZlbnRlZDtcblx0XHRcblx0XHRcdFx0Ly8gUmVtb3ZlIHdhcm5pbmdzIGluIENocm9tZSB3aGVuIGFjY2Vzc2luZyByZXR1cm5WYWx1ZSAoIzI3OTApLCBsYXllclggYW5kIGxheWVyWS4gQWx0aG91Z2ggSGlnaGNoYXJ0c1xuXHRcdFx0XHQvLyBuZXZlciB1c2VzIHRoZXNlIHByb3BlcnRpZXMsIENocm9tZSBpbmNsdWRlcyB0aGVtIGluIHRoZSBkZWZhdWx0IGNsaWNrIGV2ZW50IGFuZFxuXHRcdFx0XHQvLyByYWlzZXMgdGhlIHdhcm5pbmcgd2hlbiB0aGV5IGFyZSBjb3BpZWQgb3ZlciBpbiB0aGUgZXh0ZW5kIHN0YXRlbWVudCBiZWxvdy5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gVG8gYXZvaWQgcHJvYmxlbXMgaW4gSUUgKHNlZSAjMTAxMCkgd2hlcmUgd2UgY2Fubm90IGRlbGV0ZSB0aGUgcHJvcGVydGllcyBhbmQgYXZvaWRcblx0XHRcdFx0Ly8gdGVzdGluZyBpZiB0aGV5IGFyZSB0aGVyZSAod2FybmluZyBpbiBjaHJvbWUpIHRoZSBvbmx5IG9wdGlvbiBpcyB0byB0ZXN0IGlmIHJ1bm5pbmcgSUUuXG5cdFx0XHRcdGlmICghaXNJRSAmJiBldmVudEFyZ3VtZW50cykge1xuXHRcdFx0XHRcdGRlbGV0ZSBldmVudEFyZ3VtZW50cy5sYXllclg7XG5cdFx0XHRcdFx0ZGVsZXRlIGV2ZW50QXJndW1lbnRzLmxheWVyWTtcblx0XHRcdFx0XHRkZWxldGUgZXZlbnRBcmd1bWVudHMucmV0dXJuVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0ZXh0ZW5kKGV2ZW50LCBldmVudEFyZ3VtZW50cyk7XG5cdFx0XG5cdFx0XHRcdC8vIFByZXZlbnQgalF1ZXJ5IGZyb20gdHJpZ2dlcmluZyB0aGUgb2JqZWN0IG1ldGhvZCB0aGF0IGlzIG5hbWVkIHRoZVxuXHRcdFx0XHQvLyBzYW1lIGFzIHRoZSBldmVudC4gRm9yIGV4YW1wbGUsIGlmIHRoZSBldmVudCBpcyAnc2VsZWN0JywgalF1ZXJ5XG5cdFx0XHRcdC8vIGF0dGVtcHRzIGNhbGxpbmcgZWwuc2VsZWN0IGFuZCBpdCBnb2VzIGludG8gYSBsb29wLlxuXHRcdFx0XHRpZiAoZWxbdHlwZV0pIHtcblx0XHRcdFx0XHRlbFtkZXRhY2hlZFR5cGVdID0gZWxbdHlwZV07XG5cdFx0XHRcdFx0ZWxbdHlwZV0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdC8vIFdyYXAgcHJldmVudERlZmF1bHQgYW5kIHN0b3BQcm9wYWdhdGlvbiBpbiB0cnkvY2F0Y2ggYmxvY2tzIGluXG5cdFx0XHRcdC8vIG9yZGVyIHRvIHByZXZlbnQgSlMgZXJyb3JzIHdoZW4gY2FuY2VsbGluZyBldmVudHMgb24gbm9uLURPTVxuXHRcdFx0XHQvLyBvYmplY3RzLiAjNjE1LlxuXHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiB0cnVlKi9cblx0XHRcdFx0JC5lYWNoKFsncHJldmVudERlZmF1bHQnLCAnc3RvcFByb3BhZ2F0aW9uJ10sIGZ1bmN0aW9uIChpLCBmbikge1xuXHRcdFx0XHRcdHZhciBiYXNlID0gZXZlbnRbZm5dO1xuXHRcdFx0XHRcdGV2ZW50W2ZuXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGJhc2UuY2FsbChldmVudCk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChmbiA9PT0gJ3ByZXZlbnREZWZhdWx0Jykge1xuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8qanNsaW50IHVucGFyYW06IGZhbHNlKi9cblx0XHRcblx0XHRcdFx0Ly8gdHJpZ2dlciBpdFxuXHRcdFx0XHQkKGVsKS50cmlnZ2VyKGV2ZW50KTtcblx0XHRcblx0XHRcdFx0Ly8gYXR0YWNoIHRoZSBtZXRob2Rcblx0XHRcdFx0aWYgKGVsW2RldGFjaGVkVHlwZV0pIHtcblx0XHRcdFx0XHRlbFt0eXBlXSA9IGVsW2RldGFjaGVkVHlwZV07XG5cdFx0XHRcdFx0ZWxbZGV0YWNoZWRUeXBlXSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0aWYgKGRlZmF1bHRGdW5jdGlvbiAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgIWRlZmF1bHRQcmV2ZW50ZWQpIHtcblx0XHRcdFx0XHRkZWZhdWx0RnVuY3Rpb24oZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEV4dGVuc2lvbiBtZXRob2QgbmVlZGVkIGZvciBNb29Ub29sc1xuXHRcdFx0ICovXG5cdFx0XHR3YXNoTW91c2VFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIHJldCA9IGUub3JpZ2luYWxFdmVudCB8fCBlO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY29tcHV0ZWQgYnkgalF1ZXJ5LCBuZWVkZWQgYnkgSUU4XG5cdFx0XHRcdGlmIChyZXQucGFnZVggPT09IFVOREVGSU5FRCkgeyAvLyAjMTIzNlxuXHRcdFx0XHRcdHJldC5wYWdlWCA9IGUucGFnZVg7XG5cdFx0XHRcdFx0cmV0LnBhZ2VZID0gZS5wYWdlWTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH0sXG5cdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEFuaW1hdGUgYSBIVE1MIGVsZW1lbnQgb3IgU1ZHIGVsZW1lbnQgd3JhcHBlclxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBqUXVlcnktbGlrZSBhbmltYXRpb24gb3B0aW9uczogZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2tcblx0XHRcdCAqL1xuXHRcdFx0YW5pbWF0ZTogZnVuY3Rpb24gKGVsLCBwYXJhbXMsIG9wdGlvbnMpIHtcblx0XHRcdFx0dmFyICRlbCA9ICQoZWwpO1xuXHRcdFx0XHRpZiAoIWVsLnN0eWxlKSB7XG5cdFx0XHRcdFx0ZWwuc3R5bGUgPSB7fTsgLy8gIzE4ODFcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFyYW1zLmQpIHtcblx0XHRcdFx0XHRlbC50b0QgPSBwYXJhbXMuZDsgLy8ga2VlcCB0aGUgYXJyYXkgZm9ybSBmb3IgcGF0aHMsIHVzZWQgaW4gJC5meC5zdGVwLmRcblx0XHRcdFx0XHRwYXJhbXMuZCA9IDE7IC8vIGJlY2F1c2UgaW4galF1ZXJ5LCBhbmltYXRpbmcgdG8gYW4gYXJyYXkgaGFzIGEgZGlmZmVyZW50IG1lYW5pbmdcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHQkZWwuc3RvcCgpO1xuXHRcdFx0XHRpZiAocGFyYW1zLm9wYWNpdHkgIT09IFVOREVGSU5FRCAmJiBlbC5hdHRyKSB7XG5cdFx0XHRcdFx0cGFyYW1zLm9wYWNpdHkgKz0gJ3B4JzsgLy8gZm9yY2UgalF1ZXJ5IHRvIHVzZSBzYW1lIGxvZ2ljIGFzIHdpZHRoIGFuZCBoZWlnaHQgKCMyMTYxKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsLmhhc0FuaW0gPSAxOyAvLyAjMzM0MlxuXHRcdFx0XHQkZWwuYW5pbWF0ZShwYXJhbXMsIG9wdGlvbnMpO1xuXHRcdFxuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogU3RvcCBydW5uaW5nIGFuaW1hdGlvblxuXHRcdFx0ICovXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdFx0aWYgKGVsLmhhc0FuaW0pIHsgLy8gIzMzNDIsIG1lbW9yeSBsZWFrIG9uIGNhbGxpbmcgJChlbCkgZnJvbSBkZXN0cm95XG5cdFx0XHRcdFx0JChlbCkuc3RvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0od2luLmpRdWVyeSkpO1xuXG5cblx0Ly8gY2hlY2sgZm9yIGEgY3VzdG9tIEhpZ2hjaGFydHNBZGFwdGVyIGRlZmluZWQgcHJpb3IgdG8gdGhpcyBmaWxlXG5cdHZhciBnbG9iYWxBZGFwdGVyID0gd2luLkhpZ2hjaGFydHNBZGFwdGVyLFxuXHRcdGFkYXB0ZXIgPSBnbG9iYWxBZGFwdGVyIHx8IHt9O1xuXHRcdFxuXHQvLyBJbml0aWFsaXplIHRoZSBhZGFwdGVyXG5cdGlmIChnbG9iYWxBZGFwdGVyKSB7XG5cdFx0Z2xvYmFsQWRhcHRlci5pbml0LmNhbGwoZ2xvYmFsQWRhcHRlciwgcGF0aEFuaW0pO1xuXHR9XG5cblxuXHQvLyBVdGlsaXR5IGZ1bmN0aW9ucy4gSWYgdGhlIEhpZ2hjaGFydHNBZGFwdGVyIGlzIG5vdCBkZWZpbmVkLCBhZGFwdGVyIGlzIGFuIGVtcHR5IG9iamVjdFxuXHQvLyBhbmQgYWxsIHRoZSB1dGlsaXR5IGZ1bmN0aW9ucyB3aWxsIGJlIG51bGwuIEluIHRoYXQgY2FzZSB0aGV5IGFyZSBwb3B1bGF0ZWQgYnkgdGhlXG5cdC8vIGRlZmF1bHQgYWRhcHRlcnMgYmVsb3cuXG5cdHZhciBhZGFwdGVyUnVuID0gYWRhcHRlci5hZGFwdGVyUnVuLFxuXHRcdGdldFNjcmlwdCA9IGFkYXB0ZXIuZ2V0U2NyaXB0LFxuXHRcdGluQXJyYXkgPSBhZGFwdGVyLmluQXJyYXksXG5cdFx0ZWFjaCA9IEhpZ2hjaGFydHMuZWFjaCA9IGFkYXB0ZXIuZWFjaCxcblx0XHRncmVwID0gYWRhcHRlci5ncmVwLFxuXHRcdG9mZnNldCA9IGFkYXB0ZXIub2Zmc2V0LFxuXHRcdG1hcCA9IGFkYXB0ZXIubWFwLFxuXHRcdGFkZEV2ZW50ID0gYWRhcHRlci5hZGRFdmVudCxcblx0XHRyZW1vdmVFdmVudCA9IGFkYXB0ZXIucmVtb3ZlRXZlbnQsXG5cdFx0ZmlyZUV2ZW50ID0gYWRhcHRlci5maXJlRXZlbnQsXG5cdFx0d2FzaE1vdXNlRXZlbnQgPSBhZGFwdGVyLndhc2hNb3VzZUV2ZW50LFxuXHRcdGFuaW1hdGUgPSBhZGFwdGVyLmFuaW1hdGUsXG5cdFx0c3RvcCA9IGFkYXB0ZXIuc3RvcDtcblxuXG5cblx0LyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBIYW5kbGUgdGhlIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0ZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0Y29sb3JzOiBbJyM3Y2I1ZWMnLCAnIzQzNDM0OCcsICcjOTBlZDdkJywgJyNmN2EzNWMnLCBcblx0XHRcdCAgICAnIzgwODVlOScsICcjZjE1YzgwJywgJyNlNGQzNTQnLCAnIzJiOTA4ZicsICcjZjQ1YjViJywgJyM5MWU4ZTEnXSxcblx0XHRzeW1ib2xzOiBbJ2NpcmNsZScsICdkaWFtb25kJywgJ3NxdWFyZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS1kb3duJ10sXG5cdFx0bGFuZzoge1xuXHRcdFx0bG9hZGluZzogJ0xvYWRpbmcuLi4nLFxuXHRcdFx0bW9udGhzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsXG5cdFx0XHRcdFx0J0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuXHRcdFx0c2hvcnRNb250aHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcblx0XHRcdHdlZWtkYXlzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG5cdFx0XHRkZWNpbWFsUG9pbnQ6ICcuJyxcblx0XHRcdG51bWVyaWNTeW1ib2xzOiBbJ2snLCAnTScsICdHJywgJ1QnLCAnUCcsICdFJ10sIC8vIFNJIHByZWZpeGVzIHVzZWQgaW4gYXhpcyBsYWJlbHNcblx0XHRcdHJlc2V0Wm9vbTogJ1Jlc2V0IHpvb20nLFxuXHRcdFx0cmVzZXRab29tVGl0bGU6ICdSZXNldCB6b29tIGxldmVsIDE6MScsXG5cdFx0XHR0aG91c2FuZHNTZXA6ICcgJ1xuXHRcdH0sXG5cdFx0Z2xvYmFsOiB7XG5cdFx0XHR1c2VVVEM6IHRydWUsXG5cdFx0XHQvL3RpbWV6b25lT2Zmc2V0OiAwLFxuXHRcdFx0Y2FudmFzVG9vbHNVUkw6ICdodHRwOi8vY29kZS5oaWdoY2hhcnRzLmNvbS80LjEuNC1tb2RpZmllZC9tb2R1bGVzL2NhbnZhcy10b29scy5qcycsXG5cdFx0XHRWTUxSYWRpYWxHcmFkaWVudFVSTDogJ2h0dHA6Ly9jb2RlLmhpZ2hjaGFydHMuY29tLzQuMS40LW1vZGlmaWVkL2dmeC92bWwtcmFkaWFsLWdyYWRpZW50LnBuZydcblx0XHR9LFxuXHRcdGNoYXJ0OiB7XG5cdFx0XHQvL2FuaW1hdGlvbjogdHJ1ZSxcblx0XHRcdC8vYWxpZ25UaWNrczogZmFsc2UsXG5cdFx0XHQvL3JlZmxvdzogdHJ1ZSxcblx0XHRcdC8vY2xhc3NOYW1lOiBudWxsLFxuXHRcdFx0Ly9ldmVudHM6IHsgbG9hZCwgc2VsZWN0aW9uIH0sXG5cdFx0XHQvL21hcmdpbjogW251bGxdLFxuXHRcdFx0Ly9tYXJnaW5Ub3A6IG51bGwsXG5cdFx0XHQvL21hcmdpblJpZ2h0OiBudWxsLFxuXHRcdFx0Ly9tYXJnaW5Cb3R0b206IG51bGwsXG5cdFx0XHQvL21hcmdpbkxlZnQ6IG51bGwsXG5cdFx0XHRib3JkZXJDb2xvcjogJyM0NTcyQTcnLFxuXHRcdFx0Ly9ib3JkZXJXaWR0aDogMCxcblx0XHRcdGJvcmRlclJhZGl1czogMCxcblx0XHRcdGRlZmF1bHRTZXJpZXNUeXBlOiAnbGluZScsXG5cdFx0XHRpZ25vcmVIaWRkZW5TZXJpZXM6IHRydWUsXG5cdFx0XHQvL2ludmVydGVkOiBmYWxzZSxcblx0XHRcdC8vc2hhZG93OiBmYWxzZSxcblx0XHRcdHNwYWNpbmc6IFsxMCwgMTAsIDE1LCAxMF0sXG5cdFx0XHQvL3NwYWNpbmdUb3A6IDEwLFxuXHRcdFx0Ly9zcGFjaW5nUmlnaHQ6IDEwLFxuXHRcdFx0Ly9zcGFjaW5nQm90dG9tOiAxNSxcblx0XHRcdC8vc3BhY2luZ0xlZnQ6IDEwLFxuXHRcdFx0Ly9zdHlsZToge1xuXHRcdFx0Ly9cdGZvbnRGYW1pbHk6ICdcIkx1Y2lkYSBHcmFuZGVcIiwgXCJMdWNpZGEgU2FucyBVbmljb2RlXCIsIFZlcmRhbmEsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLCAvLyBkZWZhdWx0IGZvbnRcblx0XHRcdC8vXHRmb250U2l6ZTogJzEycHgnXG5cdFx0XHQvL30sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRcdC8vcGxvdEJhY2tncm91bmRDb2xvcjogbnVsbCxcblx0XHRcdHBsb3RCb3JkZXJDb2xvcjogJyNDMEMwQzAnLFxuXHRcdFx0Ly9wbG90Qm9yZGVyV2lkdGg6IDAsXG5cdFx0XHQvL3Bsb3RTaGFkb3c6IGZhbHNlLFxuXHRcdFx0Ly96b29tVHlwZTogJydcblx0XHRcdHJlc2V0Wm9vbUJ1dHRvbjoge1xuXHRcdFx0XHR0aGVtZToge1xuXHRcdFx0XHRcdHpJbmRleDogMjBcblx0XHRcdFx0fSxcblx0XHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0XHRhbGlnbjogJ3JpZ2h0Jyxcblx0XHRcdFx0XHR4OiAtMTAsXG5cdFx0XHRcdFx0Ly92ZXJ0aWNhbEFsaWduOiAndG9wJyxcblx0XHRcdFx0XHR5OiAxMFxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHJlbGF0aXZlVG86ICdwbG90J1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dGl0bGU6IHtcblx0XHRcdHRleHQ6ICdDaGFydCB0aXRsZScsXG5cdFx0XHRhbGlnbjogJ2NlbnRlcicsXG5cdFx0XHQvLyBmbG9hdGluZzogZmFsc2UsXG5cdFx0XHRtYXJnaW46IDE1LFxuXHRcdFx0Ly8geDogMCxcblx0XHRcdC8vIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuXHRcdFx0Ly8geTogbnVsbCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGNvbG9yOiAnIzMzMzMzMycsXG5cdFx0XHRcdGZvbnRTaXplOiAnMThweCdcblx0XHRcdH1cblxuXHRcdH0sXG5cdFx0c3VidGl0bGU6IHtcblx0XHRcdHRleHQ6ICcnLFxuXHRcdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdFx0Ly8gZmxvYXRpbmc6IGZhbHNlXG5cdFx0XHQvLyB4OiAwLFxuXHRcdFx0Ly8gdmVydGljYWxBbGlnbjogJ3RvcCcsXG5cdFx0XHQvLyB5OiBudWxsLFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Y29sb3I6ICcjNTU1NTU1J1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRwbG90T3B0aW9uczoge1xuXHRcdFx0bGluZTogeyAvLyBiYXNlIHNlcmllcyBvcHRpb25zXG5cdFx0XHRcdGFsbG93UG9pbnRTZWxlY3Q6IGZhbHNlLFxuXHRcdFx0XHRzaG93Q2hlY2tib3g6IGZhbHNlLFxuXHRcdFx0XHRhbmltYXRpb246IHtcblx0XHRcdFx0XHRkdXJhdGlvbjogMTAwMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvL2Nvbm5lY3ROdWxsczogZmFsc2UsXG5cdFx0XHRcdC8vY3Vyc29yOiAnZGVmYXVsdCcsXG5cdFx0XHRcdC8vY2xpcDogdHJ1ZSxcblx0XHRcdFx0Ly9kYXNoU3R5bGU6IG51bGwsXG5cdFx0XHRcdC8vZW5hYmxlTW91c2VUcmFja2luZzogdHJ1ZSxcblx0XHRcdFx0ZXZlbnRzOiB7fSxcblx0XHRcdFx0Ly9sZWdlbmRJbmRleDogMCxcblx0XHRcdFx0Ly9saW5lY2FwOiAncm91bmQnLFxuXHRcdFx0XHRsaW5lV2lkdGg6IDIsXG5cdFx0XHRcdC8vc2hhZG93OiBmYWxzZSxcblx0XHRcdFx0Ly8gc3RhY2tpbmc6IG51bGwsXG5cdFx0XHRcdG1hcmtlcjoge1xuXHRcdFx0XHRcdC8vZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0XHQvL3N5bWJvbDogbnVsbCxcblx0XHRcdFx0XHRsaW5lV2lkdGg6IDAsXG5cdFx0XHRcdFx0cmFkaXVzOiA0LFxuXHRcdFx0XHRcdGxpbmVDb2xvcjogJyNGRkZGRkYnLFxuXHRcdFx0XHRcdC8vZmlsbENvbG9yOiBudWxsLFxuXHRcdFx0XHRcdHN0YXRlczogeyAvLyBzdGF0ZXMgZm9yIGEgc2luZ2xlIHBvaW50XG5cdFx0XHRcdFx0XHRob3Zlcjoge1xuXHRcdFx0XHRcdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGhQbHVzOiAxLFxuXHRcdFx0XHRcdFx0XHRyYWRpdXNQbHVzOiAyXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0XHRcdGZpbGxDb2xvcjogJyNGRkZGRkYnLFxuXHRcdFx0XHRcdFx0XHRsaW5lQ29sb3I6ICcjMDAwMDAwJyxcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiAyXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRwb2ludDoge1xuXHRcdFx0XHRcdGV2ZW50czoge31cblx0XHRcdFx0fSxcblx0XHRcdFx0ZGF0YUxhYmVsczoge1xuXHRcdFx0XHRcdGFsaWduOiAnY2VudGVyJyxcblx0XHRcdFx0XHQvLyBkZWZlcjogdHJ1ZSxcblx0XHRcdFx0XHQvLyBlbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0XHRmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnkgPT09IG51bGwgPyAnJyA6IEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHRoaXMueSwgLTEpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGNvbG9yOiAnY29udHJhc3QnLFxuXHRcdFx0XHRcdFx0Zm9udFNpemU6ICcxMXB4Jyxcblx0XHRcdFx0XHRcdGZvbnRXZWlnaHQ6ICdib2xkJyxcblx0XHRcdFx0XHRcdHRleHRTaGFkb3c6ICcwIDAgNnB4IGNvbnRyYXN0LCAwIDAgM3B4IGNvbnRyYXN0J1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0dmVydGljYWxBbGlnbjogJ2JvdHRvbScsIC8vIGFib3ZlIHNpbmd1bGFyIHBvaW50XG5cdFx0XHRcdFx0eDogMCxcblx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdC8vIGJhY2tncm91bmRDb2xvcjogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdC8vIGJvcmRlckNvbG9yOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0Ly8gYm9yZGVyUmFkaXVzOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0Ly8gYm9yZGVyV2lkdGg6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRwYWRkaW5nOiA1XG5cdFx0XHRcdFx0Ly8gc2hhZG93OiBmYWxzZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjcm9wVGhyZXNob2xkOiAzMDAsIC8vIGRyYXcgcG9pbnRzIG91dHNpZGUgdGhlIHBsb3QgYXJlYSB3aGVuIHRoZSBudW1iZXIgb2YgcG9pbnRzIGlzIGxlc3MgdGhhbiB0aGlzXG5cdFx0XHRcdHBvaW50UmFuZ2U6IDAsXG5cdFx0XHRcdC8vcG9pbnRTdGFydDogMCxcblx0XHRcdFx0Ly9wb2ludEludGVydmFsOiAxLFxuXHRcdFx0XHQvL3Nob3dJbkxlZ2VuZDogbnVsbCwgLy8gYXV0bzogdHJ1ZSBmb3Igc3RhbmRhbG9uZSBzZXJpZXMsIGZhbHNlIGZvciBsaW5rZWQgc2VyaWVzXG5cdFx0XHRcdHN0YXRlczogeyAvLyBzdGF0ZXMgZm9yIHRoZSBlbnRpcmUgc2VyaWVzXG5cdFx0XHRcdFx0aG92ZXI6IHtcblx0XHRcdFx0XHRcdC8vZW5hYmxlZDogZmFsc2UsXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGhQbHVzOiAxLFxuXHRcdFx0XHRcdFx0bWFya2VyOiB7XG5cdFx0XHRcdFx0XHRcdC8vIGxpbmVXaWR0aDogYmFzZSArIDEsXG5cdFx0XHRcdFx0XHRcdC8vIHJhZGl1czogYmFzZSArIDFcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRoYWxvOiB7XG5cdFx0XHRcdFx0XHRcdHNpemU6IDEwLFxuXHRcdFx0XHRcdFx0XHRvcGFjaXR5OiAwLjI1XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzZWxlY3Q6IHtcblx0XHRcdFx0XHRcdG1hcmtlcjoge31cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN0aWNreVRyYWNraW5nOiB0cnVlLFxuXHRcdFx0XHQvL3Rvb2x0aXA6IHtcblx0XHRcdFx0XHQvL3BvaW50Rm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+XFx1MjVDRjwvc3Bhbj4ge3Nlcmllcy5uYW1lfTogPGI+e3BvaW50Lnl9PC9iPidcblx0XHRcdFx0XHQvL3ZhbHVlRGVjaW1hbHM6IG51bGwsXG5cdFx0XHRcdFx0Ly94RGF0ZUZvcm1hdDogJyVBLCAlYiAlZSwgJVknLFxuXHRcdFx0XHRcdC8vdmFsdWVQcmVmaXg6ICcnLFxuXHRcdFx0XHRcdC8veVN1ZmZpeDogJydcdFx0XHRcdFxuXHRcdFx0XHQvL31cblx0XHRcdFx0dHVyYm9UaHJlc2hvbGQ6IDEwMDBcblx0XHRcdFx0Ly8gekluZGV4OiBudWxsXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsYWJlbHM6IHtcblx0XHRcdC8vaXRlbXM6IFtdLFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Ly9mb250OiBkZWZhdWx0Rm9udCxcblx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0XHRjb2xvcjogJyMzRTU3NkYnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsZWdlbmQ6IHtcblx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRhbGlnbjogJ2NlbnRlcicsXG5cdFx0XHQvL2Zsb2F0aW5nOiBmYWxzZSxcblx0XHRcdGxheW91dDogJ2hvcml6b250YWwnLFxuXHRcdFx0bGFiZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubmFtZTtcblx0XHRcdH0sXG5cdFx0XHQvL2JvcmRlcldpZHRoOiAwLFxuXHRcdFx0Ym9yZGVyQ29sb3I6ICcjOTA5MDkwJyxcblx0XHRcdGJvcmRlclJhZGl1czogMCxcblx0XHRcdG5hdmlnYXRpb246IHtcblx0XHRcdFx0Ly8gYW5pbWF0aW9uOiB0cnVlLFxuXHRcdFx0XHRhY3RpdmVDb2xvcjogJyMyNzRiNmQnLFxuXHRcdFx0XHQvLyBhcnJvd1NpemU6IDEyXG5cdFx0XHRcdGluYWN0aXZlQ29sb3I6ICcjQ0NDJ1xuXHRcdFx0XHQvLyBzdHlsZToge30gLy8gdGV4dCBzdHlsZXNcblx0XHRcdH0sXG5cdFx0XHQvLyBtYXJnaW46IDIwLFxuXHRcdFx0Ly8gcmV2ZXJzZWQ6IGZhbHNlLFxuXHRcdFx0c2hhZG93OiBmYWxzZSxcblx0XHRcdC8vIGJhY2tncm91bmRDb2xvcjogbnVsbCxcblx0XHRcdC8qc3R5bGU6IHtcblx0XHRcdFx0cGFkZGluZzogJzVweCdcblx0XHRcdH0sKi9cblx0XHRcdGl0ZW1TdHlsZToge1x0XHRcdFxuXHRcdFx0XHRjb2xvcjogJyMzMzMzMzMnLFxuXHRcdFx0XHRmb250U2l6ZTogJzEycHgnLFxuXHRcdFx0XHRmb250V2VpZ2h0OiAnYm9sZCdcblx0XHRcdH0sXG5cdFx0XHRpdGVtSG92ZXJTdHlsZToge1xuXHRcdFx0XHQvL2N1cnNvcjogJ3BvaW50ZXInLCByZW1vdmVkIGFzIG9mICM2MDFcblx0XHRcdFx0Y29sb3I6ICcjMDAwJ1xuXHRcdFx0fSxcblx0XHRcdGl0ZW1IaWRkZW5TdHlsZToge1xuXHRcdFx0XHRjb2xvcjogJyNDQ0MnXG5cdFx0XHR9LFxuXHRcdFx0aXRlbUNoZWNrYm94U3R5bGU6IHtcblx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0XHR3aWR0aDogJzEzcHgnLCAvLyBmb3IgSUUgcHJlY2lzaW9uXG5cdFx0XHRcdGhlaWdodDogJzEzcHgnXG5cdFx0XHR9LFxuXHRcdFx0Ly8gaXRlbVdpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHQvLyBzeW1ib2xSYWRpdXM6IDAsXG5cdFx0XHQvLyBzeW1ib2xXaWR0aDogMTYsXG5cdFx0XHRzeW1ib2xQYWRkaW5nOiA1LFxuXHRcdFx0dmVydGljYWxBbGlnbjogJ2JvdHRvbScsXG5cdFx0XHQvLyB3aWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0eDogMCxcblx0XHRcdHk6IDAsXG5cdFx0XHR0aXRsZToge1xuXHRcdFx0XHQvL3RleHQ6IG51bGwsXG5cdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0Zm9udFdlaWdodDogJ2JvbGQnXG5cdFx0XHRcdH1cblx0XHRcdH1cdFx0XHRcblx0XHR9LFxuXG5cdFx0bG9hZGluZzoge1xuXHRcdFx0Ly8gaGlkZUR1cmF0aW9uOiAxMDAsXG5cdFx0XHRsYWJlbFN0eWxlOiB7XG5cdFx0XHRcdGZvbnRXZWlnaHQ6ICdib2xkJyxcblx0XHRcdFx0cG9zaXRpb246IFJFTEFUSVZFLFxuXHRcdFx0XHR0b3A6ICc0NSUnXG5cdFx0XHR9LFxuXHRcdFx0Ly8gc2hvd0R1cmF0aW9uOiAwLFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG5cdFx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdFx0dGV4dEFsaWduOiAnY2VudGVyJ1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0b29sdGlwOiB7XG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0YW5pbWF0aW9uOiBoYXNTVkcsXG5cdFx0XHQvL2Nyb3NzaGFpcnM6IG51bGwsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI0OSwgMjQ5LCAyNDksIC44NSknLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdFx0XHRib3JkZXJSYWRpdXM6IDMsXG5cdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0czogeyBcblx0XHRcdFx0bWlsbGlzZWNvbmQ6ICclQSwgJWIgJWUsICVIOiVNOiVTLiVMJyxcblx0XHRcdFx0c2Vjb25kOiAnJUEsICViICVlLCAlSDolTTolUycsXG5cdFx0XHRcdG1pbnV0ZTogJyVBLCAlYiAlZSwgJUg6JU0nLFxuXHRcdFx0XHRob3VyOiAnJUEsICViICVlLCAlSDolTScsXG5cdFx0XHRcdGRheTogJyVBLCAlYiAlZSwgJVknLFxuXHRcdFx0XHR3ZWVrOiAnV2VlayBmcm9tICVBLCAlYiAlZSwgJVknLFxuXHRcdFx0XHRtb250aDogJyVCICVZJyxcblx0XHRcdFx0eWVhcjogJyVZJ1xuXHRcdFx0fSxcblx0XHRcdGZvb3RlckZvcm1hdDogJycsXG5cdFx0XHQvL2Zvcm1hdHRlcjogZGVmYXVsdEZvcm1hdHRlcixcblx0XHRcdGhlYWRlckZvcm1hdDogJzxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxMHB4XCI+e3BvaW50LmtleX08L3NwYW4+PGJyLz4nLFxuXHRcdFx0cG9pbnRGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImNvbG9yOntwb2ludC5jb2xvcn1cIj5cXHUyNUNGPC9zcGFuPiB7c2VyaWVzLm5hbWV9OiA8Yj57cG9pbnQueX08L2I+PGJyLz4nLFxuXHRcdFx0c2hhZG93OiB0cnVlLFxuXHRcdFx0Ly9zaGFwZTogJ2NhbGxvdXQnLFxuXHRcdFx0Ly9zaGFyZWQ6IGZhbHNlLFxuXHRcdFx0c25hcDogaXNUb3VjaERldmljZSA/IDI1IDogMTAsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRjb2xvcjogJyMzMzMzMzMnLFxuXHRcdFx0XHRjdXJzb3I6ICdkZWZhdWx0Jyxcblx0XHRcdFx0Zm9udFNpemU6ICcxMnB4Jyxcblx0XHRcdFx0cGFkZGluZzogJzhweCcsXG5cdFx0XHRcdHdoaXRlU3BhY2U6ICdub3dyYXAnXG5cdFx0XHR9XG5cdFx0XHQvL3hEYXRlRm9ybWF0OiAnJUEsICViICVlLCAlWScsXG5cdFx0XHQvL3ZhbHVlRGVjaW1hbHM6IG51bGwsXG5cdFx0XHQvL3ZhbHVlUHJlZml4OiAnJyxcblx0XHRcdC8vdmFsdWVTdWZmaXg6ICcnXG5cdFx0fSxcblxuXHRcdGNyZWRpdHM6IHtcblx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHR0ZXh0OiAnSGlnaGNoYXJ0cy5jb20nLFxuXHRcdFx0aHJlZjogJ2h0dHA6Ly93d3cuaGlnaGNoYXJ0cy5jb20nLFxuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0YWxpZ246ICdyaWdodCcsXG5cdFx0XHRcdHg6IC0xMCxcblx0XHRcdFx0dmVydGljYWxBbGlnbjogJ2JvdHRvbScsXG5cdFx0XHRcdHk6IC01XG5cdFx0XHR9LFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Y3Vyc29yOiAncG9pbnRlcicsXG5cdFx0XHRcdGNvbG9yOiAnIzkwOTA5MCcsXG5cdFx0XHRcdGZvbnRTaXplOiAnOXB4J1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXG5cblxuXHQvLyBTZXJpZXMgZGVmYXVsdHNcblx0dmFyIGRlZmF1bHRQbG90T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zLnBsb3RPcHRpb25zLFxuXHRcdGRlZmF1bHRTZXJpZXNPcHRpb25zID0gZGVmYXVsdFBsb3RPcHRpb25zLmxpbmU7XG5cblx0Ly8gc2V0IHRoZSBkZWZhdWx0IHRpbWUgbWV0aG9kc1xuXHRzZXRUaW1lTWV0aG9kcygpO1xuXG5cblxuXHQvKipcblx0ICogU2V0IHRoZSB0aW1lIG1ldGhvZHMgZ2xvYmFsbHkgYmFzZWQgb24gdGhlIHVzZVVUQyBvcHRpb24uIFRpbWUgbWV0aG9kIGNhbiBiZSBlaXRoZXJcblx0ICogbG9jYWwgdGltZSBvciBVVEMgKGRlZmF1bHQpLlxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0VGltZU1ldGhvZHMoKSB7XG5cdFx0dmFyIGdsb2JhbE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucy5nbG9iYWwsXG5cdFx0XHR1c2VVVEMgPSBnbG9iYWxPcHRpb25zLnVzZVVUQyxcblx0XHRcdEdFVCA9IHVzZVVUQyA/ICdnZXRVVEMnIDogJ2dldCcsXG5cdFx0XHRTRVQgPSB1c2VVVEMgPyAnc2V0VVRDJyA6ICdzZXQnO1xuXG5cblx0XHREYXRlID0gZ2xvYmFsT3B0aW9ucy5EYXRlIHx8IHdpbmRvdy5EYXRlO1xuXHRcdHRpbWV6b25lT2Zmc2V0ID0gdXNlVVRDICYmIGdsb2JhbE9wdGlvbnMudGltZXpvbmVPZmZzZXQ7XG5cdFx0Z2V0VGltZXpvbmVPZmZzZXQgPSB1c2VVVEMgJiYgZ2xvYmFsT3B0aW9ucy5nZXRUaW1lem9uZU9mZnNldDtcblx0XHRtYWtlVGltZSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcblx0XHRcdHZhciBkO1xuXHRcdFx0aWYgKHVzZVVUQykge1xuXHRcdFx0XHRkID0gRGF0ZS5VVEMuYXBwbHkoMCwgYXJndW1lbnRzKTtcblx0XHRcdFx0ZCArPSBnZXRUWk9mZnNldChkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGQgPSBuZXcgRGF0ZShcblx0XHRcdFx0XHR5ZWFyLFxuXHRcdFx0XHRcdG1vbnRoLFxuXHRcdFx0XHRcdHBpY2soZGF0ZSwgMSksXG5cdFx0XHRcdFx0cGljayhob3VycywgMCksXG5cdFx0XHRcdFx0cGljayhtaW51dGVzLCAwKSxcblx0XHRcdFx0XHRwaWNrKHNlY29uZHMsIDApXG5cdFx0XHRcdCkuZ2V0VGltZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGQ7XG5cdFx0fTtcblx0XHRnZXRNaW51dGVzID0gIEdFVCArICdNaW51dGVzJztcblx0XHRnZXRIb3VycyA9ICAgIEdFVCArICdIb3Vycyc7XG5cdFx0Z2V0RGF5ID0gICAgICBHRVQgKyAnRGF5Jztcblx0XHRnZXREYXRlID0gICAgIEdFVCArICdEYXRlJztcblx0XHRnZXRNb250aCA9ICAgIEdFVCArICdNb250aCc7XG5cdFx0Z2V0RnVsbFllYXIgPSBHRVQgKyAnRnVsbFllYXInO1xuXHRcdHNldE1pbnV0ZXMgPSAgU0VUICsgJ01pbnV0ZXMnO1xuXHRcdHNldEhvdXJzID0gICAgU0VUICsgJ0hvdXJzJztcblx0XHRzZXREYXRlID0gICAgIFNFVCArICdEYXRlJztcblx0XHRzZXRNb250aCA9ICAgIFNFVCArICdNb250aCc7XG5cdFx0c2V0RnVsbFllYXIgPSBTRVQgKyAnRnVsbFllYXInO1xuXG5cdH1cblxuXHQvKipcblx0ICogTWVyZ2UgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIGN1c3RvbSBvcHRpb25zIGFuZCByZXR1cm4gdGhlIG5ldyBvcHRpb25zIHN0cnVjdHVyZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgbmV3IGN1c3RvbSBvcHRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRcblx0XHQvLyBDb3B5IGluIHRoZSBkZWZhdWx0IG9wdGlvbnNcblx0XHRkZWZhdWx0T3B0aW9ucyA9IG1lcmdlKHRydWUsIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblx0XHRcblx0XHQvLyBBcHBseSBVVENcblx0XHRzZXRUaW1lTWV0aG9kcygpO1xuXG5cdFx0cmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdXBkYXRlZCBkZWZhdWx0IG9wdGlvbnMuIFVudGlsIDMuMC43LCBtZXJlbHkgZXhwb3NpbmcgZGVmYXVsdE9wdGlvbnMgZm9yIG91dHNpZGUgbW9kdWxlc1xuXHQgKiB3YXNuJ3QgZW5vdWdoIGJlY2F1c2UgdGhlIHNldE9wdGlvbnMgbWV0aG9kIGNyZWF0ZWQgYSBuZXcgb2JqZWN0LlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcblx0XHRyZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgY29sb3Igb3BlcmF0aW9ucy4gVGhlIG9iamVjdCBtZXRob2RzIGFyZSBjaGFpbmFibGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgaW5wdXQgY29sb3IgaW4gZWl0aGVyIHJiZ2Egb3IgaGV4IGZvcm1hdFxuXHQgKi9cblx0dmFyIHJnYmFSZWdFeCA9IC9yZ2JhXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XT8oPzpcXC5bMC05XSspPylcXHMqXFwpLyxcblx0XHRoZXhSZWdFeCA9IC8jKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkoW2EtZkEtRjAtOV17Mn0pLyxcblx0XHRyZ2JSZWdFeCA9IC9yZ2JcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKlxcKS87XG5cblx0dmFyIENvbG9yID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0Ly8gZGVjbGFyZSB2YXJpYWJsZXNcblx0XHR2YXIgcmdiYSA9IFtdLCByZXN1bHQsIHN0b3BzO1xuXG5cdFx0LyoqXG5cdFx0ICogUGFyc2UgdGhlIGlucHV0IGNvbG9yIHRvIHJnYmEgYXJyYXlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBpbml0KGlucHV0KSB7XG5cblx0XHRcdC8vIEdyYWRpZW50c1xuXHRcdFx0aWYgKGlucHV0ICYmIGlucHV0LnN0b3BzKSB7XG5cdFx0XHRcdHN0b3BzID0gbWFwKGlucHV0LnN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuXHRcdFx0XHRcdHJldHVybiBDb2xvcihzdG9wWzFdKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIFNvbGlkIGNvbG9yc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gcmdiYVxuXHRcdFx0XHRyZXN1bHQgPSByZ2JhUmVnRXguZXhlYyhpbnB1dCk7XG5cdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRyZ2JhID0gW3BJbnQocmVzdWx0WzFdKSwgcEludChyZXN1bHRbMl0pLCBwSW50KHJlc3VsdFszXSksIHBhcnNlRmxvYXQocmVzdWx0WzRdLCAxMCldO1xuXHRcdFx0XHR9IGVsc2UgeyBcblx0XHRcdFx0XHQvLyBoZXhcblx0XHRcdFx0XHRyZXN1bHQgPSBoZXhSZWdFeC5leGVjKGlucHV0KTtcblx0XHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRyZ2JhID0gW3BJbnQocmVzdWx0WzFdLCAxNiksIHBJbnQocmVzdWx0WzJdLCAxNiksIHBJbnQocmVzdWx0WzNdLCAxNiksIDFdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyByZ2Jcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHJnYlJlZ0V4LmV4ZWMoaW5wdXQpO1xuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRcdFx0XHRyZ2JhID0gW3BJbnQocmVzdWx0WzFdKSwgcEludChyZXN1bHRbMl0pLCBwSW50KHJlc3VsdFszXSksIDFdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVx0XHRcblxuXHRcdH1cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdGhlIGNvbG9yIGEgc3BlY2lmaWVkIGZvcm1hdFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXQoZm9ybWF0KSB7XG5cdFx0XHR2YXIgcmV0O1xuXG5cdFx0XHRpZiAoc3RvcHMpIHtcblx0XHRcdFx0cmV0ID0gbWVyZ2UoaW5wdXQpO1xuXHRcdFx0XHRyZXQuc3RvcHMgPSBbXS5jb25jYXQocmV0LnN0b3BzKTtcblx0XHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3AsIGkpIHtcblx0XHRcdFx0XHRyZXQuc3RvcHNbaV0gPSBbcmV0LnN0b3BzW2ldWzBdLCBzdG9wLmdldChmb3JtYXQpXTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIGl0J3MgTmFOIGlmIGdyYWRpZW50IGNvbG9ycyBvbiBhIGNvbHVtbiBjaGFydFxuXHRcdFx0fSBlbHNlIGlmIChyZ2JhICYmICFpc05hTihyZ2JhWzBdKSkge1xuXHRcdFx0XHRpZiAoZm9ybWF0ID09PSAncmdiJykge1xuXHRcdFx0XHRcdHJldCA9ICdyZ2IoJyArIHJnYmFbMF0gKyAnLCcgKyByZ2JhWzFdICsgJywnICsgcmdiYVsyXSArICcpJztcblx0XHRcdFx0fSBlbHNlIGlmIChmb3JtYXQgPT09ICdhJykge1xuXHRcdFx0XHRcdHJldCA9IHJnYmFbM107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0ID0gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXQgPSBpbnB1dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQnJpZ2h0ZW4gdGhlIGNvbG9yXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gYnJpZ2h0ZW4oYWxwaGEpIHtcblx0XHRcdGlmIChzdG9wcykge1xuXHRcdFx0XHRlYWNoKHN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuXHRcdFx0XHRcdHN0b3AuYnJpZ2h0ZW4oYWxwaGEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmIChpc051bWJlcihhbHBoYSkgJiYgYWxwaGEgIT09IDApIHtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0XHRyZ2JhW2ldICs9IHBJbnQoYWxwaGEgKiAyNTUpO1xuXG5cdFx0XHRcdFx0aWYgKHJnYmFbaV0gPCAwKSB7XG5cdFx0XHRcdFx0XHRyZ2JhW2ldID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHJnYmFbaV0gPiAyNTUpIHtcblx0XHRcdFx0XHRcdHJnYmFbaV0gPSAyNTU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBjb2xvcidzIG9wYWNpdHkgdG8gYSBnaXZlbiBhbHBoYSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHNldE9wYWNpdHkoYWxwaGEpIHtcblx0XHRcdHJnYmFbM10gPSBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIGluaXRpYWxpemU6IHBhcnNlIHRoZSBpbnB1dFxuXHRcdGluaXQoaW5wdXQpO1xuXG5cdFx0Ly8gcHVibGljIG1ldGhvZHNcblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRicmlnaHRlbjogYnJpZ2h0ZW4sXG5cdFx0XHRyZ2JhOiByZ2JhLFxuXHRcdFx0c2V0T3BhY2l0eTogc2V0T3BhY2l0eSxcblx0XHRcdHJhdzogaW5wdXRcblx0XHR9O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEEgd3JhcHBlciBvYmplY3QgZm9yIFNWRyBlbGVtZW50c1xuXHQgKi9cblx0ZnVuY3Rpb24gU1ZHRWxlbWVudCgpIHt9XG5cblx0U1ZHRWxlbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0XG5cdFx0Ly8gRGVmYXVsdCBiYXNlIGZvciBhbmltYXRpb25cblx0XHRvcGFjaXR5OiAxLFxuXHRcdC8vIEZvciBsYWJlbHMsIHRoZXNlIENTUyBwcm9wZXJ0aWVzIGFyZSBhcHBsaWVkIHRvIHRoZSA8dGV4dD4gbm9kZSBkaXJlY3RseVxuXHRcdHRleHRQcm9wczogWydmb250U2l6ZScsICdmb250V2VpZ2h0JywgJ2ZvbnRGYW1pbHknLCAnY29sb3InLCBcblx0XHRcdCdsaW5lSGVpZ2h0JywgJ3dpZHRoJywgJ3RleHREZWNvcmF0aW9uJywgJ3RleHRTaGFkb3cnXSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBTVkcgcmVuZGVyZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyZXJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAocmVuZGVyZXIsIG5vZGVOYW1lKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXM7XG5cdFx0XHR3cmFwcGVyLmVsZW1lbnQgPSBub2RlTmFtZSA9PT0gJ3NwYW4nID9cblx0XHRcdFx0Y3JlYXRlRWxlbWVudChub2RlTmFtZSkgOlxuXHRcdFx0XHRkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgbm9kZU5hbWUpO1xuXHRcdFx0d3JhcHBlci5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQW5pbWF0ZSBhIGdpdmVuIGF0dHJpYnV0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucyBUaGUgc2FtZSBvcHRpb25zIGFzIGluIGpRdWVyeSBhbmltYXRpb25cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wbGV0ZSBGdW5jdGlvbiB0byBwZXJmb3JtIGF0IHRoZSBlbmQgb2YgYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0YW5pbWF0ZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucywgY29tcGxldGUpIHtcblx0XHRcdHZhciBhbmltT3B0aW9ucyA9IHBpY2sob3B0aW9ucywgZ2xvYmFsQW5pbWF0aW9uLCB0cnVlKTtcblx0XHRcdHN0b3AodGhpcyk7IC8vIHN0b3AgcmVnYXJkbGVzcyBvZiBhbmltYXRpb24gYWN0dWFsbHkgcnVubmluZywgb3IgcmV2ZXJ0aW5nIHRvIC5hdHRyICgjNjA3KVxuXHRcdFx0aWYgKGFuaW1PcHRpb25zKSB7XG5cdFx0XHRcdGFuaW1PcHRpb25zID0gbWVyZ2UoYW5pbU9wdGlvbnMsIHt9KTsgLy8jMjYyNVxuXHRcdFx0XHRpZiAoY29tcGxldGUpIHsgLy8gYWxsb3dzIHVzaW5nIGEgY2FsbGJhY2sgd2l0aCB0aGUgZ2xvYmFsIGFuaW1hdGlvbiB3aXRob3V0IG92ZXJ3cml0aW5nIGl0XG5cdFx0XHRcdFx0YW5pbU9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmltYXRlKHRoaXMsIHBhcmFtcywgYW5pbU9wdGlvbnMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hdHRyKHBhcmFtcyk7XG5cdFx0XHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0XHRcdGNvbXBsZXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBCdWlsZCBhbiBTVkcgZ3JhZGllbnQgb3V0IG9mIGEgY29tbW9uIEphdmFTY3JpcHQgY29uZmlndXJhdGlvbiBvYmplY3Rcblx0XHQgKi9cblx0XHRjb2xvckdyYWRpZW50OiBmdW5jdGlvbiAoY29sb3IsIHByb3AsIGVsZW0pIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRcdGNvbG9yT2JqZWN0LFxuXHRcdFx0XHRncmFkTmFtZSxcblx0XHRcdFx0Z3JhZEF0dHIsXG5cdFx0XHRcdGdyYWRpZW50cyxcblx0XHRcdFx0Z3JhZGllbnRPYmplY3QsXG5cdFx0XHRcdHN0b3BzLFxuXHRcdFx0XHRzdG9wQ29sb3IsXG5cdFx0XHRcdHN0b3BPcGFjaXR5LFxuXHRcdFx0XHRyYWRpYWxSZWZlcmVuY2UsXG5cdFx0XHRcdG4sXG5cdFx0XHRcdGlkLFxuXHRcdFx0XHRrZXkgPSBbXTtcblxuXHRcdFx0Ly8gQXBwbHkgbGluZWFyIG9yIHJhZGlhbCBncmFkaWVudHNcblx0XHRcdGlmIChjb2xvci5saW5lYXJHcmFkaWVudCkge1xuXHRcdFx0XHRncmFkTmFtZSA9ICdsaW5lYXJHcmFkaWVudCc7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbG9yLnJhZGlhbEdyYWRpZW50KSB7XG5cdFx0XHRcdGdyYWROYW1lID0gJ3JhZGlhbEdyYWRpZW50Jztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGdyYWROYW1lKSB7XG5cdFx0XHRcdGdyYWRBdHRyID0gY29sb3JbZ3JhZE5hbWVdO1xuXHRcdFx0XHRncmFkaWVudHMgPSByZW5kZXJlci5ncmFkaWVudHM7XG5cdFx0XHRcdHN0b3BzID0gY29sb3Iuc3RvcHM7XG5cdFx0XHRcdHJhZGlhbFJlZmVyZW5jZSA9IGVsZW0ucmFkaWFsUmVmZXJlbmNlO1xuXG5cdFx0XHRcdC8vIEtlZXAgPCAyLjIga29tcGF0aWJpbGl0eVxuXHRcdFx0XHRpZiAoaXNBcnJheShncmFkQXR0cikpIHtcblx0XHRcdFx0XHRjb2xvcltncmFkTmFtZV0gPSBncmFkQXR0ciA9IHtcblx0XHRcdFx0XHRcdHgxOiBncmFkQXR0clswXSxcblx0XHRcdFx0XHRcdHkxOiBncmFkQXR0clsxXSxcblx0XHRcdFx0XHRcdHgyOiBncmFkQXR0clsyXSxcblx0XHRcdFx0XHRcdHkyOiBncmFkQXR0clszXSxcblx0XHRcdFx0XHRcdGdyYWRpZW50VW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29ycmVjdCB0aGUgcmFkaWFsIGdyYWRpZW50IGZvciB0aGUgcmFkaWFsIHJlZmVyZW5jZSBzeXN0ZW1cblx0XHRcdFx0aWYgKGdyYWROYW1lID09PSAncmFkaWFsR3JhZGllbnQnICYmIHJhZGlhbFJlZmVyZW5jZSAmJiAhZGVmaW5lZChncmFkQXR0ci5ncmFkaWVudFVuaXRzKSkge1xuXHRcdFx0XHRcdGdyYWRBdHRyID0gbWVyZ2UoZ3JhZEF0dHIsIHtcblx0XHRcdFx0XHRcdGN4OiAocmFkaWFsUmVmZXJlbmNlWzBdIC0gcmFkaWFsUmVmZXJlbmNlWzJdIC8gMikgKyBncmFkQXR0ci5jeCAqIHJhZGlhbFJlZmVyZW5jZVsyXSxcblx0XHRcdFx0XHRcdGN5OiAocmFkaWFsUmVmZXJlbmNlWzFdIC0gcmFkaWFsUmVmZXJlbmNlWzJdIC8gMikgKyBncmFkQXR0ci5jeSAqIHJhZGlhbFJlZmVyZW5jZVsyXSxcblx0XHRcdFx0XHRcdHI6IGdyYWRBdHRyLnIgKiByYWRpYWxSZWZlcmVuY2VbMl0sXG5cdFx0XHRcdFx0XHRncmFkaWVudFVuaXRzOiAndXNlclNwYWNlT25Vc2UnXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBCdWlsZCB0aGUgdW5pcXVlIGtleSB0byBkZXRlY3Qgd2hldGhlciB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBlbGVtZW50ICgjMTI4Milcblx0XHRcdFx0Zm9yIChuIGluIGdyYWRBdHRyKSB7XG5cdFx0XHRcdFx0aWYgKG4gIT09ICdpZCcpIHtcblx0XHRcdFx0XHRcdGtleS5wdXNoKG4sIGdyYWRBdHRyW25dKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChuIGluIHN0b3BzKSB7XG5cdFx0XHRcdFx0a2V5LnB1c2goc3RvcHNbbl0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleSA9IGtleS5qb2luKCcsJyk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgYSBncmFkaWVudCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBjb25maWcgb2JqZWN0IGlzIGNyZWF0ZWQgd2l0aGluIHRoaXMgcmVuZGVyZXJcblx0XHRcdFx0aWYgKGdyYWRpZW50c1trZXldKSB7XG5cdFx0XHRcdFx0aWQgPSBncmFkaWVudHNba2V5XS5hdHRyKCdpZCcpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBTZXQgdGhlIGlkIGFuZCBjcmVhdGUgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRncmFkQXR0ci5pZCA9IGlkID0gUFJFRklYICsgaWRDb3VudGVyKys7XG5cdFx0XHRcdFx0Z3JhZGllbnRzW2tleV0gPSBncmFkaWVudE9iamVjdCA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoZ3JhZE5hbWUpXG5cdFx0XHRcdFx0XHQuYXR0cihncmFkQXR0cilcblx0XHRcdFx0XHRcdC5hZGQocmVuZGVyZXIuZGVmcyk7XG5cblxuXHRcdFx0XHRcdC8vIFRoZSBncmFkaWVudCBuZWVkcyB0byBrZWVwIGEgbGlzdCBvZiBzdG9wcyB0byBiZSBhYmxlIHRvIGRlc3Ryb3kgdGhlbVxuXHRcdFx0XHRcdGdyYWRpZW50T2JqZWN0LnN0b3BzID0gW107XG5cdFx0XHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3ApIHtcblx0XHRcdFx0XHRcdHZhciBzdG9wT2JqZWN0O1xuXHRcdFx0XHRcdFx0aWYgKHN0b3BbMV0uaW5kZXhPZigncmdiYScpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvbG9yT2JqZWN0ID0gQ29sb3Ioc3RvcFsxXSk7XG5cdFx0XHRcdFx0XHRcdHN0b3BDb2xvciA9IGNvbG9yT2JqZWN0LmdldCgncmdiJyk7XG5cdFx0XHRcdFx0XHRcdHN0b3BPcGFjaXR5ID0gY29sb3JPYmplY3QuZ2V0KCdhJyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdG9wQ29sb3IgPSBzdG9wWzFdO1xuXHRcdFx0XHRcdFx0XHRzdG9wT3BhY2l0eSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdG9wT2JqZWN0ID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnc3RvcCcpLmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRvZmZzZXQ6IHN0b3BbMF0sXG5cdFx0XHRcdFx0XHRcdCdzdG9wLWNvbG9yJzogc3RvcENvbG9yLFxuXHRcdFx0XHRcdFx0XHQnc3RvcC1vcGFjaXR5Jzogc3RvcE9wYWNpdHlcblx0XHRcdFx0XHRcdH0pLmFkZChncmFkaWVudE9iamVjdCk7XG5cblx0XHRcdFx0XHRcdC8vIEFkZCB0aGUgc3RvcCBlbGVtZW50IHRvIHRoZSBncmFkaWVudFxuXHRcdFx0XHRcdFx0Z3JhZGllbnRPYmplY3Quc3RvcHMucHVzaChzdG9wT2JqZWN0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBncmFkaWVudCBvYmplY3Rcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUocHJvcCwgJ3VybCgnICsgcmVuZGVyZXIudXJsICsgJyMnICsgaWQgKyAnKScpO1xuXHRcdFx0fSBcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgYSBwb2x5ZmlsbCB0byB0aGUgdGV4dC1zdHJva2UgQ1NTIHByb3BlcnR5LCBieSBjb3B5aW5nIHRoZSB0ZXh0IGVsZW1lbnRcblx0XHQgKiBhbmQgYXBwbHkgc3Ryb2tlcyB0byB0aGUgY29weS5cblx0XHQgKlxuXHRcdCAqIGRvY3M6IHVwZGF0ZSBkZWZhdWx0LCBkb2N1bWVudCB0aGUgcG9seWZpbGwgYW5kIHRoZSBsaW1pdGF0aW9ucyBvbiBoZXggY29sb3JzIGFuZCBwaXhlbCB2YWx1ZXMsIGRvY3VtZW50IGNvbnRyYXN0IHBzZXVkby1jb2xvclxuXHRcdCAqIFRPRE86IFxuXHRcdCAqIC0gdXBkYXRlIGRlZmF1bHRzXG5cdFx0ICovXG5cdFx0YXBwbHlUZXh0U2hhZG93OiBmdW5jdGlvbiAodGV4dFNoYWRvdykge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdHRzcGFucyxcblx0XHRcdFx0aGFzQ29udHJhc3QgPSB0ZXh0U2hhZG93LmluZGV4T2YoJ2NvbnRyYXN0JykgIT09IC0xLFxuXHRcdFx0XHQvLyBJRTEwIGFuZCBJRTExIHJlcG9ydCB0ZXh0U2hhZG93IGluIGVsZW0uc3R5bGUgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCB3b3JrLiBDaGVja1xuXHRcdFx0XHQvLyB0aGlzIGFnYWluIHdpdGggbmV3IElFIHJlbGVhc2UuIEluIGV4cG9ydHMsIHRoZSByZW5kZXJpbmcgaXMgcGFzc2VkIHRvIFBoYW50b21KUy4gXG5cdFx0XHRcdHN1cHBvcnRzID0gdGhpcy5yZW5kZXJlci5mb3JFeHBvcnQgfHwgKGVsZW0uc3R5bGUudGV4dFNoYWRvdyAhPT0gVU5ERUZJTkVEICYmICFpc0lFKTtcblxuXHRcdFx0Ly8gV2hlbiB0aGUgdGV4dCBzaGFkb3cgaXMgc2V0IHRvIGNvbnRyYXN0LCB1c2UgZGFyayBzdHJva2UgZm9yIGxpZ2h0IHRleHQgYW5kIHZpY2UgdmVyc2Fcblx0XHRcdGlmIChoYXNDb250cmFzdCkge1xuXHRcdFx0XHR0ZXh0U2hhZG93ID0gdGV4dFNoYWRvdy5yZXBsYWNlKC9jb250cmFzdC9nLCB0aGlzLnJlbmRlcmVyLmdldENvbnRyYXN0KGVsZW0uc3R5bGUuZmlsbCkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBTZWxlY3RpdmUgc2lkZS1ieS1zaWRlIHRlc3RpbmcgaW4gc3VwcG9ydGVkIGJyb3dzZXIgKGh0dHA6Ly9qc2ZpZGRsZS5uZXQvaGlnaGNoYXJ0cy83M0wxcHRyaC8pXG5cdFx0XHRpZiAoZWxlbS50ZXh0Q29udGVudC5pbmRleE9mKCcyLicpID09PSAwKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGVbJ3RleHQtc2hhZG93J10gPSAnbm9uZSc7XG5cdFx0XHRcdHN1cHBvcnRzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyAqL1xuXG5cdFx0XHQvLyBObyByZWFzb24gdG8gcG9seWZpbGwsIHdlJ3ZlIGdvdCBuYXRpdmUgc3VwcG9ydFxuXHRcdFx0aWYgKHN1cHBvcnRzKSB7XG5cdFx0XHRcdGlmIChoYXNDb250cmFzdCkgeyAvLyBBcHBseSB0aGUgYWx0ZXJlZCBzdHlsZVxuXHRcdFx0XHRcdGNzcyhlbGVtLCB7XG5cdFx0XHRcdFx0XHR0ZXh0U2hhZG93OiB0ZXh0U2hhZG93XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5mYWtlVFMgPSB0cnVlOyAvLyBGYWtlIHRleHQgc2hhZG93XG5cblx0XHRcdFx0Ly8gSW4gb3JkZXIgdG8gZ2V0IHRoZSByaWdodCB5IHBvc2l0aW9uIG9mIHRoZSBjbG9uZXMsIFxuXHRcdFx0XHQvLyBjb3B5IG92ZXIgdGhlIHkgc2V0dGVyXG5cdFx0XHRcdHRoaXMueVNldHRlciA9IHRoaXMueFNldHRlcjtcblxuXHRcdFx0XHR0c3BhbnMgPSBbXS5zbGljZS5jYWxsKGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RzcGFuJykpO1xuXHRcdFx0XHRlYWNoKHRleHRTaGFkb3cuc3BsaXQoL1xccz8sXFxzPy9nKSwgZnVuY3Rpb24gKHRleHRTaGFkb3cpIHtcblx0XHRcdFx0XHR2YXIgZmlyc3RDaGlsZCA9IGVsZW0uZmlyc3RDaGlsZCxcblx0XHRcdFx0XHRcdGNvbG9yLFxuXHRcdFx0XHRcdFx0c3Ryb2tlV2lkdGg7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGV4dFNoYWRvdyA9IHRleHRTaGFkb3cuc3BsaXQoJyAnKTtcblx0XHRcdFx0XHRjb2xvciA9IHRleHRTaGFkb3dbdGV4dFNoYWRvdy5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdC8vIEFwcHJveGltYXRlbHkgdHVuZSB0aGUgc2V0dGluZ3MgdG8gdGhlIHRleHQtc2hhZG93IGJlaGF2aW91clxuXHRcdFx0XHRcdHN0cm9rZVdpZHRoID0gdGV4dFNoYWRvd1t0ZXh0U2hhZG93Lmxlbmd0aCAtIDJdO1xuXG5cdFx0XHRcdFx0aWYgKHN0cm9rZVdpZHRoKSB7XG5cdFx0XHRcdFx0XHRlYWNoKHRzcGFucywgZnVuY3Rpb24gKHRzcGFuLCB5KSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjbG9uZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBMZXQgdGhlIGZpcnN0IGxpbmUgc3RhcnQgYXQgdGhlIGNvcnJlY3QgWCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRpZiAoeSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHRzcGFuLnNldEF0dHJpYnV0ZSgneCcsIGVsZW0uZ2V0QXR0cmlidXRlKCd4JykpO1xuXHRcdFx0XHRcdFx0XHRcdHkgPSBlbGVtLmdldEF0dHJpYnV0ZSgneScpO1xuXHRcdFx0XHRcdFx0XHRcdHRzcGFuLnNldEF0dHJpYnV0ZSgneScsIHkgfHwgMCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHkgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCd5JywgMCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBjbG9uZSBhbmQgYXBwbHkgc2hhZG93IHByb3BlcnRpZXNcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSB0c3Bhbi5jbG9uZU5vZGUoMSk7XG5cdFx0XHRcdFx0XHRcdGF0dHIoY2xvbmUsIHtcblx0XHRcdFx0XHRcdFx0XHQnY2xhc3MnOiBQUkVGSVggKyAndGV4dC1zaGFkb3cnLFxuXHRcdFx0XHRcdFx0XHRcdCdmaWxsJzogY29sb3IsXG5cdFx0XHRcdFx0XHRcdFx0J3N0cm9rZSc6IGNvbG9yLFxuXHRcdFx0XHRcdFx0XHRcdCdzdHJva2Utb3BhY2l0eSc6IDEgLyBtYXRoTWF4KHBJbnQoc3Ryb2tlV2lkdGgpLCAzKSxcblx0XHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0J3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCdcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5zZXJ0QmVmb3JlKGNsb25lLCBmaXJzdENoaWxkKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCBvciBnZXQgYSBnaXZlbiBhdHRyaWJ1dGVcblx0XHQgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGhhc2hcblx0XHQgKiBAcGFyYW0ge01peGVkfFVuZGVmaW5lZH0gdmFsXG5cdFx0ICovXG5cdFx0YXR0cjogZnVuY3Rpb24gKGhhc2gsIHZhbCkge1xuXHRcdFx0dmFyIGtleSxcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdGhhc1NldFN5bWJvbFNpemUsXG5cdFx0XHRcdHJldCA9IHRoaXMsXG5cdFx0XHRcdHNraXBBdHRyO1xuXG5cdFx0XHQvLyBzaW5nbGUga2V5LXZhbHVlIHBhaXJcblx0XHRcdGlmICh0eXBlb2YgaGFzaCA9PT0gJ3N0cmluZycgJiYgdmFsICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0a2V5ID0gaGFzaDtcblx0XHRcdFx0aGFzaCA9IHt9O1xuXHRcdFx0XHRoYXNoW2tleV0gPSB2YWw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHVzZWQgYXMgYSBnZXR0ZXI6IGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLCBzZWNvbmQgaXMgdW5kZWZpbmVkXG5cdFx0XHRpZiAodHlwZW9mIGhhc2ggPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldCA9ICh0aGlzW2hhc2ggKyAnR2V0dGVyJ10gfHwgdGhpcy5fZGVmYXVsdEdldHRlcikuY2FsbCh0aGlzLCBoYXNoLCBlbGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Ly8gc2V0dGVyXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZvciAoa2V5IGluIGhhc2gpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGhhc2hba2V5XTtcblx0XHRcdFx0XHRza2lwQXR0ciA9IGZhbHNlO1xuXG5cblxuXHRcdFx0XHRcdGlmICh0aGlzLnN5bWJvbE5hbWUgJiYgL14oeHx5fHdpZHRofGhlaWdodHxyfHN0YXJ0fGVuZHxpbm5lclJ8YW5jaG9yWHxhbmNob3JZKS8udGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWhhc1NldFN5bWJvbFNpemUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zeW1ib2xBdHRyKGhhc2gpO1xuXHRcdFx0XHRcdFx0XHRoYXNTZXRTeW1ib2xTaXplID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNraXBBdHRyID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGhpcy5yb3RhdGlvbiAmJiAoa2V5ID09PSAneCcgfHwga2V5ID09PSAneScpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRvVHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCFza2lwQXR0cikge1xuXHRcdFx0XHRcdFx0KHRoaXNba2V5ICsgJ1NldHRlciddIHx8IHRoaXMuX2RlZmF1bHRTZXR0ZXIpLmNhbGwodGhpcywgdmFsdWUsIGtleSwgZWxlbWVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGV0IHRoZSBzaGFkb3cgZm9sbG93IHRoZSBtYWluIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAodGhpcy5zaGFkb3dzICYmIC9eKHdpZHRofGhlaWdodHx2aXNpYmlsaXR5fHh8eXxkfHRyYW5zZm9ybXxjeHxjeXxyKSQvLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGVTaGFkb3dzKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVwZGF0ZSB0cmFuc2Zvcm0uIERvIHRoaXMgb3V0c2lkZSB0aGUgbG9vcCB0byBwcmV2ZW50IHJlZHVuZGFudCB1cGRhdGluZyBmb3IgYmF0Y2ggc2V0dGluZ1xuXHRcdFx0XHQvLyBvZiBhdHRyaWJ1dGVzLlxuXHRcdFx0XHRpZiAodGhpcy5kb1RyYW5zZm9ybSkge1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0XHRcdFx0dGhpcy5kb1RyYW5zZm9ybSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0dXBkYXRlU2hhZG93czogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdHZhciBzaGFkb3dzID0gdGhpcy5zaGFkb3dzLFxuXHRcdFx0XHRpID0gc2hhZG93cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHNoYWRvd3NbaV0uc2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRrZXkgPT09ICdoZWlnaHQnID9cblx0XHRcdFx0XHRcdG1hdGhNYXgodmFsdWUgLSAoc2hhZG93c1tpXS5jdXRIZWlnaHQgfHwgMCksIDApIDpcblx0XHRcdFx0XHRcdGtleSA9PT0gJ2QnID8gdGhpcy5kIDogdmFsdWVcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG5cdFx0ICovXG5cdFx0YWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0XHRjdXJyZW50Q2xhc3NOYW1lID0gYXR0cihlbGVtZW50LCAnY2xhc3MnKSB8fCAnJztcblxuXHRcdFx0aWYgKGN1cnJlbnRDbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpID09PSAtMSkge1xuXHRcdFx0XHRhdHRyKGVsZW1lbnQsICdjbGFzcycsIGN1cnJlbnRDbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHQvKiBoYXNDbGFzcyBhbmQgcmVtb3ZlQ2xhc3MgYXJlIG5vdCAoeWV0KSBuZWVkZWRcblx0XHRoYXNDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHRcdFx0cmV0dXJuIGF0dHIodGhpcy5lbGVtZW50LCAnY2xhc3MnKS5pbmRleE9mKGNsYXNzTmFtZSkgIT09IC0xO1xuXHRcdH0sXG5cdFx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRcdGF0dHIodGhpcy5lbGVtZW50LCAnY2xhc3MnLCBhdHRyKHRoaXMuZWxlbWVudCwgJ2NsYXNzJykucmVwbGFjZShjbGFzc05hbWUsICcnKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdCovXG5cblx0XHQvKipcblx0XHQgKiBJZiBvbmUgb2YgdGhlIHN5bWJvbCBzaXplIGFmZmVjdGluZyBwYXJhbWV0ZXJzIGFyZSBjaGFuZ2VkLFxuXHRcdCAqIGNoZWNrIGFsbCB0aGUgb3RoZXJzIG9ubHkgb25jZSBmb3IgZWFjaCBjYWxsIHRvIGFuIGVsZW1lbnQnc1xuXHRcdCAqIC5hdHRyKCkgbWV0aG9kXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGhhc2hcblx0XHQgKi9cblx0XHRzeW1ib2xBdHRyOiBmdW5jdGlvbiAoaGFzaCkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzO1xuXG5cdFx0XHRlYWNoKFsneCcsICd5JywgJ3InLCAnc3RhcnQnLCAnZW5kJywgJ3dpZHRoJywgJ2hlaWdodCcsICdpbm5lclInLCAnYW5jaG9yWCcsICdhbmNob3JZJ10sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0d3JhcHBlcltrZXldID0gcGljayhoYXNoW2tleV0sIHdyYXBwZXJba2V5XSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0ZDogd3JhcHBlci5yZW5kZXJlci5zeW1ib2xzW3dyYXBwZXIuc3ltYm9sTmFtZV0oXG5cdFx0XHRcdFx0d3JhcHBlci54LFxuXHRcdFx0XHRcdHdyYXBwZXIueSxcblx0XHRcdFx0XHR3cmFwcGVyLndpZHRoLFxuXHRcdFx0XHRcdHdyYXBwZXIuaGVpZ2h0LFxuXHRcdFx0XHRcdHdyYXBwZXJcblx0XHRcdFx0KVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IGEgY2xpcHBpbmcgcGF0aCB0byB0aGlzIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuXHRcdCAqL1xuXHRcdGNsaXA6IGZ1bmN0aW9uIChjbGlwUmVjdCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0cignY2xpcC1wYXRoJywgY2xpcFJlY3QgPyAndXJsKCcgKyB0aGlzLnJlbmRlcmVyLnVybCArICcjJyArIGNsaXBSZWN0LmlkICsgJyknIDogTk9ORSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENhbGN1bGF0ZSB0aGUgY29vcmRpbmF0ZXMgbmVlZGVkIGZvciBkcmF3aW5nIGEgcmVjdGFuZ2xlIGNyaXNwbHkgYW5kIHJldHVybiB0aGVcblx0XHQgKiBjYWxjdWxhdGVkIGF0dHJpYnV0ZXNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3Ryb2tlV2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHRcdCAqL1xuXHRcdGNyaXNwOiBmdW5jdGlvbiAocmVjdCkge1xuXG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdGtleSxcblx0XHRcdFx0YXR0cmlicyA9IHt9LFxuXHRcdFx0XHRub3JtYWxpemVyLFxuXHRcdFx0XHRzdHJva2VXaWR0aCA9IHJlY3Quc3Ryb2tlV2lkdGggfHwgd3JhcHBlci5zdHJva2VXaWR0aCB8fCAwO1xuXG5cdFx0XHRub3JtYWxpemVyID0gbWF0aFJvdW5kKHN0cm9rZVdpZHRoKSAlIDIgLyAyOyAvLyBtYXRoUm91bmQgYmVjYXVzZSBzdHJva2VXaWR0aCBjYW4gc29tZXRpbWVzIGhhdmUgcm91bmRvZmYgZXJyb3JzXG5cblx0XHRcdC8vIG5vcm1hbGl6ZSBmb3IgY3Jpc3AgZWRnZXNcblx0XHRcdHJlY3QueCA9IG1hdGhGbG9vcihyZWN0LnggfHwgd3JhcHBlci54IHx8IDApICsgbm9ybWFsaXplcjtcblx0XHRcdHJlY3QueSA9IG1hdGhGbG9vcihyZWN0LnkgfHwgd3JhcHBlci55IHx8IDApICsgbm9ybWFsaXplcjtcblx0XHRcdHJlY3Qud2lkdGggPSBtYXRoRmxvb3IoKHJlY3Qud2lkdGggfHwgd3JhcHBlci53aWR0aCB8fCAwKSAtIDIgKiBub3JtYWxpemVyKTtcblx0XHRcdHJlY3QuaGVpZ2h0ID0gbWF0aEZsb29yKChyZWN0LmhlaWdodCB8fCB3cmFwcGVyLmhlaWdodCB8fCAwKSAtIDIgKiBub3JtYWxpemVyKTtcblx0XHRcdHJlY3Quc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcblxuXHRcdFx0Zm9yIChrZXkgaW4gcmVjdCkge1xuXHRcdFx0XHRpZiAod3JhcHBlcltrZXldICE9PSByZWN0W2tleV0pIHsgLy8gb25seSBzZXQgYXR0cmlidXRlIGlmIGNoYW5nZWRcblx0XHRcdFx0XHR3cmFwcGVyW2tleV0gPSBhdHRyaWJzW2tleV0gPSByZWN0W2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGF0dHJpYnM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCBzdHlsZXMgZm9yIHRoZSBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuXHRcdCAqL1xuXHRcdGNzczogZnVuY3Rpb24gKHN0eWxlcykge1xuXHRcdFx0dmFyIGVsZW1XcmFwcGVyID0gdGhpcyxcblx0XHRcdFx0b2xkU3R5bGVzID0gZWxlbVdyYXBwZXIuc3R5bGVzLFxuXHRcdFx0XHRuZXdTdHlsZXMgPSB7fSxcblx0XHRcdFx0ZWxlbSA9IGVsZW1XcmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdHRleHRXaWR0aCxcblx0XHRcdFx0bixcblx0XHRcdFx0c2VyaWFsaXplZENzcyA9ICcnLFxuXHRcdFx0XHRoeXBoZW5hdGUsXG5cdFx0XHRcdGhhc05ldyA9ICFvbGRTdHlsZXM7XG5cblx0XHRcdC8vIGNvbnZlcnQgbGVnYWN5XG5cdFx0XHRpZiAoc3R5bGVzICYmIHN0eWxlcy5jb2xvcikge1xuXHRcdFx0XHRzdHlsZXMuZmlsbCA9IHN0eWxlcy5jb2xvcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBleGlzdGluZyBzdHlsZXMgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UgKCMyNjQwKVxuXHRcdFx0aWYgKG9sZFN0eWxlcykge1xuXHRcdFx0XHRmb3IgKG4gaW4gc3R5bGVzKSB7XG5cdFx0XHRcdFx0aWYgKHN0eWxlc1tuXSAhPT0gb2xkU3R5bGVzW25dKSB7XG5cdFx0XHRcdFx0XHRuZXdTdHlsZXNbbl0gPSBzdHlsZXNbbl07XG5cdFx0XHRcdFx0XHRoYXNOZXcgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc05ldykge1xuXHRcdFx0XHR0ZXh0V2lkdGggPSBlbGVtV3JhcHBlci50ZXh0V2lkdGggPSBcblx0XHRcdFx0XHQoc3R5bGVzICYmIHN0eWxlcy53aWR0aCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0JyAmJiBwSW50KHN0eWxlcy53aWR0aCkpIHx8IFxuXHRcdFx0XHRcdGVsZW1XcmFwcGVyLnRleHRXaWR0aDsgLy8gIzM1MDFcblxuXHRcdFx0XHQvLyBNZXJnZSB0aGUgbmV3IHN0eWxlcyB3aXRoIHRoZSBvbGQgb25lc1xuXHRcdFx0XHRpZiAob2xkU3R5bGVzKSB7XG5cdFx0XHRcdFx0c3R5bGVzID0gZXh0ZW5kKFxuXHRcdFx0XHRcdFx0b2xkU3R5bGVzLFxuXHRcdFx0XHRcdFx0bmV3U3R5bGVzXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVx0XHRcblxuXHRcdFx0XHQvLyBzdG9yZSBvYmplY3Rcblx0XHRcdFx0ZWxlbVdyYXBwZXIuc3R5bGVzID0gc3R5bGVzO1xuXG5cdFx0XHRcdGlmICh0ZXh0V2lkdGggJiYgKHVzZUNhblZHIHx8ICghaGFzU1ZHICYmIGVsZW1XcmFwcGVyLnJlbmRlcmVyLmZvckV4cG9ydCkpKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHN0eWxlcy53aWR0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlcmlhbGl6ZSBhbmQgc2V0IHN0eWxlIGF0dHJpYnV0ZVxuXHRcdFx0XHRpZiAoaXNJRSAmJiAhaGFzU1ZHKSB7XG5cdFx0XHRcdFx0Y3NzKGVsZW1XcmFwcGVyLmVsZW1lbnQsIHN0eWxlcyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogdHJ1ZSovXG5cdFx0XHRcdFx0aHlwaGVuYXRlID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuICctJyArIGIudG9Mb3dlckNhc2UoKTsgfTtcblx0XHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiBmYWxzZSovXG5cdFx0XHRcdFx0Zm9yIChuIGluIHN0eWxlcykge1xuXHRcdFx0XHRcdFx0c2VyaWFsaXplZENzcyArPSBuLnJlcGxhY2UoLyhbQS1aXSkvZywgaHlwaGVuYXRlKSArICc6JyArIHN0eWxlc1tuXSArICc7Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YXR0cihlbGVtLCAnc3R5bGUnLCBzZXJpYWxpemVkQ3NzKTsgLy8gIzE4ODFcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Ly8gcmUtYnVpbGQgdGV4dFxuXHRcdFx0XHRpZiAodGV4dFdpZHRoICYmIGVsZW1XcmFwcGVyLmFkZGVkKSB7XG5cdFx0XHRcdFx0ZWxlbVdyYXBwZXIucmVuZGVyZXIuYnVpbGRUZXh0KGVsZW1XcmFwcGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbVdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG5cdFx0ICovXG5cdFx0b246IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcblx0XHRcdHZhciBzdmdFbGVtZW50ID0gdGhpcyxcblx0XHRcdFx0ZWxlbWVudCA9IHN2Z0VsZW1lbnQuZWxlbWVudDtcblx0XHRcdFxuXHRcdFx0Ly8gdG91Y2hcblx0XHRcdGlmIChoYXNUb3VjaCAmJiBldmVudFR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0ZWxlbWVudC5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZSkge1x0XHRcdFxuXHRcdFx0XHRcdHN2Z0VsZW1lbnQudG91Y2hFdmVudEZpcmVkID0gRGF0ZS5ub3coKTtcdFx0XHRcdFxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRoYW5kbGVyLmNhbGwoZWxlbWVudCwgZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGVsZW1lbnQub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgPT09IC0xIHx8IERhdGUubm93KCkgLSAoc3ZnRWxlbWVudC50b3VjaEV2ZW50RmlyZWQgfHwgMCkgPiAxMTAwKSB7IC8vICMyMjY5XG5cdFx0XHRcdFx0XHRoYW5kbGVyLmNhbGwoZWxlbWVudCwgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1x0XHRcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc2ltcGxlc3QgcG9zc2libGUgZXZlbnQgbW9kZWwgZm9yIGludGVybmFsIHVzZVxuXHRcdFx0XHRlbGVtZW50WydvbicgKyBldmVudFR5cGVdID0gaGFuZGxlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG5lZWRlZCB0byBkcmF3IGEgY29uc2lzdGVudCByYWRpYWwgZ3JhZGllbnQgYWNyb3NzXG5cdFx0ICogcGllIHNsaWNlcyByZWdhcmRsZXNzIG9mIHBvc2l0aW9uaW5nIGluc2lkZSB0aGUgY2hhcnQuIFRoZSBmb3JtYXQgaXNcblx0XHQgKiBbY2VudGVyWCwgY2VudGVyWSwgZGlhbWV0ZXJdIGluIHBpeGVscy5cblx0XHQgKi9cblx0XHRzZXRSYWRpYWxSZWZlcmVuY2U6IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuXHRcdFx0dGhpcy5lbGVtZW50LnJhZGlhbFJlZmVyZW5jZSA9IGNvb3JkaW5hdGVzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1vdmUgYW4gb2JqZWN0IGFuZCBpdHMgY2hpbGRyZW4gYnkgeCBhbmQgeSB2YWx1ZXNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICovXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0cih7XG5cdFx0XHRcdHRyYW5zbGF0ZVg6IHgsXG5cdFx0XHRcdHRyYW5zbGF0ZVk6IHlcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbnZlcnQgYSBncm91cCwgcm90YXRlIGFuZCBmbGlwXG5cdFx0ICovXG5cdFx0aW52ZXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXM7XG5cdFx0XHR3cmFwcGVyLmludmVydGVkID0gdHJ1ZTtcblx0XHRcdHdyYXBwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUHJpdmF0ZSBtZXRob2QgdG8gdXBkYXRlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGJhc2VkIG9uIGludGVybmFsXG5cdFx0ICogcHJvcGVydGllc1xuXHRcdCAqL1xuXHRcdHVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHR0cmFuc2xhdGVYID0gd3JhcHBlci50cmFuc2xhdGVYIHx8IDAsXG5cdFx0XHRcdHRyYW5zbGF0ZVkgPSB3cmFwcGVyLnRyYW5zbGF0ZVkgfHwgMCxcblx0XHRcdFx0c2NhbGVYID0gd3JhcHBlci5zY2FsZVgsXG5cdFx0XHRcdHNjYWxlWSA9IHdyYXBwZXIuc2NhbGVZLFxuXHRcdFx0XHRpbnZlcnRlZCA9IHdyYXBwZXIuaW52ZXJ0ZWQsXG5cdFx0XHRcdHJvdGF0aW9uID0gd3JhcHBlci5yb3RhdGlvbixcblx0XHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0dHJhbnNmb3JtO1xuXG5cdFx0XHQvLyBmbGlwcGluZyBhZmZlY3RzIHRyYW5zbGF0ZSBhcyBhZGp1c3RtZW50IGZvciBmbGlwcGluZyBhcm91bmQgdGhlIGdyb3VwJ3MgYXhpc1xuXHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdHRyYW5zbGF0ZVggKz0gd3JhcHBlci5hdHRyKCd3aWR0aCcpO1xuXHRcdFx0XHR0cmFuc2xhdGVZICs9IHdyYXBwZXIuYXR0cignaGVpZ2h0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHRyYW5zbGF0ZS4gTmVhcmx5IGFsbCB0cmFuc2Zvcm1lZCBlbGVtZW50cyBoYXZlIHRyYW5zbGF0aW9uLCBzbyBpbnN0ZWFkXG5cdFx0XHQvLyBvZiBjaGVja2luZyBmb3IgdHJhbnNsYXRlID0gMCwgZG8gaXQgYWx3YXlzICgjMTc2NywgIzE4NDYpLlxuXHRcdFx0dHJhbnNmb3JtID0gWyd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVggKyAnLCcgKyB0cmFuc2xhdGVZICsgJyknXTtcblxuXHRcdFx0Ly8gYXBwbHkgcm90YXRpb25cblx0XHRcdGlmIChpbnZlcnRlZCkge1xuXHRcdFx0XHR0cmFuc2Zvcm0ucHVzaCgncm90YXRlKDkwKSBzY2FsZSgtMSwxKScpO1xuXHRcdFx0fSBlbHNlIGlmIChyb3RhdGlvbikgeyAvLyB0ZXh0IHJvdGF0aW9uXG5cdFx0XHRcdHRyYW5zZm9ybS5wdXNoKCdyb3RhdGUoJyArIHJvdGF0aW9uICsgJyAnICsgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4JykgfHwgMCkgKyAnICcgKyAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwKSArICcpJyk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBEZWxldGUgYkJveCBtZW1vIHdoZW4gdGhlIHJvdGF0aW9uIGNoYW5nZXNcblx0XHRcdFx0Ly9kZWxldGUgd3JhcHBlci5iQm94O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhcHBseSBzY2FsZVxuXHRcdFx0aWYgKGRlZmluZWQoc2NhbGVYKSB8fCBkZWZpbmVkKHNjYWxlWSkpIHtcblx0XHRcdFx0dHJhbnNmb3JtLnB1c2goJ3NjYWxlKCcgKyBwaWNrKHNjYWxlWCwgMSkgKyAnICcgKyBwaWNrKHNjYWxlWSwgMSkgKyAnKScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHJhbnNmb3JtLmxlbmd0aCkge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdHJhbnNmb3JtLmpvaW4oJyAnKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBCcmluZyB0aGUgZWxlbWVudCB0byB0aGUgZnJvbnRcblx0XHQgKi9cblx0XHR0b0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdGVsZW1lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIEJyZWFrIGRvd24gYWxpZ25tZW50IG9wdGlvbnMgbGlrZSBhbGlnbiwgdmVydGljYWxBbGlnbiwgeCBhbmQgeVxuXHRcdCAqIHRvIHggYW5kIHkgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGFsaWduT3B0aW9uc1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxpZ25CeVRyYW5zbGF0ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nW09iamVjdH0gYm94IFRoZSBib3ggdG8gYWxpZ24gdG8sIG5lZWRzIGEgd2lkdGggYW5kIGhlaWdodC4gV2hlbiB0aGVcblx0XHQgKlx0XHRib3ggaXMgYSBzdHJpbmcsIGl0IHJlZmVycyB0byBhbiBvYmplY3QgaW4gdGhlIFJlbmRlcmVyLiBGb3IgZXhhbXBsZSwgd2hlblxuXHRcdCAqXHRcdGJveCBpcyAnc3BhY2luZ0JveCcsIGl0IHJlZmVycyB0byBSZW5kZXJlci5zcGFjaW5nQm94IHdoaWNoIGhvbGRzIHdpZHRoLCBoZWlnaHRcblx0XHQgKlx0XHR4IGFuZCB5IHByb3BlcnRpZXMuXG5cdFx0ICpcblx0XHQgKi9cblx0XHRhbGlnbjogZnVuY3Rpb24gKGFsaWduT3B0aW9ucywgYWxpZ25CeVRyYW5zbGF0ZSwgYm94KSB7XG5cdFx0XHR2YXIgYWxpZ24sXG5cdFx0XHRcdHZBbGlnbixcblx0XHRcdFx0eCxcblx0XHRcdFx0eSxcblx0XHRcdFx0YXR0cmlicyA9IHt9LFxuXHRcdFx0XHRhbGlnblRvLFxuXHRcdFx0XHRyZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRcdGFsaWduZWRPYmplY3RzID0gcmVuZGVyZXIuYWxpZ25lZE9iamVjdHM7XG5cblx0XHRcdC8vIEZpcnN0IGNhbGwgb24gaW5zdGFuY2lhdGVcblx0XHRcdGlmIChhbGlnbk9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5hbGlnbk9wdGlvbnMgPSBhbGlnbk9wdGlvbnM7XG5cdFx0XHRcdHRoaXMuYWxpZ25CeVRyYW5zbGF0ZSA9IGFsaWduQnlUcmFuc2xhdGU7XG5cdFx0XHRcdGlmICghYm94IHx8IGlzU3RyaW5nKGJveCkpIHsgLy8gYm94ZXMgb3RoZXIgdGhhbiByZW5kZXJlciBoYW5kbGUgdGhpcyBpbnRlcm5hbGx5XG5cdFx0XHRcdFx0dGhpcy5hbGlnblRvID0gYWxpZ25UbyA9IGJveCB8fCAncmVuZGVyZXInO1xuXHRcdFx0XHRcdGVyYXNlKGFsaWduZWRPYmplY3RzLCB0aGlzKTsgLy8gcHJldmVudCBkdXBsaWNhdGVzLCBsaWtlIGxlZ2VuZEdyb3VwIGFmdGVyIHJlc2l6ZVxuXHRcdFx0XHRcdGFsaWduZWRPYmplY3RzLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0Ym94ID0gbnVsbDsgLy8gcmVhc3NpZ24gaXQgYmVsb3dcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBXaGVuIGNhbGxlZCBvbiByZXNpemUsIG5vIGFyZ3VtZW50cyBhcmUgc3VwcGxpZWRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFsaWduT3B0aW9ucyA9IHRoaXMuYWxpZ25PcHRpb25zO1xuXHRcdFx0XHRhbGlnbkJ5VHJhbnNsYXRlID0gdGhpcy5hbGlnbkJ5VHJhbnNsYXRlO1xuXHRcdFx0XHRhbGlnblRvID0gdGhpcy5hbGlnblRvO1xuXHRcdFx0fVxuXG5cdFx0XHRib3ggPSBwaWNrKGJveCwgcmVuZGVyZXJbYWxpZ25Ub10sIHJlbmRlcmVyKTtcblxuXHRcdFx0Ly8gQXNzaWduIHZhcmlhYmxlc1xuXHRcdFx0YWxpZ24gPSBhbGlnbk9wdGlvbnMuYWxpZ247XG5cdFx0XHR2QWxpZ24gPSBhbGlnbk9wdGlvbnMudmVydGljYWxBbGlnbjtcblx0XHRcdHggPSAoYm94LnggfHwgMCkgKyAoYWxpZ25PcHRpb25zLnggfHwgMCk7IC8vIGRlZmF1bHQ6IGxlZnQgYWxpZ25cblx0XHRcdHkgPSAoYm94LnkgfHwgMCkgKyAoYWxpZ25PcHRpb25zLnkgfHwgMCk7IC8vIGRlZmF1bHQ6IHRvcCBhbGlnblxuXG5cdFx0XHQvLyBBbGlnblxuXHRcdFx0aWYgKGFsaWduID09PSAncmlnaHQnIHx8IGFsaWduID09PSAnY2VudGVyJykge1xuXHRcdFx0XHR4ICs9IChib3gud2lkdGggLSAoYWxpZ25PcHRpb25zLndpZHRoIHx8IDApKSAvXG5cdFx0XHRcdFx0XHR7IHJpZ2h0OiAxLCBjZW50ZXI6IDIgfVthbGlnbl07XG5cdFx0XHR9XG5cdFx0XHRhdHRyaWJzW2FsaWduQnlUcmFuc2xhdGUgPyAndHJhbnNsYXRlWCcgOiAneCddID0gbWF0aFJvdW5kKHgpO1xuXG5cblx0XHRcdC8vIFZlcnRpY2FsIGFsaWduXG5cdFx0XHRpZiAodkFsaWduID09PSAnYm90dG9tJyB8fCB2QWxpZ24gPT09ICdtaWRkbGUnKSB7XG5cdFx0XHRcdHkgKz0gKGJveC5oZWlnaHQgLSAoYWxpZ25PcHRpb25zLmhlaWdodCB8fCAwKSkgL1xuXHRcdFx0XHRcdFx0KHsgYm90dG9tOiAxLCBtaWRkbGU6IDIgfVt2QWxpZ25dIHx8IDEpO1xuXG5cdFx0XHR9XG5cdFx0XHRhdHRyaWJzW2FsaWduQnlUcmFuc2xhdGUgPyAndHJhbnNsYXRlWScgOiAneSddID0gbWF0aFJvdW5kKHkpO1xuXG5cdFx0XHQvLyBBbmltYXRlIG9ubHkgaWYgYWxyZWFkeSBwbGFjZWRcblx0XHRcdHRoaXNbdGhpcy5wbGFjZWQgPyAnYW5pbWF0ZScgOiAnYXR0ciddKGF0dHJpYnMpO1xuXHRcdFx0dGhpcy5wbGFjZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5hbGlnbkF0dHIgPSBhdHRyaWJzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBib3VuZGluZyBib3ggKHdpZHRoLCBoZWlnaHQsIHggYW5kIHkpIGZvciB0aGUgZWxlbWVudFxuXHRcdCAqL1xuXHRcdGdldEJCb3g6IGZ1bmN0aW9uIChyZWxvYWQpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0YkJveCwvLyA9IHdyYXBwZXIuYkJveCxcblx0XHRcdFx0cmVuZGVyZXIgPSB3cmFwcGVyLnJlbmRlcmVyLFxuXHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0aGVpZ2h0LFxuXHRcdFx0XHRyb3RhdGlvbiA9IHdyYXBwZXIucm90YXRpb24sXG5cdFx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdHN0eWxlcyA9IHdyYXBwZXIuc3R5bGVzLFxuXHRcdFx0XHRyYWQgPSByb3RhdGlvbiAqIGRlZzJyYWQsXG5cdFx0XHRcdHRleHRTdHIgPSB3cmFwcGVyLnRleHRTdHIsXG5cdFx0XHRcdHRleHRTaGFkb3csXG5cdFx0XHRcdGVsZW1TdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG5cdFx0XHRcdHRvZ2dsZVRleHRTaGFkb3dTaGltLFxuXHRcdFx0XHRjYWNoZUtleTtcblxuXHRcdFx0aWYgKHRleHRTdHIgIT09IFVOREVGSU5FRCkge1xuXG5cdFx0XHRcdC8vIFByb3BlcnRpZXMgdGhhdCBhZmZlY3QgYm91bmRpbmcgYm94XG5cdFx0XHRcdGNhY2hlS2V5ID0gWycnLCByb3RhdGlvbiB8fCAwLCBzdHlsZXMgJiYgc3R5bGVzLmZvbnRTaXplLCBlbGVtZW50LnN0eWxlLndpZHRoXS5qb2luKCcsJyk7XG5cblx0XHRcdFx0Ly8gU2luY2UgbnVtYmVycyBhcmUgbW9ub3NwYWNlZCwgYW5kIG51bWVyaWNhbCBsYWJlbHMgYXBwZWFyIGEgbG90IGluIGEgY2hhcnQsXG5cdFx0XHRcdC8vIHdlIGFzc3VtZSB0aGF0IGEgbGFiZWwgb2YgbiBjaGFyYWN0ZXJzIGhhcyB0aGUgc2FtZSBib3VuZGluZyBib3ggYXMgb3RoZXJzIFxuXHRcdFx0XHQvLyBvZiB0aGUgc2FtZSBsZW5ndGguXG5cdFx0XHRcdGlmICh0ZXh0U3RyID09PSAnJyB8fCBudW1SZWdleC50ZXN0KHRleHRTdHIpKSB7XG5cdFx0XHRcdFx0Y2FjaGVLZXkgPSAnbnVtOicgKyB0ZXh0U3RyLnRvU3RyaW5nKCkubGVuZ3RoICsgY2FjaGVLZXk7XG5cblx0XHRcdFx0Ly8gQ2FjaGluZyBhbGwgc3RyaW5ncyByZWR1Y2VzIHJlbmRlcmluZyB0aW1lIGJ5IDQtNSUuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FjaGVLZXkgPSB0ZXh0U3RyICsgY2FjaGVLZXk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGNhY2hlS2V5ICYmICFyZWxvYWQpIHtcblx0XHRcdFx0YkJveCA9IHJlbmRlcmVyLmNhY2hlW2NhY2hlS2V5XTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gY2FjaGUgZm91bmRcblx0XHRcdGlmICghYkJveCkge1xuXG5cdFx0XHRcdC8vIFNWRyBlbGVtZW50c1xuXHRcdFx0XHRpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OUyB8fCByZW5kZXJlci5mb3JFeHBvcnQpIHtcblx0XHRcdFx0XHR0cnkgeyAvLyBGYWlscyBpbiBGaXJlZm94IGlmIHRoZSBjb250YWluZXIgaGFzIGRpc3BsYXk6IG5vbmUuXG5cblx0XHRcdFx0XHRcdC8vIFdoZW4gdGhlIHRleHQgc2hhZG93IHNoaW0gaXMgdXNlZCwgd2UgbmVlZCB0byBoaWRlIHRoZSBmYWtlIHNoYWRvd3Ncblx0XHRcdFx0XHRcdC8vIHRvIGdldCB0aGUgY29ycmVjdCBib3VuZGluZyBib3ggKCMzODcyKVxuXHRcdFx0XHRcdFx0dG9nZ2xlVGV4dFNoYWRvd1NoaW0gPSB0aGlzLmZha2VUUyAmJiBmdW5jdGlvbiAoZGlzcGxheSkge1xuXHRcdFx0XHRcdFx0XHRlYWNoKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBQUkVGSVggKyAndGV4dC1zaGFkb3cnKSwgZnVuY3Rpb24gKHRzcGFuKSB7XG5cdFx0XHRcdFx0XHRcdFx0dHNwYW4uc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Ly8gV29ya2Fyb3VuZCBmb3IgIzM4NDIsIEZpcmVmb3ggcmVwb3J0aW5nIHdyb25nIGJvdW5kaW5nIGJveCBmb3Igc2hhZG93c1xuXHRcdFx0XHRcdFx0aWYgKGlzRmlyZWZveCAmJiBlbGVtU3R5bGUudGV4dFNoYWRvdykge1xuXHRcdFx0XHRcdFx0XHR0ZXh0U2hhZG93ID0gZWxlbVN0eWxlLnRleHRTaGFkb3c7XG5cdFx0XHRcdFx0XHRcdGVsZW1TdHlsZS50ZXh0U2hhZG93ID0gJyc7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRvZ2dsZVRleHRTaGFkb3dTaGltKSB7XG5cdFx0XHRcdFx0XHRcdHRvZ2dsZVRleHRTaGFkb3dTaGltKE5PTkUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRiQm94ID0gZWxlbWVudC5nZXRCQm94ID9cblx0XHRcdFx0XHRcdFx0Ly8gU1ZHOiB1c2UgZXh0ZW5kIGJlY2F1c2UgSUU5IGlzIG5vdCBhbGxvd2VkIHRvIGNoYW5nZSB3aWR0aCBhbmQgaGVpZ2h0IGluIGNhc2Vcblx0XHRcdFx0XHRcdFx0Ly8gb2Ygcm90YXRpb24gKGJlbG93KVxuXHRcdFx0XHRcdFx0XHRleHRlbmQoe30sIGVsZW1lbnQuZ2V0QkJveCgpKSA6XG5cdFx0XHRcdFx0XHRcdC8vIENhbnZhcyByZW5kZXJlciBhbmQgbGVnYWN5IElFIGluIGV4cG9ydCBtb2RlXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vICMzODQyXG5cdFx0XHRcdFx0XHRpZiAodGV4dFNoYWRvdykge1xuXHRcdFx0XHRcdFx0XHRlbGVtU3R5bGUudGV4dFNoYWRvdyA9IHRleHRTaGFkb3c7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRvZ2dsZVRleHRTaGFkb3dTaGltKSB7XG5cdFx0XHRcdFx0XHRcdHRvZ2dsZVRleHRTaGFkb3dTaGltKCcnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7fVxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGJCb3ggaXMgbm90IHNldCwgdGhlIHRyeS1jYXRjaCBibG9jayBhYm92ZSBmYWlsZWQuIFRoZSBvdGhlciBjb25kaXRpb25cblx0XHRcdFx0XHQvLyBpcyBmb3IgT3BlcmEgdGhhdCByZXR1cm5zIGEgd2lkdGggb2YgLUluZmluaXR5IG9uIGhpZGRlbiBlbGVtZW50cy5cblx0XHRcdFx0XHRpZiAoIWJCb3ggfHwgYkJveC53aWR0aCA8IDApIHtcblx0XHRcdFx0XHRcdGJCb3ggPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyBWTUwgUmVuZGVyZXIgb3IgdXNlSFRNTCB3aXRoaW4gU1ZHXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRiQm94ID0gd3JhcHBlci5odG1sR2V0QkJveCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcnVlIFNWRyBlbGVtZW50cyBhcyB3ZWxsIGFzIEhUTUwgZWxlbWVudHMgaW4gbW9kZXJuIGJyb3dzZXJzIHVzaW5nIHRoZSAudXNlSFRNTCBvcHRpb25cblx0XHRcdFx0Ly8gbmVlZCB0byBjb21wZW5zYXRlZCBmb3Igcm90YXRpb25cblx0XHRcdFx0aWYgKHJlbmRlcmVyLmlzU1ZHKSB7XG5cdFx0XHRcdFx0d2lkdGggPSBiQm94LndpZHRoO1xuXHRcdFx0XHRcdGhlaWdodCA9IGJCb3guaGVpZ2h0O1xuXG5cdFx0XHRcdFx0Ly8gV29ya2Fyb3VuZCBmb3Igd3JvbmcgYm91bmRpbmcgYm94IGluIElFOSBhbmQgSUUxMCAoIzExMDEsICMxNTA1LCAjMTY2OSwgIzI1NjgpXG5cdFx0XHRcdFx0aWYgKGlzSUUgJiYgc3R5bGVzICYmIHN0eWxlcy5mb250U2l6ZSA9PT0gJzExcHgnICYmIGhlaWdodC50b1ByZWNpc2lvbigzKSA9PT0gJzE2LjknKSB7XG5cdFx0XHRcdFx0XHRiQm94LmhlaWdodCA9IGhlaWdodCA9IDE0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFkanVzdCBmb3Igcm90YXRlZCB0ZXh0XG5cdFx0XHRcdFx0aWYgKHJvdGF0aW9uKSB7XG5cdFx0XHRcdFx0XHRiQm94LndpZHRoID0gbWF0aEFicyhoZWlnaHQgKiBtYXRoU2luKHJhZCkpICsgbWF0aEFicyh3aWR0aCAqIG1hdGhDb3MocmFkKSk7XG5cdFx0XHRcdFx0XHRiQm94LmhlaWdodCA9IG1hdGhBYnMoaGVpZ2h0ICogbWF0aENvcyhyYWQpKSArIG1hdGhBYnMod2lkdGggKiBtYXRoU2luKHJhZCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhY2hlIGl0XG5cdFx0XHRcdHJlbmRlcmVyLmNhY2hlW2NhY2hlS2V5XSA9IGJCb3g7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYkJveDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2hvdyB0aGUgZWxlbWVudFxuXHRcdCAqL1xuXHRcdHNob3c6IGZ1bmN0aW9uIChpbmhlcml0KSB7XG5cdFx0XHQvLyBJRTktMTEgZG9lc24ndCBoYW5kbGUgdmlzaWJpbHR5OmluaGVyaXQgd2VsbCwgc28gd2UgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgaW5zdGVhZCAoIzI4ODEpXG5cdFx0XHRpZiAoaW5oZXJpdCAmJiB0aGlzLmVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTlMpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndmlzaWJpbGl0eScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hdHRyKHsgdmlzaWJpbGl0eTogaW5oZXJpdCA/ICdpbmhlcml0JyA6IFZJU0lCTEUgfSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlkZSB0aGUgZWxlbWVudFxuXHRcdCAqL1xuXHRcdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoeyB2aXNpYmlsaXR5OiBISURERU4gfSk7XG5cdFx0fSxcblxuXHRcdGZhZGVPdXQ6IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuXHRcdFx0dmFyIGVsZW1XcmFwcGVyID0gdGhpcztcblx0XHRcdGVsZW1XcmFwcGVyLmFuaW1hdGUoe1xuXHRcdFx0XHRvcGFjaXR5OiAwXG5cdFx0XHR9LCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbiB8fCAxNTAsXG5cdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0ZWxlbVdyYXBwZXIuYXR0cih7IHk6IC05OTk5IH0pOyAvLyAjMzA4OCwgYXNzdW1pbmcgd2UncmUgb25seSB1c2luZyB0aGlzIGZvciB0b29sdGlwc1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIHRoZSBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R8VW5kZWZpbmVkfSBwYXJlbnQgQ2FuIGJlIGFuIGVsZW1lbnQsIGFuIGVsZW1lbnQgd3JhcHBlciBvciB1bmRlZmluZWRcblx0XHQgKlx0dG8gYXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSByZW5kZXJlci5ib3guXG5cdFx0ICovXG5cdFx0YWRkOiBmdW5jdGlvbiAocGFyZW50KSB7XG5cblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdGluc2VydGVkO1xuXG5cdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdHRoaXMucGFyZW50R3JvdXAgPSBwYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1hcmsgYXMgaW52ZXJ0ZWRcblx0XHRcdHRoaXMucGFyZW50SW52ZXJ0ZWQgPSBwYXJlbnQgJiYgcGFyZW50LmludmVydGVkO1xuXG5cdFx0XHQvLyBidWlsZCBmb3JtYXR0ZWQgdGV4dFxuXHRcdFx0aWYgKHRoaXMudGV4dFN0ciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFyayBhcyBhZGRlZFxuXHRcdFx0dGhpcy5hZGRlZCA9IHRydWU7XG5cblx0XHRcdC8vIElmIHdlJ3JlIGFkZGluZyB0byByZW5kZXJlciByb290LCBvciBvdGhlciBlbGVtZW50cyBpbiB0aGUgZ3JvdXAgXG5cdFx0XHQvLyBoYXZlIGEgeiBpbmRleCwgd2UgbmVlZCB0byBoYW5kbGUgaXRcblx0XHRcdGlmICghcGFyZW50IHx8IHBhcmVudC5oYW5kbGVaIHx8IHRoaXMuekluZGV4KSB7XG5cdFx0XHRcdGluc2VydGVkID0gdGhpcy56SW5kZXhTZXR0ZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgekluZGV4IGlzIG5vdCBoYW5kbGVkLCBhcHBlbmQgYXQgdGhlIGVuZFxuXHRcdFx0aWYgKCFpbnNlcnRlZCkge1xuXHRcdFx0XHQocGFyZW50ID8gcGFyZW50LmVsZW1lbnQgOiByZW5kZXJlci5ib3gpLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmaXJlIGFuIGV2ZW50IGZvciBpbnRlcm5hbCBob29rc1xuXHRcdFx0aWYgKHRoaXMub25BZGQpIHtcblx0XHRcdFx0dGhpcy5vbkFkZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhIGNoaWxkIGVpdGhlciBieSByZW1vdmVDaGlsZCBvciBtb3ZlIHRvIGdhcmJhZ2VCaW4uXG5cdFx0ICogSXNzdWUgNDkwOyBpbiBWTUwgcmVtb3ZlQ2hpbGQgcmVzdWx0cyBpbiBPcnBoYW5lZCBub2RlcyBhY2NvcmRpbmcgdG8gc0lFdmUsIGRpc2NhcmRFbGVtZW50IGRvZXMgbm90LlxuXHRcdCAqL1xuXHRcdHNhZmVSZW1vdmVDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdHZhciBwYXJlbnROb2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKHBhcmVudE5vZGUpIHtcblx0XHRcdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSB0aGUgZWxlbWVudCBhbmQgZWxlbWVudCB3cmFwcGVyXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50IHx8IHt9LFxuXHRcdFx0XHRzaGFkb3dzID0gd3JhcHBlci5zaGFkb3dzLFxuXHRcdFx0XHRwYXJlbnRUb0NsZWFuID0gd3JhcHBlci5yZW5kZXJlci5pc1NWRyAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSAnU1BBTicgJiYgd3JhcHBlci5wYXJlbnRHcm91cCxcblx0XHRcdFx0Z3JhbmRQYXJlbnQsXG5cdFx0XHRcdGtleSxcblx0XHRcdFx0aTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGV2ZW50c1xuXHRcdFx0ZWxlbWVudC5vbmNsaWNrID0gZWxlbWVudC5vbm1vdXNlb3V0ID0gZWxlbWVudC5vbm1vdXNlb3ZlciA9IGVsZW1lbnQub25tb3VzZW1vdmUgPSBlbGVtZW50LnBvaW50ID0gbnVsbDtcblx0XHRcdHN0b3Aod3JhcHBlcik7IC8vIHN0b3AgcnVubmluZyBhbmltYXRpb25zXG5cblx0XHRcdGlmICh3cmFwcGVyLmNsaXBQYXRoKSB7XG5cdFx0XHRcdHdyYXBwZXIuY2xpcFBhdGggPSB3cmFwcGVyLmNsaXBQYXRoLmRlc3Ryb3koKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVzdHJveSBzdG9wcyBpbiBjYXNlIHRoaXMgaXMgYSBncmFkaWVudCBvYmplY3Rcblx0XHRcdGlmICh3cmFwcGVyLnN0b3BzKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB3cmFwcGVyLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5zdG9wc1tpXSA9IHdyYXBwZXIuc3RvcHNbaV0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdyYXBwZXIuc3RvcHMgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgZWxlbWVudFxuXHRcdFx0d3JhcHBlci5zYWZlUmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cblx0XHRcdC8vIGRlc3Ryb3kgc2hhZG93c1xuXHRcdFx0aWYgKHNoYWRvd3MpIHtcblx0XHRcdFx0ZWFjaChzaGFkb3dzLCBmdW5jdGlvbiAoc2hhZG93KSB7XG5cdFx0XHRcdFx0d3JhcHBlci5zYWZlUmVtb3ZlQ2hpbGQoc2hhZG93KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluIGNhc2Ugb2YgdXNlSFRNTCwgY2xlYW4gdXAgZW1wdHkgY29udGFpbmVycyBlbXVsYXRpbmcgU1ZHIGdyb3VwcyAoIzE5NjAsICMyMzkzLCAjMjY5NykuXG5cdFx0XHR3aGlsZSAocGFyZW50VG9DbGVhbiAmJiBwYXJlbnRUb0NsZWFuLmRpdiAmJiBwYXJlbnRUb0NsZWFuLmRpdi5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRncmFuZFBhcmVudCA9IHBhcmVudFRvQ2xlYW4ucGFyZW50R3JvdXA7XG5cdFx0XHRcdHdyYXBwZXIuc2FmZVJlbW92ZUNoaWxkKHBhcmVudFRvQ2xlYW4uZGl2KTtcblx0XHRcdFx0ZGVsZXRlIHBhcmVudFRvQ2xlYW4uZGl2O1xuXHRcdFx0XHRwYXJlbnRUb0NsZWFuID0gZ3JhbmRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBmcm9tIGFsaWduT2JqZWN0c1xuXHRcdFx0aWYgKHdyYXBwZXIuYWxpZ25Ubykge1xuXHRcdFx0XHRlcmFzZSh3cmFwcGVyLnJlbmRlcmVyLmFsaWduZWRPYmplY3RzLCB3cmFwcGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChrZXkgaW4gd3JhcHBlcikge1xuXHRcdFx0XHRkZWxldGUgd3JhcHBlcltrZXldO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgc2hhZG93IHRvIHRoZSBlbGVtZW50LiBNdXN0IGJlIGRvbmUgYWZ0ZXIgdGhlIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IHNoYWRvd09wdGlvbnNcblx0XHQgKi9cblx0XHRzaGFkb3c6IGZ1bmN0aW9uIChzaGFkb3dPcHRpb25zLCBncm91cCwgY3V0T2ZmKSB7XG5cdFx0XHR2YXIgc2hhZG93cyA9IFtdLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRzaGFkb3csXG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdHN0cm9rZVdpZHRoLFxuXHRcdFx0XHRzaGFkb3dXaWR0aCxcblx0XHRcdFx0c2hhZG93RWxlbWVudE9wYWNpdHksXG5cblx0XHRcdFx0Ly8gY29tcGVuc2F0ZSBmb3IgaW52ZXJ0ZWQgcGxvdCBhcmVhXG5cdFx0XHRcdHRyYW5zZm9ybTtcblxuXG5cdFx0XHRpZiAoc2hhZG93T3B0aW9ucykge1xuXHRcdFx0XHRzaGFkb3dXaWR0aCA9IHBpY2soc2hhZG93T3B0aW9ucy53aWR0aCwgMyk7XG5cdFx0XHRcdHNoYWRvd0VsZW1lbnRPcGFjaXR5ID0gKHNoYWRvd09wdGlvbnMub3BhY2l0eSB8fCAwLjE1KSAvIHNoYWRvd1dpZHRoO1xuXHRcdFx0XHR0cmFuc2Zvcm0gPSB0aGlzLnBhcmVudEludmVydGVkID9cblx0XHRcdFx0XHQnKC0xLC0xKScgOlxuXHRcdFx0XHRcdCcoJyArIHBpY2soc2hhZG93T3B0aW9ucy5vZmZzZXRYLCAxKSArICcsICcgKyBwaWNrKHNoYWRvd09wdGlvbnMub2Zmc2V0WSwgMSkgKyAnKSc7XG5cdFx0XHRcdGZvciAoaSA9IDE7IGkgPD0gc2hhZG93V2lkdGg7IGkrKykge1xuXHRcdFx0XHRcdHNoYWRvdyA9IGVsZW1lbnQuY2xvbmVOb2RlKDApO1xuXHRcdFx0XHRcdHN0cm9rZVdpZHRoID0gKHNoYWRvd1dpZHRoICogMikgKyAxIC0gKDIgKiBpKTtcblx0XHRcdFx0XHRhdHRyKHNoYWRvdywge1xuXHRcdFx0XHRcdFx0J2lzU2hhZG93JzogJ3RydWUnLFxuXHRcdFx0XHRcdFx0J3N0cm9rZSc6IHNoYWRvd09wdGlvbnMuY29sb3IgfHwgJ2JsYWNrJyxcblx0XHRcdFx0XHRcdCdzdHJva2Utb3BhY2l0eSc6IHNoYWRvd0VsZW1lbnRPcGFjaXR5ICogaSxcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aCxcblx0XHRcdFx0XHRcdCd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlJyArIHRyYW5zZm9ybSxcblx0XHRcdFx0XHRcdCdmaWxsJzogTk9ORVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmIChjdXRPZmYpIHtcblx0XHRcdFx0XHRcdGF0dHIoc2hhZG93LCAnaGVpZ2h0JywgbWF0aE1heChhdHRyKHNoYWRvdywgJ2hlaWdodCcpIC0gc3Ryb2tlV2lkdGgsIDApKTtcblx0XHRcdFx0XHRcdHNoYWRvdy5jdXRIZWlnaHQgPSBzdHJva2VXaWR0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0XHRcdGdyb3VwLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhZG93KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzaGFkb3csIGVsZW1lbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNoYWRvd3MucHVzaChzaGFkb3cpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5zaGFkb3dzID0gc2hhZG93cztcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHhHZXR0ZXI6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICh0aGlzLmVsZW1lbnQubm9kZU5hbWUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdGtleSA9IHsgeDogJ2N4JywgeTogJ2N5JyB9W2tleV0gfHwga2V5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2RlZmF1bHRHZXR0ZXIoa2V5KTtcblx0XHR9LFxuXG5cdFx0LyoqIFxuXHRcdCAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb3IgcHNldWRvIGF0dHJpYnV0ZSwgdXNlZCBtYWlubHlcblx0XHQgKiBmb3IgYW5pbWF0aW9uLlxuXHRcdCAqL1xuXHRcdF9kZWZhdWx0R2V0dGVyOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR2YXIgcmV0ID0gcGljayh0aGlzW2tleV0sIHRoaXMuZWxlbWVudCA/IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoa2V5KSA6IG51bGwsIDApO1xuXG5cdFx0XHRpZiAoL15bXFwtMC05XFwuXSskLy50ZXN0KHJldCkpIHsgLy8gaXMgbnVtZXJpY2FsXG5cdFx0XHRcdHJldCA9IHBhcnNlRmxvYXQocmV0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXG5cdFx0ZFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5qb2luKSB7IC8vIGpvaW4gcGF0aFxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmpvaW4oJyAnKTtcblx0XHRcdH1cblx0XHRcdGlmICgvKE5hTnwgezJ9fF4kKS8udGVzdCh2YWx1ZSkpIHtcblx0XHRcdFx0dmFsdWUgPSAnTSAwIDAnO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cblx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdH0sXG5cdFx0ZGFzaHN0eWxlU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0dmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVcblx0XHRcdFx0XHQucmVwbGFjZSgnc2hvcnRkYXNoZG90ZG90JywgJzMsMSwxLDEsMSwxLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoJ3Nob3J0ZGFzaGRvdCcsICczLDEsMSwxJylcblx0XHRcdFx0XHQucmVwbGFjZSgnc2hvcnRkb3QnLCAnMSwxLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoJ3Nob3J0ZGFzaCcsICczLDEsJylcblx0XHRcdFx0XHQucmVwbGFjZSgnbG9uZ2Rhc2gnLCAnOCwzLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL2RvdC9nLCAnMSwzLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoJ2Rhc2gnLCAnNCwzLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLywkLywgJycpXG5cdFx0XHRcdFx0LnNwbGl0KCcsJyk7IC8vIGVuZGluZyBjb21tYVxuXG5cdFx0XHRcdGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHR2YWx1ZVtpXSA9IHBJbnQodmFsdWVbaV0pICogdGhpc1snc3Ryb2tlLXdpZHRoJ107XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5qb2luKCcsJylcblx0XHRcdFx0XHQucmVwbGFjZSgnTmFOJywgJ25vbmUnKTsgLy8gIzMyMjZcblx0XHRcdFx0dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFsaWduU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgeyBsZWZ0OiAnc3RhcnQnLCBjZW50ZXI6ICdtaWRkbGUnLCByaWdodDogJ2VuZCcgfVt2YWx1ZV0pO1xuXHRcdH0sXG5cdFx0b3BhY2l0eVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0fSxcblx0XHR0aXRsZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGl0bGVOb2RlID0gdGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aXRsZScpWzBdO1xuXHRcdFx0aWYgKCF0aXRsZU5vZGUpIHtcblx0XHRcdFx0dGl0bGVOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICd0aXRsZScpO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGl0bGVOb2RlKTtcblx0XHRcdH1cblx0XHRcdHRpdGxlTm9kZS50ZXh0Q29udGVudCA9IChTdHJpbmcocGljayh2YWx1ZSksICcnKSkucmVwbGFjZSgvPFtePl0qPi9nLCAnJyk7IC8vICMzMjc2ICMzODk1XG5cdFx0fSxcblx0XHR0ZXh0U2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdGhpcy50ZXh0U3RyKSB7XG5cdFx0XHRcdC8vIERlbGV0ZSBiQm94IG1lbW8gd2hlbiB0aGUgdGV4dCBjaGFuZ2VzXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmJCb3g7XG5cdFx0XHRcblx0XHRcdFx0dGhpcy50ZXh0U3RyID0gdmFsdWU7XG5cdFx0XHRcdGlmICh0aGlzLmFkZGVkKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJlci5idWlsZFRleHQodGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGZpbGxTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUpIHtcblx0XHRcdFx0dGhpcy5jb2xvckdyYWRpZW50KHZhbHVlLCBrZXksIGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ekluZGV4U2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcblx0XHRcdFx0cGFyZW50R3JvdXAgPSB0aGlzLnBhcmVudEdyb3VwLFxuXHRcdFx0XHRwYXJlbnRXcmFwcGVyID0gcGFyZW50R3JvdXAgfHwgcmVuZGVyZXIsXG5cdFx0XHRcdHBhcmVudE5vZGUgPSBwYXJlbnRXcmFwcGVyLmVsZW1lbnQgfHwgcmVuZGVyZXIuYm94LFxuXHRcdFx0XHRjaGlsZE5vZGVzLFxuXHRcdFx0XHRvdGhlckVsZW1lbnQsXG5cdFx0XHRcdG90aGVyWkluZGV4LFxuXHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0XHRpbnNlcnRlZCxcblx0XHRcdFx0cnVuID0gdGhpcy5hZGRlZCxcblx0XHRcdFx0aTtcblx0XHRcdFxuXHRcdFx0aWYgKGRlZmluZWQodmFsdWUpKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpOyAvLyBTbyB3ZSBjYW4gcmVhZCBpdCBmb3Igb3RoZXIgZWxlbWVudHMgaW4gdGhlIGdyb3VwXG5cdFx0XHRcdHZhbHVlID0gK3ZhbHVlO1xuXHRcdFx0XHRpZiAodGhpc1trZXldID09PSB2YWx1ZSkgeyAvLyBPbmx5IHVwZGF0ZSB3aGVuIG5lZWRlZCAoIzM4NjUpXG5cdFx0XHRcdFx0cnVuID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluc2VydCBhY2NvcmRpbmcgdG8gdGhpcyBhbmQgb3RoZXIgZWxlbWVudHMnIHpJbmRleC4gQmVmb3JlIC5hZGQoKSBpcyBjYWxsZWQsXG5cdFx0XHQvLyBub3RoaW5nIGlzIGRvbmUuIFRoZW4gb24gYWRkLCBvciBieSBsYXRlciBjYWxscyB0byB6SW5kZXhTZXR0ZXIsIHRoZSBub2RlXG5cdFx0XHQvLyBpcyBwbGFjZWQgb24gdGhlIHJpZ2h0IHBsYWNlIGluIHRoZSBET00uXG5cdFx0XHRpZiAocnVuKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy56SW5kZXg7XG5cblx0XHRcdFx0aWYgKHZhbHVlICYmIHBhcmVudEdyb3VwKSB7XG5cdFx0XHRcdFx0cGFyZW50R3JvdXAuaGFuZGxlWiA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHRjaGlsZE5vZGVzID0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGggJiYgIWluc2VydGVkOyBpKyspIHtcblx0XHRcdFx0XHRvdGhlckVsZW1lbnQgPSBjaGlsZE5vZGVzW2ldO1xuXHRcdFx0XHRcdG90aGVyWkluZGV4ID0gYXR0cihvdGhlckVsZW1lbnQsICd6SW5kZXgnKTtcblx0XHRcdFx0XHRpZiAob3RoZXJFbGVtZW50ICE9PSBlbGVtZW50ICYmIChcblx0XHRcdFx0XHRcdFx0Ly8gSW5zZXJ0IGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIGEgaGlnaGVyIHpJbmRleFxuXHRcdFx0XHRcdFx0XHRwSW50KG90aGVyWkluZGV4KSA+IHZhbHVlIHx8XG5cdFx0XHRcdFx0XHRcdC8vIElmIG5vIHpJbmRleCBnaXZlbiwgaW5zZXJ0IGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIGEgekluZGV4XG5cdFx0XHRcdFx0XHRcdCghZGVmaW5lZCh2YWx1ZSkgJiYgZGVmaW5lZChvdGhlclpJbmRleCkpXG5cblx0XHRcdFx0XHRcdFx0KSkge1xuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgb3RoZXJFbGVtZW50KTtcblx0XHRcdFx0XHRcdGluc2VydGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpbnNlcnRlZCkge1xuXHRcdFx0XHRcdHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBpbnNlcnRlZDtcblx0XHR9LFxuXHRcdF9kZWZhdWx0U2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFNvbWUgc2hhcmVkIHNldHRlcnMgYW5kIGdldHRlcnNcblx0U1ZHRWxlbWVudC5wcm90b3R5cGUueUdldHRlciA9IFNWR0VsZW1lbnQucHJvdG90eXBlLnhHZXR0ZXI7XG5cdFNWR0VsZW1lbnQucHJvdG90eXBlLnRyYW5zbGF0ZVhTZXR0ZXIgPSBTVkdFbGVtZW50LnByb3RvdHlwZS50cmFuc2xhdGVZU2V0dGVyID0gXG5cdFx0XHRTVkdFbGVtZW50LnByb3RvdHlwZS5yb3RhdGlvblNldHRlciA9IFNWR0VsZW1lbnQucHJvdG90eXBlLnZlcnRpY2FsQWxpZ25TZXR0ZXIgPSBcblx0XHRcdFNWR0VsZW1lbnQucHJvdG90eXBlLnNjYWxlWFNldHRlciA9IFNWR0VsZW1lbnQucHJvdG90eXBlLnNjYWxlWVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0dGhpcy5kb1RyYW5zZm9ybSA9IHRydWU7XG5cdH07XG5cblx0Ly8gV2ViS2l0IGFuZCBCYXRpayBoYXZlIHByb2JsZW1zIHdpdGggYSBzdHJva2Utd2lkdGggb2YgemVybywgc28gaW4gdGhpcyBjYXNlIHdlIHJlbW92ZSB0aGUgXG5cdC8vIHN0cm9rZSBhdHRyaWJ1dGUgYWx0b2dldGhlci4gIzEyNzAsICMxMzY5LCAjMzA2NSwgIzMwNzIuXG5cdFNWR0VsZW1lbnQucHJvdG90eXBlWydzdHJva2Utd2lkdGhTZXR0ZXInXSA9IFNWR0VsZW1lbnQucHJvdG90eXBlLnN0cm9rZVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0Ly8gT25seSBhcHBseSB0aGUgc3Ryb2tlIGF0dHJpYnV0ZSBpZiB0aGUgc3Ryb2tlIHdpZHRoIGlzIGRlZmluZWQgYW5kIGxhcmdlciB0aGFuIDBcblx0XHRpZiAodGhpcy5zdHJva2UgJiYgdGhpc1snc3Ryb2tlLXdpZHRoJ10pIHtcblx0XHRcdHRoaXMuc3Ryb2tlV2lkdGggPSB0aGlzWydzdHJva2Utd2lkdGgnXTtcblx0XHRcdFNWR0VsZW1lbnQucHJvdG90eXBlLmZpbGxTZXR0ZXIuY2FsbCh0aGlzLCB0aGlzLnN0cm9rZSwgJ3N0cm9rZScsIGVsZW1lbnQpOyAvLyB1c2UgcHJvdG90eXBlIGFzIGluc3RhbmNlIG1heSBiZSBvdmVycmlkZGVuXG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgdGhpc1snc3Ryb2tlLXdpZHRoJ10pO1xuXHRcdFx0dGhpcy5oYXNTdHJva2UgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc3Ryb2tlLXdpZHRoJyAmJiB2YWx1ZSA9PT0gMCAmJiB0aGlzLmhhc1N0cm9rZSkge1xuXHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZScpO1xuXHRcdFx0dGhpcy5oYXNTdHJva2UgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgU1ZHIHJlbmRlcmVyXG5cdCAqL1xuXHR2YXIgU1ZHUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cdFNWR1JlbmRlcmVyLnByb3RvdHlwZSA9IHtcblx0XHRFbGVtZW50OiBTVkdFbGVtZW50LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSB0aGUgU1ZHUmVuZGVyZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yRXhwb3J0XG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKGNvbnRhaW5lciwgd2lkdGgsIGhlaWdodCwgc3R5bGUsIGZvckV4cG9ydCkge1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdFx0bG9jID0gbG9jYXRpb24sXG5cdFx0XHRcdGJveFdyYXBwZXIsXG5cdFx0XHRcdGVsZW1lbnQsXG5cdFx0XHRcdGRlc2M7XG5cblx0XHRcdGJveFdyYXBwZXIgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KCdzdmcnKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0dmVyc2lvbjogJzEuMSdcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyh0aGlzLmdldFN0eWxlKHN0eWxlKSk7XG5cdFx0XHRlbGVtZW50ID0gYm94V3JhcHBlci5lbGVtZW50O1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG5cdFx0XHQvLyBGb3IgYnJvd3NlcnMgb3RoZXIgdGhhbiBJRSwgYWRkIHRoZSBuYW1lc3BhY2UgYXR0cmlidXRlICgjMTk3OClcblx0XHRcdGlmIChjb250YWluZXIuaW5uZXJIVE1MLmluZGV4T2YoJ3htbG5zJykgPT09IC0xKSB7XG5cdFx0XHRcdGF0dHIoZWxlbWVudCwgJ3htbG5zJywgU1ZHX05TKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gb2JqZWN0IHByb3BlcnRpZXNcblx0XHRcdHJlbmRlcmVyLmlzU1ZHID0gdHJ1ZTtcblx0XHRcdHJlbmRlcmVyLmJveCA9IGVsZW1lbnQ7XG5cdFx0XHRyZW5kZXJlci5ib3hXcmFwcGVyID0gYm94V3JhcHBlcjtcblx0XHRcdHJlbmRlcmVyLmFsaWduZWRPYmplY3RzID0gW107XG5cblx0XHRcdC8vIFBhZ2UgdXJsIHVzZWQgZm9yIGludGVybmFsIHJlZmVyZW5jZXMuICMyNCwgIzY3MiwgIzEwNzBcblx0XHRcdHJlbmRlcmVyLnVybCA9IChpc0ZpcmVmb3ggfHwgaXNXZWJLaXQpICYmIGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpLmxlbmd0aCA/XG5cdFx0XHRcdGxvYy5ocmVmXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyMuKj8kLywgJycpIC8vIHJlbW92ZSB0aGUgaGFzaFxuXHRcdFx0XHRcdC5yZXBsYWNlKC8oW1xcKCdcXCldKS9nLCAnXFxcXCQxJykgLy8gZXNjYXBlIHBhcmFudGhlc2VzIGFuZCBxdW90ZXNcblx0XHRcdFx0XHQucmVwbGFjZSgvIC9nLCAnJTIwJykgOiAvLyByZXBsYWNlIHNwYWNlcyAobmVlZGVkIGZvciBTYWZhcmkgb25seSlcblx0XHRcdFx0Jyc7XG5cblx0XHRcdC8vIEFkZCBkZXNjcmlwdGlvblxuXHRcdFx0ZGVzYyA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZGVzYycpLmFkZCgpO1xuXHRcdFx0ZGVzYy5lbGVtZW50LmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSgnQ3JlYXRlZCB3aXRoICcgKyBQUk9EVUNUICsgJyAnICsgVkVSU0lPTikpO1xuXG5cblx0XHRcdHJlbmRlcmVyLmRlZnMgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2RlZnMnKS5hZGQoKTtcblx0XHRcdHJlbmRlcmVyLmZvckV4cG9ydCA9IGZvckV4cG9ydDtcblx0XHRcdHJlbmRlcmVyLmdyYWRpZW50cyA9IHt9OyAvLyBPYmplY3Qgd2hlcmUgZ3JhZGllbnQgU3ZnRWxlbWVudHMgYXJlIHN0b3JlZFxuXHRcdFx0cmVuZGVyZXIuY2FjaGUgPSB7fTsgLy8gQ2FjaGUgZm9yIG51bWVyaWNhbCBib3VuZGluZyBib3hlc1xuXG5cdFx0XHRyZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIGZhbHNlKTtcblxuXG5cblx0XHRcdC8vIElzc3VlIDExMCB3b3JrYXJvdW5kOlxuXHRcdFx0Ly8gSW4gRmlyZWZveCwgaWYgYSBkaXYgaXMgcG9zaXRpb25lZCBieSBwZXJjZW50YWdlLCBpdHMgcGl4ZWwgcG9zaXRpb24gbWF5IGxhbmRcblx0XHRcdC8vIGJldHdlZW4gcGl4ZWxzLiBUaGUgY29udGFpbmVyIGl0c2VsZiBkb2Vzbid0IGRpc3BsYXkgdGhpcywgYnV0IGFuIFNWRyBlbGVtZW50XG5cdFx0XHQvLyBpbnNpZGUgdGhpcyBjb250YWluZXIgd2lsbCBiZSBkcmF3biBhdCBzdWJwaXhlbCBwcmVjaXNpb24uIEluIG9yZGVyIHRvIGRyYXdcblx0XHRcdC8vIHNoYXJwIGxpbmVzLCB0aGlzIG11c3QgYmUgY29tcGVuc2F0ZWQgZm9yLiBUaGlzIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluc2lkZVxuXHRcdFx0Ly8gaWZyYW1lcyB0aG91Z2ggKGxpa2UgaW4ganNGaWRkbGUpLlxuXHRcdFx0dmFyIHN1YlBpeGVsRml4LCByZWN0O1xuXHRcdFx0aWYgKGlzRmlyZWZveCAmJiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG5cdFx0XHRcdHJlbmRlcmVyLnN1YlBpeGVsRml4ID0gc3ViUGl4ZWxGaXggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Y3NzKGNvbnRhaW5lciwgeyBsZWZ0OiAwLCB0b3A6IDAgfSk7XG5cdFx0XHRcdFx0cmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHRjc3MoY29udGFpbmVyLCB7XG5cdFx0XHRcdFx0XHRsZWZ0OiAobWF0aENlaWwocmVjdC5sZWZ0KSAtIHJlY3QubGVmdCkgKyBQWCxcblx0XHRcdFx0XHRcdHRvcDogKG1hdGhDZWlsKHJlY3QudG9wKSAtIHJlY3QudG9wKSArIFBYXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gcnVuIHRoZSBmaXggbm93XG5cdFx0XHRcdHN1YlBpeGVsRml4KCk7XG5cblx0XHRcdFx0Ly8gcnVuIGl0IG9uIHJlc2l6ZVxuXHRcdFx0XHRhZGRFdmVudCh3aW4sICdyZXNpemUnLCBzdWJQaXhlbEZpeCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRcdHJldHVybiAodGhpcy5zdHlsZSA9IGV4dGVuZCh7XG5cdFx0XHRcdGZvbnRGYW1pbHk6ICdcIkx1Y2lkYSBHcmFuZGVcIiwgXCJMdWNpZGEgU2FucyBVbmljb2RlXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLCAvLyBkZWZhdWx0IGZvbnRcblx0XHRcdFx0Zm9udFNpemU6ICcxMnB4J1xuXHRcdFx0fSwgc3R5bGUpKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZWN0IHdoZXRoZXIgdGhlIHJlbmRlcmVyIGlzIGhpZGRlbi4gVGhpcyBoYXBwZW5zIHdoZW4gb25lIG9mIHRoZSBwYXJlbnQgZWxlbWVudHNcblx0XHQgKiBoYXMgZGlzcGxheTogbm9uZS4gIzYwOC5cblx0XHQgKi9cblx0XHRpc0hpZGRlbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLmJveFdyYXBwZXIuZ2V0QkJveCgpLndpZHRoO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95cyB0aGUgcmVuZGVyZXIgYW5kIGl0cyBhbGxvY2F0ZWQgbWVtYmVycy5cblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0XHRyZW5kZXJlckRlZnMgPSByZW5kZXJlci5kZWZzO1xuXHRcdFx0cmVuZGVyZXIuYm94ID0gbnVsbDtcblx0XHRcdHJlbmRlcmVyLmJveFdyYXBwZXIgPSByZW5kZXJlci5ib3hXcmFwcGVyLmRlc3Ryb3koKTtcblxuXHRcdFx0Ly8gQ2FsbCBkZXN0cm95IG9uIGFsbCBncmFkaWVudCBlbGVtZW50c1xuXHRcdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXMocmVuZGVyZXIuZ3JhZGllbnRzIHx8IHt9KTtcblx0XHRcdHJlbmRlcmVyLmdyYWRpZW50cyA9IG51bGw7XG5cblx0XHRcdC8vIERlZnMgYXJlIG51bGwgaW4gVk1MUmVuZGVyZXJcblx0XHRcdC8vIE90aGVyd2lzZSwgZGVzdHJveSB0aGVtIGhlcmUuXG5cdFx0XHRpZiAocmVuZGVyZXJEZWZzKSB7XG5cdFx0XHRcdHJlbmRlcmVyLmRlZnMgPSByZW5kZXJlckRlZnMuZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgc3ViIHBpeGVsIGZpeCBoYW5kbGVyXG5cdFx0XHQvLyBXZSBuZWVkIHRvIGNoZWNrIHRoYXQgdGhlcmUgaXMgYSBoYW5kbGVyLCBvdGhlcndpc2UgYWxsIGZ1bmN0aW9ucyB0aGF0IGFyZSByZWdpc3RlcmVkIGZvciBldmVudCAncmVzaXplJyBhcmUgcmVtb3ZlZFxuXHRcdFx0Ly8gU2VlIGlzc3VlICM5ODJcblx0XHRcdGlmIChyZW5kZXJlci5zdWJQaXhlbEZpeCkge1xuXHRcdFx0XHRyZW1vdmVFdmVudCh3aW4sICdyZXNpemUnLCByZW5kZXJlci5zdWJQaXhlbEZpeCk7XG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlcmVyLmFsaWduZWRPYmplY3RzID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIHdyYXBwZXIgZm9yIGFuIFNWRyBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVOYW1lXG5cdFx0ICovXG5cdFx0Y3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IG5ldyB0aGlzLkVsZW1lbnQoKTtcblx0XHRcdHdyYXBwZXIuaW5pdCh0aGlzLCBub2RlTmFtZSk7XG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHVtbXkgZnVuY3Rpb24gZm9yIHVzZSBpbiBjYW52YXMgcmVuZGVyZXJcblx0XHQgKi9cblx0XHRkcmF3OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBhcnNlIGEgc2ltcGxlIEhUTUwgc3RyaW5nIGludG8gU1ZHIHRzcGFuc1xuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRleHROb2RlIFRoZSBwYXJlbnQgdGV4dCBTVkcgbm9kZVxuXHRcdCAqL1xuXHRcdGJ1aWxkVGV4dDogZnVuY3Rpb24gKHdyYXBwZXIpIHtcblx0XHRcdHZhciB0ZXh0Tm9kZSA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0XHRmb3JFeHBvcnQgPSByZW5kZXJlci5mb3JFeHBvcnQsXG5cdFx0XHRcdHRleHRTdHIgPSBwaWNrKHdyYXBwZXIudGV4dFN0ciwgJycpLnRvU3RyaW5nKCksXG5cdFx0XHRcdGhhc01hcmt1cCA9IHRleHRTdHIuaW5kZXhPZignPCcpICE9PSAtMSxcblx0XHRcdFx0bGluZXMsXG5cdFx0XHRcdGNoaWxkTm9kZXMgPSB0ZXh0Tm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0XHRzdHlsZVJlZ2V4LFxuXHRcdFx0XHRocmVmUmVnZXgsXG5cdFx0XHRcdHBhcmVudFggPSBhdHRyKHRleHROb2RlLCAneCcpLFxuXHRcdFx0XHR0ZXh0U3R5bGVzID0gd3JhcHBlci5zdHlsZXMsXG5cdFx0XHRcdHdpZHRoID0gd3JhcHBlci50ZXh0V2lkdGgsXG5cdFx0XHRcdHRleHRMaW5lSGVpZ2h0ID0gdGV4dFN0eWxlcyAmJiB0ZXh0U3R5bGVzLmxpbmVIZWlnaHQsXG5cdFx0XHRcdHRleHRTaGFkb3cgPSB0ZXh0U3R5bGVzICYmIHRleHRTdHlsZXMudGV4dFNoYWRvdyxcblx0XHRcdFx0ZWxsaXBzaXMgPSB0ZXh0U3R5bGVzICYmIHRleHRTdHlsZXMudGV4dE92ZXJmbG93ID09PSAnZWxsaXBzaXMnLFxuXHRcdFx0XHRpID0gY2hpbGROb2Rlcy5sZW5ndGgsXG5cdFx0XHRcdHRlbXBQYXJlbnQgPSB3aWR0aCAmJiAhd3JhcHBlci5hZGRlZCAmJiB0aGlzLmJveCxcblx0XHRcdFx0Z2V0TGluZUhlaWdodCA9IGZ1bmN0aW9uICh0c3Bhbikge1xuXHRcdFx0XHRcdHJldHVybiB0ZXh0TGluZUhlaWdodCA/IFxuXHRcdFx0XHRcdFx0cEludCh0ZXh0TGluZUhlaWdodCkgOlxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuZm9udE1ldHJpY3MoXG5cdFx0XHRcdFx0XHRcdC8ocHh8ZW0pJC8udGVzdCh0c3BhbiAmJiB0c3Bhbi5zdHlsZS5mb250U2l6ZSkgP1xuXHRcdFx0XHRcdFx0XHRcdHRzcGFuLnN0eWxlLmZvbnRTaXplIDpcblx0XHRcdFx0XHRcdFx0XHQoKHRleHRTdHlsZXMgJiYgdGV4dFN0eWxlcy5mb250U2l6ZSkgfHwgcmVuZGVyZXIuc3R5bGUuZm9udFNpemUgfHwgMTIpLFxuXHRcdFx0XHRcdFx0XHR0c3BhblxuXHRcdFx0XHRcdFx0KS5oO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1bmVzY2FwZUFuZ2xlQnJhY2tldHMgPSBmdW5jdGlvbiAoaW5wdXRTdHIpIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5wdXRTdHIucmVwbGFjZSgvJmx0Oy9nLCAnPCcpLnJlcGxhY2UoLyZndDsvZywgJz4nKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8vIHJlbW92ZSBvbGQgdGV4dFxuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR0ZXh0Tm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2tpcCB0c3BhbnMsIGFkZCB0ZXh0IGRpcmVjdGx5IHRvIHRleHQgbm9kZS4gVGhlIGZvcmNlVFNwYW4gaXMgYSBob29rIFxuXHRcdFx0Ly8gdXNlZCBpbiB0ZXh0IG91dGxpbmUgaGFjay5cblx0XHRcdGlmICghaGFzTWFya3VwICYmICF0ZXh0U2hhZG93ICYmICFlbGxpcHNpcyAmJiB0ZXh0U3RyLmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcblx0XHRcdFx0dGV4dE5vZGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHVuZXNjYXBlQW5nbGVCcmFja2V0cyh0ZXh0U3RyKSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIENvbXBsZXggc3RyaW5ncywgYWRkIG1vcmUgbG9naWNcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3R5bGVSZWdleCA9IC88LipzdHlsZT1cIihbXlwiXSspXCIuKj4vO1xuXHRcdFx0XHRocmVmUmVnZXggPSAvPC4qaHJlZj1cIihodHRwW15cIl0rKVwiLio+LztcblxuXHRcdFx0XHRpZiAodGVtcFBhcmVudCkge1xuXHRcdFx0XHRcdHRlbXBQYXJlbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpOyAvLyBhdHRhY2ggaXQgdG8gdGhlIERPTSB0byByZWFkIG9mZnNldCB3aWR0aFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGhhc01hcmt1cCkge1xuXHRcdFx0XHRcdGxpbmVzID0gdGV4dFN0clxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoLzwoYnxzdHJvbmcpPi9nLCAnPHNwYW4gc3R5bGU9XCJmb250LXdlaWdodDpib2xkXCI+Jylcblx0XHRcdFx0XHRcdC5yZXBsYWNlKC88KGl8ZW0pPi9nLCAnPHNwYW4gc3R5bGU9XCJmb250LXN0eWxlOml0YWxpY1wiPicpXG5cdFx0XHRcdFx0XHQucmVwbGFjZSgvPGEvZywgJzxzcGFuJylcblx0XHRcdFx0XHRcdC5yZXBsYWNlKC88XFwvKGJ8c3Ryb25nfGl8ZW18YSk+L2csICc8L3NwYW4+Jylcblx0XHRcdFx0XHRcdC5zcGxpdCgvPGJyLio/Pi9nKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpbmVzID0gW3RleHRTdHJdO1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyByZW1vdmUgZW1wdHkgbGluZSBhdCBlbmRcblx0XHRcdFx0aWYgKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID09PSAnJykge1xuXHRcdFx0XHRcdGxpbmVzLnBvcCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIGJ1aWxkIHRoZSBsaW5lc1xuXHRcdFx0XHRlYWNoKGxpbmVzLCBmdW5jdGlvbiAobGluZSwgbGluZU5vKSB7XG5cdFx0XHRcdFx0dmFyIHNwYW5zLCBzcGFuTm8gPSAwO1xuXG5cdFx0XHRcdFx0bGluZSA9IGxpbmUucmVwbGFjZSgvPHNwYW4vZywgJ3x8fDxzcGFuJykucmVwbGFjZSgvPFxcL3NwYW4+L2csICc8L3NwYW4+fHx8Jyk7XG5cdFx0XHRcdFx0c3BhbnMgPSBsaW5lLnNwbGl0KCd8fHwnKTtcblxuXHRcdFx0XHRcdGVhY2goc3BhbnMsIGZ1bmN0aW9uIChzcGFuKSB7XG5cdFx0XHRcdFx0XHRpZiAoc3BhbiAhPT0gJycgfHwgc3BhbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0ge30sXG5cdFx0XHRcdFx0XHRcdFx0dHNwYW4gPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgJ3RzcGFuJyksXG5cdFx0XHRcdFx0XHRcdFx0c3BhblN0eWxlOyAvLyAjMzkwXG5cdFx0XHRcdFx0XHRcdGlmIChzdHlsZVJlZ2V4LnRlc3Qoc3BhbikpIHtcblx0XHRcdFx0XHRcdFx0XHRzcGFuU3R5bGUgPSBzcGFuLm1hdGNoKHN0eWxlUmVnZXgpWzFdLnJlcGxhY2UoLyg7fCB8Xiljb2xvcihbIDpdKS8sICckMWZpbGwkMicpO1xuXHRcdFx0XHRcdFx0XHRcdGF0dHIodHNwYW4sICdzdHlsZScsIHNwYW5TdHlsZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGhyZWZSZWdleC50ZXN0KHNwYW4pICYmICFmb3JFeHBvcnQpIHsgLy8gTm90IGZvciBleHBvcnQgLSAjMTUyOVxuXHRcdFx0XHRcdFx0XHRcdGF0dHIodHNwYW4sICdvbmNsaWNrJywgJ2xvY2F0aW9uLmhyZWY9XFxcIicgKyBzcGFuLm1hdGNoKGhyZWZSZWdleClbMV0gKyAnXFxcIicpO1xuXHRcdFx0XHRcdFx0XHRcdGNzcyh0c3BhbiwgeyBjdXJzb3I6ICdwb2ludGVyJyB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHNwYW4gPSB1bmVzY2FwZUFuZ2xlQnJhY2tldHMoc3Bhbi5yZXBsYWNlKC88KC58XFxuKSo/Pi9nLCAnJykgfHwgJyAnKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBOZXN0ZWQgdGFncyBhcmVuJ3Qgc3VwcG9ydGVkLCBhbmQgY2F1c2UgY3Jhc2ggaW4gU2FmYXJpICgjMTU5Nilcblx0XHRcdFx0XHRcdFx0aWYgKHNwYW4gIT09ICcgJykge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYWRkIHRoZSB0ZXh0IG5vZGVcblx0XHRcdFx0XHRcdFx0XHR0c3Bhbi5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoc3BhbikpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFzcGFuTm8pIHsgLy8gZmlyc3Qgc3BhbiBpbiBhIGxpbmUsIGFsaWduIGl0IHRvIHRoZSBsZWZ0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobGluZU5vICYmIHBhcmVudFggIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YXR0cmlidXRlcy54ID0gcGFyZW50WDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0YXR0cmlidXRlcy5keCA9IDA7IC8vICMxNlxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIGFkZCBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgYXR0cmlidXRlcyk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBBcHBlbmQgaXRcblx0XHRcdFx0XHRcdFx0XHR0ZXh0Tm9kZS5hcHBlbmRDaGlsZCh0c3Bhbik7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBzcGFuIG9uIHN1YnNlcXVlbnQgbGluZSwgYWRkIHRoZSBsaW5lIGhlaWdodFxuXHRcdFx0XHRcdFx0XHRcdGlmICghc3Bhbk5vICYmIGxpbmVObykge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBhbGxvdyBnZXR0aW5nIHRoZSByaWdodCBvZmZzZXQgaGVpZ2h0IGluIGV4cG9ydGluZyBpbiBJRVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFoYXNTVkcgJiYgZm9yRXhwb3J0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNzcyh0c3BhbiwgeyBkaXNwbGF5OiAnYmxvY2snIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTZXQgdGhlIGxpbmUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBmb250IHNpemUgb2YgZWl0aGVyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgdGV4dCBlbGVtZW50IG9yIHRoZSB0c3BhbiBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRhdHRyKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0c3Bhbixcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2R5Jyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Z2V0TGluZUhlaWdodCh0c3Bhbilcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyppZiAod2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlbmRlcmVyLmJyZWFrVGV4dCh3cmFwcGVyLCB3aWR0aCk7XG5cdFx0XHRcdFx0XHRcdFx0fSovXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDaGVjayB3aWR0aCBhbmQgYXBwbHkgc29mdCBicmVha3Mgb3IgZWxsaXBzaXNcblx0XHRcdFx0XHRcdFx0XHRpZiAod2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciB3b3JkcyA9IHNwYW4ucmVwbGFjZSgvKFteXFxeXSktL2csICckMS0gJykuc3BsaXQoJyAnKSwgLy8gIzEyNzNcblx0XHRcdFx0XHRcdFx0XHRcdFx0aGFzV2hpdGVTcGFjZSA9IHNwYW5zLmxlbmd0aCA+IDEgfHwgbGluZU5vIHx8ICh3b3Jkcy5sZW5ndGggPiAxICYmIHRleHRTdHlsZXMud2hpdGVTcGFjZSAhPT0gJ25vd3JhcCcpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0b29Mb25nLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR3YXNUb29Mb25nLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhY3R1YWxXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdCA9IFtdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkeSA9IGdldExpbmVIZWlnaHQodHNwYW4pLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzb2Z0TGluZU5vID0gMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cm90YXRpb24gPSB3cmFwcGVyLnJvdGF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR3b3JkU3RyID0gc3BhbiwgLy8gZm9yIGVsbGlwc2lzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnNvciA9IHdvcmRTdHIubGVuZ3RoLCAvLyBiaW5hcnkgc2VhcmNoIGN1cnNvclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRiQm94O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoKGhhc1doaXRlU3BhY2UgfHwgZWxsaXBzaXMpICYmICh3b3Jkcy5sZW5ndGggfHwgcmVzdC5sZW5ndGgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdyYXBwZXIucm90YXRpb24gPSAwOyAvLyBkaXNjYXJkIHJvdGF0aW9uIHdoZW4gY29tcHV0aW5nIGJveFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRiQm94ID0gd3JhcHBlci5nZXRCQm94KHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhY3R1YWxXaWR0aCA9IGJCb3gud2lkdGg7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT2xkIElFIGNhbm5vdCBtZWFzdXJlIHRoZSBhY3R1YWxXaWR0aCBmb3IgU1ZHIGVsZW1lbnRzICgjMjMxNClcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFoYXNTVkcgJiYgcmVuZGVyZXIuZm9yRXhwb3J0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0dWFsV2lkdGggPSByZW5kZXJlci5tZWFzdXJlU3BhbldpZHRoKHRzcGFuLmZpcnN0Q2hpbGQuZGF0YSwgd3JhcHBlci5zdHlsZXMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dG9vTG9uZyA9IGFjdHVhbFdpZHRoID4gd2lkdGg7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIGVsbGlwc2lzLCBkbyBhIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBjb3JyZWN0IHN0cmluZyBsZW5ndGhcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHdhc1Rvb0xvbmcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdhc1Rvb0xvbmcgPSB0b29Mb25nOyAvLyBGaXJzdCB0aW1lXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVsbGlwc2lzICYmIHdhc1Rvb0xvbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJzb3IgLz0gMjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh3b3JkU3RyID09PSAnJyB8fCAoIXRvb0xvbmcgJiYgY3Vyc29yIDwgMC41KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0d29yZHMgPSBbXTsgLy8gQWxsIG9rLCBicmVhayBvdXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRvb0xvbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0d2FzVG9vTG9uZyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3b3JkU3RyID0gc3Bhbi5zdWJzdHJpbmcoMCwgd29yZFN0ci5sZW5ndGggKyAodG9vTG9uZyA/IC0xIDogMSkgKiBtYXRoQ2VpbChjdXJzb3IpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdvcmRzID0gW3dvcmRTdHIgKyAnXFx1MjAyNiddO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHNwYW4ucmVtb3ZlQ2hpbGQodHNwYW4uZmlyc3RDaGlsZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIExvb3BpbmcgZG93biwgdGhpcyBpcyB0aGUgZmlyc3Qgd29yZCBzZXF1ZW5jZSB0aGF0IGlzIG5vdCB0b28gbG9uZyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gc28gd2UgY2FuIG1vdmUgb24gdG8gYnVpbGQgdGhlIG5leHQgbGluZS5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghdG9vTG9uZyB8fCB3b3Jkcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3b3JkcyA9IHJlc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdCA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAod29yZHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzb2Z0TGluZU5vKys7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICd0c3BhbicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXR0cih0c3Bhbiwge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkeTogZHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHg6IHBhcmVudFhcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHNwYW5TdHlsZSkgeyAvLyAjMzkwXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGF0dHIodHNwYW4sICdzdHlsZScsIHNwYW5TdHlsZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0Tm9kZS5hcHBlbmRDaGlsZCh0c3Bhbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChhY3R1YWxXaWR0aCA+IHdpZHRoKSB7IC8vIGEgc2luZ2xlIHdvcmQgaXMgcHJlc3NpbmcgaXQgb3V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3aWR0aCA9IGFjdHVhbFdpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gYXBwZW5kIHRvIGV4aXN0aW5nIGxpbmUgdHNwYW5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0c3Bhbi5yZW1vdmVDaGlsZCh0c3Bhbi5maXJzdENoaWxkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN0LnVuc2hpZnQod29yZHMucG9wKCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh3b3Jkcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0c3Bhbi5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUod29yZHMuam9pbignICcpLnJlcGxhY2UoLy0gL2csICctJykpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHdhc1Rvb0xvbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0d3JhcHBlci5hdHRyKCd0aXRsZScsIHdyYXBwZXIudGV4dFN0cik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR3cmFwcGVyLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0c3Bhbk5vKys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmICh0ZW1wUGFyZW50KSB7XG5cdFx0XHRcdFx0dGVtcFBhcmVudC5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7IC8vIGF0dGFjaCBpdCB0byB0aGUgRE9NIHRvIHJlYWQgb2Zmc2V0IHdpZHRoXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSB0aGUgdGV4dCBzaGFkb3dcblx0XHRcdFx0aWYgKHRleHRTaGFkb3cgJiYgd3JhcHBlci5hcHBseVRleHRTaGFkb3cpIHtcblx0XHRcdFx0XHR3cmFwcGVyLmFwcGx5VGV4dFNoYWRvdyh0ZXh0U2hhZG93KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRcblxuXHRcdC8qXG5cdFx0YnJlYWtUZXh0OiBmdW5jdGlvbiAod3JhcHBlciwgd2lkdGgpIHtcblx0XHRcdHZhciBiQm94ID0gd3JhcHBlci5nZXRCQm94KCksXG5cdFx0XHRcdG5vZGUgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdHRleHRMZW5ndGggPSBub2RlLnRleHRDb250ZW50Lmxlbmd0aCxcblx0XHRcdFx0cG9zID0gbWF0aFJvdW5kKHdpZHRoICogdGV4dExlbmd0aCAvIGJCb3gud2lkdGgpLCAvLyB0cnkgdGhpcyBwb3NpdGlvbiBmaXJzdCwgYmFzZWQgb24gYXZlcmFnZSBjaGFyYWN0ZXIgd2lkdGhcblx0XHRcdFx0aW5jcmVtZW50ID0gMCxcblx0XHRcdFx0ZmluYWxQb3M7XG5cblx0XHRcdGlmIChiQm94LndpZHRoID4gd2lkdGgpIHtcblx0XHRcdFx0d2hpbGUgKGZpbmFsUG9zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0ZXh0TGVuZ3RoID0gbm9kZS5nZXRTdWJTdHJpbmdMZW5ndGgoMCwgcG9zKTtcblxuXHRcdFx0XHRcdGlmICh0ZXh0TGVuZ3RoIDw9IHdpZHRoKSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5jcmVtZW50ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRmaW5hbFBvcyA9IHBvcztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGluY3JlbWVudCA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnQgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0ZmluYWxQb3MgPSBwb3MgLSAxO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5jcmVtZW50ID0gLTE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvcyArPSBpbmNyZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKGZpbmFsUG9zLCBub2RlLmdldFN1YlN0cmluZ0xlbmd0aCgwLCBmaW5hbFBvcykpXG5cdFx0fSxcblx0XHQqL1xuXG5cdFx0LyoqIFxuXHRcdCAqIFJldHVybnMgd2hpdGUgZm9yIGRhcmsgY29sb3JzIGFuZCBibGFjayBmb3IgYnJpZ2h0IGNvbG9yc1xuXHRcdCAqL1xuXHRcdGdldENvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IpIHtcblx0XHRcdGNvbG9yID0gQ29sb3IoY29sb3IpLnJnYmE7XG5cdFx0XHRyZXR1cm4gY29sb3JbMF0gKyBjb2xvclsxXSArIGNvbG9yWzJdID4gMzg0ID8gJyMwMDAnIDogJyNGRkYnO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBidXR0b24gd2l0aCBwcmVzZXQgc3RhdGVzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9ybWFsU3RhdGVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaG92ZXJTdGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzc2VkU3RhdGVcblx0XHQgKi9cblx0XHRidXR0b246IGZ1bmN0aW9uICh0ZXh0LCB4LCB5LCBjYWxsYmFjaywgbm9ybWFsU3RhdGUsIGhvdmVyU3RhdGUsIHByZXNzZWRTdGF0ZSwgZGlzYWJsZWRTdGF0ZSwgc2hhcGUpIHtcblx0XHRcdHZhciBsYWJlbCA9IHRoaXMubGFiZWwodGV4dCwgeCwgeSwgc2hhcGUsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICdidXR0b24nKSxcblx0XHRcdFx0Y3VyU3RhdGUgPSAwLFxuXHRcdFx0XHRzdGF0ZU9wdGlvbnMsXG5cdFx0XHRcdHN0YXRlU3R5bGUsXG5cdFx0XHRcdG5vcm1hbFN0eWxlLFxuXHRcdFx0XHRob3ZlclN0eWxlLFxuXHRcdFx0XHRwcmVzc2VkU3R5bGUsXG5cdFx0XHRcdGRpc2FibGVkU3R5bGUsXG5cdFx0XHRcdHZlcnRpY2FsR3JhZGllbnQgPSB7IHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAxIH07XG5cblx0XHRcdC8vIE5vcm1hbCBzdGF0ZSAtIHByZXBhcmUgdGhlIGF0dHJpYnV0ZXNcblx0XHRcdG5vcm1hbFN0YXRlID0gbWVyZ2Uoe1xuXHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMSxcblx0XHRcdFx0c3Ryb2tlOiAnI0NDQ0NDQycsXG5cdFx0XHRcdGZpbGw6IHtcblx0XHRcdFx0XHRsaW5lYXJHcmFkaWVudDogdmVydGljYWxHcmFkaWVudCxcblx0XHRcdFx0XHRzdG9wczogW1xuXHRcdFx0XHRcdFx0WzAsICcjRkVGRUZFJ10sXG5cdFx0XHRcdFx0XHRbMSwgJyNGNkY2RjYnXVxuXHRcdFx0XHRcdF1cblx0XHRcdFx0fSxcblx0XHRcdFx0cjogMixcblx0XHRcdFx0cGFkZGluZzogNSxcblx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRjb2xvcjogJ2JsYWNrJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBub3JtYWxTdGF0ZSk7XG5cdFx0XHRub3JtYWxTdHlsZSA9IG5vcm1hbFN0YXRlLnN0eWxlO1xuXHRcdFx0ZGVsZXRlIG5vcm1hbFN0YXRlLnN0eWxlO1xuXG5cdFx0XHQvLyBIb3ZlciBzdGF0ZVxuXHRcdFx0aG92ZXJTdGF0ZSA9IG1lcmdlKG5vcm1hbFN0YXRlLCB7XG5cdFx0XHRcdHN0cm9rZTogJyM2OEEnLFxuXHRcdFx0XHRmaWxsOiB7XG5cdFx0XHRcdFx0bGluZWFyR3JhZGllbnQ6IHZlcnRpY2FsR3JhZGllbnQsXG5cdFx0XHRcdFx0c3RvcHM6IFtcblx0XHRcdFx0XHRcdFswLCAnI0ZGRiddLFxuXHRcdFx0XHRcdFx0WzEsICcjQUNGJ11cblx0XHRcdFx0XHRdXG5cdFx0XHRcdH1cblx0XHRcdH0sIGhvdmVyU3RhdGUpO1xuXHRcdFx0aG92ZXJTdHlsZSA9IGhvdmVyU3RhdGUuc3R5bGU7XG5cdFx0XHRkZWxldGUgaG92ZXJTdGF0ZS5zdHlsZTtcblxuXHRcdFx0Ly8gUHJlc3NlZCBzdGF0ZVxuXHRcdFx0cHJlc3NlZFN0YXRlID0gbWVyZ2Uobm9ybWFsU3RhdGUsIHtcblx0XHRcdFx0c3Ryb2tlOiAnIzY4QScsXG5cdFx0XHRcdGZpbGw6IHtcblx0XHRcdFx0XHRsaW5lYXJHcmFkaWVudDogdmVydGljYWxHcmFkaWVudCxcblx0XHRcdFx0XHRzdG9wczogW1xuXHRcdFx0XHRcdFx0WzAsICcjOUJEJ10sXG5cdFx0XHRcdFx0XHRbMSwgJyNDREYnXVxuXHRcdFx0XHRcdF1cblx0XHRcdFx0fVxuXHRcdFx0fSwgcHJlc3NlZFN0YXRlKTtcblx0XHRcdHByZXNzZWRTdHlsZSA9IHByZXNzZWRTdGF0ZS5zdHlsZTtcblx0XHRcdGRlbGV0ZSBwcmVzc2VkU3RhdGUuc3R5bGU7XG5cblx0XHRcdC8vIERpc2FibGVkIHN0YXRlXG5cdFx0XHRkaXNhYmxlZFN0YXRlID0gbWVyZ2Uobm9ybWFsU3RhdGUsIHtcblx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRjb2xvcjogJyNDQ0MnXG5cdFx0XHRcdH1cblx0XHRcdH0sIGRpc2FibGVkU3RhdGUpO1xuXHRcdFx0ZGlzYWJsZWRTdHlsZSA9IGRpc2FibGVkU3RhdGUuc3R5bGU7XG5cdFx0XHRkZWxldGUgZGlzYWJsZWRTdGF0ZS5zdHlsZTtcblxuXHRcdFx0Ly8gQWRkIHRoZSBldmVudHMuIElFOSBhbmQgSUUxMCBuZWVkIG1vdXNlb3ZlciBhbmQgbW91c2VvdXQgdG8gZnVuY2l0b24gKCM2NjcpLlxuXHRcdFx0YWRkRXZlbnQobGFiZWwuZWxlbWVudCwgaXNJRSA/ICdtb3VzZW92ZXInIDogJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChjdXJTdGF0ZSAhPT0gMykge1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIoaG92ZXJTdGF0ZSlcblx0XHRcdFx0XHRcdC5jc3MoaG92ZXJTdHlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0YWRkRXZlbnQobGFiZWwuZWxlbWVudCwgaXNJRSA/ICdtb3VzZW91dCcgOiAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGN1clN0YXRlICE9PSAzKSB7XG5cdFx0XHRcdFx0c3RhdGVPcHRpb25zID0gW25vcm1hbFN0YXRlLCBob3ZlclN0YXRlLCBwcmVzc2VkU3RhdGVdW2N1clN0YXRlXTtcblx0XHRcdFx0XHRzdGF0ZVN0eWxlID0gW25vcm1hbFN0eWxlLCBob3ZlclN0eWxlLCBwcmVzc2VkU3R5bGVdW2N1clN0YXRlXTtcblx0XHRcdFx0XHRsYWJlbC5hdHRyKHN0YXRlT3B0aW9ucylcblx0XHRcdFx0XHRcdC5jc3Moc3RhdGVTdHlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRsYWJlbC5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHRcdFx0XHRsYWJlbC5zdGF0ZSA9IGN1clN0YXRlID0gc3RhdGU7XG5cdFx0XHRcdGlmICghc3RhdGUpIHtcblx0XHRcdFx0XHRsYWJlbC5hdHRyKG5vcm1hbFN0YXRlKVxuXHRcdFx0XHRcdFx0LmNzcyhub3JtYWxTdHlsZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09IDIpIHtcblx0XHRcdFx0XHRsYWJlbC5hdHRyKHByZXNzZWRTdGF0ZSlcblx0XHRcdFx0XHRcdC5jc3MocHJlc3NlZFN0eWxlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gMykge1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIoZGlzYWJsZWRTdGF0ZSlcblx0XHRcdFx0XHRcdC5jc3MoZGlzYWJsZWRTdHlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBsYWJlbFxuXHRcdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChjdXJTdGF0ZSAhPT0gMykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChsYWJlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXR0cihub3JtYWxTdGF0ZSlcblx0XHRcdFx0LmNzcyhleHRlbmQoeyBjdXJzb3I6ICdkZWZhdWx0JyB9LCBub3JtYWxTdHlsZSkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBNYWtlIGEgc3RyYWlnaHQgbGluZSBjcmlzcGVyIGJ5IG5vdCBzcGlsbGluZyBvdXQgdG8gbmVpZ2hib3VyIHBpeGVsc1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqL1xuXHRcdGNyaXNwTGluZTogZnVuY3Rpb24gKHBvaW50cywgd2lkdGgpIHtcblx0XHRcdC8vIHBvaW50cyBmb3JtYXQ6IFtNLCAwLCAwLCBMLCAxMDAsIDBdXG5cdFx0XHQvLyBub3JtYWxpemUgdG8gYSBjcmlzcCBsaW5lXG5cdFx0XHRpZiAocG9pbnRzWzFdID09PSBwb2ludHNbNF0pIHtcblx0XHRcdFx0Ly8gU3Vic3RyYWN0IGR1ZSB0byAjMTEyOS4gTm93IGJvdHRvbSBhbmQgbGVmdCBheGlzIGdyaWRsaW5lcyBiZWhhdmUgdGhlIHNhbWUuXG5cdFx0XHRcdHBvaW50c1sxXSA9IHBvaW50c1s0XSA9IG1hdGhSb3VuZChwb2ludHNbMV0pIC0gKHdpZHRoICUgMiAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvaW50c1syXSA9PT0gcG9pbnRzWzVdKSB7XG5cdFx0XHRcdHBvaW50c1syXSA9IHBvaW50c1s1XSA9IG1hdGhSb3VuZChwb2ludHNbMl0pICsgKHdpZHRoICUgMiAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBvaW50cztcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IGEgcGF0aFxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHBhdGggQW4gU1ZHIHBhdGggaW4gYXJyYXkgZm9ybVxuXHRcdCAqL1xuXHRcdHBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0XHR2YXIgYXR0ciA9IHtcblx0XHRcdFx0ZmlsbDogTk9ORVxuXHRcdFx0fTtcblx0XHRcdGlmIChpc0FycmF5KHBhdGgpKSB7XG5cdFx0XHRcdGF0dHIuZCA9IHBhdGg7XG5cdFx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KHBhdGgpKSB7IC8vIGF0dHJpYnV0ZXNcblx0XHRcdFx0ZXh0ZW5kKGF0dHIsIHBhdGgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudCgncGF0aCcpLmF0dHIoYXR0cik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgYW5kIHJldHVybiBhbiBTVkcgY2lyY2xlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSByIFRoZSByYWRpdXNcblx0XHQgKi9cblx0XHRjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCByKSB7XG5cdFx0XHR2YXIgYXR0ciA9IGlzT2JqZWN0KHgpID9cblx0XHRcdFx0eCA6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0cjogclxuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cmFwcGVyID0gdGhpcy5jcmVhdGVFbGVtZW50KCdjaXJjbGUnKTtcblxuXHRcdFx0d3JhcHBlci54U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2N4JywgdmFsdWUpO1xuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIueVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdjeScsIHZhbHVlKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gd3JhcHBlci5hdHRyKGF0dHIpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IGFuZCByZXR1cm4gYW4gYXJjXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gciBSYWRpdXNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaW5uZXJSIElubmVyIHJhZGl1cyBsaWtlIHVzZWQgaW4gZG9udXQgY2hhcnRzXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0aW5nIGFuZ2xlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmRpbmcgYW5nbGVcblx0XHQgKi9cblx0XHRhcmM6IGZ1bmN0aW9uICh4LCB5LCByLCBpbm5lclIsIHN0YXJ0LCBlbmQpIHtcblx0XHRcdHZhciBhcmM7XG5cblx0XHRcdGlmIChpc09iamVjdCh4KSkge1xuXHRcdFx0XHR5ID0geC55O1xuXHRcdFx0XHRyID0geC5yO1xuXHRcdFx0XHRpbm5lclIgPSB4LmlubmVyUjtcblx0XHRcdFx0c3RhcnQgPSB4LnN0YXJ0O1xuXHRcdFx0XHRlbmQgPSB4LmVuZDtcblx0XHRcdFx0eCA9IHgueDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXJjcyBhcmUgZGVmaW5lZCBhcyBzeW1ib2xzIGZvciB0aGUgYWJpbGl0eSB0byBzZXRcblx0XHRcdC8vIGF0dHJpYnV0ZXMgaW4gYXR0ciBhbmQgYW5pbWF0ZVxuXHRcdFx0YXJjID0gdGhpcy5zeW1ib2woJ2FyYycsIHggfHwgMCwgeSB8fCAwLCByIHx8IDAsIHIgfHwgMCwge1xuXHRcdFx0XHRpbm5lclI6IGlubmVyUiB8fCAwLFxuXHRcdFx0XHRzdGFydDogc3RhcnQgfHwgMCxcblx0XHRcdFx0ZW5kOiBlbmQgfHwgMFxuXHRcdFx0fSk7XG5cdFx0XHRhcmMuciA9IHI7IC8vICM5NTlcblx0XHRcdHJldHVybiBhcmM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgYW5kIHJldHVybiBhIHJlY3RhbmdsZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4IExlZnQgcG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge051bWJlcn0geSBUb3AgcG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgQm9yZGVyIGNvcm5lciByYWRpdXNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3Ryb2tlV2lkdGggQSBzdHJva2Ugd2lkdGggY2FuIGJlIHN1cHBsaWVkIHRvIGFsbG93IGNyaXNwIGRyYXdpbmdcblx0XHQgKi9cblx0XHRyZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgciwgc3Ryb2tlV2lkdGgpIHtcblxuXHRcdFx0ciA9IGlzT2JqZWN0KHgpID8geC5yIDogcjtcblxuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3JlY3QnKSxcblx0XHRcdFx0YXR0cmlicyA9IGlzT2JqZWN0KHgpID8geCA6IHggPT09IFVOREVGSU5FRCA/IHt9IDoge1xuXHRcdFx0XHRcdHg6IHgsXG5cdFx0XHRcdFx0eTogeSxcblx0XHRcdFx0XHR3aWR0aDogbWF0aE1heCh3aWR0aCwgMCksXG5cdFx0XHRcdFx0aGVpZ2h0OiBtYXRoTWF4KGhlaWdodCwgMClcblx0XHRcdFx0fTtcblxuXHRcdFx0aWYgKHN0cm9rZVdpZHRoICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0YXR0cmlicy5zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHRhdHRyaWJzID0gd3JhcHBlci5jcmlzcChhdHRyaWJzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHIpIHtcblx0XHRcdFx0YXR0cmlicy5yID0gcjtcblx0XHRcdH1cblxuXHRcdFx0d3JhcHBlci5yU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGF0dHIodGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdFx0cng6IHZhbHVlLFxuXHRcdFx0XHRcdHJ5OiB2YWx1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiB3cmFwcGVyLmF0dHIoYXR0cmlicyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlc2l6ZSB0aGUgYm94IGFuZCByZS1hbGlnbiBhbGwgYWxpZ25lZCBlbGVtZW50c1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBoZWlnaHRcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFuaW1hdGVcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBhbmltYXRlKSB7XG5cdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0XHRhbGlnbmVkT2JqZWN0cyA9IHJlbmRlcmVyLmFsaWduZWRPYmplY3RzLFxuXHRcdFx0XHRpID0gYWxpZ25lZE9iamVjdHMubGVuZ3RoO1xuXG5cdFx0XHRyZW5kZXJlci53aWR0aCA9IHdpZHRoO1xuXHRcdFx0cmVuZGVyZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRyZW5kZXJlci5ib3hXcmFwcGVyW3BpY2soYW5pbWF0ZSwgdHJ1ZSkgPyAnYW5pbWF0ZScgOiAnYXR0ciddKHtcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0fSk7XG5cblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0YWxpZ25lZE9iamVjdHNbaV0uYWxpZ24oKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgZ3JvdXBcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZ3JvdXAgd2lsbCBiZSBnaXZlbiBhIGNsYXNzIG5hbWUgb2YgJ2hpZ2hjaGFydHMte25hbWV9Jy5cblx0XHQgKlx0IFRoaXMgY2FuIGJlIHVzZWQgZm9yIHN0eWxpbmcgYW5kIHNjcmlwdGluZy5cblx0XHQgKi9cblx0XHRnOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2cnKTtcblx0XHRcdHJldHVybiBkZWZpbmVkKG5hbWUpID8gZWxlbS5hdHRyKHsgJ2NsYXNzJzogUFJFRklYICsgbmFtZSB9KSA6IGVsZW07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERpc3BsYXkgYW4gaW1hZ2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0XHQgKi9cblx0XHRpbWFnZTogZnVuY3Rpb24gKHNyYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0dmFyIGF0dHJpYnMgPSB7XG5cdFx0XHRcdFx0cHJlc2VydmVBc3BlY3RSYXRpbzogTk9ORVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlbGVtV3JhcHBlcjtcblxuXHRcdFx0Ly8gb3B0aW9uYWwgcHJvcGVydGllc1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGV4dGVuZChhdHRyaWJzLCB7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbVdyYXBwZXIgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2ltYWdlJykuYXR0cihhdHRyaWJzKTtcblxuXHRcdFx0Ly8gc2V0IHRoZSBocmVmIGluIHRoZSB4bGluayBuYW1lc3BhY2Vcblx0XHRcdGlmIChlbGVtV3JhcHBlci5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKSB7XG5cdFx0XHRcdGVsZW1XcmFwcGVyLmVsZW1lbnQuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdFx0XHRcdCdocmVmJywgc3JjKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNvdWxkIGJlIGV4cG9ydGluZyBpbiBJRVxuXHRcdFx0XHQvLyB1c2luZyBocmVmIHRocm93cyBcIm5vdCBzdXBwb3J0ZWRcIiBpbiBpZTcgYW5kIHVuZGVyLCByZXF1cmllcyByZWdleCBzaGltIHRvIGZpeCBsYXRlclxuXHRcdFx0XHRlbGVtV3JhcHBlci5lbGVtZW50LnNldEF0dHJpYnV0ZSgnaGMtc3ZnLWhyZWYnLCBzcmMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW1XcmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IGEgc3ltYm9sIG91dCBvZiBwcmUtZGVmaW5lZCBzaGFwZSBwYXRocyBmcm9tIHRoZSBuYW1lc3BhY2UgJ3N5bWJvbCcgb2JqZWN0LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB4XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHlcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcmFkaXVzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0XHQgKi9cblx0XHRzeW1ib2w6IGZ1bmN0aW9uIChzeW1ib2wsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcblxuXHRcdFx0dmFyIG9iaixcblxuXHRcdFx0XHQvLyBnZXQgdGhlIHN5bWJvbCBkZWZpbml0aW9uIGZ1bmN0aW9uXG5cdFx0XHRcdHN5bWJvbEZuID0gdGhpcy5zeW1ib2xzW3N5bWJvbF0sXG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlcmUncyBhIHBhdGggZGVmaW5lZCBmb3IgdGhpcyBzeW1ib2xcblx0XHRcdFx0cGF0aCA9IHN5bWJvbEZuICYmIHN5bWJvbEZuKFxuXHRcdFx0XHRcdG1hdGhSb3VuZCh4KSxcblx0XHRcdFx0XHRtYXRoUm91bmQoeSksXG5cdFx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0LFxuXHRcdFx0XHRcdG9wdGlvbnNcblx0XHRcdFx0KSxcblxuXHRcdFx0XHRpbWFnZUVsZW1lbnQsXG5cdFx0XHRcdGltYWdlUmVnZXggPSAvXnVybFxcKCguKj8pXFwpJC8sXG5cdFx0XHRcdGltYWdlU3JjLFxuXHRcdFx0XHRpbWFnZVNpemUsXG5cdFx0XHRcdGNlbnRlckltYWdlO1xuXG5cdFx0XHRpZiAocGF0aCkge1xuXG5cdFx0XHRcdG9iaiA9IHRoaXMucGF0aChwYXRoKTtcblx0XHRcdFx0Ly8gZXhwYW5kbyBwcm9wZXJ0aWVzIGZvciB1c2UgaW4gYW5pbWF0ZSBhbmQgYXR0clxuXHRcdFx0XHRleHRlbmQob2JqLCB7XG5cdFx0XHRcdFx0c3ltYm9sTmFtZTogc3ltYm9sLFxuXHRcdFx0XHRcdHg6IHgsXG5cdFx0XHRcdFx0eTogeSxcblx0XHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHRcdFx0ZXh0ZW5kKG9iaiwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHQvLyBpbWFnZSBzeW1ib2xzXG5cdFx0XHR9IGVsc2UgaWYgKGltYWdlUmVnZXgudGVzdChzeW1ib2wpKSB7XG5cblx0XHRcdFx0Ly8gT24gaW1hZ2UgbG9hZCwgc2V0IHRoZSBzaXplIGFuZCBwb3NpdGlvblxuXHRcdFx0XHRjZW50ZXJJbWFnZSA9IGZ1bmN0aW9uIChpbWcsIHNpemUpIHtcblx0XHRcdFx0XHRpZiAoaW1nLmVsZW1lbnQpIHsgLy8gaXQgbWF5IGJlIGRlc3Ryb3llZCBpbiB0aGUgbWVhbnRpbWUgKCMxMzkwKVxuXHRcdFx0XHRcdFx0aW1nLmF0dHIoe1xuXHRcdFx0XHRcdFx0XHR3aWR0aDogc2l6ZVswXSxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBzaXplWzFdXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCFpbWcuYWxpZ25CeVRyYW5zbGF0ZSkgeyAvLyAjMTg1XG5cdFx0XHRcdFx0XHRcdGltZy50cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKCh3aWR0aCAtIHNpemVbMF0pIC8gMiksIC8vICMxMzc4XG5cdFx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKChoZWlnaHQgLSBzaXplWzFdKSAvIDIpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGltYWdlU3JjID0gc3ltYm9sLm1hdGNoKGltYWdlUmVnZXgpWzFdO1xuXHRcdFx0XHRpbWFnZVNpemUgPSBzeW1ib2xTaXplc1tpbWFnZVNyY10gfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCAmJiBbb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHRdKTtcblxuXHRcdFx0XHQvLyBJcmVhdGUgdGhlIGltYWdlIHN5bmNocm9ub3VzbHksIGFkZCBhdHRyaWJzIGFzeW5jXG5cdFx0XHRcdG9iaiA9IHRoaXMuaW1hZ2UoaW1hZ2VTcmMpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHRcdHk6IHlcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0b2JqLmlzSW1nID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoaW1hZ2VTaXplKSB7XG5cdFx0XHRcdFx0Y2VudGVySW1hZ2Uob2JqLCBpbWFnZVNpemUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEluaXRpYWxpemUgaW1hZ2UgdG8gYmUgMCBzaXplIHNvIGV4cG9ydCB3aWxsIHN0aWxsIGZ1bmN0aW9uIGlmIHRoZXJlJ3Mgbm8gY2FjaGVkIHNpemVzLlxuXHRcdFx0XHRcdG9iai5hdHRyKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBhIGR1bW15IEphdmFTY3JpcHQgaW1hZ2UgdG8gZ2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0LiBEdWUgdG8gYSBidWcgaW4gSUUgPCA4LFxuXHRcdFx0XHRcdC8vIHRoZSBjcmVhdGVkIGVsZW1lbnQgbXVzdCBiZSBhc3NpZ25lZCB0byBhIHZhcmlhYmxlIGluIG9yZGVyIHRvIGxvYWQgKCMyOTIpLlxuXHRcdFx0XHRcdGltYWdlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoJ2ltZycsIHtcblx0XHRcdFx0XHRcdG9ubG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRjZW50ZXJJbWFnZShvYmosIHN5bWJvbFNpemVzW2ltYWdlU3JjXSA9IFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0pO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHNyYzogaW1hZ2VTcmNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBbiBleHRlbmRhYmxlIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIGZvciBkZWZpbmluZyBzeW1ib2wgcGF0aHMuXG5cdFx0ICovXG5cdFx0c3ltYm9sczoge1xuXHRcdFx0J2NpcmNsZSc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG5cdFx0XHRcdHZhciBjcHcgPSAwLjE2NiAqIHc7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0TSwgeCArIHcgLyAyLCB5LFxuXHRcdFx0XHRcdCdDJywgeCArIHcgKyBjcHcsIHksIHggKyB3ICsgY3B3LCB5ICsgaCwgeCArIHcgLyAyLCB5ICsgaCxcblx0XHRcdFx0XHQnQycsIHggLSBjcHcsIHkgKyBoLCB4IC0gY3B3LCB5LCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdFx0J1onXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXG5cdFx0XHQnc3F1YXJlJzogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRNLCB4LCB5LFxuXHRcdFx0XHRcdEwsIHggKyB3LCB5LFxuXHRcdFx0XHRcdHggKyB3LCB5ICsgaCxcblx0XHRcdFx0XHR4LCB5ICsgaCxcblx0XHRcdFx0XHQnWidcblx0XHRcdFx0XTtcblx0XHRcdH0sXG5cblx0XHRcdCd0cmlhbmdsZSc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0TSwgeCArIHcgLyAyLCB5LFxuXHRcdFx0XHRcdEwsIHggKyB3LCB5ICsgaCxcblx0XHRcdFx0XHR4LCB5ICsgaCxcblx0XHRcdFx0XHQnWidcblx0XHRcdFx0XTtcblx0XHRcdH0sXG5cblx0XHRcdCd0cmlhbmdsZS1kb3duJzogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRNLCB4LCB5LFxuXHRcdFx0XHRcdEwsIHggKyB3LCB5LFxuXHRcdFx0XHRcdHggKyB3IC8gMiwgeSArIGgsXG5cdFx0XHRcdFx0J1onXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0J2RpYW1vbmQnOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdE0sIHggKyB3IC8gMiwgeSxcblx0XHRcdFx0XHRMLCB4ICsgdywgeSArIGggLyAyLFxuXHRcdFx0XHRcdHggKyB3IC8gMiwgeSArIGgsXG5cdFx0XHRcdFx0eCwgeSArIGggLyAyLFxuXHRcdFx0XHRcdCdaJ1xuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblx0XHRcdCdhcmMnOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0LFxuXHRcdFx0XHRcdHJhZGl1cyA9IG9wdGlvbnMuciB8fCB3IHx8IGgsXG5cdFx0XHRcdFx0ZW5kID0gb3B0aW9ucy5lbmQgLSAwLjAwMSwgLy8gdG8gcHJldmVudCBjb3MgYW5kIHNpbiBvZiBzdGFydCBhbmQgZW5kIGZyb20gYmVjb21pbmcgZXF1YWwgb24gMzYwIGFyY3MgKHJlbGF0ZWQ6ICMxNTYxKVxuXHRcdFx0XHRcdGlubmVyUmFkaXVzID0gb3B0aW9ucy5pbm5lclIsXG5cdFx0XHRcdFx0b3BlbiA9IG9wdGlvbnMub3Blbixcblx0XHRcdFx0XHRjb3NTdGFydCA9IG1hdGhDb3Moc3RhcnQpLFxuXHRcdFx0XHRcdHNpblN0YXJ0ID0gbWF0aFNpbihzdGFydCksXG5cdFx0XHRcdFx0Y29zRW5kID0gbWF0aENvcyhlbmQpLFxuXHRcdFx0XHRcdHNpbkVuZCA9IG1hdGhTaW4oZW5kKSxcblx0XHRcdFx0XHRsb25nQXJjID0gb3B0aW9ucy5lbmQgLSBzdGFydCA8IG1hdGhQSSA/IDAgOiAxO1xuXG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0TSxcblx0XHRcdFx0XHR4ICsgcmFkaXVzICogY29zU3RhcnQsXG5cdFx0XHRcdFx0eSArIHJhZGl1cyAqIHNpblN0YXJ0LFxuXHRcdFx0XHRcdCdBJywgLy8gYXJjVG9cblx0XHRcdFx0XHRyYWRpdXMsIC8vIHggcmFkaXVzXG5cdFx0XHRcdFx0cmFkaXVzLCAvLyB5IHJhZGl1c1xuXHRcdFx0XHRcdDAsIC8vIHNsYW50aW5nXG5cdFx0XHRcdFx0bG9uZ0FyYywgLy8gbG9uZyBvciBzaG9ydCBhcmNcblx0XHRcdFx0XHQxLCAvLyBjbG9ja3dpc2Vcblx0XHRcdFx0XHR4ICsgcmFkaXVzICogY29zRW5kLFxuXHRcdFx0XHRcdHkgKyByYWRpdXMgKiBzaW5FbmQsXG5cdFx0XHRcdFx0b3BlbiA/IE0gOiBMLFxuXHRcdFx0XHRcdHggKyBpbm5lclJhZGl1cyAqIGNvc0VuZCxcblx0XHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5FbmQsXG5cdFx0XHRcdFx0J0EnLCAvLyBhcmNUb1xuXHRcdFx0XHRcdGlubmVyUmFkaXVzLCAvLyB4IHJhZGl1c1xuXHRcdFx0XHRcdGlubmVyUmFkaXVzLCAvLyB5IHJhZGl1c1xuXHRcdFx0XHRcdDAsIC8vIHNsYW50aW5nXG5cdFx0XHRcdFx0bG9uZ0FyYywgLy8gbG9uZyBvciBzaG9ydCBhcmNcblx0XHRcdFx0XHQwLCAvLyBjbG9ja3dpc2Vcblx0XHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMgKiBjb3NTdGFydCxcblx0XHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5TdGFydCxcblxuXHRcdFx0XHRcdG9wZW4gPyAnJyA6ICdaJyAvLyBjbG9zZVxuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDYWxsb3V0IHNoYXBlIHVzZWQgZm9yIGRlZmF1bHQgdG9vbHRpcHMsIGFsc28gdXNlZCBmb3Igcm91bmRlZCByZWN0YW5nbGVzIGluIFZNTFxuXHRcdFx0ICovXG5cdFx0XHRjYWxsb3V0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgYXJyb3dMZW5ndGggPSA2LFxuXHRcdFx0XHRcdGhhbGZEaXN0YW5jZSA9IDYsXG5cdFx0XHRcdFx0ciA9IG1hdGhNaW4oKG9wdGlvbnMgJiYgb3B0aW9ucy5yKSB8fCAwLCB3LCBoKSxcblx0XHRcdFx0XHRzYWZlRGlzdGFuY2UgPSByICsgaGFsZkRpc3RhbmNlLFxuXHRcdFx0XHRcdGFuY2hvclggPSBvcHRpb25zICYmIG9wdGlvbnMuYW5jaG9yWCxcblx0XHRcdFx0XHRhbmNob3JZID0gb3B0aW9ucyAmJiBvcHRpb25zLmFuY2hvclksXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHRub3JtYWxpemVyID0gbWF0aFJvdW5kKG9wdGlvbnMuc3Ryb2tlV2lkdGggfHwgMCkgJSAyIC8gMjsgLy8gbWF0aFJvdW5kIGJlY2F1c2Ugc3Ryb2tlV2lkdGggY2FuIHNvbWV0aW1lcyBoYXZlIHJvdW5kb2ZmIGVycm9ycztcblxuXHRcdFx0XHR4ICs9IG5vcm1hbGl6ZXI7XG5cdFx0XHRcdHkgKz0gbm9ybWFsaXplcjtcblx0XHRcdFx0cGF0aCA9IFtcblx0XHRcdFx0XHQnTScsIHggKyByLCB5LCBcblx0XHRcdFx0XHQnTCcsIHggKyB3IC0gciwgeSwgLy8gdG9wIHNpZGVcblx0XHRcdFx0XHQnQycsIHggKyB3LCB5LCB4ICsgdywgeSwgeCArIHcsIHkgKyByLCAvLyB0b3AtcmlnaHQgY29ybmVyXG5cdFx0XHRcdFx0J0wnLCB4ICsgdywgeSArIGggLSByLCAvLyByaWdodCBzaWRlXG5cdFx0XHRcdFx0J0MnLCB4ICsgdywgeSArIGgsIHggKyB3LCB5ICsgaCwgeCArIHcgLSByLCB5ICsgaCwgLy8gYm90dG9tLXJpZ2h0IGNvcm5lclxuXHRcdFx0XHRcdCdMJywgeCArIHIsIHkgKyBoLCAvLyBib3R0b20gc2lkZVxuXHRcdFx0XHRcdCdDJywgeCwgeSArIGgsIHgsIHkgKyBoLCB4LCB5ICsgaCAtIHIsIC8vIGJvdHRvbS1sZWZ0IGNvcm5lclxuXHRcdFx0XHRcdCdMJywgeCwgeSArIHIsIC8vIGxlZnQgc2lkZVxuXHRcdFx0XHRcdCdDJywgeCwgeSwgeCwgeSwgeCArIHIsIHkgLy8gdG9wLXJpZ2h0IGNvcm5lclxuXHRcdFx0XHRdO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGFuY2hvclggJiYgYW5jaG9yWCA+IHcgJiYgYW5jaG9yWSA+IHkgKyBzYWZlRGlzdGFuY2UgJiYgYW5jaG9yWSA8IHkgKyBoIC0gc2FmZURpc3RhbmNlKSB7IC8vIHJlcGxhY2UgcmlnaHQgc2lkZVxuXHRcdFx0XHRcdHBhdGguc3BsaWNlKDEzLCAzLFxuXHRcdFx0XHRcdFx0J0wnLCB4ICsgdywgYW5jaG9yWSAtIGhhbGZEaXN0YW5jZSwgXG5cdFx0XHRcdFx0XHR4ICsgdyArIGFycm93TGVuZ3RoLCBhbmNob3JZLFxuXHRcdFx0XHRcdFx0eCArIHcsIGFuY2hvclkgKyBoYWxmRGlzdGFuY2UsXG5cdFx0XHRcdFx0XHR4ICsgdywgeSArIGggLSByXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChhbmNob3JYICYmIGFuY2hvclggPCAwICYmIGFuY2hvclkgPiB5ICsgc2FmZURpc3RhbmNlICYmIGFuY2hvclkgPCB5ICsgaCAtIHNhZmVEaXN0YW5jZSkgeyAvLyByZXBsYWNlIGxlZnQgc2lkZVxuXHRcdFx0XHRcdHBhdGguc3BsaWNlKDMzLCAzLCBcblx0XHRcdFx0XHRcdCdMJywgeCwgYW5jaG9yWSArIGhhbGZEaXN0YW5jZSwgXG5cdFx0XHRcdFx0XHR4IC0gYXJyb3dMZW5ndGgsIGFuY2hvclksXG5cdFx0XHRcdFx0XHR4LCBhbmNob3JZIC0gaGFsZkRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0eCwgeSArIHJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFuY2hvclkgJiYgYW5jaG9yWSA+IGggJiYgYW5jaG9yWCA+IHggKyBzYWZlRGlzdGFuY2UgJiYgYW5jaG9yWCA8IHggKyB3IC0gc2FmZURpc3RhbmNlKSB7IC8vIHJlcGxhY2UgYm90dG9tXG5cdFx0XHRcdFx0cGF0aC5zcGxpY2UoMjMsIDMsXG5cdFx0XHRcdFx0XHQnTCcsIGFuY2hvclggKyBoYWxmRGlzdGFuY2UsIHkgKyBoLFxuXHRcdFx0XHRcdFx0YW5jaG9yWCwgeSArIGggKyBhcnJvd0xlbmd0aCxcblx0XHRcdFx0XHRcdGFuY2hvclggLSBoYWxmRGlzdGFuY2UsIHkgKyBoLFxuXHRcdFx0XHRcdFx0eCArIHIsIHkgKyBoXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChhbmNob3JZICYmIGFuY2hvclkgPCAwICYmIGFuY2hvclggPiB4ICsgc2FmZURpc3RhbmNlICYmIGFuY2hvclggPCB4ICsgdyAtIHNhZmVEaXN0YW5jZSkgeyAvLyByZXBsYWNlIHRvcFxuXHRcdFx0XHRcdHBhdGguc3BsaWNlKDMsIDMsXG5cdFx0XHRcdFx0XHQnTCcsIGFuY2hvclggLSBoYWxmRGlzdGFuY2UsIHksXG5cdFx0XHRcdFx0XHRhbmNob3JYLCB5IC0gYXJyb3dMZW5ndGgsXG5cdFx0XHRcdFx0XHRhbmNob3JYICsgaGFsZkRpc3RhbmNlLCB5LFxuXHRcdFx0XHRcdFx0dyAtIHIsIHlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXRoO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZWZpbmUgYSBjbGlwcGluZyByZWN0YW5nbGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaWRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHRcdCAqL1xuXHRcdGNsaXBSZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0dmFyIHdyYXBwZXIsXG5cdFx0XHRcdGlkID0gUFJFRklYICsgaWRDb3VudGVyKyssXG5cblx0XHRcdFx0Y2xpcFBhdGggPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2NsaXBQYXRoJykuYXR0cih7XG5cdFx0XHRcdFx0aWQ6IGlkXG5cdFx0XHRcdH0pLmFkZCh0aGlzLmRlZnMpO1xuXG5cdFx0XHR3cmFwcGVyID0gdGhpcy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIDApLmFkZChjbGlwUGF0aCk7XG5cdFx0XHR3cmFwcGVyLmlkID0gaWQ7XG5cdFx0XHR3cmFwcGVyLmNsaXBQYXRoID0gY2xpcFBhdGg7XG5cdFx0XHR3cmFwcGVyLmNvdW50ID0gMDtcblxuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fSxcblxuXG5cdFx0XG5cblxuXHRcdC8qKlxuXHRcdCAqIEFkZCB0ZXh0IHRvIHRoZSBTVkcgb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4IExlZnQgcG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge051bWJlcn0geSBUb3AgcG9zaXRpb25cblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZUhUTUwgVXNlIEhUTUwgdG8gcmVuZGVyIHRoZSB0ZXh0XG5cdFx0ICovXG5cdFx0dGV4dDogZnVuY3Rpb24gKHN0ciwgeCwgeSwgdXNlSFRNTCkge1xuXG5cdFx0XHQvLyBkZWNsYXJlIHZhcmlhYmxlc1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdFx0ZmFrZVNWRyA9IHVzZUNhblZHIHx8ICghaGFzU1ZHICYmIHJlbmRlcmVyLmZvckV4cG9ydCksXG5cdFx0XHRcdHdyYXBwZXIsXG5cdFx0XHRcdGF0dHIgPSB7fTtcblxuXHRcdFx0aWYgKHVzZUhUTUwgJiYgIXJlbmRlcmVyLmZvckV4cG9ydCkge1xuXHRcdFx0XHRyZXR1cm4gcmVuZGVyZXIuaHRtbChzdHIsIHgsIHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRhdHRyLnggPSBNYXRoLnJvdW5kKHggfHwgMCk7IC8vIFggaXMgYWx3YXlzIG5lZWRlZCBmb3IgbGluZS13cmFwIGxvZ2ljXG5cdFx0XHRpZiAoeSkge1xuXHRcdFx0XHRhdHRyLnkgPSBNYXRoLnJvdW5kKHkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0ciB8fCBzdHIgPT09IDApIHtcblx0XHRcdFx0YXR0ci50ZXh0ID0gc3RyO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwcGVyID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudCgndGV4dCcpXG5cdFx0XHRcdC5hdHRyKGF0dHIpO1xuXG5cdFx0XHQvLyBQcmV2ZW50IHdyYXBwaW5nIGZyb20gY3JlYXRpbmcgZmFsc2Ugb2Zmc2V0V2lkdGhzIGluIGV4cG9ydCBpbiBsZWdhY3kgSUUgKCMxMDc5LCAjMTA2Mylcblx0XHRcdGlmIChmYWtlU1ZHKSB7XG5cdFx0XHRcdHdyYXBwZXIuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogQUJTT0xVVEVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdXNlSFRNTCkge1xuXHRcdFx0XHR3cmFwcGVyLnhTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciB0c3BhbnMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0c3BhbicpLFxuXHRcdFx0XHRcdFx0dHNwYW4sXG5cdFx0XHRcdFx0XHRwYXJlbnRWYWwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShrZXkpLFxuXHRcdFx0XHRcdFx0aTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdHNwYW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0c3BhbiA9IHRzcGFuc1tpXTtcblx0XHRcdFx0XHRcdC8vIElmIHRoZSB4IHZhbHVlcyBhcmUgZXF1YWwsIHRoZSB0c3BhbiByZXByZXNlbnRzIGEgbGluZWJyZWFrXG5cdFx0XHRcdFx0XHRpZiAodHNwYW4uZ2V0QXR0cmlidXRlKGtleSkgPT09IHBhcmVudFZhbCkge1xuXHRcdFx0XHRcdFx0XHR0c3Bhbi5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXRpbGl0eSB0byByZXR1cm4gdGhlIGJhc2VsaW5lIG9mZnNldCBhbmQgdG90YWwgbGluZSBoZWlnaHQgZnJvbSB0aGUgZm9udCBzaXplXG5cdFx0ICovXG5cdFx0Zm9udE1ldHJpY3M6IGZ1bmN0aW9uIChmb250U2l6ZSwgZWxlbSkge1xuXHRcdFx0Zm9udFNpemUgPSBmb250U2l6ZSB8fCB0aGlzLnN0eWxlLmZvbnRTaXplO1xuXHRcdFx0aWYgKGVsZW0gJiYgd2luLmdldENvbXB1dGVkU3R5bGUpIHtcblx0XHRcdFx0ZWxlbSA9IGVsZW0uZWxlbWVudCB8fCBlbGVtOyAvLyBTVkdFbGVtZW50XG5cdFx0XHRcdGZvbnRTaXplID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbSwgXCJcIikuZm9udFNpemU7XG5cdFx0XHR9XG5cdFx0XHRmb250U2l6ZSA9IC9weC8udGVzdChmb250U2l6ZSkgPyBwSW50KGZvbnRTaXplKSA6IC9lbS8udGVzdChmb250U2l6ZSkgPyBwYXJzZUZsb2F0KGZvbnRTaXplKSAqIDEyIDogMTI7XG5cblx0XHRcdC8vIEVtcGlyaWNhbCB2YWx1ZXMgZm91bmQgYnkgY29tcGFyaW5nIGZvbnQgc2l6ZSBhbmQgYm91bmRpbmcgYm94IGhlaWdodC5cblx0XHRcdC8vIEFwcGxpZXMgdG8gdGhlIGRlZmF1bHQgZm9udCBmYW1pbHkuIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvaGlnaGNoYXJ0cy83eHZuNy9cblx0XHRcdHZhciBsaW5lSGVpZ2h0ID0gZm9udFNpemUgPCAyNCA/IGZvbnRTaXplICsgMyA6IG1hdGhSb3VuZChmb250U2l6ZSAqIDEuMiksXG5cdFx0XHRcdGJhc2VsaW5lID0gbWF0aFJvdW5kKGxpbmVIZWlnaHQgKiAwLjgpO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRoOiBsaW5lSGVpZ2h0LFxuXHRcdFx0XHRiOiBiYXNlbGluZSxcblx0XHRcdFx0ZjogZm9udFNpemVcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvcnJlY3QgWCBhbmQgWSBwb3NpdGlvbmluZyBvZiBhIGxhYmVsIGZvciByb3RhdGlvbiAoIzE3NjQpXG5cdFx0ICovXG5cdFx0cm90Q29ycjogZnVuY3Rpb24gKGJhc2VsaW5lLCByb3RhdGlvbiwgYWx0ZXJZKSB7XG5cdFx0XHR2YXIgeSA9IGJhc2VsaW5lO1xuXHRcdFx0aWYgKHJvdGF0aW9uICYmIGFsdGVyWSkge1xuXHRcdFx0XHR5ID0gbWF0aE1heCh5ICogbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpLCA0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6ICgtYmFzZWxpbmUgLyAzKSAqIG1hdGhTaW4ocm90YXRpb24gKiBkZWcycmFkKSxcblx0XHRcdFx0eTogeVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgbGFiZWwsIGEgdGV4dCBpdGVtIHRoYXQgY2FuIGhvbGQgYSBjb2xvcmVkIG9yIGdyYWRpZW50IGJhY2tncm91bmRcblx0XHQgKiBhcyB3ZWxsIGFzIGEgYm9yZGVyIGFuZCBzaGFkb3cuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc2hhcGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYW5jaG9yWCBJbiBjYXNlIHRoZSBzaGFwZSBoYXMgYSBwb2ludGVyLCBsaWtlIGEgZmxhZywgdGhpcyBpcyB0aGVcblx0XHQgKlx0Y29vcmRpbmF0ZXMgaXQgc2hvdWxkIGJlIHBpbm5lZCB0b1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmNob3JZXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBiYXNlbGluZSBXaGV0aGVyIHRvIHBvc2l0aW9uIHRoZSBsYWJlbCByZWxhdGl2ZSB0byB0aGUgdGV4dCBiYXNlbGluZSxcblx0XHQgKlx0bGlrZSByZW5kZXJlci50ZXh0LCBvciB0byB0aGUgdXBwZXIgYm9yZGVyIG9mIHRoZSByZWN0YW5nbGUuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyBuYW1lIGZvciB0aGUgZ3JvdXBcblx0XHQgKi9cblx0XHRsYWJlbDogZnVuY3Rpb24gKHN0ciwgeCwgeSwgc2hhcGUsIGFuY2hvclgsIGFuY2hvclksIHVzZUhUTUwsIGJhc2VsaW5lLCBjbGFzc05hbWUpIHtcblxuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdFx0d3JhcHBlciA9IHJlbmRlcmVyLmcoY2xhc3NOYW1lKSxcblx0XHRcdFx0dGV4dCA9IHJlbmRlcmVyLnRleHQoJycsIDAsIDAsIHVzZUhUTUwpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0ekluZGV4OiAxXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0Ly8uYWRkKHdyYXBwZXIpLFxuXHRcdFx0XHRib3gsXG5cdFx0XHRcdGJCb3gsXG5cdFx0XHRcdGFsaWduRmFjdG9yID0gMCxcblx0XHRcdFx0cGFkZGluZyA9IDMsXG5cdFx0XHRcdHBhZGRpbmdMZWZ0ID0gMCxcblx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdGhlaWdodCxcblx0XHRcdFx0d3JhcHBlclgsXG5cdFx0XHRcdHdyYXBwZXJZLFxuXHRcdFx0XHRjcmlzcEFkanVzdCA9IDAsXG5cdFx0XHRcdGRlZmVycmVkQXR0ciA9IHt9LFxuXHRcdFx0XHRiYXNlbGluZU9mZnNldCxcblx0XHRcdFx0bmVlZHNCb3g7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBmdW5jdGlvbiBydW5zIGFmdGVyIHRoZSBsYWJlbCBpcyBhZGRlZCB0byB0aGUgRE9NICh3aGVuIHRoZSBib3VuZGluZyBib3ggaXNcblx0XHRcdCAqIGF2YWlsYWJsZSksIGFuZCBhZnRlciB0aGUgdGV4dCBvZiB0aGUgbGFiZWwgaXMgdXBkYXRlZCB0byBkZXRlY3QgdGhlIG5ldyBib3VuZGluZ1xuXHRcdFx0ICogYm94IGFuZCByZWZsZWN0IGl0IGluIHRoZSBib3JkZXIgYm94LlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGVCb3hTaXplKCkge1xuXHRcdFx0XHR2YXIgYm94WCxcblx0XHRcdFx0XHRib3hZLFxuXHRcdFx0XHRcdHN0eWxlID0gdGV4dC5lbGVtZW50LnN0eWxlO1xuXG5cdFx0XHRcdGJCb3ggPSAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IHVuZGVmaW5lZCB8fCB3cmFwcGVyLnN0eWxlcy50ZXh0QWxpZ24pICYmIGRlZmluZWQodGV4dC50ZXh0U3RyKSAmJiBcblx0XHRcdFx0XHR0ZXh0LmdldEJCb3goKTsgLy8jMzI5NSAmJiAzNTE0IGJveCBmYWlsdXJlIHdoZW4gc3RyaW5nIGVxdWFscyAwXG5cdFx0XHRcdHdyYXBwZXIud2lkdGggPSAod2lkdGggfHwgYkJveC53aWR0aCB8fCAwKSArIDIgKiBwYWRkaW5nICsgcGFkZGluZ0xlZnQ7XG5cdFx0XHRcdHdyYXBwZXIuaGVpZ2h0ID0gKGhlaWdodCB8fCBiQm94LmhlaWdodCB8fCAwKSArIDIgKiBwYWRkaW5nO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgbGFiZWwtc2NvcGVkIHkgb2Zmc2V0XG5cdFx0XHRcdGJhc2VsaW5lT2Zmc2V0ID0gcGFkZGluZyArIHJlbmRlcmVyLmZvbnRNZXRyaWNzKHN0eWxlICYmIHN0eWxlLmZvbnRTaXplLCB0ZXh0KS5iO1xuXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobmVlZHNCb3gpIHtcblxuXHRcdFx0XHRcdC8vIGNyZWF0ZSB0aGUgYm9yZGVyIGJveCBpZiBpdCBpcyBub3QgYWxyZWFkeSBwcmVzZW50XG5cdFx0XHRcdFx0aWYgKCFib3gpIHtcblx0XHRcdFx0XHRcdGJveFggPSBtYXRoUm91bmQoLWFsaWduRmFjdG9yICogcGFkZGluZyk7XG5cdFx0XHRcdFx0XHRib3hZID0gYmFzZWxpbmUgPyAtYmFzZWxpbmVPZmZzZXQgOiAwO1xuXG5cdFx0XHRcdFx0XHR3cmFwcGVyLmJveCA9IGJveCA9IHNoYXBlID9cblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc3ltYm9sKHNoYXBlLCBib3hYLCBib3hZLCB3cmFwcGVyLndpZHRoLCB3cmFwcGVyLmhlaWdodCwgZGVmZXJyZWRBdHRyKSA6XG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnJlY3QoYm94WCwgYm94WSwgd3JhcHBlci53aWR0aCwgd3JhcHBlci5oZWlnaHQsIDAsIGRlZmVycmVkQXR0cltTVFJPS0VfV0lEVEhdKTtcblx0XHRcdFx0XHRcdGJveC5hdHRyKCdmaWxsJywgTk9ORSkuYWRkKHdyYXBwZXIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGFwcGx5IHRoZSBib3ggYXR0cmlidXRlc1xuXHRcdFx0XHRcdGlmICghYm94LmlzSW1nKSB7IC8vICMxNjMwXG5cdFx0XHRcdFx0XHRib3guYXR0cihleHRlbmQoe1xuXHRcdFx0XHRcdFx0XHR3aWR0aDogbWF0aFJvdW5kKHdyYXBwZXIud2lkdGgpLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IG1hdGhSb3VuZCh3cmFwcGVyLmhlaWdodClcblx0XHRcdFx0XHRcdH0sIGRlZmVycmVkQXR0cikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWZlcnJlZEF0dHIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhpcyBmdW5jdGlvbiBydW5zIGFmdGVyIHNldHRpbmcgdGV4dCBvciBwYWRkaW5nLCBidXQgb25seSBpZiBwYWRkaW5nIGlzIGNoYW5nZWRcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlVGV4dFBhZGRpbmcoKSB7XG5cdFx0XHRcdHZhciBzdHlsZXMgPSB3cmFwcGVyLnN0eWxlcyxcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSBzdHlsZXMgJiYgc3R5bGVzLnRleHRBbGlnbixcblx0XHRcdFx0XHR4ID0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nICogKDEgLSBhbGlnbkZhY3RvciksXG5cdFx0XHRcdFx0eTtcblxuXHRcdFx0XHQvLyBkZXRlcm1pbiB5IGJhc2VkIG9uIHRoZSBiYXNlbGluZVxuXHRcdFx0XHR5ID0gYmFzZWxpbmUgPyAwIDogYmFzZWxpbmVPZmZzZXQ7XG5cblx0XHRcdFx0Ly8gY29tcGVuc2F0ZSBmb3IgYWxpZ25tZW50XG5cdFx0XHRcdGlmIChkZWZpbmVkKHdpZHRoKSAmJiBiQm94ICYmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInIHx8IHRleHRBbGlnbiA9PT0gJ3JpZ2h0JykpIHtcblx0XHRcdFx0XHR4ICs9IHsgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bdGV4dEFsaWduXSAqICh3aWR0aCAtIGJCb3gud2lkdGgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXBkYXRlIGlmIGFueXRoaW5nIGNoYW5nZWRcblx0XHRcdFx0aWYgKHggIT09IHRleHQueCB8fCB5ICE9PSB0ZXh0LnkpIHtcblx0XHRcdFx0XHR0ZXh0LmF0dHIoJ3gnLCB4KTtcblx0XHRcdFx0XHRpZiAoeSAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHQvLyBBcyBhIHdvcmthcm91bmQgZm9yICMzNjQ5LCB1c2UgdHJhbnNsYXRpb24gaW5zdGVhZCBvZiB5IGF0dHJpYnV0ZS4gIzM2NDlcblx0XHRcdFx0XHRcdC8vIGlzIGEgcmVuZGVyaW5nIGJ1ZyBpbiBXZWJLaXQgZm9yIFJldGluYSAoTWFjLCBpT1MsIFBoYW50b21KUykgdGhhdCBcblx0XHRcdFx0XHRcdC8vIHJlc3VsdHMgaW4gZHVwbGljYXRlZCB0ZXh0IHdoZW4gYW4geSBhdHRyaWJ1dGUgaXMgdXNlZCBpbiBjb21iaW5hdGlvbiBcblx0XHRcdFx0XHRcdC8vIHdpdGggYSBDU1MgdGV4dC1zdHlsZS5cblx0XHRcdFx0XHRcdHRleHQuYXR0cih0ZXh0LmVsZW1lbnQubm9kZU5hbWUgPT09ICdTUEFOJyA/ICd5JyA6ICd0cmFuc2xhdGVZJywgeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVjb3JkIGN1cnJlbnQgdmFsdWVzXG5cdFx0XHRcdHRleHQueCA9IHg7XG5cdFx0XHRcdHRleHQueSA9IHk7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0IGEgYm94IGF0dHJpYnV0ZSwgb3IgZGVmZXIgaXQgaWYgdGhlIGJveCBpcyBub3QgeWV0IGNyZWF0ZWRcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBib3hBdHRyKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRcdGJveC5hdHRyKGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkQXR0cltrZXldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZnRlciB0aGUgdGV4dCBlbGVtZW50IGlzIGFkZGVkLCBnZXQgdGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgYm9yZGVyIGJveFxuXHRcdFx0ICogYW5kIGFkZCBpdCBiZWZvcmUgdGhlIHRleHQgaW4gdGhlIERPTS5cblx0XHRcdCAqL1xuXHRcdFx0d3JhcHBlci5vbkFkZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGV4dC5hZGQod3JhcHBlcik7XG5cdFx0XHRcdHdyYXBwZXIuYXR0cih7XG5cdFx0XHRcdFx0dGV4dDogKHN0ciB8fCBzdHIgPT09IDApID8gc3RyIDogJycsIC8vIGFsaWdubWVudCBpcyBhdmFpbGFibGUgbm93IC8vICMzMjk1OiAwIG5vdCByZW5kZXJlZCBpZiBnaXZlbiBhcyBhIHZhbHVlXG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChib3ggJiYgZGVmaW5lZChhbmNob3JYKSkge1xuXHRcdFx0XHRcdHdyYXBwZXIuYXR0cih7XG5cdFx0XHRcdFx0XHRhbmNob3JYOiBhbmNob3JYLFxuXHRcdFx0XHRcdFx0YW5jaG9yWTogYW5jaG9yWVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvKlxuXHRcdFx0ICogQWRkIHNwZWNpZmljIGF0dHJpYnV0ZSBzZXR0ZXJzLlxuXHRcdFx0ICovXG5cblx0XHRcdC8vIG9ubHkgY2hhbmdlIGxvY2FsIHZhcmlhYmxlc1xuXHRcdFx0d3JhcHBlci53aWR0aFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHR3aWR0aCA9IHZhbHVlO1xuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIuaGVpZ2h0U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGhlaWdodCA9IHZhbHVlO1xuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIucGFkZGluZ1NldHRlciA9ICBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0aWYgKGRlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSBwYWRkaW5nKSB7XG5cdFx0XHRcdFx0cGFkZGluZyA9IHdyYXBwZXIucGFkZGluZyA9IHZhbHVlO1xuXHRcdFx0XHRcdHVwZGF0ZVRleHRQYWRkaW5nKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLnBhZGRpbmdMZWZ0U2V0dGVyID0gIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAoZGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IHBhZGRpbmdMZWZ0KSB7XG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR1cGRhdGVUZXh0UGFkZGluZygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cblx0XHRcdC8vIGNoYW5nZSBsb2NhbCB2YXJpYWJsZSBhbmQgcHJldmVudCBzZXR0aW5nIGF0dHJpYnV0ZSBvbiB0aGUgZ3JvdXBcblx0XHRcdHdyYXBwZXIuYWxpZ25TZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0YWxpZ25GYWN0b3IgPSB7IGxlZnQ6IDAsIGNlbnRlcjogMC41LCByaWdodDogMSB9W3ZhbHVlXTtcblx0XHRcdH07XG5cblx0XHRcdC8vIGFwcGx5IHRoZXNlIHRvIHRoZSBib3ggYW5kIHRoZSB0ZXh0IGFsaWtlXG5cdFx0XHR3cmFwcGVyLnRleHRTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0aWYgKHZhbHVlICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHR0ZXh0LnRleHRTZXR0ZXIodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHVwZGF0ZUJveFNpemUoKTtcblx0XHRcdFx0dXBkYXRlVGV4dFBhZGRpbmcoKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIGFwcGx5IHRoZXNlIHRvIHRoZSBib3ggYnV0IG5vdCB0byB0aGUgdGV4dFxuXHRcdFx0d3JhcHBlclsnc3Ryb2tlLXdpZHRoU2V0dGVyJ10gPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRuZWVkc0JveCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3Jpc3BBZGp1c3QgPSB2YWx1ZSAlIDIgLyAyO1xuXHRcdFx0XHRib3hBdHRyKGtleSwgdmFsdWUpO1xuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIuc3Ryb2tlU2V0dGVyID0gd3JhcHBlci5maWxsU2V0dGVyID0gd3JhcHBlci5yU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gJ2ZpbGwnICYmIHZhbHVlKSB7XG5cdFx0XHRcdFx0bmVlZHNCb3ggPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJveEF0dHIoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5hbmNob3JYU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0YW5jaG9yWCA9IHZhbHVlO1xuXHRcdFx0XHRib3hBdHRyKGtleSwgdmFsdWUgKyBjcmlzcEFkanVzdCAtIHdyYXBwZXJYKTtcblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLmFuY2hvcllTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRhbmNob3JZID0gdmFsdWU7XG5cdFx0XHRcdGJveEF0dHIoa2V5LCB2YWx1ZSAtIHdyYXBwZXJZKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIHJlbmFtZSBhdHRyaWJ1dGVzXG5cdFx0XHR3cmFwcGVyLnhTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0d3JhcHBlci54ID0gdmFsdWU7IC8vIGZvciBhbmltYXRpb24gZ2V0dGVyXG5cdFx0XHRcdGlmIChhbGlnbkZhY3Rvcikge1xuXHRcdFx0XHRcdHZhbHVlIC09IGFsaWduRmFjdG9yICogKCh3aWR0aCB8fCBiQm94LndpZHRoKSArIHBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdyYXBwZXJYID0gbWF0aFJvdW5kKHZhbHVlKTtcblx0XHRcdFx0d3JhcHBlci5hdHRyKCd0cmFuc2xhdGVYJywgd3JhcHBlclgpO1xuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIueVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHR3cmFwcGVyWSA9IHdyYXBwZXIueSA9IG1hdGhSb3VuZCh2YWx1ZSk7XG5cdFx0XHRcdHdyYXBwZXIuYXR0cigndHJhbnNsYXRlWScsIHdyYXBwZXJZKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIFJlZGlyZWN0IGNlcnRhaW4gbWV0aG9kcyB0byBlaXRoZXIgdGhlIGJveCBvciB0aGUgdGV4dFxuXHRcdFx0dmFyIGJhc2VDc3MgPSB3cmFwcGVyLmNzcztcblx0XHRcdHJldHVybiBleHRlbmQod3JhcHBlciwge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogUGljayB1cCBzb21lIHByb3BlcnRpZXMgYW5kIGFwcGx5IHRoZW0gdG8gdGhlIHRleHQgaW5zdGVhZCBvZiB0aGUgd3JhcHBlclxuXHRcdFx0XHQgKi9cblx0XHRcdFx0Y3NzOiBmdW5jdGlvbiAoc3R5bGVzKSB7XG5cdFx0XHRcdFx0aWYgKHN0eWxlcykge1xuXHRcdFx0XHRcdFx0dmFyIHRleHRTdHlsZXMgPSB7fTtcblx0XHRcdFx0XHRcdHN0eWxlcyA9IG1lcmdlKHN0eWxlcyk7IC8vIGNyZWF0ZSBhIGNvcHkgdG8gYXZvaWQgYWx0ZXJpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCAoIzUzNylcblx0XHRcdFx0XHRcdGVhY2god3JhcHBlci50ZXh0UHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzdHlsZXNbcHJvcF0gIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHRcdHRleHRTdHlsZXNbcHJvcF0gPSBzdHlsZXNbcHJvcF07XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIHN0eWxlc1twcm9wXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR0ZXh0LmNzcyh0ZXh0U3R5bGVzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGJhc2VDc3MuY2FsbCh3cmFwcGVyLCBzdHlsZXMpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogUmV0dXJuIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGJveCwgbm90IHRoZSBncm91cFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0Z2V0QkJveDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR3aWR0aDogYkJveC53aWR0aCArIDIgKiBwYWRkaW5nLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBiQm94LmhlaWdodCArIDIgKiBwYWRkaW5nLFxuXHRcdFx0XHRcdFx0eDogYkJveC54IC0gcGFkZGluZyxcblx0XHRcdFx0XHRcdHk6IGJCb3gueSAtIHBhZGRpbmdcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQXBwbHkgdGhlIHNoYWRvdyB0byB0aGUgYm94XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRzaGFkb3c6IGZ1bmN0aW9uIChiKSB7XG5cdFx0XHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRcdFx0Ym94LnNoYWRvdyhiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBEZXN0cm95IGFuZCByZWxlYXNlIG1lbW9yeS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdC8vIEFkZGVkIGJ5IGJ1dHRvbiBpbXBsZW1lbnRhdGlvblxuXHRcdFx0XHRcdHJlbW92ZUV2ZW50KHdyYXBwZXIuZWxlbWVudCwgJ21vdXNlZW50ZXInKTtcblx0XHRcdFx0XHRyZW1vdmVFdmVudCh3cmFwcGVyLmVsZW1lbnQsICdtb3VzZWxlYXZlJyk7XG5cblx0XHRcdFx0XHRpZiAodGV4dCkge1xuXHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoYm94KSB7XG5cdFx0XHRcdFx0XHRib3ggPSBib3guZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBDYWxsIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gZGVzdHJveSB0aGUgcmVzdFxuXHRcdFx0XHRcdFNWR0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh3cmFwcGVyKTtcblxuXHRcdFx0XHRcdC8vIFJlbGVhc2UgbG9jYWwgcG9pbnRlcnMgKCMxMjk4KVxuXHRcdFx0XHRcdHdyYXBwZXIgPSByZW5kZXJlciA9IHVwZGF0ZUJveFNpemUgPSB1cGRhdGVUZXh0UGFkZGluZyA9IGJveEF0dHIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07IC8vIGVuZCBTVkdSZW5kZXJlclxuXG5cblx0Ly8gZ2VuZXJhbCByZW5kZXJlclxuXHRSZW5kZXJlciA9IFNWR1JlbmRlcmVyO1xuXHQvLyBleHRlbmQgU3ZnRWxlbWVudCBmb3IgdXNlSFRNTCBvcHRpb25cblx0ZXh0ZW5kKFNWR0VsZW1lbnQucHJvdG90eXBlLCB7XG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgQ1NTIHRvIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdXNlZCBpbiB0ZXh0IHdpdGhpbiBTVkcgcmVuZGVyaW5nIGFuZFxuXHRcdCAqIGJ5IHRoZSBWTUwgcmVuZGVyZXJcblx0XHQgKi9cblx0XHRodG1sQ3NzOiBmdW5jdGlvbiAoc3R5bGVzKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdHRleHRXaWR0aCA9IHN0eWxlcyAmJiBlbGVtZW50LnRhZ05hbWUgPT09ICdTUEFOJyAmJiBzdHlsZXMud2lkdGg7XG5cblx0XHRcdGlmICh0ZXh0V2lkdGgpIHtcblx0XHRcdFx0ZGVsZXRlIHN0eWxlcy53aWR0aDtcblx0XHRcdFx0d3JhcHBlci50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGVzICYmIHN0eWxlcy50ZXh0T3ZlcmZsb3cgPT09ICdlbGxpcHNpcycpIHtcblx0XHRcdFx0c3R5bGVzLndoaXRlU3BhY2UgPSAnbm93cmFwJztcblx0XHRcdFx0c3R5bGVzLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cdFx0XHR9XG5cdFx0XHR3cmFwcGVyLnN0eWxlcyA9IGV4dGVuZCh3cmFwcGVyLnN0eWxlcywgc3R5bGVzKTtcblx0XHRcdGNzcyh3cmFwcGVyLmVsZW1lbnQsIHN0eWxlcyk7XG5cblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBWTUwgYW5kIHVzZUhUTUwgbWV0aG9kIGZvciBjYWxjdWxhdGluZyB0aGUgYm91bmRpbmcgYm94IGJhc2VkIG9uIG9mZnNldHNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZnJlc2ggV2hldGhlciB0byBmb3JjZSBhIGZyZXNoIHZhbHVlIGZyb20gdGhlIERPTSBvciB0b1xuXHRcdCAqIHVzZSB0aGUgY2FjaGVkIHZhbHVlXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgaGFzaCBjb250YWluaW5nIHZhbHVlcyBmb3IgeCwgeSwgd2lkdGggYW5kIGhlaWdodFxuXHRcdCAqL1xuXG5cdFx0aHRtbEdldEJCb3g6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudDtcblxuXHRcdFx0Ly8gZmFraW5nIGdldEJCb3ggaW4gZXhwb3J0ZWQgU1ZHIGluIGxlZ2FjeSBJRVxuXHRcdFx0Ly8gZmFraW5nIGdldEJCb3ggaW4gZXhwb3J0ZWQgU1ZHIGluIGxlZ2FjeSBJRSAoaXMgdGhpcyBhIGR1cGxpY2F0ZSBvZiB0aGUgZml4IGZvciAjMTA3OT8pXG5cdFx0XHRpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3RleHQnKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBBQlNPTFVURTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuXHRcdFx0XHR5OiBlbGVtZW50Lm9mZnNldFRvcCxcblx0XHRcdFx0d2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFZNTCBvdmVycmlkZSBwcml2YXRlIG1ldGhvZCB0byB1cGRhdGUgZWxlbWVudHMgYmFzZWQgb24gaW50ZXJuYWxcblx0XHQgKiBwcm9wZXJ0aWVzIGJhc2VkIG9uIFNWRyB0cmFuc2Zvcm1cblx0XHQgKi9cblx0XHRodG1sVXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBhbGlnbmluZyBub24gYWRkZWQgZWxlbWVudHMgaXMgZXhwZW5zaXZlXG5cdFx0XHRpZiAoIXRoaXMuYWRkZWQpIHtcblx0XHRcdFx0dGhpcy5hbGlnbk9uQWRkID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcixcblx0XHRcdFx0ZWxlbSA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0dHJhbnNsYXRlWCA9IHdyYXBwZXIudHJhbnNsYXRlWCB8fCAwLFxuXHRcdFx0XHR0cmFuc2xhdGVZID0gd3JhcHBlci50cmFuc2xhdGVZIHx8IDAsXG5cdFx0XHRcdHggPSB3cmFwcGVyLnggfHwgMCxcblx0XHRcdFx0eSA9IHdyYXBwZXIueSB8fCAwLFxuXHRcdFx0XHRhbGlnbiA9IHdyYXBwZXIudGV4dEFsaWduIHx8ICdsZWZ0Jyxcblx0XHRcdFx0YWxpZ25Db3JyZWN0aW9uID0geyBsZWZ0OiAwLCBjZW50ZXI6IDAuNSwgcmlnaHQ6IDEgfVthbGlnbl0sXG5cdFx0XHRcdHNoYWRvd3MgPSB3cmFwcGVyLnNoYWRvd3MsXG5cdFx0XHRcdHN0eWxlcyA9IHdyYXBwZXIuc3R5bGVzO1xuXG5cdFx0XHQvLyBhcHBseSB0cmFuc2xhdGVcblx0XHRcdGNzcyhlbGVtLCB7XG5cdFx0XHRcdG1hcmdpbkxlZnQ6IHRyYW5zbGF0ZVgsXG5cdFx0XHRcdG1hcmdpblRvcDogdHJhbnNsYXRlWVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoc2hhZG93cykgeyAvLyB1c2VkIGluIGxhYmVscy90b29sdGlwXG5cdFx0XHRcdGVhY2goc2hhZG93cywgZnVuY3Rpb24gKHNoYWRvdykge1xuXHRcdFx0XHRcdGNzcyhzaGFkb3csIHtcblx0XHRcdFx0XHRcdG1hcmdpbkxlZnQ6IHRyYW5zbGF0ZVggKyAxLFxuXHRcdFx0XHRcdFx0bWFyZ2luVG9wOiB0cmFuc2xhdGVZICsgMVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwbHkgaW52ZXJzaW9uXG5cdFx0XHRpZiAod3JhcHBlci5pbnZlcnRlZCkgeyAvLyB3cmFwcGVyIGlzIGEgZ3JvdXBcblx0XHRcdFx0ZWFjaChlbGVtLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHRcdHJlbmRlcmVyLmludmVydENoaWxkKGNoaWxkLCBlbGVtKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChlbGVtLnRhZ05hbWUgPT09ICdTUEFOJykge1xuXG5cdFx0XHRcdHZhciB3aWR0aCxcblx0XHRcdFx0XHRyb3RhdGlvbiA9IHdyYXBwZXIucm90YXRpb24sXG5cdFx0XHRcdFx0YmFzZWxpbmUsXG5cdFx0XHRcdFx0dGV4dFdpZHRoID0gcEludCh3cmFwcGVyLnRleHRXaWR0aCksXG5cdFx0XHRcdFx0Y3VycmVudFRleHRUcmFuc2Zvcm0gPSBbcm90YXRpb24sIGFsaWduLCBlbGVtLmlubmVySFRNTCwgd3JhcHBlci50ZXh0V2lkdGhdLmpvaW4oJywnKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFRleHRUcmFuc2Zvcm0gIT09IHdyYXBwZXIuY1RUKSB7IC8vIGRvIHRoZSBjYWxjdWxhdGlvbnMgYW5kIERPTSBhY2Nlc3Mgb25seSBpZiBwcm9wZXJ0aWVzIGNoYW5nZWRcblxuXG5cdFx0XHRcdFx0YmFzZWxpbmUgPSByZW5kZXJlci5mb250TWV0cmljcyhlbGVtLnN0eWxlLmZvbnRTaXplKS5iO1xuXG5cdFx0XHRcdFx0Ly8gUmVuZGVyZXIgc3BlY2lmaWMgaGFuZGxpbmcgb2Ygc3BhbiByb3RhdGlvblxuXHRcdFx0XHRcdGlmIChkZWZpbmVkKHJvdGF0aW9uKSkge1xuXHRcdFx0XHRcdFx0d3JhcHBlci5zZXRTcGFuUm90YXRpb24ocm90YXRpb24sIGFsaWduQ29ycmVjdGlvbiwgYmFzZWxpbmUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdpZHRoID0gcGljayh3cmFwcGVyLmVsZW1XaWR0aCwgZWxlbS5vZmZzZXRXaWR0aCk7XG5cblx0XHRcdFx0XHQvLyBVcGRhdGUgdGV4dFdpZHRoXG5cdFx0XHRcdFx0aWYgKHdpZHRoID4gdGV4dFdpZHRoICYmIC9bIFxcLV0vLnRlc3QoZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCkpIHsgLy8gIzk4MywgIzEyNTRcblx0XHRcdFx0XHRcdGNzcyhlbGVtLCB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiB0ZXh0V2lkdGggKyBQWCxcblx0XHRcdFx0XHRcdFx0ZGlzcGxheTogJ2Jsb2NrJyxcblx0XHRcdFx0XHRcdFx0d2hpdGVTcGFjZTogKHN0eWxlcyAmJiBzdHlsZXMud2hpdGVTcGFjZSkgfHwgJ25vcm1hbCcgLy8gIzMzMzFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0d2lkdGggPSB0ZXh0V2lkdGg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0d3JhcHBlci5nZXRTcGFuQ29ycmVjdGlvbih3aWR0aCwgYmFzZWxpbmUsIGFsaWduQ29ycmVjdGlvbiwgcm90YXRpb24sIGFsaWduKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IHBvc2l0aW9uIHdpdGggY29ycmVjdGlvblxuXHRcdFx0XHRjc3MoZWxlbSwge1xuXHRcdFx0XHRcdGxlZnQ6ICh4ICsgKHdyYXBwZXIueENvcnIgfHwgMCkpICsgUFgsXG5cdFx0XHRcdFx0dG9wOiAoeSArICh3cmFwcGVyLnlDb3JyIHx8IDApKSArIFBYXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIGZvcmNlIHJlZmxvdyBpbiB3ZWJraXQgdG8gYXBwbHkgdGhlIGxlZnQgYW5kIHRvcCBvbiB1c2VIVE1MIGVsZW1lbnQgKCMxMjQ5KVxuXHRcdFx0XHRpZiAoaXNXZWJLaXQpIHtcblx0XHRcdFx0XHRiYXNlbGluZSA9IGVsZW0ub2Zmc2V0SGVpZ2h0OyAvLyBhc3NpZ25lZCB0byBiYXNlbGluZSBmb3IgSlNMaW50IHB1cnBvc2Vcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlY29yZCBjdXJyZW50IHRleHQgdHJhbnNmb3JtXG5cdFx0XHRcdHdyYXBwZXIuY1RUID0gY3VycmVudFRleHRUcmFuc2Zvcm07XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgcm90YXRpb24gb2YgYW4gaW5kaXZpZHVhbCBIVE1MIHNwYW5cblx0XHQgKi9cblx0XHRzZXRTcGFuUm90YXRpb246IGZ1bmN0aW9uIChyb3RhdGlvbiwgYWxpZ25Db3JyZWN0aW9uLCBiYXNlbGluZSkge1xuXHRcdFx0dmFyIHJvdGF0aW9uU3R5bGUgPSB7fSxcblx0XHRcdFx0Y3NzVHJhbnNmb3JtS2V5ID0gaXNJRSA/ICctbXMtdHJhbnNmb3JtJyA6IGlzV2ViS2l0ID8gJy13ZWJraXQtdHJhbnNmb3JtJyA6IGlzRmlyZWZveCA/ICdNb3pUcmFuc2Zvcm0nIDogaXNPcGVyYSA/ICctby10cmFuc2Zvcm0nIDogJyc7XG5cblx0XHRcdHJvdGF0aW9uU3R5bGVbY3NzVHJhbnNmb3JtS2V5XSA9IHJvdGF0aW9uU3R5bGUudHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgcm90YXRpb24gKyAnZGVnKSc7XG5cdFx0XHRyb3RhdGlvblN0eWxlW2Nzc1RyYW5zZm9ybUtleSArIChpc0ZpcmVmb3ggPyAnT3JpZ2luJyA6ICctb3JpZ2luJyldID0gcm90YXRpb25TdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAoYWxpZ25Db3JyZWN0aW9uICogMTAwKSArICclICcgKyBiYXNlbGluZSArICdweCc7XG5cdFx0XHRjc3ModGhpcy5lbGVtZW50LCByb3RhdGlvblN0eWxlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBjb3JyZWN0aW9uIGluIFggYW5kIFkgcG9zaXRpb25pbmcgYXMgdGhlIGVsZW1lbnQgaXMgcm90YXRlZC5cblx0XHQgKi9cblx0XHRnZXRTcGFuQ29ycmVjdGlvbjogZnVuY3Rpb24gKHdpZHRoLCBiYXNlbGluZSwgYWxpZ25Db3JyZWN0aW9uKSB7XG5cdFx0XHR0aGlzLnhDb3JyID0gLXdpZHRoICogYWxpZ25Db3JyZWN0aW9uO1xuXHRcdFx0dGhpcy55Q29yciA9IC1iYXNlbGluZTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIEV4dGVuZCBTdmdSZW5kZXJlciBmb3IgdXNlSFRNTCBvcHRpb24uXG5cdGV4dGVuZChTVkdSZW5kZXJlci5wcm90b3R5cGUsIHtcblx0XHQvKipcblx0XHQgKiBDcmVhdGUgSFRNTCB0ZXh0IG5vZGUuIFRoaXMgaXMgdXNlZCBieSB0aGUgVk1MIHJlbmRlcmVyIGFzIHdlbGwgYXMgdGhlIFNWR1xuXHRcdCAqIHJlbmRlcmVyIHRocm91Z2ggdGhlIHVzZUhUTUwgb3B0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKi9cblx0XHRodG1sOiBmdW5jdGlvbiAoc3RyLCB4LCB5KSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxuXHRcdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0XHRyZW5kZXJlciA9IHdyYXBwZXIucmVuZGVyZXI7XG5cblx0XHRcdC8vIFRleHQgc2V0dGVyXG5cdFx0XHR3cmFwcGVyLnRleHRTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0aWYgKHZhbHVlICE9PSBlbGVtZW50LmlubmVySFRNTCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmJCb3g7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLnRleHRTdHIgPSB2YWx1ZTtcblx0XHRcdH07XG5cblx0XHRcdC8vIFZhcmlvdXMgc2V0dGVycyB3aGljaCByZWx5IG9uIHVwZGF0ZSB0cmFuc2Zvcm1cblx0XHRcdHdyYXBwZXIueFNldHRlciA9IHdyYXBwZXIueVNldHRlciA9IHdyYXBwZXIuYWxpZ25TZXR0ZXIgPSB3cmFwcGVyLnJvdGF0aW9uU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gJ2FsaWduJykge1xuXHRcdFx0XHRcdGtleSA9ICd0ZXh0QWxpZ24nOyAvLyBEbyBub3Qgb3ZlcndyaXRlIHRoZSBTVkdFbGVtZW50LmFsaWduIG1ldGhvZC4gU2FtZSBhcyBWTUwuXG5cdFx0XHRcdH1cblx0XHRcdFx0d3JhcHBlcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdHdyYXBwZXIuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXNcblx0XHRcdHdyYXBwZXIuYXR0cih7XG5cdFx0XHRcdFx0dGV4dDogc3RyLFxuXHRcdFx0XHRcdHg6IG1hdGhSb3VuZCh4KSxcblx0XHRcdFx0XHR5OiBtYXRoUm91bmQoeSlcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0XHRcdGZvbnRGYW1pbHk6IHRoaXMuc3R5bGUuZm9udEZhbWlseSxcblx0XHRcdFx0XHRmb250U2l6ZTogdGhpcy5zdHlsZS5mb250U2l6ZVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gS2VlcCB0aGUgd2hpdGVTcGFjZSBzdHlsZSBvdXRzaWRlIHRoZSB3cmFwcGVyLnN0eWxlcyBjb2xsZWN0aW9uXG5cdFx0XHRlbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcblxuXHRcdFx0Ly8gVXNlIHRoZSBIVE1MIHNwZWNpZmljIC5jc3MgbWV0aG9kXG5cdFx0XHR3cmFwcGVyLmNzcyA9IHdyYXBwZXIuaHRtbENzcztcblxuXHRcdFx0Ly8gVGhpcyBpcyBzcGVjaWZpYyBmb3IgSFRNTCB3aXRoaW4gU1ZHXG5cdFx0XHRpZiAocmVuZGVyZXIuaXNTVkcpIHtcblx0XHRcdFx0d3JhcHBlci5hZGQgPSBmdW5jdGlvbiAoc3ZnR3JvdXBXcmFwcGVyKSB7XG5cblx0XHRcdFx0XHR2YXIgaHRtbEdyb3VwLFxuXHRcdFx0XHRcdFx0Y29udGFpbmVyID0gcmVuZGVyZXIuYm94LnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRwYXJlbnRHcm91cCxcblx0XHRcdFx0XHRcdHBhcmVudHMgPSBbXTtcblxuXHRcdFx0XHRcdHRoaXMucGFyZW50R3JvdXAgPSBzdmdHcm91cFdyYXBwZXI7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBtb2NrIGdyb3VwIHRvIGhvbGQgdGhlIEhUTUwgZWxlbWVudHNcblx0XHRcdFx0XHRpZiAoc3ZnR3JvdXBXcmFwcGVyKSB7XG5cdFx0XHRcdFx0XHRodG1sR3JvdXAgPSBzdmdHcm91cFdyYXBwZXIuZGl2O1xuXHRcdFx0XHRcdFx0aWYgKCFodG1sR3JvdXApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZWFkIHRoZSBwYXJlbnQgY2hhaW4gaW50byBhbiBhcnJheSBhbmQgcmVhZCBmcm9tIHRvcCBkb3duXG5cdFx0XHRcdFx0XHRcdHBhcmVudEdyb3VwID0gc3ZnR3JvdXBXcmFwcGVyO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAocGFyZW50R3JvdXApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBhcmVudHMucHVzaChwYXJlbnRHcm91cCk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBNb3ZlIHVwIHRvIHRoZSBuZXh0IHBhcmVudCBncm91cFxuXHRcdFx0XHRcdFx0XHRcdHBhcmVudEdyb3VwID0gcGFyZW50R3JvdXAucGFyZW50R3JvdXA7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBFbnN1cmUgZHluYW1pY2FsbHkgdXBkYXRpbmcgcG9zaXRpb24gd2hlbiBhbnkgcGFyZW50IGlzIHRyYW5zbGF0ZWRcblx0XHRcdFx0XHRcdFx0ZWFjaChwYXJlbnRzLnJldmVyc2UoKSwgZnVuY3Rpb24gKHBhcmVudEdyb3VwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGh0bWxHcm91cFN0eWxlO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgSFRNTCBkaXYgYW5kIGFwcGVuZCBpdCB0byB0aGUgcGFyZW50IGRpdiB0byBlbXVsYXRlXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhlIFNWRyBncm91cCBzdHJ1Y3R1cmVcblx0XHRcdFx0XHRcdFx0XHRodG1sR3JvdXAgPSBwYXJlbnRHcm91cC5kaXYgPSBwYXJlbnRHcm91cC5kaXYgfHwgY3JlYXRlRWxlbWVudChESVYsIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZTogYXR0cihwYXJlbnRHcm91cC5lbGVtZW50LCAnY2xhc3MnKVxuXHRcdFx0XHRcdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0XHRcdFx0XHRcdGxlZnQ6IChwYXJlbnRHcm91cC50cmFuc2xhdGVYIHx8IDApICsgUFgsXG5cdFx0XHRcdFx0XHRcdFx0XHR0b3A6IChwYXJlbnRHcm91cC50cmFuc2xhdGVZIHx8IDApICsgUFhcblx0XHRcdFx0XHRcdFx0XHR9LCBodG1sR3JvdXAgfHwgY29udGFpbmVyKTsgLy8gdGhlIHRvcCBncm91cCBpcyBhcHBlbmRlZCB0byBjb250YWluZXJcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFNob3J0Y3V0XG5cdFx0XHRcdFx0XHRcdFx0aHRtbEdyb3VwU3R5bGUgPSBodG1sR3JvdXAuc3R5bGU7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTZXQgbGlzdGVuZXJzIHRvIHVwZGF0ZSB0aGUgSFRNTCBkaXYncyBwb3NpdGlvbiB3aGVuZXZlciB0aGUgU1ZHIGdyb3VwXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcG9zaXRpb24gaXMgY2hhbmdlZFxuXHRcdFx0XHRcdFx0XHRcdGV4dGVuZChwYXJlbnRHcm91cCwge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNsYXRlWFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aHRtbEdyb3VwU3R5bGUubGVmdCA9IHZhbHVlICsgUFg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudEdyb3VwW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXAuZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zbGF0ZVlTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlLnRvcCA9IHZhbHVlICsgUFg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudEdyb3VwW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXAuZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHZpc2liaWxpdHlTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cFN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aHRtbEdyb3VwID0gY29udGFpbmVyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGh0bWxHcm91cC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuXHRcdFx0XHRcdC8vIFNoYXJlZCB3aXRoIFZNTDpcblx0XHRcdFx0XHR3cmFwcGVyLmFkZGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAod3JhcHBlci5hbGlnbk9uQWRkKSB7XG5cdFx0XHRcdFx0XHR3cmFwcGVyLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH1cblx0fSk7XG5cblx0LyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqIFNUQVJUIE9GIElOVEVSTkVUIEVYUExPUkVSIDw9IDggU1BFQ0lGSUMgQ09ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiBGb3IgYXBwbGljYXRpb25zIGFuZCB3ZWJzaXRlcyB0aGF0IGRvbid0IG5lZWQgSUUgc3VwcG9ydCwgbGlrZSBwbGF0Zm9ybSAgICAqXG5cdCAqIHRhcmdldGVkIG1vYmlsZSBhcHBzIGFuZCB3ZWIgYXBwcywgdGhpcyBjb2RlIGNhbiBiZSByZW1vdmVkLiAgICAgICAgICAgICAgICpcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIFZNTFJlbmRlcmVyLCBWTUxFbGVtZW50O1xuXHRpZiAoIWhhc1NWRyAmJiAhdXNlQ2FuVkcpIHtcblxuXHQvKipcblx0ICogVGhlIFZNTCBlbGVtZW50IHdyYXBwZXIuXG5cdCAqL1xuXHRWTUxFbGVtZW50ID0ge1xuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSBhIG5ldyBWTUwgZWxlbWVudCB3cmFwcGVyLiBJdCBidWlsZHMgdGhlIG1hcmt1cCBhcyBhIHN0cmluZ1xuXHRcdCAqIHRvIG1pbmltaXplIERPTSB0cmFmZmljLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlTmFtZVxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChyZW5kZXJlciwgbm9kZU5hbWUpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0bWFya3VwID0gIFsnPCcsIG5vZGVOYW1lLCAnIGZpbGxlZD1cImZcIiBzdHJva2VkPVwiZlwiJ10sXG5cdFx0XHRcdHN0eWxlID0gWydwb3NpdGlvbjogJywgQUJTT0xVVEUsICc7J10sXG5cdFx0XHRcdGlzRGl2ID0gbm9kZU5hbWUgPT09IERJVjtcblxuXHRcdFx0Ly8gZGl2cyBhbmQgc2hhcGVzIG5lZWQgc2l6ZVxuXHRcdFx0aWYgKG5vZGVOYW1lID09PSAnc2hhcGUnIHx8IGlzRGl2KSB7XG5cdFx0XHRcdHN0eWxlLnB1c2goJ2xlZnQ6MDt0b3A6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnKTtcblx0XHRcdH1cblx0XHRcdHN0eWxlLnB1c2goJ3Zpc2liaWxpdHk6ICcsIGlzRGl2ID8gSElEREVOIDogVklTSUJMRSk7XG5cblx0XHRcdG1hcmt1cC5wdXNoKCcgc3R5bGU9XCInLCBzdHlsZS5qb2luKCcnKSwgJ1wiLz4nKTtcblxuXHRcdFx0Ly8gY3JlYXRlIGVsZW1lbnQgd2l0aCBkZWZhdWx0IGF0dHJpYnV0ZXMgYW5kIHN0eWxlXG5cdFx0XHRpZiAobm9kZU5hbWUpIHtcblx0XHRcdFx0bWFya3VwID0gaXNEaXYgfHwgbm9kZU5hbWUgPT09ICdzcGFuJyB8fCBub2RlTmFtZSA9PT0gJ2ltZycgP1xuXHRcdFx0XHRcdG1hcmt1cC5qb2luKCcnKVxuXHRcdFx0XHRcdDogcmVuZGVyZXIucHJlcFZNTChtYXJrdXApO1xuXHRcdFx0XHR3cmFwcGVyLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KG1hcmt1cCk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXBwZXIucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIHRoZSBub2RlIHRvIHRoZSBnaXZlbiBwYXJlbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG5cdFx0ICovXG5cdFx0YWRkOiBmdW5jdGlvbiAocGFyZW50KSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcixcblx0XHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0Ym94ID0gcmVuZGVyZXIuYm94LFxuXHRcdFx0XHRpbnZlcnRlZCA9IHBhcmVudCAmJiBwYXJlbnQuaW52ZXJ0ZWQsXG5cblx0XHRcdFx0Ly8gZ2V0IHRoZSBwYXJlbnQgbm9kZVxuXHRcdFx0XHRwYXJlbnROb2RlID0gcGFyZW50ID9cblx0XHRcdFx0XHRwYXJlbnQuZWxlbWVudCB8fCBwYXJlbnQgOlxuXHRcdFx0XHRcdGJveDtcblxuXG5cdFx0XHQvLyBpZiB0aGUgcGFyZW50IGdyb3VwIGlzIGludmVydGVkLCBhcHBseSBpbnZlcnNpb24gb24gYWxsIGNoaWxkcmVuXG5cdFx0XHRpZiAoaW52ZXJ0ZWQpIHsgLy8gb25seSBvbiBncm91cHNcblx0XHRcdFx0cmVuZGVyZXIuaW52ZXJ0Q2hpbGQoZWxlbWVudCwgcGFyZW50Tm9kZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFwcGVuZCBpdFxuXHRcdFx0cGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuXHRcdFx0Ly8gYWxpZ24gdGV4dCBhZnRlciBhZGRpbmcgdG8gYmUgYWJsZSB0byByZWFkIG9mZnNldFxuXHRcdFx0d3JhcHBlci5hZGRlZCA9IHRydWU7XG5cdFx0XHRpZiAod3JhcHBlci5hbGlnbk9uQWRkICYmICF3cmFwcGVyLmRlZmVyVXBkYXRlVHJhbnNmb3JtKSB7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZpcmUgYW4gZXZlbnQgZm9yIGludGVybmFsIGhvb2tzXG5cdFx0XHRpZiAod3JhcHBlci5vbkFkZCkge1xuXHRcdFx0XHR3cmFwcGVyLm9uQWRkKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBWTUwgYWx3YXlzIHVzZXMgaHRtbFVwZGF0ZVRyYW5zZm9ybVxuXHRcdCAqL1xuXHRcdHVwZGF0ZVRyYW5zZm9ybTogU1ZHRWxlbWVudC5wcm90b3R5cGUuaHRtbFVwZGF0ZVRyYW5zZm9ybSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgcm90YXRpb24gb2YgYSBzcGFuIHdpdGggb2xkSUUncyBmaWx0ZXJcblx0XHQgKi9cblx0XHRzZXRTcGFuUm90YXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIEFkanVzdCBmb3IgYWxpZ25tZW50IGFuZCByb3RhdGlvbi4gUm90YXRpb24gb2YgdXNlSFRNTCBjb250ZW50IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcblx0XHRcdC8vIGJ1dCBpdCBjYW4gcHJvYmFibHkgYmUgaW1wbGVtZW50ZWQgZm9yIEZpcmVmb3ggMy41KyBvbiB1c2VyIHJlcXVlc3QuIEZGMy41K1xuXHRcdFx0Ly8gaGFzIHN1cHBvcnQgZm9yIENTUzMgdHJhbnNmb3JtLiBUaGUgZ2V0QkJveCBtZXRob2QgYWxzbyBuZWVkcyB0byBiZSB1cGRhdGVkXG5cdFx0XHQvLyB0byBjb21wZW5zYXRlIGZvciB0aGUgcm90YXRpb24sIGxpa2UgaXQgY3VycmVudGx5IGRvZXMgZm9yIFNWRy5cblx0XHRcdC8vIFRlc3QgY2FzZTogaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzL1lidDQ0L1xuXG5cdFx0XHR2YXIgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuXHRcdFx0XHRjb3N0aGV0YSA9IG1hdGhDb3Mocm90YXRpb24gKiBkZWcycmFkKSxcblx0XHRcdFx0c2ludGhldGEgPSBtYXRoU2luKHJvdGF0aW9uICogZGVnMnJhZCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdGNzcyh0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0ZmlsdGVyOiByb3RhdGlvbiA/IFsncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9JywgY29zdGhldGEsXG5cdFx0XHRcdFx0JywgTTEyPScsIC1zaW50aGV0YSwgJywgTTIxPScsIHNpbnRoZXRhLCAnLCBNMjI9JywgY29zdGhldGEsXG5cdFx0XHRcdFx0Jywgc2l6aW5nTWV0aG9kPVxcJ2F1dG8gZXhwYW5kXFwnKSddLmpvaW4oJycpIDogTk9ORVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgcG9zaXRpb25pbmcgY29ycmVjdGlvbiBmb3IgdGhlIHNwYW4gYWZ0ZXIgcm90YXRpbmcuIFxuXHRcdCAqL1xuXHRcdGdldFNwYW5Db3JyZWN0aW9uOiBmdW5jdGlvbiAod2lkdGgsIGJhc2VsaW5lLCBhbGlnbkNvcnJlY3Rpb24sIHJvdGF0aW9uLCBhbGlnbikge1xuXG5cdFx0XHR2YXIgY29zdGhldGEgPSByb3RhdGlvbiA/IG1hdGhDb3Mocm90YXRpb24gKiBkZWcycmFkKSA6IDEsXG5cdFx0XHRcdHNpbnRoZXRhID0gcm90YXRpb24gPyBtYXRoU2luKHJvdGF0aW9uICogZGVnMnJhZCkgOiAwLFxuXHRcdFx0XHRoZWlnaHQgPSBwaWNrKHRoaXMuZWxlbUhlaWdodCwgdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCksXG5cdFx0XHRcdHF1YWQsXG5cdFx0XHRcdG5vbkxlZnQgPSBhbGlnbiAmJiBhbGlnbiAhPT0gJ2xlZnQnO1xuXG5cdFx0XHQvLyBjb3JyZWN0IHggYW5kIHlcblx0XHRcdHRoaXMueENvcnIgPSBjb3N0aGV0YSA8IDAgJiYgLXdpZHRoO1xuXHRcdFx0dGhpcy55Q29yciA9IHNpbnRoZXRhIDwgMCAmJiAtaGVpZ2h0O1xuXG5cdFx0XHQvLyBjb3JyZWN0IGZvciBiYXNlbGluZSBhbmQgY29ybmVycyBzcGlsbGluZyBvdXQgYWZ0ZXIgcm90YXRpb25cblx0XHRcdHF1YWQgPSBjb3N0aGV0YSAqIHNpbnRoZXRhIDwgMDtcblx0XHRcdHRoaXMueENvcnIgKz0gc2ludGhldGEgKiBiYXNlbGluZSAqIChxdWFkID8gMSAtIGFsaWduQ29ycmVjdGlvbiA6IGFsaWduQ29ycmVjdGlvbik7XG5cdFx0XHR0aGlzLnlDb3JyIC09IGNvc3RoZXRhICogYmFzZWxpbmUgKiAocm90YXRpb24gPyAocXVhZCA/IGFsaWduQ29ycmVjdGlvbiA6IDEgLSBhbGlnbkNvcnJlY3Rpb24pIDogMSk7XG5cdFx0XHQvLyBjb3JyZWN0IGZvciB0aGUgbGVuZ3RoL2hlaWdodCBvZiB0aGUgdGV4dFxuXHRcdFx0aWYgKG5vbkxlZnQpIHtcblx0XHRcdFx0dGhpcy54Q29yciAtPSB3aWR0aCAqIGFsaWduQ29ycmVjdGlvbiAqIChjb3N0aGV0YSA8IDAgPyAtMSA6IDEpO1xuXHRcdFx0XHRpZiAocm90YXRpb24pIHtcblx0XHRcdFx0XHR0aGlzLnlDb3JyIC09IGhlaWdodCAqIGFsaWduQ29ycmVjdGlvbiAqIChzaW50aGV0YSA8IDAgPyAtMSA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNzcyh0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0XHR0ZXh0QWxpZ246IGFsaWduXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0cyBhIHN1YnNldCBvZiBhbiBTVkcgcGF0aCBkZWZpbml0aW9uIHRvIGl0cyBWTUwgY291bnRlcnBhcnQuIFRha2VzIGFuIGFycmF5XG5cdFx0ICogYXMgdGhlIHBhcmFtZXRlciBhbmQgcmV0dXJucyBhIHN0cmluZy5cblx0XHQgKi9cblx0XHRwYXRoVG9WTUw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Ly8gY29udmVydCBwYXRoc1xuXHRcdFx0dmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG5cdFx0XHRcdHBhdGggPSBbXTtcblxuXHRcdFx0d2hpbGUgKGktLSkge1xuXG5cdFx0XHRcdC8vIE11bHRpcGx5IGJ5IDEwIHRvIGFsbG93IHN1YnBpeGVsIHByZWNpc2lvbi5cblx0XHRcdFx0Ly8gU3Vic3RyYWN0aW5nIGhhbGYgYSBwaXhlbCBzZWVtcyB0byBtYWtlIHRoZSBjb29yZGluYXRlc1xuXHRcdFx0XHQvLyBhbGlnbiB3aXRoIFNWRywgYnV0IHRoaXMgaGFzbid0IGJlZW4gdGVzdGVkIHRob3JvdWdobHlcblx0XHRcdFx0aWYgKGlzTnVtYmVyKHZhbHVlW2ldKSkge1xuXHRcdFx0XHRcdHBhdGhbaV0gPSBtYXRoUm91bmQodmFsdWVbaV0gKiAxMCkgLSA1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlW2ldID09PSAnWicpIHsgLy8gY2xvc2UgdGhlIHBhdGhcblx0XHRcdFx0XHRwYXRoW2ldID0gJ3gnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhdGhbaV0gPSB2YWx1ZVtpXTtcblxuXHRcdFx0XHRcdC8vIFdoZW4gdGhlIHN0YXJ0IFggYW5kIGVuZCBYIGNvb3JkaW5hdGVzIG9mIGFuIGFyYyBhcmUgdG9vIGNsb3NlLFxuXHRcdFx0XHRcdC8vIHRoZXkgYXJlIHJvdW5kZWQgdG8gdGhlIHNhbWUgdmFsdWUgYWJvdmUuIEluIHRoaXMgY2FzZSwgc3Vic3RyYWN0IG9yIFxuXHRcdFx0XHRcdC8vIGFkZCAxIGZyb20gdGhlIGVuZCBYIGFuZCBZIHBvc2l0aW9ucy4gIzE4NiwgIzc2MCwgIzEzNzEsICMxNDEwLlxuXHRcdFx0XHRcdGlmICh2YWx1ZS5pc0FyYyAmJiAodmFsdWVbaV0gPT09ICd3YScgfHwgdmFsdWVbaV0gPT09ICdhdCcpKSB7XG5cdFx0XHRcdFx0XHQvLyBTdGFydCBhbmQgZW5kIFhcblx0XHRcdFx0XHRcdGlmIChwYXRoW2kgKyA1XSA9PT0gcGF0aFtpICsgN10pIHtcblx0XHRcdFx0XHRcdFx0cGF0aFtpICsgN10gKz0gdmFsdWVbaSArIDddID4gdmFsdWVbaSArIDVdID8gMSA6IC0xO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gU3RhcnQgYW5kIGVuZCBZXG5cdFx0XHRcdFx0XHRpZiAocGF0aFtpICsgNl0gPT09IHBhdGhbaSArIDhdKSB7XG5cdFx0XHRcdFx0XHRcdHBhdGhbaSArIDhdICs9IHZhbHVlW2kgKyA4XSA+IHZhbHVlW2kgKyA2XSA/IDEgOiAtMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0XG5cdFx0XHQvLyBMb29wIHVwIGFnYWluIHRvIGhhbmRsZSBwYXRoIHNob3J0Y3V0cyAoIzIxMzIpXG5cdFx0XHQvKndoaWxlIChpKysgPCBwYXRoLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAocGF0aFtpXSA9PT0gJ0gnKSB7IC8vIGhvcml6b250YWwgbGluZSB0b1xuXHRcdFx0XHRcdHBhdGhbaV0gPSAnTCc7XG5cdFx0XHRcdFx0cGF0aC5zcGxpY2UoaSArIDIsIDAsIHBhdGhbaSAtIDFdKTtcblx0XHRcdFx0fSBlbHNlIGlmIChwYXRoW2ldID09PSAnVicpIHsgLy8gdmVydGljYWwgbGluZSB0b1xuXHRcdFx0XHRcdHBhdGhbaV0gPSAnTCc7XG5cdFx0XHRcdFx0cGF0aC5zcGxpY2UoaSArIDEsIDAsIHBhdGhbaSAtIDJdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSovXG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKCcgJykgfHwgJ3gnO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGVsZW1lbnQncyBjbGlwcGluZyB0byBhIHByZWRlZmluZWQgcmVjdGFuZ2xlXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBjbGlwIHJlY3RhbmdsZVxuXHRcdCAqL1xuXHRcdGNsaXA6IGZ1bmN0aW9uIChjbGlwUmVjdCkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRjbGlwTWVtYmVycyxcblx0XHRcdFx0Y3NzUmV0O1xuXG5cdFx0XHRpZiAoY2xpcFJlY3QpIHtcblx0XHRcdFx0Y2xpcE1lbWJlcnMgPSBjbGlwUmVjdC5tZW1iZXJzO1xuXHRcdFx0XHRlcmFzZShjbGlwTWVtYmVycywgd3JhcHBlcik7IC8vIEVuc3VyZSB1bmlxdWUgbGlzdCBvZiBlbGVtZW50cyAoIzEyNTgpXG5cdFx0XHRcdGNsaXBNZW1iZXJzLnB1c2god3JhcHBlcik7XG5cdFx0XHRcdHdyYXBwZXIuZGVzdHJveUNsaXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0ZXJhc2UoY2xpcE1lbWJlcnMsIHdyYXBwZXIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRjc3NSZXQgPSBjbGlwUmVjdC5nZXRDU1Mod3JhcHBlcik7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh3cmFwcGVyLmRlc3Ryb3lDbGlwKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5kZXN0cm95Q2xpcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNzc1JldCA9IHsgY2xpcDogZG9jTW9kZTggPyAnaW5oZXJpdCcgOiAncmVjdChhdXRvKScgfTsgLy8gIzEyMTRcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHdyYXBwZXIuY3NzKGNzc1JldCk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHN0eWxlcyBmb3IgdGhlIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG5cdFx0ICovXG5cdFx0Y3NzOiBTVkdFbGVtZW50LnByb3RvdHlwZS5odG1sQ3NzLFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhIGNoaWxkIGVpdGhlciBieSByZW1vdmVDaGlsZCBvciBtb3ZlIHRvIGdhcmJhZ2VCaW4uXG5cdFx0ICogSXNzdWUgNDkwOyBpbiBWTUwgcmVtb3ZlQ2hpbGQgcmVzdWx0cyBpbiBPcnBoYW5lZCBub2RlcyBhY2NvcmRpbmcgdG8gc0lFdmUsIGRpc2NhcmRFbGVtZW50IGRvZXMgbm90LlxuXHRcdCAqL1xuXHRcdHNhZmVSZW1vdmVDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdC8vIGRpc2NhcmRFbGVtZW50IHdpbGwgZGV0YWNoIHRoZSBub2RlIGZyb20gaXRzIHBhcmVudCBiZWZvcmUgYXR0YWNoaW5nIGl0XG5cdFx0XHQvLyB0byB0aGUgZ2FyYmFnZSBiaW4uIFRoZXJlZm9yZSBpdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGUgbm9kZSBpcyBhdHRhY2hlZCBhbmQgaGF2ZSBwYXJlbnQuXG5cdFx0XHRpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGRpc2NhcmRFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHRlbmQgZWxlbWVudC5kZXN0cm95IGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIGNsaXAgbWVtYmVycyBhcnJheVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLmRlc3Ryb3lDbGlwKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveUNsaXAoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFNWR0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci4gVk1MIG92ZXJyaWRlIGZvciBub3JtYWxpemluZyBldmVudCBwYXJhbWV0ZXJzLlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG5cdFx0ICovXG5cdFx0b246IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcblx0XHRcdC8vIHNpbXBsZXN0IHBvc3NpYmxlIGV2ZW50IG1vZGVsIGZvciBpbnRlcm5hbCB1c2Vcblx0XHRcdHRoaXMuZWxlbWVudFsnb24nICsgZXZlbnRUeXBlXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGV2dCA9IHdpbi5ldmVudDtcblx0XHRcdFx0ZXZ0LnRhcmdldCA9IGV2dC5zcmNFbGVtZW50O1xuXHRcdFx0XHRoYW5kbGVyKGV2dCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEluIHN0YWNrZWQgY29sdW1ucywgY3V0IG9mZiB0aGUgc2hhZG93cyBzbyB0aGF0IHRoZXkgZG9uJ3Qgb3ZlcmxhcFxuXHRcdCAqL1xuXHRcdGN1dE9mZlBhdGg6IGZ1bmN0aW9uIChwYXRoLCBsZW5ndGgpIHtcblxuXHRcdFx0dmFyIGxlbjtcblxuXHRcdFx0cGF0aCA9IHBhdGguc3BsaXQoL1sgLF0vKTtcblx0XHRcdGxlbiA9IHBhdGgubGVuZ3RoO1xuXG5cdFx0XHRpZiAobGVuID09PSA5IHx8IGxlbiA9PT0gMTEpIHtcblx0XHRcdFx0cGF0aFtsZW4gLSA0XSA9IHBhdGhbbGVuIC0gMl0gPSBwSW50KHBhdGhbbGVuIC0gMl0pIC0gMTAgKiBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKCcgJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IGEgZHJvcCBzaGFkb3cgYnkgY29weWluZyBlbGVtZW50cyBhbmQgZ2l2aW5nIHRoZW0gZGlmZmVyZW50IHN0cm9rZXNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBzaGFkb3dPcHRpb25zXG5cdFx0ICovXG5cdFx0c2hhZG93OiBmdW5jdGlvbiAoc2hhZG93T3B0aW9ucywgZ3JvdXAsIGN1dE9mZikge1xuXHRcdFx0dmFyIHNoYWRvd3MgPSBbXSxcblx0XHRcdFx0aSxcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0XHRzaGFkb3csXG5cdFx0XHRcdGVsZW1TdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG5cdFx0XHRcdG1hcmt1cCxcblx0XHRcdFx0cGF0aCA9IGVsZW1lbnQucGF0aCxcblx0XHRcdFx0c3Ryb2tlV2lkdGgsXG5cdFx0XHRcdG1vZGlmaWVkUGF0aCxcblx0XHRcdFx0c2hhZG93V2lkdGgsXG5cdFx0XHRcdHNoYWRvd0VsZW1lbnRPcGFjaXR5O1xuXG5cdFx0XHQvLyBzb21lIHRpbWVzIGVtcHR5IHBhdGhzIGFyZSBub3Qgc3RyaW5nc1xuXHRcdFx0aWYgKHBhdGggJiYgdHlwZW9mIHBhdGgudmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHBhdGggPSAneCc7XG5cdFx0XHR9XG5cdFx0XHRtb2RpZmllZFBhdGggPSBwYXRoO1xuXG5cdFx0XHRpZiAoc2hhZG93T3B0aW9ucykge1xuXHRcdFx0XHRzaGFkb3dXaWR0aCA9IHBpY2soc2hhZG93T3B0aW9ucy53aWR0aCwgMyk7XG5cdFx0XHRcdHNoYWRvd0VsZW1lbnRPcGFjaXR5ID0gKHNoYWRvd09wdGlvbnMub3BhY2l0eSB8fCAwLjE1KSAvIHNoYWRvd1dpZHRoO1xuXHRcdFx0XHRmb3IgKGkgPSAxOyBpIDw9IDM7IGkrKykge1xuXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSAoc2hhZG93V2lkdGggKiAyKSArIDEgLSAoMiAqIGkpO1xuXG5cdFx0XHRcdFx0Ly8gQ3V0IG9mZiBzaGFkb3dzIGZvciBzdGFja2VkIGNvbHVtbiBpdGVtc1xuXHRcdFx0XHRcdGlmIChjdXRPZmYpIHtcblx0XHRcdFx0XHRcdG1vZGlmaWVkUGF0aCA9IHRoaXMuY3V0T2ZmUGF0aChwYXRoLnZhbHVlLCBzdHJva2VXaWR0aCArIDAuNSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWFya3VwID0gWyc8c2hhcGUgaXNTaGFkb3c9XCJ0cnVlXCIgc3Ryb2tld2VpZ2h0PVwiJywgc3Ryb2tlV2lkdGgsXG5cdFx0XHRcdFx0XHQnXCIgZmlsbGVkPVwiZmFsc2VcIiBwYXRoPVwiJywgbW9kaWZpZWRQYXRoLFxuXHRcdFx0XHRcdFx0J1wiIGNvb3Jkc2l6ZT1cIjEwIDEwXCIgc3R5bGU9XCInLCBlbGVtZW50LnN0eWxlLmNzc1RleHQsICdcIiAvPiddO1xuXG5cdFx0XHRcdFx0c2hhZG93ID0gY3JlYXRlRWxlbWVudChyZW5kZXJlci5wcmVwVk1MKG1hcmt1cCksXG5cdFx0XHRcdFx0XHRudWxsLCB7XG5cdFx0XHRcdFx0XHRcdGxlZnQ6IHBJbnQoZWxlbVN0eWxlLmxlZnQpICsgcGljayhzaGFkb3dPcHRpb25zLm9mZnNldFgsIDEpLFxuXHRcdFx0XHRcdFx0XHR0b3A6IHBJbnQoZWxlbVN0eWxlLnRvcCkgKyBwaWNrKHNoYWRvd09wdGlvbnMub2Zmc2V0WSwgMSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGlmIChjdXRPZmYpIHtcblx0XHRcdFx0XHRcdHNoYWRvdy5jdXRPZmYgPSBzdHJva2VXaWR0aCArIDE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gYXBwbHkgdGhlIG9wYWNpdHlcblx0XHRcdFx0XHRtYXJrdXAgPSBbJzxzdHJva2UgY29sb3I9XCInLCBzaGFkb3dPcHRpb25zLmNvbG9yIHx8ICdibGFjaycsICdcIiBvcGFjaXR5PVwiJywgc2hhZG93RWxlbWVudE9wYWNpdHkgKiBpLCAnXCIvPiddO1xuXHRcdFx0XHRcdGNyZWF0ZUVsZW1lbnQocmVuZGVyZXIucHJlcFZNTChtYXJrdXApLCBudWxsLCBudWxsLCBzaGFkb3cpO1xuXG5cblx0XHRcdFx0XHQvLyBpbnNlcnQgaXRcblx0XHRcdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0XHRcdGdyb3VwLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc2hhZG93KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzaGFkb3csIGVsZW1lbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHJlY29yZCBpdFxuXHRcdFx0XHRcdHNoYWRvd3MucHVzaChzaGFkb3cpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNoYWRvd3MgPSBzaGFkb3dzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHR1cGRhdGVTaGFkb3dzOiBub29wLCAvLyBVc2VkIGluIFNWRyBvbmx5XG5cblx0XHRzZXRBdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKGRvY01vZGU4KSB7IC8vIElFOCBzZXRBdHRyaWJ1dGUgYnVnXG5cdFx0XHRcdHRoaXMuZWxlbWVudFtrZXldID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2xhc3NTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Ly8gSUU4IFN0YW5kYXJkcyBtb2RlIGhhcyBwcm9ibGVtcyByZXRyaWV2aW5nIHRoZSBjbGFzc05hbWUgdW5sZXNzIHNldCBsaWtlIHRoaXNcblx0XHRcdHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB2YWx1ZTtcblx0XHR9LFxuXHRcdGRhc2hzdHlsZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHZhciBzdHJva2VFbGVtID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3Ryb2tlJylbMF0gfHxcblx0XHRcdFx0Y3JlYXRlRWxlbWVudCh0aGlzLnJlbmRlcmVyLnByZXBWTUwoWyc8c3Ryb2tlLz4nXSksIG51bGwsIG51bGwsIGVsZW1lbnQpO1xuXHRcdFx0c3Ryb2tlRWxlbVtrZXldID0gdmFsdWUgfHwgJ3NvbGlkJztcblx0XHRcdHRoaXNba2V5XSA9IHZhbHVlOyAvKiBiZWNhdXNlIGNoYW5naW5nIHN0cm9rZS13aWR0aCB3aWxsIGNoYW5nZSB0aGUgZGFzaCBsZW5ndGhcblx0XHRcdFx0YW5kIGNhdXNlIGFuIGVwaWxlcHRpYyBlZmZlY3QgKi9cblx0XHR9LFxuXHRcdGRTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0c2hhZG93cyA9IHRoaXMuc2hhZG93cztcblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgW107XG5cdFx0XHR0aGlzLmQgPSB2YWx1ZS5qb2luICYmIHZhbHVlLmpvaW4oJyAnKTsgLy8gdXNlZCBpbiBnZXR0ZXIgZm9yIGFuaW1hdGlvblxuXG5cdFx0XHRlbGVtZW50LnBhdGggPSB2YWx1ZSA9IHRoaXMucGF0aFRvVk1MKHZhbHVlKTtcblxuXHRcdFx0Ly8gdXBkYXRlIHNoYWRvd3Ncblx0XHRcdGlmIChzaGFkb3dzKSB7XG5cdFx0XHRcdGkgPSBzaGFkb3dzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHNoYWRvd3NbaV0ucGF0aCA9IHNoYWRvd3NbaV0uY3V0T2ZmID8gdGhpcy5jdXRPZmZQYXRoKHZhbHVlLCBzaGFkb3dzW2ldLmN1dE9mZikgOiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRBdHRyKGtleSwgdmFsdWUpO1xuXHRcdH0sXG5cdFx0ZmlsbFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cdFx0XHRpZiAobm9kZU5hbWUgPT09ICdTUEFOJykgeyAvLyB0ZXh0IGNvbG9yXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUuY29sb3IgPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgIT09ICdJTUcnKSB7IC8vICMxMzM2XG5cdFx0XHRcdGVsZW1lbnQuZmlsbGVkID0gdmFsdWUgIT09IE5PTkU7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cignZmlsbGNvbG9yJywgdGhpcy5yZW5kZXJlci5jb2xvcih2YWx1ZSwgZWxlbWVudCwga2V5LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvcGFjaXR5U2V0dGVyOiBub29wLCAvLyBEb24ndCBib3RoZXIgLSBhbmltYXRpb24gaXMgdG9vIHNsb3cgYW5kIGZpbHRlcnMgaW50cm9kdWNlIGFydGlmYWN0c1xuXHRcdHJvdGF0aW9uU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0dmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblx0XHRcdHRoaXNba2V5XSA9IHN0eWxlW2tleV0gPSB2YWx1ZTsgLy8gc3R5bGUgaXMgZm9yICMxODczXG5cblx0XHRcdC8vIENvcnJlY3Rpb24gZm9yIHRoZSAxeDEgc2l6ZSBvZiB0aGUgc2hhcGUgY29udGFpbmVyLiBVc2VkIGluIGdhdWdlIG5lZWRsZXMuXG5cdFx0XHRzdHlsZS5sZWZ0ID0gLW1hdGhSb3VuZChtYXRoU2luKHZhbHVlICogZGVnMnJhZCkgKyAxKSArIFBYO1xuXHRcdFx0c3R5bGUudG9wID0gbWF0aFJvdW5kKG1hdGhDb3ModmFsdWUgKiBkZWcycmFkKSkgKyBQWDtcblx0XHR9LFxuXHRcdHN0cm9rZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHRoaXMuc2V0QXR0cignc3Ryb2tlY29sb3InLCB0aGlzLnJlbmRlcmVyLmNvbG9yKHZhbHVlLCBlbGVtZW50LCBrZXkpKTtcblx0XHR9LFxuXHRcdCdzdHJva2Utd2lkdGhTZXR0ZXInOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0ZWxlbWVudC5zdHJva2VkID0gISF2YWx1ZTsgLy8gVk1MIFwic3Ryb2tlZFwiIGF0dHJpYnV0ZVxuXHRcdFx0dGhpc1trZXldID0gdmFsdWU7IC8vIHVzZWQgaW4gZ2V0dGVyLCBpc3N1ZSAjMTEzXG5cdFx0XHRpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlICs9IFBYO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRBdHRyKCdzdHJva2V3ZWlnaHQnLCB2YWx1ZSk7XG5cdFx0fSxcblx0XHR0aXRsZVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdHRoaXMuc2V0QXR0cihrZXksIHZhbHVlKTtcblx0XHR9LFxuXHRcdHZpc2liaWxpdHlTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cblx0XHRcdC8vIEhhbmRsZSBpbmhlcml0ZWQgdmlzaWJpbGl0eVxuXHRcdFx0aWYgKHZhbHVlID09PSAnaW5oZXJpdCcpIHtcblx0XHRcdFx0dmFsdWUgPSBWSVNJQkxFO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBMZXQgdGhlIHNoYWRvdyBmb2xsb3cgdGhlIG1haW4gZWxlbWVudFxuXHRcdFx0aWYgKHRoaXMuc2hhZG93cykge1xuXHRcdFx0XHRlYWNoKHRoaXMuc2hhZG93cywgZnVuY3Rpb24gKHNoYWRvdykge1xuXHRcdFx0XHRcdHNoYWRvdy5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnN0ZWFkIG9mIHRvZ2dsaW5nIHRoZSB2aXNpYmlsaXR5IENTUyBwcm9wZXJ0eSwgbW92ZSB0aGUgZGl2IG91dCBvZiB0aGUgdmlld3BvcnQuXG5cdFx0XHQvLyBUaGlzIHdvcmtzIGFyb3VuZCAjNjEgYW5kICM1ODZcblx0XHRcdGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnRElWJykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlID09PSBISURERU4gPyAnLTk5OWVtJyA6IDA7XG5cblx0XHRcdFx0Ly8gSW4gb3JkZXIgdG8gcmVkcmF3LCBJRTcgbmVlZHMgdGhlIGRpdiB0byBiZSB2aXNpYmxlIHdoZW4gdHVja2VkIGF3YXlcblx0XHRcdFx0Ly8gb3V0c2lkZSB0aGUgdmlld3BvcnQuIFNvIHRoZSB2aXNpYmlsaXR5IGlzIGFjdHVhbGx5IG9wcG9zaXRlIG9mXG5cdFx0XHRcdC8vIHRoZSBleHBlY3RlZCB2YWx1ZS4gVGhpcyBhcHBsaWVzIHRvIHRoZSB0b29sdGlwIG9ubHkuXG5cdFx0XHRcdGlmICghZG9jTW9kZTgpIHtcblx0XHRcdFx0XHRlbGVtZW50LnN0eWxlW2tleV0gPSB2YWx1ZSA/IFZJU0lCTEUgOiBISURERU47XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0gJ3RvcCc7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50LnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHR9LFxuXHRcdHhTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTsgLy8gdXNlZCBpbiBnZXR0ZXJcblxuXHRcdFx0aWYgKGtleSA9PT0gJ3gnKSB7XG5cdFx0XHRcdGtleSA9ICdsZWZ0Jztcblx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAneScpIHtcblx0XHRcdFx0a2V5ID0gJ3RvcCc7XG5cdFx0XHR9LyogZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gbWF0aE1heCgwLCB2YWx1ZSk7IC8vIGRvbid0IHNldCB3aWR0aCBvciBoZWlnaHQgYmVsb3cgemVybyAoIzMxMSlcblx0XHRcdH0qL1xuXG5cdFx0XHQvLyBjbGlwcGluZyByZWN0YW5nbGUgc3BlY2lhbFxuXHRcdFx0aWYgKHRoaXMudXBkYXRlQ2xpcHBpbmcpIHtcblx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7IC8vIHRoZSBrZXkgaXMgbm93ICdsZWZ0JyBvciAndG9wJyBmb3IgJ3gnIGFuZCAneSdcblx0XHRcdFx0dGhpcy51cGRhdGVDbGlwcGluZygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbm9ybWFsXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ekluZGV4U2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0ZWxlbWVudC5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0fVxuXHR9O1xuXHRIaWdoY2hhcnRzLlZNTEVsZW1lbnQgPSBWTUxFbGVtZW50ID0gZXh0ZW5kQ2xhc3MoU1ZHRWxlbWVudCwgVk1MRWxlbWVudCk7XG5cblx0Ly8gU29tZSBzaGFyZWQgc2V0dGVyc1xuXHRWTUxFbGVtZW50LnByb3RvdHlwZS55U2V0dGVyID1cblx0XHRWTUxFbGVtZW50LnByb3RvdHlwZS53aWR0aFNldHRlciA9IFxuXHRcdFZNTEVsZW1lbnQucHJvdG90eXBlLmhlaWdodFNldHRlciA9IFxuXHRcdFZNTEVsZW1lbnQucHJvdG90eXBlLnhTZXR0ZXI7XG5cblxuXHQvKipcblx0ICogVGhlIFZNTCByZW5kZXJlclxuXHQgKi9cblx0dmFyIFZNTFJlbmRlcmVyRXh0ZW5zaW9uID0geyAvLyBpbmhlcml0IFNWR1JlbmRlcmVyXG5cblx0XHRFbGVtZW50OiBWTUxFbGVtZW50LFxuXHRcdGlzSUU4OiB1c2VyQWdlbnQuaW5kZXhPZignTVNJRSA4LjAnKSA+IC0xLFxuXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBWTUxSZW5kZXJlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKGNvbnRhaW5lciwgd2lkdGgsIGhlaWdodCwgc3R5bGUpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGJveFdyYXBwZXIsXG5cdFx0XHRcdGJveCxcblx0XHRcdFx0Y3NzO1xuXG5cdFx0XHRyZW5kZXJlci5hbGlnbmVkT2JqZWN0cyA9IFtdO1xuXG5cdFx0XHRib3hXcmFwcGVyID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudChESVYpXG5cdFx0XHRcdC5jc3MoZXh0ZW5kKHRoaXMuZ2V0U3R5bGUoc3R5bGUpLCB7IHBvc2l0aW9uOiBSRUxBVElWRX0pKTtcblx0XHRcdGJveCA9IGJveFdyYXBwZXIuZWxlbWVudDtcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3hXcmFwcGVyLmVsZW1lbnQpO1xuXG5cblx0XHRcdC8vIGdlbmVyYXRlIHRoZSBjb250YWluaW5nIGJveFxuXHRcdFx0cmVuZGVyZXIuaXNWTUwgPSB0cnVlO1xuXHRcdFx0cmVuZGVyZXIuYm94ID0gYm94O1xuXHRcdFx0cmVuZGVyZXIuYm94V3JhcHBlciA9IGJveFdyYXBwZXI7XG5cdFx0XHRyZW5kZXJlci5jYWNoZSA9IHt9O1xuXG5cblx0XHRcdHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCwgZmFsc2UpO1xuXG5cdFx0XHQvLyBUaGUgb25seSB3YXkgdG8gbWFrZSBJRTYgYW5kIElFNyBwcmludCBpcyB0byB1c2UgYSBnbG9iYWwgbmFtZXNwYWNlLiBIb3dldmVyLFxuXHRcdFx0Ly8gd2l0aCBJRTggdGhlIG9ubHkgd2F5IHRvIG1ha2UgdGhlIGR5bmFtaWMgc2hhcGVzIHZpc2libGUgaW4gc2NyZWVuIGFuZCBwcmludCBtb2RlXG5cdFx0XHQvLyBzZWVtcyB0byBiZSB0byBhZGQgdGhlIHhtbG5zIGF0dHJpYnV0ZSBhbmQgdGhlIGJlaGF2aW91ciBzdHlsZSBpbmxpbmUuXG5cdFx0XHRpZiAoIWRvYy5uYW1lc3BhY2VzLmhjdikge1xuXG5cdFx0XHRcdGRvYy5uYW1lc3BhY2VzLmFkZCgnaGN2JywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cblx0XHRcdFx0Ly8gU2V0dXAgZGVmYXVsdCBDU1MgKCMyMTUzLCAjMjM2OCwgIzIzODQpXG5cdFx0XHRcdGNzcyA9ICdoY3ZcXFxcOmZpbGwsIGhjdlxcXFw6cGF0aCwgaGN2XFxcXDpzaGFwZSwgaGN2XFxcXDpzdHJva2UnICtcblx0XHRcdFx0XHQneyBiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKTsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9ICc7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKS5jc3NUZXh0ID0gY3NzO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0ZG9jLnN0eWxlU2hlZXRzWzBdLmNzc1RleHQgKz0gY3NzO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBEZXRlY3Qgd2hldGhlciB0aGUgcmVuZGVyZXIgaXMgaGlkZGVuLiBUaGlzIGhhcHBlbnMgd2hlbiBvbmUgb2YgdGhlIHBhcmVudCBlbGVtZW50c1xuXHRcdCAqIGhhcyBkaXNwbGF5OiBub25lXG5cdFx0ICovXG5cdFx0aXNIaWRkZW46IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAhdGhpcy5ib3gub2Zmc2V0V2lkdGg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZSBhIGNsaXBwaW5nIHJlY3RhbmdsZS4gSW4gVk1MIGl0IGlzIGFjY29tcGxpc2hlZCBieSBzdG9yaW5nIHRoZSB2YWx1ZXNcblx0XHQgKiBmb3Igc2V0dGluZyB0aGUgQ1NTIHN0eWxlIHRvIGFsbCBhc3NvY2lhdGVkIG1lbWJlcnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHRcdCAqL1xuXHRcdGNsaXBSZWN0OiBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG5cdFx0XHQvLyBjcmVhdGUgYSBkdW1teSBlbGVtZW50XG5cdFx0XHR2YXIgY2xpcFJlY3QgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoKSxcblx0XHRcdFx0aXNPYmogPSBpc09iamVjdCh4KTtcblxuXHRcdFx0Ly8gbWltaWMgYSByZWN0YW5nbGUgd2l0aCBpdHMgc3R5bGUgb2JqZWN0IGZvciBhdXRvbWF0aWMgdXBkYXRpbmcgaW4gYXR0clxuXHRcdFx0cmV0dXJuIGV4dGVuZChjbGlwUmVjdCwge1xuXHRcdFx0XHRtZW1iZXJzOiBbXSxcblx0XHRcdFx0Y291bnQ6IDAsXG5cdFx0XHRcdGxlZnQ6IChpc09iaiA/IHgueCA6IHgpICsgMSxcblx0XHRcdFx0dG9wOiAoaXNPYmogPyB4LnkgOiB5KSArIDEsXG5cdFx0XHRcdHdpZHRoOiAoaXNPYmogPyB4LndpZHRoIDogd2lkdGgpIC0gMSxcblx0XHRcdFx0aGVpZ2h0OiAoaXNPYmogPyB4LmhlaWdodCA6IGhlaWdodCkgLSAxLFxuXHRcdFx0XHRnZXRDU1M6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdFx0XHRub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUsXG5cdFx0XHRcdFx0XHRpc1NoYXBlID0gbm9kZU5hbWUgPT09ICdzaGFwZScsXG5cdFx0XHRcdFx0XHRpbnZlcnRlZCA9IHdyYXBwZXIuaW52ZXJ0ZWQsXG5cdFx0XHRcdFx0XHRyZWN0ID0gdGhpcyxcblx0XHRcdFx0XHRcdHRvcCA9IHJlY3QudG9wIC0gKGlzU2hhcGUgPyBlbGVtZW50Lm9mZnNldFRvcCA6IDApLFxuXHRcdFx0XHRcdFx0bGVmdCA9IHJlY3QubGVmdCxcblx0XHRcdFx0XHRcdHJpZ2h0ID0gbGVmdCArIHJlY3Qud2lkdGgsXG5cdFx0XHRcdFx0XHRib3R0b20gPSB0b3AgKyByZWN0LmhlaWdodCxcblx0XHRcdFx0XHRcdHJldCA9IHtcblx0XHRcdFx0XHRcdFx0Y2xpcDogJ3JlY3QoJyArXG5cdFx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKGludmVydGVkID8gbGVmdCA6IHRvcCkgKyAncHgsJyArXG5cdFx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKGludmVydGVkID8gYm90dG9tIDogcmlnaHQpICsgJ3B4LCcgK1xuXHRcdFx0XHRcdFx0XHRcdG1hdGhSb3VuZChpbnZlcnRlZCA/IHJpZ2h0IDogYm90dG9tKSArICdweCwnICtcblx0XHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoaW52ZXJ0ZWQgPyB0b3AgOiBsZWZ0KSArICdweCknXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gaXNzdWUgNzQgd29ya2Fyb3VuZFxuXHRcdFx0XHRcdGlmICghaW52ZXJ0ZWQgJiYgZG9jTW9kZTggJiYgbm9kZU5hbWUgPT09ICdESVYnKSB7XG5cdFx0XHRcdFx0XHRleHRlbmQocmV0LCB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiByaWdodCArIFBYLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGJvdHRvbSArIFBYXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyB1c2VkIGluIGF0dHIgYW5kIGFuaW1hdGlvbiB0byB1cGRhdGUgdGhlIGNsaXBwaW5nIG9mIGFsbCBtZW1iZXJzXG5cdFx0XHRcdHVwZGF0ZUNsaXBwaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0ZWFjaChjbGlwUmVjdC5tZW1iZXJzLCBmdW5jdGlvbiAobWVtYmVyKSB7XG5cdFx0XHRcdFx0XHRpZiAobWVtYmVyLmVsZW1lbnQpIHsgLy8gRGVsZXRlZCBzZXJpZXMsIGxpa2UgaW4gc3RvY2svbWVtYmVycy9zZXJpZXMtcmVtb3ZlIGRlbW8uIFNob3VsZCBiZSByZW1vdmVkIGZyb20gbWVtYmVycywgYnV0IHRoaXMgd2lsbCBkby5cblx0XHRcdFx0XHRcdFx0bWVtYmVyLmNzcyhjbGlwUmVjdC5nZXRDU1MobWVtYmVyKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogVGFrZSBhIGNvbG9yIGFuZCByZXR1cm4gaXQgaWYgaXQncyBhIHN0cmluZywgbWFrZSBpdCBhIGdyYWRpZW50IGlmIGl0J3MgYVxuXHRcdCAqIGdyYWRpZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBhbmQgYXBwbHkgb3BhY2l0eS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvciBUaGUgY29sb3Igb3IgY29uZmlnIG9iamVjdFxuXHRcdCAqL1xuXHRcdGNvbG9yOiBmdW5jdGlvbiAoY29sb3IsIGVsZW0sIHByb3AsIHdyYXBwZXIpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGNvbG9yT2JqZWN0LFxuXHRcdFx0XHRyZWdleFJnYmEgPSAvXnJnYmEvLFxuXHRcdFx0XHRtYXJrdXAsXG5cdFx0XHRcdGZpbGxUeXBlLFxuXHRcdFx0XHRyZXQgPSBOT05FO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgbGluZWFyIG9yIHJhZGlhbCBncmFkaWVudFxuXHRcdFx0aWYgKGNvbG9yICYmIGNvbG9yLmxpbmVhckdyYWRpZW50KSB7XG5cdFx0XHRcdGZpbGxUeXBlID0gJ2dyYWRpZW50Jztcblx0XHRcdH0gZWxzZSBpZiAoY29sb3IgJiYgY29sb3IucmFkaWFsR3JhZGllbnQpIHtcblx0XHRcdFx0ZmlsbFR5cGUgPSAncGF0dGVybic7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKGZpbGxUeXBlKSB7XG5cblx0XHRcdFx0dmFyIHN0b3BDb2xvcixcblx0XHRcdFx0XHRzdG9wT3BhY2l0eSxcblx0XHRcdFx0XHRncmFkaWVudCA9IGNvbG9yLmxpbmVhckdyYWRpZW50IHx8IGNvbG9yLnJhZGlhbEdyYWRpZW50LFxuXHRcdFx0XHRcdHgxLFxuXHRcdFx0XHRcdHkxLFxuXHRcdFx0XHRcdHgyLFxuXHRcdFx0XHRcdHkyLFxuXHRcdFx0XHRcdG9wYWNpdHkxLFxuXHRcdFx0XHRcdG9wYWNpdHkyLFxuXHRcdFx0XHRcdGNvbG9yMSxcblx0XHRcdFx0XHRjb2xvcjIsXG5cdFx0XHRcdFx0ZmlsbEF0dHIgPSAnJyxcblx0XHRcdFx0XHRzdG9wcyA9IGNvbG9yLnN0b3BzLFxuXHRcdFx0XHRcdGZpcnN0U3RvcCxcblx0XHRcdFx0XHRsYXN0U3RvcCxcblx0XHRcdFx0XHRjb2xvcnMgPSBbXSxcblx0XHRcdFx0XHRhZGRGaWxsTm9kZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8vIEFkZCB0aGUgZmlsbCBzdWJub2RlLiBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcblx0XHRcdFx0XHRcdC8vIGFyZSByZXZlcnNlZC5cblx0XHRcdFx0XHRcdG1hcmt1cCA9IFsnPGZpbGwgY29sb3JzPVwiJyArIGNvbG9ycy5qb2luKCcsJykgKyAnXCIgb3BhY2l0eT1cIicsIG9wYWNpdHkyLCAnXCIgbzpvcGFjaXR5Mj1cIicsIG9wYWNpdHkxLFxuXHRcdFx0XHRcdFx0XHQnXCIgdHlwZT1cIicsIGZpbGxUeXBlLCAnXCIgJywgZmlsbEF0dHIsICdmb2N1cz1cIjEwMCVcIiBtZXRob2Q9XCJhbnlcIiAvPiddO1xuXHRcdFx0XHRcdFx0Y3JlYXRlRWxlbWVudChyZW5kZXJlci5wcmVwVk1MKG1hcmt1cCksIG51bGwsIG51bGwsIGVsZW0pO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gRXh0ZW5kIGZyb20gMCB0byAxXG5cdFx0XHRcdGZpcnN0U3RvcCA9IHN0b3BzWzBdO1xuXHRcdFx0XHRsYXN0U3RvcCA9IHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRpZiAoZmlyc3RTdG9wWzBdID4gMCkge1xuXHRcdFx0XHRcdHN0b3BzLnVuc2hpZnQoW1xuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdGZpcnN0U3RvcFsxXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsYXN0U3RvcFswXSA8IDEpIHtcblx0XHRcdFx0XHRzdG9wcy5wdXNoKFtcblx0XHRcdFx0XHRcdDEsXG5cdFx0XHRcdFx0XHRsYXN0U3RvcFsxXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29tcHV0ZSB0aGUgc3RvcHNcblx0XHRcdFx0ZWFjaChzdG9wcywgZnVuY3Rpb24gKHN0b3AsIGkpIHtcblx0XHRcdFx0XHRpZiAocmVnZXhSZ2JhLnRlc3Qoc3RvcFsxXSkpIHtcblx0XHRcdFx0XHRcdGNvbG9yT2JqZWN0ID0gQ29sb3Ioc3RvcFsxXSk7XG5cdFx0XHRcdFx0XHRzdG9wQ29sb3IgPSBjb2xvck9iamVjdC5nZXQoJ3JnYicpO1xuXHRcdFx0XHRcdFx0c3RvcE9wYWNpdHkgPSBjb2xvck9iamVjdC5nZXQoJ2EnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcFsxXTtcblx0XHRcdFx0XHRcdHN0b3BPcGFjaXR5ID0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBCdWlsZCB0aGUgY29sb3IgYXR0cmlidXRlXG5cdFx0XHRcdFx0Y29sb3JzLnB1c2goKHN0b3BbMF0gKiAxMDApICsgJyUgJyArIHN0b3BDb2xvcik7XG5cblx0XHRcdFx0XHQvLyBPbmx5IHN0YXJ0IGFuZCBlbmQgb3BhY2l0aWVzIGFyZSBhbGxvd2VkLCBzbyB3ZSB1c2UgdGhlIGZpcnN0IGFuZCB0aGUgbGFzdFxuXHRcdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTEgPSBzdG9wT3BhY2l0eTtcblx0XHRcdFx0XHRcdGNvbG9yMiA9IHN0b3BDb2xvcjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTIgPSBzdG9wT3BhY2l0eTtcblx0XHRcdFx0XHRcdGNvbG9yMSA9IHN0b3BDb2xvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIEFwcGx5IHRoZSBncmFkaWVudCB0byBmaWxscyBvbmx5LlxuXHRcdFx0XHRpZiAocHJvcCA9PT0gJ2ZpbGwnKSB7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgbGluZWFyIGdyYWRpZW50IGFuZ2xlXG5cdFx0XHRcdFx0aWYgKGZpbGxUeXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdFx0XHR4MSA9IGdyYWRpZW50LngxIHx8IGdyYWRpZW50WzBdIHx8IDA7XG5cdFx0XHRcdFx0XHR5MSA9IGdyYWRpZW50LnkxIHx8IGdyYWRpZW50WzFdIHx8IDA7XG5cdFx0XHRcdFx0XHR4MiA9IGdyYWRpZW50LngyIHx8IGdyYWRpZW50WzJdIHx8IDA7XG5cdFx0XHRcdFx0XHR5MiA9IGdyYWRpZW50LnkyIHx8IGdyYWRpZW50WzNdIHx8IDA7XG5cdFx0XHRcdFx0XHRmaWxsQXR0ciA9ICdhbmdsZT1cIicgKyAoOTAgIC0gbWF0aC5hdGFuKFxuXHRcdFx0XHRcdFx0XHQoeTIgLSB5MSkgLyAvLyB5IHZlY3RvclxuXHRcdFx0XHRcdFx0XHQoeDIgLSB4MSkgLy8geCB2ZWN0b3Jcblx0XHRcdFx0XHRcdFx0KSAqIDE4MCAvIG1hdGhQSSkgKyAnXCInO1xuXG5cdFx0XHRcdFx0XHRhZGRGaWxsTm9kZSgpO1xuXG5cdFx0XHRcdFx0Ly8gUmFkaWFsIChjaXJjdWxhcikgZ3JhZGllbnRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2YXIgciA9IGdyYWRpZW50LnIsXG5cdFx0XHRcdFx0XHRcdHNpemV4ID0gciAqIDIsXG5cdFx0XHRcdFx0XHRcdHNpemV5ID0gciAqIDIsXG5cdFx0XHRcdFx0XHRcdGN4ID0gZ3JhZGllbnQuY3gsXG5cdFx0XHRcdFx0XHRcdGN5ID0gZ3JhZGllbnQuY3ksXG5cdFx0XHRcdFx0XHRcdHJhZGlhbFJlZmVyZW5jZSA9IGVsZW0ucmFkaWFsUmVmZXJlbmNlLFxuXHRcdFx0XHRcdFx0XHRiQm94LFxuXHRcdFx0XHRcdFx0XHRhcHBseVJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyYWRpYWxSZWZlcmVuY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJCb3ggPSB3cmFwcGVyLmdldEJCb3goKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN4ICs9IChyYWRpYWxSZWZlcmVuY2VbMF0gLSBiQm94LngpIC8gYkJveC53aWR0aCAtIDAuNTtcblx0XHRcdFx0XHRcdFx0XHRcdGN5ICs9IChyYWRpYWxSZWZlcmVuY2VbMV0gLSBiQm94LnkpIC8gYkJveC5oZWlnaHQgLSAwLjU7XG5cdFx0XHRcdFx0XHRcdFx0XHRzaXpleCAqPSByYWRpYWxSZWZlcmVuY2VbMl0gLyBiQm94LndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdFx0c2l6ZXkgKj0gcmFkaWFsUmVmZXJlbmNlWzJdIC8gYkJveC5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGZpbGxBdHRyID0gJ3NyYz1cIicgKyBkZWZhdWx0T3B0aW9ucy5nbG9iYWwuVk1MUmFkaWFsR3JhZGllbnRVUkwgKyAnXCIgJyArXG5cdFx0XHRcdFx0XHRcdFx0XHQnc2l6ZT1cIicgKyBzaXpleCArICcsJyArIHNpemV5ICsgJ1wiICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J29yaWdpbj1cIjAuNSwwLjVcIiAnICtcblx0XHRcdFx0XHRcdFx0XHRcdCdwb3NpdGlvbj1cIicgKyBjeCArICcsJyArIGN5ICsgJ1wiICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J2NvbG9yMj1cIicgKyBjb2xvcjIgKyAnXCIgJztcblxuXHRcdFx0XHRcdFx0XHRcdGFkZEZpbGxOb2RlKCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIEFwcGx5IHJhZGlhbCBncmFkaWVudFxuXHRcdFx0XHRcdFx0aWYgKHdyYXBwZXIuYWRkZWQpIHtcblx0XHRcdFx0XHRcdFx0YXBwbHlSYWRpYWxHcmFkaWVudCgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBrbm93IHRoZSBib3VuZGluZyBib3ggdG8gZ2V0IHRoZSBzaXplIGFuZCBwb3NpdGlvbiByaWdodFxuXHRcdFx0XHRcdFx0XHR3cmFwcGVyLm9uQWRkID0gYXBwbHlSYWRpYWxHcmFkaWVudDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVGhlIGZpbGwgZWxlbWVudCdzIGNvbG9yIGF0dHJpYnV0ZSBpcyBicm9rZW4gaW4gSUU4IHN0YW5kYXJkcyBtb2RlLCBzbyB3ZVxuXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byBzZXQgdGhlIHBhcmVudCBzaGFwZSdzIGZpbGxjb2xvciBhdHRyaWJ1dGUgaW5zdGVhZC5cblx0XHRcdFx0XHRcdHJldCA9IGNvbG9yMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR3JhZGllbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBWTUwgc3Ryb2tlLCByZXR1cm4gdGhlIGZpcnN0IGNvbG9yLiAjNzIyLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldCA9IHN0b3BDb2xvcjtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGUgY29sb3IgaXMgYW4gcmdiYSBjb2xvciwgc3BsaXQgaXQgYW5kIGFkZCBhIGZpbGwgbm9kZVxuXHRcdFx0Ly8gdG8gaG9sZCB0aGUgb3BhY2l0eSBjb21wb25lbnRcblx0XHRcdH0gZWxzZSBpZiAocmVnZXhSZ2JhLnRlc3QoY29sb3IpICYmIGVsZW0udGFnTmFtZSAhPT0gJ0lNRycpIHtcblxuXHRcdFx0XHRjb2xvck9iamVjdCA9IENvbG9yKGNvbG9yKTtcblxuXHRcdFx0XHRtYXJrdXAgPSBbJzwnLCBwcm9wLCAnIG9wYWNpdHk9XCInLCBjb2xvck9iamVjdC5nZXQoJ2EnKSwgJ1wiLz4nXTtcblx0XHRcdFx0Y3JlYXRlRWxlbWVudCh0aGlzLnByZXBWTUwobWFya3VwKSwgbnVsbCwgbnVsbCwgZWxlbSk7XG5cblx0XHRcdFx0cmV0ID0gY29sb3JPYmplY3QuZ2V0KCdyZ2InKTtcblxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcHJvcE5vZGVzID0gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShwcm9wKTsgLy8gJ3N0cm9rZScgb3IgJ2ZpbGwnIG5vZGVcblx0XHRcdFx0aWYgKHByb3BOb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRwcm9wTm9kZXNbMF0ub3BhY2l0eSA9IDE7XG5cdFx0XHRcdFx0cHJvcE5vZGVzWzBdLnR5cGUgPSAnc29saWQnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldCA9IGNvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUYWtlIGEgVk1MIHN0cmluZyBhbmQgcHJlcGFyZSBpdCBmb3IgZWl0aGVyIElFOCBvciBJRTYvSUU3LlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IG1hcmt1cCBBIHN0cmluZyBhcnJheSBvZiB0aGUgVk1MIG1hcmt1cCB0byBwcmVwYXJlXG5cdFx0ICovXG5cdFx0cHJlcFZNTDogZnVuY3Rpb24gKG1hcmt1cCkge1xuXHRcdFx0dmFyIHZtbFN0eWxlID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpOycsXG5cdFx0XHRcdGlzSUU4ID0gdGhpcy5pc0lFODtcblxuXHRcdFx0bWFya3VwID0gbWFya3VwLmpvaW4oJycpO1xuXG5cdFx0XHRpZiAoaXNJRTgpIHsgLy8gYWRkIHhtbG5zIGFuZCBzdHlsZSBpbmxpbmVcblx0XHRcdFx0bWFya3VwID0gbWFya3VwLnJlcGxhY2UoJy8+JywgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sXCIgLz4nKTtcblx0XHRcdFx0aWYgKG1hcmt1cC5pbmRleE9mKCdzdHlsZT1cIicpID09PSAtMSkge1xuXHRcdFx0XHRcdG1hcmt1cCA9IG1hcmt1cC5yZXBsYWNlKCcvPicsICcgc3R5bGU9XCInICsgdm1sU3R5bGUgKyAnXCIgLz4nKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZSgnc3R5bGU9XCInLCAnc3R5bGU9XCInICsgdm1sU3R5bGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7IC8vIGFkZCBuYW1lc3BhY2Vcblx0XHRcdFx0bWFya3VwID0gbWFya3VwLnJlcGxhY2UoJzwnLCAnPGhjdjonKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hcmt1cDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHJvdGF0ZWQgYW5kIGFsaWduZWQgdGV4dFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICovXG5cdFx0dGV4dDogU1ZHUmVuZGVyZXIucHJvdG90eXBlLmh0bWwsXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYW5kIHJldHVybiBhIHBhdGggZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcblx0XHQgKi9cblx0XHRwYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHRcdFx0dmFyIGF0dHIgPSB7XG5cdFx0XHRcdC8vIHN1YnBpeGVsIHByZWNpc2lvbiBkb3duIHRvIDAuMSAod2lkdGggYW5kIGhlaWdodCA9IDFweClcblx0XHRcdFx0Y29vcmRzaXplOiAnMTAgMTAnXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGlzQXJyYXkocGF0aCkpIHtcblx0XHRcdFx0YXR0ci5kID0gcGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaXNPYmplY3QocGF0aCkpIHsgLy8gYXR0cmlidXRlc1xuXHRcdFx0XHRleHRlbmQoYXR0ciwgcGF0aCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgdGhlIHNoYXBlXG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KCdzaGFwZScpLmF0dHIoYXR0cik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgY2lyY2xlIGVsZW1lbnQuIEluIFZNTCBjaXJjbGVzIGFyZSBpbXBsZW1lbnRlZCBhc1xuXHRcdCAqIHNoYXBlcywgd2hpY2ggaXMgZmFzdGVyIHRoYW4gdjpvdmFsXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSByXG5cdFx0ICovXG5cdFx0Y2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgcikge1xuXHRcdFx0dmFyIGNpcmNsZSA9IHRoaXMuc3ltYm9sKCdjaXJjbGUnKTtcblx0XHRcdGlmIChpc09iamVjdCh4KSkge1xuXHRcdFx0XHRyID0geC5yO1xuXHRcdFx0XHR5ID0geC55O1xuXHRcdFx0XHR4ID0geC54O1xuXHRcdFx0fVxuXHRcdFx0Y2lyY2xlLmlzQ2lyY2xlID0gdHJ1ZTsgLy8gQ2F1c2VzIHggYW5kIHkgdG8gbWVhbiBjZW50ZXIgKCMxNjgyKVxuXHRcdFx0Y2lyY2xlLnIgPSByO1xuXHRcdFx0cmV0dXJuIGNpcmNsZS5hdHRyKHsgeDogeCwgeTogeSB9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgZ3JvdXAgdXNpbmcgYW4gb3V0ZXIgZGl2IGFuZCBhbiBpbm5lciB2Omdyb3VwIHRvIGFsbG93IHJvdGF0aW5nXG5cdFx0ICogYW5kIGZsaXBwaW5nLiBBIHNpbXBsZSB2Omdyb3VwIHdvdWxkIGhhdmUgcHJvYmxlbXMgd2l0aCBwb3NpdGlvbmluZ1xuXHRcdCAqIGNoaWxkIEhUTUwgZWxlbWVudHMgYW5kIENTUyBjbGlwLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGdyb3VwXG5cdFx0ICovXG5cdFx0ZzogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHZhciB3cmFwcGVyLFxuXHRcdFx0XHRhdHRyaWJzO1xuXG5cdFx0XHQvLyBzZXQgdGhlIGNsYXNzIG5hbWVcblx0XHRcdGlmIChuYW1lKSB7XG5cdFx0XHRcdGF0dHJpYnMgPSB7ICdjbGFzc05hbWUnOiBQUkVGSVggKyBuYW1lLCAnY2xhc3MnOiBQUkVGSVggKyBuYW1lIH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRoZSBkaXYgdG8gaG9sZCBIVE1MIGFuZCBjbGlwcGluZ1xuXHRcdFx0d3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudChESVYpLmF0dHIoYXR0cmlicyk7XG5cblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBWTUwgb3ZlcnJpZGUgdG8gY3JlYXRlIGEgcmVndWxhciBIVE1MIGltYWdlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICovXG5cdFx0aW1hZ2U6IGZ1bmN0aW9uIChzcmMsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdHZhciBvYmogPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG5cdFx0XHRcdC5hdHRyKHsgc3JjOiBzcmMgfSk7XG5cblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRvYmouYXR0cih7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvciByZWN0YW5nbGVzLCBWTUwgdXNlcyBhIHNoYXBlIGZvciByZWN0IHRvIG92ZXJjb21lIGJ1Z3MgYW5kIHJvdGF0aW9uIHByb2JsZW1zXG5cdFx0ICovXG5cdFx0Y3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWUgPT09ICdyZWN0JyA/IHRoaXMuc3ltYm9sKG5vZGVOYW1lKSA6IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbm9kZU5hbWUpO1x0XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEluIHRoZSBWTUwgcmVuZGVyZXIsIGVhY2ggY2hpbGQgb2YgYW4gaW52ZXJ0ZWQgZGl2IChncm91cCkgaXMgaW52ZXJ0ZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnROb2RlXG5cdFx0ICovXG5cdFx0aW52ZXJ0Q2hpbGQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnROb2RlKSB7XG5cdFx0XHR2YXIgcmVuID0gdGhpcyxcblx0XHRcdFx0cGFyZW50U3R5bGUgPSBwYXJlbnROb2RlLnN0eWxlLFxuXHRcdFx0XHRpbWdTdHlsZSA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lNRycgJiYgZWxlbWVudC5zdHlsZTsgLy8gIzExMTFcblxuXHRcdFx0Y3NzKGVsZW1lbnQsIHtcblx0XHRcdFx0ZmxpcDogJ3gnLFxuXHRcdFx0XHRsZWZ0OiBwSW50KHBhcmVudFN0eWxlLndpZHRoKSAtIChpbWdTdHlsZSA/IHBJbnQoaW1nU3R5bGUudG9wKSA6IDEpLFxuXHRcdFx0XHR0b3A6IHBJbnQocGFyZW50U3R5bGUuaGVpZ2h0KSAtIChpbWdTdHlsZSA/IHBJbnQoaW1nU3R5bGUubGVmdCkgOiAxKSxcblx0XHRcdFx0cm90YXRpb246IC05MFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFJlY3Vyc2l2ZWx5IGludmVydCBjaGlsZCBlbGVtZW50cywgbmVlZGVkIGZvciBuZXN0ZWQgY29tcG9zaXRlIHNoYXBlcyBsaWtlIGJveCBwbG90cyBhbmQgZXJyb3IgYmFycy4gIzE2ODAsICMxODA2LlxuXHRcdFx0ZWFjaChlbGVtZW50LmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHRyZW4uaW52ZXJ0Q2hpbGQoY2hpbGQsIGVsZW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFN5bWJvbCBkZWZpbml0aW9ucyB0aGF0IG92ZXJyaWRlIHRoZSBwYXJlbnQgU1ZHIHJlbmRlcmVyJ3Mgc3ltYm9sc1xuXHRcdCAqXG5cdFx0ICovXG5cdFx0c3ltYm9sczoge1xuXHRcdFx0Ly8gVk1MIHNwZWNpZmljIGFyYyBmdW5jdGlvblxuXHRcdFx0YXJjOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBvcHRpb25zLnN0YXJ0LFxuXHRcdFx0XHRcdGVuZCA9IG9wdGlvbnMuZW5kLFxuXHRcdFx0XHRcdHJhZGl1cyA9IG9wdGlvbnMuciB8fCB3IHx8IGgsXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXMgPSBvcHRpb25zLmlubmVyUixcblx0XHRcdFx0XHRjb3NTdGFydCA9IG1hdGhDb3Moc3RhcnQpLFxuXHRcdFx0XHRcdHNpblN0YXJ0ID0gbWF0aFNpbihzdGFydCksXG5cdFx0XHRcdFx0Y29zRW5kID0gbWF0aENvcyhlbmQpLFxuXHRcdFx0XHRcdHNpbkVuZCA9IG1hdGhTaW4oZW5kKSxcblx0XHRcdFx0XHRyZXQ7XG5cblx0XHRcdFx0aWYgKGVuZCAtIHN0YXJ0ID09PSAwKSB7IC8vIG5vIGFuZ2xlLCBkb24ndCBzaG93IGl0LlxuXHRcdFx0XHRcdHJldHVybiBbJ3gnXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IFtcblx0XHRcdFx0XHQnd2EnLCAvLyBjbG9ja3dpc2UgYXJjIHRvXG5cdFx0XHRcdFx0eCAtIHJhZGl1cywgLy8gbGVmdFxuXHRcdFx0XHRcdHkgLSByYWRpdXMsIC8vIHRvcFxuXHRcdFx0XHRcdHggKyByYWRpdXMsIC8vIHJpZ2h0XG5cdFx0XHRcdFx0eSArIHJhZGl1cywgLy8gYm90dG9tXG5cdFx0XHRcdFx0eCArIHJhZGl1cyAqIGNvc1N0YXJ0LCAvLyBzdGFydCB4XG5cdFx0XHRcdFx0eSArIHJhZGl1cyAqIHNpblN0YXJ0LCAvLyBzdGFydCB5XG5cdFx0XHRcdFx0eCArIHJhZGl1cyAqIGNvc0VuZCwgLy8gZW5kIHhcblx0XHRcdFx0XHR5ICsgcmFkaXVzICogc2luRW5kICAvLyBlbmQgeVxuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLm9wZW4gJiYgIWlubmVyUmFkaXVzKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goXG5cdFx0XHRcdFx0XHQnZScsXG5cdFx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdFx0eCwvLyAtIGlubmVyUmFkaXVzLFxuXHRcdFx0XHRcdFx0eS8vIC0gaW5uZXJSYWRpdXNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0LnB1c2goXG5cdFx0XHRcdFx0J2F0JywgLy8gYW50aSBjbG9ja3dpc2UgYXJjIHRvXG5cdFx0XHRcdFx0eCAtIGlubmVyUmFkaXVzLCAvLyBsZWZ0XG5cdFx0XHRcdFx0eSAtIGlubmVyUmFkaXVzLCAvLyB0b3Bcblx0XHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMsIC8vIHJpZ2h0XG5cdFx0XHRcdFx0eSArIGlubmVyUmFkaXVzLCAvLyBib3R0b21cblx0XHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMgKiBjb3NFbmQsIC8vIHN0YXJ0IHhcblx0XHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5FbmQsIC8vIHN0YXJ0IHlcblx0XHRcdFx0XHR4ICsgaW5uZXJSYWRpdXMgKiBjb3NTdGFydCwgLy8gZW5kIHhcblx0XHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMgKiBzaW5TdGFydCwgLy8gZW5kIHlcblx0XHRcdFx0XHQneCcsIC8vIGZpbmlzaCBwYXRoXG5cdFx0XHRcdFx0J2UnIC8vIGNsb3NlXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cmV0LmlzQXJjID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSxcblx0XHRcdC8vIEFkZCBjaXJjbGUgc3ltYm9sIHBhdGguIFRoaXMgcGVyZm9ybXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgdGhhbiB2Om92YWwuXG5cdFx0XHRjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCB3cmFwcGVyKSB7XG5cblx0XHRcdFx0aWYgKHdyYXBwZXIpIHtcblx0XHRcdFx0XHR3ID0gaCA9IDIgKiB3cmFwcGVyLnI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDZW50ZXIgY29ycmVjdGlvbiwgIzE2ODJcblx0XHRcdFx0aWYgKHdyYXBwZXIgJiYgd3JhcHBlci5pc0NpcmNsZSkge1xuXHRcdFx0XHRcdHggLT0gdyAvIDI7XG5cdFx0XHRcdFx0eSAtPSBoIC8gMjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiB0aGUgcGF0aFxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdCd3YScsIC8vIGNsb2Nrd2lzZWFyY3RvXG5cdFx0XHRcdFx0eCwgLy8gbGVmdFxuXHRcdFx0XHRcdHksIC8vIHRvcFxuXHRcdFx0XHRcdHggKyB3LCAvLyByaWdodFxuXHRcdFx0XHRcdHkgKyBoLCAvLyBib3R0b21cblx0XHRcdFx0XHR4ICsgdywgLy8gc3RhcnQgeFxuXHRcdFx0XHRcdHkgKyBoIC8gMiwgICAgIC8vIHN0YXJ0IHlcblx0XHRcdFx0XHR4ICsgdywgLy8gZW5kIHhcblx0XHRcdFx0XHR5ICsgaCAvIDIsICAgICAvLyBlbmQgeVxuXHRcdFx0XHRcdC8vJ3gnLCAvLyBmaW5pc2ggcGF0aFxuXHRcdFx0XHRcdCdlJyAvLyBjbG9zZVxuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkIHJlY3RhbmdsZSBzeW1ib2wgcGF0aCB3aGljaCBlYXNlcyByb3RhdGlvbiBhbmQgb21pdHMgYXJjc2l6ZSBwcm9ibGVtc1xuXHRcdFx0ICogY29tcGFyZWQgdG8gdGhlIGJ1aWx0LWluIFZNTCByb3VuZHJlY3Qgc2hhcGUuIFdoZW4gYm9yZGVycyBhcmUgbm90IHJvdW5kZWQsXG5cdFx0XHQgKiB1c2UgdGhlIHNpbXBsZXIgc3F1YXJlIHBhdGgsIGVsc2UgdXNlIHRoZSBjYWxsb3V0IHBhdGggd2l0aG91dCB0aGUgYXJyb3cuXG5cdFx0XHQgKi9cblx0XHRcdHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHRcdHJldHVybiBTVkdSZW5kZXJlci5wcm90b3R5cGUuc3ltYm9sc1tcblx0XHRcdFx0XHQhZGVmaW5lZChvcHRpb25zKSB8fCAhb3B0aW9ucy5yID8gJ3NxdWFyZScgOiAnY2FsbG91dCdcblx0XHRcdFx0XS5jYWxsKDAsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0SGlnaGNoYXJ0cy5WTUxSZW5kZXJlciA9IFZNTFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXHRWTUxSZW5kZXJlci5wcm90b3R5cGUgPSBtZXJnZShTVkdSZW5kZXJlci5wcm90b3R5cGUsIFZNTFJlbmRlcmVyRXh0ZW5zaW9uKTtcblxuXHRcdC8vIGdlbmVyYWwgcmVuZGVyZXJcblx0XHRSZW5kZXJlciA9IFZNTFJlbmRlcmVyO1xuXHR9XG5cblx0Ly8gVGhpcyBtZXRob2QgaXMgdXNlZCB3aXRoIGV4cG9ydGluZyBpbiBvbGQgSUUsIHdoZW4gZW11bGF0aW5nIFNWRyAoc2VlICMyMzE0KVxuXHRTVkdSZW5kZXJlci5wcm90b3R5cGUubWVhc3VyZVNwYW5XaWR0aCA9IGZ1bmN0aW9uICh0ZXh0LCBzdHlsZXMpIHtcblx0XHR2YXIgbWVhc3VyaW5nU3BhbiA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyksXG5cdFx0XHRvZmZzZXRXaWR0aCxcblx0XHR0ZXh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcblxuXHRcdG1lYXN1cmluZ1NwYW4uYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuXHRcdGNzcyhtZWFzdXJpbmdTcGFuLCBzdHlsZXMpO1xuXHRcdHRoaXMuYm94LmFwcGVuZENoaWxkKG1lYXN1cmluZ1NwYW4pO1xuXHRcdG9mZnNldFdpZHRoID0gbWVhc3VyaW5nU3Bhbi5vZmZzZXRXaWR0aDtcblx0XHRkaXNjYXJkRWxlbWVudChtZWFzdXJpbmdTcGFuKTsgLy8gIzI0NjNcblx0XHRyZXR1cm4gb2Zmc2V0V2lkdGg7XG5cdH07XG5cblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICogRU5EIE9GIElOVEVSTkVUIEVYUExPUkVSIDw9IDggU1BFQ0lGSUMgQ09ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqIFNUQVJUIE9GIEFORFJPSUQgPCAzIFNQRUNJRklDIENPREUuIFRISVMgQ0FOIEJFIFJFTU9WRUQgSUYgWU9VJ1JFIE5PVCAgICAgICpcblx0ICogVEFSR0VUSU5HIFRIQVQgU1lTVEVNLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0dmFyIENhblZHUmVuZGVyZXIsXG5cdFx0Q2FuVkdDb250cm9sbGVyO1xuXG5cdGlmICh1c2VDYW5WRykge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBDYW5WR1JlbmRlcmVyIGlzIGVtcHR5IGZyb20gc3RhcnQgdG8ga2VlcCB0aGUgc291cmNlIGZvb3RwcmludCBzbWFsbC5cblx0XHQgKiBXaGVuIHJlcXVlc3RlZCwgdGhlIENhblZHQ29udHJvbGxlciBkb3dubG9hZHMgdGhlIHJlc3Qgb2YgdGhlIHNvdXJjZSBwYWNrYWdlZFxuXHRcdCAqIHRvZ2V0aGVyIHdpdGggdGhlIGNhbnZnIGxpYnJhcnkuXG5cdFx0ICovXG5cdFx0SGlnaGNoYXJ0cy5DYW5WR1JlbmRlcmVyID0gQ2FuVkdSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIE92ZXJyaWRlIHRoZSBnbG9iYWwgU1ZHIG5hbWVzcGFjZSB0byBmYWtlIFNWRy9IVE1MIHRoYXQgYWNjZXB0cyBDU1Ncblx0XHRcdFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogU3RhcnQgd2l0aCBhbiBlbXB0eSBzeW1ib2xzIG9iamVjdC4gVGhpcyBpcyBuZWVkZWQgd2hlbiBleHBvcnRpbmcgaXMgdXNlZCAoZXhwb3J0aW5nLnNyYy5qcyB3aWxsIGFkZCBhIGZldyBzeW1ib2xzKSwgYnV0IFxuXHRcdCAqIHRoZSBpbXBsZW1lbnRhdGlvbiBmcm9tIFN2Z1JlbmRlcmVyIHdpbGwgbm90IGJlIG1lcmdlZCBpbiB1bnRpbCBmaXJzdCByZW5kZXIuXG5cdFx0ICovXG5cdFx0Q2FuVkdSZW5kZXJlci5wcm90b3R5cGUuc3ltYm9scyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlcyBvbiBkZW1hbmQgZG93bmxvYWQgb2YgY2FudmcgcmVuZGVyaW5nIHN1cHBvcnQuXG5cdFx0ICovXG5cdFx0Q2FuVkdDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIExpc3Qgb2YgcmVuZGVyZXJpbmcgY2FsbHNcblx0XHRcdHZhciBkZWZlcnJlZFJlbmRlckNhbGxzID0gW107XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogV2hlbiBkb3dubG9hZGVkLCB3ZSBhcmUgcmVhZHkgdG8gZHJhdyBkZWZlcnJlZCBjaGFydHMuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIGRyYXdEZWZlcnJlZCgpIHtcblx0XHRcdFx0dmFyIGNhbGxMZW5ndGggPSBkZWZlcnJlZFJlbmRlckNhbGxzLmxlbmd0aCxcblx0XHRcdFx0XHRjYWxsSW5kZXg7XG5cblx0XHRcdFx0Ly8gRHJhdyBhbGwgcGVuZGluZyByZW5kZXIgY2FsbHNcblx0XHRcdFx0Zm9yIChjYWxsSW5kZXggPSAwOyBjYWxsSW5kZXggPCBjYWxsTGVuZ3RoOyBjYWxsSW5kZXgrKykge1xuXHRcdFx0XHRcdGRlZmVycmVkUmVuZGVyQ2FsbHNbY2FsbEluZGV4XSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENsZWFyIHRoZSBsaXN0XG5cdFx0XHRcdGRlZmVycmVkUmVuZGVyQ2FsbHMgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cHVzaDogZnVuY3Rpb24gKGZ1bmMsIHNjcmlwdExvY2F0aW9uKSB7XG5cdFx0XHRcdFx0Ly8gT25seSBnZXQgdGhlIHNjcmlwdCBvbmNlXG5cdFx0XHRcdFx0aWYgKGRlZmVycmVkUmVuZGVyQ2FsbHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRnZXRTY3JpcHQoc2NyaXB0TG9jYXRpb24sIGRyYXdEZWZlcnJlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFJlZ2lzdGVyIHJlbmRlciBjYWxsXG5cdFx0XHRcdFx0ZGVmZXJyZWRSZW5kZXJDYWxscy5wdXNoKGZ1bmMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0oKSk7XG5cblx0XHRSZW5kZXJlciA9IENhblZHUmVuZGVyZXI7XG5cdH0gLy8gZW5kIENhblZHUmVuZGVyZXJcblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICogRU5EIE9GIEFORFJPSUQgPCAzIFNQRUNJRklDIENPREUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvKipcblx0ICogVGhlIFRpY2sgY2xhc3Ncblx0ICovXG5cdGZ1bmN0aW9uIFRpY2soYXhpcywgcG9zLCB0eXBlLCBub0xhYmVsKSB7XG5cdFx0dGhpcy5heGlzID0gYXhpcztcblx0XHR0aGlzLnBvcyA9IHBvcztcblx0XHR0aGlzLnR5cGUgPSB0eXBlIHx8ICcnO1xuXHRcdHRoaXMuaXNOZXcgPSB0cnVlO1xuXG5cdFx0aWYgKCF0eXBlICYmICFub0xhYmVsKSB7XG5cdFx0XHR0aGlzLmFkZExhYmVsKCk7XG5cdFx0fVxuXHR9XG5cblx0VGljay5wcm90b3R5cGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogV3JpdGUgdGhlIHRpY2sgbGFiZWxcblx0XHQgKi9cblx0XHRhZGRMYWJlbDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRpY2sgPSB0aGlzLFxuXHRcdFx0XHRheGlzID0gdGljay5heGlzLFxuXHRcdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRcdGNhdGVnb3JpZXMgPSBheGlzLmNhdGVnb3JpZXMsXG5cdFx0XHRcdG5hbWVzID0gYXhpcy5uYW1lcyxcblx0XHRcdFx0cG9zID0gdGljay5wb3MsXG5cdFx0XHRcdGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWxzLFxuXHRcdFx0XHRzdHIsXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSBheGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHRcdGlzRmlyc3QgPSBwb3MgPT09IHRpY2tQb3NpdGlvbnNbMF0sXG5cdFx0XHRcdGlzTGFzdCA9IHBvcyA9PT0gdGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdLFxuXHRcdFx0XHR2YWx1ZSA9IGNhdGVnb3JpZXMgP1xuXHRcdFx0XHRcdHBpY2soY2F0ZWdvcmllc1twb3NdLCBuYW1lc1twb3NdLCBwb3MpIDpcblx0XHRcdFx0XHRwb3MsXG5cdFx0XHRcdGxhYmVsID0gdGljay5sYWJlbCxcblx0XHRcdFx0dGlja1Bvc2l0aW9uSW5mbyA9IHRpY2tQb3NpdGlvbnMuaW5mbyxcblx0XHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdDtcblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRldGltZSBsYWJlbCBmb3JtYXQuIElmIGEgaGlnaGVyIHJhbmsgaXMgc2V0IGZvciB0aGlzIHBvc2l0aW9uLCB1c2UgdGhhdC4gSWYgbm90LFxuXHRcdFx0Ly8gdXNlIHRoZSBnZW5lcmFsIGZvcm1hdC5cblx0XHRcdGlmIChheGlzLmlzRGF0ZXRpbWVBeGlzICYmIHRpY2tQb3NpdGlvbkluZm8pIHtcblx0XHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdCA9IG9wdGlvbnMuZGF0ZVRpbWVMYWJlbEZvcm1hdHNbdGlja1Bvc2l0aW9uSW5mby5oaWdoZXJSYW5rc1twb3NdIHx8IHRpY2tQb3NpdGlvbkluZm8udW5pdE5hbWVdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc2V0IHByb3BlcnRpZXMgZm9yIGFjY2VzcyBpbiByZW5kZXIgbWV0aG9kXG5cdFx0XHR0aWNrLmlzRmlyc3QgPSBpc0ZpcnN0O1xuXHRcdFx0dGljay5pc0xhc3QgPSBpc0xhc3Q7XG5cblx0XHRcdC8vIGdldCB0aGUgc3RyaW5nXG5cdFx0XHRzdHIgPSBheGlzLmxhYmVsRm9ybWF0dGVyLmNhbGwoe1xuXHRcdFx0XHRheGlzOiBheGlzLFxuXHRcdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRcdGlzRmlyc3Q6IGlzRmlyc3QsXG5cdFx0XHRcdGlzTGFzdDogaXNMYXN0LFxuXHRcdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0OiBkYXRlVGltZUxhYmVsRm9ybWF0LFxuXHRcdFx0XHR2YWx1ZTogYXhpcy5pc0xvZyA/IGNvcnJlY3RGbG9hdChsaW4ybG9nKHZhbHVlKSkgOiB2YWx1ZVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHByZXBhcmUgQ1NTXG5cdFx0XHQvL2NzcyA9IHdpZHRoICYmIHsgd2lkdGg6IG1hdGhNYXgoMSwgbWF0aFJvdW5kKHdpZHRoIC0gMiAqIChsYWJlbE9wdGlvbnMucGFkZGluZyB8fCAxMCkpKSArIFBYIH07XG5cdFx0XHRcblx0XHRcdC8vIGZpcnN0IGNhbGxcblx0XHRcdGlmICghZGVmaW5lZChsYWJlbCkpIHtcblxuXHRcdFx0XHR0aWNrLmxhYmVsID0gbGFiZWwgPVxuXHRcdFx0XHRcdGRlZmluZWQoc3RyKSAmJiBsYWJlbE9wdGlvbnMuZW5hYmxlZCA/XG5cdFx0XHRcdFx0XHRjaGFydC5yZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0XHRcdHN0cixcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWxPcHRpb25zLnVzZUhUTUxcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQvLy5hdHRyKGF0dHIpXG5cdFx0XHRcdFx0XHRcdC8vIHdpdGhvdXQgcG9zaXRpb24gYWJzb2x1dGUsIElFIGV4cG9ydCBzb21ldGltZXMgaXMgd3Jvbmdcblx0XHRcdFx0XHRcdFx0LmNzcyhtZXJnZShsYWJlbE9wdGlvbnMuc3R5bGUpKVxuXHRcdFx0XHRcdFx0XHQuYWRkKGF4aXMubGFiZWxHcm91cCkgOlxuXHRcdFx0XHRcdFx0bnVsbDtcblx0XHRcdFx0dGljay5sYWJlbExlbmd0aCA9IGxhYmVsICYmIGxhYmVsLmdldEJCb3goKS53aWR0aDsgLy8gVW4tcm90YXRlZCBsZW5ndGhcblx0XHRcdFx0dGljay5yb3RhdGlvbiA9IDA7IC8vIEJhc2UgdmFsdWUgdG8gZGV0ZWN0IGNoYW5nZSBmb3IgbmV3IGNhbGxzIHRvIGdldEJCb3hcblxuXHRcdFx0Ly8gdXBkYXRlXG5cdFx0XHR9IGVsc2UgaWYgKGxhYmVsKSB7XG5cdFx0XHRcdGxhYmVsLmF0dHIoeyB0ZXh0OiBzdHIgfSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgb2Zmc2V0IGhlaWdodCBvciB3aWR0aCBvZiB0aGUgbGFiZWxcblx0XHQgKi9cblx0XHRnZXRMYWJlbFNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmxhYmVsID9cblx0XHRcdFx0dGhpcy5sYWJlbC5nZXRCQm94KClbdGhpcy5heGlzLmhvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnXSA6XG5cdFx0XHRcdDA7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSB0aGUgbGFiZWwgb3ZlcmZsb3cgYnkgYWRqdXN0aW5nIHRoZSBsYWJlbHMgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IGVkZ2UsIG9yXG5cdFx0ICogaGlkZSB0aGVtIGlmIHRoZXkgY29sbGlkZSBpbnRvIHRoZSBuZWlnaGJvdXIgbGFiZWwuXG5cdFx0ICovXG5cdFx0aGFuZGxlT3ZlcmZsb3c6IGZ1bmN0aW9uICh4eSkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLmF4aXMsXG5cdFx0XHRcdHB4UG9zID0geHkueCxcblx0XHRcdFx0Y2hhcnRXaWR0aCA9IGF4aXMuY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdFx0c3BhY2luZyA9IGF4aXMuY2hhcnQuc3BhY2luZyxcblx0XHRcdFx0bGVmdEJvdW5kID0gcGljayhheGlzLmxhYmVsTGVmdCwgc3BhY2luZ1szXSksXG5cdFx0XHRcdHJpZ2h0Qm91bmQgPSBwaWNrKGF4aXMubGFiZWxSaWdodCwgY2hhcnRXaWR0aCAtIHNwYWNpbmdbMV0pLFxuXHRcdFx0XHRsYWJlbCA9IHRoaXMubGFiZWwsXG5cdFx0XHRcdHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcblx0XHRcdFx0ZmFjdG9yID0geyBsZWZ0OiAwLCBjZW50ZXI6IDAuNSwgcmlnaHQ6IDEgfVtheGlzLmxhYmVsQWxpZ25dLFxuXHRcdFx0XHRsYWJlbFdpZHRoID0gbGFiZWwuZ2V0QkJveCgpLndpZHRoLFxuXHRcdFx0XHRzbG90V2lkdGggPSBheGlzLnNsb3RXaWR0aCxcblx0XHRcdFx0bGVmdFBvcyxcblx0XHRcdFx0cmlnaHRQb3MsXG5cdFx0XHRcdHRleHRXaWR0aDtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIGxhYmVsIG92ZXJzaG9vdHMgdGhlIGNoYXJ0IHNwYWNpbmcgYm94LiBJZiBpdCBkb2VzLCBtb3ZlIGl0LlxuXHRcdFx0Ly8gSWYgaXQgbm93IG92ZXJzaG9vdHMgdGhlIHNsb3RXaWR0aCwgYWRkIGVsbGlwc2lzLlxuXHRcdFx0aWYgKCFyb3RhdGlvbikge1xuXHRcdFx0XHRsZWZ0UG9zID0gcHhQb3MgLSBmYWN0b3IgKiBsYWJlbFdpZHRoO1xuXHRcdFx0XHRyaWdodFBvcyA9IHB4UG9zICsgZmFjdG9yICogbGFiZWxXaWR0aDtcblxuXHRcdFx0XHRpZiAobGVmdFBvcyA8IGxlZnRCb3VuZCkge1xuXHRcdFx0XHRcdHNsb3RXaWR0aCAtPSBsZWZ0Qm91bmQgLSBsZWZ0UG9zO1xuXHRcdFx0XHRcdHh5LnggPSBsZWZ0Qm91bmQ7XG5cdFx0XHRcdFx0bGFiZWwuYXR0cih7IGFsaWduOiAnbGVmdCcgfSk7XHRcdFx0XHRcblx0XHRcdFx0fSBlbHNlIGlmIChyaWdodFBvcyA+IHJpZ2h0Qm91bmQpIHtcblx0XHRcdFx0XHRzbG90V2lkdGggLT0gcmlnaHRQb3MgLSByaWdodEJvdW5kO1xuXHRcdFx0XHRcdHh5LnggPSByaWdodEJvdW5kO1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIoeyBhbGlnbjogJ3JpZ2h0JyB9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsYWJlbFdpZHRoID4gc2xvdFdpZHRoKSB7XG5cdFx0XHRcdFx0dGV4dFdpZHRoID0gc2xvdFdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcblxuXHRcdFx0Ly8gQWRkIGVsbGlwc2lzIHRvIHByZXZlbnQgcm90YXRlZCBsYWJlbHMgdG8gYmUgY2xpcHBlZCBhZ2FpbnN0IHRoZSBlZGdlIG9mIHRoZSBjaGFydFxuXHRcdFx0fSBlbHNlIGlmIChyb3RhdGlvbiA8IDAgJiYgcHhQb3MgLSBmYWN0b3IgKiBsYWJlbFdpZHRoIDwgbGVmdEJvdW5kKSB7XG5cdFx0XHRcdHRleHRXaWR0aCA9IG1hdGhSb3VuZChweFBvcyAvIG1hdGhDb3Mocm90YXRpb24gKiBkZWcycmFkKSAtIGxlZnRCb3VuZCk7XG5cdFx0XHR9IGVsc2UgaWYgKHJvdGF0aW9uID4gMCAmJiBweFBvcyArIGZhY3RvciAqIGxhYmVsV2lkdGggPiByaWdodEJvdW5kKSB7XG5cdFx0XHRcdHRleHRXaWR0aCA9IG1hdGhSb3VuZCgoY2hhcnRXaWR0aCAtIHB4UG9zKSAvIG1hdGhDb3Mocm90YXRpb24gKiBkZWcycmFkKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0ZXh0V2lkdGgpIHtcblx0XHRcdFx0bGFiZWwuY3NzKHtcblx0XHRcdFx0XHR3aWR0aDogdGV4dFdpZHRoLFxuXHRcdFx0XHRcdHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSB4IGFuZCB5IHBvc2l0aW9uIGZvciB0aWNrcyBhbmQgbGFiZWxzXG5cdFx0ICovXG5cdFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChob3JpeiwgcG9zLCB0aWNrbWFya09mZnNldCwgb2xkKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRjSGVpZ2h0ID0gKG9sZCAmJiBjaGFydC5vbGRDaGFydEhlaWdodCkgfHwgY2hhcnQuY2hhcnRIZWlnaHQ7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGhvcml6ID9cblx0XHRcdFx0XHRheGlzLnRyYW5zbGF0ZShwb3MgKyB0aWNrbWFya09mZnNldCwgbnVsbCwgbnVsbCwgb2xkKSArIGF4aXMudHJhbnNCIDpcblx0XHRcdFx0XHRheGlzLmxlZnQgKyBheGlzLm9mZnNldCArIChheGlzLm9wcG9zaXRlID8gKChvbGQgJiYgY2hhcnQub2xkQ2hhcnRXaWR0aCkgfHwgY2hhcnQuY2hhcnRXaWR0aCkgLSBheGlzLnJpZ2h0IC0gYXhpcy5sZWZ0IDogMCksXG5cblx0XHRcdFx0eTogaG9yaXogP1xuXHRcdFx0XHRcdGNIZWlnaHQgLSBheGlzLmJvdHRvbSArIGF4aXMub2Zmc2V0IC0gKGF4aXMub3Bwb3NpdGUgPyBheGlzLmhlaWdodCA6IDApIDpcblx0XHRcdFx0XHRjSGVpZ2h0IC0gYXhpcy50cmFuc2xhdGUocG9zICsgdGlja21hcmtPZmZzZXQsIG51bGwsIG51bGwsIG9sZCkgLSBheGlzLnRyYW5zQlxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHgsIHkgcG9zaXRpb24gb2YgdGhlIHRpY2sgbGFiZWxcblx0XHQgKi9cblx0XHRnZXRMYWJlbFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSwgbGFiZWwsIGhvcml6LCBsYWJlbE9wdGlvbnMsIHRpY2ttYXJrT2Zmc2V0LCBpbmRleCwgc3RlcCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLmF4aXMsXG5cdFx0XHRcdHRyYW5zQSA9IGF4aXMudHJhbnNBLFxuXHRcdFx0XHRyZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQsXG5cdFx0XHRcdHN0YWdnZXJMaW5lcyA9IGF4aXMuc3RhZ2dlckxpbmVzLFxuXHRcdFx0XHRyb3RDb3JyID0gYXhpcy50aWNrUm90Q29yciB8fCB7IHg6IDAsIHk6IDAgfSxcblx0XHRcdFx0eU9mZnNldCA9IHBpY2sobGFiZWxPcHRpb25zLnksIHJvdENvcnIueSArIChheGlzLnNpZGUgPT09IDIgPyA4IDogLShsYWJlbC5nZXRCQm94KCkuaGVpZ2h0IC8gMikpKSxcblx0XHRcdFx0bGluZTtcblxuXHRcdFx0eCA9IHggKyBsYWJlbE9wdGlvbnMueCArIHJvdENvcnIueCAtICh0aWNrbWFya09mZnNldCAmJiBob3JpeiA/XG5cdFx0XHRcdHRpY2ttYXJrT2Zmc2V0ICogdHJhbnNBICogKHJldmVyc2VkID8gLTEgOiAxKSA6IDApO1xuXHRcdFx0eSA9IHkgKyB5T2Zmc2V0IC0gKHRpY2ttYXJrT2Zmc2V0ICYmICFob3JpeiA/XG5cdFx0XHRcdHRpY2ttYXJrT2Zmc2V0ICogdHJhbnNBICogKHJldmVyc2VkID8gMSA6IC0xKSA6IDApO1xuXG5cdFx0XHQvLyBDb3JyZWN0IGZvciBzdGFnZ2VyZWQgbGFiZWxzXG5cdFx0XHRpZiAoc3RhZ2dlckxpbmVzKSB7XG5cdFx0XHRcdGxpbmUgPSAoaW5kZXggLyAoc3RlcCB8fCAxKSAlIHN0YWdnZXJMaW5lcyk7XG5cdFx0XHRcdHkgKz0gbGluZSAqIChheGlzLmxhYmVsT2Zmc2V0IC8gc3RhZ2dlckxpbmVzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogbWF0aFJvdW5kKHkpXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHRlbmRpYmxlIG1ldGhvZCB0byByZXR1cm4gdGhlIHBhdGggb2YgdGhlIG1hcmtlclxuXHRcdCAqL1xuXHRcdGdldE1hcmtQYXRoOiBmdW5jdGlvbiAoeCwgeSwgdGlja0xlbmd0aCwgdGlja1dpZHRoLCBob3JpeiwgcmVuZGVyZXIpIHtcblx0XHRcdHJldHVybiByZW5kZXJlci5jcmlzcExpbmUoW1xuXHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0eCxcblx0XHRcdFx0XHR5LFxuXHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0eCArIChob3JpeiA/IDAgOiAtdGlja0xlbmd0aCksXG5cdFx0XHRcdFx0eSArIChob3JpeiA/IHRpY2tMZW5ndGggOiAwKVxuXHRcdFx0XHRdLCB0aWNrV2lkdGgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQdXQgZXZlcnl0aGluZyBpbiBwbGFjZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9XG5cdFx0ICogQHBhcmFtIG9sZCB7Qm9vbGVhbn0gVXNlIG9sZCBjb29yZGluYXRlcyB0byBwcmVwYXJlIGFuIGFuaW1hdGlvbiBpbnRvIG5ldyBwb3NpdGlvblxuXHRcdCAqL1xuXHRcdHJlbmRlcjogZnVuY3Rpb24gKGluZGV4LCBvbGQsIG9wYWNpdHkpIHtcblx0XHRcdHZhciB0aWNrID0gdGhpcyxcblx0XHRcdFx0YXhpcyA9IHRpY2suYXhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdHR5cGUgPSB0aWNrLnR5cGUsXG5cdFx0XHRcdGxhYmVsID0gdGljay5sYWJlbCxcblx0XHRcdFx0cG9zID0gdGljay5wb3MsXG5cdFx0XHRcdGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWxzLFxuXHRcdFx0XHRncmlkTGluZSA9IHRpY2suZ3JpZExpbmUsXG5cdFx0XHRcdGdyaWRQcmVmaXggPSB0eXBlID8gdHlwZSArICdHcmlkJyA6ICdncmlkJyxcblx0XHRcdFx0dGlja1ByZWZpeCA9IHR5cGUgPyB0eXBlICsgJ1RpY2snIDogJ3RpY2snLFxuXHRcdFx0XHRncmlkTGluZVdpZHRoID0gb3B0aW9uc1tncmlkUHJlZml4ICsgJ0xpbmVXaWR0aCddLFxuXHRcdFx0XHRncmlkTGluZUNvbG9yID0gb3B0aW9uc1tncmlkUHJlZml4ICsgJ0xpbmVDb2xvciddLFxuXHRcdFx0XHRkYXNoU3R5bGUgPSBvcHRpb25zW2dyaWRQcmVmaXggKyAnTGluZURhc2hTdHlsZSddLFxuXHRcdFx0XHR0aWNrTGVuZ3RoID0gb3B0aW9uc1t0aWNrUHJlZml4ICsgJ0xlbmd0aCddLFxuXHRcdFx0XHR0aWNrV2lkdGggPSBvcHRpb25zW3RpY2tQcmVmaXggKyAnV2lkdGgnXSB8fCAwLFxuXHRcdFx0XHR0aWNrQ29sb3IgPSBvcHRpb25zW3RpY2tQcmVmaXggKyAnQ29sb3InXSxcblx0XHRcdFx0dGlja1Bvc2l0aW9uID0gb3B0aW9uc1t0aWNrUHJlZml4ICsgJ1Bvc2l0aW9uJ10sXG5cdFx0XHRcdGdyaWRMaW5lUGF0aCxcblx0XHRcdFx0bWFyayA9IHRpY2subWFyayxcblx0XHRcdFx0bWFya1BhdGgsXG5cdFx0XHRcdHN0ZXAgPSAvKmF4aXMubGFiZWxTdGVwIHx8ICovbGFiZWxPcHRpb25zLnN0ZXAsXG5cdFx0XHRcdGF0dHJpYnMsXG5cdFx0XHRcdHNob3cgPSB0cnVlLFxuXHRcdFx0XHR0aWNrbWFya09mZnNldCA9IGF4aXMudGlja21hcmtPZmZzZXQsXG5cdFx0XHRcdHh5ID0gdGljay5nZXRQb3NpdGlvbihob3JpeiwgcG9zLCB0aWNrbWFya09mZnNldCwgb2xkKSxcblx0XHRcdFx0eCA9IHh5LngsXG5cdFx0XHRcdHkgPSB4eS55LFxuXHRcdFx0XHRyZXZlcnNlQ3Jpc3AgPSAoKGhvcml6ICYmIHggPT09IGF4aXMucG9zICsgYXhpcy5sZW4pIHx8ICghaG9yaXogJiYgeSA9PT0gYXhpcy5wb3MpKSA/IC0xIDogMTsgLy8gIzE0ODAsICMxNjg3XG5cblx0XHRcdG9wYWNpdHkgPSBwaWNrKG9wYWNpdHksIDEpO1xuXHRcdFx0dGhpcy5pc0FjdGl2ZSA9IHRydWU7XG5cblx0XHRcdC8vIGNyZWF0ZSB0aGUgZ3JpZCBsaW5lXG5cdFx0XHRpZiAoZ3JpZExpbmVXaWR0aCkge1xuXHRcdFx0XHRncmlkTGluZVBhdGggPSBheGlzLmdldFBsb3RMaW5lUGF0aChwb3MgKyB0aWNrbWFya09mZnNldCwgZ3JpZExpbmVXaWR0aCAqIHJldmVyc2VDcmlzcCwgb2xkLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoZ3JpZExpbmUgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdGF0dHJpYnMgPSB7XG5cdFx0XHRcdFx0XHRzdHJva2U6IGdyaWRMaW5lQ29sb3IsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogZ3JpZExpbmVXaWR0aFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKGRhc2hTdHlsZSkge1xuXHRcdFx0XHRcdFx0YXR0cmlicy5kYXNoc3R5bGUgPSBkYXNoU3R5bGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdFx0YXR0cmlicy56SW5kZXggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAob2xkKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzLm9wYWNpdHkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aWNrLmdyaWRMaW5lID0gZ3JpZExpbmUgPVxuXHRcdFx0XHRcdFx0Z3JpZExpbmVXaWR0aCA/XG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnBhdGgoZ3JpZExpbmVQYXRoKVxuXHRcdFx0XHRcdFx0XHRcdC5hdHRyKGF0dHJpYnMpLmFkZChheGlzLmdyaWRHcm91cCkgOlxuXHRcdFx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHBhcmFtZXRlciAnb2xkJyBpcyBzZXQsIHRoZSBjdXJyZW50IGNhbGwgd2lsbCBiZSBmb2xsb3dlZFxuXHRcdFx0XHQvLyBieSBhbm90aGVyIGNhbGwsIHRoZXJlZm9yZSBkbyBub3QgZG8gYW55IGFuaW1hdGlvbnMgdGhpcyB0aW1lXG5cdFx0XHRcdGlmICghb2xkICYmIGdyaWRMaW5lICYmIGdyaWRMaW5lUGF0aCkge1xuXHRcdFx0XHRcdGdyaWRMaW5lW3RpY2suaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKHtcblx0XHRcdFx0XHRcdGQ6IGdyaWRMaW5lUGF0aCxcblx0XHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgdGhlIHRpY2sgbWFya1xuXHRcdFx0aWYgKHRpY2tXaWR0aCAmJiB0aWNrTGVuZ3RoKSB7XG5cblx0XHRcdFx0Ly8gbmVnYXRlIHRoZSBsZW5ndGhcblx0XHRcdFx0aWYgKHRpY2tQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcblx0XHRcdFx0XHR0aWNrTGVuZ3RoID0gLXRpY2tMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGF4aXMub3Bwb3NpdGUpIHtcblx0XHRcdFx0XHR0aWNrTGVuZ3RoID0gLXRpY2tMZW5ndGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXJrUGF0aCA9IHRpY2suZ2V0TWFya1BhdGgoeCwgeSwgdGlja0xlbmd0aCwgdGlja1dpZHRoICogcmV2ZXJzZUNyaXNwLCBob3JpeiwgcmVuZGVyZXIpO1xuXHRcdFx0XHRpZiAobWFyaykgeyAvLyB1cGRhdGluZ1xuXHRcdFx0XHRcdG1hcmsuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0XHRkOiBtYXJrUGF0aCxcblx0XHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHsgLy8gZmlyc3QgdGltZVxuXHRcdFx0XHRcdHRpY2subWFyayA9IHJlbmRlcmVyLnBhdGgoXG5cdFx0XHRcdFx0XHRtYXJrUGF0aFxuXHRcdFx0XHRcdCkuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6IHRpY2tDb2xvcixcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiB0aWNrV2lkdGgsXG5cdFx0XHRcdFx0XHRvcGFjaXR5OiBvcGFjaXR5XG5cdFx0XHRcdFx0fSkuYWRkKGF4aXMuYXhpc0dyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0aGUgbGFiZWwgaXMgY3JlYXRlZCBvbiBpbml0IC0gbm93IG1vdmUgaXQgaW50byBwbGFjZVxuXHRcdFx0aWYgKGxhYmVsICYmICFpc05hTih4KSkge1xuXHRcdFx0XHRsYWJlbC54eSA9IHh5ID0gdGljay5nZXRMYWJlbFBvc2l0aW9uKHgsIHksIGxhYmVsLCBob3JpeiwgbGFiZWxPcHRpb25zLCB0aWNrbWFya09mZnNldCwgaW5kZXgsIHN0ZXApO1xuXG5cdFx0XHRcdC8vIEFwcGx5IHNob3cgZmlyc3QgYW5kIHNob3cgbGFzdC4gSWYgdGhlIHRpY2sgaXMgYm90aCBmaXJzdCBhbmQgbGFzdCwgaXQgaXNcblx0XHRcdFx0Ly8gYSBzaW5nbGUgY2VudGVyZWQgdGljaywgaW4gd2hpY2ggY2FzZSB3ZSBzaG93IHRoZSBsYWJlbCBhbnl3YXkgKCMyMTAwKS5cblx0XHRcdFx0aWYgKCh0aWNrLmlzRmlyc3QgJiYgIXRpY2suaXNMYXN0ICYmICFwaWNrKG9wdGlvbnMuc2hvd0ZpcnN0TGFiZWwsIDEpKSB8fFxuXHRcdFx0XHRcdFx0KHRpY2suaXNMYXN0ICYmICF0aWNrLmlzRmlyc3QgJiYgIXBpY2sob3B0aW9ucy5zaG93TGFzdExhYmVsLCAxKSkpIHtcblx0XHRcdFx0XHRzaG93ID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGxhYmVsIG92ZXJmbG93IGFuZCBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHlcblx0XHRcdFx0fSBlbHNlIGlmIChob3JpeiAmJiAhYXhpcy5pc1JhZGlhbCAmJiAhbGFiZWxPcHRpb25zLnN0ZXAgJiYgIWxhYmVsT3B0aW9ucy5yb3RhdGlvbiAmJiAhb2xkICYmIG9wYWNpdHkgIT09IDApIHtcblx0XHRcdFx0XHR0aWNrLmhhbmRsZU92ZXJmbG93KHh5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IHN0ZXBcblx0XHRcdFx0aWYgKHN0ZXAgJiYgaW5kZXggJSBzdGVwKSB7XG5cdFx0XHRcdFx0Ly8gc2hvdyB0aG9zZSBpbmRpY2VzIGRpdmlkYWJsZSBieSBzdGVwXG5cdFx0XHRcdFx0c2hvdyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBuZXcgcG9zaXRpb24sIGFuZCBzaG93IG9yIGhpZGVcblx0XHRcdFx0aWYgKHNob3cgJiYgIWlzTmFOKHh5LnkpKSB7XG5cdFx0XHRcdFx0eHkub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0XHRcdFx0bGFiZWxbdGljay5pc05ldyA/ICdhdHRyJyA6ICdhbmltYXRlJ10oeHkpO1xuXHRcdFx0XHRcdHRpY2suaXNOZXcgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsYWJlbC5hdHRyKCd5JywgLTk5OTkpOyAvLyAjMTMzOFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3RydWN0b3IgZm9yIHRoZSB0aWNrIHByb3RvdHlwZVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHRoaXMsIHRoaXMuYXhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgb2JqZWN0IHdyYXBwZXIgZm9yIHBsb3QgbGluZXMgYW5kIHBsb3QgYmFuZHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICovXG5cdEhpZ2hjaGFydHMuUGxvdExpbmVPckJhbmQgPSBmdW5jdGlvbiAoYXhpcywgb3B0aW9ucykge1xuXHRcdHRoaXMuYXhpcyA9IGF4aXM7XG5cblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuXHRcdH1cblx0fTtcblxuXHRIaWdoY2hhcnRzLlBsb3RMaW5lT3JCYW5kLnByb3RvdHlwZSA9IHtcblx0XHRcblx0XHQvKipcblx0XHQgKiBSZW5kZXIgdGhlIHBsb3QgbGluZSBvciBwbG90IGJhbmQuIElmIGl0IGlzIGFscmVhZHkgZXhpc3RpbmcsXG5cdFx0ICogbW92ZSBpdC5cblx0XHQgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwbG90TGluZSA9IHRoaXMsXG5cdFx0XHRcdGF4aXMgPSBwbG90TGluZS5heGlzLFxuXHRcdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdG9wdGlvbnMgPSBwbG90TGluZS5vcHRpb25zLFxuXHRcdFx0XHRvcHRpb25zTGFiZWwgPSBvcHRpb25zLmxhYmVsLFxuXHRcdFx0XHRsYWJlbCA9IHBsb3RMaW5lLmxhYmVsLFxuXHRcdFx0XHR3aWR0aCA9IG9wdGlvbnMud2lkdGgsXG5cdFx0XHRcdHRvID0gb3B0aW9ucy50byxcblx0XHRcdFx0ZnJvbSA9IG9wdGlvbnMuZnJvbSxcblx0XHRcdFx0aXNCYW5kID0gZGVmaW5lZChmcm9tKSAmJiBkZWZpbmVkKHRvKSxcblx0XHRcdFx0dmFsdWUgPSBvcHRpb25zLnZhbHVlLFxuXHRcdFx0XHRkYXNoU3R5bGUgPSBvcHRpb25zLmRhc2hTdHlsZSxcblx0XHRcdFx0c3ZnRWxlbSA9IHBsb3RMaW5lLnN2Z0VsZW0sXG5cdFx0XHRcdHBhdGggPSBbXSxcblx0XHRcdFx0YWRkRXZlbnQsXG5cdFx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdFx0eHMsXG5cdFx0XHRcdHlzLFxuXHRcdFx0XHR4LFxuXHRcdFx0XHR5LFxuXHRcdFx0XHRjb2xvciA9IG9wdGlvbnMuY29sb3IsXG5cdFx0XHRcdHpJbmRleCA9IG9wdGlvbnMuekluZGV4LFxuXHRcdFx0XHRldmVudHMgPSBvcHRpb25zLmV2ZW50cyxcblx0XHRcdFx0YXR0cmlicyA9IHt9LFxuXHRcdFx0XHRyZW5kZXJlciA9IGF4aXMuY2hhcnQucmVuZGVyZXI7XG5cblx0XHRcdC8vIGxvZ2FyaXRobWljIGNvbnZlcnNpb25cblx0XHRcdGlmIChheGlzLmlzTG9nKSB7XG5cdFx0XHRcdGZyb20gPSBsb2cybGluKGZyb20pO1xuXHRcdFx0XHR0byA9IGxvZzJsaW4odG8pO1xuXHRcdFx0XHR2YWx1ZSA9IGxvZzJsaW4odmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwbG90IGxpbmVcblx0XHRcdGlmICh3aWR0aCkge1xuXHRcdFx0XHRwYXRoID0gYXhpcy5nZXRQbG90TGluZVBhdGgodmFsdWUsIHdpZHRoKTtcblx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRzdHJva2U6IGNvbG9yLFxuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiB3aWR0aFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoZGFzaFN0eWxlKSB7XG5cdFx0XHRcdFx0YXR0cmlicy5kYXNoc3R5bGUgPSBkYXNoU3R5bGU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoaXNCYW5kKSB7IC8vIHBsb3QgYmFuZFxuXG5cdFx0XHRcdHBhdGggPSBheGlzLmdldFBsb3RCYW5kUGF0aChmcm9tLCB0bywgb3B0aW9ucyk7XG5cdFx0XHRcdGlmIChjb2xvcikge1xuXHRcdFx0XHRcdGF0dHJpYnMuZmlsbCA9IGNvbG9yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcHRpb25zLmJvcmRlcldpZHRoKSB7XG5cdFx0XHRcdFx0YXR0cmlicy5zdHJva2UgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuXHRcdFx0XHRcdGF0dHJpYnNbJ3N0cm9rZS13aWR0aCddID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gekluZGV4XG5cdFx0XHRpZiAoZGVmaW5lZCh6SW5kZXgpKSB7XG5cdFx0XHRcdGF0dHJpYnMuekluZGV4ID0gekluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb21tb24gZm9yIGxpbmVzIGFuZCBiYW5kc1xuXHRcdFx0aWYgKHN2Z0VsZW0pIHtcblx0XHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0XHRzdmdFbGVtLmFuaW1hdGUoe1xuXHRcdFx0XHRcdFx0ZDogcGF0aFxuXHRcdFx0XHRcdH0sIG51bGwsIHN2Z0VsZW0ub25HZXRQYXRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdmdFbGVtLmhpZGUoKTtcblx0XHRcdFx0XHRzdmdFbGVtLm9uR2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHN2Z0VsZW0uc2hvdygpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0XHRwbG90TGluZS5sYWJlbCA9IGxhYmVsID0gbGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChwYXRoICYmIHBhdGgubGVuZ3RoKSB7XG5cdFx0XHRcdHBsb3RMaW5lLnN2Z0VsZW0gPSBzdmdFbGVtID0gcmVuZGVyZXIucGF0aChwYXRoKVxuXHRcdFx0XHRcdC5hdHRyKGF0dHJpYnMpLmFkZCgpO1xuXG5cdFx0XHRcdC8vIGV2ZW50c1xuXHRcdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdFx0YWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG5cdFx0XHRcdFx0XHRzdmdFbGVtLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnRzW2V2ZW50VHlwZV0uYXBwbHkocGxvdExpbmUsIFtlXSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHRcdFx0YWRkRXZlbnQoZXZlbnRUeXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhlIHBsb3QgYmFuZC9saW5lIGxhYmVsXG5cdFx0XHRpZiAob3B0aW9uc0xhYmVsICYmIGRlZmluZWQob3B0aW9uc0xhYmVsLnRleHQpICYmIHBhdGggJiYgcGF0aC5sZW5ndGggJiYgYXhpcy53aWR0aCA+IDAgJiYgYXhpcy5oZWlnaHQgPiAwKSB7XG5cdFx0XHRcdC8vIGFwcGx5IGRlZmF1bHRzXG5cdFx0XHRcdG9wdGlvbnNMYWJlbCA9IG1lcmdlKHtcblx0XHRcdFx0XHRhbGlnbjogaG9yaXogJiYgaXNCYW5kICYmICdjZW50ZXInLFxuXHRcdFx0XHRcdHg6IGhvcml6ID8gIWlzQmFuZCAmJiA0IDogMTAsXG5cdFx0XHRcdFx0dmVydGljYWxBbGlnbiA6ICFob3JpeiAmJiBpc0JhbmQgJiYgJ21pZGRsZScsXG5cdFx0XHRcdFx0eTogaG9yaXogPyBpc0JhbmQgPyAxNiA6IDEwIDogaXNCYW5kID8gNiA6IC00LFxuXHRcdFx0XHRcdHJvdGF0aW9uOiBob3JpeiAmJiAhaXNCYW5kICYmIDkwXG5cdFx0XHRcdH0sIG9wdGlvbnNMYWJlbCk7XG5cblx0XHRcdFx0Ly8gYWRkIHRoZSBTVkcgZWxlbWVudFxuXHRcdFx0XHRpZiAoIWxhYmVsKSB7XG5cdFx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRcdGFsaWduOiBvcHRpb25zTGFiZWwudGV4dEFsaWduIHx8IG9wdGlvbnNMYWJlbC5hbGlnbixcblx0XHRcdFx0XHRcdHJvdGF0aW9uOiBvcHRpb25zTGFiZWwucm90YXRpb25cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmIChkZWZpbmVkKHpJbmRleCkpIHtcblx0XHRcdFx0XHRcdGF0dHJpYnMuekluZGV4ID0gekluZGV4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwbG90TGluZS5sYWJlbCA9IGxhYmVsID0gcmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRcdFx0b3B0aW9uc0xhYmVsLnRleHQsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnNMYWJlbC51c2VIVE1MXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXR0cihhdHRyaWJzKVxuXHRcdFx0XHRcdFx0LmNzcyhvcHRpb25zTGFiZWwuc3R5bGUpXG5cdFx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBhbmQgYWxpZ24gdGhlIGxhYmVsXG5cdFx0XHRcdC8vICMzMDAwIGNoYW5nZWQgdG8gYmV0dGVyIGhhbmRsZSBjaG9pY2UgYmV0d2VlbiBwbG90YmFuZCBvciBwbG90bGluZVxuXHRcdFx0XHR4cyA9IFtwYXRoWzFdLCBwYXRoWzRdLCAoaXNCYW5kID8gcGF0aFs2XSA6IHBhdGhbMV0pXTtcblx0XHRcdFx0eXMgPSBbcGF0aFsyXSwgcGF0aFs1XSwgKGlzQmFuZCA/IHBhdGhbN10gOiBwYXRoWzJdKV07XG5cdFx0XHRcdHggPSBhcnJheU1pbih4cyk7XG5cdFx0XHRcdHkgPSBhcnJheU1pbih5cyk7XG5cblx0XHRcdFx0bGFiZWwuYWxpZ24ob3B0aW9uc0xhYmVsLCBmYWxzZSwge1xuXHRcdFx0XHRcdHg6IHgsXG5cdFx0XHRcdFx0eTogeSxcblx0XHRcdFx0XHR3aWR0aDogYXJyYXlNYXgoeHMpIC0geCxcblx0XHRcdFx0XHRoZWlnaHQ6IGFycmF5TWF4KHlzKSAtIHlcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGxhYmVsLnNob3coKTtcblxuXHRcdFx0fSBlbHNlIGlmIChsYWJlbCkgeyAvLyBtb3ZlIG91dCBvZiBzaWdodFxuXHRcdFx0XHRsYWJlbC5oaWRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoYWluYWJsZVxuXHRcdFx0cmV0dXJuIHBsb3RMaW5lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIHBsb3QgbGluZSBvciBiYW5kXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gcmVtb3ZlIGl0IGZyb20gdGhlIGxvb2t1cFxuXHRcdFx0ZXJhc2UodGhpcy5heGlzLnBsb3RMaW5lc0FuZEJhbmRzLCB0aGlzKTtcblx0XHRcdFxuXHRcdFx0ZGVsZXRlIHRoaXMuYXhpcztcblx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogT2JqZWN0IHdpdGggbWVtYmVycyBmb3IgZXh0ZW5kaW5nIHRoZSBBeGlzIHByb3RvdHlwZVxuXHQgKi9cblxuXHRBeGlzUGxvdExpbmVPckJhbmRFeHRlbnNpb24gPSB7XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgdGhlIHBhdGggZm9yIGEgcGxvdCBiYW5kXG5cdFx0ICovIFxuXHRcdGdldFBsb3RCYW5kUGF0aDogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG5cdFx0XHR2YXIgdG9QYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgodG8sIG51bGwsIG51bGwsIHRydWUpLFxuXHRcdFx0XHRwYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgoZnJvbSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG5cblx0XHRcdGlmIChwYXRoICYmIHRvUGF0aCAmJiBwYXRoLnRvU3RyaW5nKCkgIT09IHRvUGF0aC50b1N0cmluZygpKSB7IC8vICMzODM2XG5cdFx0XHRcdHBhdGgucHVzaChcblx0XHRcdFx0XHR0b1BhdGhbNF0sXG5cdFx0XHRcdFx0dG9QYXRoWzVdLFxuXHRcdFx0XHRcdHRvUGF0aFsxXSxcblx0XHRcdFx0XHR0b1BhdGhbMl1cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7IC8vIG91dHNpZGUgdGhlIGF4aXMgYXJlYVxuXHRcdFx0XHRwYXRoID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fSxcblxuXHRcdGFkZFBsb3RCYW5kOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUob3B0aW9ucywgJ3Bsb3RCYW5kcycpO1xuXHRcdH0sXG5cdFx0XG5cdFx0YWRkUGxvdExpbmU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShvcHRpb25zLCAncGxvdExpbmVzJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHBsb3QgYmFuZCBvciBwbG90IGxpbmUgYWZ0ZXIgcmVuZGVyIHRpbWVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFRoZSBwbG90QmFuZCBvciBwbG90TGluZSBjb25maWd1cmF0aW9uIG9iamVjdFxuXHRcdCAqL1xuXHRcdGFkZFBsb3RCYW5kT3JMaW5lOiBmdW5jdGlvbiAob3B0aW9ucywgY29sbCkge1xuXHRcdFx0dmFyIG9iaiA9IG5ldyBIaWdoY2hhcnRzLlBsb3RMaW5lT3JCYW5kKHRoaXMsIG9wdGlvbnMpLnJlbmRlcigpLFxuXHRcdFx0XHR1c2VyT3B0aW9ucyA9IHRoaXMudXNlck9wdGlvbnM7XG5cblx0XHRcdGlmIChvYmopIHsgLy8gIzIxODlcblx0XHRcdFx0Ly8gQWRkIGl0IHRvIHRoZSB1c2VyIG9wdGlvbnMgZm9yIGV4cG9ydGluZyBhbmQgQXhpcy51cGRhdGVcblx0XHRcdFx0aWYgKGNvbGwpIHtcblx0XHRcdFx0XHR1c2VyT3B0aW9uc1tjb2xsXSA9IHVzZXJPcHRpb25zW2NvbGxdIHx8IFtdO1xuXHRcdFx0XHRcdHVzZXJPcHRpb25zW2NvbGxdLnB1c2gob3B0aW9ucyk7IFxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucGxvdExpbmVzQW5kQmFuZHMucHVzaChvYmopOyBcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGEgcGxvdCBiYW5kIG9yIHBsb3QgbGluZSBmcm9tIHRoZSBjaGFydCBieSBpZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpZFxuXHRcdCAqL1xuXHRcdHJlbW92ZVBsb3RCYW5kT3JMaW5lOiBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHZhciBwbG90TGluZXNBbmRCYW5kcyA9IHRoaXMucGxvdExpbmVzQW5kQmFuZHMsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHVzZXJPcHRpb25zID0gdGhpcy51c2VyT3B0aW9ucyxcblx0XHRcdFx0aSA9IHBsb3RMaW5lc0FuZEJhbmRzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0aWYgKHBsb3RMaW5lc0FuZEJhbmRzW2ldLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHBsb3RMaW5lc0FuZEJhbmRzW2ldLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWFjaChbb3B0aW9ucy5wbG90TGluZXMgfHwgW10sIHVzZXJPcHRpb25zLnBsb3RMaW5lcyB8fCBbXSwgb3B0aW9ucy5wbG90QmFuZHMgfHwgW10sIHVzZXJPcHRpb25zLnBsb3RCYW5kcyB8fCBbXV0sIGZ1bmN0aW9uIChhcnIpIHtcblx0XHRcdFx0aSA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRpZiAoYXJyW2ldLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdFx0ZXJhc2UoYXJyLCBhcnJbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgYXhpcyBvYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHR2YXIgQXhpcyA9IEhpZ2hjaGFydHMuQXhpcyA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHRBeGlzLnByb3RvdHlwZSA9IHtcblxuXHRcdC8qKlxuXHRcdCAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIFggYXhpcyAtIHRoZSBZIGF4aXMgaGFzIGV4dGVuZGVkIGRlZmF1bHRzXG5cdFx0ICovXG5cdFx0ZGVmYXVsdE9wdGlvbnM6IHtcblx0XHRcdC8vIGFsbG93RGVjaW1hbHM6IG51bGwsXG5cdFx0XHQvLyBhbHRlcm5hdGVHcmlkQ29sb3I6IG51bGwsXG5cdFx0XHQvLyBjYXRlZ29yaWVzOiBbXSxcblx0XHRcdGRhdGVUaW1lTGFiZWxGb3JtYXRzOiB7XG5cdFx0XHRcdG1pbGxpc2Vjb25kOiAnJUg6JU06JVMuJUwnLFxuXHRcdFx0XHRzZWNvbmQ6ICclSDolTTolUycsXG5cdFx0XHRcdG1pbnV0ZTogJyVIOiVNJyxcblx0XHRcdFx0aG91cjogJyVIOiVNJyxcblx0XHRcdFx0ZGF5OiAnJWUuICViJyxcblx0XHRcdFx0d2VlazogJyVlLiAlYicsXG5cdFx0XHRcdG1vbnRoOiAnJWIgXFwnJXknLFxuXHRcdFx0XHR5ZWFyOiAnJVknXG5cdFx0XHR9LFxuXHRcdFx0ZW5kT25UaWNrOiBmYWxzZSxcblx0XHRcdGdyaWRMaW5lQ29sb3I6ICcjRDhEOEQ4Jyxcblx0XHRcdC8vIGdyaWRMaW5lRGFzaFN0eWxlOiAnc29saWQnLFxuXHRcdFx0Ly8gZ3JpZExpbmVXaWR0aDogMCxcblx0XHRcdC8vIHJldmVyc2VkOiBmYWxzZSxcblxuXHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdC8vIHJvdGF0aW9uOiAwLFxuXHRcdFx0XHQvLyBhbGlnbjogJ2NlbnRlcicsXG5cdFx0XHRcdC8vIHN0ZXA6IG51bGwsXG5cdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0Y29sb3I6ICcjNjA2MDYwJyxcblx0XHRcdFx0XHRjdXJzb3I6ICdkZWZhdWx0Jyxcblx0XHRcdFx0XHRmb250U2l6ZTogJzExcHgnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHg6IDAsXG5cdFx0XHRcdHk6IDE1XG5cdFx0XHRcdC8qZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sKi9cblx0XHRcdH0sXG5cdFx0XHRsaW5lQ29sb3I6ICcjQzBEMEUwJyxcblx0XHRcdGxpbmVXaWR0aDogMSxcblx0XHRcdC8vbGlua2VkVG86IG51bGwsXG5cdFx0XHQvL21heDogdW5kZWZpbmVkLFxuXHRcdFx0Ly9taW46IHVuZGVmaW5lZCxcblx0XHRcdG1pblBhZGRpbmc6IDAuMDEsXG5cdFx0XHRtYXhQYWRkaW5nOiAwLjAxLFxuXHRcdFx0Ly9taW5SYW5nZTogbnVsbCxcblx0XHRcdG1pbm9yR3JpZExpbmVDb2xvcjogJyNFMEUwRTAnLFxuXHRcdFx0Ly8gbWlub3JHcmlkTGluZURhc2hTdHlsZTogbnVsbCxcblx0XHRcdG1pbm9yR3JpZExpbmVXaWR0aDogMSxcblx0XHRcdG1pbm9yVGlja0NvbG9yOiAnI0EwQTBBMCcsXG5cdFx0XHQvL21pbm9yVGlja0ludGVydmFsOiBudWxsLFxuXHRcdFx0bWlub3JUaWNrTGVuZ3RoOiAyLFxuXHRcdFx0bWlub3JUaWNrUG9zaXRpb246ICdvdXRzaWRlJywgLy8gaW5zaWRlIG9yIG91dHNpZGVcblx0XHRcdC8vbWlub3JUaWNrV2lkdGg6IDAsXG5cdFx0XHQvL29wcG9zaXRlOiBmYWxzZSxcblx0XHRcdC8vb2Zmc2V0OiAwLFxuXHRcdFx0Ly9wbG90QmFuZHM6IFt7XG5cdFx0XHQvL1x0ZXZlbnRzOiB7fSxcblx0XHRcdC8vXHR6SW5kZXg6IDEsXG5cdFx0XHQvL1x0bGFiZWxzOiB7IGFsaWduLCB4LCB2ZXJ0aWNhbEFsaWduLCB5LCBzdHlsZSwgcm90YXRpb24sIHRleHRBbGlnbiB9XG5cdFx0XHQvL31dLFxuXHRcdFx0Ly9wbG90TGluZXM6IFt7XG5cdFx0XHQvL1x0ZXZlbnRzOiB7fVxuXHRcdFx0Ly8gIGRhc2hTdHlsZToge31cblx0XHRcdC8vXHR6SW5kZXg6XG5cdFx0XHQvL1x0bGFiZWxzOiB7IGFsaWduLCB4LCB2ZXJ0aWNhbEFsaWduLCB5LCBzdHlsZSwgcm90YXRpb24sIHRleHRBbGlnbiB9XG5cdFx0XHQvL31dLFxuXHRcdFx0Ly9yZXZlcnNlZDogZmFsc2UsXG5cdFx0XHQvLyBzaG93Rmlyc3RMYWJlbDogdHJ1ZSxcblx0XHRcdC8vIHNob3dMYXN0TGFiZWw6IHRydWUsXG5cdFx0XHRzdGFydE9mV2VlazogMSxcblx0XHRcdHN0YXJ0T25UaWNrOiBmYWxzZSxcblx0XHRcdHRpY2tDb2xvcjogJyNDMEQwRTAnLFxuXHRcdFx0Ly90aWNrSW50ZXJ2YWw6IG51bGwsXG5cdFx0XHR0aWNrTGVuZ3RoOiAxMCxcblx0XHRcdHRpY2ttYXJrUGxhY2VtZW50OiAnYmV0d2VlbicsIC8vIG9uIG9yIGJldHdlZW5cblx0XHRcdHRpY2tQaXhlbEludGVydmFsOiAxMDAsXG5cdFx0XHR0aWNrUG9zaXRpb246ICdvdXRzaWRlJyxcblx0XHRcdHRpY2tXaWR0aDogMSxcblx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdC8vdGV4dDogbnVsbCxcblx0XHRcdFx0YWxpZ246ICdtaWRkbGUnLCAvLyBsb3csIG1pZGRsZSBvciBoaWdoXG5cdFx0XHRcdC8vbWFyZ2luOiAwIGZvciBob3Jpem9udGFsLCAxMCBmb3IgdmVydGljYWwgYXhlcyxcblx0XHRcdFx0Ly9yb3RhdGlvbjogMCxcblx0XHRcdFx0Ly9zaWRlOiAnb3V0c2lkZScsXG5cdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0Y29sb3I6ICcjNzA3MDcwJ1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8veDogMCxcblx0XHRcdFx0Ly95OiAwXG5cdFx0XHR9LFxuXHRcdFx0dHlwZTogJ2xpbmVhcicgLy8gbGluZWFyLCBsb2dhcml0aG1pYyBvciBkYXRldGltZVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIG9wdGlvbnMgc2V0IGV4dGVuZHMgdGhlIGRlZmF1bHRPcHRpb25zIGZvciBZIGF4ZXNcblx0XHQgKi9cblx0XHRkZWZhdWx0WUF4aXNPcHRpb25zOiB7XG5cdFx0XHRlbmRPblRpY2s6IHRydWUsXG5cdFx0XHRncmlkTGluZVdpZHRoOiAxLFxuXHRcdFx0dGlja1BpeGVsSW50ZXJ2YWw6IDcyLFxuXHRcdFx0c2hvd0xhc3RMYWJlbDogdHJ1ZSxcblx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHR4OiAtOCxcblx0XHRcdFx0eTogM1xuXHRcdFx0fSxcblx0XHRcdGxpbmVXaWR0aDogMCxcblx0XHRcdG1heFBhZGRpbmc6IDAuMDUsXG5cdFx0XHRtaW5QYWRkaW5nOiAwLjA1LFxuXHRcdFx0c3RhcnRPblRpY2s6IHRydWUsXG5cdFx0XHR0aWNrV2lkdGg6IDAsXG5cdFx0XHR0aXRsZToge1xuXHRcdFx0XHRyb3RhdGlvbjogMjcwLFxuXHRcdFx0XHR0ZXh0OiAnVmFsdWVzJ1xuXHRcdFx0fSxcblx0XHRcdHN0YWNrTGFiZWxzOiB7XG5cdFx0XHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdFx0XHQvL2FsaWduOiBkeW5hbWljLFxuXHRcdFx0XHQvL3k6IGR5bmFtaWMsXG5cdFx0XHRcdC8veDogZHluYW1pYyxcblx0XHRcdFx0Ly92ZXJ0aWNhbEFsaWduOiBkeW5hbWljLFxuXHRcdFx0XHQvL3RleHRBbGlnbjogZHluYW1pYyxcblx0XHRcdFx0Ly9yb3RhdGlvbjogMCxcblx0XHRcdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHRoaXMudG90YWwsIC0xKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c3R5bGU6IG1lcmdlKGRlZmF1bHRQbG90T3B0aW9ucy5saW5lLmRhdGFMYWJlbHMuc3R5bGUsIHsgY29sb3I6ICcjMDAwMDAwJyB9KVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIGxlZnQgYXhlc1xuXHRcdCAqL1xuXHRcdGRlZmF1bHRMZWZ0QXhpc09wdGlvbnM6IHtcblx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHR4OiAtMTUsXG5cdFx0XHRcdHk6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR0aXRsZToge1xuXHRcdFx0XHRyb3RhdGlvbjogMjcwXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZXNlIG9wdGlvbnMgZXh0ZW5kIHRoZSBkZWZhdWx0T3B0aW9ucyBmb3IgcmlnaHQgYXhlc1xuXHRcdCAqL1xuXHRcdGRlZmF1bHRSaWdodEF4aXNPcHRpb25zOiB7XG5cdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0eDogMTUsXG5cdFx0XHRcdHk6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR0aXRsZToge1xuXHRcdFx0XHRyb3RhdGlvbjogOTBcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlc2Ugb3B0aW9ucyBleHRlbmQgdGhlIGRlZmF1bHRPcHRpb25zIGZvciBib3R0b20gYXhlc1xuXHRcdCAqL1xuXHRcdGRlZmF1bHRCb3R0b21BeGlzT3B0aW9uczoge1xuXHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdGF1dG9Sb3RhdGlvbjogWy00NV0sXG5cdFx0XHRcdHg6IDAsXG5cdFx0XHRcdHk6IG51bGwgLy8gYmFzZWQgb24gZm9udCBzaXplXG5cdFx0XHRcdC8vIG92ZXJmbG93OiB1bmRlZmluZWQsXG5cdFx0XHRcdC8vIHN0YWdnZXJMaW5lczogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIHRvcCBheGVzXG5cdFx0ICovXG5cdFx0ZGVmYXVsdFRvcEF4aXNPcHRpb25zOiB7XG5cdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0YXV0b1JvdGF0aW9uOiBbLTQ1XSxcblx0XHRcdFx0eDogMCxcblx0XHRcdFx0eTogLTE1XG5cdFx0XHRcdC8vIG92ZXJmbG93OiB1bmRlZmluZWRcblx0XHRcdFx0Ly8gc3RhZ2dlckxpbmVzOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0dGl0bGU6IHtcblx0XHRcdFx0cm90YXRpb246IDBcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSB0aGUgYXhpc1xuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgdXNlck9wdGlvbnMpIHtcblxuXG5cdFx0XHR2YXIgaXNYQXhpcyA9IHVzZXJPcHRpb25zLmlzWCxcblx0XHRcdFx0YXhpcyA9IHRoaXM7XG5cblx0XHRcdC8vIEZsYWcsIGlzIHRoZSBheGlzIGhvcml6b250YWxcblx0XHRcdGF4aXMuaG9yaXogPSBjaGFydC5pbnZlcnRlZCA/ICFpc1hBeGlzIDogaXNYQXhpcztcblxuXHRcdFx0Ly8gRmxhZywgaXNYQXhpc1xuXHRcdFx0YXhpcy5pc1hBeGlzID0gaXNYQXhpcztcblx0XHRcdGF4aXMuY29sbCA9IGlzWEF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJztcblxuXHRcdFx0YXhpcy5vcHBvc2l0ZSA9IHVzZXJPcHRpb25zLm9wcG9zaXRlOyAvLyBuZWVkZWQgaW4gc2V0T3B0aW9uc1xuXHRcdFx0YXhpcy5zaWRlID0gdXNlck9wdGlvbnMuc2lkZSB8fCAoYXhpcy5ob3JpeiA/XG5cdFx0XHRcdFx0KGF4aXMub3Bwb3NpdGUgPyAwIDogMikgOiAvLyB0b3AgOiBib3R0b21cblx0XHRcdFx0XHQoYXhpcy5vcHBvc2l0ZSA/IDEgOiAzKSk7ICAvLyByaWdodCA6IGxlZnRcblxuXHRcdFx0YXhpcy5zZXRPcHRpb25zKHVzZXJPcHRpb25zKTtcblxuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dHlwZSA9IG9wdGlvbnMudHlwZSxcblx0XHRcdFx0aXNEYXRldGltZUF4aXMgPSB0eXBlID09PSAnZGF0ZXRpbWUnO1xuXG5cdFx0XHRheGlzLmxhYmVsRm9ybWF0dGVyID0gb3B0aW9ucy5sYWJlbHMuZm9ybWF0dGVyIHx8IGF4aXMuZGVmYXVsdExhYmVsRm9ybWF0dGVyOyAvLyBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgZHluYW1pYyBmb3JtYXRcblxuXG5cdFx0XHQvLyBGbGFnLCBzdGFnZ2VyIGxpbmVzIG9yIG5vdFxuXHRcdFx0YXhpcy51c2VyT3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuXG5cdFx0XHQvL2F4aXMuYXhpc1RpdGxlTWFyZ2luID0gVU5ERUZJTkVELC8vID0gb3B0aW9ucy50aXRsZS5tYXJnaW4sXG5cdFx0XHRheGlzLm1pblBpeGVsUGFkZGluZyA9IDA7XG5cdFx0XHQvL2F4aXMuaWdub3JlTWluUGFkZGluZyA9IFVOREVGSU5FRDsgLy8gY2FuIGJlIHNldCB0byB0cnVlIGJ5IGEgY29sdW1uIG9yIGJhciBzZXJpZXNcblx0XHRcdC8vYXhpcy5pZ25vcmVNYXhQYWRkaW5nID0gVU5ERUZJTkVEO1xuXG5cdFx0XHRheGlzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XHRheGlzLnJldmVyc2VkID0gb3B0aW9ucy5yZXZlcnNlZDtcblx0XHRcdGF4aXMuem9vbUVuYWJsZWQgPSBvcHRpb25zLnpvb21FbmFibGVkICE9PSBmYWxzZTtcblxuXHRcdFx0Ly8gSW5pdGlhbCBjYXRlZ29yaWVzXG5cdFx0XHRheGlzLmNhdGVnb3JpZXMgPSBvcHRpb25zLmNhdGVnb3JpZXMgfHwgdHlwZSA9PT0gJ2NhdGVnb3J5Jztcblx0XHRcdGF4aXMubmFtZXMgPSBheGlzLm5hbWVzIHx8IFtdOyAvLyBQcmVzZXJ2ZSBvbiB1cGRhdGUgKCMzODMwKVxuXG5cdFx0XHQvLyBFbGVtZW50c1xuXHRcdFx0Ly9heGlzLmF4aXNHcm91cCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5ncmlkR3JvdXAgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMuYXhpc1RpdGxlID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLmF4aXNMaW5lID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvLyBTaG9ydGhhbmQgdHlwZXNcblx0XHRcdGF4aXMuaXNMb2cgPSB0eXBlID09PSAnbG9nYXJpdGhtaWMnO1xuXHRcdFx0YXhpcy5pc0RhdGV0aW1lQXhpcyA9IGlzRGF0ZXRpbWVBeGlzO1xuXG5cdFx0XHQvLyBGbGFnLCBpZiBheGlzIGlzIGxpbmtlZCB0byBhbm90aGVyIGF4aXNcblx0XHRcdGF4aXMuaXNMaW5rZWQgPSBkZWZpbmVkKG9wdGlvbnMubGlua2VkVG8pO1xuXHRcdFx0Ly8gTGlua2VkIGF4aXMuXG5cdFx0XHQvL2F4aXMubGlua2VkUGFyZW50ID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvLyBUaWNrIHBvc2l0aW9uc1xuXHRcdFx0Ly9heGlzLnRpY2tQb3NpdGlvbnMgPSBVTkRFRklORUQ7IC8vIGFycmF5IGNvbnRhaW5pbmcgcHJlZGVmaW5lZCBwb3NpdGlvbnNcblx0XHRcdC8vIFRpY2sgaW50ZXJ2YWxzXG5cdFx0XHQvL2F4aXMudGlja0ludGVydmFsID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLm1pbm9yVGlja0ludGVydmFsID0gVU5ERUZJTkVEO1xuXG5cdFx0XHRcblx0XHRcdC8vIE1ham9yIHRpY2tzXG5cdFx0XHRheGlzLnRpY2tzID0ge307XG5cdFx0XHRheGlzLmxhYmVsRWRnZSA9IFtdO1xuXHRcdFx0Ly8gTWlub3IgdGlja3Ncblx0XHRcdGF4aXMubWlub3JUaWNrcyA9IHt9O1xuXG5cdFx0XHQvLyBMaXN0IG9mIHBsb3RMaW5lcy9CYW5kc1xuXHRcdFx0YXhpcy5wbG90TGluZXNBbmRCYW5kcyA9IFtdO1xuXG5cdFx0XHQvLyBBbHRlcm5hdGUgYmFuZHNcblx0XHRcdGF4aXMuYWx0ZXJuYXRlQmFuZHMgPSB7fTtcblxuXHRcdFx0Ly8gQXhpcyBtZXRyaWNzXG5cdFx0XHQvL2F4aXMubGVmdCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy50b3AgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMud2lkdGggPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMuaGVpZ2h0ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLmJvdHRvbSA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5yaWdodCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy50cmFuc0EgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMudHJhbnNCID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLm9sZFRyYW5zQSA9IFVOREVGSU5FRDtcblx0XHRcdGF4aXMubGVuID0gMDtcblx0XHRcdC8vYXhpcy5vbGRNaW4gPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMub2xkTWF4ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLm9sZFVzZXJNaW4gPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMub2xkVXNlck1heCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5vbGRBeGlzTGVuZ3RoID0gVU5ERUZJTkVEO1xuXHRcdFx0YXhpcy5taW5SYW5nZSA9IGF4aXMudXNlck1pblJhbmdlID0gb3B0aW9ucy5taW5SYW5nZSB8fCBvcHRpb25zLm1heFpvb207XG5cdFx0XHRheGlzLnJhbmdlID0gb3B0aW9ucy5yYW5nZTtcblx0XHRcdGF4aXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcblxuXG5cdFx0XHQvLyBEaWN0aW9uYXJ5IGZvciBzdGFja3Ncblx0XHRcdGF4aXMuc3RhY2tzID0ge307XG5cdFx0XHRheGlzLm9sZFN0YWNrcyA9IHt9O1xuXHRcdFx0XG5cdFx0XHQvLyBNaW4gYW5kIG1heCBpbiB0aGUgZGF0YVxuXHRcdFx0Ly9heGlzLmRhdGFNaW4gPSBVTkRFRklORUQsXG5cdFx0XHQvL2F4aXMuZGF0YU1heCA9IFVOREVGSU5FRCxcblxuXHRcdFx0Ly8gVGhlIGF4aXMgcmFuZ2Vcblx0XHRcdGF4aXMubWF4ID0gbnVsbDtcblx0XHRcdGF4aXMubWluID0gbnVsbDtcblxuXHRcdFx0Ly8gVXNlciBzZXQgbWluIGFuZCBtYXhcblx0XHRcdC8vYXhpcy51c2VyTWluID0gVU5ERUZJTkVELFxuXHRcdFx0Ly9heGlzLnVzZXJNYXggPSBVTkRFRklORUQsXG5cblx0XHRcdC8vIENyb3NzaGFpciBvcHRpb25zXG5cdFx0XHRheGlzLmNyb3NzaGFpciA9IHBpY2sob3B0aW9ucy5jcm9zc2hhaXIsIHNwbGF0KGNoYXJ0Lm9wdGlvbnMudG9vbHRpcC5jcm9zc2hhaXJzKVtpc1hBeGlzID8gMCA6IDFdLCBmYWxzZSk7XG5cdFx0XHQvLyBSdW4gQXhpc1xuXG5cdFx0XHR2YXIgZXZlbnRUeXBlLFxuXHRcdFx0XHRldmVudHMgPSBheGlzLm9wdGlvbnMuZXZlbnRzO1xuXG5cdFx0XHQvLyBSZWdpc3RlclxuXHRcdFx0aWYgKGluQXJyYXkoYXhpcywgY2hhcnQuYXhlcykgPT09IC0xKSB7IC8vIGRvbid0IGFkZCBpdCBhZ2FpbiBvbiBBeGlzLnVwZGF0ZSgpXG5cdFx0XHRcdGlmIChpc1hBeGlzICYmICF0aGlzLmlzQ29sb3JBeGlzKSB7IC8vICMyNzEzXG5cdFx0XHRcdFx0Y2hhcnQuYXhlcy5zcGxpY2UoY2hhcnQueEF4aXMubGVuZ3RoLCAwLCBheGlzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGFydC5heGVzLnB1c2goYXhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjaGFydFtheGlzLmNvbGxdLnB1c2goYXhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGF4aXMuc2VyaWVzID0gYXhpcy5zZXJpZXMgfHwgW107IC8vIHBvcHVsYXRlZCBieSBTZXJpZXNcblxuXHRcdFx0Ly8gaW52ZXJ0ZWQgY2hhcnRzIGhhdmUgcmV2ZXJzZWQgeEF4ZXMgYXMgZGVmYXVsdFxuXHRcdFx0aWYgKGNoYXJ0LmludmVydGVkICYmIGlzWEF4aXMgJiYgYXhpcy5yZXZlcnNlZCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdGF4aXMucmV2ZXJzZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRheGlzLnJlbW92ZVBsb3RCYW5kID0gYXhpcy5yZW1vdmVQbG90QmFuZE9yTGluZTtcblx0XHRcdGF4aXMucmVtb3ZlUGxvdExpbmUgPSBheGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lO1xuXG5cblx0XHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyc1xuXHRcdFx0Zm9yIChldmVudFR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdGFkZEV2ZW50KGF4aXMsIGV2ZW50VHlwZSwgZXZlbnRzW2V2ZW50VHlwZV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBleHRlbmQgbG9nYXJpdGhtaWMgYXhpc1xuXHRcdFx0aWYgKGF4aXMuaXNMb2cpIHtcblx0XHRcdFx0YXhpcy52YWwybGluID0gbG9nMmxpbjtcblx0XHRcdFx0YXhpcy5saW4ydmFsID0gbGluMmxvZztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTWVyZ2UgYW5kIHNldCBvcHRpb25zXG5cdFx0ICovXG5cdFx0c2V0T3B0aW9uczogZnVuY3Rpb24gKHVzZXJPcHRpb25zKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBtZXJnZShcblx0XHRcdFx0dGhpcy5kZWZhdWx0T3B0aW9ucyxcblx0XHRcdFx0dGhpcy5pc1hBeGlzID8ge30gOiB0aGlzLmRlZmF1bHRZQXhpc09wdGlvbnMsXG5cdFx0XHRcdFt0aGlzLmRlZmF1bHRUb3BBeGlzT3B0aW9ucywgdGhpcy5kZWZhdWx0UmlnaHRBeGlzT3B0aW9ucyxcblx0XHRcdFx0XHR0aGlzLmRlZmF1bHRCb3R0b21BeGlzT3B0aW9ucywgdGhpcy5kZWZhdWx0TGVmdEF4aXNPcHRpb25zXVt0aGlzLnNpZGVdLFxuXHRcdFx0XHRtZXJnZShcblx0XHRcdFx0XHRkZWZhdWx0T3B0aW9uc1t0aGlzLmNvbGxdLCAvLyBpZiBzZXQgaW4gc2V0T3B0aW9ucyAoIzEwNTMpXG5cdFx0XHRcdFx0dXNlck9wdGlvbnNcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlZmF1bHQgbGFiZWwgZm9ybWF0dGVyLiBUaGUgY29udGV4dCBpcyBhIHNwZWNpYWwgY29uZmlnIG9iamVjdCBmb3IgdGhlIGxhYmVsLlxuXHRcdCAqL1xuXHRcdGRlZmF1bHRMYWJlbEZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLmF4aXMsXG5cdFx0XHRcdHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdFx0Y2F0ZWdvcmllcyA9IGF4aXMuY2F0ZWdvcmllcyxcblx0XHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdCA9IHRoaXMuZGF0ZVRpbWVMYWJlbEZvcm1hdCxcblx0XHRcdFx0bnVtZXJpY1N5bWJvbHMgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLm51bWVyaWNTeW1ib2xzLFxuXHRcdFx0XHRpID0gbnVtZXJpY1N5bWJvbHMgJiYgbnVtZXJpY1N5bWJvbHMubGVuZ3RoLFxuXHRcdFx0XHRtdWx0aSxcblx0XHRcdFx0cmV0LFxuXHRcdFx0XHRmb3JtYXRPcHRpb24gPSBheGlzLm9wdGlvbnMubGFiZWxzLmZvcm1hdCxcblxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIHNhbWUgc3ltYm9sIGlzIGFkZGVkIGZvciBhbGwgbGFiZWxzIG9uIGEgbGluZWFyIGF4aXNcblx0XHRcdFx0bnVtZXJpY1N5bWJvbERldGVjdG9yID0gYXhpcy5pc0xvZyA/IHZhbHVlIDogYXhpcy50aWNrSW50ZXJ2YWw7XG5cblx0XHRcdGlmIChmb3JtYXRPcHRpb24pIHtcblx0XHRcdFx0cmV0ID0gZm9ybWF0KGZvcm1hdE9wdGlvbiwgdGhpcyk7XG5cblx0XHRcdH0gZWxzZSBpZiAoY2F0ZWdvcmllcykge1xuXHRcdFx0XHRyZXQgPSB2YWx1ZTtcblxuXHRcdFx0fSBlbHNlIGlmIChkYXRlVGltZUxhYmVsRm9ybWF0KSB7IC8vIGRhdGV0aW1lIGF4aXNcblx0XHRcdFx0cmV0ID0gZGF0ZUZvcm1hdChkYXRlVGltZUxhYmVsRm9ybWF0LCB2YWx1ZSk7XG5cblx0XHRcdH0gZWxzZSBpZiAoaSAmJiBudW1lcmljU3ltYm9sRGV0ZWN0b3IgPj0gMTAwMCkge1xuXHRcdFx0XHQvLyBEZWNpZGUgd2hldGhlciB3ZSBzaG91bGQgYWRkIGEgbnVtZXJpYyBzeW1ib2wgbGlrZSBrICh0aG91c2FuZHMpIG9yIE0gKG1pbGxpb25zKS5cblx0XHRcdFx0Ly8gSWYgd2UgYXJlIHRvIGVuYWJsZSB0aGlzIGluIHRvb2x0aXAgb3Igb3RoZXIgcGxhY2VzIGFzIHdlbGwsIHdlIGNhbiBtb3ZlIHRoaXNcblx0XHRcdFx0Ly8gbG9naWMgdG8gdGhlIG51bWJlckZvcm1hdHRlciBhbmQgZW5hYmxlIGl0IGJ5IGEgcGFyYW1ldGVyLlxuXHRcdFx0XHR3aGlsZSAoaS0tICYmIHJldCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0bXVsdGkgPSBNYXRoLnBvdygxMDAwLCBpICsgMSk7XG5cdFx0XHRcdFx0aWYgKG51bWVyaWNTeW1ib2xEZXRlY3RvciA+PSBtdWx0aSAmJiBudW1lcmljU3ltYm9sc1tpXSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0cmV0ID0gSGlnaGNoYXJ0cy5udW1iZXJGb3JtYXQodmFsdWUgLyBtdWx0aSwgLTEpICsgbnVtZXJpY1N5bWJvbHNbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZXQgPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRpZiAobWF0aEFicyh2YWx1ZSkgPj0gMTAwMDApIHsgLy8gYWRkIHRob3VzYW5kcyBzZXBhcmF0b3JzXG5cdFx0XHRcdFx0cmV0ID0gSGlnaGNoYXJ0cy5udW1iZXJGb3JtYXQodmFsdWUsIDApO1xuXG5cdFx0XHRcdH0gZWxzZSB7IC8vIHNtYWxsIG51bWJlcnNcblx0XHRcdFx0XHRyZXQgPSBIaWdoY2hhcnRzLm51bWJlckZvcm1hdCh2YWx1ZSwgLTEsIFVOREVGSU5FRCwgJycpOyAvLyAjMjQ2NlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBmb3IgdGhlIHNlcmllcyBvZiBlYWNoIGF4aXNcblx0XHQgKi9cblx0XHRnZXRTZXJpZXNFeHRyZW1lczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQ7XG5cblx0XHRcdGF4aXMuaGFzVmlzaWJsZVNlcmllcyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBSZXNldCBwcm9wZXJ0aWVzIGluIGNhc2Ugd2UncmUgcmVkcmF3aW5nICgjMzM1Mylcblx0XHRcdGF4aXMuZGF0YU1pbiA9IGF4aXMuZGF0YU1heCA9IGF4aXMuaWdub3JlTWluUGFkZGluZyA9IGF4aXMuaWdub3JlTWF4UGFkZGluZyA9IG51bGw7XG5cdFx0XHRcblx0XHRcdGlmIChheGlzLmJ1aWxkU3RhY2tzKSB7XG5cdFx0XHRcdGF4aXMuYnVpbGRTdGFja3MoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHRoaXMgYXhpcycgc2VyaWVzXG5cdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cblx0XHRcdFx0aWYgKHNlcmllcy52aXNpYmxlIHx8ICFjaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcykge1xuXG5cdFx0XHRcdFx0dmFyIHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0XHRcdHhEYXRhLFxuXHRcdFx0XHRcdFx0dGhyZXNob2xkID0gc2VyaWVzT3B0aW9ucy50aHJlc2hvbGQsXG5cdFx0XHRcdFx0XHRzZXJpZXNEYXRhTWluLFxuXHRcdFx0XHRcdFx0c2VyaWVzRGF0YU1heDtcblxuXHRcdFx0XHRcdGF4aXMuaGFzVmlzaWJsZVNlcmllcyA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBWYWxpZGF0ZSB0aHJlc2hvbGQgaW4gbG9nYXJpdGhtaWMgYXhlc1xuXHRcdFx0XHRcdGlmIChheGlzLmlzTG9nICYmIHRocmVzaG9sZCA8PSAwKSB7XG5cdFx0XHRcdFx0XHR0aHJlc2hvbGQgPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCBkYXRhTWluIGFuZCBkYXRhTWF4IGZvciBYIGF4ZXNcblx0XHRcdFx0XHRpZiAoYXhpcy5pc1hBeGlzKSB7XG5cdFx0XHRcdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YTtcblx0XHRcdFx0XHRcdGlmICh4RGF0YS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0YXhpcy5kYXRhTWluID0gbWF0aE1pbihwaWNrKGF4aXMuZGF0YU1pbiwgeERhdGFbMF0pLCBhcnJheU1pbih4RGF0YSkpO1xuXHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNYXggPSBtYXRoTWF4KHBpY2soYXhpcy5kYXRhTWF4LCB4RGF0YVswXSksIGFycmF5TWF4KHhEYXRhKSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBHZXQgZGF0YU1pbiBhbmQgZGF0YU1heCBmb3IgWSBheGVzLCBhcyB3ZWxsIGFzIGhhbmRsZSBzdGFja2luZyBhbmQgcHJvY2Vzc2VkIGRhdGFcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhpcyBwYXJ0aWN1bGFyIHNlcmllcyBleHRyZW1lc1xuXHRcdFx0XHRcdFx0c2VyaWVzLmdldEV4dHJlbWVzKCk7XG5cdFx0XHRcdFx0XHRzZXJpZXNEYXRhTWF4ID0gc2VyaWVzLmRhdGFNYXg7XG5cdFx0XHRcdFx0XHRzZXJpZXNEYXRhTWluID0gc2VyaWVzLmRhdGFNaW47XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgZGF0YU1pbiBhbmQgZGF0YU1heCBzbyBmYXIuIElmIHBlcmNlbnRhZ2UgaXMgdXNlZCwgdGhlIG1pbiBhbmQgbWF4IGFyZVxuXHRcdFx0XHRcdFx0Ly8gYWx3YXlzIDAgYW5kIDEwMC4gSWYgc2VyaWVzRGF0YU1pbiBhbmQgc2VyaWVzRGF0YU1heCBpcyBudWxsLCB0aGVuIHNlcmllc1xuXHRcdFx0XHRcdFx0Ly8gZG9lc24ndCBoYXZlIGFjdGl2ZSB5IGRhdGEsIHdlIGNvbnRpbnVlIHdpdGggbnVsbHNcblx0XHRcdFx0XHRcdGlmIChkZWZpbmVkKHNlcmllc0RhdGFNaW4pICYmIGRlZmluZWQoc2VyaWVzRGF0YU1heCkpIHtcblx0XHRcdFx0XHRcdFx0YXhpcy5kYXRhTWluID0gbWF0aE1pbihwaWNrKGF4aXMuZGF0YU1pbiwgc2VyaWVzRGF0YU1pbiksIHNlcmllc0RhdGFNaW4pO1xuXHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNYXggPSBtYXRoTWF4KHBpY2soYXhpcy5kYXRhTWF4LCBzZXJpZXNEYXRhTWF4KSwgc2VyaWVzRGF0YU1heCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEFkanVzdCB0byB0aHJlc2hvbGRcblx0XHRcdFx0XHRcdGlmIChkZWZpbmVkKHRocmVzaG9sZCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGF4aXMuZGF0YU1pbiA+PSB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNaW4gPSB0aHJlc2hvbGQ7XG5cdFx0XHRcdFx0XHRcdFx0YXhpcy5pZ25vcmVNaW5QYWRkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChheGlzLmRhdGFNYXggPCB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNYXggPSB0aHJlc2hvbGQ7XG5cdFx0XHRcdFx0XHRcdFx0YXhpcy5pZ25vcmVNYXhQYWRkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zbGF0ZSBmcm9tIGF4aXMgdmFsdWUgdG8gcGl4ZWwgcG9zaXRpb24gb24gdGhlIGNoYXJ0LCBvciBiYWNrXG5cdFx0ICpcblx0XHQgKi9cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICh2YWwsIGJhY2t3YXJkcywgY3ZzQ29vcmQsIG9sZCwgaGFuZGxlTG9nLCBwb2ludFBsYWNlbWVudCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRzaWduID0gMSxcblx0XHRcdFx0Y3ZzT2Zmc2V0ID0gMCxcblx0XHRcdFx0bG9jYWxBID0gb2xkID8gYXhpcy5vbGRUcmFuc0EgOiBheGlzLnRyYW5zQSxcblx0XHRcdFx0bG9jYWxNaW4gPSBvbGQgPyBheGlzLm9sZE1pbiA6IGF4aXMubWluLFxuXHRcdFx0XHRyZXR1cm5WYWx1ZSxcblx0XHRcdFx0bWluUGl4ZWxQYWRkaW5nID0gYXhpcy5taW5QaXhlbFBhZGRpbmcsXG5cdFx0XHRcdGRvUG9zdFRyYW5zbGF0ZSA9IChheGlzLmRvUG9zdFRyYW5zbGF0ZSB8fCAoYXhpcy5pc0xvZyAmJiBoYW5kbGVMb2cpKSAmJiBheGlzLmxpbjJ2YWw7XG5cblx0XHRcdGlmICghbG9jYWxBKSB7XG5cdFx0XHRcdGxvY2FsQSA9IGF4aXMudHJhbnNBO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbiB2ZXJ0aWNhbCBheGVzLCB0aGUgY2FudmFzIGNvb3JkaW5hdGVzIHN0YXJ0IGZyb20gMCBhdCB0aGUgdG9wIGxpa2UgaW5cblx0XHRcdC8vIFNWRy5cblx0XHRcdGlmIChjdnNDb29yZCkge1xuXHRcdFx0XHRzaWduICo9IC0xOyAvLyBjYW52YXMgY29vcmRpbmF0ZXMgaW52ZXJ0cyB0aGUgdmFsdWVcblx0XHRcdFx0Y3ZzT2Zmc2V0ID0gYXhpcy5sZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSByZXZlcnNlZCBheGlzXG5cdFx0XHRpZiAoYXhpcy5yZXZlcnNlZCkge1xuXHRcdFx0XHRzaWduICo9IC0xO1xuXHRcdFx0XHRjdnNPZmZzZXQgLT0gc2lnbiAqIChheGlzLnNlY3RvciB8fCBheGlzLmxlbik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZyb20gcGl4ZWxzIHRvIHZhbHVlXG5cdFx0XHRpZiAoYmFja3dhcmRzKSB7IC8vIHJldmVyc2UgdHJhbnNsYXRpb25cblxuXHRcdFx0XHR2YWwgPSB2YWwgKiBzaWduICsgY3ZzT2Zmc2V0O1xuXHRcdFx0XHR2YWwgLT0gbWluUGl4ZWxQYWRkaW5nO1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbCAvIGxvY2FsQSArIGxvY2FsTWluOyAvLyBmcm9tIGNoYXJ0IHBpeGVsIHRvIHZhbHVlXG5cdFx0XHRcdGlmIChkb1Bvc3RUcmFuc2xhdGUpIHsgLy8gbG9nIGFuZCBvcmRpbmFsIGF4ZXNcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IGF4aXMubGluMnZhbChyZXR1cm5WYWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gRnJvbSB2YWx1ZSB0byBwaXhlbHNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkb1Bvc3RUcmFuc2xhdGUpIHsgLy8gbG9nIGFuZCBvcmRpbmFsIGF4ZXNcblx0XHRcdFx0XHR2YWwgPSBheGlzLnZhbDJsaW4odmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocG9pbnRQbGFjZW1lbnQgPT09ICdiZXR3ZWVuJykge1xuXHRcdFx0XHRcdHBvaW50UGxhY2VtZW50ID0gMC41O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVyblZhbHVlID0gc2lnbiAqICh2YWwgLSBsb2NhbE1pbikgKiBsb2NhbEEgKyBjdnNPZmZzZXQgKyAoc2lnbiAqIG1pblBpeGVsUGFkZGluZykgK1xuXHRcdFx0XHRcdChpc051bWJlcihwb2ludFBsYWNlbWVudCkgPyBsb2NhbEEgKiBwb2ludFBsYWNlbWVudCAqIGF4aXMucG9pbnRSYW5nZSA6IDApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFV0aWxpdHkgbWV0aG9kIHRvIHRyYW5zbGF0ZSBhbiBheGlzIHZhbHVlIHRvIHBpeGVsIHBvc2l0aW9uLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGluIHRlcm1zIG9mIGF4aXMgdW5pdHNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhbmVDb29yZGluYXRlcyBXaGV0aGVyIHRvIHJldHVybiB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgY2hhcnRcblx0XHQgKiAgICAgICAgb3IganVzdCB0aGUgYXhpcy9wYW5lIGl0c2VsZi5cblx0XHQgKi9cblx0XHR0b1BpeGVsczogZnVuY3Rpb24gKHZhbHVlLCBwYW5lQ29vcmRpbmF0ZXMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZSh2YWx1ZSwgZmFsc2UsICF0aGlzLmhvcml6LCBudWxsLCB0cnVlKSArIChwYW5lQ29vcmRpbmF0ZXMgPyAwIDogdGhpcy5wb3MpO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCAqIFV0aWxpdHkgbWV0aG9kIHRvIHRyYW5zbGF0ZSBhIHBpeGVsIHBvc2l0aW9uIGluIHRvIGFuIGF4aXMgdmFsdWVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWwgVGhlIHBpeGVsIHZhbHVlIGNvb3JkaW5hdGVcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhbmVDb29yZGlhbnRlcyBXaGV0aGVyIHRoZSBpbnB1dCBwaXhlbCBpcyByZWxhdGl2ZSB0byB0aGUgY2hhcnQgb3IganVzdCB0aGVcblx0XHQgKiAgICAgICAgYXhpcy9wYW5lIGl0c2VsZi5cblx0XHQgKi9cblx0XHR0b1ZhbHVlOiBmdW5jdGlvbiAocGl4ZWwsIHBhbmVDb29yZGluYXRlcykge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlKHBpeGVsIC0gKHBhbmVDb29yZGluYXRlcyA/IDAgOiB0aGlzLnBvcyksIHRydWUsICF0aGlzLmhvcml6LCBudWxsLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHRoZSBwYXRoIGZvciBhIHBsb3QgbGluZSB0aGF0IGdvZXMgZnJvbSB0aGUgZ2l2ZW4gdmFsdWUgb25cblx0XHQgKiB0aGlzIGF4aXMsIGFjcm9zcyB0aGUgcGxvdCB0byB0aGUgb3Bwb3NpdGUgc2lkZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lV2lkdGggVXNlZCBmb3IgY2FsY3VsYXRpb24gY3Jpc3AgbGluZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyXSBvbGQgVXNlIG9sZCBjb29yZGluYXRlcyAoZm9yIHJlc2l6aW5nIGFuZCByZXNjYWxpbmcpXG5cdFx0ICovXG5cdFx0Z2V0UGxvdExpbmVQYXRoOiBmdW5jdGlvbiAodmFsdWUsIGxpbmVXaWR0aCwgb2xkLCBmb3JjZSwgdHJhbnNsYXRlZFZhbHVlKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdFx0YXhpc0xlZnQgPSBheGlzLmxlZnQsXG5cdFx0XHRcdGF4aXNUb3AgPSBheGlzLnRvcCxcblx0XHRcdFx0eDEsXG5cdFx0XHRcdHkxLFxuXHRcdFx0XHR4Mixcblx0XHRcdFx0eTIsXG5cdFx0XHRcdGNIZWlnaHQgPSAob2xkICYmIGNoYXJ0Lm9sZENoYXJ0SGVpZ2h0KSB8fCBjaGFydC5jaGFydEhlaWdodCxcblx0XHRcdFx0Y1dpZHRoID0gKG9sZCAmJiBjaGFydC5vbGRDaGFydFdpZHRoKSB8fCBjaGFydC5jaGFydFdpZHRoLFxuXHRcdFx0XHRza2lwLFxuXHRcdFx0XHR0cmFuc0IgPSBheGlzLnRyYW5zQixcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIENoZWNrIGlmIHggaXMgYmV0d2VlbiBhIGFuZCBiLiBJZiBub3QsIGVpdGhlciBtb3ZlIHRvIGEvYiBvciBza2lwLCBcblx0XHRcdFx0ICogZGVwZW5kaW5nIG9uIHRoZSBmb3JjZSBwYXJhbWV0ZXIuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRiZXR3ZWVuID0gZnVuY3Rpb24gKHgsIGEsIGIpIHtcblx0XHRcdFx0XHRpZiAoeCA8IGEgfHwgeCA+IGIpIHtcblx0XHRcdFx0XHRcdGlmIChmb3JjZSkge1xuXHRcdFx0XHRcdFx0XHR4ID0gbWF0aE1pbihtYXRoTWF4KGEsIHgpLCBiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNraXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4geDtcblx0XHRcdFx0fTtcblxuXHRcdFx0dHJhbnNsYXRlZFZhbHVlID0gcGljayh0cmFuc2xhdGVkVmFsdWUsIGF4aXMudHJhbnNsYXRlKHZhbHVlLCBudWxsLCBudWxsLCBvbGQpKTtcblx0XHRcdHgxID0geDIgPSBtYXRoUm91bmQodHJhbnNsYXRlZFZhbHVlICsgdHJhbnNCKTtcblx0XHRcdHkxID0geTIgPSBtYXRoUm91bmQoY0hlaWdodCAtIHRyYW5zbGF0ZWRWYWx1ZSAtIHRyYW5zQik7XG5cblx0XHRcdGlmIChpc05hTih0cmFuc2xhdGVkVmFsdWUpKSB7IC8vIG5vIG1pbiBvciBtYXhcblx0XHRcdFx0c2tpcCA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoYXhpcy5ob3Jpeikge1xuXHRcdFx0XHR5MSA9IGF4aXNUb3A7XG5cdFx0XHRcdHkyID0gY0hlaWdodCAtIGF4aXMuYm90dG9tO1xuXHRcdFx0XHR4MSA9IHgyID0gYmV0d2Vlbih4MSwgYXhpc0xlZnQsIGF4aXNMZWZ0ICsgYXhpcy53aWR0aCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4MSA9IGF4aXNMZWZ0O1xuXHRcdFx0XHR4MiA9IGNXaWR0aCAtIGF4aXMucmlnaHQ7XG5cdFx0XHRcdHkxID0geTIgPSBiZXR3ZWVuKHkxLCBheGlzVG9wLCBheGlzVG9wICsgYXhpcy5oZWlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNraXAgJiYgIWZvcmNlID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGNoYXJ0LnJlbmRlcmVyLmNyaXNwTGluZShbTSwgeDEsIHkxLCBMLCB4MiwgeTJdLCBsaW5lV2lkdGggfHwgMSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgdGljayBwb3NpdGlvbnMgb2YgYSBsaW5lYXIgYXhpcyB0byByb3VuZCB2YWx1ZXMgbGlrZSB3aG9sZSB0ZW5zIG9yIGV2ZXJ5IGZpdmUuXG5cdFx0ICovXG5cdFx0Z2V0TGluZWFyVGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKHRpY2tJbnRlcnZhbCwgbWluLCBtYXgpIHtcblx0XHRcdHZhciBwb3MsXG5cdFx0XHRcdGxhc3RQb3MsXG5cdFx0XHRcdHJvdW5kZWRNaW4gPSBjb3JyZWN0RmxvYXQobWF0aEZsb29yKG1pbiAvIHRpY2tJbnRlcnZhbCkgKiB0aWNrSW50ZXJ2YWwpLFxuXHRcdFx0XHRyb3VuZGVkTWF4ID0gY29ycmVjdEZsb2F0KG1hdGhDZWlsKG1heCAvIHRpY2tJbnRlcnZhbCkgKiB0aWNrSW50ZXJ2YWwpLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zID0gW107XG5cblx0XHRcdC8vIEZvciBzaW5nbGUgcG9pbnRzLCBhZGQgYSB0aWNrIHJlZ2FyZGxlc3Mgb2YgdGhlIHJlbGF0aXZlIHBvc2l0aW9uICgjMjY2Milcblx0XHRcdGlmIChtaW4gPT09IG1heCAmJiBpc051bWJlcihtaW4pKSB7XG5cdFx0XHRcdHJldHVybiBbbWluXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUG9wdWxhdGUgdGhlIGludGVybWVkaWF0ZSB2YWx1ZXNcblx0XHRcdHBvcyA9IHJvdW5kZWRNaW47XG5cdFx0XHR3aGlsZSAocG9zIDw9IHJvdW5kZWRNYXgpIHtcblxuXHRcdFx0XHQvLyBQbGFjZSB0aGUgdGljayBvbiB0aGUgcm91bmRlZCB2YWx1ZVxuXHRcdFx0XHR0aWNrUG9zaXRpb25zLnB1c2gocG9zKTtcblxuXHRcdFx0XHQvLyBBbHdheXMgYWRkIHRoZSByYXcgdGlja0ludGVydmFsLCBub3QgdGhlIGNvcnJlY3RlZCBvbmUuXG5cdFx0XHRcdHBvcyA9IGNvcnJlY3RGbG9hdChwb3MgKyB0aWNrSW50ZXJ2YWwpO1xuXG5cdFx0XHRcdC8vIElmIHRoZSBpbnRlcnZhbCBpcyBub3QgYmlnIGVub3VnaCBpbiB0aGUgY3VycmVudCBtaW4gLSBtYXggcmFuZ2UgdG8gYWN0dWFsbHkgaW5jcmVhc2Vcblx0XHRcdFx0Ly8gdGhlIGxvb3AgdmFyaWFibGUsIHdlIG5lZWQgdG8gYnJlYWsgb3V0IHRvIHByZXZlbnQgZW5kbGVzcyBsb29wLiBJc3N1ZSAjNjE5XG5cdFx0XHRcdGlmIChwb3MgPT09IGxhc3RQb3MpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY29yZCB0aGUgbGFzdCB2YWx1ZVxuXHRcdFx0XHRsYXN0UG9zID0gcG9zO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpY2tQb3NpdGlvbnM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0aGUgbWlub3IgdGljayBwb3NpdGlvbnMuIEZvciBsb2dhcml0aG1pYyBheGVzLCByZXVzZSB0aGUgc2FtZSBsb2dpY1xuXHRcdCAqIGFzIGZvciBtYWpvciB0aWNrcy5cblx0XHQgKi9cblx0XHRnZXRNaW5vclRpY2tQb3NpdGlvbnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IGF4aXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0bWlub3JUaWNrSW50ZXJ2YWwgPSBheGlzLm1pbm9yVGlja0ludGVydmFsLFxuXHRcdFx0XHRtaW5vclRpY2tQb3NpdGlvbnMgPSBbXSxcblx0XHRcdFx0cG9zLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRtaW4gPSBheGlzLm1pbixcblx0XHRcdFx0bWF4ID0gYXhpcy5tYXgsXG5cdFx0XHRcdHJhbmdlID0gbWF4IC0gbWluLFxuXHRcdFx0XHRsZW47XG5cblx0XHRcdC8vIElmIG1pbm9yIHRpY2tzIGdldCB0b28gZGVuc2UsIHRoZXkgYXJlIGhhcmQgdG8gcmVhZCwgYW5kIG1heSBjYXVzZSBsb25nIHJ1bm5pbmcgc2NyaXB0LiBTbyB3ZSBkb24ndCBkcmF3IHRoZW0uXG5cdFx0XHRpZiAocmFuZ2UgJiYgcmFuZ2UgLyBtaW5vclRpY2tJbnRlcnZhbCA8IGF4aXMubGVuIC8gMykgeyAvLyAjMzg3NVxuXG5cdFx0XHRcdGlmIChheGlzLmlzTG9nKSB7XG5cdFx0XHRcdFx0bGVuID0gdGlja1Bvc2l0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRtaW5vclRpY2tQb3NpdGlvbnMgPSBtaW5vclRpY2tQb3NpdGlvbnMuY29uY2F0KFxuXHRcdFx0XHRcdFx0XHRheGlzLmdldExvZ1RpY2tQb3NpdGlvbnMobWlub3JUaWNrSW50ZXJ2YWwsIHRpY2tQb3NpdGlvbnNbaSAtIDFdLCB0aWNrUG9zaXRpb25zW2ldLCB0cnVlKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXhpcy5pc0RhdGV0aW1lQXhpcyAmJiBvcHRpb25zLm1pbm9yVGlja0ludGVydmFsID09PSAnYXV0bycpIHsgLy8gIzEzMTRcblx0XHRcdFx0XHRtaW5vclRpY2tQb3NpdGlvbnMgPSBtaW5vclRpY2tQb3NpdGlvbnMuY29uY2F0KFxuXHRcdFx0XHRcdFx0YXhpcy5nZXRUaW1lVGlja3MoXG5cdFx0XHRcdFx0XHRcdGF4aXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbChtaW5vclRpY2tJbnRlcnZhbCksXG5cdFx0XHRcdFx0XHRcdG1pbixcblx0XHRcdFx0XHRcdFx0bWF4LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zLnN0YXJ0T2ZXZWVrXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHBvcyA9IG1pbiArICh0aWNrUG9zaXRpb25zWzBdIC0gbWluKSAlIG1pbm9yVGlja0ludGVydmFsOyBwb3MgPD0gbWF4OyBwb3MgKz0gbWlub3JUaWNrSW50ZXJ2YWwpIHtcblx0XHRcdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucy5wdXNoKHBvcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGF4aXMudHJpbVRpY2tzKG1pbm9yVGlja1Bvc2l0aW9ucyk7IC8vICMzNjUyICMzNzQzXG5cdFx0XHRyZXR1cm4gbWlub3JUaWNrUG9zaXRpb25zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGp1c3QgdGhlIG1pbiBhbmQgbWF4IGZvciB0aGUgbWluaW11bSByYW5nZS4gS2VlcCBpbiBtaW5kIHRoYXQgdGhlIHNlcmllcyBkYXRhIGlzXG5cdFx0ICogbm90IHlldCBwcm9jZXNzZWQsIHNvIHdlIGRvbid0IGhhdmUgaW5mb3JtYXRpb24gb24gZGF0YSBjcm9wcGluZyBhbmQgZ3JvdXBpbmcsIG9yXG5cdFx0ICogdXBkYXRlZCBheGlzLnBvaW50UmFuZ2Ugb3Igc2VyaWVzLnBvaW50UmFuZ2UuIFRoZSBkYXRhIGNhbid0IGJlIHByb2Nlc3NlZCB1bnRpbFxuXHRcdCAqIHdlIGhhdmUgZmluYWxseSBlc3RhYmxpc2hlZCBtaW4gYW5kIG1heC5cblx0XHQgKi9cblx0XHRhZGp1c3RGb3JNaW5SYW5nZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHRtaW4gPSBheGlzLm1pbixcblx0XHRcdFx0bWF4ID0gYXhpcy5tYXgsXG5cdFx0XHRcdHpvb21PZmZzZXQsXG5cdFx0XHRcdHNwYWNlQXZhaWxhYmxlID0gYXhpcy5kYXRhTWF4IC0gYXhpcy5kYXRhTWluID49IGF4aXMubWluUmFuZ2UsXG5cdFx0XHRcdGNsb3Nlc3REYXRhUmFuZ2UsXG5cdFx0XHRcdGksXG5cdFx0XHRcdGRpc3RhbmNlLFxuXHRcdFx0XHR4RGF0YSxcblx0XHRcdFx0bG9vcExlbmd0aCxcblx0XHRcdFx0bWluQXJncyxcblx0XHRcdFx0bWF4QXJncztcblxuXHRcdFx0Ly8gU2V0IHRoZSBhdXRvbWF0aWMgbWluaW11bSByYW5nZSBiYXNlZCBvbiB0aGUgY2xvc2VzdCBwb2ludCBkaXN0YW5jZVxuXHRcdFx0aWYgKGF4aXMuaXNYQXhpcyAmJiBheGlzLm1pblJhbmdlID09PSBVTkRFRklORUQgJiYgIWF4aXMuaXNMb2cpIHtcblxuXHRcdFx0XHRpZiAoZGVmaW5lZChvcHRpb25zLm1pbikgfHwgZGVmaW5lZChvcHRpb25zLm1heCkpIHtcblx0XHRcdFx0XHRheGlzLm1pblJhbmdlID0gbnVsbDsgLy8gZG9uJ3QgZG8gdGhpcyBhZ2FpblxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBGaW5kIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGJldHdlZW4gcmF3IGRhdGEgcG9pbnRzLCBhcyBvcHBvc2VkIHRvXG5cdFx0XHRcdFx0Ly8gY2xvc2VzdFBvaW50UmFuZ2UgdGhhdCBhcHBsaWVzIHRvIHByb2Nlc3NlZCBwb2ludHMgKGNyb3BwZWQgYW5kIGdyb3VwZWQpXG5cdFx0XHRcdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRcdFx0eERhdGEgPSBzZXJpZXMueERhdGE7XG5cdFx0XHRcdFx0XHRsb29wTGVuZ3RoID0gc2VyaWVzLnhJbmNyZW1lbnQgPyAxIDogeERhdGEubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdGZvciAoaSA9IGxvb3BMZW5ndGg7IGkgPiAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2UgPSB4RGF0YVtpXSAtIHhEYXRhW2kgLSAxXTtcblx0XHRcdFx0XHRcdFx0aWYgKGNsb3Nlc3REYXRhUmFuZ2UgPT09IFVOREVGSU5FRCB8fCBkaXN0YW5jZSA8IGNsb3Nlc3REYXRhUmFuZ2UpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGF0YVJhbmdlID0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRheGlzLm1pblJhbmdlID0gbWF0aE1pbihjbG9zZXN0RGF0YVJhbmdlICogNSwgYXhpcy5kYXRhTWF4IC0gYXhpcy5kYXRhTWluKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiBtaW5SYW5nZSBpcyBleGNlZWRlZCwgYWRqdXN0XG5cdFx0XHRpZiAobWF4IC0gbWluIDwgYXhpcy5taW5SYW5nZSkge1xuXHRcdFx0XHR2YXIgbWluUmFuZ2UgPSBheGlzLm1pblJhbmdlO1xuXHRcdFx0XHR6b29tT2Zmc2V0ID0gKG1pblJhbmdlIC0gbWF4ICsgbWluKSAvIDI7XG5cblx0XHRcdFx0Ly8gaWYgbWluIGFuZCBtYXggb3B0aW9ucyBoYXZlIGJlZW4gc2V0LCBkb24ndCBnbyBiZXlvbmQgaXRcblx0XHRcdFx0bWluQXJncyA9IFttaW4gLSB6b29tT2Zmc2V0LCBwaWNrKG9wdGlvbnMubWluLCBtaW4gLSB6b29tT2Zmc2V0KV07XG5cdFx0XHRcdGlmIChzcGFjZUF2YWlsYWJsZSkgeyAvLyBpZiBzcGFjZSBpcyBhdmFpbGFibGUsIHN0YXkgd2l0aGluIHRoZSBkYXRhIHJhbmdlXG5cdFx0XHRcdFx0bWluQXJnc1syXSA9IGF4aXMuZGF0YU1pbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRtaW4gPSBhcnJheU1heChtaW5BcmdzKTtcblxuXHRcdFx0XHRtYXhBcmdzID0gW21pbiArIG1pblJhbmdlLCBwaWNrKG9wdGlvbnMubWF4LCBtaW4gKyBtaW5SYW5nZSldO1xuXHRcdFx0XHRpZiAoc3BhY2VBdmFpbGFibGUpIHsgLy8gaWYgc3BhY2UgaXMgYXZhaWxhYmUsIHN0YXkgd2l0aGluIHRoZSBkYXRhIHJhbmdlXG5cdFx0XHRcdFx0bWF4QXJnc1syXSA9IGF4aXMuZGF0YU1heDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1heCA9IGFycmF5TWluKG1heEFyZ3MpO1xuXG5cdFx0XHRcdC8vIG5vdyBpZiB0aGUgbWF4IGlzIGFkanVzdGVkLCBhZGp1c3QgdGhlIG1pbiBiYWNrXG5cdFx0XHRcdGlmIChtYXggLSBtaW4gPCBtaW5SYW5nZSkge1xuXHRcdFx0XHRcdG1pbkFyZ3NbMF0gPSBtYXggLSBtaW5SYW5nZTtcblx0XHRcdFx0XHRtaW5BcmdzWzFdID0gcGljayhvcHRpb25zLm1pbiwgbWF4IC0gbWluUmFuZ2UpO1xuXHRcdFx0XHRcdG1pbiA9IGFycmF5TWF4KG1pbkFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlY29yZCBtb2RpZmllZCBleHRyZW1lc1xuXHRcdFx0YXhpcy5taW4gPSBtaW47XG5cdFx0XHRheGlzLm1heCA9IG1heDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRyYW5zbGF0aW9uIGluZm9ybWF0aW9uXG5cdFx0ICovXG5cdFx0c2V0QXhpc1RyYW5zbGF0aW9uOiBmdW5jdGlvbiAoc2F2ZU9sZCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRyYW5nZSA9IGF4aXMubWF4IC0gYXhpcy5taW4sXG5cdFx0XHRcdHBvaW50UmFuZ2UgPSBheGlzLmF4aXNQb2ludFJhbmdlIHx8IDAsXG5cdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlLFxuXHRcdFx0XHRtaW5Qb2ludE9mZnNldCA9IDAsXG5cdFx0XHRcdHBvaW50UmFuZ2VQYWRkaW5nID0gMCxcblx0XHRcdFx0bGlua2VkUGFyZW50ID0gYXhpcy5saW5rZWRQYXJlbnQsXG5cdFx0XHRcdG9yZGluYWxDb3JyZWN0aW9uLFxuXHRcdFx0XHRoYXNDYXRlZ29yaWVzID0gISFheGlzLmNhdGVnb3JpZXMsXG5cdFx0XHRcdHRyYW5zQSA9IGF4aXMudHJhbnNBLFxuXHRcdFx0XHRpc1hBeGlzID0gYXhpcy5pc1hBeGlzO1xuXG5cdFx0XHQvLyBBZGp1c3QgdHJhbnNsYXRpb24gZm9yIHBhZGRpbmcuIFkgYXhpcyB3aXRoIGNhdGVnb3JpZXMgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSBzYW1lICgjMTc4NCkuXG5cdFx0XHRpZiAoaXNYQXhpcyB8fCBoYXNDYXRlZ29yaWVzIHx8IHBvaW50UmFuZ2UpIHtcblx0XHRcdFx0aWYgKGxpbmtlZFBhcmVudCkge1xuXHRcdFx0XHRcdG1pblBvaW50T2Zmc2V0ID0gbGlua2VkUGFyZW50Lm1pblBvaW50T2Zmc2V0O1xuXHRcdFx0XHRcdHBvaW50UmFuZ2VQYWRkaW5nID0gbGlua2VkUGFyZW50LnBvaW50UmFuZ2VQYWRkaW5nO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRcdFx0dmFyIHNlcmllc1BvaW50UmFuZ2UgPSBoYXNDYXRlZ29yaWVzID8gMSA6IChpc1hBeGlzID8gc2VyaWVzLnBvaW50UmFuZ2UgOiAoYXhpcy5heGlzUG9pbnRSYW5nZSB8fCAwKSksIC8vICMyODA2XG5cdFx0XHRcdFx0XHRcdHBvaW50UGxhY2VtZW50ID0gc2VyaWVzLm9wdGlvbnMucG9pbnRQbGFjZW1lbnQsXG5cdFx0XHRcdFx0XHRcdHNlcmllc0Nsb3Nlc3RQb2ludFJhbmdlID0gc2VyaWVzLmNsb3Nlc3RQb2ludFJhbmdlO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2VyaWVzUG9pbnRSYW5nZSA+IHJhbmdlKSB7IC8vICMxNDQ2XG5cdFx0XHRcdFx0XHRcdHNlcmllc1BvaW50UmFuZ2UgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cG9pbnRSYW5nZSA9IG1hdGhNYXgocG9pbnRSYW5nZSwgc2VyaWVzUG9pbnRSYW5nZSk7XG5cblx0XHRcdFx0XHRcdGlmICghYXhpcy5zaW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbWluUG9pbnRPZmZzZXQgaXMgdGhlIHZhbHVlIHBhZGRpbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGF4aXMgaW4gb3JkZXIgdG8gbWFrZVxuXHRcdFx0XHRcdFx0XHQvLyByb29tIGZvciBwb2ludHMgd2l0aCBhIHBvaW50UmFuZ2UsIHR5cGljYWxseSBjb2x1bW5zLiBXaGVuIHRoZSBwb2ludFBsYWNlbWVudCBvcHRpb25cblx0XHRcdFx0XHRcdFx0Ly8gaXMgJ2JldHdlZW4nIG9yICdvbicsIHRoaXMgcGFkZGluZyBkb2VzIG5vdCBhcHBseS5cblx0XHRcdFx0XHRcdFx0bWluUG9pbnRPZmZzZXQgPSBtYXRoTWF4KFxuXHRcdFx0XHRcdFx0XHRcdG1pblBvaW50T2Zmc2V0LFxuXHRcdFx0XHRcdFx0XHRcdGlzU3RyaW5nKHBvaW50UGxhY2VtZW50KSA/IDAgOiBzZXJpZXNQb2ludFJhbmdlIC8gMlxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIERldGVybWluZSB0aGUgdG90YWwgcGFkZGluZyBuZWVkZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXhpcyB0byBtYWtlIHJvb20gZm9yIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBwb2ludFJhbmdlLiBJZiB0aGUgc2VyaWVzJyBwb2ludFBsYWNlbWVudCBpcyAnb24nLCBubyBwYWRkaW5nIGlzIGFkZGVkLlxuXHRcdFx0XHRcdFx0XHRwb2ludFJhbmdlUGFkZGluZyA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcsXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPT09ICdvbicgPyAwIDogc2VyaWVzUG9pbnRSYW5nZVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBTZXQgdGhlIGNsb3Nlc3RQb2ludFJhbmdlXG5cdFx0XHRcdFx0XHRpZiAoIXNlcmllcy5ub1NoYXJlZFRvb2x0aXAgJiYgZGVmaW5lZChzZXJpZXNDbG9zZXN0UG9pbnRSYW5nZSkpIHtcblx0XHRcdFx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2UgPSBkZWZpbmVkKGNsb3Nlc3RQb2ludFJhbmdlKSA/XG5cdFx0XHRcdFx0XHRcdFx0bWF0aE1pbihjbG9zZXN0UG9pbnRSYW5nZSwgc2VyaWVzQ2xvc2VzdFBvaW50UmFuZ2UpIDpcblx0XHRcdFx0XHRcdFx0XHRzZXJpZXNDbG9zZXN0UG9pbnRSYW5nZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY29yZCBtaW5Qb2ludE9mZnNldCBhbmQgcG9pbnRSYW5nZVBhZGRpbmdcblx0XHRcdFx0b3JkaW5hbENvcnJlY3Rpb24gPSBheGlzLm9yZGluYWxTbG9wZSAmJiBjbG9zZXN0UG9pbnRSYW5nZSA/IGF4aXMub3JkaW5hbFNsb3BlIC8gY2xvc2VzdFBvaW50UmFuZ2UgOiAxOyAvLyAjOTg4LCAjMTg1M1xuXHRcdFx0XHRheGlzLm1pblBvaW50T2Zmc2V0ID0gbWluUG9pbnRPZmZzZXQgPSBtaW5Qb2ludE9mZnNldCAqIG9yZGluYWxDb3JyZWN0aW9uO1xuXHRcdFx0XHRheGlzLnBvaW50UmFuZ2VQYWRkaW5nID0gcG9pbnRSYW5nZVBhZGRpbmcgPSBwb2ludFJhbmdlUGFkZGluZyAqIG9yZGluYWxDb3JyZWN0aW9uO1xuXG5cdFx0XHRcdC8vIHBvaW50UmFuZ2UgbWVhbnMgdGhlIHdpZHRoIHJlc2VydmVkIGZvciBlYWNoIHBvaW50LCBsaWtlIGluIGEgY29sdW1uIGNoYXJ0XG5cdFx0XHRcdGF4aXMucG9pbnRSYW5nZSA9IG1hdGhNaW4ocG9pbnRSYW5nZSwgcmFuZ2UpO1xuXG5cdFx0XHRcdC8vIGNsb3Nlc3RQb2ludFJhbmdlIG1lYW5zIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzLiBJbiBjb2x1bW5zXG5cdFx0XHRcdC8vIGl0IGlzIG1vc3RseSBlcXVhbCB0byBwb2ludFJhbmdlLCBidXQgaW4gbGluZXMgcG9pbnRSYW5nZSBpcyAwIHdoaWxlIGNsb3Nlc3RQb2ludFJhbmdlXG5cdFx0XHRcdC8vIGlzIHNvbWUgb3RoZXIgdmFsdWVcblx0XHRcdFx0aWYgKGlzWEF4aXMpIHtcblx0XHRcdFx0XHRheGlzLmNsb3Nlc3RQb2ludFJhbmdlID0gY2xvc2VzdFBvaW50UmFuZ2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2Vjb25kYXJ5IHZhbHVlc1xuXHRcdFx0aWYgKHNhdmVPbGQpIHtcblx0XHRcdFx0YXhpcy5vbGRUcmFuc0EgPSB0cmFuc0E7XG5cdFx0XHR9XG5cdFx0XHRheGlzLnRyYW5zbGF0aW9uU2xvcGUgPSBheGlzLnRyYW5zQSA9IHRyYW5zQSA9IGF4aXMubGVuIC8gKChyYW5nZSArIHBvaW50UmFuZ2VQYWRkaW5nKSB8fCAxKTtcblx0XHRcdGF4aXMudHJhbnNCID0gYXhpcy5ob3JpeiA/IGF4aXMubGVmdCA6IGF4aXMuYm90dG9tOyAvLyB0cmFuc2xhdGlvbiBhZGRlbmRcblx0XHRcdGF4aXMubWluUGl4ZWxQYWRkaW5nID0gdHJhbnNBICogbWluUG9pbnRPZmZzZXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgdGljayBwb3NpdGlvbnMgdG8gcm91bmQgdmFsdWVzIGFuZCBvcHRpb25hbGx5IGV4dGVuZCB0aGUgZXh0cmVtZXNcblx0XHQgKiB0byB0aGUgbmVhcmVzdCB0aWNrXG5cdFx0ICovXG5cdFx0c2V0VGlja0ludGVydmFsOiBmdW5jdGlvbiAoc2Vjb25kUGFzcykge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRcdGlzTG9nID0gYXhpcy5pc0xvZyxcblx0XHRcdFx0aXNEYXRldGltZUF4aXMgPSBheGlzLmlzRGF0ZXRpbWVBeGlzLFxuXHRcdFx0XHRpc1hBeGlzID0gYXhpcy5pc1hBeGlzLFxuXHRcdFx0XHRpc0xpbmtlZCA9IGF4aXMuaXNMaW5rZWQsXG5cdFx0XHRcdG1heFBhZGRpbmcgPSBvcHRpb25zLm1heFBhZGRpbmcsXG5cdFx0XHRcdG1pblBhZGRpbmcgPSBvcHRpb25zLm1pblBhZGRpbmcsXG5cdFx0XHRcdGxlbmd0aCxcblx0XHRcdFx0bGlua2VkUGFyZW50RXh0cmVtZXMsXG5cdFx0XHRcdHRpY2tJbnRlcnZhbE9wdGlvbiA9IG9wdGlvbnMudGlja0ludGVydmFsLFxuXHRcdFx0XHRtaW5UaWNrSW50ZXJ2YWwsXG5cdFx0XHRcdHRpY2tQaXhlbEludGVydmFsT3B0aW9uID0gb3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbCxcblx0XHRcdFx0Y2F0ZWdvcmllcyA9IGF4aXMuY2F0ZWdvcmllcztcblxuXHRcdFx0aWYgKCFpc0RhdGV0aW1lQXhpcyAmJiAhY2F0ZWdvcmllcyAmJiAhaXNMaW5rZWQpIHtcblx0XHRcdFx0dGhpcy5nZXRUaWNrQW1vdW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGxpbmtlZCBheGlzIGdldHMgdGhlIGV4dHJlbWVzIGZyb20gdGhlIHBhcmVudCBheGlzXG5cdFx0XHRpZiAoaXNMaW5rZWQpIHtcblx0XHRcdFx0YXhpcy5saW5rZWRQYXJlbnQgPSBjaGFydFtheGlzLmNvbGxdW29wdGlvbnMubGlua2VkVG9dO1xuXHRcdFx0XHRsaW5rZWRQYXJlbnRFeHRyZW1lcyA9IGF4aXMubGlua2VkUGFyZW50LmdldEV4dHJlbWVzKCk7XG5cdFx0XHRcdGF4aXMubWluID0gcGljayhsaW5rZWRQYXJlbnRFeHRyZW1lcy5taW4sIGxpbmtlZFBhcmVudEV4dHJlbWVzLmRhdGFNaW4pO1xuXHRcdFx0XHRheGlzLm1heCA9IHBpY2sobGlua2VkUGFyZW50RXh0cmVtZXMubWF4LCBsaW5rZWRQYXJlbnRFeHRyZW1lcy5kYXRhTWF4KTtcblx0XHRcdFx0aWYgKG9wdGlvbnMudHlwZSAhPT0gYXhpcy5saW5rZWRQYXJlbnQub3B0aW9ucy50eXBlKSB7XG5cdFx0XHRcdFx0ZXJyb3IoMTEsIDEpOyAvLyBDYW4ndCBsaW5rIGF4ZXMgb2YgZGlmZmVyZW50IHR5cGVcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHsgLy8gaW5pdGlhbCBtaW4gYW5kIG1heCBmcm9tIHRoZSBleHRyZW1lIGRhdGEgdmFsdWVzXG5cdFx0XHRcdGF4aXMubWluID0gcGljayhheGlzLnVzZXJNaW4sIG9wdGlvbnMubWluLCBheGlzLmRhdGFNaW4pO1xuXHRcdFx0XHRheGlzLm1heCA9IHBpY2soYXhpcy51c2VyTWF4LCBvcHRpb25zLm1heCwgYXhpcy5kYXRhTWF4KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzTG9nKSB7XG5cdFx0XHRcdGlmICghc2Vjb25kUGFzcyAmJiBtYXRoTWluKGF4aXMubWluLCBwaWNrKGF4aXMuZGF0YU1pbiwgYXhpcy5taW4pKSA8PSAwKSB7IC8vICM5Nzhcblx0XHRcdFx0XHRlcnJvcigxMCwgMSk7IC8vIENhbid0IHBsb3QgbmVnYXRpdmUgdmFsdWVzIG9uIGxvZyBheGlzXG5cdFx0XHRcdH1cblx0XHRcdFx0YXhpcy5taW4gPSBjb3JyZWN0RmxvYXQobG9nMmxpbihheGlzLm1pbikpOyAvLyBjb3JyZWN0RmxvYXQgY3VyZXMgIzkzNFxuXHRcdFx0XHRheGlzLm1heCA9IGNvcnJlY3RGbG9hdChsb2cybGluKGF4aXMubWF4KSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhhbmRsZSB6b29tZWQgcmFuZ2Vcblx0XHRcdGlmIChheGlzLnJhbmdlICYmIGRlZmluZWQoYXhpcy5tYXgpKSB7XG5cdFx0XHRcdGF4aXMudXNlck1pbiA9IGF4aXMubWluID0gbWF0aE1heChheGlzLm1pbiwgYXhpcy5tYXggLSBheGlzLnJhbmdlKTsgLy8gIzYxOFxuXHRcdFx0XHRheGlzLnVzZXJNYXggPSBheGlzLm1heDtcblxuXHRcdFx0XHRheGlzLnJhbmdlID0gbnVsbDsgIC8vIGRvbid0IHVzZSBpdCB3aGVuIHJ1bm5pbmcgc2V0RXh0cmVtZXNcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBmb3IgYWRqdXN0aW5nIHRoaXMubWluIGFuZCB0aGlzLm1heC4gVXNlZCBieSBidWJibGUgc2VyaWVzLlxuXHRcdFx0aWYgKGF4aXMuYmVmb3JlUGFkZGluZykge1xuXHRcdFx0XHRheGlzLmJlZm9yZVBhZGRpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRqdXN0IG1pbiBhbmQgbWF4IGZvciB0aGUgbWluaW11bSByYW5nZVxuXHRcdFx0YXhpcy5hZGp1c3RGb3JNaW5SYW5nZSgpO1xuXG5cdFx0XHQvLyBQYWQgdGhlIHZhbHVlcyB0byBnZXQgY2xlYXIgb2YgdGhlIGNoYXJ0J3MgZWRnZXMuIFRvIGF2b2lkIHRpY2tJbnRlcnZhbCB0YWtpbmcgdGhlIHBhZGRpbmdcblx0XHRcdC8vIGludG8gYWNjb3VudCwgd2UgZG8gdGhpcyBhZnRlciBjb21wdXRpbmcgdGljayBpbnRlcnZhbCAoIzEzMzcpLlxuXHRcdFx0aWYgKCFjYXRlZ29yaWVzICYmICFheGlzLmF4aXNQb2ludFJhbmdlICYmICFheGlzLnVzZVBlcmNlbnRhZ2UgJiYgIWlzTGlua2VkICYmIGRlZmluZWQoYXhpcy5taW4pICYmIGRlZmluZWQoYXhpcy5tYXgpKSB7XG5cdFx0XHRcdGxlbmd0aCA9IGF4aXMubWF4IC0gYXhpcy5taW47XG5cdFx0XHRcdGlmIChsZW5ndGgpIHtcblx0XHRcdFx0XHRpZiAoIWRlZmluZWQob3B0aW9ucy5taW4pICYmICFkZWZpbmVkKGF4aXMudXNlck1pbikgJiYgbWluUGFkZGluZyAmJiAoYXhpcy5kYXRhTWluIDwgMCB8fCAhYXhpcy5pZ25vcmVNaW5QYWRkaW5nKSkge1xuXHRcdFx0XHRcdFx0YXhpcy5taW4gLT0gbGVuZ3RoICogbWluUGFkZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFkZWZpbmVkKG9wdGlvbnMubWF4KSAmJiAhZGVmaW5lZChheGlzLnVzZXJNYXgpICAmJiBtYXhQYWRkaW5nICYmIChheGlzLmRhdGFNYXggPiAwIHx8ICFheGlzLmlnbm9yZU1heFBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0XHRheGlzLm1heCArPSBsZW5ndGggKiBtYXhQYWRkaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF5IHdpdGhpbiBmbG9vciBhbmQgY2VpbGluZ1xuXHRcdFx0aWYgKGlzTnVtYmVyKG9wdGlvbnMuZmxvb3IpKSB7XG5cdFx0XHRcdGF4aXMubWluID0gbWF0aE1heChheGlzLm1pbiwgb3B0aW9ucy5mbG9vcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNOdW1iZXIob3B0aW9ucy5jZWlsaW5nKSkge1xuXHRcdFx0XHRheGlzLm1heCA9IG1hdGhNaW4oYXhpcy5tYXgsIG9wdGlvbnMuY2VpbGluZyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCB0aWNrSW50ZXJ2YWxcblx0XHRcdGlmIChheGlzLm1pbiA9PT0gYXhpcy5tYXggfHwgYXhpcy5taW4gPT09IHVuZGVmaW5lZCB8fCBheGlzLm1heCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGF4aXMudGlja0ludGVydmFsID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoaXNMaW5rZWQgJiYgIXRpY2tJbnRlcnZhbE9wdGlvbiAmJlxuXHRcdFx0XHRcdHRpY2tQaXhlbEludGVydmFsT3B0aW9uID09PSBheGlzLmxpbmtlZFBhcmVudC5vcHRpb25zLnRpY2tQaXhlbEludGVydmFsKSB7XG5cdFx0XHRcdGF4aXMudGlja0ludGVydmFsID0gYXhpcy5saW5rZWRQYXJlbnQudGlja0ludGVydmFsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBwaWNrKFxuXHRcdFx0XHRcdHRpY2tJbnRlcnZhbE9wdGlvbixcblx0XHRcdFx0XHR0aGlzLnRpY2tBbW91bnQgPyAoKGF4aXMubWF4IC0gYXhpcy5taW4pIC8gbWF0aE1heCh0aGlzLnRpY2tBbW91bnQgLSAxLCAxKSkgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0Y2F0ZWdvcmllcyA/IC8vIGZvciBjYXRlZ29yaWVkIGF4aXMsIDEgaXMgZGVmYXVsdCwgZm9yIGxpbmVhciBheGlzIHVzZSB0aWNrUGl4XG5cdFx0XHRcdFx0XHQxIDpcblx0XHRcdFx0XHRcdC8vIGRvbid0IGxldCBpdCBiZSBtb3JlIHRoYW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0XHRcdChheGlzLm1heCAtIGF4aXMubWluKSAqIHRpY2tQaXhlbEludGVydmFsT3B0aW9uIC8gbWF0aE1heChheGlzLmxlbiwgdGlja1BpeGVsSW50ZXJ2YWxPcHRpb24pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vdyB3ZSdyZSBmaW5pc2hlZCBkZXRlY3RpbmcgbWluIGFuZCBtYXgsIGNyb3AgYW5kIGdyb3VwIHNlcmllcyBkYXRhLiBUaGlzXG5cdFx0XHQvLyBpcyBpbiB0dXJuIG5lZWRlZCBpbiBvcmRlciB0byBmaW5kIHRpY2sgcG9zaXRpb25zIGluIG9yZGluYWwgYXhlcy5cblx0XHRcdGlmIChpc1hBeGlzICYmICFzZWNvbmRQYXNzKSB7XG5cdFx0XHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0XHRzZXJpZXMucHJvY2Vzc0RhdGEoYXhpcy5taW4gIT09IGF4aXMub2xkTWluIHx8IGF4aXMubWF4ICE9PSBheGlzLm9sZE1heCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgdGhlIHRyYW5zbGF0aW9uIGZhY3RvciB1c2VkIGluIHRyYW5zbGF0ZSBmdW5jdGlvblxuXHRcdFx0YXhpcy5zZXRBeGlzVHJhbnNsYXRpb24odHJ1ZSk7XG5cblx0XHRcdC8vIGhvb2sgZm9yIG9yZGluYWwgYXhlcyBhbmQgcmFkaWFsIGF4ZXNcblx0XHRcdGlmIChheGlzLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMpIHtcblx0XHRcdFx0YXhpcy5iZWZvcmVTZXRUaWNrUG9zaXRpb25zKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhvb2sgZm9yIGV4dGVuc2lvbnMsIHVzZWQgaW4gSGlnaHN0b2NrIG9yZGluYWwgYXhlc1xuXHRcdFx0aWYgKGF4aXMucG9zdFByb2Nlc3NUaWNrSW50ZXJ2YWwpIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBheGlzLnBvc3RQcm9jZXNzVGlja0ludGVydmFsKGF4aXMudGlja0ludGVydmFsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW4gY29sdW1uLWxpa2UgY2hhcnRzLCBkb24ndCBjcmFtcCBpbiBtb3JlIHRpY2tzIHRoYW4gdGhlcmUgYXJlIHBvaW50cyAoIzE5NDMpXG5cdFx0XHRpZiAoYXhpcy5wb2ludFJhbmdlKSB7XG5cdFx0XHRcdGF4aXMudGlja0ludGVydmFsID0gbWF0aE1heChheGlzLnBvaW50UmFuZ2UsIGF4aXMudGlja0ludGVydmFsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQmVmb3JlIG5vcm1hbGl6aW5nIHRoZSB0aWNrIGludGVydmFsLCBoYW5kbGUgbWluaW11bSB0aWNrIGludGVydmFsLiBUaGlzIGFwcGxpZXMgb25seSBpZiB0aWNrSW50ZXJ2YWwgaXMgbm90IGRlZmluZWQuXG5cdFx0XHRtaW5UaWNrSW50ZXJ2YWwgPSBwaWNrKG9wdGlvbnMubWluVGlja0ludGVydmFsLCBheGlzLmlzRGF0ZXRpbWVBeGlzICYmIGF4aXMuY2xvc2VzdFBvaW50UmFuZ2UpO1xuXHRcdFx0aWYgKCF0aWNrSW50ZXJ2YWxPcHRpb24gJiYgYXhpcy50aWNrSW50ZXJ2YWwgPCBtaW5UaWNrSW50ZXJ2YWwpIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBtaW5UaWNrSW50ZXJ2YWw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBsaW5lYXIgYXhlcywgZ2V0IG1hZ25pdHVkZSBhbmQgbm9ybWFsaXplIHRoZSBpbnRlcnZhbFxuXHRcdFx0aWYgKCFpc0RhdGV0aW1lQXhpcyAmJiAhaXNMb2cpIHsgLy8gbGluZWFyXG5cdFx0XHRcdGlmICghdGlja0ludGVydmFsT3B0aW9uKSB7XG5cdFx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBub3JtYWxpemVUaWNrSW50ZXJ2YWwoXG5cdFx0XHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCwgXG5cdFx0XHRcdFx0XHRudWxsLCBcblx0XHRcdFx0XHRcdGdldE1hZ25pdHVkZShheGlzLnRpY2tJbnRlcnZhbCksIFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHRpY2sgaW50ZXJ2YWwgaXMgYmV0d2VlbiAwLjUgYW5kIDUgYW5kIHRoZSBheGlzIG1heCBpcyBpbiB0aGUgb3JkZXIgb2Zcblx0XHRcdFx0XHRcdC8vIHRob3VzYW5kcywgY2hhbmNlcyBhcmUgd2UgYXJlIGRlYWxpbmcgd2l0aCB5ZWFycy4gRG9uJ3QgYWxsb3cgZGVjaW1hbHMuICMzMzYzLlxuXHRcdFx0XHRcdFx0cGljayhvcHRpb25zLmFsbG93RGVjaW1hbHMsICEoYXhpcy50aWNrSW50ZXJ2YWwgPiAwLjUgJiYgYXhpcy50aWNrSW50ZXJ2YWwgPCA1ICYmIGF4aXMubWF4ID4gMTAwMCAmJiBheGlzLm1heCA8IDk5OTkpKSxcblx0XHRcdFx0XHRcdCEhdGhpcy50aWNrQW1vdW50XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcmV2ZW50IHRpY2tzIGZyb20gZ2V0dGluZyBzbyBjbG9zZSB0aGF0IHdlIGNhbid0IGRyYXcgdGhlIGxhYmVsc1xuXHRcdFx0aWYgKCF0aGlzLnRpY2tBbW91bnQgJiYgdGhpcy5sZW4pIHsgLy8gQ29sb3IgYXhpcyB3aXRoIGRpc2FibGVkIGxlZ2VuZCBoYXMgbm8gbGVuZ3RoXG5cdFx0XHRcdGF4aXMudGlja0ludGVydmFsID0gYXhpcy51bnNxdWlzaCgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFRpY2tQb3NpdGlvbnMoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTm93IHdlIGhhdmUgY29tcHV0ZWQgdGhlIG5vcm1hbGl6ZWQgdGlja0ludGVydmFsLCBnZXQgdGhlIHRpY2sgcG9zaXRpb25zXG5cdFx0ICovXG5cdFx0c2V0VGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0dGlja1Bvc2l0aW9uc09wdGlvbiA9IG9wdGlvbnMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0dGlja1Bvc2l0aW9uZXIgPSBvcHRpb25zLnRpY2tQb3NpdGlvbmVyLFxuXHRcdFx0XHRzdGFydE9uVGljayA9IG9wdGlvbnMuc3RhcnRPblRpY2ssXG5cdFx0XHRcdGVuZE9uVGljayA9IG9wdGlvbnMuZW5kT25UaWNrLFxuXHRcdFx0XHRzaW5nbGU7XG5cblx0XHRcdC8vIFNldCB0aGUgdGlja21hcmtPZmZzZXRcblx0XHRcdHRoaXMudGlja21hcmtPZmZzZXQgPSAodGhpcy5jYXRlZ29yaWVzICYmIG9wdGlvbnMudGlja21hcmtQbGFjZW1lbnQgPT09ICdiZXR3ZWVuJyAmJiBcblx0XHRcdFx0dGhpcy50aWNrSW50ZXJ2YWwgPT09IDEpID8gMC41IDogMDsgLy8gIzMyMDJcblxuXG5cdFx0XHQvLyBnZXQgbWlub3JUaWNrSW50ZXJ2YWxcblx0XHRcdHRoaXMubWlub3JUaWNrSW50ZXJ2YWwgPSBvcHRpb25zLm1pbm9yVGlja0ludGVydmFsID09PSAnYXV0bycgJiYgdGhpcy50aWNrSW50ZXJ2YWwgP1xuXHRcdFx0XHR0aGlzLnRpY2tJbnRlcnZhbCAvIDUgOiBvcHRpb25zLm1pbm9yVGlja0ludGVydmFsO1xuXG5cdFx0XHQvLyBGaW5kIHRoZSB0aWNrIHBvc2l0aW9uc1xuXHRcdFx0dGhpcy50aWNrUG9zaXRpb25zID0gdGlja1Bvc2l0aW9ucyA9IG9wdGlvbnMudGlja1Bvc2l0aW9ucyAmJiBvcHRpb25zLnRpY2tQb3NpdGlvbnMuc2xpY2UoKTsgLy8gV29yayBvbiBhIGNvcHkgKCMxNTY1KVxuXHRcdFx0aWYgKCF0aWNrUG9zaXRpb25zKSB7XG5cblx0XHRcdFx0aWYgKHRoaXMuaXNEYXRldGltZUF4aXMpIHtcblx0XHRcdFx0XHR0aWNrUG9zaXRpb25zID0gdGhpcy5nZXRUaW1lVGlja3MoXG5cdFx0XHRcdFx0XHR0aGlzLm5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWwodGhpcy50aWNrSW50ZXJ2YWwsIG9wdGlvbnMudW5pdHMpLFxuXHRcdFx0XHRcdFx0dGhpcy5taW4sXG5cdFx0XHRcdFx0XHR0aGlzLm1heCxcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RhcnRPZldlZWssXG5cdFx0XHRcdFx0XHR0aGlzLm9yZGluYWxQb3NpdGlvbnMsXG5cdFx0XHRcdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFJhbmdlLFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5pc0xvZykge1xuXHRcdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSB0aGlzLmdldExvZ1RpY2tQb3NpdGlvbnModGhpcy50aWNrSW50ZXJ2YWwsIHRoaXMubWluLCB0aGlzLm1heCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IHRoaXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCwgdGhpcy5taW4sIHRoaXMubWF4KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudGlja1Bvc2l0aW9ucyA9IHRpY2tQb3NpdGlvbnM7XG5cblx0XHRcdFx0Ly8gUnVuIHRoZSB0aWNrIHBvc2l0aW9uZXIgY2FsbGJhY2ssIHRoYXQgYWxsb3dzIG1vZGlmeWluZyBhdXRvIHRpY2sgcG9zaXRpb25zLlxuXHRcdFx0XHRpZiAodGlja1Bvc2l0aW9uZXIpIHtcblx0XHRcdFx0XHR0aWNrUG9zaXRpb25lciA9IHRpY2tQb3NpdGlvbmVyLmFwcGx5KHRoaXMsIFt0aGlzLm1pbiwgdGhpcy5tYXhdKTtcblx0XHRcdFx0XHRpZiAodGlja1Bvc2l0aW9uZXIpIHtcblx0XHRcdFx0XHRcdHRoaXMudGlja1Bvc2l0aW9ucyA9IHRpY2tQb3NpdGlvbnMgPSB0aWNrUG9zaXRpb25lcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuaXNMaW5rZWQpIHtcblxuXHRcdFx0XHQvLyByZXNldCBtaW4vbWF4IG9yIHJlbW92ZSBleHRyZW1lcyBiYXNlZCBvbiBzdGFydC9lbmQgb24gdGlja1xuXHRcdFx0XHR0aGlzLnRyaW1UaWNrcyh0aWNrUG9zaXRpb25zLCBzdGFydE9uVGljaywgZW5kT25UaWNrKTtcblxuXHRcdFx0XHQvLyBXaGVuIHRoZXJlIGlzIG9ubHkgb25lIHBvaW50LCBvciBhbGwgcG9pbnRzIGhhdmUgdGhlIHNhbWUgdmFsdWUgb24gdGhpcyBheGlzLCB0aGVuIG1pblxuXHRcdFx0XHQvLyBhbmQgbWF4IGFyZSBlcXVhbCBhbmQgdGlja1Bvc2l0aW9ucy5sZW5ndGggaXMgMCBvciAxLiBJbiB0aGlzIGNhc2UsIGFkZCBzb21lIHBhZGRpbmdcblx0XHRcdFx0Ly8gaW4gb3JkZXIgdG8gY2VudGVyIHRoZSBwb2ludCwgYnV0IGxlYXZlIGl0IHdpdGggb25lIHRpY2suICMxMzM3LlxuXHRcdFx0XHRpZiAodGhpcy5taW4gPT09IHRoaXMubWF4ICYmIGRlZmluZWQodGhpcy5taW4pICYmICF0aGlzLnRpY2tBbW91bnQpIHtcblx0XHRcdFx0XHQvLyBTdWJzdHJhY3QgaGFsZiBhIHVuaXQgKCMyNjE5LCAjMjg0NiwgIzI1MTUsICMzMzkwKVxuXHRcdFx0XHRcdHNpbmdsZSA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5taW4gLT0gMC41O1xuXHRcdFx0XHRcdHRoaXMubWF4ICs9IDAuNTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNpbmdsZSA9IHNpbmdsZTtcblxuXHRcdFx0XHRpZiAoIXRpY2tQb3NpdGlvbnNPcHRpb24gJiYgIXRpY2tQb3NpdGlvbmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGp1c3RUaWNrQW1vdW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlIHN0YXJ0T25UaWNrIGFuZCBlbmRPblRpY2sgYnkgZWl0aGVyIGFkYXB0aW5nIHRvIHBhZGRpbmcgbWluL21heCBvciByb3VuZGVkIG1pbi9tYXhcblx0XHQgKi9cblx0XHR0cmltVGlja3M6IGZ1bmN0aW9uICh0aWNrUG9zaXRpb25zLCBzdGFydE9uVGljaywgZW5kT25UaWNrKSB7XG5cdFx0XHR2YXIgcm91bmRlZE1pbiA9IHRpY2tQb3NpdGlvbnNbMF0sXG5cdFx0XHRcdHJvdW5kZWRNYXggPSB0aWNrUG9zaXRpb25zW3RpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMV0sXG5cdFx0XHRcdG1pblBvaW50T2Zmc2V0ID0gdGhpcy5taW5Qb2ludE9mZnNldCB8fCAwO1xuXHRcdFx0XHRcblx0XHRcdGlmIChzdGFydE9uVGljaykge1xuXHRcdFx0XHR0aGlzLm1pbiA9IHJvdW5kZWRNaW47XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMubWluIC0gbWluUG9pbnRPZmZzZXQgPiByb3VuZGVkTWluKSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGVuZE9uVGljaykge1xuXHRcdFx0XHR0aGlzLm1heCA9IHJvdW5kZWRNYXg7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMubWF4ICsgbWluUG9pbnRPZmZzZXQgPCByb3VuZGVkTWF4KSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMucG9wKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG5vIHRpY2sgYXJlIGxlZnQsIHNldCBvbmUgdGljayBpbiB0aGUgbWlkZGxlICgjMzE5NSkgXG5cdFx0XHRpZiAodGlja1Bvc2l0aW9ucy5sZW5ndGggPT09IDAgJiYgZGVmaW5lZChyb3VuZGVkTWluKSkge1xuXHRcdFx0XHR0aWNrUG9zaXRpb25zLnB1c2goKHJvdW5kZWRNYXggKyByb3VuZGVkTWluKSAvIDIpO1xuXHRcdFx0fVx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBtYXggdGlja3Mgb2YgZWl0aGVyIHRoZSB4IGFuZCB5IGF4aXMgY29sbGVjdGlvblxuXHRcdCAqL1xuXHRcdGdldFRpY2tBbW91bnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBvdGhlcnMgPSB7fSwgLy8gV2hldGhlciB0aGVyZSBpcyBhbm90aGVyIGF4aXMgdG8gcGFpciB3aXRoIHRoaXMgb25lXG5cdFx0XHRcdGhhc090aGVyLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR0aWNrQW1vdW50ID0gb3B0aW9ucy50aWNrQW1vdW50LFxuXHRcdFx0XHR0aWNrUGl4ZWxJbnRlcnZhbCA9IG9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWw7XG5cblx0XHRcdGlmICghZGVmaW5lZChvcHRpb25zLnRpY2tJbnRlcnZhbCkgJiYgdGhpcy5sZW4gPCB0aWNrUGl4ZWxJbnRlcnZhbCAmJiAhdGhpcy5pc1JhZGlhbCAmJlxuXHRcdFx0XHRcdCF0aGlzLmlzTG9nICYmIG9wdGlvbnMuc3RhcnRPblRpY2sgJiYgb3B0aW9ucy5lbmRPblRpY2spIHtcblx0XHRcdFx0dGlja0Ftb3VudCA9IDI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGlja0Ftb3VudCAmJiB0aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuYWxpZ25UaWNrcyAhPT0gZmFsc2UgJiYgb3B0aW9ucy5hbGlnblRpY2tzICE9PSBmYWxzZSkge1xuXHRcdFx0XHQvLyBDaGVjayBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgYXhlcyBpbiB0aGUgc2FtZSBwYW5lXG5cdFx0XHRcdGVhY2godGhpcy5jaGFydFt0aGlzLmNvbGxdLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdHZhciBvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHRcdFx0aG9yaXogPSBheGlzLmhvcml6LFxuXHRcdFx0XHRcdFx0a2V5ID0gW2hvcml6ID8gb3B0aW9ucy5sZWZ0IDogb3B0aW9ucy50b3AsIGhvcml6ID8gb3B0aW9ucy53aWR0aCA6IG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLnBhbmVdLmpvaW4oJywnKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAob3RoZXJzW2tleV0pIHtcblx0XHRcdFx0XHRcdGhhc090aGVyID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3RoZXJzW2tleV0gPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGhhc090aGVyKSB7XG5cdFx0XHRcdFx0Ly8gQWRkIDEgYmVjYXVzZSA0IHRpY2sgaW50ZXJ2YWxzIHJlcXVpcmUgNSB0aWNrcyAoaW5jbHVkaW5nIGZpcnN0IGFuZCBsYXN0KVxuXHRcdFx0XHRcdHRpY2tBbW91bnQgPSBtYXRoQ2VpbCh0aGlzLmxlbiAvIHRpY2tQaXhlbEludGVydmFsKSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIHRpY2sgYW1vdW50cyBvZiAyIGFuZCAzLCBjb21wdXRlIGZpdmUgdGlja3MgYW5kIHJlbW92ZSB0aGUgaW50ZXJtZWRpYXRlIG9uZXMuIFRoaXNcblx0XHRcdC8vIHByZXZlbnRzIHRoZSBheGlzIGZyb20gYWRkaW5nIHRpY2tzIHRoYXQgYXJlIHRvbyBmYXIgYXdheSBmcm9tIHRoZSBkYXRhIGV4dHJlbWVzLlxuXHRcdFx0aWYgKHRpY2tBbW91bnQgPCA0KSB7XG5cdFx0XHRcdHRoaXMuZmluYWxUaWNrQW10ID0gdGlja0Ftb3VudDtcblx0XHRcdFx0dGlja0Ftb3VudCA9IDU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMudGlja0Ftb3VudCA9IHRpY2tBbW91bnQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdXNpbmcgbXVsdGlwbGUgYXhlcywgYWRqdXN0IHRoZSBudW1iZXIgb2YgdGlja3MgdG8gbWF0Y2ggdGhlIGhpZ2hlc3Rcblx0XHQgKiBudW1iZXIgb2YgdGlja3MgaW4gdGhhdCBncm91cFxuXHRcdCAqL1xuXHRcdGFkanVzdFRpY2tBbW91bnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB0aWNrSW50ZXJ2YWwgPSB0aGlzLnRpY2tJbnRlcnZhbCxcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IHRoaXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0dGlja0Ftb3VudCA9IHRoaXMudGlja0Ftb3VudCxcblx0XHRcdFx0ZmluYWxUaWNrQW10ID0gdGhpcy5maW5hbFRpY2tBbXQsXG5cdFx0XHRcdGN1cnJlbnRUaWNrQW1vdW50ID0gdGlja1Bvc2l0aW9ucyAmJiB0aWNrUG9zaXRpb25zLmxlbmd0aCxcblx0XHRcdFx0aSxcblx0XHRcdFx0bGVuO1xuXG5cdFx0XHRpZiAoY3VycmVudFRpY2tBbW91bnQgPCB0aWNrQW1vdW50KSB7IC8vIFRPRE86IENoZWNrICMzNDExXG5cdFx0XHRcdHdoaWxlICh0aWNrUG9zaXRpb25zLmxlbmd0aCA8IHRpY2tBbW91bnQpIHtcblx0XHRcdFx0XHR0aWNrUG9zaXRpb25zLnB1c2goY29ycmVjdEZsb2F0KFxuXHRcdFx0XHRcdFx0dGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdICsgdGlja0ludGVydmFsXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50cmFuc0EgKj0gKGN1cnJlbnRUaWNrQW1vdW50IC0gMSkgLyAodGlja0Ftb3VudCAtIDEpO1xuXHRcdFx0XHR0aGlzLm1heCA9IHRpY2tQb3NpdGlvbnNbdGlja1Bvc2l0aW9ucy5sZW5ndGggLSAxXTtcblxuXHRcdFx0Ly8gV2UgaGF2ZSB0b28gbWFueSB0aWNrcywgcnVuIHNlY29uZCBwYXNzIHRvIHRyeSB0byByZWR1Y2UgdGlja3Ncblx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFRpY2tBbW91bnQgPiB0aWNrQW1vdW50KSB7XG5cdFx0XHRcdHRoaXMudGlja0ludGVydmFsICo9IDI7XG5cdFx0XHRcdHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZmluYWxUaWNrQW10IHByb3BlcnR5IGlzIHNldCBpbiBnZXRUaWNrQW1vdW50XG5cdFx0XHRpZiAoZGVmaW5lZChmaW5hbFRpY2tBbXQpKSB7XG5cdFx0XHRcdGkgPSBsZW4gPSB0aWNrUG9zaXRpb25zLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdChmaW5hbFRpY2tBbXQgPT09IDMgJiYgaSAlIDIgPT09IDEpIHx8IC8vIFJlbW92ZSBldmVyeSBvdGhlciB0aWNrXG5cdFx0XHRcdFx0XHQoZmluYWxUaWNrQW10IDw9IDIgJiYgaSA+IDAgJiYgaSA8IGxlbiAtIDEpIC8vIFJlbW92ZSBhbGwgYnV0IGZpcnN0IGFuZCBsYXN0XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR0aWNrUG9zaXRpb25zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XHRcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZpbmFsVGlja0FtdCA9IFVOREVGSU5FRDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBzY2FsZSBiYXNlZCBvbiBkYXRhIG1pbiBhbmQgbWF4LCB1c2VyIHNldCBtaW4gYW5kIG1heCBvciBvcHRpb25zXG5cdFx0ICpcblx0XHQgKi9cblx0XHRzZXRTY2FsZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRzdGFja3MgPSBheGlzLnN0YWNrcyxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0aSxcblx0XHRcdFx0aXNEaXJ0eURhdGEsXG5cdFx0XHRcdGlzRGlydHlBeGlzTGVuZ3RoO1xuXG5cdFx0XHRheGlzLm9sZE1pbiA9IGF4aXMubWluO1xuXHRcdFx0YXhpcy5vbGRNYXggPSBheGlzLm1heDtcblx0XHRcdGF4aXMub2xkQXhpc0xlbmd0aCA9IGF4aXMubGVuO1xuXG5cdFx0XHQvLyBzZXQgdGhlIG5ldyBheGlzTGVuZ3RoXG5cdFx0XHRheGlzLnNldEF4aXNTaXplKCk7XG5cdFx0XHQvL2F4aXNMZW5ndGggPSBob3JpeiA/IGF4aXNXaWR0aCA6IGF4aXNIZWlnaHQ7XG5cdFx0XHRpc0RpcnR5QXhpc0xlbmd0aCA9IGF4aXMubGVuICE9PSBheGlzLm9sZEF4aXNMZW5ndGg7XG5cblx0XHRcdC8vIGlzIHRoZXJlIG5ldyBkYXRhP1xuXHRcdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRpZiAoc2VyaWVzLmlzRGlydHlEYXRhIHx8IHNlcmllcy5pc0RpcnR5IHx8XG5cdFx0XHRcdFx0XHRzZXJpZXMueEF4aXMuaXNEaXJ0eSkgeyAvLyB3aGVuIHggYXhpcyBpcyBkaXJ0eSwgd2UgbmVlZCBuZXcgZGF0YSBleHRyZW1lcyBmb3IgeSBhcyB3ZWxsXG5cdFx0XHRcdFx0aXNEaXJ0eURhdGEgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gZG8gd2UgcmVhbGx5IG5lZWQgdG8gZ28gdGhyb3VnaCBhbGwgdGhpcz9cblx0XHRcdGlmIChpc0RpcnR5QXhpc0xlbmd0aCB8fCBpc0RpcnR5RGF0YSB8fCBheGlzLmlzTGlua2VkIHx8IGF4aXMuZm9yY2VSZWRyYXcgfHxcblx0XHRcdFx0YXhpcy51c2VyTWluICE9PSBheGlzLm9sZFVzZXJNaW4gfHwgYXhpcy51c2VyTWF4ICE9PSBheGlzLm9sZFVzZXJNYXgpIHtcblxuXHRcdFx0XHQvLyByZXNldCBzdGFja3Ncblx0XHRcdFx0aWYgKCFheGlzLmlzWEF4aXMpIHtcblx0XHRcdFx0XHRmb3IgKHR5cGUgaW4gc3RhY2tzKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGkgaW4gc3RhY2tzW3R5cGVdKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWNrc1t0eXBlXVtpXS50b3RhbCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHN0YWNrc1t0eXBlXVtpXS5jdW0gPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF4aXMuZm9yY2VSZWRyYXcgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBnZXQgZGF0YSBleHRyZW1lcyBpZiBuZWVkZWRcblx0XHRcdFx0YXhpcy5nZXRTZXJpZXNFeHRyZW1lcygpO1xuXG5cdFx0XHRcdC8vIGdldCBmaXhlZCBwb3NpdGlvbnMgYmFzZWQgb24gdGlja0ludGVydmFsXG5cdFx0XHRcdGF4aXMuc2V0VGlja0ludGVydmFsKCk7XG5cblx0XHRcdFx0Ly8gcmVjb3JkIG9sZCB2YWx1ZXMgdG8gZGVjaWRlIHdoZXRoZXIgYSByZXNjYWxlIGlzIG5lY2Vzc2FyeSBsYXRlciBvbiAoIzU0MClcblx0XHRcdFx0YXhpcy5vbGRVc2VyTWluID0gYXhpcy51c2VyTWluO1xuXHRcdFx0XHRheGlzLm9sZFVzZXJNYXggPSBheGlzLnVzZXJNYXg7XG5cblx0XHRcdFx0Ly8gTWFyayBhcyBkaXJ0eSBpZiBpdCBpcyBub3QgYWxyZWFkeSBzZXQgdG8gZGlydHkgYW5kIGV4dHJlbWVzIGhhdmUgY2hhbmdlZC4gIzU5NS5cblx0XHRcdFx0aWYgKCFheGlzLmlzRGlydHkpIHtcblx0XHRcdFx0XHRheGlzLmlzRGlydHkgPSBpc0RpcnR5QXhpc0xlbmd0aCB8fCBheGlzLm1pbiAhPT0gYXhpcy5vbGRNaW4gfHwgYXhpcy5tYXggIT09IGF4aXMub2xkTWF4O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCFheGlzLmlzWEF4aXMpIHtcblx0XHRcdFx0aWYgKGF4aXMub2xkU3RhY2tzKSB7XG5cdFx0XHRcdFx0c3RhY2tzID0gYXhpcy5zdGFja3MgPSBheGlzLm9sZFN0YWNrcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlc2V0IHN0YWNrc1xuXHRcdFx0XHRmb3IgKHR5cGUgaW4gc3RhY2tzKSB7XG5cdFx0XHRcdFx0Zm9yIChpIGluIHN0YWNrc1t0eXBlXSkge1xuXHRcdFx0XHRcdFx0c3RhY2tzW3R5cGVdW2ldLmN1bSA9IHN0YWNrc1t0eXBlXVtpXS50b3RhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBleHRyZW1lcyBhbmQgb3B0aW9uYWxseSByZWRyYXdcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gbmV3TWluXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG5ld01heFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0XHQgKiAgICBjb25maWd1cmF0aW9uXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50QXJndW1lbnRzXG5cdFx0ICpcblx0XHQgKi9cblx0XHRzZXRFeHRyZW1lczogZnVuY3Rpb24gKG5ld01pbiwgbmV3TWF4LCByZWRyYXcsIGFuaW1hdGlvbiwgZXZlbnRBcmd1bWVudHMpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0O1xuXG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7IC8vIGRlZmF1bHRzIHRvIHRydWVcblxuXHRcdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRcdGRlbGV0ZSBzZXJpZS5rZFRyZWU7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBhcmd1bWVudHMgd2l0aCBtaW4gYW5kIG1heFxuXHRcdFx0ZXZlbnRBcmd1bWVudHMgPSBleHRlbmQoZXZlbnRBcmd1bWVudHMsIHtcblx0XHRcdFx0bWluOiBuZXdNaW4sXG5cdFx0XHRcdG1heDogbmV3TWF4XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRmlyZSB0aGUgZXZlbnRcblx0XHRcdGZpcmVFdmVudChheGlzLCAnc2V0RXh0cmVtZXMnLCBldmVudEFyZ3VtZW50cywgZnVuY3Rpb24gKCkgeyAvLyB0aGUgZGVmYXVsdCBldmVudCBoYW5kbGVyXG5cblx0XHRcdFx0YXhpcy51c2VyTWluID0gbmV3TWluO1xuXHRcdFx0XHRheGlzLnVzZXJNYXggPSBuZXdNYXg7XG5cdFx0XHRcdGF4aXMuZXZlbnRBcmdzID0gZXZlbnRBcmd1bWVudHM7XG5cblx0XHRcdFx0Ly8gTWFyayBmb3IgcnVubmluZyBhZnRlclNldEV4dHJlbWVzXG5cdFx0XHRcdGF4aXMuaXNEaXJ0eUV4dHJlbWVzID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyByZWRyYXdcblx0XHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciB6b29taW5nIGNoYXJ0LiBQdWxsZWQgb3V0IGluIGEgc2VwYXJhdGUgbWV0aG9kIHRvIGFsbG93IG92ZXJyaWRpbmdcblx0XHQgKiBpbiBzdG9jayBjaGFydHMuXG5cdFx0ICovXG5cdFx0em9vbTogZnVuY3Rpb24gKG5ld01pbiwgbmV3TWF4KSB7XG5cdFx0XHR2YXIgZGF0YU1pbiA9IHRoaXMuZGF0YU1pbixcblx0XHRcdFx0ZGF0YU1heCA9IHRoaXMuZGF0YU1heCxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdFx0Ly8gUHJldmVudCBwaW5jaCB6b29taW5nIG91dCBvZiByYW5nZS4gQ2hlY2sgZm9yIGRlZmluZWQgaXMgZm9yICMxOTQ2LiAjMTczNC5cblx0XHRcdGlmICghdGhpcy5hbGxvd1pvb21PdXRzaWRlKSB7XG5cdFx0XHRcdGlmIChkZWZpbmVkKGRhdGFNaW4pICYmIG5ld01pbiA8PSBtYXRoTWluKGRhdGFNaW4sIHBpY2sob3B0aW9ucy5taW4sIGRhdGFNaW4pKSkge1xuXHRcdFx0XHRcdG5ld01pbiA9IFVOREVGSU5FRDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGVmaW5lZChkYXRhTWF4KSAmJiBuZXdNYXggPj0gbWF0aE1heChkYXRhTWF4LCBwaWNrKG9wdGlvbnMubWF4LCBkYXRhTWF4KSkpIHtcblx0XHRcdFx0XHRuZXdNYXggPSBVTkRFRklORUQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW4gZnVsbCB2aWV3LCBkaXNwbGF5aW5nIHRoZSByZXNldCB6b29tIGJ1dHRvbiBpcyBub3QgcmVxdWlyZWRcblx0XHRcdHRoaXMuZGlzcGxheUJ0biA9IG5ld01pbiAhPT0gVU5ERUZJTkVEIHx8IG5ld01heCAhPT0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvLyBEbyBpdFxuXHRcdFx0dGhpcy5zZXRFeHRyZW1lcyhcblx0XHRcdFx0bmV3TWluLFxuXHRcdFx0XHRuZXdNYXgsXG5cdFx0XHRcdGZhbHNlLFxuXHRcdFx0XHRVTkRFRklORUQsXG5cdFx0XHRcdHsgdHJpZ2dlcjogJ3pvb20nIH1cblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBheGlzIG1ldHJpY3Ncblx0XHQgKi9cblx0XHRzZXRBeGlzU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0b2Zmc2V0TGVmdCA9IG9wdGlvbnMub2Zmc2V0TGVmdCB8fCAwLFxuXHRcdFx0XHRvZmZzZXRSaWdodCA9IG9wdGlvbnMub2Zmc2V0UmlnaHQgfHwgMCxcblx0XHRcdFx0aG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0XHR3aWR0aCA9IHBpY2sob3B0aW9ucy53aWR0aCwgY2hhcnQucGxvdFdpZHRoIC0gb2Zmc2V0TGVmdCArIG9mZnNldFJpZ2h0KSxcblx0XHRcdFx0aGVpZ2h0ID0gcGljayhvcHRpb25zLmhlaWdodCwgY2hhcnQucGxvdEhlaWdodCksXG5cdFx0XHRcdHRvcCA9IHBpY2sob3B0aW9ucy50b3AsIGNoYXJ0LnBsb3RUb3ApLFxuXHRcdFx0XHRsZWZ0ID0gcGljayhvcHRpb25zLmxlZnQsIGNoYXJ0LnBsb3RMZWZ0ICsgb2Zmc2V0TGVmdCksXG5cdFx0XHRcdHBlcmNlbnRSZWdleCA9IC8lJC87XG5cblx0XHRcdC8vIENoZWNrIGZvciBwZXJjZW50YWdlIGJhc2VkIGlucHV0IHZhbHVlc1xuXHRcdFx0aWYgKHBlcmNlbnRSZWdleC50ZXN0KGhlaWdodCkpIHtcblx0XHRcdFx0aGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQpIC8gMTAwICogY2hhcnQucGxvdEhlaWdodDtcblx0XHRcdH1cblx0XHRcdGlmIChwZXJjZW50UmVnZXgudGVzdCh0b3ApKSB7XG5cdFx0XHRcdHRvcCA9IHBhcnNlRmxvYXQodG9wKSAvIDEwMCAqIGNoYXJ0LnBsb3RIZWlnaHQgKyBjaGFydC5wbG90VG9wO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBFeHBvc2UgYmFzaWMgdmFsdWVzIHRvIHVzZSBpbiBTZXJpZXMgb2JqZWN0IGFuZCBuYXZpZ2F0b3Jcblx0XHRcdHRoaXMubGVmdCA9IGxlZnQ7XG5cdFx0XHR0aGlzLnRvcCA9IHRvcDtcblx0XHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0dGhpcy5ib3R0b20gPSBjaGFydC5jaGFydEhlaWdodCAtIGhlaWdodCAtIHRvcDtcblx0XHRcdHRoaXMucmlnaHQgPSBjaGFydC5jaGFydFdpZHRoIC0gd2lkdGggLSBsZWZ0O1xuXG5cdFx0XHQvLyBEaXJlY3Rpb24gYWdub3N0aWMgcHJvcGVydGllc1xuXHRcdFx0dGhpcy5sZW4gPSBtYXRoTWF4KGhvcml6ID8gd2lkdGggOiBoZWlnaHQsIDApOyAvLyBtYXRoTWF4IGZpeGVzICM5MDVcblx0XHRcdHRoaXMucG9zID0gaG9yaXogPyBsZWZ0IDogdG9wOyAvLyBkaXN0YW5jZSBmcm9tIFNWRyBvcmlnaW5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBhY3R1YWwgYXhpcyBleHRyZW1lc1xuXHRcdCAqL1xuXHRcdGdldEV4dHJlbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGlzTG9nID0gYXhpcy5pc0xvZztcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWluOiBpc0xvZyA/IGNvcnJlY3RGbG9hdChsaW4ybG9nKGF4aXMubWluKSkgOiBheGlzLm1pbixcblx0XHRcdFx0bWF4OiBpc0xvZyA/IGNvcnJlY3RGbG9hdChsaW4ybG9nKGF4aXMubWF4KSkgOiBheGlzLm1heCxcblx0XHRcdFx0ZGF0YU1pbjogYXhpcy5kYXRhTWluLFxuXHRcdFx0XHRkYXRhTWF4OiBheGlzLmRhdGFNYXgsXG5cdFx0XHRcdHVzZXJNaW46IGF4aXMudXNlck1pbixcblx0XHRcdFx0dXNlck1heDogYXhpcy51c2VyTWF4XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHplcm8gcGxhbmUgZWl0aGVyIGJhc2VkIG9uIHplcm8gb3Igb24gdGhlIG1pbiBvciBtYXggdmFsdWUuXG5cdFx0ICogVXNlZCBpbiBiYXIgYW5kIGFyZWEgcGxvdHNcblx0XHQgKi9cblx0XHRnZXRUaHJlc2hvbGQ6IGZ1bmN0aW9uICh0aHJlc2hvbGQpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdFx0aXNMb2cgPSBheGlzLmlzTG9nO1xuXG5cdFx0XHR2YXIgcmVhbE1pbiA9IGlzTG9nID8gbGluMmxvZyhheGlzLm1pbikgOiBheGlzLm1pbixcblx0XHRcdFx0cmVhbE1heCA9IGlzTG9nID8gbGluMmxvZyhheGlzLm1heCkgOiBheGlzLm1heDtcblxuXHRcdFx0aWYgKHJlYWxNaW4gPiB0aHJlc2hvbGQgfHwgdGhyZXNob2xkID09PSBudWxsKSB7XG5cdFx0XHRcdHRocmVzaG9sZCA9IHJlYWxNaW47XG5cdFx0XHR9IGVsc2UgaWYgKHJlYWxNYXggPCB0aHJlc2hvbGQpIHtcblx0XHRcdFx0dGhyZXNob2xkID0gcmVhbE1heDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGF4aXMudHJhbnNsYXRlKHRocmVzaG9sZCwgMCwgMSwgMCwgMSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvbXB1dGUgYXV0byBhbGlnbm1lbnQgZm9yIHRoZSBheGlzIGxhYmVsIGJhc2VkIG9uIHdoaWNoIHNpZGUgdGhlIGF4aXMgaXMgb25cblx0XHQgKiBhbmQgdGhlIGdpdmVuIHJvdGF0aW9uIGZvciB0aGUgbGFiZWxcblx0XHQgKi9cblx0XHRhdXRvTGFiZWxBbGlnbjogZnVuY3Rpb24gKHJvdGF0aW9uKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRhbmdsZSA9IChwaWNrKHJvdGF0aW9uLCAwKSAtICh0aGlzLnNpZGUgKiA5MCkgKyA3MjApICUgMzYwO1xuXG5cdFx0XHRpZiAoYW5nbGUgPiAxNSAmJiBhbmdsZSA8IDE2NSkge1xuXHRcdFx0XHRyZXQgPSAncmlnaHQnO1xuXHRcdFx0fSBlbHNlIGlmIChhbmdsZSA+IDE5NSAmJiBhbmdsZSA8IDM0NSkge1xuXHRcdFx0XHRyZXQgPSAnbGVmdCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXQgPSAnY2VudGVyJztcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnQgdGhlIHRpY2tzIGZyb20gZ2V0dGluZyBzbyBjbG9zZSB3ZSBjYW4ndCBkcmF3IHRoZSBsYWJlbHMuIE9uIGEgaG9yaXpvbnRhbFxuXHRcdCAqIGF4aXMsIHRoaXMgaXMgaGFuZGxlZCBieSByb3RhdGluZyB0aGUgbGFiZWxzLCByZW1vdmluZyB0aWNrcyBhbmQgYWRkaW5nIGVsbGlwc2lzLiBcblx0XHQgKiBPbiBhIHZlcnRpY2FsIGF4aXMgcmVtb3ZlIHRpY2tzIGFuZCBhZGQgZWxsaXBzaXMuXG5cdFx0ICovXG5cdFx0dW5zcXVpc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHRpY2tzID0gdGhpcy50aWNrcyxcblx0XHRcdFx0bGFiZWxPcHRpb25zID0gdGhpcy5vcHRpb25zLmxhYmVscyxcblx0XHRcdFx0aG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0XHR0aWNrSW50ZXJ2YWwgPSB0aGlzLnRpY2tJbnRlcnZhbCxcblx0XHRcdFx0bmV3VGlja0ludGVydmFsID0gdGlja0ludGVydmFsLFxuXHRcdFx0XHRzbG90U2l6ZSA9IHRoaXMubGVuIC8gKCgodGhpcy5jYXRlZ29yaWVzID8gMSA6IDApICsgdGhpcy5tYXggLSB0aGlzLm1pbikgLyB0aWNrSW50ZXJ2YWwpLFxuXHRcdFx0XHRyb3RhdGlvbixcblx0XHRcdFx0cm90YXRpb25PcHRpb24gPSBsYWJlbE9wdGlvbnMucm90YXRpb24sXG5cdFx0XHRcdGxhYmVsTWV0cmljcyA9IGNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKGxhYmVsT3B0aW9ucy5zdHlsZS5mb250U2l6ZSwgdGlja3NbMF0gJiYgdGlja3NbMF0ubGFiZWwpLFxuXHRcdFx0XHRzdGVwLFxuXHRcdFx0XHRiZXN0U2NvcmUgPSBOdW1iZXIuTUFYX1ZBTFVFLFxuXHRcdFx0XHRhdXRvUm90YXRpb24sXG5cdFx0XHRcdC8vIFJldHVybiB0aGUgbXVsdGlwbGUgb2YgdGlja0ludGVydmFsIHRoYXQgaXMgbmVlZGVkIHRvIGF2b2lkIGNvbGxpc2lvblxuXHRcdFx0XHRnZXRTdGVwID0gZnVuY3Rpb24gKHNwYWNlTmVlZGVkKSB7XG5cdFx0XHRcdFx0dmFyIHN0ZXAgPSBzcGFjZU5lZWRlZCAvIChzbG90U2l6ZSB8fCAxKTtcblx0XHRcdFx0XHRzdGVwID0gc3RlcCA+IDEgPyBtYXRoQ2VpbChzdGVwKSA6IDE7XG5cdFx0XHRcdFx0cmV0dXJuIHN0ZXAgKiB0aWNrSW50ZXJ2YWw7XG5cdFx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGlmIChob3Jpeikge1xuXHRcdFx0XHRhdXRvUm90YXRpb24gPSBkZWZpbmVkKHJvdGF0aW9uT3B0aW9uKSA/IFxuXHRcdFx0XHRcdFtyb3RhdGlvbk9wdGlvbl0gOlxuXHRcdFx0XHRcdHNsb3RTaXplIDwgODAgJiYgIWxhYmVsT3B0aW9ucy5zdGFnZ2VyTGluZXMgJiYgIWxhYmVsT3B0aW9ucy5zdGVwICYmIGxhYmVsT3B0aW9ucy5hdXRvUm90YXRpb247XG5cblx0XHRcdFx0aWYgKGF1dG9Sb3RhdGlvbikge1xuXG5cdFx0XHRcdFx0Ly8gTG9vcCBvdmVyIHRoZSBnaXZlbiBhdXRvUm90YXRpb24gb3B0aW9ucywgYW5kIGRldGVybWluZSB3aGljaCBnaXZlcyB0aGUgYmVzdCBzY29yZS4gVGhlIFxuXHRcdFx0XHRcdC8vIGJlc3Qgc2NvcmUgaXMgdGhhdCB3aXRoIHRoZSBsb3dlc3QgbnVtYmVyIG9mIHN0ZXBzIGFuZCBhIHJvdGF0aW9uIGNsb3Nlc3QgdG8gaG9yaXpvbnRhbC5cblx0XHRcdFx0XHRlYWNoKGF1dG9Sb3RhdGlvbiwgZnVuY3Rpb24gKHJvdCkge1xuXHRcdFx0XHRcdFx0dmFyIHNjb3JlO1xuXG5cdFx0XHRcdFx0XHRpZiAocm90ID09PSByb3RhdGlvbk9wdGlvbiB8fCAocm90ICYmIHJvdCA+PSAtOTAgJiYgcm90IDw9IDkwKSkgeyAvLyAjMzg5MVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHN0ZXAgPSBnZXRTdGVwKG1hdGhBYnMobGFiZWxNZXRyaWNzLmggLyBtYXRoU2luKGRlZzJyYWQgKiByb3QpKSk7XG5cblx0XHRcdFx0XHRcdFx0c2NvcmUgPSBzdGVwICsgbWF0aEFicyhyb3QgLyAzNjApO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChzY29yZSA8IGJlc3RTY29yZSkge1xuXHRcdFx0XHRcdFx0XHRcdGJlc3RTY29yZSA9IHNjb3JlO1xuXHRcdFx0XHRcdFx0XHRcdHJvdGF0aW9uID0gcm90O1xuXHRcdFx0XHRcdFx0XHRcdG5ld1RpY2tJbnRlcnZhbCA9IHN0ZXA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdUaWNrSW50ZXJ2YWwgPSBnZXRTdGVwKGxhYmVsTWV0cmljcy5oKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hdXRvUm90YXRpb24gPSBhdXRvUm90YXRpb247XG5cdFx0XHR0aGlzLmxhYmVsUm90YXRpb24gPSByb3RhdGlvbjtcblxuXHRcdFx0cmV0dXJuIG5ld1RpY2tJbnRlcnZhbDtcblx0XHR9LFxuXG5cdFx0cmVuZGVyVW5zcXVpc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSB0aGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHRcdHRpY2tzID0gdGhpcy50aWNrcyxcblx0XHRcdFx0bGFiZWxPcHRpb25zID0gdGhpcy5vcHRpb25zLmxhYmVscyxcblx0XHRcdFx0aG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0XHRtYXJnaW4gPSBjaGFydC5tYXJnaW4sXG5cdFx0XHRcdHNsb3RXaWR0aCA9IHRoaXMuc2xvdFdpZHRoID0gKGhvcml6ICYmICFsYWJlbE9wdGlvbnMuc3RlcCAmJiAhbGFiZWxPcHRpb25zLnJvdGF0aW9uICYmXG5cdFx0XHRcdFx0KCh0aGlzLnN0YWdnZXJMaW5lcyB8fCAxKSAqIGNoYXJ0LnBsb3RXaWR0aCkgLyB0aWNrUG9zaXRpb25zLmxlbmd0aCkgfHxcblx0XHRcdFx0XHQoIWhvcml6ICYmICgobWFyZ2luWzNdICYmIChtYXJnaW5bM10gLSBjaGFydC5zcGFjaW5nWzNdKSkgfHwgY2hhcnQuY2hhcnRXaWR0aCAqIDAuMzMpKSwgLy8gIzE1ODAsICMxOTMxLFxuXHRcdFx0XHRpbm5lcldpZHRoID0gbWF0aE1heCgxLCBtYXRoUm91bmQoc2xvdFdpZHRoIC0gMiAqIChsYWJlbE9wdGlvbnMucGFkZGluZyB8fCA1KSkpLFxuXHRcdFx0XHRhdHRyID0ge30sXG5cdFx0XHRcdGxhYmVsTWV0cmljcyA9IHJlbmRlcmVyLmZvbnRNZXRyaWNzKGxhYmVsT3B0aW9ucy5zdHlsZS5mb250U2l6ZSwgdGlja3NbMF0gJiYgdGlja3NbMF0ubGFiZWwpLFxuXHRcdFx0XHRjc3MsXG5cdFx0XHRcdGxhYmVsTGVuZ3RoID0gMCxcblx0XHRcdFx0bGFiZWwsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHBvcztcblxuXHRcdFx0Ly8gU2V0IHJvdGF0aW9uIG9wdGlvbiB1bmxlc3MgaXQgaXMgXCJhdXRvXCIsIGxpa2UgaW4gZ2F1Z2VzXG5cdFx0XHRpZiAoIWlzU3RyaW5nKGxhYmVsT3B0aW9ucy5yb3RhdGlvbikpIHtcblx0XHRcdFx0YXR0ci5yb3RhdGlvbiA9IGxhYmVsT3B0aW9ucy5yb3RhdGlvbjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSGFuZGxlIGF1dG8gcm90YXRpb24gb24gaG9yaXpvbnRhbCBheGlzXG5cdFx0XHRpZiAodGhpcy5hdXRvUm90YXRpb24pIHtcblxuXHRcdFx0XHQvLyBHZXQgdGhlIGxvbmdlc3QgbGFiZWwgbGVuZ3RoXG5cdFx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHRpY2spIHtcblx0XHRcdFx0XHR0aWNrID0gdGlja3NbdGlja107XG5cdFx0XHRcdFx0aWYgKHRpY2sgJiYgdGljay5sYWJlbExlbmd0aCA+IGxhYmVsTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRsYWJlbExlbmd0aCA9IHRpY2subGFiZWxMZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFwcGx5IHJvdGF0aW9uIG9ubHkgaWYgdGhlIGxhYmVsIGlzIHRvbyB3aWRlIGZvciB0aGUgc2xvdCwgYW5kXG5cdFx0XHRcdC8vIHRoZSBsYWJlbCBpcyB3aWRlciB0aGFuIGl0cyBoZWlnaHQuXG5cdFx0XHRcdGlmIChsYWJlbExlbmd0aCA+IGlubmVyV2lkdGggJiYgbGFiZWxMZW5ndGggPiBsYWJlbE1ldHJpY3MuaCkge1xuXHRcdFx0XHRcdGF0dHIucm90YXRpb24gPSB0aGlzLmxhYmVsUm90YXRpb247XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5sYWJlbFJvdGF0aW9uID0gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgd29yZC13cmFwIG9yIGVsbGlwc2lzIG9uIHZlcnRpY2FsIGF4aXNcblx0XHRcdH0gZWxzZSBpZiAoc2xvdFdpZHRoKSB7XG5cdFx0XHRcdC8vIEZvciB3b3JkLXdyYXAgb3IgZWxsaXBzaXNcblx0XHRcdFx0Y3NzID0geyB3aWR0aDogaW5uZXJXaWR0aCArIFBYLCB0ZXh0T3ZlcmZsb3c6ICdjbGlwJyB9O1xuXG5cdFx0XHRcdC8vIE9uIHZlcnRpY2FsIGF4aXMsIG9ubHkgYWxsb3cgd29yZCB3cmFwIGlmIHRoZXJlIGlzIHJvb20gZm9yIG1vcmUgbGluZXMuXG5cdFx0XHRcdGkgPSB0aWNrUG9zaXRpb25zLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCFob3JpeiAmJiBpLS0pIHtcblx0XHRcdFx0XHRwb3MgPSB0aWNrUG9zaXRpb25zW2ldO1xuXHRcdFx0XHRcdGxhYmVsID0gdGlja3NbcG9zXS5sYWJlbDtcblx0XHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmxlbiAvIHRpY2tQb3NpdGlvbnMubGVuZ3RoIC0gNCA8IGxhYmVsLmdldEJCb3goKS5oZWlnaHQpIHtcblx0XHRcdFx0XHRcdFx0bGFiZWwuc3BlY0NzcyA9IHsgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnIH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gQWRkIGVsbGlwc2lzIGlmIHRoZSBsYWJlbCBsZW5ndGggaXMgc2lnbmlmaWNhbnRseSBsb25nZXIgdGhhbiBpZGVhbFxuXHRcdFx0aWYgKGF0dHIucm90YXRpb24pIHtcblx0XHRcdFx0Y3NzID0geyBcblx0XHRcdFx0XHR3aWR0aDogKGxhYmVsTGVuZ3RoID4gY2hhcnQuY2hhcnRIZWlnaHQgKiAwLjUgPyBjaGFydC5jaGFydEhlaWdodCAqIDAuMzMgOiBjaGFydC5jaGFydEhlaWdodCkgKyBQWCxcblx0XHRcdFx0XHR0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcydcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBleHBsaWNpdCBvciBhdXRvbWF0aWMgbGFiZWwgYWxpZ25tZW50XG5cdFx0XHR0aGlzLmxhYmVsQWxpZ24gPSBhdHRyLmFsaWduID0gbGFiZWxPcHRpb25zLmFsaWduIHx8IHRoaXMuYXV0b0xhYmVsQWxpZ24odGhpcy5sYWJlbFJvdGF0aW9uKTtcblxuXHRcdFx0Ly8gQXBwbHkgZ2VuZXJhbCBhbmQgc3BlY2lmaWMgQ1NTXG5cdFx0XHRlYWNoKHRpY2tQb3NpdGlvbnMsIGZ1bmN0aW9uIChwb3MpIHtcblx0XHRcdFx0dmFyIHRpY2sgPSB0aWNrc1twb3NdLFxuXHRcdFx0XHRcdGxhYmVsID0gdGljayAmJiB0aWNrLmxhYmVsO1xuXHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRpZiAoY3NzKSB7XG5cdFx0XHRcdFx0XHRsYWJlbC5jc3MobWVyZ2UoY3NzLCBsYWJlbC5zcGVjQ3NzKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlbGV0ZSBsYWJlbC5zcGVjQ3NzO1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIoYXR0cik7XG5cdFx0XHRcdFx0dGljay5yb3RhdGlvbiA9IGF0dHIucm90YXRpb247XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBUT0RPOiBXaHkgbm90IHBhcnQgb2YgZ2V0TGFiZWxQb3NpdGlvbj9cblx0XHRcdHRoaXMudGlja1JvdENvcnIgPSByZW5kZXJlci5yb3RDb3JyKGxhYmVsTWV0cmljcy5iLCB0aGlzLmxhYmVsUm90YXRpb24gfHwgMCwgdGhpcy5zaWRlID09PSAyKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIHRoZSB0aWNrIGxhYmVscyB0byBhIHByZWxpbWluYXJ5IHBvc2l0aW9uIHRvIGdldCB0aGVpciBzaXplc1xuXHRcdCAqL1xuXHRcdGdldE9mZnNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSBheGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHRcdHRpY2tzID0gYXhpcy50aWNrcyxcblx0XHRcdFx0aG9yaXogPSBheGlzLmhvcml6LFxuXHRcdFx0XHRzaWRlID0gYXhpcy5zaWRlLFxuXHRcdFx0XHRpbnZlcnRlZFNpZGUgPSBjaGFydC5pbnZlcnRlZCA/IFsxLCAwLCAzLCAyXVtzaWRlXSA6IHNpZGUsXG5cdFx0XHRcdGhhc0RhdGEsXG5cdFx0XHRcdHNob3dBeGlzLFxuXHRcdFx0XHR0aXRsZU9mZnNldCA9IDAsXG5cdFx0XHRcdHRpdGxlT2Zmc2V0T3B0aW9uLFxuXHRcdFx0XHR0aXRsZU1hcmdpbiA9IDAsXG5cdFx0XHRcdGF4aXNUaXRsZU9wdGlvbnMgPSBvcHRpb25zLnRpdGxlLFxuXHRcdFx0XHRsYWJlbE9wdGlvbnMgPSBvcHRpb25zLmxhYmVscyxcblx0XHRcdFx0bGFiZWxPZmZzZXQgPSAwLCAvLyByZXNldFxuXHRcdFx0XHRsYWJlbE9mZnNldFBhZGRlZCxcblx0XHRcdFx0YXhpc09mZnNldCA9IGNoYXJ0LmF4aXNPZmZzZXQsXG5cdFx0XHRcdGNsaXBPZmZzZXQgPSBjaGFydC5jbGlwT2Zmc2V0LFxuXHRcdFx0XHRkaXJlY3Rpb25GYWN0b3IgPSBbLTEsIDEsIDEsIC0xXVtzaWRlXSxcblx0XHRcdFx0bixcblx0XHRcdFx0bGluZUhlaWdodENvcnJlY3Rpb247XG5cblx0XHRcdC8vIEZvciByZXVzZSBpbiBBeGlzLnJlbmRlclxuXHRcdFx0YXhpcy5oYXNEYXRhID0gaGFzRGF0YSA9IChheGlzLmhhc1Zpc2libGVTZXJpZXMgfHwgKGRlZmluZWQoYXhpcy5taW4pICYmIGRlZmluZWQoYXhpcy5tYXgpICYmICEhdGlja1Bvc2l0aW9ucykpO1xuXHRcdFx0YXhpcy5zaG93QXhpcyA9IHNob3dBeGlzID0gaGFzRGF0YSB8fCBwaWNrKG9wdGlvbnMuc2hvd0VtcHR5LCB0cnVlKTtcblxuXHRcdFx0Ly8gU2V0L3Jlc2V0IHN0YWdnZXJMaW5lc1xuXHRcdFx0YXhpcy5zdGFnZ2VyTGluZXMgPSBheGlzLmhvcml6ICYmIGxhYmVsT3B0aW9ucy5zdGFnZ2VyTGluZXM7XG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgYXhpc0dyb3VwIGFuZCBncmlkR3JvdXAgZWxlbWVudHMgb24gZmlyc3QgaXRlcmF0aW9uXG5cdFx0XHRpZiAoIWF4aXMuYXhpc0dyb3VwKSB7XG5cdFx0XHRcdGF4aXMuZ3JpZEdyb3VwID0gcmVuZGVyZXIuZygnZ3JpZCcpXG5cdFx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IG9wdGlvbnMuZ3JpZFpJbmRleCB8fCAxIH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0XHRheGlzLmF4aXNHcm91cCA9IHJlbmRlcmVyLmcoJ2F4aXMnKVxuXHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiBvcHRpb25zLnpJbmRleCB8fCAyIH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0XHRheGlzLmxhYmVsR3JvdXAgPSByZW5kZXJlci5nKCdheGlzLWxhYmVscycpXG5cdFx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IGxhYmVsT3B0aW9ucy56SW5kZXggfHwgNyB9KVxuXHRcdFx0XHRcdC5hZGRDbGFzcyhQUkVGSVggKyBheGlzLmNvbGwudG9Mb3dlckNhc2UoKSArICctbGFiZWxzJylcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXNEYXRhIHx8IGF4aXMuaXNMaW5rZWQpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEdlbmVyYXRlIHRpY2tzXG5cdFx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0XHRcdGlmICghdGlja3NbcG9zXSkge1xuXHRcdFx0XHRcdFx0dGlja3NbcG9zXSA9IG5ldyBUaWNrKGF4aXMsIHBvcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRpY2tzW3Bvc10uYWRkTGFiZWwoKTsgLy8gdXBkYXRlIGxhYmVscyBkZXBlbmRpbmcgb24gdGljayBpbnRlcnZhbFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0YXhpcy5yZW5kZXJVbnNxdWlzaCgpO1xuXG5cdFx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0XHRcdC8vIGxlZnQgc2lkZSBtdXN0IGJlIGFsaWduOiByaWdodCBhbmQgcmlnaHQgc2lkZSBtdXN0IGhhdmUgYWxpZ246IGxlZnQgZm9yIGxhYmVsc1xuXHRcdFx0XHRcdGlmIChzaWRlID09PSAwIHx8IHNpZGUgPT09IDIgfHwgeyAxOiAnbGVmdCcsIDM6ICdyaWdodCcgfVtzaWRlXSA9PT0gYXhpcy5sYWJlbEFsaWduKSB7XG5cblx0XHRcdFx0XHRcdC8vIGdldCB0aGUgaGlnaGVzdCBvZmZzZXRcblx0XHRcdFx0XHRcdGxhYmVsT2Zmc2V0ID0gbWF0aE1heChcblx0XHRcdFx0XHRcdFx0dGlja3NbcG9zXS5nZXRMYWJlbFNpemUoKSxcblx0XHRcdFx0XHRcdFx0bGFiZWxPZmZzZXRcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoYXhpcy5zdGFnZ2VyTGluZXMpIHtcblx0XHRcdFx0XHRsYWJlbE9mZnNldCAqPSBheGlzLnN0YWdnZXJMaW5lcztcblx0XHRcdFx0XHRheGlzLmxhYmVsT2Zmc2V0ID0gbGFiZWxPZmZzZXQ7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgZGF0YVxuXHRcdFx0XHRmb3IgKG4gaW4gdGlja3MpIHtcblx0XHRcdFx0XHR0aWNrc1tuXS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0ZGVsZXRlIHRpY2tzW25dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChheGlzVGl0bGVPcHRpb25zICYmIGF4aXNUaXRsZU9wdGlvbnMudGV4dCAmJiBheGlzVGl0bGVPcHRpb25zLmVuYWJsZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmICghYXhpcy5heGlzVGl0bGUpIHtcblx0XHRcdFx0XHRheGlzLmF4aXNUaXRsZSA9IHJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0XHRheGlzVGl0bGVPcHRpb25zLnRleHQsXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdGF4aXNUaXRsZU9wdGlvbnMudXNlSFRNTFxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHR6SW5kZXg6IDcsXG5cdFx0XHRcdFx0XHRyb3RhdGlvbjogYXhpc1RpdGxlT3B0aW9ucy5yb3RhdGlvbiB8fCAwLFxuXHRcdFx0XHRcdFx0YWxpZ246XG5cdFx0XHRcdFx0XHRcdGF4aXNUaXRsZU9wdGlvbnMudGV4dEFsaWduIHx8XG5cdFx0XHRcdFx0XHRcdHsgbG93OiAnbGVmdCcsIG1pZGRsZTogJ2NlbnRlcicsIGhpZ2g6ICdyaWdodCcgfVtheGlzVGl0bGVPcHRpb25zLmFsaWduXVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZENsYXNzKFBSRUZJWCArIHRoaXMuY29sbC50b0xvd2VyQ2FzZSgpICsgJy10aXRsZScpXG5cdFx0XHRcdFx0LmNzcyhheGlzVGl0bGVPcHRpb25zLnN0eWxlKVxuXHRcdFx0XHRcdC5hZGQoYXhpcy5heGlzR3JvdXApO1xuXHRcdFx0XHRcdGF4aXMuYXhpc1RpdGxlLmlzTmV3ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzaG93QXhpcykge1xuXHRcdFx0XHRcdHRpdGxlT2Zmc2V0ID0gYXhpcy5heGlzVGl0bGUuZ2V0QkJveCgpW2hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnXTtcblx0XHRcdFx0XHR0aXRsZU9mZnNldE9wdGlvbiA9IGF4aXNUaXRsZU9wdGlvbnMub2Zmc2V0O1xuXHRcdFx0XHRcdHRpdGxlTWFyZ2luID0gZGVmaW5lZCh0aXRsZU9mZnNldE9wdGlvbikgPyAwIDogcGljayhheGlzVGl0bGVPcHRpb25zLm1hcmdpbiwgaG9yaXogPyA1IDogMTApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaGlkZSBvciBzaG93IHRoZSB0aXRsZSBkZXBlbmRpbmcgb24gd2hldGhlciBzaG93RW1wdHkgaXMgc2V0XG5cdFx0XHRcdGF4aXMuYXhpc1RpdGxlW3Nob3dBeGlzID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBoYW5kbGUgYXV0b21hdGljIG9yIHVzZXIgc2V0IG9mZnNldFxuXHRcdFx0YXhpcy5vZmZzZXQgPSBkaXJlY3Rpb25GYWN0b3IgKiBwaWNrKG9wdGlvbnMub2Zmc2V0LCBheGlzT2Zmc2V0W3NpZGVdKTtcblxuXHRcdFx0YXhpcy50aWNrUm90Q29yciA9IGF4aXMudGlja1JvdENvcnIgfHwgeyB4OiAwLCB5OiAwIH07IC8vIHBvbGFyXG5cdFx0XHRsaW5lSGVpZ2h0Q29ycmVjdGlvbiA9IHNpZGUgPT09IDIgPyBheGlzLnRpY2tSb3RDb3JyLnkgOiAwO1xuXHRcdFx0bGFiZWxPZmZzZXRQYWRkZWQgPSBsYWJlbE9mZnNldCArIHRpdGxlTWFyZ2luICtcblx0XHRcdFx0KGxhYmVsT2Zmc2V0ICYmIChkaXJlY3Rpb25GYWN0b3IgKiAoaG9yaXogPyBwaWNrKGxhYmVsT3B0aW9ucy55LCBheGlzLnRpY2tSb3RDb3JyLnkgKyA4KSA6IGxhYmVsT3B0aW9ucy54KSAtIGxpbmVIZWlnaHRDb3JyZWN0aW9uKSk7XG5cdFx0XHRheGlzLmF4aXNUaXRsZU1hcmdpbiA9IHBpY2sodGl0bGVPZmZzZXRPcHRpb24sIGxhYmVsT2Zmc2V0UGFkZGVkKTtcblxuXHRcdFx0YXhpc09mZnNldFtzaWRlXSA9IG1hdGhNYXgoXG5cdFx0XHRcdGF4aXNPZmZzZXRbc2lkZV0sXG5cdFx0XHRcdGF4aXMuYXhpc1RpdGxlTWFyZ2luICsgdGl0bGVPZmZzZXQgKyBkaXJlY3Rpb25GYWN0b3IgKiBheGlzLm9mZnNldCxcblx0XHRcdFx0bGFiZWxPZmZzZXRQYWRkZWQgLy8gIzMwMjdcblx0XHRcdCk7XG5cdFx0XHRjbGlwT2Zmc2V0W2ludmVydGVkU2lkZV0gPSBtYXRoTWF4KGNsaXBPZmZzZXRbaW52ZXJ0ZWRTaWRlXSwgbWF0aEZsb29yKG9wdGlvbnMubGluZVdpZHRoIC8gMikgKiAyKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBwYXRoIGZvciB0aGUgYXhpcyBsaW5lXG5cdFx0ICovXG5cdFx0Z2V0TGluZVBhdGg6IGZ1bmN0aW9uIChsaW5lV2lkdGgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdG9wcG9zaXRlID0gdGhpcy5vcHBvc2l0ZSxcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQsXG5cdFx0XHRcdGhvcml6ID0gdGhpcy5ob3Jpeixcblx0XHRcdFx0bGluZUxlZnQgPSB0aGlzLmxlZnQgKyAob3Bwb3NpdGUgPyB0aGlzLndpZHRoIDogMCkgKyBvZmZzZXQsXG5cdFx0XHRcdGxpbmVUb3AgPSBjaGFydC5jaGFydEhlaWdodCAtIHRoaXMuYm90dG9tIC0gKG9wcG9zaXRlID8gdGhpcy5oZWlnaHQgOiAwKSArIG9mZnNldDtcblxuXHRcdFx0aWYgKG9wcG9zaXRlKSB7XG5cdFx0XHRcdGxpbmVXaWR0aCAqPSAtMTsgLy8gY3Jpc3BpZnkgdGhlIG90aGVyIHdheSAtICMxNDgwLCAjMTY4N1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hhcnQucmVuZGVyZXIuY3Jpc3BMaW5lKFtcblx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdGhvcml6ID9cblx0XHRcdFx0XHRcdHRoaXMubGVmdCA6XG5cdFx0XHRcdFx0XHRsaW5lTGVmdCxcblx0XHRcdFx0XHRob3JpeiA/XG5cdFx0XHRcdFx0XHRsaW5lVG9wIDpcblx0XHRcdFx0XHRcdHRoaXMudG9wLFxuXHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0aG9yaXogP1xuXHRcdFx0XHRcdFx0Y2hhcnQuY2hhcnRXaWR0aCAtIHRoaXMucmlnaHQgOlxuXHRcdFx0XHRcdFx0bGluZUxlZnQsXG5cdFx0XHRcdFx0aG9yaXogP1xuXHRcdFx0XHRcdFx0bGluZVRvcCA6XG5cdFx0XHRcdFx0XHRjaGFydC5jaGFydEhlaWdodCAtIHRoaXMuYm90dG9tXG5cdFx0XHRcdF0sIGxpbmVXaWR0aCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uIHRoZSB0aXRsZVxuXHRcdCAqL1xuXHRcdGdldFRpdGxlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIGNvbXB1dGUgYW5jaG9yIHBvaW50cyBmb3IgZWFjaCBvZiB0aGUgdGl0bGUgYWxpZ24gb3B0aW9uc1xuXHRcdFx0dmFyIGhvcml6ID0gdGhpcy5ob3Jpeixcblx0XHRcdFx0YXhpc0xlZnQgPSB0aGlzLmxlZnQsXG5cdFx0XHRcdGF4aXNUb3AgPSB0aGlzLnRvcCxcblx0XHRcdFx0YXhpc0xlbmd0aCA9IHRoaXMubGVuLFxuXHRcdFx0XHRheGlzVGl0bGVPcHRpb25zID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuXHRcdFx0XHRtYXJnaW4gPSBob3JpeiA/IGF4aXNMZWZ0IDogYXhpc1RvcCxcblx0XHRcdFx0b3Bwb3NpdGUgPSB0aGlzLm9wcG9zaXRlLFxuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCxcblx0XHRcdFx0Zm9udFNpemUgPSBwSW50KGF4aXNUaXRsZU9wdGlvbnMuc3R5bGUuZm9udFNpemUgfHwgMTIpLFxuXG5cdFx0XHRcdC8vIHRoZSBwb3NpdGlvbiBpbiB0aGUgbGVuZ3RoIGRpcmVjdGlvbiBvZiB0aGUgYXhpc1xuXHRcdFx0XHRhbG9uZ0F4aXMgPSB7XG5cdFx0XHRcdFx0bG93OiBtYXJnaW4gKyAoaG9yaXogPyAwIDogYXhpc0xlbmd0aCksXG5cdFx0XHRcdFx0bWlkZGxlOiBtYXJnaW4gKyBheGlzTGVuZ3RoIC8gMixcblx0XHRcdFx0XHRoaWdoOiBtYXJnaW4gKyAoaG9yaXogPyBheGlzTGVuZ3RoIDogMClcblx0XHRcdFx0fVtheGlzVGl0bGVPcHRpb25zLmFsaWduXSxcblxuXHRcdFx0XHQvLyB0aGUgcG9zaXRpb24gaW4gdGhlIHBlcnBlbmRpY3VsYXIgZGlyZWN0aW9uIG9mIHRoZSBheGlzXG5cdFx0XHRcdG9mZkF4aXMgPSAoaG9yaXogPyBheGlzVG9wICsgdGhpcy5oZWlnaHQgOiBheGlzTGVmdCkgK1xuXHRcdFx0XHRcdChob3JpeiA/IDEgOiAtMSkgKiAvLyBob3Jpem9udGFsIGF4aXMgcmV2ZXJzZXMgdGhlIG1hcmdpblxuXHRcdFx0XHRcdChvcHBvc2l0ZSA/IC0xIDogMSkgKiAvLyBzbyBkb2VzIG9wcG9zaXRlIGF4ZXNcblx0XHRcdFx0XHR0aGlzLmF4aXNUaXRsZU1hcmdpbiArXG5cdFx0XHRcdFx0KHRoaXMuc2lkZSA9PT0gMiA/IGZvbnRTaXplIDogMCk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGhvcml6ID9cblx0XHRcdFx0XHRhbG9uZ0F4aXMgOlxuXHRcdFx0XHRcdG9mZkF4aXMgKyAob3Bwb3NpdGUgPyB0aGlzLndpZHRoIDogMCkgKyBvZmZzZXQgK1xuXHRcdFx0XHRcdFx0KGF4aXNUaXRsZU9wdGlvbnMueCB8fCAwKSwgLy8geFxuXHRcdFx0XHR5OiBob3JpeiA/XG5cdFx0XHRcdFx0b2ZmQXhpcyAtIChvcHBvc2l0ZSA/IHRoaXMuaGVpZ2h0IDogMCkgKyBvZmZzZXQgOlxuXHRcdFx0XHRcdGFsb25nQXhpcyArIChheGlzVGl0bGVPcHRpb25zLnkgfHwgMCkgLy8geVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIHRoZSBheGlzXG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdFx0aXNMb2cgPSBheGlzLmlzTG9nLFxuXHRcdFx0XHRpc0xpbmtlZCA9IGF4aXMuaXNMaW5rZWQsXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSBheGlzLnRpY2tQb3NpdGlvbnMsXG5cdFx0XHRcdGF4aXNUaXRsZSA9IGF4aXMuYXhpc1RpdGxlLFx0XHRcdFxuXHRcdFx0XHR0aWNrcyA9IGF4aXMudGlja3MsXG5cdFx0XHRcdG1pbm9yVGlja3MgPSBheGlzLm1pbm9yVGlja3MsXG5cdFx0XHRcdGFsdGVybmF0ZUJhbmRzID0gYXhpcy5hbHRlcm5hdGVCYW5kcyxcblx0XHRcdFx0c3RhY2tMYWJlbE9wdGlvbnMgPSBvcHRpb25zLnN0YWNrTGFiZWxzLFxuXHRcdFx0XHRhbHRlcm5hdGVHcmlkQ29sb3IgPSBvcHRpb25zLmFsdGVybmF0ZUdyaWRDb2xvcixcblx0XHRcdFx0dGlja21hcmtPZmZzZXQgPSBheGlzLnRpY2ttYXJrT2Zmc2V0LFxuXHRcdFx0XHRsaW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aCxcblx0XHRcdFx0bGluZVBhdGgsXG5cdFx0XHRcdGhhc1JlbmRlcmVkID0gY2hhcnQuaGFzUmVuZGVyZWQsXG5cdFx0XHRcdHNsaWRlSW5UaWNrcyA9IGhhc1JlbmRlcmVkICYmIGRlZmluZWQoYXhpcy5vbGRNaW4pICYmICFpc05hTihheGlzLm9sZE1pbiksXG5cdFx0XHRcdGhhc0RhdGEgPSBheGlzLmhhc0RhdGEsXG5cdFx0XHRcdHNob3dBeGlzID0gYXhpcy5zaG93QXhpcyxcblx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0dG87XG5cblx0XHRcdC8vIFJlc2V0XG5cdFx0XHRheGlzLmxhYmVsRWRnZS5sZW5ndGggPSAwO1xuXHRcdFx0Ly9heGlzLmp1c3RpZnlUb1Bsb3QgPSBvdmVyZmxvdyA9PT0gJ2p1c3RpZnknO1xuXHRcdFx0YXhpcy5vdmVybGFwID0gZmFsc2U7XG5cblx0XHRcdC8vIE1hcmsgYWxsIGVsZW1lbnRzIGluQWN0aXZlIGJlZm9yZSB3ZSBnbyBvdmVyIGFuZCBtYXJrIHRoZSBhY3RpdmUgb25lc1xuXHRcdFx0ZWFjaChbdGlja3MsIG1pbm9yVGlja3MsIGFsdGVybmF0ZUJhbmRzXSwgZnVuY3Rpb24gKGNvbGwpIHtcblx0XHRcdFx0dmFyIHBvcztcblx0XHRcdFx0Zm9yIChwb3MgaW4gY29sbCkge1xuXHRcdFx0XHRcdGNvbGxbcG9zXS5pc0FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlcmllcyBoYXMgZGF0YSBkcmF3IHRoZSB0aWNrcy4gRWxzZSBvbmx5IHRoZSBsaW5lIGFuZCB0aXRsZVxuXHRcdFx0aWYgKGhhc0RhdGEgfHwgaXNMaW5rZWQpIHtcblxuXHRcdFx0XHQvLyBtaW5vciB0aWNrc1xuXHRcdFx0XHRpZiAoYXhpcy5taW5vclRpY2tJbnRlcnZhbCAmJiAhYXhpcy5jYXRlZ29yaWVzKSB7XG5cdFx0XHRcdFx0ZWFjaChheGlzLmdldE1pbm9yVGlja1Bvc2l0aW9ucygpLCBmdW5jdGlvbiAocG9zKSB7XG5cdFx0XHRcdFx0XHRpZiAoIW1pbm9yVGlja3NbcG9zXSkge1xuXHRcdFx0XHRcdFx0XHRtaW5vclRpY2tzW3Bvc10gPSBuZXcgVGljayhheGlzLCBwb3MsICdtaW5vcicpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyByZW5kZXIgbmV3IHRpY2tzIGluIG9sZCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0aWYgKHNsaWRlSW5UaWNrcyAmJiBtaW5vclRpY2tzW3Bvc10uaXNOZXcpIHtcblx0XHRcdFx0XHRcdFx0bWlub3JUaWNrc1twb3NdLnJlbmRlcihudWxsLCB0cnVlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWlub3JUaWNrc1twb3NdLnJlbmRlcihudWxsLCBmYWxzZSwgMSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWpvciB0aWNrcy4gUHVsbCBvdXQgdGhlIGZpcnN0IGl0ZW0gYW5kIHJlbmRlciBpdCBsYXN0IHNvIHRoYXRcblx0XHRcdFx0Ly8gd2UgY2FuIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIG5laWdoYm91ciBsYWJlbC4gIzgwOC5cblx0XHRcdFx0aWYgKHRpY2tQb3NpdGlvbnMubGVuZ3RoKSB7IC8vICMxMzAwXG5cdFx0XHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zLCBpKSB7XG5cblx0XHRcdFx0XHRcdC8vIGxpbmtlZCBheGVzIG5lZWQgYW4gZXh0cmEgY2hlY2sgdG8gZmluZCBvdXQgaWZcblx0XHRcdFx0XHRcdGlmICghaXNMaW5rZWQgfHwgKHBvcyA+PSBheGlzLm1pbiAmJiBwb3MgPD0gYXhpcy5tYXgpKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCF0aWNrc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGlja3NbcG9zXSA9IG5ldyBUaWNrKGF4aXMsIHBvcyk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyByZW5kZXIgbmV3IHRpY2tzIGluIG9sZCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRpZiAoc2xpZGVJblRpY2tzICYmIHRpY2tzW3Bvc10uaXNOZXcpIHtcblx0XHRcdFx0XHRcdFx0XHR0aWNrc1twb3NdLnJlbmRlcihpLCB0cnVlLCAwLjEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dGlja3NbcG9zXS5yZW5kZXIoaSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHQvLyBJbiBhIGNhdGVnb3JpemVkIGF4aXMsIHRoZSB0aWNrIG1hcmtzIGFyZSBkaXNwbGF5ZWQgYmV0d2VlbiBsYWJlbHMuIFNvXG5cdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBhZGQgYSB0aWNrIG1hcmsgYW5kIGdyaWQgbGluZSBhdCB0aGUgbGVmdCBlZGdlIG9mIHRoZSBYIGF4aXMuXG5cdFx0XHRcdFx0aWYgKHRpY2ttYXJrT2Zmc2V0ICYmIChheGlzLm1pbiA9PT0gMCB8fCBheGlzLnNpbmdsZSkpIHtcblx0XHRcdFx0XHRcdGlmICghdGlja3NbLTFdKSB7XG5cdFx0XHRcdFx0XHRcdHRpY2tzWy0xXSA9IG5ldyBUaWNrKGF4aXMsIC0xLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRpY2tzWy0xXS5yZW5kZXIoLTEpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYWx0ZXJuYXRlIGdyaWQgY29sb3Jcblx0XHRcdFx0aWYgKGFsdGVybmF0ZUdyaWRDb2xvcikge1xuXHRcdFx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcywgaSkge1xuXHRcdFx0XHRcdFx0aWYgKGkgJSAyID09PSAwICYmIHBvcyA8IGF4aXMubWF4KSB7XG5cdFx0XHRcdFx0XHRcdGlmICghYWx0ZXJuYXRlQmFuZHNbcG9zXSkge1xuXHRcdFx0XHRcdFx0XHRcdGFsdGVybmF0ZUJhbmRzW3Bvc10gPSBuZXcgSGlnaGNoYXJ0cy5QbG90TGluZU9yQmFuZChheGlzKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRmcm9tID0gcG9zICsgdGlja21hcmtPZmZzZXQ7IC8vICM5NDlcblx0XHRcdFx0XHRcdFx0dG8gPSB0aWNrUG9zaXRpb25zW2kgKyAxXSAhPT0gVU5ERUZJTkVEID8gdGlja1Bvc2l0aW9uc1tpICsgMV0gKyB0aWNrbWFya09mZnNldCA6IGF4aXMubWF4O1xuXHRcdFx0XHRcdFx0XHRhbHRlcm5hdGVCYW5kc1twb3NdLm9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0ZnJvbTogaXNMb2cgPyBsaW4ybG9nKGZyb20pIDogZnJvbSxcblx0XHRcdFx0XHRcdFx0XHR0bzogaXNMb2cgPyBsaW4ybG9nKHRvKSA6IHRvLFxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yOiBhbHRlcm5hdGVHcmlkQ29sb3Jcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlQmFuZHNbcG9zXS5yZW5kZXIoKTtcblx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlQmFuZHNbcG9zXS5pc0FjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjdXN0b20gcGxvdCBsaW5lcyBhbmQgYmFuZHNcblx0XHRcdFx0aWYgKCFheGlzLl9hZGRlZFBsb3RMQikgeyAvLyBvbmx5IGZpcnN0IHRpbWVcblx0XHRcdFx0XHRlYWNoKChvcHRpb25zLnBsb3RMaW5lcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMucGxvdEJhbmRzIHx8IFtdKSwgZnVuY3Rpb24gKHBsb3RMaW5lT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0YXhpcy5hZGRQbG90QmFuZE9yTGluZShwbG90TGluZU9wdGlvbnMpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGF4aXMuX2FkZGVkUGxvdExCID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IC8vIGVuZCBpZiBoYXNEYXRhXG5cblx0XHRcdC8vIFJlbW92ZSBpbmFjdGl2ZSB0aWNrc1xuXHRcdFx0ZWFjaChbdGlja3MsIG1pbm9yVGlja3MsIGFsdGVybmF0ZUJhbmRzXSwgZnVuY3Rpb24gKGNvbGwpIHtcblx0XHRcdFx0dmFyIHBvcyxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdGZvckRlc3RydWN0aW9uID0gW10sXG5cdFx0XHRcdFx0ZGVsYXkgPSBnbG9iYWxBbmltYXRpb24gPyBnbG9iYWxBbmltYXRpb24uZHVyYXRpb24gfHwgNTAwIDogMCxcblx0XHRcdFx0XHRkZXN0cm95SW5hY3RpdmVJdGVtcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGkgPSBmb3JEZXN0cnVjdGlvbi5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdoZW4gcmVzaXppbmcgcmFwaWRseSwgdGhlIHNhbWUgaXRlbXMgbWF5IGJlIGRlc3Ryb3llZCBpbiBkaWZmZXJlbnQgdGltZW91dHMsXG5cdFx0XHRcdFx0XHRcdC8vIG9yIHRoZSBtYXkgYmUgcmVhY3RpdmF0ZWRcblx0XHRcdFx0XHRcdFx0aWYgKGNvbGxbZm9yRGVzdHJ1Y3Rpb25baV1dICYmICFjb2xsW2ZvckRlc3RydWN0aW9uW2ldXS5pc0FjdGl2ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbGxbZm9yRGVzdHJ1Y3Rpb25baV1dLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgY29sbFtmb3JEZXN0cnVjdGlvbltpXV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0Zm9yIChwb3MgaW4gY29sbCkge1xuXG5cdFx0XHRcdFx0aWYgKCFjb2xsW3Bvc10uaXNBY3RpdmUpIHtcblx0XHRcdFx0XHRcdC8vIFJlbmRlciB0byB6ZXJvIG9wYWNpdHlcblx0XHRcdFx0XHRcdGNvbGxbcG9zXS5yZW5kZXIocG9zLCBmYWxzZSwgMCk7XG5cdFx0XHRcdFx0XHRjb2xsW3Bvc10uaXNBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGZvckRlc3RydWN0aW9uLnB1c2gocG9zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXaGVuIHRoZSBvYmplY3RzIGFyZSBmaW5pc2hlZCBmYWRpbmcgb3V0LCBkZXN0cm95IHRoZW1cblx0XHRcdFx0aWYgKGNvbGwgPT09IGFsdGVybmF0ZUJhbmRzIHx8ICFjaGFydC5oYXNSZW5kZXJlZCB8fCAhZGVsYXkpIHtcblx0XHRcdFx0XHRkZXN0cm95SW5hY3RpdmVJdGVtcygpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRlbGF5KSB7XG5cdFx0XHRcdFx0c2V0VGltZW91dChkZXN0cm95SW5hY3RpdmVJdGVtcywgZGVsYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gU3RhdGljIGl0ZW1zLiBBcyB0aGUgYXhpcyBncm91cCBpcyBjbGVhcmVkIG9uIHN1YnNlcXVlbnQgY2FsbHNcblx0XHRcdC8vIHRvIHJlbmRlciwgdGhlc2UgaXRlbXMgYXJlIGFkZGVkIG91dHNpZGUgdGhlIGdyb3VwLlxuXHRcdFx0Ly8gYXhpcyBsaW5lXG5cdFx0XHRpZiAobGluZVdpZHRoKSB7XG5cdFx0XHRcdGxpbmVQYXRoID0gYXhpcy5nZXRMaW5lUGF0aChsaW5lV2lkdGgpO1xuXHRcdFx0XHRpZiAoIWF4aXMuYXhpc0xpbmUpIHtcblx0XHRcdFx0XHRheGlzLmF4aXNMaW5lID0gcmVuZGVyZXIucGF0aChsaW5lUGF0aClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmxpbmVDb2xvcixcblx0XHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGxpbmVXaWR0aCxcblx0XHRcdFx0XHRcdFx0ekluZGV4OiA3XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmFkZChheGlzLmF4aXNHcm91cCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXhpcy5heGlzTGluZS5hbmltYXRlKHsgZDogbGluZVBhdGggfSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzaG93IG9yIGhpZGUgdGhlIGxpbmUgZGVwZW5kaW5nIG9uIG9wdGlvbnMuc2hvd0VtcHR5XG5cdFx0XHRcdGF4aXMuYXhpc0xpbmVbc2hvd0F4aXMgPyAnc2hvdycgOiAnaGlkZSddKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChheGlzVGl0bGUgJiYgc2hvd0F4aXMpIHtcblxuXHRcdFx0XHRheGlzVGl0bGVbYXhpc1RpdGxlLmlzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXShcblx0XHRcdFx0XHRheGlzLmdldFRpdGxlUG9zaXRpb24oKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRheGlzVGl0bGUuaXNOZXcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhY2tlZCB0b3RhbHM6XG5cdFx0XHRpZiAoc3RhY2tMYWJlbE9wdGlvbnMgJiYgc3RhY2tMYWJlbE9wdGlvbnMuZW5hYmxlZCkge1xuXHRcdFx0XHRheGlzLnJlbmRlclN0YWNrVG90YWxzKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBFbmQgc3RhY2tlZCB0b3RhbHNcblxuXHRcdFx0YXhpcy5pc0RpcnR5ID0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZHJhdyB0aGUgYXhpcyB0byByZWZsZWN0IGNoYW5nZXMgaW4gdGhlIGRhdGEgb3IgYXhpcyBleHRyZW1lc1xuXHRcdCAqL1xuXHRcdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0XG5cdFx0XHQvLyByZW5kZXIgdGhlIGF4aXNcblx0XHRcdHRoaXMucmVuZGVyKCk7XG5cblx0XHRcdC8vIG1vdmUgcGxvdCBsaW5lcyBhbmQgYmFuZHNcblx0XHRcdGVhY2godGhpcy5wbG90TGluZXNBbmRCYW5kcywgZnVuY3Rpb24gKHBsb3RMaW5lKSB7XG5cdFx0XHRcdHBsb3RMaW5lLnJlbmRlcigpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIG1hcmsgYXNzb2NpYXRlZCBzZXJpZXMgYXMgZGlydHkgYW5kIHJlYWR5IGZvciByZWRyYXdcblx0XHRcdGVhY2godGhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0c2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0fSk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveXMgYW4gQXhpcyBpbnN0YW5jZS5cblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoa2VlcEV2ZW50cykge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRzdGFja3MgPSBheGlzLnN0YWNrcyxcblx0XHRcdFx0c3RhY2tLZXksXG5cdFx0XHRcdHBsb3RMaW5lc0FuZEJhbmRzID0gYXhpcy5wbG90TGluZXNBbmRCYW5kcyxcblx0XHRcdFx0aTtcblxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBldmVudHNcblx0XHRcdGlmICgha2VlcEV2ZW50cykge1xuXHRcdFx0XHRyZW1vdmVFdmVudChheGlzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVzdHJveSBlYWNoIHN0YWNrIHRvdGFsXG5cdFx0XHRmb3IgKHN0YWNrS2V5IGluIHN0YWNrcykge1xuXHRcdFx0XHRkZXN0cm95T2JqZWN0UHJvcGVydGllcyhzdGFja3Nbc3RhY2tLZXldKTtcblxuXHRcdFx0XHRzdGFja3Nbc3RhY2tLZXldID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVzdHJveSBjb2xsZWN0aW9uc1xuXHRcdFx0ZWFjaChbYXhpcy50aWNrcywgYXhpcy5taW5vclRpY2tzLCBheGlzLmFsdGVybmF0ZUJhbmRzXSwgZnVuY3Rpb24gKGNvbGwpIHtcblx0XHRcdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXMoY29sbCk7XG5cdFx0XHR9KTtcblx0XHRcdGkgPSBwbG90TGluZXNBbmRCYW5kcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7IC8vICMxOTc1XG5cdFx0XHRcdHBsb3RMaW5lc0FuZEJhbmRzW2ldLmRlc3Ryb3koKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVzdHJveSBsb2NhbCB2YXJpYWJsZXNcblx0XHRcdGVhY2goWydzdGFja1RvdGFsR3JvdXAnLCAnYXhpc0xpbmUnLCAnYXhpc1RpdGxlJywgJ2F4aXNHcm91cCcsICdjcm9zcycsICdncmlkR3JvdXAnLCAnbGFiZWxHcm91cCddLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0XHRpZiAoYXhpc1twcm9wXSkge1xuXHRcdFx0XHRcdGF4aXNbcHJvcF0gPSBheGlzW3Byb3BdLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIERlc3Ryb3kgY3Jvc3NoYWlyXG5cdFx0XHRpZiAodGhpcy5jcm9zcykge1xuXHRcdFx0XHR0aGlzLmNyb3NzLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyB0aGUgY3Jvc3NoYWlyXG5cdFx0ICovXG5cdFx0ZHJhd0Nyb3NzaGFpcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7IC8vIGRvY3M6IE1pc3NpbmcgZG9jcyBmb3IgQXhpcy5jcm9zc2hhaXIuIEFsc28gZm9yIHByb3BlcnRpZXMuXG5cblx0XHRcdHZhciBwYXRoLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5jcm9zc2hhaXIsXG5cdFx0XHRcdGFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLFxuXHRcdFx0XHRwb3MsXG5cdFx0XHRcdGF0dHJpYnMsXG5cdFx0XHRcdGNhdGVnb3JpemVkO1xuXHRcdFx0XG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIERpc2FibGVkIGluIG9wdGlvbnNcblx0XHRcdFx0IXRoaXMuY3Jvc3NoYWlyIHx8IFxuXHRcdFx0XHQvLyBTbmFwXG5cdFx0XHRcdCgoZGVmaW5lZChwb2ludCkgfHwgIXBpY2sodGhpcy5jcm9zc2hhaXIuc25hcCwgdHJ1ZSkpID09PSBmYWxzZSlcblx0XHRcdCkge1xuXHRcdFx0XHR0aGlzLmhpZGVDcm9zc2hhaXIoKTtcblx0XHRcdFxuXHRcdFx0fSBlbHNlIHtcdFx0XHRcblxuXHRcdFx0XHQvLyBHZXQgdGhlIHBhdGhcblx0XHRcdFx0aWYgKCFwaWNrKG9wdGlvbnMuc25hcCwgdHJ1ZSkpIHtcblx0XHRcdFx0XHRwb3MgPSAodGhpcy5ob3JpeiA/IGUuY2hhcnRYIC0gdGhpcy5wb3MgOiB0aGlzLmxlbiAtIGUuY2hhcnRZICsgdGhpcy5wb3MpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRlZmluZWQocG9pbnQpKSB7XG5cdFx0XHRcdFx0Lypqc2xpbnQgZXFlcTogdHJ1ZSovXG5cdFx0XHRcdFx0cG9zID0gdGhpcy5pc1hBeGlzID8gcG9pbnQucGxvdFggOiB0aGlzLmxlbiAtIHBvaW50LnBsb3RZOyAvLyAjMzgzNFxuXHRcdFx0XHRcdC8qanNsaW50IGVxZXE6IGZhbHNlKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLmlzUmFkaWFsKSB7XG5cdFx0XHRcdFx0cGF0aCA9IHRoaXMuZ2V0UGxvdExpbmVQYXRoKHRoaXMuaXNYQXhpcyA/IHBvaW50LnggOiBwaWNrKHBvaW50LnN0YWNrWSwgcG9pbnQueSkpIHx8IG51bGw7IC8vICMzMTg5XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGF0aCA9IHRoaXMuZ2V0UGxvdExpbmVQYXRoKG51bGwsIG51bGwsIG51bGwsIG51bGwsIHBvcykgfHwgbnVsbDsgLy8gIzMxODlcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwYXRoID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRHJhdyB0aGUgY3Jvc3Ncblx0XHRcdFx0aWYgKHRoaXMuY3Jvc3MpIHtcblx0XHRcdFx0XHR0aGlzLmNyb3NzXG5cdFx0XHRcdFx0XHQuYXR0cih7IHZpc2liaWxpdHk6IFZJU0lCTEUgfSlbYW5pbWF0aW9uID8gJ2FuaW1hdGUnIDogJ2F0dHInXSh7IGQ6IHBhdGggfSwgYW5pbWF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYXRlZ29yaXplZCA9IHRoaXMuY2F0ZWdvcmllcyAmJiAhdGhpcy5pc1JhZGlhbDtcblx0XHRcdFx0XHRhdHRyaWJzID0ge1xuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IG9wdGlvbnMud2lkdGggfHwgKGNhdGVnb3JpemVkID8gdGhpcy50cmFuc0EgOiAxKSxcblx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9ucy5jb2xvciB8fCAoY2F0ZWdvcml6ZWQgPyAncmdiYSgxNTUsMjAwLDI1NSwwLjIpJyA6ICcjQzBDMEMwJyksXG5cdFx0XHRcdFx0XHR6SW5kZXg6IG9wdGlvbnMuekluZGV4IHx8IDJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmIChvcHRpb25zLmRhc2hTdHlsZSkge1xuXHRcdFx0XHRcdFx0YXR0cmlicy5kYXNoc3R5bGUgPSBvcHRpb25zLmRhc2hTdHlsZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5jcm9zcyA9IHRoaXMuY2hhcnQucmVuZGVyZXIucGF0aChwYXRoKS5hdHRyKGF0dHJpYnMpLmFkZCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKlx0SGlkZSB0aGUgY3Jvc3NoYWlyLlxuXHRcdCAqL1xuXHRcdGhpZGVDcm9zc2hhaXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLmNyb3NzKSB7XG5cdFx0XHRcdHRoaXMuY3Jvc3MuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTsgLy8gZW5kIEF4aXNcblxuXHRleHRlbmQoQXhpcy5wcm90b3R5cGUsIEF4aXNQbG90TGluZU9yQmFuZEV4dGVuc2lvbik7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgdGljayBwb3NpdGlvbnMgdG8gYSB0aW1lIHVuaXQgdGhhdCBtYWtlcyBzZW5zZSwgZm9yIGV4YW1wbGVcblx0ICogb24gdGhlIGZpcnN0IG9mIGVhY2ggbW9udGggb3Igb24gZXZlcnkgTW9uZGF5LiBSZXR1cm4gYW4gYXJyYXlcblx0ICogd2l0aCB0aGUgdGltZSBwb3NpdGlvbnMuIFVzZWQgaW4gZGF0ZXRpbWUgYXhlcyBhcyB3ZWxsIGFzIGZvciBncm91cGluZ1xuXHQgKiBkYXRhIG9uIGEgZGF0ZXRpbWUgYXhpcy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG5vcm1hbGl6ZWRJbnRlcnZhbCBUaGUgaW50ZXJ2YWwgaW4gYXhpcyB2YWx1ZXMgKG1zKSBhbmQgdGhlIGNvdW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gaW4gYXhpcyB2YWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heCBUaGUgbWF4aW11bSBpbiBheGlzIHZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRPZldlZWtcblx0ICovXG5cdEF4aXMucHJvdG90eXBlLmdldFRpbWVUaWNrcyA9IGZ1bmN0aW9uIChub3JtYWxpemVkSW50ZXJ2YWwsIG1pbiwgbWF4LCBzdGFydE9mV2Vlaykge1xuXHRcdHZhciB0aWNrUG9zaXRpb25zID0gW10sXG5cdFx0XHRpLFxuXHRcdFx0aGlnaGVyUmFua3MgPSB7fSxcblx0XHRcdHVzZVVUQyA9IGRlZmF1bHRPcHRpb25zLmdsb2JhbC51c2VVVEMsXG5cdFx0XHRtaW5ZZWFyLCAvLyB1c2VkIGluIG1vbnRocyBhbmQgeWVhcnMgYXMgYSBiYXNpcyBmb3IgRGF0ZS5VVEMoKVxuXHRcdFx0bWluRGF0ZSA9IG5ldyBEYXRlKG1pbiAtIGdldFRaT2Zmc2V0KG1pbikpLFxuXHRcdFx0aW50ZXJ2YWwgPSBub3JtYWxpemVkSW50ZXJ2YWwudW5pdFJhbmdlLFxuXHRcdFx0Y291bnQgPSBub3JtYWxpemVkSW50ZXJ2YWwuY291bnQ7XG5cblx0XHRpZiAoZGVmaW5lZChtaW4pKSB7IC8vICMxMzAwXG5cdFx0XHRtaW5EYXRlLnNldE1pbGxpc2Vjb25kcyhpbnRlcnZhbCA+PSB0aW1lVW5pdHMuc2Vjb25kID8gMCA6XG5cdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLyBjb3VudCkpOyAvLyAjMzY1MiwgIzM2NTRcblxuXHRcdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy5zZWNvbmQpIHsgLy8gc2Vjb25kXG5cdFx0XHRcdG1pbkRhdGUuc2V0U2Vjb25kcyhpbnRlcnZhbCA+PSB0aW1lVW5pdHMubWludXRlID8gMCA6XG5cdFx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZS5nZXRTZWNvbmRzKCkgLyBjb3VudCkpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy5taW51dGUpIHsgLy8gbWludXRlXG5cdFx0XHRcdG1pbkRhdGVbc2V0TWludXRlc10oaW50ZXJ2YWwgPj0gdGltZVVuaXRzLmhvdXIgPyAwIDpcblx0XHRcdFx0XHRjb3VudCAqIG1hdGhGbG9vcihtaW5EYXRlW2dldE1pbnV0ZXNdKCkgLyBjb3VudCkpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy5ob3VyKSB7IC8vIGhvdXJcblx0XHRcdFx0bWluRGF0ZVtzZXRIb3Vyc10oaW50ZXJ2YWwgPj0gdGltZVVuaXRzLmRheSA/IDAgOlxuXHRcdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGVbZ2V0SG91cnNdKCkgLyBjb3VudCkpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy5kYXkpIHsgLy8gZGF5XG5cdFx0XHRcdG1pbkRhdGVbc2V0RGF0ZV0oaW50ZXJ2YWwgPj0gdGltZVVuaXRzLm1vbnRoID8gMSA6XG5cdFx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXREYXRlXSgpIC8gY291bnQpKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHMubW9udGgpIHsgLy8gbW9udGhcblx0XHRcdFx0bWluRGF0ZVtzZXRNb250aF0oaW50ZXJ2YWwgPj0gdGltZVVuaXRzLnllYXIgPyAwIDpcblx0XHRcdFx0XHRjb3VudCAqIG1hdGhGbG9vcihtaW5EYXRlW2dldE1vbnRoXSgpIC8gY291bnQpKTtcblx0XHRcdFx0bWluWWVhciA9IG1pbkRhdGVbZ2V0RnVsbFllYXJdKCk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzLnllYXIpIHsgLy8geWVhclxuXHRcdFx0XHRtaW5ZZWFyIC09IG1pblllYXIgJSBjb3VudDtcblx0XHRcdFx0bWluRGF0ZVtzZXRGdWxsWWVhcl0obWluWWVhcik7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHQvLyB3ZWVrIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcnVucyBvdXRzaWRlIHRoZSBoaWVyYXJjaHlcblx0XHRcdGlmIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzLndlZWspIHtcblx0XHRcdFx0Ly8gZ2V0IHN0YXJ0IG9mIGN1cnJlbnQgd2VlaywgaW5kZXBlbmRlbnQgb2YgY291bnRcblx0XHRcdFx0bWluRGF0ZVtzZXREYXRlXShtaW5EYXRlW2dldERhdGVdKCkgLSBtaW5EYXRlW2dldERheV0oKSArXG5cdFx0XHRcdFx0cGljayhzdGFydE9mV2VlaywgMSkpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFxuXHRcdFx0Ly8gZ2V0IHRpY2sgcG9zaXRpb25zXG5cdFx0XHRpID0gMTtcblx0XHRcdGlmICh0aW1lem9uZU9mZnNldCB8fCBnZXRUaW1lem9uZU9mZnNldCkge1xuXHRcdFx0XHRtaW5EYXRlID0gbWluRGF0ZS5nZXRUaW1lKCk7XG5cdFx0XHRcdG1pbkRhdGUgPSBuZXcgRGF0ZShtaW5EYXRlICsgZ2V0VFpPZmZzZXQobWluRGF0ZSkpO1xuXHRcdFx0fVxuXHRcdFx0bWluWWVhciA9IG1pbkRhdGVbZ2V0RnVsbFllYXJdKCk7XG5cdFx0XHR2YXIgdGltZSA9IG1pbkRhdGUuZ2V0VGltZSgpLFxuXHRcdFx0XHRtaW5Nb250aCA9IG1pbkRhdGVbZ2V0TW9udGhdKCksXG5cdFx0XHRcdG1pbkRhdGVEYXRlID0gbWluRGF0ZVtnZXREYXRlXSgpLFxuXHRcdFx0XHRsb2NhbFRpbWV6b25lT2Zmc2V0ID0gKHRpbWVVbml0cy5kYXkgKyBcblx0XHRcdFx0XHRcdCh1c2VVVEMgPyBnZXRUWk9mZnNldChtaW5EYXRlKSA6IG1pbkRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMClcblx0XHRcdFx0XHQpICUgdGltZVVuaXRzLmRheTsgLy8gIzk1MCwgIzMzNTlcblx0XHRcblx0XHRcdC8vIGl0ZXJhdGUgYW5kIGFkZCB0aWNrIHBvc2l0aW9ucyBhdCBhcHByb3ByaWF0ZSB2YWx1ZXNcblx0XHRcdHdoaWxlICh0aW1lIDwgbWF4KSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaCh0aW1lKTtcblx0XHRcblx0XHRcdFx0Ly8gaWYgdGhlIGludGVydmFsIGlzIHllYXJzLCB1c2UgRGF0ZS5VVEMgdG8gaW5jcmVhc2UgeWVhcnNcblx0XHRcdFx0aWYgKGludGVydmFsID09PSB0aW1lVW5pdHMueWVhcikge1xuXHRcdFx0XHRcdHRpbWUgPSBtYWtlVGltZShtaW5ZZWFyICsgaSAqIGNvdW50LCAwKTtcblx0XHRcblx0XHRcdFx0Ly8gaWYgdGhlIGludGVydmFsIGlzIG1vbnRocywgdXNlIERhdGUuVVRDIHRvIGluY3JlYXNlIG1vbnRoc1xuXHRcdFx0XHR9IGVsc2UgaWYgKGludGVydmFsID09PSB0aW1lVW5pdHMubW9udGgpIHtcblx0XHRcdFx0XHR0aW1lID0gbWFrZVRpbWUobWluWWVhciwgbWluTW9udGggKyBpICogY291bnQpO1xuXHRcdFxuXHRcdFx0XHQvLyBpZiB3ZSdyZSB1c2luZyBnbG9iYWwgdGltZSwgdGhlIGludGVydmFsIGlzIG5vdCBmaXhlZCBhcyBpdCBqdW1wc1xuXHRcdFx0XHQvLyBvbmUgaG91ciBhdCB0aGUgRFNUIGNyb3Nzb3ZlclxuXHRcdFx0XHR9IGVsc2UgaWYgKCF1c2VVVEMgJiYgKGludGVydmFsID09PSB0aW1lVW5pdHMuZGF5IHx8IGludGVydmFsID09PSB0aW1lVW5pdHMud2VlaykpIHtcblx0XHRcdFx0XHR0aW1lID0gbWFrZVRpbWUobWluWWVhciwgbWluTW9udGgsIG1pbkRhdGVEYXRlICtcblx0XHRcdFx0XHRcdGkgKiBjb3VudCAqIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzLmRheSA/IDEgOiA3KSk7XG5cdFx0XG5cdFx0XHRcdC8vIGVsc2UsIHRoZSBpbnRlcnZhbCBpcyBmaXhlZCBhbmQgd2UgdXNlIHNpbXBsZSBhZGRpdGlvblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpbWUgKz0gaW50ZXJ2YWwgKiBjb3VudDtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRpKys7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHQvLyBwdXNoIHRoZSBsYXN0IHRpbWVcblx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaCh0aW1lKTtcblxuXG5cdFx0XHQvLyBtYXJrIG5ldyBkYXlzIGlmIHRoZSB0aW1lIGlzIGRpdmlkaWJsZSBieSBkYXkgKCMxNjQ5LCAjMTc2MClcblx0XHRcdGVhY2goZ3JlcCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAodGltZSkge1xuXHRcdFx0XHRyZXR1cm4gaW50ZXJ2YWwgPD0gdGltZVVuaXRzLmhvdXIgJiYgdGltZSAlIHRpbWVVbml0cy5kYXkgPT09IGxvY2FsVGltZXpvbmVPZmZzZXQ7XG5cdFx0XHR9KSwgZnVuY3Rpb24gKHRpbWUpIHtcblx0XHRcdFx0aGlnaGVyUmFua3NbdGltZV0gPSAnZGF5Jztcblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0Ly8gcmVjb3JkIGluZm9ybWF0aW9uIG9uIHRoZSBjaG9zZW4gdW5pdCAtIGZvciBkeW5hbWljIGxhYmVsIGZvcm1hdHRlclxuXHRcdHRpY2tQb3NpdGlvbnMuaW5mbyA9IGV4dGVuZChub3JtYWxpemVkSW50ZXJ2YWwsIHtcblx0XHRcdGhpZ2hlclJhbmtzOiBoaWdoZXJSYW5rcyxcblx0XHRcdHRvdGFsUmFuZ2U6IGludGVydmFsICogY291bnRcblx0XHR9KTtcblxuXHRcdHJldHVybiB0aWNrUG9zaXRpb25zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYSBub3JtYWxpemVkIHRpY2sgaW50ZXJ2YWwgZm9yIGRhdGVzLiBSZXR1cm5zIGEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aFxuXHQgKiB1bml0IHJhbmdlIChpbnRlcnZhbCksIGNvdW50IGFuZCBuYW1lLiBVc2VkIHRvIHByZXBhcmUgZGF0YSBmb3IgZ2V0VGltZVRpY2tzLiBcblx0ICogUHJldmlvdXNseSB0aGlzIGxvZ2ljIHdhcyBwYXJ0IG9mIGdldFRpbWVUaWNrcywgYnV0IGFzIGdldFRpbWVUaWNrcyBub3cgcnVuc1xuXHQgKiBvZiBzZWdtZW50cyBpbiBzdG9jayBjaGFydHMsIHRoZSBub3JtYWxpemluZyBsb2dpYyB3YXMgZXh0cmFjdGVkIGluIG9yZGVyIHRvIFxuXHQgKiBwcmV2ZW50IGl0IGZvciBydW5uaW5nIG92ZXIgYWdhaW4gZm9yIGVhY2ggc2VnbWVudCBoYXZpbmcgdGhlIHNhbWUgaW50ZXJ2YWwuIFxuXHQgKiAjNjYyLCAjNjk3LlxuXHQgKi9cblx0QXhpcy5wcm90b3R5cGUubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCA9IGZ1bmN0aW9uICh0aWNrSW50ZXJ2YWwsIHVuaXRzT3B0aW9uKSB7XG5cdFx0dmFyIHVuaXRzID0gdW5pdHNPcHRpb24gfHwgW1tcblx0XHRcdFx0XHQnbWlsbGlzZWNvbmQnLCAvLyB1bml0IG5hbWVcblx0XHRcdFx0XHRbMSwgMiwgNSwgMTAsIDIwLCAyNSwgNTAsIDEwMCwgMjAwLCA1MDBdIC8vIGFsbG93ZWQgbXVsdGlwbGVzXG5cdFx0XHRcdF0sIFtcblx0XHRcdFx0XHQnc2Vjb25kJyxcblx0XHRcdFx0XHRbMSwgMiwgNSwgMTAsIDE1LCAzMF1cblx0XHRcdFx0XSwgW1xuXHRcdFx0XHRcdCdtaW51dGUnLFxuXHRcdFx0XHRcdFsxLCAyLCA1LCAxMCwgMTUsIDMwXVxuXHRcdFx0XHRdLCBbXG5cdFx0XHRcdFx0J2hvdXInLFxuXHRcdFx0XHRcdFsxLCAyLCAzLCA0LCA2LCA4LCAxMl1cblx0XHRcdFx0XSwgW1xuXHRcdFx0XHRcdCdkYXknLFxuXHRcdFx0XHRcdFsxLCAyXVxuXHRcdFx0XHRdLCBbXG5cdFx0XHRcdFx0J3dlZWsnLFxuXHRcdFx0XHRcdFsxLCAyXVxuXHRcdFx0XHRdLCBbXG5cdFx0XHRcdFx0J21vbnRoJyxcblx0XHRcdFx0XHRbMSwgMiwgMywgNCwgNl1cblx0XHRcdFx0XSwgW1xuXHRcdFx0XHRcdCd5ZWFyJyxcblx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdF1dLFxuXHRcdFx0dW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdLCAvLyBkZWZhdWx0IHVuaXQgaXMgeWVhcnNcblx0XHRcdGludGVydmFsID0gdGltZVVuaXRzW3VuaXRbMF1dLFxuXHRcdFx0bXVsdGlwbGVzID0gdW5pdFsxXSxcblx0XHRcdGNvdW50LFxuXHRcdFx0aTtcblx0XHRcdFxuXHRcdC8vIGxvb3AgdGhyb3VnaCB0aGUgdW5pdHMgdG8gZmluZCB0aGUgb25lIHRoYXQgYmVzdCBmaXRzIHRoZSB0aWNrSW50ZXJ2YWxcblx0XHRmb3IgKGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHVuaXQgPSB1bml0c1tpXTtcblx0XHRcdGludGVydmFsID0gdGltZVVuaXRzW3VuaXRbMF1dO1xuXHRcdFx0bXVsdGlwbGVzID0gdW5pdFsxXTtcblxuXG5cdFx0XHRpZiAodW5pdHNbaSArIDFdKSB7XG5cdFx0XHRcdC8vIGxlc3NUaGFuIGlzIGluIHRoZSBtaWRkbGUgYmV0d2VlbiB0aGUgaGlnaGVzdCBtdWx0aXBsZSBhbmQgdGhlIG5leHQgdW5pdC5cblx0XHRcdFx0dmFyIGxlc3NUaGFuID0gKGludGVydmFsICogbXVsdGlwbGVzW211bHRpcGxlcy5sZW5ndGggLSAxXSArXG5cdFx0XHRcdFx0XHRcdHRpbWVVbml0c1t1bml0c1tpICsgMV1bMF1dKSAvIDI7XG5cblx0XHRcdFx0Ly8gYnJlYWsgYW5kIGtlZXAgdGhlIGN1cnJlbnQgdW5pdFxuXHRcdFx0XHRpZiAodGlja0ludGVydmFsIDw9IGxlc3NUaGFuKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBwcmV2ZW50IDIuNSB5ZWFycyBpbnRlcnZhbHMsIHRob3VnaCAyNSwgMjUwIGV0Yy4gYXJlIGFsbG93ZWRcblx0XHRpZiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0cy55ZWFyICYmIHRpY2tJbnRlcnZhbCA8IDUgKiBpbnRlcnZhbCkge1xuXHRcdFx0bXVsdGlwbGVzID0gWzEsIDIsIDVdO1xuXHRcdH1cblxuXHRcdC8vIGdldCB0aGUgY291bnRcblx0XHRjb3VudCA9IG5vcm1hbGl6ZVRpY2tJbnRlcnZhbChcblx0XHRcdHRpY2tJbnRlcnZhbCAvIGludGVydmFsLCBcblx0XHRcdG11bHRpcGxlcyxcblx0XHRcdHVuaXRbMF0gPT09ICd5ZWFyJyA/IG1hdGhNYXgoZ2V0TWFnbml0dWRlKHRpY2tJbnRlcnZhbCAvIGludGVydmFsKSwgMSkgOiAxIC8vICMxOTEzLCAjMjM2MFxuXHRcdCk7XG5cdFx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdHVuaXRSYW5nZTogaW50ZXJ2YWwsXG5cdFx0XHRjb3VudDogY291bnQsXG5cdFx0XHR1bml0TmFtZTogdW5pdFswXVxuXHRcdH07XG5cdH07LyoqXG5cdCAqIE1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgQXhpcyBwcm90b3R5cGVcblx0ICovXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgdGljayBwb3NpdGlvbnMgb2YgYSBsb2dhcml0aG1pYyBheGlzXG5cdCAqL1xuXHRBeGlzLnByb3RvdHlwZS5nZXRMb2dUaWNrUG9zaXRpb25zID0gZnVuY3Rpb24gKGludGVydmFsLCBtaW4sIG1heCwgbWlub3IpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0YXhpc0xlbmd0aCA9IGF4aXMubGVuLFxuXHRcdFx0Ly8gU2luY2Ugd2UgdXNlIHRoaXMgbWV0aG9kIGZvciBib3RoIG1ham9yIGFuZCBtaW5vciB0aWNrcyxcblx0XHRcdC8vIHVzZSBhIGxvY2FsIHZhcmlhYmxlIGFuZCByZXR1cm4gdGhlIHJlc3VsdFxuXHRcdFx0cG9zaXRpb25zID0gW107IFxuXHRcdFxuXHRcdC8vIFJlc2V0XG5cdFx0aWYgKCFtaW5vcikge1xuXHRcdFx0YXhpcy5fbWlub3JBdXRvSW50ZXJ2YWwgPSBudWxsO1xuXHRcdH1cblx0XHRcblx0XHQvLyBGaXJzdCBjYXNlOiBBbGwgdGlja3MgZmFsbCBvbiB3aG9sZSBsb2dhcml0aG1zOiAxLCAxMCwgMTAwIGV0Yy5cblx0XHRpZiAoaW50ZXJ2YWwgPj0gMC41KSB7XG5cdFx0XHRpbnRlcnZhbCA9IG1hdGhSb3VuZChpbnRlcnZhbCk7XG5cdFx0XHRwb3NpdGlvbnMgPSBheGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnMoaW50ZXJ2YWwsIG1pbiwgbWF4KTtcblx0XHRcdFxuXHRcdC8vIFNlY29uZCBjYXNlOiBXZSBuZWVkIGludGVybWVkaWFyeSB0aWNrcy4gRm9yIGV4YW1wbGUgXG5cdFx0Ly8gMSwgMiwgNCwgNiwgOCwgMTAsIDIwLCA0MCBldGMuIFxuXHRcdH0gZWxzZSBpZiAoaW50ZXJ2YWwgPj0gMC4wOCkge1xuXHRcdFx0dmFyIHJvdW5kZWRNaW4gPSBtYXRoRmxvb3IobWluKSxcblx0XHRcdFx0aW50ZXJtZWRpYXRlLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRqLFxuXHRcdFx0XHRsZW4sXG5cdFx0XHRcdHBvcyxcblx0XHRcdFx0bGFzdFBvcyxcblx0XHRcdFx0YnJlYWsyO1xuXHRcdFx0XHRcblx0XHRcdGlmIChpbnRlcnZhbCA+IDAuMykge1xuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSBbMSwgMiwgNF07XG5cdFx0XHR9IGVsc2UgaWYgKGludGVydmFsID4gMC4xNSkgeyAvLyAwLjIgZXF1YWxzIGZpdmUgbWlub3IgdGlja3MgcGVyIDEsIDEwLCAxMDAgZXRjXG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IFsxLCAyLCA0LCA2LCA4XTtcblx0XHRcdH0gZWxzZSB7IC8vIDAuMSBlcXVhbHMgdGVuIG1pbm9yIHRpY2tzIHBlciAxLCAxMCwgMTAwIGV0Y1xuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvciAoaSA9IHJvdW5kZWRNaW47IGkgPCBtYXggKyAxICYmICFicmVhazI7IGkrKykge1xuXHRcdFx0XHRsZW4gPSBpbnRlcm1lZGlhdGUubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbGVuICYmICFicmVhazI7IGorKykge1xuXHRcdFx0XHRcdHBvcyA9IGxvZzJsaW4obGluMmxvZyhpKSAqIGludGVybWVkaWF0ZVtqXSk7XG5cdFx0XHRcdFx0aWYgKHBvcyA+IG1pbiAmJiAoIW1pbm9yIHx8IGxhc3RQb3MgPD0gbWF4KSAmJiBsYXN0UG9zICE9PSBVTkRFRklORUQpIHsgLy8gIzE2NzAsIGxhc3RQb3MgaXMgIzMxMTNcblx0XHRcdFx0XHRcdHBvc2l0aW9ucy5wdXNoKGxhc3RQb3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobGFzdFBvcyA+IG1heCkge1xuXHRcdFx0XHRcdFx0YnJlYWsyID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdFBvcyA9IHBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0Ly8gVGhpcmQgY2FzZTogV2UgYXJlIHNvIGRlZXAgaW4gYmV0d2VlbiB3aG9sZSBsb2dhcml0aG1pYyB2YWx1ZXMgdGhhdFxuXHRcdC8vIHdlIG1pZ2h0IGFzIHdlbGwgaGFuZGxlIHRoZSB0aWNrIHBvc2l0aW9ucyBsaWtlIGEgbGluZWFyIGF4aXMuIEZvclxuXHRcdC8vIGV4YW1wbGUgMS4wMSwgMS4wMiwgMS4wMywgMS4wNC5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHJlYWxNaW4gPSBsaW4ybG9nKG1pbiksXG5cdFx0XHRcdHJlYWxNYXggPSBsaW4ybG9nKG1heCksXG5cdFx0XHRcdHRpY2tJbnRlcnZhbE9wdGlvbiA9IG9wdGlvbnNbbWlub3IgPyAnbWlub3JUaWNrSW50ZXJ2YWwnIDogJ3RpY2tJbnRlcnZhbCddLFxuXHRcdFx0XHRmaWx0ZXJlZFRpY2tJbnRlcnZhbE9wdGlvbiA9IHRpY2tJbnRlcnZhbE9wdGlvbiA9PT0gJ2F1dG8nID8gbnVsbCA6IHRpY2tJbnRlcnZhbE9wdGlvbixcblx0XHRcdFx0dGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zLnRpY2tQaXhlbEludGVydmFsIC8gKG1pbm9yID8gNSA6IDEpLFxuXHRcdFx0XHR0b3RhbFBpeGVsTGVuZ3RoID0gbWlub3IgPyBheGlzTGVuZ3RoIC8gYXhpcy50aWNrUG9zaXRpb25zLmxlbmd0aCA6IGF4aXNMZW5ndGg7XG5cdFx0XHRcblx0XHRcdGludGVydmFsID0gcGljayhcblx0XHRcdFx0ZmlsdGVyZWRUaWNrSW50ZXJ2YWxPcHRpb24sXG5cdFx0XHRcdGF4aXMuX21pbm9yQXV0b0ludGVydmFsLFxuXHRcdFx0XHQocmVhbE1heCAtIHJlYWxNaW4pICogdGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gLyAodG90YWxQaXhlbExlbmd0aCB8fCAxKVxuXHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0aW50ZXJ2YWwgPSBub3JtYWxpemVUaWNrSW50ZXJ2YWwoXG5cdFx0XHRcdGludGVydmFsLCBcblx0XHRcdFx0bnVsbCwgXG5cdFx0XHRcdGdldE1hZ25pdHVkZShpbnRlcnZhbClcblx0XHRcdCk7XG5cdFx0XHRcblx0XHRcdHBvc2l0aW9ucyA9IG1hcChheGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnMoXG5cdFx0XHRcdGludGVydmFsLCBcblx0XHRcdFx0cmVhbE1pbixcblx0XHRcdFx0cmVhbE1heFx0XG5cdFx0XHQpLCBsb2cybGluKTtcblx0XHRcdFxuXHRcdFx0aWYgKCFtaW5vcikge1xuXHRcdFx0XHRheGlzLl9taW5vckF1dG9JbnRlcnZhbCA9IGludGVydmFsIC8gNTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gU2V0IHRoZSBheGlzLWxldmVsIHRpY2tJbnRlcnZhbCB2YXJpYWJsZSBcblx0XHRpZiAoIW1pbm9yKSB7XG5cdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IGludGVydmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9zaXRpb25zO1xuXHR9Oy8qKlxuXHQgKiBUaGUgdG9vbHRpcCBvYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0IFRoZSBjaGFydCBpbnN0YW5jZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUb29sdGlwIG9wdGlvbnNcblx0ICovXG5cdHZhciBUb29sdGlwID0gSGlnaGNoYXJ0cy5Ub29sdGlwID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdFRvb2x0aXAucHJvdG90eXBlID0ge1xuXG5cdFx0aW5pdDogZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cblx0XHRcdHZhciBib3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdHN0eWxlID0gb3B0aW9ucy5zdHlsZSxcblx0XHRcdFx0cGFkZGluZyA9IHBJbnQoc3R5bGUucGFkZGluZyk7XG5cblx0XHRcdC8vIFNhdmUgdGhlIGNoYXJ0IGFuZCBvcHRpb25zXG5cdFx0XHR0aGlzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHNlcmllc1xuXHRcdFx0Ly90aGlzLmN1cnJlbnRTZXJpZXMgPSBVTkRFRklORUQ7XG5cblx0XHRcdC8vIExpc3Qgb2YgY3Jvc3NoYWlyc1xuXHRcdFx0dGhpcy5jcm9zc2hhaXJzID0gW107XG5cblx0XHRcdC8vIEN1cnJlbnQgdmFsdWVzIG9mIHggYW5kIHkgd2hlbiBhbmltYXRpbmdcblx0XHRcdHRoaXMubm93ID0geyB4OiAwLCB5OiAwIH07XG5cblx0XHRcdC8vIFRoZSB0b29sdGlwIGlzIGluaXRpYWxseSBoaWRkZW5cblx0XHRcdHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuXG5cblx0XHRcdC8vIGNyZWF0ZSB0aGUgbGFiZWxcdFx0XG5cdFx0XHR0aGlzLmxhYmVsID0gY2hhcnQucmVuZGVyZXIubGFiZWwoJycsIDAsIDAsIG9wdGlvbnMuc2hhcGUgfHwgJ2NhbGxvdXQnLCBudWxsLCBudWxsLCBvcHRpb25zLnVzZUhUTUwsIG51bGwsICd0b29sdGlwJylcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHBhZGRpbmc6IHBhZGRpbmcsXG5cdFx0XHRcdFx0ZmlsbDogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdHI6IG9wdGlvbnMuYm9yZGVyUmFkaXVzLFxuXHRcdFx0XHRcdHpJbmRleDogOFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKHN0eWxlKVxuXHRcdFx0XHQuY3NzKHsgcGFkZGluZzogMCB9KSAvLyBSZW1vdmUgaXQgZnJvbSBWTUwsIHRoZSBwYWRkaW5nIGlzIGFwcGxpZWQgYXMgYW4gYXR0cmlidXRlIGluc3RlYWQgKCMxMTE3KVxuXHRcdFx0XHQuYWRkKClcblx0XHRcdFx0LmF0dHIoeyB5OiAtOTk5OSB9KTsgLy8gIzIzMDEsICMyNjU3XG5cblx0XHRcdC8vIFdoZW4gdXNpbmcgY2FuVkcgdGhlIHNoYWRvdyBzaG93cyB1cCBhcyBhIGdyYXkgY2lyY2xlXG5cdFx0XHQvLyBldmVuIGlmIHRoZSB0b29sdGlwIGlzIGhpZGRlbi5cblx0XHRcdGlmICghdXNlQ2FuVkcpIHtcblx0XHRcdFx0dGhpcy5sYWJlbC5zaGFkb3cob3B0aW9ucy5zaGFkb3cpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdWJsaWMgcHJvcGVydHkgZm9yIGdldHRpbmcgdGhlIHNoYXJlZCBzdGF0ZS5cblx0XHRcdHRoaXMuc2hhcmVkID0gb3B0aW9ucy5zaGFyZWQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgdGhlIHRvb2x0aXAgYW5kIGl0cyBlbGVtZW50cy5cblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBEZXN0cm95IGFuZCBjbGVhciBsb2NhbCB2YXJpYWJsZXNcblx0XHRcdGlmICh0aGlzLmxhYmVsKSB7XG5cdFx0XHRcdHRoaXMubGFiZWwgPSB0aGlzLmxhYmVsLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGUgYSBzb2Z0IG1vdmVtZW50IGZvciB0aGUgdG9vbHRpcFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0bW92ZTogZnVuY3Rpb24gKHgsIHksIGFuY2hvclgsIGFuY2hvclkpIHtcblx0XHRcdHZhciB0b29sdGlwID0gdGhpcyxcblx0XHRcdFx0bm93ID0gdG9vbHRpcC5ub3csXG5cdFx0XHRcdGFuaW1hdGUgPSB0b29sdGlwLm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSAmJiAhdG9vbHRpcC5pc0hpZGRlbiAmJiBcblx0XHRcdFx0XHQvLyBXaGVuIHdlIGdldCBjbG9zZSB0byB0aGUgdGFyZ2V0IHBvc2l0aW9uLCBhYm9ydCBhbmltYXRpb24gYW5kIGxhbmQgb24gdGhlIHJpZ2h0IHBsYWNlICgjMzA1Nilcblx0XHRcdFx0XHQobWF0aEFicyh4IC0gbm93LngpID4gMSB8fCBtYXRoQWJzKHkgLSBub3cueSkgPiAxKSxcblx0XHRcdFx0c2tpcEFuY2hvciA9IHRvb2x0aXAuZm9sbG93UG9pbnRlciB8fCB0b29sdGlwLmxlbiA+IDE7XG5cblx0XHRcdC8vIEdldCBpbnRlcm1lZGlhdGUgdmFsdWVzIGZvciBhbmltYXRpb25cblx0XHRcdGV4dGVuZChub3csIHtcblx0XHRcdFx0eDogYW5pbWF0ZSA/ICgyICogbm93LnggKyB4KSAvIDMgOiB4LFxuXHRcdFx0XHR5OiBhbmltYXRlID8gKG5vdy55ICsgeSkgLyAyIDogeSxcblx0XHRcdFx0YW5jaG9yWDogc2tpcEFuY2hvciA/IFVOREVGSU5FRCA6IGFuaW1hdGUgPyAoMiAqIG5vdy5hbmNob3JYICsgYW5jaG9yWCkgLyAzIDogYW5jaG9yWCxcblx0XHRcdFx0YW5jaG9yWTogc2tpcEFuY2hvciA/IFVOREVGSU5FRCA6IGFuaW1hdGUgPyAobm93LmFuY2hvclkgKyBhbmNob3JZKSAvIDIgOiBhbmNob3JZXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gTW92ZSB0byB0aGUgaW50ZXJtZWRpYXRlIHZhbHVlXG5cdFx0XHR0b29sdGlwLmxhYmVsLmF0dHIobm93KTtcblxuXHRcdFx0XG5cdFx0XHQvLyBSdW4gb24gbmV4dCB0aWNrIG9mIHRoZSBtb3VzZSB0cmFja2VyXG5cdFx0XHRpZiAoYW5pbWF0ZSkge1xuXHRcdFx0XG5cdFx0XHRcdC8vIE5ldmVyIGFsbG93IHR3byB0aW1lb3V0c1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBTZXQgdGhlIGZpeGVkIGludGVydmFsIHRpY2tpbmcgZm9yIHRoZSBzbW9vdGggdG9vbHRpcFxuXHRcdFx0XHR0aGlzLnRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Ly8gVGhlIGludGVydmFsIGZ1bmN0aW9uIG1heSBzdGlsbCBiZSBydW5uaW5nIGR1cmluZyBkZXN0cm95LCBzbyBjaGVjayB0aGF0IHRoZSBjaGFydCBpcyByZWFsbHkgdGhlcmUgYmVmb3JlIGNhbGxpbmcuXG5cdFx0XHRcdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdFx0XHRcdHRvb2x0aXAubW92ZSh4LCB5LCBhbmNob3JYLCBhbmNob3JZKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDMyKTtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhpZGUgdGhlIHRvb2x0aXBcblx0XHQgKi9cblx0XHRoaWRlOiBmdW5jdGlvbiAoZGVsYXkpIHtcblx0XHRcdHZhciB0b29sdGlwID0gdGhpcyxcblx0XHRcdFx0aG92ZXJQb2ludHM7XG5cdFx0XHRcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7IC8vIGRpc2FsbG93IGR1cGxpY2F0ZSB0aW1lcnMgKCMxNzI4LCAjMTc2Nilcblx0XHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0XHRob3ZlclBvaW50cyA9IHRoaXMuY2hhcnQuaG92ZXJQb2ludHM7XG5cblx0XHRcdFx0dGhpcy5oaWRlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0b29sdGlwLmxhYmVsLmZhZGVPdXQoKTtcblx0XHRcdFx0XHR0b29sdGlwLmlzSGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSwgcGljayhkZWxheSwgdGhpcy5vcHRpb25zLmhpZGVEZWxheSwgNTAwKSk7XG5cblx0XHRcdFx0Ly8gaGlkZSBwcmV2aW91cyBob3ZlclBvaW50cyBhbmQgc2V0IG5ld1xuXHRcdFx0XHRpZiAoaG92ZXJQb2ludHMpIHtcblx0XHRcdFx0XHRlYWNoKGhvdmVyUG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRcdHBvaW50LnNldFN0YXRlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmNoYXJ0LmhvdmVyUG9pbnRzID0gbnVsbDtcblx0XHRcdFx0dGhpcy5jaGFydC5ob3ZlclNlcmllcyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHQvKiogXG5cdFx0ICogRXh0ZW5kYWJsZSBtZXRob2QgdG8gZ2V0IHRoZSBhbmNob3IgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXBcblx0XHQgKiBmcm9tIGEgcG9pbnQgb3Igc2V0IG9mIHBvaW50c1xuXHRcdCAqL1xuXHRcdGdldEFuY2hvcjogZnVuY3Rpb24gKHBvaW50cywgbW91c2VFdmVudCkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHRwbG90VG9wID0gY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0cGxvdFggPSAwLFxuXHRcdFx0XHRwbG90WSA9IDAsXG5cdFx0XHRcdHlBeGlzLFxuXHRcdFx0XHR4QXhpcztcblx0XHRcdFxuXHRcdFx0cG9pbnRzID0gc3BsYXQocG9pbnRzKTtcblx0XHRcdFxuXHRcdFx0Ly8gUGllIHVzZXMgYSBzcGVjaWFsIHRvb2x0aXBQb3Ncblx0XHRcdHJldCA9IHBvaW50c1swXS50b29sdGlwUG9zO1xuXHRcdFx0XG5cdFx0XHQvLyBXaGVuIHRvb2x0aXAgZm9sbG93cyBtb3VzZSwgcmVsYXRlIHRoZSBwb3NpdGlvbiB0byB0aGUgbW91c2Vcblx0XHRcdGlmICh0aGlzLmZvbGxvd1BvaW50ZXIgJiYgbW91c2VFdmVudCkge1xuXHRcdFx0XHRpZiAobW91c2VFdmVudC5jaGFydFggPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdG1vdXNlRXZlbnQgPSBjaGFydC5wb2ludGVyLm5vcm1hbGl6ZShtb3VzZUV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXQgPSBbXG5cdFx0XHRcdFx0bW91c2VFdmVudC5jaGFydFggLSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0XHRtb3VzZUV2ZW50LmNoYXJ0WSAtIHBsb3RUb3Bcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdC8vIFdoZW4gc2hhcmVkLCB1c2UgdGhlIGF2ZXJhZ2UgcG9zaXRpb25cblx0XHRcdGlmICghcmV0KSB7XG5cdFx0XHRcdGVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHR5QXhpcyA9IHBvaW50LnNlcmllcy55QXhpcztcblx0XHRcdFx0XHR4QXhpcyA9IHBvaW50LnNlcmllcy54QXhpcztcblx0XHRcdFx0XHRwbG90WCArPSBwb2ludC5wbG90WCAgKyAoIWludmVydGVkICYmIHhBeGlzID8geEF4aXMubGVmdCAtIHBsb3RMZWZ0IDogMCk7IFxuXHRcdFx0XHRcdHBsb3RZICs9IChwb2ludC5wbG90TG93ID8gKHBvaW50LnBsb3RMb3cgKyBwb2ludC5wbG90SGlnaCkgLyAyIDogcG9pbnQucGxvdFkpICtcblx0XHRcdFx0XHRcdCghaW52ZXJ0ZWQgJiYgeUF4aXMgPyB5QXhpcy50b3AgLSBwbG90VG9wIDogMCk7IC8vICMxMTUxXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0cGxvdFggLz0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0cGxvdFkgLz0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0XG5cdFx0XHRcdHJldCA9IFtcblx0XHRcdFx0XHRpbnZlcnRlZCA/IGNoYXJ0LnBsb3RXaWR0aCAtIHBsb3RZIDogcGxvdFgsXG5cdFx0XHRcdFx0dGhpcy5zaGFyZWQgJiYgIWludmVydGVkICYmIHBvaW50cy5sZW5ndGggPiAxICYmIG1vdXNlRXZlbnQgPyBcblx0XHRcdFx0XHRcdG1vdXNlRXZlbnQuY2hhcnRZIC0gcGxvdFRvcCA6IC8vIHBsYWNlIHNoYXJlZCB0b29sdGlwIG5leHQgdG8gdGhlIG1vdXNlICgjNDI0KVxuXHRcdFx0XHRcdFx0aW52ZXJ0ZWQgPyBjaGFydC5wbG90SGVpZ2h0IC0gcGxvdFggOiBwbG90WVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWFwKHJldCwgbWF0aFJvdW5kKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFBsYWNlIHRoZSB0b29sdGlwIGluIGEgY2hhcnQgd2l0aG91dCBzcGlsbGluZyBvdmVyXG5cdFx0ICogYW5kIG5vdCBjb3ZlcmluZyB0aGUgcG9pbnQgaXQgc2VsZi5cblx0XHQgKi9cblx0XHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKGJveFdpZHRoLCBib3hIZWlnaHQsIHBvaW50KSB7XG5cdFx0XHRcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSxcblx0XHRcdFx0cmV0ID0ge30sXG5cdFx0XHRcdGggPSBwb2ludC5oLFxuXHRcdFx0XHRzd2FwcGVkLFxuXHRcdFx0XHRmaXJzdCA9IFsneScsIGNoYXJ0LmNoYXJ0SGVpZ2h0LCBib3hIZWlnaHQsIHBvaW50LnBsb3RZICsgY2hhcnQucGxvdFRvcF0sXG5cdFx0XHRcdHNlY29uZCA9IFsneCcsIGNoYXJ0LmNoYXJ0V2lkdGgsIGJveFdpZHRoLCBwb2ludC5wbG90WCArIGNoYXJ0LnBsb3RMZWZ0XSxcblx0XHRcdFx0Ly8gVGhlIGZhciBzaWRlIGlzIHJpZ2h0IG9yIGJvdHRvbVxuXHRcdFx0XHRwcmVmZXJGYXJTaWRlID0gcGljayhwb2ludC50dEJlbG93LCAoY2hhcnQuaW52ZXJ0ZWQgJiYgIXBvaW50Lm5lZ2F0aXZlKSB8fCAoIWNoYXJ0LmludmVydGVkICYmIHBvaW50Lm5lZ2F0aXZlKSksXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBIYW5kbGUgdGhlIHByZWZlcnJlZCBkaW1lbnNpb24uIFdoZW4gdGhlIHByZWZlcnJlZCBkaW1lbnNpb24gaXMgdG9vbHRpcFxuXHRcdFx0XHQgKiBvbiB0b3Agb3IgYm90dG9tIG9mIHRoZSBwb2ludCwgaXQgd2lsbCBsb29rIGZvciBzcGFjZSB0aGVyZS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGZpcnN0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSwgb3V0ZXJTaXplLCBpbm5lclNpemUsIHBvaW50KSB7XG5cdFx0XHRcdFx0dmFyIHJvb21MZWZ0ID0gaW5uZXJTaXplIDwgcG9pbnQgLSBkaXN0YW5jZSxcblx0XHRcdFx0XHRcdHJvb21SaWdodCA9IHBvaW50ICsgZGlzdGFuY2UgKyBpbm5lclNpemUgPCBvdXRlclNpemUsXG5cdFx0XHRcdFx0XHRhbGlnbmVkTGVmdCA9IHBvaW50IC0gZGlzdGFuY2UgLSBpbm5lclNpemUsXG5cdFx0XHRcdFx0XHRhbGlnbmVkUmlnaHQgPSBwb2ludCArIGRpc3RhbmNlO1xuXG5cdFx0XHRcdFx0aWYgKHByZWZlckZhclNpZGUgJiYgcm9vbVJpZ2h0KSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IGFsaWduZWRSaWdodDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFwcmVmZXJGYXJTaWRlICYmIHJvb21MZWZ0KSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IGFsaWduZWRMZWZ0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocm9vbUxlZnQpIHtcblx0XHRcdFx0XHRcdHJldFtkaW1dID0gYWxpZ25lZExlZnQgLSBoIDwgMCA/IGFsaWduZWRMZWZ0IDogYWxpZ25lZExlZnQgLSBoO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocm9vbVJpZ2h0KSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IGFsaWduZWRSaWdodCArIGggKyBpbm5lclNpemUgPiBvdXRlclNpemUgPyBhbGlnbmVkUmlnaHQgOiBhbGlnbmVkUmlnaHQgKyBoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogSGFuZGxlIHRoZSBzZWNvbmRhcnkgZGltZW5zaW9uLiBJZiB0aGUgcHJlZmVycmVkIGRpbWVuc2lvbiBpcyB0b29sdGlwXG5cdFx0XHRcdCAqIG9uIHRvcCBvciBib3R0b20gb2YgdGhlIHBvaW50LCB0aGUgc2Vjb25kIGRpbWVuc2lvbiBpcyB0byBhbGlnbiB0aGUgdG9vbHRpcFxuXHRcdFx0XHQgKiBhYm92ZSB0aGUgcG9pbnQsIHRyeWluZyB0byBhbGlnbiBjZW50ZXIgYnV0IGFsbG93aW5nIGxlZnQgb3IgcmlnaHRcblx0XHRcdFx0ICogYWxpZ24gd2l0aGluIHRoZSBjaGFydCBib3guXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRzZWNvbmREaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltLCBvdXRlclNpemUsIGlubmVyU2l6ZSwgcG9pbnQpIHtcblx0XHRcdFx0XHQvLyBUb28gY2xvc2UgdG8gdGhlIGVkZ2UsIHJldHVybiBmYWxzZSBhbmQgc3dhcCBkaW1lbnNpb25zXG5cdFx0XHRcdFx0aWYgKHBvaW50IDwgZGlzdGFuY2UgfHwgcG9pbnQgPiBvdXRlclNpemUgLSBkaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEFsaWduIGxlZnQvdG9wXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb2ludCA8IGlubmVyU2l6ZSAvIDIpIHtcblx0XHRcdFx0XHRcdHJldFtkaW1dID0gMTtcblx0XHRcdFx0XHQvLyBBbGlnbiByaWdodC9ib3R0b21cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvaW50ID4gb3V0ZXJTaXplIC0gaW5uZXJTaXplIC8gMikge1xuXHRcdFx0XHRcdFx0cmV0W2RpbV0gPSBvdXRlclNpemUgLSBpbm5lclNpemUgLSAyO1xuXHRcdFx0XHRcdC8vIEFsaWduIGNlbnRlclxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IHBvaW50IC0gaW5uZXJTaXplIC8gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBTd2FwIHRoZSBkaW1lbnNpb25zIFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0c3dhcCA9IGZ1bmN0aW9uIChjb3VudCkge1xuXHRcdFx0XHRcdHZhciB0ZW1wID0gZmlyc3Q7XG5cdFx0XHRcdFx0Zmlyc3QgPSBzZWNvbmQ7XG5cdFx0XHRcdFx0c2Vjb25kID0gdGVtcDtcblx0XHRcdFx0XHRzd2FwcGVkID0gY291bnQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJ1biA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoZmlyc3REaW1lbnNpb24uYXBwbHkoMCwgZmlyc3QpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0aWYgKHNlY29uZERpbWVuc2lvbi5hcHBseSgwLCBzZWNvbmQpID09PSBmYWxzZSAmJiAhc3dhcHBlZCkge1xuXHRcdFx0XHRcdFx0XHRzd2FwKHRydWUpO1xuXHRcdFx0XHRcdFx0XHRydW4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFzd2FwcGVkKSB7XG5cdFx0XHRcdFx0XHRzd2FwKHRydWUpO1xuXHRcdFx0XHRcdFx0cnVuKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldC54ID0gcmV0LnkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gVW5kZXIgdGhlc2UgY29uZGl0aW9ucywgcHJlZmVyIHRoZSB0b29sdGlwIG9uIHRoZSBzaWRlIG9mIHRoZSBwb2ludFxuXHRcdFx0aWYgKGNoYXJ0LmludmVydGVkIHx8IHRoaXMubGVuID4gMSkge1xuXHRcdFx0XHRzd2FwKCk7XG5cdFx0XHR9XG5cdFx0XHRydW4oKTtcblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW4gY2FzZSBubyB1c2VyIGRlZmluZWQgZm9ybWF0dGVyIGlzIGdpdmVuLCB0aGlzIHdpbGwgYmUgdXNlZC4gTm90ZSB0aGF0IHRoZSBjb250ZXh0XG5cdFx0ICogaGVyZSBpcyBhbiBvYmplY3QgaG9sZGluZyBwb2ludCwgc2VyaWVzLCB4LCB5IGV0Yy5cblx0XHQgKi9cblx0XHRkZWZhdWx0Rm9ybWF0dGVyOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5wb2ludHMgfHwgc3BsYXQodGhpcyksXG5cdFx0XHRcdHM7XG5cblx0XHRcdC8vIGJ1aWxkIHRoZSBoZWFkZXJcblx0XHRcdHMgPSBbdG9vbHRpcC50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGl0ZW1zWzBdKV07IC8vIzMzOTc6IGFic3RyYWN0aW9uIHRvIGVuYWJsZSBmb3JtYXR0aW5nIG9mIGZvb3RlciBhbmQgaGVhZGVyXG5cblx0XHRcdC8vIGJ1aWxkIHRoZSB2YWx1ZXNcblx0XHRcdHMgPSBzLmNvbmNhdCh0b29sdGlwLmJvZHlGb3JtYXR0ZXIoaXRlbXMpKTtcblxuXHRcdFx0Ly8gZm9vdGVyXG5cdFx0XHRzLnB1c2godG9vbHRpcC50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGl0ZW1zWzBdLCB0cnVlKSk7IC8vIzMzOTc6IGFic3RyYWN0aW9uIHRvIGVuYWJsZSBmb3JtYXR0aW5nIG9mIGZvb3RlciBhbmQgaGVhZGVyXG5cblx0XHRcdHJldHVybiBzLmpvaW4oJycpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZWZyZXNoIHRoZSB0b29sdGlwJ3MgdGV4dCBhbmQgcG9zaXRpb24uXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHBvaW50XG5cdFx0ICovXG5cdFx0cmVmcmVzaDogZnVuY3Rpb24gKHBvaW50LCBtb3VzZUV2ZW50KSB7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gdG9vbHRpcC5jaGFydCxcblx0XHRcdFx0bGFiZWwgPSB0b29sdGlwLmxhYmVsLFxuXHRcdFx0XHRvcHRpb25zID0gdG9vbHRpcC5vcHRpb25zLFxuXHRcdFx0XHR4LFxuXHRcdFx0XHR5LFxuXHRcdFx0XHRhbmNob3IsXG5cdFx0XHRcdHRleHRDb25maWcgPSB7fSxcblx0XHRcdFx0dGV4dCxcblx0XHRcdFx0cG9pbnRDb25maWcgPSBbXSxcblx0XHRcdFx0Zm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgdG9vbHRpcC5kZWZhdWx0Rm9ybWF0dGVyLFxuXHRcdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzLFxuXHRcdFx0XHRib3JkZXJDb2xvcixcblx0XHRcdFx0c2hhcmVkID0gdG9vbHRpcC5zaGFyZWQsXG5cdFx0XHRcdGN1cnJlbnRTZXJpZXM7XG5cdFx0XHRcdFxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcblx0XHRcdFxuXHRcdFx0Ly8gZ2V0IHRoZSByZWZlcmVuY2UgcG9pbnQgY29vcmRpbmF0ZXMgKHBpZSBjaGFydHMgdXNlIHRvb2x0aXBQb3MpXG5cdFx0XHR0b29sdGlwLmZvbGxvd1BvaW50ZXIgPSBzcGxhdChwb2ludClbMF0uc2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7XG5cdFx0XHRhbmNob3IgPSB0b29sdGlwLmdldEFuY2hvcihwb2ludCwgbW91c2VFdmVudCk7XG5cdFx0XHR4ID0gYW5jaG9yWzBdO1xuXHRcdFx0eSA9IGFuY2hvclsxXTtcblxuXHRcdFx0Ly8gc2hhcmVkIHRvb2x0aXAsIGFycmF5IGlzIHNlbnQgb3ZlclxuXHRcdFx0aWYgKHNoYXJlZCAmJiAhKHBvaW50LnNlcmllcyAmJiBwb2ludC5zZXJpZXMubm9TaGFyZWRUb29sdGlwKSkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaGlkZSBwcmV2aW91cyBob3ZlclBvaW50cyBhbmQgc2V0IG5ld1xuXHRcdFx0XHRcblx0XHRcdFx0Y2hhcnQuaG92ZXJQb2ludHMgPSBwb2ludDtcblx0XHRcdFx0aWYgKGhvdmVyUG9pbnRzKSB7XG5cdFx0XHRcdFx0ZWFjaChob3ZlclBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWFjaChwb2ludCwgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0XHRpdGVtLnNldFN0YXRlKEhPVkVSX1NUQVRFKTtcblxuXHRcdFx0XHRcdHBvaW50Q29uZmlnLnB1c2goaXRlbS5nZXRMYWJlbENvbmZpZygpKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGV4dENvbmZpZyA9IHtcblx0XHRcdFx0XHR4OiBwb2ludFswXS5jYXRlZ29yeSxcblx0XHRcdFx0XHR5OiBwb2ludFswXS55XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRleHRDb25maWcucG9pbnRzID0gcG9pbnRDb25maWc7XG5cdFx0XHRcdHRoaXMubGVuID0gcG9pbnRDb25maWcubGVuZ3RoO1xuXHRcdFx0XHRwb2ludCA9IHBvaW50WzBdO1xuXG5cdFx0XHQvLyBzaW5nbGUgcG9pbnQgdG9vbHRpcFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGV4dENvbmZpZyA9IHBvaW50LmdldExhYmVsQ29uZmlnKCk7XG5cdFx0XHR9XG5cdFx0XHR0ZXh0ID0gZm9ybWF0dGVyLmNhbGwodGV4dENvbmZpZywgdG9vbHRpcCk7XG5cblx0XHRcdC8vIHJlZ2lzdGVyIHRoZSBjdXJyZW50IHNlcmllc1xuXHRcdFx0Y3VycmVudFNlcmllcyA9IHBvaW50LnNlcmllcztcblx0XHRcdHRoaXMuZGlzdGFuY2UgPSBwaWNrKGN1cnJlbnRTZXJpZXMudG9vbHRpcE9wdGlvbnMuZGlzdGFuY2UsIDE2KTtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBpbm5lciBIVE1MXG5cdFx0XHRpZiAodGV4dCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHNob3cgaXRcblx0XHRcdFx0aWYgKHRvb2x0aXAuaXNIaWRkZW4pIHtcblx0XHRcdFx0XHRzdG9wKGxhYmVsKTtcblx0XHRcdFx0XHRsYWJlbC5hdHRyKCdvcGFjaXR5JywgMSkuc2hvdygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHRleHRcblx0XHRcdFx0bGFiZWwuYXR0cih7XG5cdFx0XHRcdFx0dGV4dDogdGV4dFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBzZXQgdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgYm94XG5cdFx0XHRcdGJvcmRlckNvbG9yID0gb3B0aW9ucy5ib3JkZXJDb2xvciB8fCBwb2ludC5jb2xvciB8fCBjdXJyZW50U2VyaWVzLmNvbG9yIHx8ICcjNjA2MDYwJztcblx0XHRcdFx0bGFiZWwuYXR0cih7XG5cdFx0XHRcdFx0c3Ryb2tlOiBib3JkZXJDb2xvclxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dG9vbHRpcC51cGRhdGVQb3NpdGlvbih7IFxuXHRcdFx0XHRcdHBsb3RYOiB4LCBcblx0XHRcdFx0XHRwbG90WTogeSwgXG5cdFx0XHRcdFx0bmVnYXRpdmU6IHBvaW50Lm5lZ2F0aXZlLCBcblx0XHRcdFx0XHR0dEJlbG93OiBwb2ludC50dEJlbG93LCBcblx0XHRcdFx0XHRoOiAocG9pbnQuc2hhcGVBcmdzICYmIHBvaW50LnNoYXBlQXJncy5oZWlnaHQpIHx8IDBcblx0XHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdFx0dGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAndG9vbHRpcFJlZnJlc2gnLCB7XG5cdFx0XHRcdFx0dGV4dDogdGV4dCxcblx0XHRcdFx0XHR4OiB4ICsgY2hhcnQucGxvdExlZnQsXG5cdFx0XHRcdFx0eTogeSArIGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IGJvcmRlckNvbG9yXG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRmluZCB0aGUgbmV3IHBvc2l0aW9uIGFuZCBwZXJmb3JtIHRoZSBtb3ZlXG5cdFx0ICovXG5cdFx0dXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0bGFiZWwgPSB0aGlzLmxhYmVsLCBcblx0XHRcdFx0cG9zID0gKHRoaXMub3B0aW9ucy5wb3NpdGlvbmVyIHx8IHRoaXMuZ2V0UG9zaXRpb24pLmNhbGwoXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRsYWJlbC53aWR0aCxcblx0XHRcdFx0XHRsYWJlbC5oZWlnaHQsXG5cdFx0XHRcdFx0cG9pbnRcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gZG8gdGhlIG1vdmVcblx0XHRcdHRoaXMubW92ZShcblx0XHRcdFx0bWF0aFJvdW5kKHBvcy54KSwgXG5cdFx0XHRcdG1hdGhSb3VuZChwb3MueSksIFxuXHRcdFx0XHRwb2ludC5wbG90WCArIGNoYXJ0LnBsb3RMZWZ0LCBcblx0XHRcdFx0cG9pbnQucGxvdFkgKyBjaGFydC5wbG90VG9wXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvKiogXG5cdFx0ICogR2V0IHRoZSBiZXN0IFggZGF0ZSBmb3JtYXQgYmFzZWQgb24gdGhlIGNsb3Nlc3QgcG9pbnQgcmFuZ2Ugb24gdGhlIGF4aXMuXG5cdFx0ICovXG5cdFx0Z2V0WERhdGVGb3JtYXQ6IGZ1bmN0aW9uIChwb2ludCwgb3B0aW9ucywgeEF4aXMpIHtcblx0XHRcdHZhciB4RGF0ZUZvcm1hdCxcblx0XHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdHMgPSBvcHRpb25zLmRhdGVUaW1lTGFiZWxGb3JtYXRzLFxuXHRcdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSA9IHhBeGlzICYmIHhBeGlzLmNsb3Nlc3RQb2ludFJhbmdlLFxuXHRcdFx0XHRuLFxuXHRcdFx0XHRibGFuayA9ICcwMS0wMSAwMDowMDowMC4wMDAnLFxuXHRcdFx0XHRzdHJwb3MgPSB7XG5cdFx0XHRcdFx0bWlsbGlzZWNvbmQ6IDE1LFxuXHRcdFx0XHRcdHNlY29uZDogMTIsXG5cdFx0XHRcdFx0bWludXRlOiA5LFxuXHRcdFx0XHRcdGhvdXI6IDYsXG5cdFx0XHRcdFx0ZGF5OiAzXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRhdGUsXG5cdFx0XHRcdGxhc3ROO1xuXG5cdFx0XHRpZiAoY2xvc2VzdFBvaW50UmFuZ2UpIHtcblx0XHRcdFx0ZGF0ZSA9IGRhdGVGb3JtYXQoJyVtLSVkICVIOiVNOiVTLiVMJywgcG9pbnQueCk7XG5cdFx0XHRcdGZvciAobiBpbiB0aW1lVW5pdHMpIHtcblxuXHRcdFx0XHRcdC8vIElmIHRoZSByYW5nZSBpcyBleGFjdGx5IG9uZSB3ZWVrIGFuZCB3ZSdyZSBsb29raW5nIGF0IGEgU3VuZGF5L01vbmRheSwgZ28gZm9yIHRoZSB3ZWVrIGZvcm1hdFxuXHRcdFx0XHRcdGlmIChjbG9zZXN0UG9pbnRSYW5nZSA9PT0gdGltZVVuaXRzLndlZWsgJiYgK2RhdGVGb3JtYXQoJyV3JywgcG9pbnQueCkgPT09IHhBeGlzLm9wdGlvbnMuc3RhcnRPZldlZWsgJiYgXG5cdFx0XHRcdFx0XHRcdGRhdGUuc3Vic3RyKDYpID09PSBibGFuay5zdWJzdHIoNikpIHtcblx0XHRcdFx0XHRcdG4gPSAnd2Vlayc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdC8vIFRoZSBmaXJzdCBmb3JtYXQgdGhhdCBpcyB0b28gZ3JlYXQgZm9yIHRoZSByYW5nZVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGltZVVuaXRzW25dID4gY2xvc2VzdFBvaW50UmFuZ2UpIHtcblx0XHRcdFx0XHRcdG4gPSBsYXN0Tjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIElmIHRoZSBwb2ludCBpcyBwbGFjZWQgZXZlcnkgZGF5IGF0IDIzOjU5LCB3ZSBuZWVkIHRvIHNob3dcblx0XHRcdFx0XHQvLyB0aGUgbWludXRlcyBhcyB3ZWxsLiAjMjYzNy5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0cnBvc1tuXSAmJiBkYXRlLnN1YnN0cihzdHJwb3Nbbl0pICE9PSBibGFuay5zdWJzdHIoc3RycG9zW25dKSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV2Vla3MgYXJlIG91dHNpZGUgdGhlIGhpZXJhcmNoeSwgb25seSBhcHBseSB0aGVtIG9uIE1vbmRheXMvU3VuZGF5cyBsaWtlIGluIHRoZSBmaXJzdCBjb25kaXRpb25cblx0XHRcdFx0XHRpZiAobiAhPT0gJ3dlZWsnKSB7XG5cdFx0XHRcdFx0XHRsYXN0TiA9IG47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobikge1xuXHRcdFx0XHRcdHhEYXRlRm9ybWF0ID0gZGF0ZVRpbWVMYWJlbEZvcm1hdHNbbl07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHhEYXRlRm9ybWF0ID0gZGF0ZVRpbWVMYWJlbEZvcm1hdHMuZGF5O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geERhdGVGb3JtYXQgfHwgZGF0ZVRpbWVMYWJlbEZvcm1hdHMueWVhcjsgLy8gIzI1NDYsIDI1ODFcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0IHRoZSBmb290ZXIvaGVhZGVyIG9mIHRoZSB0b29sdGlwXG5cdFx0ICogIzMzOTc6IGFic3RyYWN0aW9uIHRvIGVuYWJsZSBmb3JtYXR0aW5nIG9mIGZvb3RlciBhbmQgaGVhZGVyXG5cdFx0ICovXG5cdFx0dG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcjogZnVuY3Rpb24gKHBvaW50LCBpc0Zvb3Rlcikge1xuXHRcdFx0dmFyIGZvb3RPckhlYWQgPSBpc0Zvb3RlciA/ICdmb290ZXInIDogJ2hlYWRlcicsXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0dG9vbHRpcE9wdGlvbnMgPSBzZXJpZXMudG9vbHRpcE9wdGlvbnMsXG5cdFx0XHRcdHhEYXRlRm9ybWF0ID0gdG9vbHRpcE9wdGlvbnMueERhdGVGb3JtYXQsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHRpc0RhdGVUaW1lID0geEF4aXMgJiYgeEF4aXMub3B0aW9ucy50eXBlID09PSAnZGF0ZXRpbWUnICYmIGlzTnVtYmVyKHBvaW50LmtleSksXG5cdFx0XHRcdGZvcm1hdFN0cmluZyA9IHRvb2x0aXBPcHRpb25zW2Zvb3RPckhlYWQrJ0Zvcm1hdCddO1xuXG5cdFx0XHQvLyBHdWVzcyB0aGUgYmVzdCBkYXRlIGZvcm1hdCBiYXNlZCBvbiB0aGUgY2xvc2VzdCBwb2ludCBkaXN0YW5jZSAoIzU2OCwgIzM0MTgpXG5cdFx0XHRpZiAoaXNEYXRlVGltZSAmJiAheERhdGVGb3JtYXQpIHtcblx0XHRcdFx0eERhdGVGb3JtYXQgPSB0aGlzLmdldFhEYXRlRm9ybWF0KHBvaW50LCB0b29sdGlwT3B0aW9ucywgeEF4aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnNlcnQgdGhlIGZvb3RlciBkYXRlIGZvcm1hdCBpZiBhbnlcblx0XHRcdGlmIChpc0RhdGVUaW1lICYmIHhEYXRlRm9ybWF0KSB7XG5cdFx0XHRcdGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKCd7cG9pbnQua2V5fScsICd7cG9pbnQua2V5OicgKyB4RGF0ZUZvcm1hdCArICd9Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmb3JtYXQoZm9ybWF0U3RyaW5nLCB7XG5cdFx0XHRcdHBvaW50OiBwb2ludCxcblx0XHRcdFx0c2VyaWVzOiBzZXJpZXNcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0ICAgICAqIEJ1aWxkIHRoZSBib2R5IChsaW5lcykgb2YgdGhlIHRvb2x0aXAgYnkgaXRlcmF0aW5nIG92ZXIgdGhlIGl0ZW1zIGFuZCByZXR1cm5pbmcgb25lIGVudHJ5IGZvciBlYWNoIGl0ZW0sXG5cdCAgICAgKiBhYnN0cmFjdGluZyB0aGlzIGZ1bmN0aW9uYWxpdHkgYWxsb3dzIHRvIGVhc2lseSBvdmVyd3JpdGUgYW5kIGV4dGVuZCBpdC4gXG5cdFx0ICovXG5cdFx0Ym9keUZvcm1hdHRlcjogZnVuY3Rpb24gKGl0ZW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIG1hcChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICAgICAgdmFyIHRvb2x0aXBPcHRpb25zID0gaXRlbS5zZXJpZXMudG9vbHRpcE9wdGlvbnM7XG5cdCAgICAgICAgICAgIHJldHVybiAodG9vbHRpcE9wdGlvbnMucG9pbnRGb3JtYXR0ZXIgfHwgaXRlbS5wb2ludC50b29sdGlwRm9ybWF0dGVyKS5jYWxsKGl0ZW0ucG9pbnQsIHRvb2x0aXBPcHRpb25zLnBvaW50Rm9ybWF0KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIFxuXHR9O1xuXG5cdHZhciBob3ZlckNoYXJ0SW5kZXg7XG5cblx0Ly8gR2xvYmFsIGZsYWcgZm9yIHRvdWNoIHN1cHBvcnRcblx0aGFzVG91Y2ggPSBkb2MuZG9jdW1lbnRFbGVtZW50Lm9udG91Y2hzdGFydCAhPT0gVU5ERUZJTkVEO1xuXG5cdC8qKlxuXHQgKiBUaGUgbW91c2UgdHJhY2tlciBvYmplY3QuIEFsbCBtZXRob2RzIHN0YXJ0aW5nIHdpdGggXCJvblwiIGFyZSBwcmltYXJ5IERPTSBldmVudCBoYW5kbGVycy4gXG5cdCAqIFN1YnNlcXVlbnQgbWV0aG9kcyBzaG91bGQgYmUgbmFtZWQgZGlmZmVyZW50bHkgZnJvbSB3aGF0IHRoZXkgYXJlIGRvaW5nLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY2hhcnQgVGhlIENoYXJ0IGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSByb290IG9wdGlvbnMgb2JqZWN0XG5cdCAqL1xuXHR2YXIgUG9pbnRlciA9IEhpZ2hjaGFydHMuUG9pbnRlciA9IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdHRoaXMuaW5pdChjaGFydCwgb3B0aW9ucyk7XG5cdH07XG5cblx0UG9pbnRlci5wcm90b3R5cGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSBQb2ludGVyXG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0XHRcblx0XHRcdHZhciBjaGFydE9wdGlvbnMgPSBvcHRpb25zLmNoYXJ0LFxuXHRcdFx0XHRjaGFydEV2ZW50cyA9IGNoYXJ0T3B0aW9ucy5ldmVudHMsXG5cdFx0XHRcdHpvb21UeXBlID0gdXNlQ2FuVkcgPyAnJyA6IGNoYXJ0T3B0aW9ucy56b29tVHlwZSxcblx0XHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0em9vbVgsXG5cdFx0XHRcdHpvb21ZO1xuXG5cdFx0XHQvLyBTdG9yZSByZWZlcmVuY2VzXG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0dGhpcy5jaGFydCA9IGNoYXJ0O1xuXHRcdFx0XG5cdFx0XHQvLyBab29tIHN0YXR1c1xuXHRcdFx0dGhpcy56b29tWCA9IHpvb21YID0gL3gvLnRlc3Qoem9vbVR5cGUpO1xuXHRcdFx0dGhpcy56b29tWSA9IHpvb21ZID0gL3kvLnRlc3Qoem9vbVR5cGUpO1xuXHRcdFx0dGhpcy56b29tSG9yID0gKHpvb21YICYmICFpbnZlcnRlZCkgfHwgKHpvb21ZICYmIGludmVydGVkKTtcblx0XHRcdHRoaXMuem9vbVZlcnQgPSAoem9vbVkgJiYgIWludmVydGVkKSB8fCAoem9vbVggJiYgaW52ZXJ0ZWQpO1xuXHRcdFx0dGhpcy5oYXNab29tID0gem9vbVggfHwgem9vbVk7XG5cblx0XHRcdC8vIERvIHdlIG5lZWQgdG8gaGFuZGxlIGNsaWNrIG9uIGEgdG91Y2ggZGV2aWNlP1xuXHRcdFx0dGhpcy5ydW5DaGFydENsaWNrID0gY2hhcnRFdmVudHMgJiYgISFjaGFydEV2ZW50cy5jbGljaztcblxuXHRcdFx0dGhpcy5waW5jaERvd24gPSBbXTtcblx0XHRcdHRoaXMubGFzdFZhbGlkVG91Y2ggPSB7fTtcblxuXHRcdFx0aWYgKEhpZ2hjaGFydHMuVG9vbHRpcCAmJiBvcHRpb25zLnRvb2x0aXAuZW5hYmxlZCkge1xuXHRcdFx0XHRjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoY2hhcnQsIG9wdGlvbnMudG9vbHRpcCk7XG5cdFx0XHRcdHRoaXMuZm9sbG93VG91Y2hNb3ZlID0gcGljayhvcHRpb25zLnRvb2x0aXAuZm9sbG93VG91Y2hNb3ZlLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRET01FdmVudHMoKTtcblx0XHR9LCBcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCBjcm9zc2Jyb3dzZXIgc3VwcG9ydCBmb3IgY2hhcnRYIGFuZCBjaGFydFlcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgb2JqZWN0IGluIHN0YW5kYXJkIGJyb3dzZXJzXG5cdFx0ICovXG5cdFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoZSwgY2hhcnRQb3NpdGlvbikge1xuXHRcdFx0dmFyIGNoYXJ0WCxcblx0XHRcdFx0Y2hhcnRZLFxuXHRcdFx0XHRlUG9zO1xuXG5cdFx0XHQvLyBjb21tb24gSUUgbm9ybWFsaXppbmdcblx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuXHRcdFx0Ly8gRnJhbWV3b3JrIHNwZWNpZmljIG5vcm1hbGl6aW5nICgjMTE2NSlcblx0XHRcdGUgPSB3YXNoTW91c2VFdmVudChlKTtcblxuXHRcdFx0Ly8gTW9yZSBJRSBub3JtYWxpemluZywgbmVlZHMgdG8gZ28gYWZ0ZXIgd2FzaE1vdXNlRXZlbnRcblx0XHRcdGlmICghZS50YXJnZXQpIHtcblx0XHRcdFx0ZS50YXJnZXQgPSBlLnNyY0VsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGlPUyAoIzI3NTcpXG5cdFx0XHRlUG9zID0gZS50b3VjaGVzID8gIChlLnRvdWNoZXMubGVuZ3RoID8gZS50b3VjaGVzLml0ZW0oMCkgOiBlLmNoYW5nZWRUb3VjaGVzWzBdKSA6IGU7XG5cblx0XHRcdC8vIEdldCBtb3VzZSBwb3NpdGlvblxuXHRcdFx0aWYgKCFjaGFydFBvc2l0aW9uKSB7XG5cdFx0XHRcdHRoaXMuY2hhcnRQb3NpdGlvbiA9IGNoYXJ0UG9zaXRpb24gPSBvZmZzZXQodGhpcy5jaGFydC5jb250YWluZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGFydFggYW5kIGNoYXJ0WVxuXHRcdFx0aWYgKGVQb3MucGFnZVggPT09IFVOREVGSU5FRCkgeyAvLyBJRSA8IDkuICM4ODYuXG5cdFx0XHRcdGNoYXJ0WCA9IG1hdGhNYXgoZS54LCBlLmNsaWVudFggLSBjaGFydFBvc2l0aW9uLmxlZnQpOyAvLyAjMjAwNSwgIzIxMjk6IHRoZSBzZWNvbmQgY2FzZSBpcyBcblx0XHRcdFx0XHQvLyBmb3IgSUUxMCBxdWlya3MgbW9kZSB3aXRoaW4gZnJhbWVzZXRzXG5cdFx0XHRcdGNoYXJ0WSA9IGUueTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoYXJ0WCA9IGVQb3MucGFnZVggLSBjaGFydFBvc2l0aW9uLmxlZnQ7XG5cdFx0XHRcdGNoYXJ0WSA9IGVQb3MucGFnZVkgLSBjaGFydFBvc2l0aW9uLnRvcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4dGVuZChlLCB7XG5cdFx0XHRcdGNoYXJ0WDogbWF0aFJvdW5kKGNoYXJ0WCksXG5cdFx0XHRcdGNoYXJ0WTogbWF0aFJvdW5kKGNoYXJ0WSlcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGNsaWNrIHBvc2l0aW9uIGluIHRlcm1zIG9mIGF4aXMgdmFsdWVzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGUgQSBwb2ludGVyIGV2ZW50XG5cdFx0ICovXG5cdFx0Z2V0Q29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgY29vcmRpbmF0ZXMgPSB7XG5cdFx0XHRcdFx0eEF4aXM6IFtdLFxuXHRcdFx0XHRcdHlBeGlzOiBbXVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRlYWNoKHRoaXMuY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0Y29vcmRpbmF0ZXNbYXhpcy5pc1hBeGlzID8gJ3hBeGlzJyA6ICd5QXhpcyddLnB1c2goe1xuXHRcdFx0XHRcdGF4aXM6IGF4aXMsXG5cdFx0XHRcdFx0dmFsdWU6IGF4aXMudG9WYWx1ZShlW2F4aXMuaG9yaXogPyAnY2hhcnRYJyA6ICdjaGFydFknXSlcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBjb29yZGluYXRlcztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFdpdGggbGluZSB0eXBlIGNoYXJ0cyB3aXRoIGEgc2luZ2xlIHRyYWNrZXIsIGdldCB0aGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgbW91c2UuXG5cdFx0ICogUnVuIFBvaW50Lm9uTW91c2VPdmVyIGFuZCBkaXNwbGF5IHRvb2x0aXAgZm9yIHRoZSBwb2ludCBvciBwb2ludHMuXG5cdFx0ICovXG5cdFx0cnVuUG9pbnRBY3Rpb25zOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHR2YXIgcG9pbnRlciA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gcG9pbnRlci5jaGFydCxcblx0XHRcdFx0c2VyaWVzID0gY2hhcnQuc2VyaWVzLFxuXHRcdFx0XHR0b29sdGlwID0gY2hhcnQudG9vbHRpcCxcblx0XHRcdFx0c2hhcmVkID0gdG9vbHRpcCA/IHRvb2x0aXAuc2hhcmVkIDogZmFsc2UsXG5cdFx0XHRcdGZvbGxvd1BvaW50ZXIsXG5cdFx0XHRcdC8vcG9pbnQsXG5cdFx0XHRcdC8vcG9pbnRzLFxuXHRcdFx0XHRob3ZlclBvaW50ID0gY2hhcnQuaG92ZXJQb2ludCxcblx0XHRcdFx0aG92ZXJTZXJpZXMgPSBjaGFydC5ob3ZlclNlcmllcyxcblx0XHRcdFx0aSxcblx0XHRcdFx0Ly9qLFxuXHRcdFx0XHRkaXN0YW5jZSA9IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRcdHJkaXN0YW5jZSA9IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRcdGFuY2hvcixcblx0XHRcdFx0bm9TaGFyZWRUb29sdGlwLFxuXHRcdFx0XHRrZHBvaW50cyA9IFtdLFxuXHRcdFx0XHRrZHBvaW50LFxuXHRcdFx0XHRrZHBvaW50VDtcblxuXHRcdFx0Ly8gRm9yIGhvdmVyaW5nIG92ZXIgdGhlIGVtcHR5IHBhcnRzIG9mIHRoZSBwbG90IGFyZWEgKGhvdmVyU2VyaWVzIGlzIHVuZGVmaW5lZCkuIFxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgb25lIHNlcmllcyB3aXRoIHBvaW50IHRyYWNraW5nIChjb21ibyBjaGFydCksIGRvbid0IGdvIHRvIG5lYXJlc3QgbmVpZ2hib3VyLlxuXHRcdFx0aWYgKCFzaGFyZWQgJiYgIWhvdmVyU2VyaWVzKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoc2VyaWVzW2ldLmRpcmVjdFRvdWNoIHx8ICFzZXJpZXNbaV0ub3B0aW9ucy5zdGlja3lUcmFja2luZykge1xuXHRcdFx0XHRcdFx0c2VyaWVzID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBzaGFyZWQgdG9vbHRpcCBvciBjYXNlcyB3aGVyZSBhIHNlcmllcyBpcyBub3QgeWV0IGhvdmVyZWRcblx0XHRcdGlmICghKGhvdmVyU2VyaWVzICYmIGhvdmVyU2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkgJiYgKHNoYXJlZCB8fCAhaG92ZXJTZXJpZXMpKSB7IC8vICMzODIxIFxuXHRcdFx0XHQvLyBGaW5kIG5lYXJlc3QgcG9pbnRzIG9uIGFsbCBzZXJpZXNcblx0XHRcdFx0ZWFjaChzZXJpZXMsIGZ1bmN0aW9uIChzKSB7XG5cdFx0XHRcdFx0Ly8gU2tpcCBoaWRkZW4gc2VyaWVzXG5cdFx0XHRcdFx0bm9TaGFyZWRUb29sdGlwID0gcy5ub1NoYXJlZFRvb2x0aXAgJiYgc2hhcmVkO1xuXHRcdFx0XHRcdGlmIChzLnZpc2libGUgJiYgIW5vU2hhcmVkVG9vbHRpcCAmJiBwaWNrKHMub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nLCB0cnVlKSkgeyAvLyAjMzgyMVxuXHRcdFx0XHRcdFx0a2Rwb2ludFQgPSBzLnNlYXJjaFBvaW50KGUpOyAvLyAjMzgyOFxuXHRcdFx0XHRcdFx0aWYgKGtkcG9pbnRUKSB7XG5cdFx0XHRcdFx0XHRcdGtkcG9pbnRzLnB1c2goa2Rwb2ludFQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIEZpbmQgYWJzb2x1dGUgbmVhcmVzdCBwb2ludFxuXHRcdFx0XHRlYWNoKGtkcG9pbnRzLCBmdW5jdGlvbiAocCkge1xuXHRcdFx0XHRcdGlmIChwICYmIGRlZmluZWQocC5wbG90WCkgJiYgZGVmaW5lZChwLnBsb3RZKSkge1xuXHRcdFx0XHRcdFx0aWYgKChwLmRpc3QuZGlzdFggPCBkaXN0YW5jZSkgfHwgKChwLmRpc3QuZGlzdFggPT09IGRpc3RhbmNlIHx8IHAuc2VyaWVzLmtkRGltZW5zaW9ucyA+IDEpICYmIHAuZGlzdC5kaXN0UiA8IHJkaXN0YW5jZSkpIHtcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2UgPSBwLmRpc3QuZGlzdFg7XG5cdFx0XHRcdFx0XHRcdHJkaXN0YW5jZSA9IHAuZGlzdC5kaXN0Ujtcblx0XHRcdFx0XHRcdFx0a2Rwb2ludCA9IHA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcdFxuXG5cdFx0XHQvLyBIYW5kbGUgbm9uLXNoYXJlZCB0b29sdGlwc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgaXQgaGFzIGEgaG92ZXJQb2ludCBhbmQgdGhhdCBzZXJpZXMgcmVxdWlyZXMgZGlyZWN0IHRvdWNoIChsaWtlIGNvbHVtbnMpLCB1c2UgdGhlIGhvdmVyUG9pbnQgKCMzODk5KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBzZWFyY2ggdGhlIGstZCB0cmVlIChsaWtlIHNjYXR0ZXIpLlxuXHRcdFx0XHRrZHBvaW50ID0gKGhvdmVyU2VyaWVzLmRpcmVjdFRvdWNoICYmIGhvdmVyUG9pbnQpIHx8IChob3ZlclNlcmllcyAmJiBob3ZlclNlcmllcy5zZWFyY2hQb2ludChlKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlZnJlc2ggdG9vbHRpcCBmb3Iga2Rwb2ludCBpZiBuZXcgaG92ZXIgcG9pbnQgb3IgdG9vbHRpcCB3YXMgaGlkZGVuIC8vICMzOTI2XG5cdFx0XHRpZiAoa2Rwb2ludCAmJiAoa2Rwb2ludCAhPT0gaG92ZXJQb2ludCB8fCAodG9vbHRpcCAmJiB0b29sdGlwLmlzSGlkZGVuKSkpIHtcblx0XHRcdFx0Ly8gRHJhdyB0b29sdGlwIGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRpZiAoc2hhcmVkICYmICFrZHBvaW50LnNlcmllcy5ub1NoYXJlZFRvb2x0aXApIHtcblx0XHRcdFx0XHRpID0ga2Rwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdGlmIChrZHBvaW50c1tpXS5jbGllbnRYICE9PSBrZHBvaW50LmNsaWVudFggfHwgKGtkcG9pbnRzW2ldLnNlcmllcy5ub1NoYXJlZFRvb2x0aXAgfHwgZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHRcdGtkcG9pbnRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGtkcG9pbnRzLmxlbmd0aCAmJiB0b29sdGlwKSB7XG5cdFx0XHRcdFx0XHR0b29sdGlwLnJlZnJlc2goa2Rwb2ludHMsIGUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGRvIG1vdXNlb3ZlciBvbiBhbGwgcG9pbnRzIGV4Y2VwdCB0aGUgY2xvc2VzdFxuXHRcdFx0XHRcdGVhY2goa2Rwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdFx0aWYgKHBvaW50ICE9PSBrZHBvaW50KSB7IFxuXHRcdFx0XHRcdFx0XHRwb2ludC5vbk1vdXNlT3ZlcihlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcdFx0XHRcdFxuXHRcdFx0XHRcdGtkcG9pbnQub25Nb3VzZU92ZXIoZSk7IC8vICMzOTE5IGRvIG1vdXNlb3ZlciBvbiB0aGUgY2xvc2VzdCBwb2ludCBsYXN0IHRvIGVuc3VyZSBpdCBpcyB0aGUgaG92ZXJwb2ludFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0b29sdGlwKSB7IFxuXHRcdFx0XHRcdFx0dG9vbHRpcC5yZWZyZXNoKGtkcG9pbnQsIGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRrZHBvaW50Lm9uTW91c2VPdmVyKGUpOyBcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBVcGRhdGUgcG9zaXRpb25zIChyZWdhcmRsZXNzIG9mIGtkcG9pbnQgb3IgaG92ZXJQb2ludClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvbGxvd1BvaW50ZXIgPSBob3ZlclNlcmllcyAmJiBob3ZlclNlcmllcy50b29sdGlwT3B0aW9ucy5mb2xsb3dQb2ludGVyO1xuXHRcdFx0XHRpZiAodG9vbHRpcCAmJiBmb2xsb3dQb2ludGVyICYmICF0b29sdGlwLmlzSGlkZGVuKSB7XG5cdFx0XHRcdFx0YW5jaG9yID0gdG9vbHRpcC5nZXRBbmNob3IoW3t9XSwgZSk7XG5cdFx0XHRcdFx0dG9vbHRpcC51cGRhdGVQb3NpdGlvbih7IHBsb3RYOiBhbmNob3JbMF0sIHBsb3RZOiBhbmNob3JbMV0gfSk7XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIHBpY2sgdXAgdGhlIHRvb2x0aXAgXG5cdFx0XHRpZiAodG9vbHRpcCAmJiAhcG9pbnRlci5fb25Eb2N1bWVudE1vdXNlTW92ZSkge1xuXHRcdFx0XHRwb2ludGVyLl9vbkRvY3VtZW50TW91c2VNb3ZlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZiAoY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0pIHtcblx0XHRcdFx0XHRcdGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXIub25Eb2N1bWVudE1vdXNlTW92ZShlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGFkZEV2ZW50KGRvYywgJ21vdXNlbW92ZScsIHBvaW50ZXIuX29uRG9jdW1lbnRNb3VzZU1vdmUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBDcm9zc2hhaXJcblx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0YXhpcy5kcmF3Q3Jvc3NoYWlyKGUsIHBpY2soa2Rwb2ludCwgaG92ZXJQb2ludCkpO1xuXHRcdFx0fSk7XHRcblx0XHRcdFx0XHRcblx0XHR9LFxuXG5cblxuXHRcdC8qKlxuXHRcdCAqIFJlc2V0IHRoZSB0cmFja2luZyBieSBoaWRpbmcgdGhlIHRvb2x0aXAsIHRoZSBob3ZlciBzZXJpZXMgc3RhdGUgYW5kIHRoZSBob3ZlciBwb2ludFxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSBhbGxvd01vdmUge0Jvb2xlYW59IEluc3RlYWQgb2YgZGVzdHJveWluZyB0aGUgdG9vbHRpcCBhbHRvZ2V0aGVyLCBhbGxvdyBtb3ZpbmcgaXQgaWYgcG9zc2libGVcblx0XHQgKi9cblx0XHRyZXNldDogZnVuY3Rpb24gKGFsbG93TW92ZSwgZGVsYXkpIHtcblx0XHRcdHZhciBwb2ludGVyID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBwb2ludGVyLmNoYXJ0LFxuXHRcdFx0XHRob3ZlclNlcmllcyA9IGNoYXJ0LmhvdmVyU2VyaWVzLFxuXHRcdFx0XHRob3ZlclBvaW50ID0gY2hhcnQuaG92ZXJQb2ludCxcblx0XHRcdFx0dG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXAsXG5cdFx0XHRcdHRvb2x0aXBQb2ludHMgPSB0b29sdGlwICYmIHRvb2x0aXAuc2hhcmVkID8gY2hhcnQuaG92ZXJQb2ludHMgOiBob3ZlclBvaW50O1xuXHRcdFx0XHRcblx0XHRcdC8vIE5hcnJvdyBpbiBhbGxvd01vdmVcblx0XHRcdGFsbG93TW92ZSA9IGFsbG93TW92ZSAmJiB0b29sdGlwICYmIHRvb2x0aXBQb2ludHM7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIHBvaW50cyBoYXZlIG1vdmVkIG91dHNpZGUgdGhlIHBsb3QgYXJlYSwgIzEwMDNcdFx0XG5cdFx0XHRpZiAoYWxsb3dNb3ZlICAmJiBzcGxhdCh0b29sdGlwUG9pbnRzKVswXS5wbG90WCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdGFsbG93TW92ZSA9IGZhbHNlO1xuXHRcdFx0fVx0XG5cdFx0XHQvLyBKdXN0IG1vdmUgdGhlIHRvb2x0aXAsICMzNDlcblx0XHRcdGlmIChhbGxvd01vdmUpIHtcblx0XHRcdFx0dG9vbHRpcC5yZWZyZXNoKHRvb2x0aXBQb2ludHMpO1xuXHRcdFx0XHRpZiAoaG92ZXJQb2ludCkgeyAvLyAjMjUwMFxuXHRcdFx0XHRcdGhvdmVyUG9pbnQuc2V0U3RhdGUoaG92ZXJQb2ludC5zdGF0ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdFx0aWYgKHBpY2soYXhpcy5vcHRpb25zLmNyb3NzaGFpciAmJiBheGlzLm9wdGlvbnMuY3Jvc3NoYWlyLnNuYXAsIHRydWUpKSB7XG5cdFx0XHRcdFx0XHRcdGF4aXMuZHJhd0Nyb3NzaGFpcihudWxsLCBhbGxvd01vdmUpO1xuXHRcdFx0XHRcdFx0fSAgZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGF4aXMuaGlkZUNyb3NzaGFpcigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEZ1bGwgcmVzZXRcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKGhvdmVyUG9pbnQpIHtcblx0XHRcdFx0XHRob3ZlclBvaW50Lm9uTW91c2VPdXQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChob3ZlclNlcmllcykge1xuXHRcdFx0XHRcdGhvdmVyU2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHRcdFx0dG9vbHRpcC5oaWRlKGRlbGF5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwb2ludGVyLl9vbkRvY3VtZW50TW91c2VNb3ZlKSB7XG5cdFx0XHRcdFx0cmVtb3ZlRXZlbnQoZG9jLCAnbW91c2Vtb3ZlJywgcG9pbnRlci5fb25Eb2N1bWVudE1vdXNlTW92ZSk7XG5cdFx0XHRcdFx0cG9pbnRlci5fb25Eb2N1bWVudE1vdXNlTW92ZSA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZW1vdmUgY3Jvc3NoYWlyc1xuXHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0YXhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0cG9pbnRlci5ob3ZlclggPSBudWxsO1xuXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNjYWxlIHNlcmllcyBncm91cHMgdG8gYSBjZXJ0YWluIHNjYWxlIGFuZCB0cmFuc2xhdGlvblxuXHRcdCAqL1xuXHRcdHNjYWxlR3JvdXBzOiBmdW5jdGlvbiAoYXR0cmlicywgY2xpcCkge1xuXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRzZXJpZXNBdHRyaWJzO1xuXG5cdFx0XHQvLyBTY2FsZSBlYWNoIHNlcmllc1xuXHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0c2VyaWVzQXR0cmlicyA9IGF0dHJpYnMgfHwgc2VyaWVzLmdldFBsb3RCb3goKTsgLy8gIzE3MDFcblx0XHRcdFx0aWYgKHNlcmllcy54QXhpcyAmJiBzZXJpZXMueEF4aXMuem9vbUVuYWJsZWQpIHtcblx0XHRcdFx0XHRzZXJpZXMuZ3JvdXAuYXR0cihzZXJpZXNBdHRyaWJzKTtcblx0XHRcdFx0XHRpZiAoc2VyaWVzLm1hcmtlckdyb3VwKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMubWFya2VyR3JvdXAuYXR0cihzZXJpZXNBdHRyaWJzKTtcblx0XHRcdFx0XHRcdHNlcmllcy5tYXJrZXJHcm91cC5jbGlwKGNsaXAgPyBjaGFydC5jbGlwUmVjdCA6IG51bGwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VyaWVzLmRhdGFMYWJlbHNHcm91cCkge1xuXHRcdFx0XHRcdFx0c2VyaWVzLmRhdGFMYWJlbHNHcm91cC5hdHRyKHNlcmllc0F0dHJpYnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIENsaXBcblx0XHRcdGNoYXJ0LmNsaXBSZWN0LmF0dHIoY2xpcCB8fCBjaGFydC5jbGlwQm94KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU3RhcnQgYSBkcmFnIG9wZXJhdGlvblxuXHRcdCAqL1xuXHRcdGRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cblx0XHRcdC8vIFJlY29yZCB0aGUgc3RhcnQgcG9zaXRpb25cblx0XHRcdGNoYXJ0Lm1vdXNlSXNEb3duID0gZS50eXBlO1xuXHRcdFx0Y2hhcnQuY2FuY2VsQ2xpY2sgPSBmYWxzZTtcblx0XHRcdGNoYXJ0Lm1vdXNlRG93blggPSB0aGlzLm1vdXNlRG93blggPSBlLmNoYXJ0WDtcblx0XHRcdGNoYXJ0Lm1vdXNlRG93blkgPSB0aGlzLm1vdXNlRG93blkgPSBlLmNoYXJ0WTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUGVyZm9ybSBhIGRyYWcgb3BlcmF0aW9uIGluIHJlc3BvbnNlIHRvIGEgbW91c2Vtb3ZlIGV2ZW50IHdoaWxlIHRoZSBtb3VzZSBpcyBkb3duXG5cdFx0ICovXG5cdFx0ZHJhZzogZnVuY3Rpb24gKGUpIHtcblxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0Y2hhcnRPcHRpb25zID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0Y2hhcnRYID0gZS5jaGFydFgsXG5cdFx0XHRcdGNoYXJ0WSA9IGUuY2hhcnRZLFxuXHRcdFx0XHR6b29tSG9yID0gdGhpcy56b29tSG9yLFxuXHRcdFx0XHR6b29tVmVydCA9IHRoaXMuem9vbVZlcnQsXG5cdFx0XHRcdHBsb3RMZWZ0ID0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRcdHBsb3RUb3AgPSBjaGFydC5wbG90VG9wLFxuXHRcdFx0XHRwbG90V2lkdGggPSBjaGFydC5wbG90V2lkdGgsXG5cdFx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0LFxuXHRcdFx0XHRjbGlja2VkSW5zaWRlLFxuXHRcdFx0XHRzaXplLFxuXHRcdFx0XHRtb3VzZURvd25YID0gdGhpcy5tb3VzZURvd25YLFxuXHRcdFx0XHRtb3VzZURvd25ZID0gdGhpcy5tb3VzZURvd25ZLFxuXHRcdFx0XHRwYW5LZXkgPSBjaGFydE9wdGlvbnMucGFuS2V5ICYmIGVbY2hhcnRPcHRpb25zLnBhbktleSArICdLZXknXTtcblxuXHRcdFx0Ly8gSWYgdGhlIG1vdXNlIGlzIG91dHNpZGUgdGhlIHBsb3QgYXJlYSwgYWRqdXN0IHRvIGNvb29yZGluYXRlc1xuXHRcdFx0Ly8gaW5zaWRlIHRvIHByZXZlbnQgdGhlIHNlbGVjdGlvbiBtYXJrZXIgZnJvbSBnb2luZyBvdXRzaWRlXG5cdFx0XHRpZiAoY2hhcnRYIDwgcGxvdExlZnQpIHtcblx0XHRcdFx0Y2hhcnRYID0gcGxvdExlZnQ7XG5cdFx0XHR9IGVsc2UgaWYgKGNoYXJ0WCA+IHBsb3RMZWZ0ICsgcGxvdFdpZHRoKSB7XG5cdFx0XHRcdGNoYXJ0WCA9IHBsb3RMZWZ0ICsgcGxvdFdpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2hhcnRZIDwgcGxvdFRvcCkge1xuXHRcdFx0XHRjaGFydFkgPSBwbG90VG9wO1xuXHRcdFx0fSBlbHNlIGlmIChjaGFydFkgPiBwbG90VG9wICsgcGxvdEhlaWdodCkge1xuXHRcdFx0XHRjaGFydFkgPSBwbG90VG9wICsgcGxvdEhlaWdodDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gZGV0ZXJtaW5lIGlmIHRoZSBtb3VzZSBoYXMgbW92ZWQgbW9yZSB0aGFuIDEwcHhcblx0XHRcdHRoaXMuaGFzRHJhZ2dlZCA9IE1hdGguc3FydChcblx0XHRcdFx0TWF0aC5wb3cobW91c2VEb3duWCAtIGNoYXJ0WCwgMikgK1xuXHRcdFx0XHRNYXRoLnBvdyhtb3VzZURvd25ZIC0gY2hhcnRZLCAyKVxuXHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaGFzRHJhZ2dlZCA+IDEwKSB7XG5cdFx0XHRcdGNsaWNrZWRJbnNpZGUgPSBjaGFydC5pc0luc2lkZVBsb3QobW91c2VEb3duWCAtIHBsb3RMZWZ0LCBtb3VzZURvd25ZIC0gcGxvdFRvcCk7XG5cblx0XHRcdFx0Ly8gbWFrZSBhIHNlbGVjdGlvblxuXHRcdFx0XHRpZiAoY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzICYmICh0aGlzLnpvb21YIHx8IHRoaXMuem9vbVkpICYmIGNsaWNrZWRJbnNpZGUgJiYgIXBhbktleSkge1xuXHRcdFx0XHRcdGlmICghdGhpcy5zZWxlY3Rpb25NYXJrZXIpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0aW9uTWFya2VyID0gY2hhcnQucmVuZGVyZXIucmVjdChcblx0XHRcdFx0XHRcdFx0cGxvdExlZnQsXG5cdFx0XHRcdFx0XHRcdHBsb3RUb3AsXG5cdFx0XHRcdFx0XHRcdHpvb21Ib3IgPyAxIDogcGxvdFdpZHRoLFxuXHRcdFx0XHRcdFx0XHR6b29tVmVydCA/IDEgOiBwbG90SGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHQwXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdGZpbGw6IGNoYXJ0T3B0aW9ucy5zZWxlY3Rpb25NYXJrZXJGaWxsIHx8ICdyZ2JhKDY5LDExNCwxNjcsMC4yNSknLFxuXHRcdFx0XHRcdFx0XHR6SW5kZXg6IDdcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYWRqdXN0IHRoZSB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIG1hcmtlclxuXHRcdFx0XHRpZiAodGhpcy5zZWxlY3Rpb25NYXJrZXIgJiYgem9vbUhvcikge1xuXHRcdFx0XHRcdHNpemUgPSBjaGFydFggLSBtb3VzZURvd25YO1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0aW9uTWFya2VyLmF0dHIoe1xuXHRcdFx0XHRcdFx0d2lkdGg6IG1hdGhBYnMoc2l6ZSksXG5cdFx0XHRcdFx0XHR4OiAoc2l6ZSA+IDAgPyAwIDogc2l6ZSkgKyBtb3VzZURvd25YXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWRqdXN0IHRoZSBoZWlnaHQgb2YgdGhlIHNlbGVjdGlvbiBtYXJrZXJcblx0XHRcdFx0aWYgKHRoaXMuc2VsZWN0aW9uTWFya2VyICYmIHpvb21WZXJ0KSB7XG5cdFx0XHRcdFx0c2l6ZSA9IGNoYXJ0WSAtIG1vdXNlRG93blk7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3Rpb25NYXJrZXIuYXR0cih7XG5cdFx0XHRcdFx0XHRoZWlnaHQ6IG1hdGhBYnMoc2l6ZSksXG5cdFx0XHRcdFx0XHR5OiAoc2l6ZSA+IDAgPyAwIDogc2l6ZSkgKyBtb3VzZURvd25ZXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwYW5uaW5nXG5cdFx0XHRcdGlmIChjbGlja2VkSW5zaWRlICYmICF0aGlzLnNlbGVjdGlvbk1hcmtlciAmJiBjaGFydE9wdGlvbnMucGFubmluZykge1xuXHRcdFx0XHRcdGNoYXJ0LnBhbihlLCBjaGFydE9wdGlvbnMucGFubmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogT24gbW91c2UgdXAgb3IgdG91Y2ggZW5kIGFjcm9zcyB0aGUgZW50aXJlIGRvY3VtZW50LCBkcm9wIHRoZSBzZWxlY3Rpb24uXG5cdFx0ICovXG5cdFx0ZHJvcDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBwb2ludGVyID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRoYXNQaW5jaGVkID0gdGhpcy5oYXNQaW5jaGVkO1xuXG5cdFx0XHRpZiAodGhpcy5zZWxlY3Rpb25NYXJrZXIpIHtcblx0XHRcdFx0dmFyIHNlbGVjdGlvbkRhdGEgPSB7XG5cdFx0XHRcdFx0XHR4QXhpczogW10sXG5cdFx0XHRcdFx0XHR5QXhpczogW10sXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEV2ZW50OiBlLm9yaWdpbmFsRXZlbnQgfHwgZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c2VsZWN0aW9uQm94ID0gdGhpcy5zZWxlY3Rpb25NYXJrZXIsXG5cdFx0XHRcdFx0c2VsZWN0aW9uTGVmdCA9IHNlbGVjdGlvbkJveC5hdHRyID8gc2VsZWN0aW9uQm94LmF0dHIoJ3gnKSA6IHNlbGVjdGlvbkJveC54LFxuXHRcdFx0XHRcdHNlbGVjdGlvblRvcCA9IHNlbGVjdGlvbkJveC5hdHRyID8gc2VsZWN0aW9uQm94LmF0dHIoJ3knKSA6IHNlbGVjdGlvbkJveC55LFxuXHRcdFx0XHRcdHNlbGVjdGlvbldpZHRoID0gc2VsZWN0aW9uQm94LmF0dHIgPyBzZWxlY3Rpb25Cb3guYXR0cignd2lkdGgnKSA6IHNlbGVjdGlvbkJveC53aWR0aCxcblx0XHRcdFx0XHRzZWxlY3Rpb25IZWlnaHQgPSBzZWxlY3Rpb25Cb3guYXR0ciA/IHNlbGVjdGlvbkJveC5hdHRyKCdoZWlnaHQnKSA6IHNlbGVjdGlvbkJveC5oZWlnaHQsXG5cdFx0XHRcdFx0cnVuWm9vbTtcblxuXHRcdFx0XHQvLyBhIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlXG5cdFx0XHRcdGlmICh0aGlzLmhhc0RyYWdnZWQgfHwgaGFzUGluY2hlZCkge1xuXG5cdFx0XHRcdFx0Ly8gcmVjb3JkIGVhY2ggYXhpcycgbWluIGFuZCBtYXhcblx0XHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0XHRpZiAoYXhpcy56b29tRW5hYmxlZCAmJiBkZWZpbmVkKGF4aXMubWluKSAmJiAoaGFzUGluY2hlZCB8fCBwb2ludGVyW3sgeEF4aXM6ICd6b29tWCcsIHlBeGlzOiAnem9vbVknIH1bYXhpcy5jb2xsXV0pKSB7IC8vICM4NTksICMzNTY5XG5cdFx0XHRcdFx0XHRcdHZhciBob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdFx0XHRcdFx0bWluUGl4ZWxQYWRkaW5nID0gZS50eXBlID09PSAndG91Y2hlbmQnID8gYXhpcy5taW5QaXhlbFBhZGRpbmc6IDAsIC8vICMxMjA3LCAjMzA3NVxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdGlvbk1pbiA9IGF4aXMudG9WYWx1ZSgoaG9yaXogPyBzZWxlY3Rpb25MZWZ0IDogc2VsZWN0aW9uVG9wKSArIG1pblBpeGVsUGFkZGluZyksXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uTWF4ID0gYXhpcy50b1ZhbHVlKChob3JpeiA/IHNlbGVjdGlvbkxlZnQgKyBzZWxlY3Rpb25XaWR0aCA6IHNlbGVjdGlvblRvcCArIHNlbGVjdGlvbkhlaWdodCkgLSBtaW5QaXhlbFBhZGRpbmcpO1xuXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGFbYXhpcy5jb2xsXS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRheGlzOiBheGlzLFxuXHRcdFx0XHRcdFx0XHRcdG1pbjogbWF0aE1pbihzZWxlY3Rpb25NaW4sIHNlbGVjdGlvbk1heCksIC8vIGZvciByZXZlcnNlZCBheGVzXG5cdFx0XHRcdFx0XHRcdFx0bWF4OiBtYXRoTWF4KHNlbGVjdGlvbk1pbiwgc2VsZWN0aW9uTWF4KVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0cnVuWm9vbSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYgKHJ1blpvb20pIHtcblx0XHRcdFx0XHRcdGZpcmVFdmVudChjaGFydCwgJ3NlbGVjdGlvbicsIHNlbGVjdGlvbkRhdGEsIGZ1bmN0aW9uIChhcmdzKSB7IFxuXHRcdFx0XHRcdFx0XHRjaGFydC56b29tKGV4dGVuZChhcmdzLCBoYXNQaW5jaGVkID8geyBhbmltYXRpb246IGZhbHNlIH0gOiBudWxsKSk7IFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zZWxlY3Rpb25NYXJrZXIgPSB0aGlzLnNlbGVjdGlvbk1hcmtlci5kZXN0cm95KCk7XG5cblx0XHRcdFx0Ly8gUmVzZXQgc2NhbGluZyBwcmV2aWV3XG5cdFx0XHRcdGlmIChoYXNQaW5jaGVkKSB7XG5cdFx0XHRcdFx0dGhpcy5zY2FsZUdyb3VwcygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IGFsbFxuXHRcdFx0aWYgKGNoYXJ0KSB7IC8vIGl0IG1heSBiZSBkZXN0cm95ZWQgb24gbW91c2UgdXAgLSAjODc3XG5cdFx0XHRcdGNzcyhjaGFydC5jb250YWluZXIsIHsgY3Vyc29yOiBjaGFydC5fY3Vyc29yIH0pO1xuXHRcdFx0XHRjaGFydC5jYW5jZWxDbGljayA9IHRoaXMuaGFzRHJhZ2dlZCA+IDEwOyAvLyAjMzcwXG5cdFx0XHRcdGNoYXJ0Lm1vdXNlSXNEb3duID0gdGhpcy5oYXNEcmFnZ2VkID0gdGhpcy5oYXNQaW5jaGVkID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMucGluY2hEb3duID0gW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ29udGFpbmVyTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHRlID0gdGhpcy5ub3JtYWxpemUoZSk7XG5cblx0XHRcdC8vIGlzc3VlICMyOTUsIGRyYWdnaW5nIG5vdCBhbHdheXMgd29ya2luZyBpbiBGaXJlZm94XG5cdFx0XHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuZHJhZ1N0YXJ0KGUpO1xuXHRcdH0sXG5cblx0XHRcblxuXHRcdG9uRG9jdW1lbnRNb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdKSB7XG5cdFx0XHRcdGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXIuZHJvcChlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU3BlY2lhbCBoYW5kbGVyIGZvciBtb3VzZSBtb3ZlIHRoYXQgd2lsbCBoaWRlIHRoZSB0b29sdGlwIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgcGxvdGFyZWEuXG5cdFx0ICogSXNzdWUgIzE0OSB3b3JrYXJvdW5kLiBUaGUgbW91c2VsZWF2ZSBldmVudCBkb2VzIG5vdCBhbHdheXMgZmlyZS4gXG5cdFx0ICovXG5cdFx0b25Eb2N1bWVudE1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdGNoYXJ0UG9zaXRpb24gPSB0aGlzLmNoYXJ0UG9zaXRpb247XG5cblx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlLCBjaGFydFBvc2l0aW9uKTtcblxuXHRcdFx0Ly8gSWYgd2UncmUgb3V0c2lkZSwgaGlkZSB0aGUgdG9vbHRpcFxuXHRcdFx0aWYgKGNoYXJ0UG9zaXRpb24gJiYgIXRoaXMuaW5DbGFzcyhlLnRhcmdldCwgJ2hpZ2hjaGFydHMtdHJhY2tlcicpICYmXG5cdFx0XHRcdFx0IWNoYXJ0LmlzSW5zaWRlUGxvdChlLmNoYXJ0WCAtIGNoYXJ0LnBsb3RMZWZ0LCBlLmNoYXJ0WSAtIGNoYXJ0LnBsb3RUb3ApKSB7XG5cdFx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiBtb3VzZSBsZWF2ZXMgdGhlIGNvbnRhaW5lciwgaGlkZSB0aGUgdG9vbHRpcC5cblx0XHQgKi9cblx0XHRvbkNvbnRhaW5lck1vdXNlTGVhdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdO1xuXHRcdFx0aWYgKGNoYXJ0KSB7XG5cdFx0XHRcdGNoYXJ0LnBvaW50ZXIucmVzZXQoKTtcblx0XHRcdFx0Y2hhcnQucG9pbnRlci5jaGFydFBvc2l0aW9uID0gbnVsbDsgLy8gYWxzbyByZXNldCB0aGUgY2hhcnQgcG9zaXRpb24sIHVzZWQgaW4gIzE0OSBmaXhcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gVGhlIG1vdXNlbW92ZSwgdG91Y2htb3ZlIGFuZCB0b3VjaHN0YXJ0IGV2ZW50IGhhbmRsZXJcblx0XHRvbkNvbnRhaW5lck1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdFx0aG92ZXJDaGFydEluZGV4ID0gY2hhcnQuaW5kZXg7XG5cblx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcdFx0XG5cdFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7IC8vICMyMjUxLCAjMzIyNFxuXHRcdFx0XG5cdFx0XHRpZiAoY2hhcnQubW91c2VJc0Rvd24gPT09ICdtb3VzZWRvd24nKSB7XG5cdFx0XHRcdHRoaXMuZHJhZyhlKTtcblx0XHRcdH0gXG5cdFx0XHRcblx0XHRcdC8vIFNob3cgdGhlIHRvb2x0aXAgYW5kIHJ1biBtb3VzZSBvdmVyIGV2ZW50cyAoIzk3Nylcblx0XHRcdGlmICgodGhpcy5pbkNsYXNzKGUudGFyZ2V0LCAnaGlnaGNoYXJ0cy10cmFja2VyJykgfHwgXG5cdFx0XHRcdFx0Y2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gY2hhcnQucGxvdExlZnQsIGUuY2hhcnRZIC0gY2hhcnQucGxvdFRvcCkpICYmICFjaGFydC5vcGVuTWVudSkge1xuXHRcdFx0XHR0aGlzLnJ1blBvaW50QWN0aW9ucyhlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXRpbGl0eSB0byBkZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IGhhcywgb3IgaGFzIGEgcGFyZW50IHdpdGgsIGEgc3BlY2lmaWNcblx0XHQgKiBjbGFzcyBuYW1lLiBVc2VkIG9uIGRldGVjdGlvbiBvZiB0cmFja2VyIG9iamVjdHMgYW5kIG9uIGRlY2lkaW5nIHdoZXRoZXJcblx0XHQgKiBob3ZlcmluZyB0aGUgdG9vbHRpcCBzaG91bGQgY2F1c2UgdGhlIGFjdGl2ZSBzZXJpZXMgdG8gbW91c2Ugb3V0LlxuXHRcdCAqL1xuXHRcdGluQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcblx0XHRcdHZhciBlbGVtQ2xhc3NOYW1lO1xuXHRcdFx0d2hpbGUgKGVsZW1lbnQpIHtcblx0XHRcdFx0ZWxlbUNsYXNzTmFtZSA9IGF0dHIoZWxlbWVudCwgJ2NsYXNzJyk7XG5cdFx0XHRcdGlmIChlbGVtQ2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0aWYgKGVsZW1DbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlbGVtQ2xhc3NOYW1lLmluZGV4T2YoUFJFRklYICsgJ2NvbnRhaW5lcicpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVx0XHRcblx0XHR9LFxuXG5cdFx0b25UcmFja2VyTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcy5jaGFydC5ob3ZlclNlcmllcyxcblx0XHRcdFx0cmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldCB8fCBlLnRvRWxlbWVudCxcblx0XHRcdFx0cmVsYXRlZFNlcmllcyA9IHJlbGF0ZWRUYXJnZXQgJiYgcmVsYXRlZFRhcmdldC5wb2ludCAmJiByZWxhdGVkVGFyZ2V0LnBvaW50LnNlcmllczsgLy8gIzI0OTlcblx0XHRcdFxuXHRcdFx0aWYgKHNlcmllcyAmJiAhc2VyaWVzLm9wdGlvbnMuc3RpY2t5VHJhY2tpbmcgJiYgIXRoaXMuaW5DbGFzcyhyZWxhdGVkVGFyZ2V0LCBQUkVGSVggKyAndG9vbHRpcCcpICYmXG5cdFx0XHRcdFx0cmVsYXRlZFNlcmllcyAhPT0gc2VyaWVzKSB7XG5cdFx0XHRcdHNlcmllcy5vbk1vdXNlT3V0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ29udGFpbmVyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRob3ZlclBvaW50ID0gY2hhcnQuaG92ZXJQb2ludCwgXG5cdFx0XHRcdHBsb3RMZWZ0ID0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRcdHBsb3RUb3AgPSBjaGFydC5wbG90VG9wO1xuXHRcdFx0XG5cdFx0XHRlID0gdGhpcy5ub3JtYWxpemUoZSk7XG5cdFx0XHRlLm9yaWdpbmFsRXZlbnQgPSBlOyAvLyAjMzkxM1xuXHRcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlOyAvLyBJRSBzcGVjaWZpY1xuXG5cdFx0XHRpZiAoIWNoYXJ0LmNhbmNlbENsaWNrKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBPbiB0cmFja2VyIGNsaWNrLCBmaXJlIHRoZSBzZXJpZXMgYW5kIHBvaW50IGV2ZW50cy4gIzc4MywgIzE1ODNcblx0XHRcdFx0aWYgKGhvdmVyUG9pbnQgJiYgdGhpcy5pbkNsYXNzKGUudGFyZ2V0LCBQUkVGSVggKyAndHJhY2tlcicpKSB7XG5cblx0XHRcdFx0XHQvLyB0aGUgc2VyaWVzIGNsaWNrIGV2ZW50XG5cdFx0XHRcdFx0ZmlyZUV2ZW50KGhvdmVyUG9pbnQuc2VyaWVzLCAnY2xpY2snLCBleHRlbmQoZSwge1xuXHRcdFx0XHRcdFx0cG9pbnQ6IGhvdmVyUG9pbnRcblx0XHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0XHQvLyB0aGUgcG9pbnQgY2xpY2sgZXZlbnRcblx0XHRcdFx0XHRpZiAoY2hhcnQuaG92ZXJQb2ludCkgeyAvLyBpdCBtYXkgYmUgZGVzdHJveWVkICgjMTg0NClcblx0XHRcdFx0XHRcdGhvdmVyUG9pbnQuZmlyZVBvaW50RXZlbnQoJ2NsaWNrJywgZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdoZW4gY2xpY2tpbmcgb3V0c2lkZSBhIHRyYWNrZXIsIGZpcmUgYSBjaGFydCBldmVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGV4dGVuZChlLCB0aGlzLmdldENvb3JkaW5hdGVzKGUpKTtcblxuXHRcdFx0XHRcdC8vIGZpcmUgYSBjbGljayBldmVudCBpbiB0aGUgY2hhcnRcblx0XHRcdFx0XHRpZiAoY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gcGxvdExlZnQsIGUuY2hhcnRZIC0gcGxvdFRvcCkpIHtcblx0XHRcdFx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2NsaWNrJywgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIEpTIERPTSBldmVudHMgb24gdGhlIGNvbnRhaW5lciBhbmQgZG9jdW1lbnQuIFRoaXMgbWV0aG9kIHNob3VsZCBjb250YWluXG5cdFx0ICogYSBvbmUtdG8tb25lIGFzc2lnbm1lbnQgYmV0d2VlbiBtZXRob2RzIGFuZCB0aGVpciBoYW5kbGVycy4gQW55IGFkdmFuY2VkIGxvZ2ljIHNob3VsZFxuXHRcdCAqIGJlIG1vdmVkIHRvIHRoZSBoYW5kbGVyIHJlZmxlY3RpbmcgdGhlIGV2ZW50J3MgbmFtZS5cblx0XHQgKi9cblx0XHRzZXRET01FdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHBvaW50ZXIgPSB0aGlzLFxuXHRcdFx0XHRjb250YWluZXIgPSBwb2ludGVyLmNoYXJ0LmNvbnRhaW5lcjtcblxuXHRcdFx0Y29udGFpbmVyLm9ubW91c2Vkb3duID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0cG9pbnRlci5vbkNvbnRhaW5lck1vdXNlRG93bihlKTtcblx0XHRcdH07XG5cdFx0XHRjb250YWluZXIub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyTW91c2VNb3ZlKGUpO1xuXHRcdFx0fTtcblx0XHRcdGNvbnRhaW5lci5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0cG9pbnRlci5vbkNvbnRhaW5lckNsaWNrKGUpO1xuXHRcdFx0fTtcblx0XHRcdGFkZEV2ZW50KGNvbnRhaW5lciwgJ21vdXNlbGVhdmUnLCBwb2ludGVyLm9uQ29udGFpbmVyTW91c2VMZWF2ZSk7XG5cdFx0XHRpZiAoY2hhcnRDb3VudCA9PT0gMSkge1xuXHRcdFx0XHRhZGRFdmVudChkb2MsICdtb3VzZXVwJywgcG9pbnRlci5vbkRvY3VtZW50TW91c2VVcCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzVG91Y2gpIHtcblx0XHRcdFx0Y29udGFpbmVyLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0cG9pbnRlci5vbkNvbnRhaW5lclRvdWNoU3RhcnQoZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGNvbnRhaW5lci5vbnRvdWNobW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0cG9pbnRlci5vbkNvbnRhaW5lclRvdWNoTW92ZShlKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGNoYXJ0Q291bnQgPT09IDEpIHtcblx0XHRcdFx0XHRhZGRFdmVudChkb2MsICd0b3VjaGVuZCcsIHBvaW50ZXIub25Eb2N1bWVudFRvdWNoRW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3lzIHRoZSBQb2ludGVyIG9iamVjdCBhbmQgZGlzY29ubmVjdHMgRE9NIGV2ZW50cy5cblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcHJvcDtcblxuXHRcdFx0cmVtb3ZlRXZlbnQodGhpcy5jaGFydC5jb250YWluZXIsICdtb3VzZWxlYXZlJywgdGhpcy5vbkNvbnRhaW5lck1vdXNlTGVhdmUpO1xuXHRcdFx0aWYgKCFjaGFydENvdW50KSB7XG5cdFx0XHRcdHJlbW92ZUV2ZW50KGRvYywgJ21vdXNldXAnLCB0aGlzLm9uRG9jdW1lbnRNb3VzZVVwKTtcblx0XHRcdFx0cmVtb3ZlRXZlbnQoZG9jLCAndG91Y2hlbmQnLCB0aGlzLm9uRG9jdW1lbnRUb3VjaEVuZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1lbW9yeSBhbmQgQ1BVIGxlYWtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy50b29sdGlwVGltZW91dCk7XG5cblx0XHRcdGZvciAocHJvcCBpbiB0aGlzKSB7XG5cdFx0XHRcdHRoaXNbcHJvcF0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXG5cdC8qIFN1cHBvcnQgZm9yIHRvdWNoIGRldmljZXMgKi9cblx0ZXh0ZW5kKEhpZ2hjaGFydHMuUG9pbnRlci5wcm90b3R5cGUsIHtcblxuXHRcdC8qKlxuXHRcdCAqIFJ1biB0cmFuc2xhdGlvbiBvcGVyYXRpb25zXG5cdFx0ICovXG5cdFx0cGluY2hUcmFuc2xhdGU6IGZ1bmN0aW9uIChwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCkge1xuXHRcdFx0aWYgKHRoaXMuem9vbUhvciB8fCB0aGlzLnBpbmNoSG9yKSB7XG5cdFx0XHRcdHRoaXMucGluY2hUcmFuc2xhdGVEaXJlY3Rpb24odHJ1ZSwgcGluY2hEb3duLCB0b3VjaGVzLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1hcmtlciwgY2xpcCwgbGFzdFZhbGlkVG91Y2gpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuem9vbVZlcnQgfHwgdGhpcy5waW5jaFZlcnQpIHtcblx0XHRcdFx0dGhpcy5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbihmYWxzZSwgcGluY2hEb3duLCB0b3VjaGVzLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1hcmtlciwgY2xpcCwgbGFzdFZhbGlkVG91Y2gpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSdW4gdHJhbnNsYXRpb24gb3BlcmF0aW9ucyBmb3IgZWFjaCBkaXJlY3Rpb24gKGhvcml6b250YWwgYW5kIHZlcnRpY2FsKSBpbmRlcGVuZGVudGx5XG5cdFx0ICovXG5cdFx0cGluY2hUcmFuc2xhdGVEaXJlY3Rpb246IGZ1bmN0aW9uIChob3JpeiwgcGluY2hEb3duLCB0b3VjaGVzLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1hcmtlciwgY2xpcCwgbGFzdFZhbGlkVG91Y2gsIGZvcmNlZFNjYWxlKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHR4eSA9IGhvcml6ID8gJ3gnIDogJ3knLFxuXHRcdFx0XHRYWSA9IGhvcml6ID8gJ1gnIDogJ1knLFxuXHRcdFx0XHRzQ2hhcnRYWSA9ICdjaGFydCcgKyBYWSxcblx0XHRcdFx0d2ggPSBob3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0Jyxcblx0XHRcdFx0cGxvdExlZnRUb3AgPSBjaGFydFsncGxvdCcgKyAoaG9yaXogPyAnTGVmdCcgOiAnVG9wJyldLFxuXHRcdFx0XHRzZWxlY3Rpb25XSCxcblx0XHRcdFx0c2VsZWN0aW9uWFksXG5cdFx0XHRcdGNsaXBYWSxcblx0XHRcdFx0c2NhbGUgPSBmb3JjZWRTY2FsZSB8fCAxLFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHRib3VuZHMgPSBjaGFydC5ib3VuZHNbaG9yaXogPyAnaCcgOiAndiddLFxuXHRcdFx0XHRzaW5nbGVUb3VjaCA9IHBpbmNoRG93bi5sZW5ndGggPT09IDEsXG5cdFx0XHRcdHRvdWNoMFN0YXJ0ID0gcGluY2hEb3duWzBdW3NDaGFydFhZXSxcblx0XHRcdFx0dG91Y2gwTm93ID0gdG91Y2hlc1swXVtzQ2hhcnRYWV0sXG5cdFx0XHRcdHRvdWNoMVN0YXJ0ID0gIXNpbmdsZVRvdWNoICYmIHBpbmNoRG93blsxXVtzQ2hhcnRYWV0sXG5cdFx0XHRcdHRvdWNoMU5vdyA9ICFzaW5nbGVUb3VjaCAmJiB0b3VjaGVzWzFdW3NDaGFydFhZXSxcblx0XHRcdFx0b3V0T2ZCb3VuZHMsXG5cdFx0XHRcdHRyYW5zZm9ybVNjYWxlLFxuXHRcdFx0XHRzY2FsZUtleSxcblx0XHRcdFx0c2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKCFzaW5nbGVUb3VjaCAmJiBtYXRoQWJzKHRvdWNoMFN0YXJ0IC0gdG91Y2gxU3RhcnQpID4gMjApIHsgLy8gRG9uJ3Qgem9vbSBpZiBmaW5nZXJzIGFyZSB0b28gY2xvc2Ugb24gdGhpcyBheGlzXG5cdFx0XHRcdFx0XHRzY2FsZSA9IGZvcmNlZFNjYWxlIHx8IG1hdGhBYnModG91Y2gwTm93IC0gdG91Y2gxTm93KSAvIG1hdGhBYnModG91Y2gwU3RhcnQgLSB0b3VjaDFTdGFydCk7IFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjbGlwWFkgPSAoKHBsb3RMZWZ0VG9wIC0gdG91Y2gwTm93KSAvIHNjYWxlKSArIHRvdWNoMFN0YXJ0O1xuXHRcdFx0XHRcdHNlbGVjdGlvbldIID0gY2hhcnRbJ3Bsb3QnICsgKGhvcml6ID8gJ1dpZHRoJyA6ICdIZWlnaHQnKV0gLyBzY2FsZTtcblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBzY2FsZSwgZmlyc3QgcGFzc1xuXHRcdFx0c2V0U2NhbGUoKTtcblxuXHRcdFx0c2VsZWN0aW9uWFkgPSBjbGlwWFk7IC8vIHRoZSBjbGlwIHBvc2l0aW9uICh4IG9yIHkpIGlzIGFsdGVyZWQgaWYgb3V0IG9mIGJvdW5kcywgdGhlIHNlbGVjdGlvbiBwb3NpdGlvbiBpcyBub3RcblxuXHRcdFx0Ly8gT3V0IG9mIGJvdW5kc1xuXHRcdFx0aWYgKHNlbGVjdGlvblhZIDwgYm91bmRzLm1pbikge1xuXHRcdFx0XHRzZWxlY3Rpb25YWSA9IGJvdW5kcy5taW47XG5cdFx0XHRcdG91dE9mQm91bmRzID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsZWN0aW9uWFkgKyBzZWxlY3Rpb25XSCA+IGJvdW5kcy5tYXgpIHtcblx0XHRcdFx0c2VsZWN0aW9uWFkgPSBib3VuZHMubWF4IC0gc2VsZWN0aW9uV0g7XG5cdFx0XHRcdG91dE9mQm91bmRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSXMgdGhlIGNoYXJ0IGRyYWdnZWQgb2ZmIGl0cyBib3VuZHMsIGRldGVybWluZWQgYnkgZGF0YU1pbiBhbmQgZGF0YU1heD9cblx0XHRcdGlmIChvdXRPZkJvdW5kcykge1xuXG5cdFx0XHRcdC8vIE1vZGlmeSB0aGUgdG91Y2hOb3cgcG9zaXRpb24gaW4gb3JkZXIgdG8gY3JlYXRlIGFuIGVsYXN0aWMgZHJhZyBtb3ZlbWVudC4gVGhpcyBpbmRpY2F0ZXNcblx0XHRcdFx0Ly8gdG8gdGhlIHVzZXIgdGhhdCB0aGUgY2hhcnQgaXMgcmVzcG9uc2l2ZSBidXQgY2FuJ3QgYmUgZHJhZ2dlZCBmdXJ0aGVyLlxuXHRcdFx0XHR0b3VjaDBOb3cgLT0gMC44ICogKHRvdWNoME5vdyAtIGxhc3RWYWxpZFRvdWNoW3h5XVswXSk7XG5cdFx0XHRcdGlmICghc2luZ2xlVG91Y2gpIHtcblx0XHRcdFx0XHR0b3VjaDFOb3cgLT0gMC44ICogKHRvdWNoMU5vdyAtIGxhc3RWYWxpZFRvdWNoW3h5XVsxXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIHNjYWxlLCBzZWNvbmQgcGFzcyB0byBhZGFwdCB0byB0aGUgbW9kaWZpZWQgdG91Y2hOb3cgcG9zaXRpb25zXG5cdFx0XHRcdHNldFNjYWxlKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhc3RWYWxpZFRvdWNoW3h5XSA9IFt0b3VjaDBOb3csIHRvdWNoMU5vd107XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBnZW9tZXRyeSBmb3IgY2xpcHBpbmcsIHNlbGVjdGlvbiBhbmQgdHJhbnNmb3JtYXRpb25cblx0XHRcdGlmICghaW52ZXJ0ZWQpIHsgLy8gVE9ETzogaW1wbGVtZW50IGNsaXBwaW5nIGZvciBpbnZlcnRlZCBjaGFydHNcblx0XHRcdFx0Y2xpcFt4eV0gPSBjbGlwWFkgLSBwbG90TGVmdFRvcDtcblx0XHRcdFx0Y2xpcFt3aF0gPSBzZWxlY3Rpb25XSDtcblx0XHRcdH1cblx0XHRcdHNjYWxlS2V5ID0gaW52ZXJ0ZWQgPyAoaG9yaXogPyAnc2NhbGVZJyA6ICdzY2FsZVgnKSA6ICdzY2FsZScgKyBYWTtcblx0XHRcdHRyYW5zZm9ybVNjYWxlID0gaW52ZXJ0ZWQgPyAxIC8gc2NhbGUgOiBzY2FsZTtcblxuXHRcdFx0c2VsZWN0aW9uTWFya2VyW3doXSA9IHNlbGVjdGlvbldIO1xuXHRcdFx0c2VsZWN0aW9uTWFya2VyW3h5XSA9IHNlbGVjdGlvblhZO1xuXHRcdFx0dHJhbnNmb3JtW3NjYWxlS2V5XSA9IHNjYWxlO1xuXHRcdFx0dHJhbnNmb3JtWyd0cmFuc2xhdGUnICsgWFldID0gKHRyYW5zZm9ybVNjYWxlICogcGxvdExlZnRUb3ApICsgKHRvdWNoME5vdyAtICh0cmFuc2Zvcm1TY2FsZSAqIHRvdWNoMFN0YXJ0KSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBIYW5kbGUgdG91Y2ggZXZlbnRzIHdpdGggdHdvIHRvdWNoZXNcblx0XHQgKi9cblx0XHRwaW5jaDogZnVuY3Rpb24gKGUpIHtcblxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlbGYuY2hhcnQsXG5cdFx0XHRcdHBpbmNoRG93biA9IHNlbGYucGluY2hEb3duLFxuXHRcdFx0XHR0b3VjaGVzID0gZS50b3VjaGVzLFxuXHRcdFx0XHR0b3VjaGVzTGVuZ3RoID0gdG91Y2hlcy5sZW5ndGgsXG5cdFx0XHRcdGxhc3RWYWxpZFRvdWNoID0gc2VsZi5sYXN0VmFsaWRUb3VjaCxcblx0XHRcdFx0aGFzWm9vbSA9IHNlbGYuaGFzWm9vbSxcblx0XHRcdFx0c2VsZWN0aW9uTWFya2VyID0gc2VsZi5zZWxlY3Rpb25NYXJrZXIsXG5cdFx0XHRcdHRyYW5zZm9ybSA9IHt9LFxuXHRcdFx0XHRmaXJlQ2xpY2tFdmVudCA9IHRvdWNoZXNMZW5ndGggPT09IDEgJiYgKChzZWxmLmluQ2xhc3MoZS50YXJnZXQsIFBSRUZJWCArICd0cmFja2VyJykgJiYgXG5cdFx0XHRcdFx0Y2hhcnQucnVuVHJhY2tlckNsaWNrKSB8fCBzZWxmLnJ1bkNoYXJ0Q2xpY2spLFxuXHRcdFx0XHRjbGlwID0ge307XG5cblx0XHRcdC8vIE9uIHRvdWNoIGRldmljZXMsIG9ubHkgcHJvY2VlZCB0byB0cmlnZ2VyIGNsaWNrIGlmIGEgaGFuZGxlciBpcyBkZWZpbmVkXG5cdFx0XHRpZiAoaGFzWm9vbSAmJiAhZmlyZUNsaWNrRXZlbnQpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBOb3JtYWxpemUgZWFjaCB0b3VjaFxuXHRcdFx0bWFwKHRvdWNoZXMsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLm5vcm1hbGl6ZShlKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBSZWdpc3RlciB0aGUgdG91Y2ggc3RhcnQgcG9zaXRpb25cblx0XHRcdGlmIChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdFx0XHRlYWNoKHRvdWNoZXMsIGZ1bmN0aW9uIChlLCBpKSB7XG5cdFx0XHRcdFx0cGluY2hEb3duW2ldID0geyBjaGFydFg6IGUuY2hhcnRYLCBjaGFydFk6IGUuY2hhcnRZIH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRsYXN0VmFsaWRUb3VjaC54ID0gW3BpbmNoRG93blswXS5jaGFydFgsIHBpbmNoRG93blsxXSAmJiBwaW5jaERvd25bMV0uY2hhcnRYXTtcblx0XHRcdFx0bGFzdFZhbGlkVG91Y2gueSA9IFtwaW5jaERvd25bMF0uY2hhcnRZLCBwaW5jaERvd25bMV0gJiYgcGluY2hEb3duWzFdLmNoYXJ0WV07XG5cblx0XHRcdFx0Ly8gSWRlbnRpZnkgdGhlIGRhdGEgYm91bmRzIGluIHBpeGVsc1xuXHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0aWYgKGF4aXMuem9vbUVuYWJsZWQpIHtcblx0XHRcdFx0XHRcdHZhciBib3VuZHMgPSBjaGFydC5ib3VuZHNbYXhpcy5ob3JpeiA/ICdoJyA6ICd2J10sXG5cdFx0XHRcdFx0XHRcdG1pblBpeGVsUGFkZGluZyA9IGF4aXMubWluUGl4ZWxQYWRkaW5nLFxuXHRcdFx0XHRcdFx0XHRtaW4gPSBheGlzLnRvUGl4ZWxzKHBpY2soYXhpcy5vcHRpb25zLm1pbiwgYXhpcy5kYXRhTWluKSksXG5cdFx0XHRcdFx0XHRcdG1heCA9IGF4aXMudG9QaXhlbHMocGljayhheGlzLm9wdGlvbnMubWF4LCBheGlzLmRhdGFNYXgpKSxcblx0XHRcdFx0XHRcdFx0YWJzTWluID0gbWF0aE1pbihtaW4sIG1heCksXG5cdFx0XHRcdFx0XHRcdGFic01heCA9IG1hdGhNYXgobWluLCBtYXgpO1xuXG5cdFx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgYm91bmRzIGZvciB1c2UgaW4gdGhlIHRvdWNobW92ZSBoYW5kbGVyXG5cdFx0XHRcdFx0XHRib3VuZHMubWluID0gbWF0aE1pbihheGlzLnBvcywgYWJzTWluIC0gbWluUGl4ZWxQYWRkaW5nKTtcblx0XHRcdFx0XHRcdGJvdW5kcy5tYXggPSBtYXRoTWF4KGF4aXMucG9zICsgYXhpcy5sZW4sIGFic01heCArIG1pblBpeGVsUGFkZGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2VsZi5yZXMgPSB0cnVlOyAvLyByZXNldCBvbiBuZXh0IG1vdmVcblx0XHRcdFxuXHRcdFx0Ly8gRXZlbnQgdHlwZSBpcyB0b3VjaG1vdmUsIGhhbmRsZSBwYW5uaW5nIGFuZCBwaW5jaGluZ1xuXHRcdFx0fSBlbHNlIGlmIChwaW5jaERvd24ubGVuZ3RoKSB7IC8vIGNhbiBiZSAwIHdoZW4gcmVsZWFzaW5nLCBpZiB0b3VjaGVuZCBmaXJlcyBmaXJzdFxuXHRcdFx0XHRcblxuXHRcdFx0XHQvLyBTZXQgdGhlIG1hcmtlclxuXHRcdFx0XHRpZiAoIXNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0XHRcdHNlbGYuc2VsZWN0aW9uTWFya2VyID0gc2VsZWN0aW9uTWFya2VyID0gZXh0ZW5kKHtcblx0XHRcdFx0XHRcdGRlc3Ryb3k6IG5vb3Bcblx0XHRcdFx0XHR9LCBjaGFydC5wbG90Qm94KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0c2VsZi5waW5jaFRyYW5zbGF0ZShwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCk7XG5cblx0XHRcdFx0c2VsZi5oYXNQaW5jaGVkID0gaGFzWm9vbTtcblxuXHRcdFx0XHQvLyBTY2FsZSBhbmQgdHJhbnNsYXRlIHRoZSBncm91cHMgdG8gcHJvdmlkZSB2aXN1YWwgZmVlZGJhY2sgZHVyaW5nIHBpbmNoaW5nXG5cdFx0XHRcdHNlbGYuc2NhbGVHcm91cHModHJhbnNmb3JtLCBjbGlwKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIE9wdGlvbmFsbHkgbW92ZSB0aGUgdG9vbHRpcCBvbiB0b3VjaG1vdmVcblx0XHRcdFx0aWYgKCFoYXNab29tICYmIHNlbGYuZm9sbG93VG91Y2hNb3ZlICYmIHRvdWNoZXNMZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHR0aGlzLnJ1blBvaW50QWN0aW9ucyhzZWxmLm5vcm1hbGl6ZShlKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2VsZi5yZXMpIHtcblx0XHRcdFx0XHRzZWxmLnJlcyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMucmVzZXQoZmFsc2UsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ29udGFpbmVyVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cblx0XHRcdGhvdmVyQ2hhcnRJbmRleCA9IGNoYXJ0LmluZGV4O1xuXG5cdFx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuXG5cdFx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcblxuXHRcdFx0XHRpZiAoY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gY2hhcnQucGxvdExlZnQsIGUuY2hhcnRZIC0gY2hhcnQucGxvdFRvcCkgJiYgIWNoYXJ0Lm9wZW5NZW51KSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gbW91c2UgZXZlbnRzIGFuZCBkaXNwbGF5IHRvb2x0aXAgZXRjXG5cdFx0XHRcdFx0dGhpcy5ydW5Qb2ludEFjdGlvbnMoZSk7XG5cblx0XHRcdFx0XHR0aGlzLnBpbmNoKGUpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSGlkZSB0aGUgdG9vbHRpcCBvbiB0b3VjaGluZyBvdXRzaWRlIHRoZSBwbG90IGFyZWEgKCMxMjAzKVxuXHRcdFx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0dGhpcy5waW5jaChlKTtcblx0XHRcdH0gICBcblx0XHR9LFxuXG5cdFx0b25Db250YWluZXJUb3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSB8fCBlLnRvdWNoZXMubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdHRoaXMucGluY2goZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uRG9jdW1lbnRUb3VjaEVuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChjaGFydHNbaG92ZXJDaGFydEluZGV4XSkge1xuXHRcdFx0XHRjaGFydHNbaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3AoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0pO1xuXHRpZiAod2luLlBvaW50ZXJFdmVudCB8fCB3aW4uTVNQb2ludGVyRXZlbnQpIHtcblx0XHRcblx0XHQvLyBUaGUgdG91Y2hlcyBvYmplY3Qga2VlcHMgdHJhY2sgb2YgdGhlIHBvaW50cyBiZWluZyB0b3VjaGVkIGF0IGFsbCB0aW1lc1xuXHRcdHZhciB0b3VjaGVzID0ge30sXG5cdFx0XHRoYXNQb2ludGVyRXZlbnQgPSAhIXdpbi5Qb2ludGVyRXZlbnQsXG5cdFx0XHRnZXRXZWJraXRUb3VjaGVzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIga2V5LCBmYWtlID0gW107XG5cdFx0XHRcdGZha2UuaXRlbSA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzW2ldOyB9O1xuXHRcdFx0XHRmb3IgKGtleSBpbiB0b3VjaGVzKSB7XG5cdFx0XHRcdFx0aWYgKHRvdWNoZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0ZmFrZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0cGFnZVg6IHRvdWNoZXNba2V5XS5wYWdlWCxcblx0XHRcdFx0XHRcdFx0cGFnZVk6IHRvdWNoZXNba2V5XS5wYWdlWSxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0OiB0b3VjaGVzW2tleV0udGFyZ2V0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZha2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNsYXRlTVNQb2ludGVyID0gZnVuY3Rpb24gKGUsIG1ldGhvZCwgd2t0eXBlLCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgcDtcblx0XHRcdFx0ZSA9IGUub3JpZ2luYWxFdmVudCB8fCBlO1xuXHRcdFx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9UT1VDSCkgJiYgY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0pIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlKTtcblx0XHRcdFx0XHRwID0gY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0ucG9pbnRlcjtcblx0XHRcdFx0XHRwW21ldGhvZF0oe1xuXHRcdFx0XHRcdFx0dHlwZTogd2t0eXBlLFxuXHRcdFx0XHRcdFx0dGFyZ2V0OiBlLmN1cnJlbnRUYXJnZXQsXG5cdFx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdDogbm9vcCxcblx0XHRcdFx0XHRcdHRvdWNoZXM6IGdldFdlYmtpdFRvdWNoZXMoKVxuXHRcdFx0XHRcdH0pO1x0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBFeHRlbmQgdGhlIFBvaW50ZXIgcHJvdG90eXBlIHdpdGggbWV0aG9kcyBmb3IgZWFjaCBldmVudCBoYW5kbGVyIGFuZCBtb3JlXG5cdFx0ICovXG5cdFx0ZXh0ZW5kKFBvaW50ZXIucHJvdG90eXBlLCB7XG5cdFx0XHRvbkNvbnRhaW5lclBvaW50ZXJEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR0cmFuc2xhdGVNU1BvaW50ZXIoZSwgJ29uQ29udGFpbmVyVG91Y2hTdGFydCcsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHR0b3VjaGVzW2UucG9pbnRlcklkXSA9IHsgcGFnZVg6IGUucGFnZVgsIHBhZ2VZOiBlLnBhZ2VZLCB0YXJnZXQ6IGUuY3VycmVudFRhcmdldCB9O1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRvbkNvbnRhaW5lclBvaW50ZXJNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR0cmFuc2xhdGVNU1BvaW50ZXIoZSwgJ29uQ29udGFpbmVyVG91Y2hNb3ZlJywgJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0dG91Y2hlc1tlLnBvaW50ZXJJZF0gPSB7IHBhZ2VYOiBlLnBhZ2VYLCBwYWdlWTogZS5wYWdlWSB9O1xuXHRcdFx0XHRcdGlmICghdG91Y2hlc1tlLnBvaW50ZXJJZF0udGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHR0b3VjaGVzW2UucG9pbnRlcklkXS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRvbkRvY3VtZW50UG9pbnRlclVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR0cmFuc2xhdGVNU1BvaW50ZXIoZSwgJ29uQ29udGFpbmVyVG91Y2hFbmQnLCAndG91Y2hlbmQnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0b3VjaGVzW2UucG9pbnRlcklkXTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFkZCBvciByZW1vdmUgdGhlIE1TIFBvaW50ZXIgc3BlY2lmaWMgZXZlbnRzXG5cdFx0XHQgKi9cblx0XHRcdGJhdGNoTVNFdmVudHM6IGZ1bmN0aW9uIChmbikge1xuXHRcdFx0XHRmbih0aGlzLmNoYXJ0LmNvbnRhaW5lciwgaGFzUG9pbnRlckV2ZW50ID8gJ3BvaW50ZXJkb3duJyA6ICdNU1BvaW50ZXJEb3duJywgdGhpcy5vbkNvbnRhaW5lclBvaW50ZXJEb3duKTtcblx0XHRcdFx0Zm4odGhpcy5jaGFydC5jb250YWluZXIsIGhhc1BvaW50ZXJFdmVudCA/ICdwb2ludGVybW92ZScgOiAnTVNQb2ludGVyTW92ZScsIHRoaXMub25Db250YWluZXJQb2ludGVyTW92ZSk7XG5cdFx0XHRcdGZuKGRvYywgaGFzUG9pbnRlckV2ZW50ID8gJ3BvaW50ZXJ1cCcgOiAnTVNQb2ludGVyVXAnLCB0aGlzLm9uRG9jdW1lbnRQb2ludGVyVXApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRGlzYWJsZSBkZWZhdWx0IElFIGFjdGlvbnMgZm9yIHBpbmNoIGFuZCBzdWNoIG9uIGNoYXJ0IGVsZW1lbnRcblx0XHR3cmFwKFBvaW50ZXIucHJvdG90eXBlLCAnaW5pdCcsIGZ1bmN0aW9uIChwcm9jZWVkLCBjaGFydCwgb3B0aW9ucykge1xuXHRcdFx0cHJvY2VlZC5jYWxsKHRoaXMsIGNoYXJ0LCBvcHRpb25zKTtcblx0XHRcdGlmICh0aGlzLmhhc1pvb20gfHwgdGhpcy5mb2xsb3dUb3VjaE1vdmUpIHtcblx0XHRcdFx0Y3NzKGNoYXJ0LmNvbnRhaW5lciwge1xuXHRcdFx0XHRcdCctbXMtdG91Y2gtYWN0aW9uJzogTk9ORSxcblx0XHRcdFx0XHQndG91Y2gtYWN0aW9uJzogTk9ORVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEFkZCBJRSBzcGVjaWZpYyB0b3VjaCBldmVudHMgdG8gY2hhcnRcblx0XHR3cmFwKFBvaW50ZXIucHJvdG90eXBlLCAnc2V0RE9NRXZlbnRzJywgZnVuY3Rpb24gKHByb2NlZWQpIHtcblx0XHRcdHByb2NlZWQuYXBwbHkodGhpcyk7XG5cdFx0XHRpZiAodGhpcy5oYXNab29tIHx8IHRoaXMuZm9sbG93VG91Y2hNb3ZlKSB7XG5cdFx0XHRcdHRoaXMuYmF0Y2hNU0V2ZW50cyhhZGRFdmVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Ly8gRGVzdHJveSBNUyBldmVudHMgYWxzb1xuXHRcdHdyYXAoUG9pbnRlci5wcm90b3R5cGUsICdkZXN0cm95JywgZnVuY3Rpb24gKHByb2NlZWQpIHtcblx0XHRcdHRoaXMuYmF0Y2hNU0V2ZW50cyhyZW1vdmVFdmVudCk7XG5cdFx0XHRwcm9jZWVkLmNhbGwodGhpcyk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCAqIFRoZSBvdmVydmlldyBvZiB0aGUgY2hhcnQncyBzZXJpZXNcblx0ICovXG5cdHZhciBMZWdlbmQgPSBIaWdoY2hhcnRzLkxlZ2VuZCA9IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdHRoaXMuaW5pdChjaGFydCwgb3B0aW9ucyk7XG5cdH07XG5cblx0TGVnZW5kLnByb3RvdHlwZSA9IHtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmRcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoY2hhcnQsIG9wdGlvbnMpIHtcblx0XHRcdFxuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRcdGl0ZW1TdHlsZSA9IG9wdGlvbnMuaXRlbVN0eWxlLFxuXHRcdFx0XHRwYWRkaW5nLFxuXHRcdFx0XHRpdGVtTWFyZ2luVG9wID0gb3B0aW9ucy5pdGVtTWFyZ2luVG9wIHx8IDA7XG5cdFx0XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0XHRpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRsZWdlbmQuaXRlbVN0eWxlID0gaXRlbVN0eWxlO1xuXHRcdFx0bGVnZW5kLml0ZW1IaWRkZW5TdHlsZSA9IG1lcmdlKGl0ZW1TdHlsZSwgb3B0aW9ucy5pdGVtSGlkZGVuU3R5bGUpO1xuXHRcdFx0bGVnZW5kLml0ZW1NYXJnaW5Ub3AgPSBpdGVtTWFyZ2luVG9wO1xuXHRcdFx0bGVnZW5kLnBhZGRpbmcgPSBwYWRkaW5nID0gcGljayhvcHRpb25zLnBhZGRpbmcsIDgpO1xuXHRcdFx0bGVnZW5kLmluaXRpYWxJdGVtWCA9IHBhZGRpbmc7XG5cdFx0XHRsZWdlbmQuaW5pdGlhbEl0ZW1ZID0gcGFkZGluZyAtIDU7IC8vIDUgaXMgdGhlIG51bWJlciBvZiBwaXhlbHMgYWJvdmUgdGhlIHRleHRcblx0XHRcdGxlZ2VuZC5tYXhJdGVtV2lkdGggPSAwO1xuXHRcdFx0bGVnZW5kLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XHRsZWdlbmQuaXRlbUhlaWdodCA9IDA7XG5cdFx0XHRsZWdlbmQuc3ltYm9sV2lkdGggPSBwaWNrKG9wdGlvbnMuc3ltYm9sV2lkdGgsIDE2KTtcblx0XHRcdGxlZ2VuZC5wYWdlcyA9IFtdO1xuXG5cblx0XHRcdC8vIFJlbmRlciBpdFxuXHRcdFx0bGVnZW5kLnJlbmRlcigpO1xuXG5cdFx0XHQvLyBtb3ZlIGNoZWNrYm94ZXNcblx0XHRcdGFkZEV2ZW50KGxlZ2VuZC5jaGFydCwgJ2VuZFJlc2l6ZScsIGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdGxlZ2VuZC5wb3NpdGlvbkNoZWNrYm94ZXMoKTtcblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgY29sb3JzIGZvciB0aGUgbGVnZW5kIGl0ZW1cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBBIFNlcmllcyBvciBQb2ludCBpbnN0YW5jZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2aXNpYmxlIERpbW1lZCBvciBjb2xvcmVkXG5cdFx0ICovXG5cdFx0Y29sb3JpemVJdGVtOiBmdW5jdGlvbiAoaXRlbSwgdmlzaWJsZSkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBsZWdlbmQub3B0aW9ucyxcblx0XHRcdFx0bGVnZW5kSXRlbSA9IGl0ZW0ubGVnZW5kSXRlbSxcblx0XHRcdFx0bGVnZW5kTGluZSA9IGl0ZW0ubGVnZW5kTGluZSxcblx0XHRcdFx0bGVnZW5kU3ltYm9sID0gaXRlbS5sZWdlbmRTeW1ib2wsXG5cdFx0XHRcdGhpZGRlbkNvbG9yID0gbGVnZW5kLml0ZW1IaWRkZW5TdHlsZS5jb2xvcixcblx0XHRcdFx0dGV4dENvbG9yID0gdmlzaWJsZSA/IG9wdGlvbnMuaXRlbVN0eWxlLmNvbG9yIDogaGlkZGVuQ29sb3IsXG5cdFx0XHRcdHN5bWJvbENvbG9yID0gdmlzaWJsZSA/IChpdGVtLmxlZ2VuZENvbG9yIHx8IGl0ZW0uY29sb3IgfHwgJyNDQ0MnKSA6IGhpZGRlbkNvbG9yLFxuXHRcdFx0XHRtYXJrZXJPcHRpb25zID0gaXRlbS5vcHRpb25zICYmIGl0ZW0ub3B0aW9ucy5tYXJrZXIsXG5cdFx0XHRcdHN5bWJvbEF0dHIgPSB7IGZpbGw6IHN5bWJvbENvbG9yIH0sXG5cdFx0XHRcdGtleSxcblx0XHRcdFx0dmFsO1xuXHRcdFx0XG5cdFx0XHRpZiAobGVnZW5kSXRlbSkge1xuXHRcdFx0XHRsZWdlbmRJdGVtLmNzcyh7IGZpbGw6IHRleHRDb2xvciwgY29sb3I6IHRleHRDb2xvciB9KTsgLy8gY29sb3IgZm9yICMxNTUzLCBvbGRJRVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlZ2VuZExpbmUpIHtcblx0XHRcdFx0bGVnZW5kTGluZS5hdHRyKHsgc3Ryb2tlOiBzeW1ib2xDb2xvciB9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGxlZ2VuZFN5bWJvbCkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQXBwbHkgbWFya2VyIG9wdGlvbnNcblx0XHRcdFx0aWYgKG1hcmtlck9wdGlvbnMgJiYgbGVnZW5kU3ltYm9sLmlzTWFya2VyKSB7IC8vICM1ODVcblx0XHRcdFx0XHRzeW1ib2xBdHRyLnN0cm9rZSA9IHN5bWJvbENvbG9yO1xuXHRcdFx0XHRcdG1hcmtlck9wdGlvbnMgPSBpdGVtLmNvbnZlcnRBdHRyaWJzKG1hcmtlck9wdGlvbnMpO1xuXHRcdFx0XHRcdGZvciAoa2V5IGluIG1hcmtlck9wdGlvbnMpIHtcblx0XHRcdFx0XHRcdHZhbCA9IG1hcmtlck9wdGlvbnNba2V5XTtcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHRzeW1ib2xBdHRyW2tleV0gPSB2YWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGVnZW5kU3ltYm9sLmF0dHIoc3ltYm9sQXR0cik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uIHRoZSBsZWdlbmQgaXRlbVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgU2VyaWVzIG9yIFBvaW50IGluc3RhbmNlXG5cdFx0ICovXG5cdFx0cG9zaXRpb25JdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBsZWdlbmQub3B0aW9ucyxcblx0XHRcdFx0c3ltYm9sUGFkZGluZyA9IG9wdGlvbnMuc3ltYm9sUGFkZGluZyxcblx0XHRcdFx0bHRyID0gIW9wdGlvbnMucnRsLFxuXHRcdFx0XHRsZWdlbmRJdGVtUG9zID0gaXRlbS5fbGVnZW5kSXRlbVBvcyxcblx0XHRcdFx0aXRlbVggPSBsZWdlbmRJdGVtUG9zWzBdLFxuXHRcdFx0XHRpdGVtWSA9IGxlZ2VuZEl0ZW1Qb3NbMV0sXG5cdFx0XHRcdGNoZWNrYm94ID0gaXRlbS5jaGVja2JveDtcblxuXHRcdFx0aWYgKGl0ZW0ubGVnZW5kR3JvdXApIHtcblx0XHRcdFx0aXRlbS5sZWdlbmRHcm91cC50cmFuc2xhdGUoXG5cdFx0XHRcdFx0bHRyID8gaXRlbVggOiBsZWdlbmQubGVnZW5kV2lkdGggLSBpdGVtWCAtIDIgKiBzeW1ib2xQYWRkaW5nIC0gNCxcblx0XHRcdFx0XHRpdGVtWVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2hlY2tib3gpIHtcblx0XHRcdFx0Y2hlY2tib3gueCA9IGl0ZW1YO1xuXHRcdFx0XHRjaGVja2JveC55ID0gaXRlbVk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgYSBzaW5nbGUgbGVnZW5kIGl0ZW1cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgc2VyaWVzIG9yIHBvaW50XG5cdFx0ICovXG5cdFx0ZGVzdHJveUl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY2hlY2tib3ggPSBpdGVtLmNoZWNrYm94O1xuXG5cdFx0XHQvLyBkZXN0cm95IFNWRyBlbGVtZW50c1xuXHRcdFx0ZWFjaChbJ2xlZ2VuZEl0ZW0nLCAnbGVnZW5kTGluZScsICdsZWdlbmRTeW1ib2wnLCAnbGVnZW5kR3JvdXAnXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRpZiAoaXRlbVtrZXldKSB7XG5cdFx0XHRcdFx0aXRlbVtrZXldID0gaXRlbVtrZXldLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChjaGVja2JveCkge1xuXHRcdFx0XHRkaXNjYXJkRWxlbWVudChpdGVtLmNoZWNrYm94KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBhbGwgaXRlbXMuXG5cdFx0ICovXG5cdFx0Y2xlYXJJdGVtczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXM7XG5cdFx0XHRlYWNoKGxlZ2VuZC5nZXRBbGxJdGVtcygpLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRsZWdlbmQuZGVzdHJveUl0ZW0oaXRlbSk7IFxuXHRcdFx0fSk7XHRcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95cyB0aGUgbGVnZW5kLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0XHRsZWdlbmRHcm91cCA9IGxlZ2VuZC5ncm91cCxcblx0XHRcdFx0Ym94ID0gbGVnZW5kLmJveDtcblxuXHRcdFx0aWYgKGJveCkge1xuXHRcdFx0XHRsZWdlbmQuYm94ID0gYm94LmRlc3Ryb3koKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGxlZ2VuZEdyb3VwKSB7XG5cdFx0XHRcdGxlZ2VuZC5ncm91cCA9IGxlZ2VuZEdyb3VwLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gdGhlIGNoZWNrYm94ZXMgYWZ0ZXIgdGhlIHdpZHRoIGlzIGRldGVybWluZWRcblx0XHQgKi9cblx0XHRwb3NpdGlvbkNoZWNrYm94ZXM6IGZ1bmN0aW9uIChzY3JvbGxPZmZzZXQpIHtcblx0XHRcdHZhciBhbGlnbkF0dHIgPSB0aGlzLmdyb3VwLmFsaWduQXR0cixcblx0XHRcdFx0dHJhbnNsYXRlWSxcblx0XHRcdFx0Y2xpcEhlaWdodCA9IHRoaXMuY2xpcEhlaWdodCB8fCB0aGlzLmxlZ2VuZEhlaWdodDtcblxuXHRcdFx0aWYgKGFsaWduQXR0cikge1xuXHRcdFx0XHR0cmFuc2xhdGVZID0gYWxpZ25BdHRyLnRyYW5zbGF0ZVk7XG5cdFx0XHRcdGVhY2godGhpcy5hbGxJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0XHR2YXIgY2hlY2tib3ggPSBpdGVtLmNoZWNrYm94LFxuXHRcdFx0XHRcdFx0dG9wO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChjaGVja2JveCkge1xuXHRcdFx0XHRcdFx0dG9wID0gKHRyYW5zbGF0ZVkgKyBjaGVja2JveC55ICsgKHNjcm9sbE9mZnNldCB8fCAwKSArIDMpO1xuXHRcdFx0XHRcdFx0Y3NzKGNoZWNrYm94LCB7XG5cdFx0XHRcdFx0XHRcdGxlZnQ6IChhbGlnbkF0dHIudHJhbnNsYXRlWCArIGl0ZW0uY2hlY2tib3hPZmZzZXQgKyBjaGVja2JveC54IC0gMjApICsgUFgsXG5cdFx0XHRcdFx0XHRcdHRvcDogdG9wICsgUFgsXG5cdFx0XHRcdFx0XHRcdGRpc3BsYXk6IHRvcCA+IHRyYW5zbGF0ZVkgLSA2ICYmIHRvcCA8IHRyYW5zbGF0ZVkgKyBjbGlwSGVpZ2h0IC0gNiA/ICcnIDogTk9ORVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciB0aGUgbGVnZW5kIHRpdGxlIG9uIHRvcCBvZiB0aGUgbGVnZW5kXG5cdFx0ICovXG5cdFx0cmVuZGVyVGl0bGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRwYWRkaW5nID0gdGhpcy5wYWRkaW5nLFxuXHRcdFx0XHR0aXRsZU9wdGlvbnMgPSBvcHRpb25zLnRpdGxlLFxuXHRcdFx0XHR0aXRsZUhlaWdodCA9IDAsXG5cdFx0XHRcdGJCb3g7XG5cdFx0XHRcblx0XHRcdGlmICh0aXRsZU9wdGlvbnMudGV4dCkge1xuXHRcdFx0XHRpZiAoIXRoaXMudGl0bGUpIHtcblx0XHRcdFx0XHR0aGlzLnRpdGxlID0gdGhpcy5jaGFydC5yZW5kZXJlci5sYWJlbCh0aXRsZU9wdGlvbnMudGV4dCwgcGFkZGluZyAtIDMsIHBhZGRpbmcgLSA0LCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAnbGVnZW5kLXRpdGxlJylcblx0XHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiAxIH0pXG5cdFx0XHRcdFx0XHQuY3NzKHRpdGxlT3B0aW9ucy5zdHlsZSlcblx0XHRcdFx0XHRcdC5hZGQodGhpcy5ncm91cCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YkJveCA9IHRoaXMudGl0bGUuZ2V0QkJveCgpO1xuXHRcdFx0XHR0aXRsZUhlaWdodCA9IGJCb3guaGVpZ2h0O1xuXHRcdFx0XHR0aGlzLm9mZnNldFdpZHRoID0gYkJveC53aWR0aDsgLy8gIzE3MTdcblx0XHRcdFx0dGhpcy5jb250ZW50R3JvdXAuYXR0cih7IHRyYW5zbGF0ZVk6IHRpdGxlSGVpZ2h0IH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50aXRsZUhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgYSBzaW5nbGUgc3BlY2lmaWMgbGVnZW5kIGl0ZW1cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBBIHNlcmllcyBvciBwb2ludFxuXHRcdCAqL1xuXHRcdHJlbmRlckl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBsZWdlbmQuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdG9wdGlvbnMgPSBsZWdlbmQub3B0aW9ucyxcblx0XHRcdFx0aG9yaXpvbnRhbCA9IG9wdGlvbnMubGF5b3V0ID09PSAnaG9yaXpvbnRhbCcsXG5cdFx0XHRcdHN5bWJvbFdpZHRoID0gbGVnZW5kLnN5bWJvbFdpZHRoLFxuXHRcdFx0XHRzeW1ib2xQYWRkaW5nID0gb3B0aW9ucy5zeW1ib2xQYWRkaW5nLFxuXHRcdFx0XHRpdGVtU3R5bGUgPSBsZWdlbmQuaXRlbVN0eWxlLFxuXHRcdFx0XHRpdGVtSGlkZGVuU3R5bGUgPSBsZWdlbmQuaXRlbUhpZGRlblN0eWxlLFxuXHRcdFx0XHRwYWRkaW5nID0gbGVnZW5kLnBhZGRpbmcsXG5cdFx0XHRcdGl0ZW1EaXN0YW5jZSA9IGhvcml6b250YWwgPyBwaWNrKG9wdGlvbnMuaXRlbURpc3RhbmNlLCAyMCkgOiAwLFxuXHRcdFx0XHRsdHIgPSAhb3B0aW9ucy5ydGwsXG5cdFx0XHRcdGl0ZW1IZWlnaHQsXG5cdFx0XHRcdHdpZHRoT3B0aW9uID0gb3B0aW9ucy53aWR0aCxcblx0XHRcdFx0aXRlbU1hcmdpbkJvdHRvbSA9IG9wdGlvbnMuaXRlbU1hcmdpbkJvdHRvbSB8fCAwLFxuXHRcdFx0XHRpdGVtTWFyZ2luVG9wID0gbGVnZW5kLml0ZW1NYXJnaW5Ub3AsXG5cdFx0XHRcdGluaXRpYWxJdGVtWCA9IGxlZ2VuZC5pbml0aWFsSXRlbVgsXG5cdFx0XHRcdGJCb3gsXG5cdFx0XHRcdGl0ZW1XaWR0aCxcblx0XHRcdFx0bGkgPSBpdGVtLmxlZ2VuZEl0ZW0sXG5cdFx0XHRcdHNlcmllcyA9IGl0ZW0uc2VyaWVzICYmIGl0ZW0uc2VyaWVzLmRyYXdMZWdlbmRTeW1ib2wgPyBpdGVtLnNlcmllcyA6IGl0ZW0sXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0c2hvd0NoZWNrYm94ID0gbGVnZW5kLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbSAmJiBzZXJpZXNPcHRpb25zICYmIHNlcmllc09wdGlvbnMuc2hvd0NoZWNrYm94LFxuXHRcdFx0XHR1c2VIVE1MID0gb3B0aW9ucy51c2VIVE1MO1xuXG5cdFx0XHRpZiAoIWxpKSB7IC8vIGdlbmVyYXRlIGl0IG9uY2UsIGxhdGVyIG1vdmUgaXRcblxuXHRcdFx0XHQvLyBHZW5lcmF0ZSB0aGUgZ3JvdXAgYm94XG5cdFx0XHRcdC8vIEEgZ3JvdXAgdG8gaG9sZCB0aGUgc3ltYm9sIGFuZCB0ZXh0LiBUZXh0IGlzIHRvIGJlIGFwcGVuZGVkIGluIExlZ2VuZCBjbGFzcy5cblx0XHRcdFx0aXRlbS5sZWdlbmRHcm91cCA9IHJlbmRlcmVyLmcoJ2xlZ2VuZC1pdGVtJylcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogMSB9KVxuXHRcdFx0XHRcdC5hZGQobGVnZW5kLnNjcm9sbEdyb3VwKTtcblxuXHRcdFx0XHQvLyBHZW5lcmF0ZSB0aGUgbGlzdCBpdGVtIHRleHQgYW5kIGFkZCBpdCB0byB0aGUgZ3JvdXBcblx0XHRcdFx0aXRlbS5sZWdlbmRJdGVtID0gbGkgPSByZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5sYWJlbEZvcm1hdCA/IGZvcm1hdChvcHRpb25zLmxhYmVsRm9ybWF0LCBpdGVtKSA6IG9wdGlvbnMubGFiZWxGb3JtYXR0ZXIuY2FsbChpdGVtKSxcblx0XHRcdFx0XHRcdGx0ciA/IHN5bWJvbFdpZHRoICsgc3ltYm9sUGFkZGluZyA6IC1zeW1ib2xQYWRkaW5nLFxuXHRcdFx0XHRcdFx0bGVnZW5kLmJhc2VsaW5lIHx8IDAsXG5cdFx0XHRcdFx0XHR1c2VIVE1MXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5jc3MobWVyZ2UoaXRlbS52aXNpYmxlID8gaXRlbVN0eWxlIDogaXRlbUhpZGRlblN0eWxlKSkgLy8gbWVyZ2UgdG8gcHJldmVudCBtb2RpZnlpbmcgb3JpZ2luYWwgKCMxMDIxKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdGFsaWduOiBsdHIgPyAnbGVmdCcgOiAncmlnaHQnLFxuXHRcdFx0XHRcdFx0ekluZGV4OiAyXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYWRkKGl0ZW0ubGVnZW5kR3JvdXApO1xuXG5cdFx0XHRcdC8vIEdldCB0aGUgYmFzZWxpbmUgZm9yIHRoZSBmaXJzdCBpdGVtIC0gdGhlIGZvbnQgc2l6ZSBpcyBlcXVhbCBmb3IgYWxsXG5cdFx0XHRcdGlmICghbGVnZW5kLmJhc2VsaW5lKSB7XG5cdFx0XHRcdFx0bGVnZW5kLmJhc2VsaW5lID0gcmVuZGVyZXIuZm9udE1ldHJpY3MoaXRlbVN0eWxlLmZvbnRTaXplLCBsaSkuZiArIDMgKyBpdGVtTWFyZ2luVG9wO1xuXHRcdFx0XHRcdGxpLmF0dHIoJ3knLCBsZWdlbmQuYmFzZWxpbmUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRHJhdyB0aGUgbGVnZW5kIHN5bWJvbCBpbnNpZGUgdGhlIGdyb3VwIGJveFxuXHRcdFx0XHRzZXJpZXMuZHJhd0xlZ2VuZFN5bWJvbChsZWdlbmQsIGl0ZW0pO1xuXG5cdFx0XHRcdGlmIChsZWdlbmQuc2V0SXRlbUV2ZW50cykge1xuXHRcdFx0XHRcdGxlZ2VuZC5zZXRJdGVtRXZlbnRzKGl0ZW0sIGxpLCB1c2VIVE1MLCBpdGVtU3R5bGUsIGl0ZW1IaWRkZW5TdHlsZSk7XG5cdFx0XHRcdH1cdFx0XHRcblxuXHRcdFx0XHQvLyBDb2xvcml6ZSB0aGUgaXRlbXNcblx0XHRcdFx0bGVnZW5kLmNvbG9yaXplSXRlbShpdGVtLCBpdGVtLnZpc2libGUpO1xuXG5cdFx0XHRcdC8vIGFkZCB0aGUgSFRNTCBjaGVja2JveCBvbiB0b3Bcblx0XHRcdFx0aWYgKHNob3dDaGVja2JveCkge1xuXHRcdFx0XHRcdGxlZ2VuZC5jcmVhdGVDaGVja2JveEZvckl0ZW0oaXRlbSk7XHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHBvc2l0aW9ucyBmb3IgdGhlIG5leHQgbGluZVxuXHRcdFx0YkJveCA9IGxpLmdldEJCb3goKTtcblxuXHRcdFx0aXRlbVdpZHRoID0gaXRlbS5jaGVja2JveE9mZnNldCA9IFxuXHRcdFx0XHRvcHRpb25zLml0ZW1XaWR0aCB8fCBcblx0XHRcdFx0aXRlbS5sZWdlbmRJdGVtV2lkdGggfHwgXG5cdFx0XHRcdHN5bWJvbFdpZHRoICsgc3ltYm9sUGFkZGluZyArIGJCb3gud2lkdGggKyBpdGVtRGlzdGFuY2UgKyAoc2hvd0NoZWNrYm94ID8gMjAgOiAwKTtcblx0XHRcdGxlZ2VuZC5pdGVtSGVpZ2h0ID0gaXRlbUhlaWdodCA9IG1hdGhSb3VuZChpdGVtLmxlZ2VuZEl0ZW1IZWlnaHQgfHwgYkJveC5oZWlnaHQpO1xuXG5cdFx0XHQvLyBpZiB0aGUgaXRlbSBleGNlZWRzIHRoZSB3aWR0aCwgc3RhcnQgYSBuZXcgbGluZVxuXHRcdFx0aWYgKGhvcml6b250YWwgJiYgbGVnZW5kLml0ZW1YIC0gaW5pdGlhbEl0ZW1YICsgaXRlbVdpZHRoID5cblx0XHRcdFx0XHQod2lkdGhPcHRpb24gfHwgKGNoYXJ0LmNoYXJ0V2lkdGggLSAyICogcGFkZGluZyAtIGluaXRpYWxJdGVtWCAtIG9wdGlvbnMueCkpKSB7XG5cdFx0XHRcdGxlZ2VuZC5pdGVtWCA9IGluaXRpYWxJdGVtWDtcblx0XHRcdFx0bGVnZW5kLml0ZW1ZICs9IGl0ZW1NYXJnaW5Ub3AgKyBsZWdlbmQubGFzdExpbmVIZWlnaHQgKyBpdGVtTWFyZ2luQm90dG9tO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgaXRlbSBleGNlZWRzIHRoZSBoZWlnaHQsIHN0YXJ0IGEgbmV3IGNvbHVtblxuXHRcdFx0LyppZiAoIWhvcml6b250YWwgJiYgbGVnZW5kLml0ZW1ZICsgb3B0aW9ucy55ICsgaXRlbUhlaWdodCA+IGNoYXJ0LmNoYXJ0SGVpZ2h0IC0gc3BhY2luZ1RvcCAtIHNwYWNpbmdCb3R0b20pIHtcblx0XHRcdFx0bGVnZW5kLml0ZW1ZID0gbGVnZW5kLmluaXRpYWxJdGVtWTtcblx0XHRcdFx0bGVnZW5kLml0ZW1YICs9IGxlZ2VuZC5tYXhJdGVtV2lkdGg7XG5cdFx0XHRcdGxlZ2VuZC5tYXhJdGVtV2lkdGggPSAwO1xuXHRcdFx0fSovXG5cblx0XHRcdC8vIFNldCB0aGUgZWRnZSBwb3NpdGlvbnNcblx0XHRcdGxlZ2VuZC5tYXhJdGVtV2lkdGggPSBtYXRoTWF4KGxlZ2VuZC5tYXhJdGVtV2lkdGgsIGl0ZW1XaWR0aCk7XG5cdFx0XHRsZWdlbmQubGFzdEl0ZW1ZID0gaXRlbU1hcmdpblRvcCArIGxlZ2VuZC5pdGVtWSArIGl0ZW1NYXJnaW5Cb3R0b207XG5cdFx0XHRsZWdlbmQubGFzdExpbmVIZWlnaHQgPSBtYXRoTWF4KGl0ZW1IZWlnaHQsIGxlZ2VuZC5sYXN0TGluZUhlaWdodCk7IC8vICM5MTVcblxuXHRcdFx0Ly8gY2FjaGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXdseSBnZW5lcmF0ZWQgb3IgcmVvcmRlcmVkIGl0ZW1zXG5cdFx0XHRpdGVtLl9sZWdlbmRJdGVtUG9zID0gW2xlZ2VuZC5pdGVtWCwgbGVnZW5kLml0ZW1ZXTtcblxuXHRcdFx0Ly8gYWR2YW5jZVxuXHRcdFx0aWYgKGhvcml6b250YWwpIHtcblx0XHRcdFx0bGVnZW5kLml0ZW1YICs9IGl0ZW1XaWR0aDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGVnZW5kLml0ZW1ZICs9IGl0ZW1NYXJnaW5Ub3AgKyBpdGVtSGVpZ2h0ICsgaXRlbU1hcmdpbkJvdHRvbTtcblx0XHRcdFx0bGVnZW5kLmxhc3RMaW5lSGVpZ2h0ID0gaXRlbUhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhlIHdpZHRoIG9mIHRoZSB3aWRlc3QgaXRlbVxuXHRcdFx0bGVnZW5kLm9mZnNldFdpZHRoID0gd2lkdGhPcHRpb24gfHwgbWF0aE1heChcblx0XHRcdFx0KGhvcml6b250YWwgPyBsZWdlbmQuaXRlbVggLSBpbml0aWFsSXRlbVggLSBpdGVtRGlzdGFuY2UgOiBpdGVtV2lkdGgpICsgcGFkZGluZyxcblx0XHRcdFx0bGVnZW5kLm9mZnNldFdpZHRoXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgYWxsIGl0ZW1zLCB3aGljaCBpcyBvbmUgaXRlbSBwZXIgc2VyaWVzIGZvciBub3JtYWwgc2VyaWVzIGFuZCBvbmUgaXRlbSBwZXIgcG9pbnRcblx0XHQgKiBmb3IgcGllIHNlcmllcy5cblx0XHQgKi9cblx0XHRnZXRBbGxJdGVtczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGFsbEl0ZW1zID0gW107XG5cdFx0XHRlYWNoKHRoaXMuY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdHZhciBzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnM7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHNob3dJbkxlZ2VuZC4gSWYgdGhlIHNlcmllcyBpcyBsaW5rZWQgdG8gYW5vdGhlciBzZXJpZXMsIGRlZmF1bHRzIHRvIGZhbHNlLlxuXHRcdFx0XHRpZiAoIXBpY2soc2VyaWVzT3B0aW9ucy5zaG93SW5MZWdlbmQsICFkZWZpbmVkKHNlcmllc09wdGlvbnMubGlua2VkVG8pID8gVU5ERUZJTkVEIDogZmFsc2UsIHRydWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXNlIHBvaW50cyBvciBzZXJpZXMgZm9yIHRoZSBsZWdlbmQgaXRlbSBkZXBlbmRpbmcgb24gbGVnZW5kVHlwZVxuXHRcdFx0XHRhbGxJdGVtcyA9IGFsbEl0ZW1zLmNvbmNhdChcblx0XHRcdFx0XHRcdHNlcmllcy5sZWdlbmRJdGVtcyB8fFxuXHRcdFx0XHRcdFx0KHNlcmllc09wdGlvbnMubGVnZW5kVHlwZSA9PT0gJ3BvaW50JyA/XG5cdFx0XHRcdFx0XHRcdFx0c2VyaWVzLmRhdGEgOlxuXHRcdFx0XHRcdFx0XHRcdHNlcmllcylcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGFsbEl0ZW1zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGp1c3QgdGhlIGNoYXJ0IG1hcmdpbnMgYnkgcmVzZXJ2aW5nIHNwYWNlIGZvciB0aGUgbGVnZW5kIG9uIG9ubHkgb25lIHNpZGVcblx0XHQgKiBvZiB0aGUgY2hhcnQuIElmIHRoZSBwb3NpdGlvbiBpcyBzZXQgdG8gYSBjb3JuZXIsIHRvcCBvciBib3R0b20gaXMgcmVzZXJ2ZWRcblx0XHQgKiBmb3IgaG9yaXpvbnRhbCBsZWdlbmRzIGFuZCBsZWZ0IG9yIHJpZ2h0IGZvciB2ZXJ0aWNhbCBvbmVzLlxuXHRcdCAqL1xuXHRcdGFkanVzdE1hcmdpbnM6IGZ1bmN0aW9uIChtYXJnaW4sIHNwYWNpbmcpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsIFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHQvLyBVc2UgdGhlIGZpcnN0IGxldHRlciBvZiBlYWNoIGFsaWdubWVudCBvcHRpb24gaW4gb3JkZXIgdG8gZGV0ZWN0IHRoZSBzaWRlIFxuXHRcdFx0XHRhbGlnbm1lbnQgPSBvcHRpb25zLmFsaWduWzBdICsgb3B0aW9ucy52ZXJ0aWNhbEFsaWduWzBdICsgb3B0aW9ucy5sYXlvdXRbMF07XG5cdFx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuZGlzcGxheSAmJiAhb3B0aW9ucy5mbG9hdGluZykge1xuXG5cdFx0XHRcdGVhY2goW1xuXHRcdFx0XHRcdC8obHRofGN0fHJ0aCkvLFxuXHRcdFx0XHRcdC8ocnR2fHJtfHJidikvLFxuXHRcdFx0XHRcdC8ocmJofGNifGxiaCkvLFxuXHRcdFx0XHRcdC8obGJ2fGxtfGx0dikvXG5cdFx0XHRcdF0sIGZ1bmN0aW9uIChhbGlnbm1lbnRzLCBzaWRlKSB7XG5cdFx0XHRcdFx0aWYgKGFsaWdubWVudHMudGVzdChhbGlnbm1lbnQpICYmICFkZWZpbmVkKG1hcmdpbltzaWRlXSkpIHtcblx0XHRcdFx0XHRcdC8vIE5vdyB3ZSBoYXZlIGRldGVjdGVkIG9uIHdoaWNoIHNpZGUgb2YgdGhlIGNoYXJ0IHdlIHNob3VsZCByZXNlcnZlIHNwYWNlIGZvciB0aGUgbGVnZW5kXG5cdFx0XHRcdFx0XHRjaGFydFttYXJnaW5OYW1lc1tzaWRlXV0gPSBtYXRoTWF4KFxuXHRcdFx0XHRcdFx0XHRjaGFydFttYXJnaW5OYW1lc1tzaWRlXV0sXG5cdFx0XHRcdFx0XHRcdGNoYXJ0LmxlZ2VuZFsoc2lkZSArIDEpICUgMiA/ICdsZWdlbmRIZWlnaHQnIDogJ2xlZ2VuZFdpZHRoJ10gKyBcblx0XHRcdFx0XHRcdFx0XHRbMSwgLTEsIC0xLCAxXVtzaWRlXSAqIG9wdGlvbnNbKHNpZGUgJSAyKSA/ICd4JyA6ICd5J10gKyBcblx0XHRcdFx0XHRcdFx0XHRwaWNrKG9wdGlvbnMubWFyZ2luLCAxMikgK1xuXHRcdFx0XHRcdFx0XHRcdHNwYWNpbmdbc2lkZV1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIHRoZSBsZWdlbmQuIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgYm90aCBiZWZvcmUgYW5kIGFmdGVyXG5cdFx0ICogY2hhcnQucmVuZGVyLiBJZiBjYWxsZWQgYWZ0ZXIsIGl0IHdpbGwgb25seSByZWFycmFuZ2UgaXRlbXMgaW5zdGVhZFxuXHRcdCAqIG9mIGNyZWF0aW5nIG5ldyBvbmVzLlxuXHRcdCAqL1xuXHRcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gbGVnZW5kLmNoYXJ0LFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRsZWdlbmRHcm91cCA9IGxlZ2VuZC5ncm91cCxcblx0XHRcdFx0YWxsSXRlbXMsXG5cdFx0XHRcdGRpc3BsYXksXG5cdFx0XHRcdGxlZ2VuZFdpZHRoLFxuXHRcdFx0XHRsZWdlbmRIZWlnaHQsXG5cdFx0XHRcdGJveCA9IGxlZ2VuZC5ib3gsXG5cdFx0XHRcdG9wdGlvbnMgPSBsZWdlbmQub3B0aW9ucyxcblx0XHRcdFx0cGFkZGluZyA9IGxlZ2VuZC5wYWRkaW5nLFxuXHRcdFx0XHRsZWdlbmRCb3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGxlZ2VuZEJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuXG5cdFx0XHRsZWdlbmQuaXRlbVggPSBsZWdlbmQuaW5pdGlhbEl0ZW1YO1xuXHRcdFx0bGVnZW5kLml0ZW1ZID0gbGVnZW5kLmluaXRpYWxJdGVtWTtcblx0XHRcdGxlZ2VuZC5vZmZzZXRXaWR0aCA9IDA7XG5cdFx0XHRsZWdlbmQubGFzdEl0ZW1ZID0gMDtcblxuXHRcdFx0aWYgKCFsZWdlbmRHcm91cCkge1xuXHRcdFx0XHRsZWdlbmQuZ3JvdXAgPSBsZWdlbmRHcm91cCA9IHJlbmRlcmVyLmcoJ2xlZ2VuZCcpXG5cdFx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IDcgfSkgXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0XHRsZWdlbmQuY29udGVudEdyb3VwID0gcmVuZGVyZXIuZygpXG5cdFx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IDEgfSkgLy8gYWJvdmUgYmFja2dyb3VuZFxuXHRcdFx0XHRcdC5hZGQobGVnZW5kR3JvdXApO1xuXHRcdFx0XHRsZWdlbmQuc2Nyb2xsR3JvdXAgPSByZW5kZXJlci5nKClcblx0XHRcdFx0XHQuYWRkKGxlZ2VuZC5jb250ZW50R3JvdXApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRsZWdlbmQucmVuZGVyVGl0bGUoKTtcblxuXHRcdFx0Ly8gYWRkIGVhY2ggc2VyaWVzIG9yIHBvaW50XG5cdFx0XHRhbGxJdGVtcyA9IGxlZ2VuZC5nZXRBbGxJdGVtcygpO1xuXG5cdFx0XHQvLyBzb3J0IGJ5IGxlZ2VuZEluZGV4XG5cdFx0XHRzdGFibGVTb3J0KGFsbEl0ZW1zLCBmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gKChhLm9wdGlvbnMgJiYgYS5vcHRpb25zLmxlZ2VuZEluZGV4KSB8fCAwKSAtICgoYi5vcHRpb25zICYmIGIub3B0aW9ucy5sZWdlbmRJbmRleCkgfHwgMCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmV2ZXJzZWQgbGVnZW5kXG5cdFx0XHRpZiAob3B0aW9ucy5yZXZlcnNlZCkge1xuXHRcdFx0XHRhbGxJdGVtcy5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGxlZ2VuZC5hbGxJdGVtcyA9IGFsbEl0ZW1zO1xuXHRcdFx0bGVnZW5kLmRpc3BsYXkgPSBkaXNwbGF5ID0gISFhbGxJdGVtcy5sZW5ndGg7XG5cblx0XHRcdC8vIHJlbmRlciB0aGUgaXRlbXNcblx0XHRcdGxlZ2VuZC5sYXN0TGluZUhlaWdodCA9IDA7XG5cdFx0XHRlYWNoKGFsbEl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRsZWdlbmQucmVuZGVySXRlbShpdGVtKTsgXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gR2V0IHRoZSBib3hcblx0XHRcdGxlZ2VuZFdpZHRoID0gKG9wdGlvbnMud2lkdGggfHwgbGVnZW5kLm9mZnNldFdpZHRoKSArIHBhZGRpbmc7XG5cdFx0XHRsZWdlbmRIZWlnaHQgPSBsZWdlbmQubGFzdEl0ZW1ZICsgbGVnZW5kLmxhc3RMaW5lSGVpZ2h0ICsgbGVnZW5kLnRpdGxlSGVpZ2h0O1xuXHRcdFx0bGVnZW5kSGVpZ2h0ID0gbGVnZW5kLmhhbmRsZU92ZXJmbG93KGxlZ2VuZEhlaWdodCk7XG5cdFx0XHRsZWdlbmRIZWlnaHQgKz0gcGFkZGluZztcblxuXHRcdFx0Ly8gRHJhdyB0aGUgYm9yZGVyIGFuZC9vciBiYWNrZ3JvdW5kXG5cdFx0XHRpZiAobGVnZW5kQm9yZGVyV2lkdGggfHwgbGVnZW5kQmFja2dyb3VuZENvbG9yKSB7XG5cblx0XHRcdFx0aWYgKCFib3gpIHtcblx0XHRcdFx0XHRsZWdlbmQuYm94ID0gYm94ID0gcmVuZGVyZXIucmVjdChcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0bGVnZW5kV2lkdGgsXG5cdFx0XHRcdFx0XHRsZWdlbmRIZWlnaHQsXG5cdFx0XHRcdFx0XHRvcHRpb25zLmJvcmRlclJhZGl1cyxcblx0XHRcdFx0XHRcdGxlZ2VuZEJvcmRlcldpZHRoIHx8IDBcblx0XHRcdFx0XHQpLmF0dHIoe1xuXHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGxlZ2VuZEJvcmRlcldpZHRoIHx8IDAsXG5cdFx0XHRcdFx0XHRmaWxsOiBsZWdlbmRCYWNrZ3JvdW5kQ29sb3IgfHwgTk9ORVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZChsZWdlbmRHcm91cClcblx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnMuc2hhZG93KTtcblx0XHRcdFx0XHRib3guaXNOZXcgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAobGVnZW5kV2lkdGggPiAwICYmIGxlZ2VuZEhlaWdodCA+IDApIHtcblx0XHRcdFx0XHRib3hbYm94LmlzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXShcblx0XHRcdFx0XHRcdGJveC5jcmlzcCh7IHdpZHRoOiBsZWdlbmRXaWR0aCwgaGVpZ2h0OiBsZWdlbmRIZWlnaHQgfSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJveC5pc05ldyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaGlkZSB0aGUgYm9yZGVyIGlmIG5vIGl0ZW1zXG5cdFx0XHRcdGJveFtkaXNwbGF5ID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRsZWdlbmQubGVnZW5kV2lkdGggPSBsZWdlbmRXaWR0aDtcblx0XHRcdGxlZ2VuZC5sZWdlbmRIZWlnaHQgPSBsZWdlbmRIZWlnaHQ7XG5cblx0XHRcdC8vIE5vdyB0aGF0IHRoZSBsZWdlbmQgd2lkdGggYW5kIGhlaWdodCBhcmUgZXN0YWJsaXNoZWQsIHB1dCB0aGUgaXRlbXMgaW4gdGhlIFxuXHRcdFx0Ly8gZmluYWwgcG9zaXRpb25cblx0XHRcdGVhY2goYWxsSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRcdGxlZ2VuZC5wb3NpdGlvbkl0ZW0oaXRlbSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gMS54IGNvbXBhdGliaWxpdHk6IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHN0eWxlXG5cdFx0XHQvKnZhciBwcm9wcyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG5cdFx0XHRcdHByb3AsXG5cdFx0XHRcdGkgPSA0O1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRwcm9wID0gcHJvcHNbaV07XG5cdFx0XHRcdGlmIChvcHRpb25zLnN0eWxlW3Byb3BdICYmIG9wdGlvbnMuc3R5bGVbcHJvcF0gIT09ICdhdXRvJykge1xuXHRcdFx0XHRcdG9wdGlvbnNbaSA8IDIgPyAnYWxpZ24nIDogJ3ZlcnRpY2FsQWxpZ24nXSA9IHByb3A7XG5cdFx0XHRcdFx0b3B0aW9uc1tpIDwgMiA/ICd4JyA6ICd5J10gPSBwSW50KG9wdGlvbnMuc3R5bGVbcHJvcF0pICogKGkgJSAyID8gLTEgOiAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSovXG5cblx0XHRcdGlmIChkaXNwbGF5KSB7XG5cdFx0XHRcdGxlZ2VuZEdyb3VwLmFsaWduKGV4dGVuZCh7XG5cdFx0XHRcdFx0d2lkdGg6IGxlZ2VuZFdpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogbGVnZW5kSGVpZ2h0XG5cdFx0XHRcdH0sIG9wdGlvbnMpLCB0cnVlLCAnc3BhY2luZ0JveCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWNoYXJ0LmlzUmVzaXppbmcpIHtcblx0XHRcdFx0dGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNldCB1cCB0aGUgb3ZlcmZsb3cgaGFuZGxpbmcgYnkgYWRkaW5nIG5hdmlnYXRpb24gd2l0aCB1cCBhbmQgZG93biBhcnJvd3MgYmVsb3cgdGhlXG5cdFx0ICogbGVnZW5kLlxuXHRcdCAqL1xuXHRcdGhhbmRsZU92ZXJmbG93OiBmdW5jdGlvbiAobGVnZW5kSGVpZ2h0KSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRvcHRpb25zWSA9IG9wdGlvbnMueSxcblx0XHRcdFx0YWxpZ25Ub3AgPSBvcHRpb25zLnZlcnRpY2FsQWxpZ24gPT09ICd0b3AnLFxuXHRcdFx0XHRzcGFjZUhlaWdodCA9IGNoYXJ0LnNwYWNpbmdCb3guaGVpZ2h0ICsgKGFsaWduVG9wID8gLW9wdGlvbnNZIDogb3B0aW9uc1kpIC0gdGhpcy5wYWRkaW5nLFxuXHRcdFx0XHRtYXhIZWlnaHQgPSBvcHRpb25zLm1heEhlaWdodCxcblx0XHRcdFx0Y2xpcEhlaWdodCxcblx0XHRcdFx0Y2xpcFJlY3QgPSB0aGlzLmNsaXBSZWN0LFxuXHRcdFx0XHRuYXZPcHRpb25zID0gb3B0aW9ucy5uYXZpZ2F0aW9uLFxuXHRcdFx0XHRhbmltYXRpb24gPSBwaWNrKG5hdk9wdGlvbnMuYW5pbWF0aW9uLCB0cnVlKSxcblx0XHRcdFx0YXJyb3dTaXplID0gbmF2T3B0aW9ucy5hcnJvd1NpemUgfHwgMTIsXG5cdFx0XHRcdG5hdiA9IHRoaXMubmF2LFxuXHRcdFx0XHRwYWdlcyA9IHRoaXMucGFnZXMsXG5cdFx0XHRcdGxhc3RZLFxuXHRcdFx0XHRhbGxJdGVtcyA9IHRoaXMuYWxsSXRlbXM7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gQWRqdXN0IHRoZSBoZWlnaHRcblx0XHRcdGlmIChvcHRpb25zLmxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG5cdFx0XHRcdHNwYWNlSGVpZ2h0IC89IDI7XG5cdFx0XHR9XG5cdFx0XHRpZiAobWF4SGVpZ2h0KSB7XG5cdFx0XHRcdHNwYWNlSGVpZ2h0ID0gbWF0aE1pbihzcGFjZUhlaWdodCwgbWF4SGVpZ2h0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gUmVzZXQgdGhlIGxlZ2VuZCBoZWlnaHQgYW5kIGFkanVzdCB0aGUgY2xpcHBpbmcgcmVjdGFuZ2xlXG5cdFx0XHRwYWdlcy5sZW5ndGggPSAwO1xuXHRcdFx0aWYgKGxlZ2VuZEhlaWdodCA+IHNwYWNlSGVpZ2h0ICYmICFvcHRpb25zLnVzZUhUTUwpIHtcblxuXHRcdFx0XHR0aGlzLmNsaXBIZWlnaHQgPSBjbGlwSGVpZ2h0ID0gbWF0aE1heChzcGFjZUhlaWdodCAtIDIwIC0gdGhpcy50aXRsZUhlaWdodCAtIHRoaXMucGFkZGluZywgMCk7XG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBwaWNrKHRoaXMuY3VycmVudFBhZ2UsIDEpO1xuXHRcdFx0XHR0aGlzLmZ1bGxIZWlnaHQgPSBsZWdlbmRIZWlnaHQ7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBGaWxsIHBhZ2VzIHdpdGggWSBwb3NpdGlvbnMgc28gdGhhdCB0aGUgdG9wIG9mIGVhY2ggYSBsZWdlbmQgaXRlbSBkZWZpbmVzXG5cdFx0XHRcdC8vIHRoZSBzY3JvbGwgdG9wIGZvciBlYWNoIHBhZ2UgKCMyMDk4KVxuXHRcdFx0XHRlYWNoKGFsbEl0ZW1zLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xuXHRcdFx0XHRcdHZhciB5ID0gaXRlbS5fbGVnZW5kSXRlbVBvc1sxXSxcblx0XHRcdFx0XHRcdGggPSBtYXRoUm91bmQoaXRlbS5sZWdlbmRJdGVtLmdldEJCb3goKS5oZWlnaHQpLFxuXHRcdFx0XHRcdFx0bGVuID0gcGFnZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICghbGVuIHx8ICh5IC0gcGFnZXNbbGVuIC0gMV0gPiBjbGlwSGVpZ2h0ICYmIChsYXN0WSB8fCB5KSAhPT0gcGFnZXNbbGVuIC0gMV0pKSB7XG5cdFx0XHRcdFx0XHRwYWdlcy5wdXNoKGxhc3RZIHx8IHkpO1xuXHRcdFx0XHRcdFx0bGVuKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpID09PSBhbGxJdGVtcy5sZW5ndGggLSAxICYmIHkgKyBoIC0gcGFnZXNbbGVuIC0gMV0gPiBjbGlwSGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRwYWdlcy5wdXNoKHkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeSAhPT0gbGFzdFkpIHtcblx0XHRcdFx0XHRcdGxhc3RZID0geTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIE9ubHkgYXBwbHkgY2xpcHBpbmcgaWYgbmVlZGVkLiBDbGlwcGluZyBjYXVzZXMgYmx1cnJlZCBsZWdlbmQgaW4gUERGIGV4cG9ydCAoIzE3ODcpXG5cdFx0XHRcdGlmICghY2xpcFJlY3QpIHtcblx0XHRcdFx0XHRjbGlwUmVjdCA9IGxlZ2VuZC5jbGlwUmVjdCA9IHJlbmRlcmVyLmNsaXBSZWN0KDAsIHRoaXMucGFkZGluZywgOTk5OSwgMCk7XG5cdFx0XHRcdFx0bGVnZW5kLmNvbnRlbnRHcm91cC5jbGlwKGNsaXBSZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGlwUmVjdC5hdHRyKHtcblx0XHRcdFx0XHRoZWlnaHQ6IGNsaXBIZWlnaHRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBZGQgbmF2aWdhdGlvbiBlbGVtZW50c1xuXHRcdFx0XHRpZiAoIW5hdikge1xuXHRcdFx0XHRcdHRoaXMubmF2ID0gbmF2ID0gcmVuZGVyZXIuZygpLmF0dHIoeyB6SW5kZXg6IDEgfSkuYWRkKHRoaXMuZ3JvdXApO1xuXHRcdFx0XHRcdHRoaXMudXAgPSByZW5kZXJlci5zeW1ib2woJ3RyaWFuZ2xlJywgMCwgMCwgYXJyb3dTaXplLCBhcnJvd1NpemUpXG5cdFx0XHRcdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRsZWdlbmQuc2Nyb2xsKC0xLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQobmF2KTtcblx0XHRcdFx0XHR0aGlzLnBhZ2VyID0gcmVuZGVyZXIudGV4dCgnJywgMTUsIDEwKVxuXHRcdFx0XHRcdFx0LmNzcyhuYXZPcHRpb25zLnN0eWxlKVxuXHRcdFx0XHRcdFx0LmFkZChuYXYpO1xuXHRcdFx0XHRcdHRoaXMuZG93biA9IHJlbmRlcmVyLnN5bWJvbCgndHJpYW5nbGUtZG93bicsIDAsIDAsIGFycm93U2l6ZSwgYXJyb3dTaXplKVxuXHRcdFx0XHRcdFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0bGVnZW5kLnNjcm9sbCgxLCBhbmltYXRpb24pO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQobmF2KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gU2V0IGluaXRpYWwgcG9zaXRpb25cblx0XHRcdFx0bGVnZW5kLnNjcm9sbCgwKTtcblx0XHRcdFx0XG5cdFx0XHRcdGxlZ2VuZEhlaWdodCA9IHNwYWNlSGVpZ2h0O1xuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSBpZiAobmF2KSB7XG5cdFx0XHRcdGNsaXBSZWN0LmF0dHIoe1xuXHRcdFx0XHRcdGhlaWdodDogY2hhcnQuY2hhcnRIZWlnaHRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG5hdi5oaWRlKCk7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsR3JvdXAuYXR0cih7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWTogMVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5jbGlwSGVpZ2h0ID0gMDsgLy8gIzEzNzlcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxlZ2VuZEhlaWdodDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNjcm9sbCB0aGUgbGVnZW5kIGJ5IGEgbnVtYmVyIG9mIHBhZ2VzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHNjcm9sbEJ5XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGFuaW1hdGlvblxuXHRcdCAqL1xuXHRcdHNjcm9sbDogZnVuY3Rpb24gKHNjcm9sbEJ5LCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBwYWdlcyA9IHRoaXMucGFnZXMsXG5cdFx0XHRcdHBhZ2VDb3VudCA9IHBhZ2VzLmxlbmd0aCxcblx0XHRcdFx0Y3VycmVudFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlICsgc2Nyb2xsQnksXG5cdFx0XHRcdGNsaXBIZWlnaHQgPSB0aGlzLmNsaXBIZWlnaHQsXG5cdFx0XHRcdG5hdk9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbixcblx0XHRcdFx0YWN0aXZlQ29sb3IgPSBuYXZPcHRpb25zLmFjdGl2ZUNvbG9yLFxuXHRcdFx0XHRpbmFjdGl2ZUNvbG9yID0gbmF2T3B0aW9ucy5pbmFjdGl2ZUNvbG9yLFxuXHRcdFx0XHRwYWdlciA9IHRoaXMucGFnZXIsXG5cdFx0XHRcdHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcsXG5cdFx0XHRcdHNjcm9sbE9mZnNldDtcblx0XHRcdFxuXHRcdFx0Ly8gV2hlbiByZXNpemluZyB3aGlsZSBsb29raW5nIGF0IHRoZSBsYXN0IHBhZ2Vcblx0XHRcdGlmIChjdXJyZW50UGFnZSA+IHBhZ2VDb3VudCkge1xuXHRcdFx0XHRjdXJyZW50UGFnZSA9IHBhZ2VDb3VudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGN1cnJlbnRQYWdlID4gMCkge1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGFuaW1hdGlvbiAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgdGhpcy5jaGFydCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMubmF2LmF0dHIoe1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVg6IHBhZGRpbmcsXG5cdFx0XHRcdFx0dHJhbnNsYXRlWTogY2xpcEhlaWdodCArIHRoaXMucGFkZGluZyArIDcgKyB0aGlzLnRpdGxlSGVpZ2h0LFxuXHRcdFx0XHRcdHZpc2liaWxpdHk6IFZJU0lCTEVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMudXAuYXR0cih7XG5cdFx0XHRcdFx0XHRmaWxsOiBjdXJyZW50UGFnZSA9PT0gMSA/IGluYWN0aXZlQ29sb3IgOiBhY3RpdmVDb2xvclxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0XHRjdXJzb3I6IGN1cnJlbnRQYWdlID09PSAxID8gJ2RlZmF1bHQnIDogJ3BvaW50ZXInXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdHBhZ2VyLmF0dHIoe1xuXHRcdFx0XHRcdHRleHQ6IGN1cnJlbnRQYWdlICsgJy8nICsgcGFnZUNvdW50XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLmRvd24uYXR0cih7XG5cdFx0XHRcdFx0XHR4OiAxOCArIHRoaXMucGFnZXIuZ2V0QkJveCgpLndpZHRoLCAvLyBhZGp1c3QgdG8gdGV4dCB3aWR0aFxuXHRcdFx0XHRcdFx0ZmlsbDogY3VycmVudFBhZ2UgPT09IHBhZ2VDb3VudCA/IGluYWN0aXZlQ29sb3IgOiBhY3RpdmVDb2xvclxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0XHRjdXJzb3I6IGN1cnJlbnRQYWdlID09PSBwYWdlQ291bnQgPyAnZGVmYXVsdCcgOiAncG9pbnRlcidcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHNjcm9sbE9mZnNldCA9IC1wYWdlc1tjdXJyZW50UGFnZSAtIDFdICsgdGhpcy5pbml0aWFsSXRlbVk7XG5cblx0XHRcdFx0dGhpcy5zY3JvbGxHcm91cC5hbmltYXRlKHtcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiBzY3JvbGxPZmZzZXRcblx0XHRcdFx0fSk7XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlID0gY3VycmVudFBhZ2U7XG5cdFx0XHRcdHRoaXMucG9zaXRpb25DaGVja2JveGVzKHNjcm9sbE9mZnNldCk7XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdH1cblx0XHRcblx0fTtcblxuXHQvKlxuXHQgKiBMZWdlbmRTeW1ib2xNaXhpblxuXHQgKi8gXG5cblx0dmFyIExlZ2VuZFN5bWJvbE1peGluID0gSGlnaGNoYXJ0cy5MZWdlbmRTeW1ib2xNaXhpbiA9IHtcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgc2VyaWVzJyBzeW1ib2wgaW4gdGhlIGxlZ2VuZFxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBsZWdlbmQgVGhlIGxlZ2VuZCBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgc2VyaWVzICh0aGlzKSBvciBwb2ludFxuXHRcdCAqL1xuXHRcdGRyYXdSZWN0YW5nbGU6IGZ1bmN0aW9uIChsZWdlbmQsIGl0ZW0pIHtcblx0XHRcdHZhciBzeW1ib2xIZWlnaHQgPSBsZWdlbmQub3B0aW9ucy5zeW1ib2xIZWlnaHQgfHwgMTI7XG5cdFx0XHRcblx0XHRcdGl0ZW0ubGVnZW5kU3ltYm9sID0gdGhpcy5jaGFydC5yZW5kZXJlci5yZWN0KFxuXHRcdFx0XHQwLFxuXHRcdFx0XHRsZWdlbmQuYmFzZWxpbmUgLSA1IC0gKHN5bWJvbEhlaWdodCAvIDIpLFxuXHRcdFx0XHRsZWdlbmQuc3ltYm9sV2lkdGgsXG5cdFx0XHRcdHN5bWJvbEhlaWdodCxcblx0XHRcdFx0bGVnZW5kLm9wdGlvbnMuc3ltYm9sUmFkaXVzIHx8IDBcblx0XHRcdCkuYXR0cih7XG5cdFx0XHRcdHpJbmRleDogM1xuXHRcdFx0fSkuYWRkKGl0ZW0ubGVnZW5kR3JvdXApO1x0XHRcblx0XHRcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNlcmllcycgc3ltYm9sIGluIHRoZSBsZWdlbmQuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkYWJsZSB0byBjcmVhdGUgY3VzdG9tIFxuXHRcdCAqIHN5bWJvbHMgdGhyb3VnaCBIaWdoY2hhcnRzLnNlcmllc1R5cGVzW3R5cGVdLnByb3RvdHlwZS5kcmF3TGVnZW5kU3ltYm9scy5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbGVnZW5kIFRoZSBsZWdlbmQgb2JqZWN0XG5cdFx0ICovXG5cdFx0ZHJhd0xpbmVNYXJrZXI6IGZ1bmN0aW9uIChsZWdlbmQpIHtcblxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdG1hcmtlck9wdGlvbnMgPSBvcHRpb25zLm1hcmtlcixcblx0XHRcdFx0cmFkaXVzLFxuXHRcdFx0XHRsZWdlbmRPcHRpb25zID0gbGVnZW5kLm9wdGlvbnMsXG5cdFx0XHRcdGxlZ2VuZFN5bWJvbCxcblx0XHRcdFx0c3ltYm9sV2lkdGggPSBsZWdlbmQuc3ltYm9sV2lkdGgsXG5cdFx0XHRcdHJlbmRlcmVyID0gdGhpcy5jaGFydC5yZW5kZXJlcixcblx0XHRcdFx0bGVnZW5kSXRlbUdyb3VwID0gdGhpcy5sZWdlbmRHcm91cCxcblx0XHRcdFx0dmVydGljYWxDZW50ZXIgPSBsZWdlbmQuYmFzZWxpbmUgLSBtYXRoUm91bmQocmVuZGVyZXIuZm9udE1ldHJpY3MobGVnZW5kT3B0aW9ucy5pdGVtU3R5bGUuZm9udFNpemUsIHRoaXMubGVnZW5kSXRlbSkuYiAqIDAuMyksXG5cdFx0XHRcdGF0dHI7XG5cblx0XHRcdC8vIERyYXcgdGhlIGxpbmVcblx0XHRcdGlmIChvcHRpb25zLmxpbmVXaWR0aCkge1xuXHRcdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBvcHRpb25zLmxpbmVXaWR0aFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAob3B0aW9ucy5kYXNoU3R5bGUpIHtcblx0XHRcdFx0XHRhdHRyLmRhc2hzdHlsZSA9IG9wdGlvbnMuZGFzaFN0eWxlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubGVnZW5kTGluZSA9IHJlbmRlcmVyLnBhdGgoW1xuXHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHR2ZXJ0aWNhbENlbnRlcixcblx0XHRcdFx0XHRMLFxuXHRcdFx0XHRcdHN5bWJvbFdpZHRoLFxuXHRcdFx0XHRcdHZlcnRpY2FsQ2VudGVyXG5cdFx0XHRcdF0pXG5cdFx0XHRcdC5hdHRyKGF0dHIpXG5cdFx0XHRcdC5hZGQobGVnZW5kSXRlbUdyb3VwKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gRHJhdyB0aGUgbWFya2VyXG5cdFx0XHRpZiAobWFya2VyT3B0aW9ucyAmJiBtYXJrZXJPcHRpb25zLmVuYWJsZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHJhZGl1cyA9IG1hcmtlck9wdGlvbnMucmFkaXVzO1xuXHRcdFx0XHR0aGlzLmxlZ2VuZFN5bWJvbCA9IGxlZ2VuZFN5bWJvbCA9IHJlbmRlcmVyLnN5bWJvbChcblx0XHRcdFx0XHR0aGlzLnN5bWJvbCxcblx0XHRcdFx0XHQoc3ltYm9sV2lkdGggLyAyKSAtIHJhZGl1cyxcblx0XHRcdFx0XHR2ZXJ0aWNhbENlbnRlciAtIHJhZGl1cyxcblx0XHRcdFx0XHQyICogcmFkaXVzLFxuXHRcdFx0XHRcdDIgKiByYWRpdXNcblx0XHRcdFx0KVxuXHRcdFx0XHQuYWRkKGxlZ2VuZEl0ZW1Hcm91cCk7XG5cdFx0XHRcdGxlZ2VuZFN5bWJvbC5pc01hcmtlciA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFdvcmthcm91bmQgZm9yICMyMDMwLCBob3Jpem9udGFsIGxlZ2VuZCBpdGVtcyBub3QgZGlzcGxheWluZyBpbiBJRTExIFByZXZpZXcsXG5cdC8vIGFuZCBmb3IgIzI1ODAsIGEgc2ltaWxhciBkcmF3aW5nIGZsYXcgaW4gRmlyZWZveCAyNi5cblx0Ly8gVE9ETzogRXhwbG9yZSBpZiB0aGVyZSdzIGEgZ2VuZXJhbCBjYXVzZSBmb3IgdGhpcy4gVGhlIHByb2JsZW0gbWF5IGJlIHJlbGF0ZWQgXG5cdC8vIHRvIG5lc3RlZCBncm91cCBlbGVtZW50cywgYXMgdGhlIGxlZ2VuZCBpdGVtIHRleHRzIGFyZSB3aXRoaW4gNCBncm91cCBlbGVtZW50cy5cblx0aWYgKC9UcmlkZW50XFwvN1xcLjAvLnRlc3QodXNlckFnZW50KSB8fCBpc0ZpcmVmb3gpIHtcblx0XHR3cmFwKExlZ2VuZC5wcm90b3R5cGUsICdwb3NpdGlvbkl0ZW0nLCBmdW5jdGlvbiAocHJvY2VlZCwgaXRlbSkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRcdHJ1blBvc2l0aW9uSXRlbSA9IGZ1bmN0aW9uICgpIHsgLy8gSWYgY2hhcnQgZGVzdHJveWVkIGluIHN5bmMsIHRoaXMgaXMgdW5kZWZpbmVkICgjMjAzMClcblx0XHRcdFx0XHRpZiAoaXRlbS5fbGVnZW5kSXRlbVBvcykge1xuXHRcdFx0XHRcdFx0cHJvY2VlZC5jYWxsKGxlZ2VuZCwgaXRlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBEbyBpdCBub3csIGZvciBleHBvcnQgYW5kIHRvIGdldCBjaGVja2JveCBwbGFjZW1lbnRcblx0XHRcdHJ1blBvc2l0aW9uSXRlbSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBEbyBpdCBhZnRlciB0byB3b3JrIGFyb3VuZCB0aGUgY29yZSBpc3N1ZVxuXHRcdFx0c2V0VGltZW91dChydW5Qb3NpdGlvbkl0ZW0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQgKiBUaGUgY2hhcnQgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIGNoYXJ0IGhhcyBsb2FkZWRcblx0ICovXG5cdHZhciBDaGFydCA9IEhpZ2hjaGFydHMuQ2hhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0Q2hhcnQucHJvdG90eXBlID0ge1xuXG5cdFx0LyoqXG5cdFx0ICogSG9vayBmb3IgbW9kdWxlc1xuXHRcdCAqL1xuXHRcdGNhbGxiYWNrczogW10sXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBjaGFydFxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uICh1c2VyT3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRcdFx0Ly8gSGFuZGxlIHJlZ3VsYXIgb3B0aW9uc1xuXHRcdFx0dmFyIG9wdGlvbnMsXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSB1c2VyT3B0aW9ucy5zZXJpZXM7IC8vIHNraXAgbWVyZ2luZyBkYXRhIHBvaW50cyB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuXG5cdFx0XHR1c2VyT3B0aW9ucy5zZXJpZXMgPSBudWxsO1xuXHRcdFx0b3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCB1c2VyT3B0aW9ucyk7IC8vIGRvIHRoZSBtZXJnZVxuXHRcdFx0b3B0aW9ucy5zZXJpZXMgPSB1c2VyT3B0aW9ucy5zZXJpZXMgPSBzZXJpZXNPcHRpb25zOyAvLyBzZXQgYmFjayB0aGUgc2VyaWVzIGRhdGFcblx0XHRcdHRoaXMudXNlck9wdGlvbnMgPSB1c2VyT3B0aW9ucztcblxuXHRcdFx0dmFyIG9wdGlvbnNDaGFydCA9IG9wdGlvbnMuY2hhcnQ7XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSBtYXJnaW4gJiBzcGFjaW5nIGFycmF5XG5cdFx0XHR0aGlzLm1hcmdpbiA9IHRoaXMuc3BsYXNoQXJyYXkoJ21hcmdpbicsIG9wdGlvbnNDaGFydCk7XG5cdFx0XHR0aGlzLnNwYWNpbmcgPSB0aGlzLnNwbGFzaEFycmF5KCdzcGFjaW5nJywgb3B0aW9uc0NoYXJ0KTtcblxuXHRcdFx0dmFyIGNoYXJ0RXZlbnRzID0gb3B0aW9uc0NoYXJ0LmV2ZW50cztcblxuXHRcdFx0Ly90aGlzLnJ1bkNoYXJ0Q2xpY2sgPSBjaGFydEV2ZW50cyAmJiAhIWNoYXJ0RXZlbnRzLmNsaWNrO1xuXHRcdFx0dGhpcy5ib3VuZHMgPSB7IGg6IHt9LCB2OiB7fSB9OyAvLyBQaXhlbCBkYXRhIGJvdW5kcyBmb3IgdG91Y2ggem9vbVxuXG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLmlzUmVzaXppbmcgPSAwO1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdC8vY2hhcnRUaXRsZU9wdGlvbnMgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2NoYXJ0U3VidGl0bGVPcHRpb25zID0gVU5ERUZJTkVEO1xuXG5cdFx0XHR0aGlzLmF4ZXMgPSBbXTtcblx0XHRcdHRoaXMuc2VyaWVzID0gW107XG5cdFx0XHR0aGlzLmhhc0NhcnRlc2lhblNlcmllcyA9IG9wdGlvbnNDaGFydC5zaG93QXhlcztcblx0XHRcdC8vdGhpcy5heGlzT2Zmc2V0ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLm1heFRpY2tzID0gVU5ERUZJTkVEOyAvLyBoYW5kbGUgdGhlIGdyZWF0ZXN0IGFtb3VudCBvZiB0aWNrcyBvbiBncm91cGVkIGF4ZXNcblx0XHRcdC8vdGhpcy5pbnZlcnRlZCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5sb2FkaW5nU2hvd24gPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMuY29udGFpbmVyID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLmNoYXJ0V2lkdGggPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMuY2hhcnRIZWlnaHQgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMubWFyZ2luUmlnaHQgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMubWFyZ2luQm90dG9tID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLmNvbnRhaW5lcldpZHRoID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLmNvbnRhaW5lckhlaWdodCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5vbGRDaGFydFdpZHRoID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLm9sZENoYXJ0SGVpZ2h0ID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvL3RoaXMucmVuZGVyVG8gPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMucmVuZGVyVG9DbG9uZSA9IFVOREVGSU5FRDtcblxuXHRcdFx0Ly90aGlzLnNwYWNpbmdCb3ggPSBVTkRFRklORURcblxuXHRcdFx0Ly90aGlzLmxlZ2VuZCA9IFVOREVGSU5FRDtcblxuXHRcdFx0Ly8gRWxlbWVudHNcblx0XHRcdC8vdGhpcy5jaGFydEJhY2tncm91bmQgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMucGxvdEJhY2tncm91bmQgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMucGxvdEJHSW1hZ2UgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMucGxvdEJvcmRlciA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5sb2FkaW5nRGl2ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLmxvYWRpbmdTcGFuID0gVU5ERUZJTkVEO1xuXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRldmVudFR5cGU7XG5cblx0XHRcdC8vIEFkZCB0aGUgY2hhcnQgdG8gdGhlIGdsb2JhbCBsb29rdXBcblx0XHRcdGNoYXJ0LmluZGV4ID0gY2hhcnRzLmxlbmd0aDtcblx0XHRcdGNoYXJ0cy5wdXNoKGNoYXJ0KTtcblx0XHRcdGNoYXJ0Q291bnQrKztcblxuXHRcdFx0Ly8gU2V0IHVwIGF1dG8gcmVzaXplXG5cdFx0XHRpZiAob3B0aW9uc0NoYXJ0LnJlZmxvdyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0YWRkRXZlbnQoY2hhcnQsICdsb2FkJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGNoYXJ0LmluaXRSZWZsb3coKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYXJ0IGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRpZiAoY2hhcnRFdmVudHMpIHtcblx0XHRcdFx0Zm9yIChldmVudFR5cGUgaW4gY2hhcnRFdmVudHMpIHtcblx0XHRcdFx0XHRhZGRFdmVudChjaGFydCwgZXZlbnRUeXBlLCBjaGFydEV2ZW50c1tldmVudFR5cGVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC54QXhpcyA9IFtdO1xuXHRcdFx0Y2hhcnQueUF4aXMgPSBbXTtcblxuXHRcdFx0Ly8gRXhwb3NlIG1ldGhvZHMgYW5kIHZhcmlhYmxlc1xuXHRcdFx0Y2hhcnQuYW5pbWF0aW9uID0gdXNlQ2FuVkcgPyBmYWxzZSA6IHBpY2sob3B0aW9uc0NoYXJ0LmFuaW1hdGlvbiwgdHJ1ZSk7XG5cdFx0XHRjaGFydC5wb2ludENvdW50ID0gY2hhcnQuY29sb3JDb3VudGVyID0gY2hhcnQuc3ltYm9sQ291bnRlciA9IDA7XG5cblx0XHRcdGNoYXJ0LmZpcnN0UmVuZGVyKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgYW4gaW5kaXZpZHVhbCBzZXJpZXMsIGNhbGxlZCBpbnRlcm5hbGx5IGJlZm9yZSByZW5kZXIgdGltZVxuXHRcdCAqL1xuXHRcdGluaXRTZXJpZXM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zQ2hhcnQgPSBjaGFydC5vcHRpb25zLmNoYXJ0LFxuXHRcdFx0XHR0eXBlID0gb3B0aW9ucy50eXBlIHx8IG9wdGlvbnNDaGFydC50eXBlIHx8IG9wdGlvbnNDaGFydC5kZWZhdWx0U2VyaWVzVHlwZSxcblx0XHRcdFx0c2VyaWVzLFxuXHRcdFx0XHRjb25zdHIgPSBzZXJpZXNUeXBlc1t0eXBlXTtcblxuXHRcdFx0Ly8gTm8gc3VjaCBzZXJpZXMgdHlwZVxuXHRcdFx0aWYgKCFjb25zdHIpIHtcblx0XHRcdFx0ZXJyb3IoMTcsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMgPSBuZXcgY29uc3RyKCk7XG5cdFx0XHRzZXJpZXMuaW5pdCh0aGlzLCBvcHRpb25zKTtcblx0XHRcdHJldHVybiBzZXJpZXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiBwb2ludCBpcyB3aXRoaW4gdGhlIHBsb3QgYXJlYVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBsb3RYIFBpeGVsIHggcmVsYXRpdmUgdG8gdGhlIHBsb3QgYXJlYVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwbG90WSBQaXhlbCB5IHJlbGF0aXZlIHRvIHRoZSBwbG90IGFyZWFcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGludmVydGVkIFdoZXRoZXIgdGhlIGNoYXJ0IGlzIGludmVydGVkXG5cdFx0ICovXG5cdFx0aXNJbnNpZGVQbG90OiBmdW5jdGlvbiAocGxvdFgsIHBsb3RZLCBpbnZlcnRlZCkge1xuXHRcdFx0dmFyIHggPSBpbnZlcnRlZCA/IHBsb3RZIDogcGxvdFgsXG5cdFx0XHRcdHkgPSBpbnZlcnRlZCA/IHBsb3RYIDogcGxvdFk7XG5cdFx0XHRcdFxuXHRcdFx0cmV0dXJuIHggPj0gMCAmJlxuXHRcdFx0XHR4IDw9IHRoaXMucGxvdFdpZHRoICYmXG5cdFx0XHRcdHkgPj0gMCAmJlxuXHRcdFx0XHR5IDw9IHRoaXMucGxvdEhlaWdodDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVkcmF3IGxlZ2VuZCwgYXhlcyBvciBzZXJpZXMgYmFzZWQgb24gdXBkYXRlZCBkYXRhXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHRcdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0XHQgKi9cblx0XHRyZWRyYXc6IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXMsXG5cdFx0XHRcdHBvaW50ZXIgPSBjaGFydC5wb2ludGVyLFxuXHRcdFx0XHRsZWdlbmQgPSBjaGFydC5sZWdlbmQsXG5cdFx0XHRcdHJlZHJhd0xlZ2VuZCA9IGNoYXJ0LmlzRGlydHlMZWdlbmQsXG5cdFx0XHRcdGhhc1N0YWNrZWRTZXJpZXMsXG5cdFx0XHRcdGhhc0RpcnR5U3RhY2tzLFxuXHRcdFx0XHRoYXNDYXJ0ZXNpYW5TZXJpZXMgPSBjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMsXG5cdFx0XHRcdGlzRGlydHlCb3ggPSBjaGFydC5pc0RpcnR5Qm94LCAvLyB0b2RvOiBjaGVjayBpZiBpdCBoYXMgYWN0dWFsbHkgY2hhbmdlZD9cblx0XHRcdFx0c2VyaWVzTGVuZ3RoID0gc2VyaWVzLmxlbmd0aCxcblx0XHRcdFx0aSA9IHNlcmllc0xlbmd0aCxcblx0XHRcdFx0c2VyaWUsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdGlzSGlkZGVuQ2hhcnQgPSByZW5kZXJlci5pc0hpZGRlbigpLFxuXHRcdFx0XHRhZnRlclJlZHJhdyA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KTtcblx0XHRcdFxuXHRcdFx0aWYgKGlzSGlkZGVuQ2hhcnQpIHtcblx0XHRcdFx0Y2hhcnQuY2xvbmVSZW5kZXJUbygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGp1c3QgdGl0bGUgbGF5b3V0IChyZWZsb3cgbXVsdGlsaW5lIHRleHQpXG5cdFx0XHRjaGFydC5sYXlPdXRUaXRsZXMoKTtcblxuXHRcdFx0Ly8gbGluayBzdGFja2VkIHNlcmllc1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzZXJpZSA9IHNlcmllc1tpXTtcblxuXHRcdFx0XHRpZiAoc2VyaWUub3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0XHRcdGhhc1N0YWNrZWRTZXJpZXMgPSB0cnVlO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChzZXJpZS5pc0RpcnR5KSB7XG5cdFx0XHRcdFx0XHRoYXNEaXJ0eVN0YWNrcyA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNEaXJ0eVN0YWNrcykgeyAvLyBtYXJrIG90aGVycyBhcyBkaXJ0eVxuXHRcdFx0XHRpID0gc2VyaWVzTGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0c2VyaWUgPSBzZXJpZXNbaV07XG5cdFx0XHRcdFx0aWYgKHNlcmllLm9wdGlvbnMuc3RhY2tpbmcpIHtcblx0XHRcdFx0XHRcdHNlcmllLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBoYW5kbGUgdXBkYXRlZCBkYXRhIGluIHRoZSBzZXJpZXNcblx0XHRcdGVhY2goc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdFx0aWYgKHNlcmllLmlzRGlydHkpIHsgLy8gcHJlcGFyZSB0aGUgZGF0YSBzbyBheGlzIGNhbiByZWFkIGl0XG5cdFx0XHRcdFx0aWYgKHNlcmllLm9wdGlvbnMubGVnZW5kVHlwZSA9PT0gJ3BvaW50Jykge1xuXHRcdFx0XHRcdFx0cmVkcmF3TGVnZW5kID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBoYW5kbGUgYWRkZWQgb3IgcmVtb3ZlZCBzZXJpZXNcblx0XHRcdGlmIChyZWRyYXdMZWdlbmQgJiYgbGVnZW5kLm9wdGlvbnMuZW5hYmxlZCkgeyAvLyBzZXJpZXMgb3IgcGllIHBvaW50cyBhcmUgYWRkZWQgb3IgcmVtb3ZlZFxuXHRcdFx0XHQvLyBkcmF3IGxlZ2VuZCBncmFwaGljc1xuXHRcdFx0XHRsZWdlbmQucmVuZGVyKCk7XG5cblx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUxlZ2VuZCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXNldCBzdGFja3Ncblx0XHRcdGlmIChoYXNTdGFja2VkU2VyaWVzKSB7XG5cdFx0XHRcdGNoYXJ0LmdldFN0YWNrcygpO1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmIChoYXNDYXJ0ZXNpYW5TZXJpZXMpIHtcblx0XHRcdFx0aWYgKCFjaGFydC5pc1Jlc2l6aW5nKSB7XG5cblx0XHRcdFx0XHQvLyByZXNldCBtYXhUaWNrc1xuXHRcdFx0XHRcdGNoYXJ0Lm1heFRpY2tzID0gbnVsbDtcblxuXHRcdFx0XHRcdC8vIHNldCBheGVzIHNjYWxlc1xuXHRcdFx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRcdGF4aXMuc2V0U2NhbGUoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC5nZXRNYXJnaW5zKCk7IC8vICMzMDk4XG5cblx0XHRcdGlmIChoYXNDYXJ0ZXNpYW5TZXJpZXMpIHtcblx0XHRcdFx0Ly8gSWYgb25lIGF4aXMgaXMgZGlydHksIGFsbCBheGVzIG11c3QgYmUgcmVkcmF3biAoIzc5MiwgIzIxNjkpXG5cdFx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRpZiAoYXhpcy5pc0RpcnR5KSB7XG5cdFx0XHRcdFx0XHRpc0RpcnR5Qm94ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIHJlZHJhdyBheGVzXG5cdFx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBGaXJlICdhZnRlclNldEV4dHJlbWVzJyBvbmx5IGlmIGV4dHJlbWVzIGFyZSBzZXRcblx0XHRcdFx0XHRpZiAoYXhpcy5pc0RpcnR5RXh0cmVtZXMpIHsgLy8gIzgyMVxuXHRcdFx0XHRcdFx0YXhpcy5pc0RpcnR5RXh0cmVtZXMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGFmdGVyUmVkcmF3LnB1c2goZnVuY3Rpb24gKCkgeyAvLyBwcmV2ZW50IGEgcmVjdXJzaXZlIGNhbGwgdG8gY2hhcnQucmVkcmF3KCkgKCMxMTE5KVxuXHRcdFx0XHRcdFx0XHRmaXJlRXZlbnQoYXhpcywgJ2FmdGVyU2V0RXh0cmVtZXMnLCBleHRlbmQoYXhpcy5ldmVudEFyZ3MsIGF4aXMuZ2V0RXh0cmVtZXMoKSkpOyAvLyAjNzQ3LCAjNzUxXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBheGlzLmV2ZW50QXJncztcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoaXNEaXJ0eUJveCB8fCBoYXNTdGFja2VkU2VyaWVzKSB7XG5cdFx0XHRcdFx0XHRheGlzLnJlZHJhdygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIHRoZSBwbG90IGFyZWFzIHNpemUgaGFzIGNoYW5nZWRcblx0XHRcdGlmIChpc0RpcnR5Qm94KSB7XG5cdFx0XHRcdGNoYXJ0LmRyYXdDaGFydEJveCgpO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vIHJlZHJhdyBhZmZlY3RlZCBzZXJpZXNcblx0XHRcdGVhY2goc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdFx0aWYgKHNlcmllLmlzRGlydHkgJiYgc2VyaWUudmlzaWJsZSAmJlxuXHRcdFx0XHRcdFx0KCFzZXJpZS5pc0NhcnRlc2lhbiB8fCBzZXJpZS54QXhpcykpIHsgLy8gaXNzdWUgIzE1M1xuXHRcdFx0XHRcdHNlcmllLnJlZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gbW92ZSB0b29sdGlwIG9yIHJlc2V0XG5cdFx0XHRpZiAocG9pbnRlcikge1xuXHRcdFx0XHRwb2ludGVyLnJlc2V0KHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWRyYXcgaWYgY2FudmFzXG5cdFx0XHRyZW5kZXJlci5kcmF3KCk7XG5cblx0XHRcdC8vIGZpcmUgdGhlIGV2ZW50XG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdyZWRyYXcnKTsgLy8galF1ZXJ5IGJyZWFrcyB0aGlzIHdoZW4gY2FsbGluZyBpdCBmcm9tIGFkZEV2ZW50LiBPdmVyd3JpdGVzIGNoYXJ0LnJlZHJhd1xuXHRcdFx0XG5cdFx0XHRpZiAoaXNIaWRkZW5DaGFydCkge1xuXHRcdFx0XHRjaGFydC5jbG9uZVJlbmRlclRvKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBGaXJlIGNhbGxiYWNrcyB0aGF0IGFyZSBwdXQgb24gaG9sZCB1bnRpbCBhZnRlciB0aGUgcmVkcmF3XG5cdFx0XHRlYWNoKGFmdGVyUmVkcmF3LCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbCgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhbiBheGlzLCBzZXJpZXMgb3IgcG9pbnQgb2JqZWN0IGJ5IGlkLlxuXHRcdCAqIEBwYXJhbSBpZCB7U3RyaW5nfSBUaGUgaWQgYXMgZ2l2ZW4gaW4gdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdGdldDogZnVuY3Rpb24gKGlkKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRheGVzID0gY2hhcnQuYXhlcyxcblx0XHRcdFx0c2VyaWVzID0gY2hhcnQuc2VyaWVzO1xuXG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0aixcblx0XHRcdFx0cG9pbnRzO1xuXG5cdFx0XHQvLyBzZWFyY2ggYXhlc1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGF4ZXNbaV0ub3B0aW9ucy5pZCA9PT0gaWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gYXhlc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZWFyY2ggc2VyaWVzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChzZXJpZXNbaV0ub3B0aW9ucy5pZCA9PT0gaWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VyaWVzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNlYXJjaCBwb2ludHNcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzW2ldLnBvaW50cyB8fCBbXTtcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmIChwb2ludHNbal0uaWQgPT09IGlkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcG9pbnRzW2pdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSB0aGUgQXhpcyBpbnN0YW5jZXMgYmFzZWQgb24gdGhlIGNvbmZpZyBvcHRpb25zXG5cdFx0ICovXG5cdFx0Z2V0QXhlczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0eEF4aXNPcHRpb25zID0gb3B0aW9ucy54QXhpcyA9IHNwbGF0KG9wdGlvbnMueEF4aXMgfHwge30pLFxuXHRcdFx0XHR5QXhpc09wdGlvbnMgPSBvcHRpb25zLnlBeGlzID0gc3BsYXQob3B0aW9ucy55QXhpcyB8fCB7fSksXG5cdFx0XHRcdG9wdGlvbnNBcnJheSxcblx0XHRcdFx0YXhpcztcblxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSBvcHRpb25zIGFyZSBhcnJheXMgYW5kIGFkZCBzb21lIG1lbWJlcnNcblx0XHRcdGVhY2goeEF4aXNPcHRpb25zLCBmdW5jdGlvbiAoYXhpcywgaSkge1xuXHRcdFx0XHRheGlzLmluZGV4ID0gaTtcblx0XHRcdFx0YXhpcy5pc1ggPSB0cnVlO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVhY2goeUF4aXNPcHRpb25zLCBmdW5jdGlvbiAoYXhpcywgaSkge1xuXHRcdFx0XHRheGlzLmluZGV4ID0gaTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBjb25jYXRlbmF0ZSBhbGwgYXhpcyBvcHRpb25zIGludG8gb25lIGFycmF5XG5cdFx0XHRvcHRpb25zQXJyYXkgPSB4QXhpc09wdGlvbnMuY29uY2F0KHlBeGlzT3B0aW9ucyk7XG5cblx0XHRcdGVhY2gob3B0aW9uc0FycmF5LCBmdW5jdGlvbiAoYXhpc09wdGlvbnMpIHtcblx0XHRcdFx0YXhpcyA9IG5ldyBBeGlzKGNoYXJ0LCBheGlzT3B0aW9ucyk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwb2ludHMgZnJvbSBhbGwgc2VyaWVzXG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0ZWRQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwb2ludHMgPSBbXTtcblx0XHRcdGVhY2godGhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRwb2ludHMgPSBwb2ludHMuY29uY2F0KGdyZXAoc2VyaWUucG9pbnRzIHx8IFtdLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcG9pbnQuc2VsZWN0ZWQ7XG5cdFx0XHRcdH0pKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHBvaW50cztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgc2VyaWVzXG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0ZWRTZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBncmVwKHRoaXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdFx0cmV0dXJuIHNlcmllLnNlbGVjdGVkO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRlIHN0YWNrcyBmb3IgZWFjaCBzZXJpZXMgYW5kIGNhbGN1bGF0ZSBzdGFja3MgdG90YWwgdmFsdWVzXG5cdFx0ICovXG5cdFx0Z2V0U3RhY2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzO1xuXG5cdFx0XHQvLyByZXNldCBzdGFja3MgZm9yIGVhY2ggeUF4aXNcblx0XHRcdGVhY2goY2hhcnQueUF4aXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGlmIChheGlzLnN0YWNrcyAmJiBheGlzLmhhc1Zpc2libGVTZXJpZXMpIHtcblx0XHRcdFx0XHRheGlzLm9sZFN0YWNrcyA9IGF4aXMuc3RhY2tzO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0aWYgKHNlcmllcy5vcHRpb25zLnN0YWNraW5nICYmIChzZXJpZXMudmlzaWJsZSA9PT0gdHJ1ZSB8fCBjaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyA9PT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0c2VyaWVzLnN0YWNrS2V5ID0gc2VyaWVzLnR5cGUgKyBwaWNrKHNlcmllcy5vcHRpb25zLnN0YWNrLCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXHRcblxuXHRcdC8qKlxuXHRcdCAqIFNob3cgdGhlIHRpdGxlIGFuZCBzdWJ0aXRsZSBvZiB0aGUgY2hhcnRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB0aXRsZU9wdGlvbnMge09iamVjdH0gTmV3IHRpdGxlIG9wdGlvbnNcblx0XHQgKiBAcGFyYW0gc3VidGl0bGVPcHRpb25zIHtPYmplY3R9IE5ldyBzdWJ0aXRsZSBvcHRpb25zXG5cdFx0ICpcblx0XHQgKi9cblx0XHRzZXRUaXRsZTogZnVuY3Rpb24gKHRpdGxlT3B0aW9ucywgc3VidGl0bGVPcHRpb25zLCByZWRyYXcpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucyxcblx0XHRcdFx0Y2hhcnRTdWJ0aXRsZU9wdGlvbnM7XG5cblx0XHRcdGNoYXJ0VGl0bGVPcHRpb25zID0gb3B0aW9ucy50aXRsZSA9IG1lcmdlKG9wdGlvbnMudGl0bGUsIHRpdGxlT3B0aW9ucyk7XG5cdFx0XHRjaGFydFN1YnRpdGxlT3B0aW9ucyA9IG9wdGlvbnMuc3VidGl0bGUgPSBtZXJnZShvcHRpb25zLnN1YnRpdGxlLCBzdWJ0aXRsZU9wdGlvbnMpO1xuXG5cdFx0XHQvLyBhZGQgdGl0bGUgYW5kIHN1YnRpdGxlXG5cdFx0XHRlYWNoKFtcblx0XHRcdFx0Wyd0aXRsZScsIHRpdGxlT3B0aW9ucywgY2hhcnRUaXRsZU9wdGlvbnNdLFxuXHRcdFx0XHRbJ3N1YnRpdGxlJywgc3VidGl0bGVPcHRpb25zLCBjaGFydFN1YnRpdGxlT3B0aW9uc11cblx0XHRcdF0sIGZ1bmN0aW9uIChhcnIpIHtcblx0XHRcdFx0dmFyIG5hbWUgPSBhcnJbMF0sXG5cdFx0XHRcdFx0dGl0bGUgPSBjaGFydFtuYW1lXSxcblx0XHRcdFx0XHR0aXRsZU9wdGlvbnMgPSBhcnJbMV0sXG5cdFx0XHRcdFx0Y2hhcnRUaXRsZU9wdGlvbnMgPSBhcnJbMl07XG5cblx0XHRcdFx0aWYgKHRpdGxlICYmIHRpdGxlT3B0aW9ucykge1xuXHRcdFx0XHRcdGNoYXJ0W25hbWVdID0gdGl0bGUgPSB0aXRsZS5kZXN0cm95KCk7IC8vIHJlbW92ZSBvbGRcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNoYXJ0VGl0bGVPcHRpb25zICYmIGNoYXJ0VGl0bGVPcHRpb25zLnRleHQgJiYgIXRpdGxlKSB7XG5cdFx0XHRcdFx0Y2hhcnRbbmFtZV0gPSBjaGFydC5yZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0Y2hhcnRUaXRsZU9wdGlvbnMudGV4dCxcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0Y2hhcnRUaXRsZU9wdGlvbnMudXNlSFRNTFxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRhbGlnbjogY2hhcnRUaXRsZU9wdGlvbnMuYWxpZ24sXG5cdFx0XHRcdFx0XHQnY2xhc3MnOiBQUkVGSVggKyBuYW1lLFxuXHRcdFx0XHRcdFx0ekluZGV4OiBjaGFydFRpdGxlT3B0aW9ucy56SW5kZXggfHwgNFxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmNzcyhjaGFydFRpdGxlT3B0aW9ucy5zdHlsZSlcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdH1cdFxuXHRcdFx0fSk7XG5cdFx0XHRjaGFydC5sYXlPdXRUaXRsZXMocmVkcmF3KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGF5IG91dCB0aGUgY2hhcnQgdGl0bGVzIGFuZCBjYWNoZSB0aGUgZnVsbCBvZmZzZXQgaGVpZ2h0IGZvciB1c2UgaW4gZ2V0TWFyZ2luc1xuXHRcdCAqL1xuXHRcdGxheU91dFRpdGxlczogZnVuY3Rpb24gKHJlZHJhdykge1xuXHRcdFx0dmFyIHRpdGxlT2Zmc2V0ID0gMCxcblx0XHRcdFx0dGl0bGUgPSB0aGlzLnRpdGxlLFxuXHRcdFx0XHRzdWJ0aXRsZSA9IHRoaXMuc3VidGl0bGUsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHRpdGxlT3B0aW9ucyA9IG9wdGlvbnMudGl0bGUsXG5cdFx0XHRcdHN1YnRpdGxlT3B0aW9ucyA9IG9wdGlvbnMuc3VidGl0bGUsXG5cdFx0XHRcdHJlcXVpcmVzRGlydHlCb3gsXG5cdFx0XHRcdHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcblx0XHRcdFx0YXV0b1dpZHRoID0gdGhpcy5zcGFjaW5nQm94LndpZHRoIC0gNDQ7IC8vIDQ0IG1ha2VzIHJvb20gZm9yIGRlZmF1bHQgY29udGV4dCBidXR0b25cblxuXHRcdFx0aWYgKHRpdGxlKSB7XG5cdFx0XHRcdHRpdGxlXG5cdFx0XHRcdFx0LmNzcyh7IHdpZHRoOiAodGl0bGVPcHRpb25zLndpZHRoIHx8IGF1dG9XaWR0aCkgKyBQWCB9KVxuXHRcdFx0XHRcdC5hbGlnbihleHRlbmQoeyBcblx0XHRcdFx0XHRcdHk6IHJlbmRlcmVyLmZvbnRNZXRyaWNzKHRpdGxlT3B0aW9ucy5zdHlsZS5mb250U2l6ZSwgdGl0bGUpLmIgLSAzXG5cdFx0XHRcdFx0fSwgdGl0bGVPcHRpb25zKSwgZmFsc2UsICdzcGFjaW5nQm94Jyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoIXRpdGxlT3B0aW9ucy5mbG9hdGluZyAmJiAhdGl0bGVPcHRpb25zLnZlcnRpY2FsQWxpZ24pIHtcblx0XHRcdFx0XHR0aXRsZU9mZnNldCA9IHRpdGxlLmdldEJCb3goKS5oZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChzdWJ0aXRsZSkge1xuXHRcdFx0XHRzdWJ0aXRsZVxuXHRcdFx0XHRcdC5jc3MoeyB3aWR0aDogKHN1YnRpdGxlT3B0aW9ucy53aWR0aCB8fCBhdXRvV2lkdGgpICsgUFggfSlcblx0XHRcdFx0XHQuYWxpZ24oZXh0ZW5kKHsgXG5cdFx0XHRcdFx0XHR5OiB0aXRsZU9mZnNldCArICh0aXRsZU9wdGlvbnMubWFyZ2luIC0gMTMpICsgcmVuZGVyZXIuZm9udE1ldHJpY3ModGl0bGVPcHRpb25zLnN0eWxlLmZvbnRTaXplLCBzdWJ0aXRsZSkuYiBcblx0XHRcdFx0XHR9LCBzdWJ0aXRsZU9wdGlvbnMpLCBmYWxzZSwgJ3NwYWNpbmdCb3gnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghc3VidGl0bGVPcHRpb25zLmZsb2F0aW5nICYmICFzdWJ0aXRsZU9wdGlvbnMudmVydGljYWxBbGlnbikge1xuXHRcdFx0XHRcdHRpdGxlT2Zmc2V0ID0gbWF0aENlaWwodGl0bGVPZmZzZXQgKyBzdWJ0aXRsZS5nZXRCQm94KCkuaGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXF1aXJlc0RpcnR5Qm94ID0gdGhpcy50aXRsZU9mZnNldCAhPT0gdGl0bGVPZmZzZXQ7XHRcdFx0XHRcblx0XHRcdHRoaXMudGl0bGVPZmZzZXQgPSB0aXRsZU9mZnNldDsgLy8gdXNlZCBpbiBnZXRNYXJnaW5zXG5cblx0XHRcdGlmICghdGhpcy5pc0RpcnR5Qm94ICYmIHJlcXVpcmVzRGlydHlCb3gpIHtcblx0XHRcdFx0dGhpcy5pc0RpcnR5Qm94ID0gcmVxdWlyZXNEaXJ0eUJveDtcblx0XHRcdFx0Ly8gUmVkcmF3IGlmIG5lY2Vzc2FyeSAoIzI3MTksICMyNzQ0KVx0XHRcblx0XHRcdFx0aWYgKHRoaXMuaGFzUmVuZGVyZWQgJiYgcGljayhyZWRyYXcsIHRydWUpICYmIHRoaXMuaXNEaXJ0eUJveCkge1xuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGNoYXJ0IHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIG9wdGlvbnMgYW5kIGNvbnRhaW5lciBzaXplXG5cdFx0ICovXG5cdFx0Z2V0Q2hhcnRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zQ2hhcnQgPSBjaGFydC5vcHRpb25zLmNoYXJ0LFxuXHRcdFx0XHR3aWR0aE9wdGlvbiA9IG9wdGlvbnNDaGFydC53aWR0aCxcblx0XHRcdFx0aGVpZ2h0T3B0aW9uID0gb3B0aW9uc0NoYXJ0LmhlaWdodCxcblx0XHRcdFx0cmVuZGVyVG8gPSBjaGFydC5yZW5kZXJUb0Nsb25lIHx8IGNoYXJ0LnJlbmRlclRvO1xuXG5cdFx0XHQvLyBnZXQgaW5uZXIgd2lkdGggYW5kIGhlaWdodCBmcm9tIGpRdWVyeSAoIzgyNClcblx0XHRcdGlmICghZGVmaW5lZCh3aWR0aE9wdGlvbikpIHtcblx0XHRcdFx0Y2hhcnQuY29udGFpbmVyV2lkdGggPSBhZGFwdGVyUnVuKHJlbmRlclRvLCAnd2lkdGgnKTtcblx0XHRcdH1cblx0XHRcdGlmICghZGVmaW5lZChoZWlnaHRPcHRpb24pKSB7XG5cdFx0XHRcdGNoYXJ0LmNvbnRhaW5lckhlaWdodCA9IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICdoZWlnaHQnKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y2hhcnQuY2hhcnRXaWR0aCA9IG1hdGhNYXgoMCwgd2lkdGhPcHRpb24gfHwgY2hhcnQuY29udGFpbmVyV2lkdGggfHwgNjAwKTsgLy8gIzEzOTMsIDE0NjBcblx0XHRcdGNoYXJ0LmNoYXJ0SGVpZ2h0ID0gbWF0aE1heCgwLCBwaWNrKGhlaWdodE9wdGlvbixcblx0XHRcdFx0Ly8gdGhlIG9mZnNldEhlaWdodCBvZiBhbiBlbXB0eSBjb250YWluZXIgaXMgMCBpbiBzdGFuZGFyZCBicm93c2VycywgYnV0IDE5IGluIElFNzpcblx0XHRcdFx0Y2hhcnQuY29udGFpbmVySGVpZ2h0ID4gMTkgPyBjaGFydC5jb250YWluZXJIZWlnaHQgOiA0MDApKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIGNoYXJ0J3MgcmVuZGVyVG8gZGl2IGFuZCBwbGFjZSBpdCBvdXRzaWRlIHRoZSB2aWV3cG9ydCB0byBhbGxvd1xuXHRcdCAqIHNpemUgY29tcHV0YXRpb24gb24gY2hhcnQucmVuZGVyIGFuZCBjaGFydC5yZWRyYXdcblx0XHQgKi9cblx0XHRjbG9uZVJlbmRlclRvOiBmdW5jdGlvbiAocmV2ZXJ0KSB7XG5cdFx0XHR2YXIgY2xvbmUgPSB0aGlzLnJlbmRlclRvQ2xvbmUsXG5cdFx0XHRcdGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuXHRcdFx0XG5cdFx0XHQvLyBEZXN0cm95IHRoZSBjbG9uZSBhbmQgYnJpbmcgdGhlIGNvbnRhaW5lciBiYWNrIHRvIHRoZSByZWFsIHJlbmRlclRvIGRpdlxuXHRcdFx0aWYgKHJldmVydCkge1xuXHRcdFx0XHRpZiAoY2xvbmUpIHtcblx0XHRcdFx0XHR0aGlzLnJlbmRlclRvLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdFx0XHRcdFx0ZGlzY2FyZEVsZW1lbnQoY2xvbmUpO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnJlbmRlclRvQ2xvbmU7XG5cdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gU2V0IHVwIHRoZSBjbG9uZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGhpcy5yZW5kZXJUbykge1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyVG8ucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTsgLy8gZG8gbm90IGNsb25lIHRoaXNcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJlbmRlclRvQ2xvbmUgPSBjbG9uZSA9IHRoaXMucmVuZGVyVG8uY2xvbmVOb2RlKDApO1xuXHRcdFx0XHRjc3MoY2xvbmUsIHtcblx0XHRcdFx0XHRwb3NpdGlvbjogQUJTT0xVVEUsXG5cdFx0XHRcdFx0dG9wOiAnLTk5OTlweCcsXG5cdFx0XHRcdFx0ZGlzcGxheTogJ2Jsb2NrJyAvLyAjODMzXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoY2xvbmUuc3R5bGUuc2V0UHJvcGVydHkpIHsgLy8gIzI2MzFcblx0XHRcdFx0XHRjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdibG9jaycsICdpbXBvcnRhbnQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb2MuYm9keS5hcHBlbmRDaGlsZChjbG9uZSk7XG5cdFx0XHRcdGlmIChjb250YWluZXIpIHtcblx0XHRcdFx0XHRjbG9uZS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgY29udGFpbmluZyBlbGVtZW50LCBkZXRlcm1pbmUgdGhlIHNpemUgYW5kIGNyZWF0ZSB0aGUgaW5uZXIgY29udGFpbmVyXG5cdFx0ICogZGl2IHRvIGhvbGQgdGhlIGNoYXJ0XG5cdFx0ICovXG5cdFx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRjb250YWluZXIsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdGNoYXJ0V2lkdGgsXG5cdFx0XHRcdGNoYXJ0SGVpZ2h0LFxuXHRcdFx0XHRyZW5kZXJUbyxcblx0XHRcdFx0aW5kZXhBdHRyTmFtZSA9ICdkYXRhLWhpZ2hjaGFydHMtY2hhcnQnLFxuXHRcdFx0XHRvbGRDaGFydEluZGV4LFxuXHRcdFx0XHRjb250YWluZXJJZDtcblxuXHRcdFx0Y2hhcnQucmVuZGVyVG8gPSByZW5kZXJUbyA9IG9wdGlvbnNDaGFydC5yZW5kZXJUbztcblx0XHRcdGNvbnRhaW5lcklkID0gUFJFRklYICsgaWRDb3VudGVyKys7XG5cblx0XHRcdGlmIChpc1N0cmluZyhyZW5kZXJUbykpIHtcblx0XHRcdFx0Y2hhcnQucmVuZGVyVG8gPSByZW5kZXJUbyA9IGRvYy5nZXRFbGVtZW50QnlJZChyZW5kZXJUbyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIERpc3BsYXkgYW4gZXJyb3IgaWYgdGhlIHJlbmRlclRvIGlzIHdyb25nXG5cdFx0XHRpZiAoIXJlbmRlclRvKSB7XG5cdFx0XHRcdGVycm9yKDEzLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlIGNvbnRhaW5lciBhbHJlYWR5IGhvbGRzIGEgY2hhcnQsIGRlc3Ryb3kgaXQuIFRoZSBjaGVjayBmb3IgaGFzUmVuZGVyZWQgaXMgdGhlcmVcblx0XHRcdC8vIGJlY2F1c2Ugd2ViIHBhZ2VzIHRoYXQgYXJlIHNhdmVkIHRvIGRpc2sgZnJvbSB0aGUgYnJvd3Nlciwgd2lsbCBwcmVzZXJ2ZSB0aGUgZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XG5cdFx0XHQvLyBhdHRyaWJ1dGUgYW5kIHRoZSBTVkcgY29udGVudHMsIGJ1dCBub3QgYW4gaW50ZXJhY3RpdmUgY2hhcnQuIFNvIGluIHRoaXMgY2FzZSxcblx0XHRcdC8vIGNoYXJ0c1tvbGRDaGFydEluZGV4XSB3aWxsIHBvaW50IHRvIHRoZSB3cm9uZyBjaGFydCBpZiBhbnkgKCMyNjA5KS5cblx0XHRcdG9sZENoYXJ0SW5kZXggPSBwSW50KGF0dHIocmVuZGVyVG8sIGluZGV4QXR0ck5hbWUpKTtcblx0XHRcdGlmICghaXNOYU4ob2xkQ2hhcnRJbmRleCkgJiYgY2hhcnRzW29sZENoYXJ0SW5kZXhdICYmIGNoYXJ0c1tvbGRDaGFydEluZGV4XS5oYXNSZW5kZXJlZCkge1xuXHRcdFx0XHRjaGFydHNbb2xkQ2hhcnRJbmRleF0uZGVzdHJveSgpO1xuXHRcdFx0fVx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gTWFrZSBhIHJlZmVyZW5jZSB0byB0aGUgY2hhcnQgZnJvbSB0aGUgZGl2XG5cdFx0XHRhdHRyKHJlbmRlclRvLCBpbmRleEF0dHJOYW1lLCBjaGFydC5pbmRleCk7XG5cblx0XHRcdC8vIHJlbW92ZSBwcmV2aW91cyBjaGFydFxuXHRcdFx0cmVuZGVyVG8uaW5uZXJIVE1MID0gJyc7XG5cblx0XHRcdC8vIElmIHRoZSBjb250YWluZXIgZG9lc24ndCBoYXZlIGFuIG9mZnNldFdpZHRoLCBpdCBoYXMgb3IgaXMgYSBjaGlsZCBvZiBhIG5vZGVcblx0XHRcdC8vIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSBtb3ZlIGl0IG91dCB0byBhIHZpc2libGVcblx0XHRcdC8vIHN0YXRlIHRvIGRldGVybWluZSB0aGUgc2l6ZSwgZWxzZSB0aGUgbGVnZW5kIGFuZCB0b29sdGlwcyB3b24ndCByZW5kZXJcblx0XHRcdC8vIHByb3Blcmx5LiBUaGUgYWxsb3dDbG9uZSBvcHRpb24gaXMgdXNlZCBpbiBzcGFya2xpbmVzIGFzIGEgbWljcm8gb3B0aW1pemF0aW9uLFxuXHRcdFx0Ly8gc2F2aW5nIGFib3V0IDEtMiBtcyBlYWNoIGNoYXJ0LlxuXHRcdFx0aWYgKCFvcHRpb25zQ2hhcnQuc2tpcENsb25lICYmICFyZW5kZXJUby5vZmZzZXRXaWR0aCkge1xuXHRcdFx0XHRjaGFydC5jbG9uZVJlbmRlclRvKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodFxuXHRcdFx0Y2hhcnQuZ2V0Q2hhcnRTaXplKCk7XG5cdFx0XHRjaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aDtcblx0XHRcdGNoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQ7XG5cblx0XHRcdC8vIGNyZWF0ZSB0aGUgaW5uZXIgY29udGFpbmVyXG5cdFx0XHRjaGFydC5jb250YWluZXIgPSBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KERJViwge1xuXHRcdFx0XHRcdGNsYXNzTmFtZTogUFJFRklYICsgJ2NvbnRhaW5lcicgK1xuXHRcdFx0XHRcdFx0KG9wdGlvbnNDaGFydC5jbGFzc05hbWUgPyAnICcgKyBvcHRpb25zQ2hhcnQuY2xhc3NOYW1lIDogJycpLFxuXHRcdFx0XHRcdGlkOiBjb250YWluZXJJZFxuXHRcdFx0XHR9LCBleHRlbmQoe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBSRUxBVElWRSxcblx0XHRcdFx0XHRvdmVyZmxvdzogSElEREVOLCAvLyBuZWVkZWQgZm9yIGNvbnRleHQgbWVudSAoYXZvaWQgc2Nyb2xsYmFycykgYW5kXG5cdFx0XHRcdFx0XHQvLyBjb250ZW50IG92ZXJmbG93IGluIElFXG5cdFx0XHRcdFx0d2lkdGg6IGNoYXJ0V2lkdGggKyBQWCxcblx0XHRcdFx0XHRoZWlnaHQ6IGNoYXJ0SGVpZ2h0ICsgUFgsXG5cdFx0XHRcdFx0dGV4dEFsaWduOiAnbGVmdCcsXG5cdFx0XHRcdFx0bGluZUhlaWdodDogJ25vcm1hbCcsIC8vICM0Mjdcblx0XHRcdFx0XHR6SW5kZXg6IDAsIC8vICMxMDcyXG5cdFx0XHRcdFx0Jy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcic6ICdyZ2JhKDAsMCwwLDApJ1xuXHRcdFx0XHR9LCBvcHRpb25zQ2hhcnQuc3R5bGUpLFxuXHRcdFx0XHRjaGFydC5yZW5kZXJUb0Nsb25lIHx8IHJlbmRlclRvXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBjYWNoZSB0aGUgY3Vyc29yICgjMTY1MClcblx0XHRcdGNoYXJ0Ll9jdXJzb3IgPSBjb250YWluZXIuc3R5bGUuY3Vyc29yO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIHRoZSByZW5kZXJlclxuXHRcdFx0Y2hhcnQucmVuZGVyZXIgPVxuXHRcdFx0XHRvcHRpb25zQ2hhcnQuZm9yRXhwb3J0ID8gLy8gZm9yY2UgU1ZHLCB1c2VkIGZvciBTVkcgZXhwb3J0XG5cdFx0XHRcdFx0bmV3IFNWR1JlbmRlcmVyKGNvbnRhaW5lciwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIG9wdGlvbnNDaGFydC5zdHlsZSwgdHJ1ZSkgOlxuXHRcdFx0XHRcdG5ldyBSZW5kZXJlcihjb250YWluZXIsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCBvcHRpb25zQ2hhcnQuc3R5bGUpO1xuXG5cdFx0XHRpZiAodXNlQ2FuVkcpIHtcblx0XHRcdFx0Ly8gSWYgd2UgbmVlZCBjYW52ZyBsaWJyYXJ5LCBleHRlbmQgYW5kIGNvbmZpZ3VyZSB0aGUgcmVuZGVyZXJcblx0XHRcdFx0Ly8gdG8gZ2V0IHRoZSB0cmFja2VyIGZvciB0cmFuc2xhdGluZyBtb3VzZSBldmVudHNcblx0XHRcdFx0Y2hhcnQucmVuZGVyZXIuY3JlYXRlKGNoYXJ0LCBjb250YWluZXIsIGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0KTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBhIHJlZmVyZW5jZSB0byB0aGUgY2hhcnRzIGluZGV4XG5cdFx0XHRjaGFydC5yZW5kZXJlci5jaGFydEluZGV4ID0gY2hhcnQuaW5kZXg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENhbGN1bGF0ZSBtYXJnaW5zIGJ5IHJlbmRlcmluZyBheGlzIGxhYmVscyBpbiBhIHByZWxpbWluYXJ5IHBvc2l0aW9uLiBUaXRsZSxcblx0XHQgKiBzdWJ0aXRsZSBhbmQgbGVnZW5kIGhhdmUgYWxyZWFkeSBiZWVuIHJlbmRlcmVkIGF0IHRoaXMgc3RhZ2UsIGJ1dCB3aWxsIGJlXG5cdFx0ICogbW92ZWQgaW50byB0aGVpciBmaW5hbCBwb3NpdGlvbnNcblx0XHQgKi9cblx0XHRnZXRNYXJnaW5zOiBmdW5jdGlvbiAoc2tpcEF4ZXMpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdHNwYWNpbmcgPSBjaGFydC5zcGFjaW5nLFxuXHRcdFx0XHRtYXJnaW4gPSBjaGFydC5tYXJnaW4sXG5cdFx0XHRcdHRpdGxlT2Zmc2V0ID0gY2hhcnQudGl0bGVPZmZzZXQ7XG5cblx0XHRcdGNoYXJ0LnJlc2V0TWFyZ2lucygpO1xuXG5cdFx0XHQvLyBBZGp1c3QgZm9yIHRpdGxlIGFuZCBzdWJ0aXRsZVxuXHRcdFx0aWYgKHRpdGxlT2Zmc2V0ICYmICFkZWZpbmVkKG1hcmdpblswXSkpIHtcblx0XHRcdFx0Y2hhcnQucGxvdFRvcCA9IG1hdGhNYXgoY2hhcnQucGxvdFRvcCwgdGl0bGVPZmZzZXQgKyBjaGFydC5vcHRpb25zLnRpdGxlLm1hcmdpbiArIHNwYWNpbmdbMF0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBZGp1c3QgZm9yIGxlZ2VuZFxuXHRcdFx0Y2hhcnQubGVnZW5kLmFkanVzdE1hcmdpbnMobWFyZ2luLCBzcGFjaW5nKTtcblxuXHRcdFx0Ly8gYWRqdXN0IGZvciBzY3JvbGxlclxuXHRcdFx0aWYgKGNoYXJ0LmV4dHJhQm90dG9tTWFyZ2luKSB7XG5cdFx0XHRcdGNoYXJ0Lm1hcmdpbkJvdHRvbSArPSBjaGFydC5leHRyYUJvdHRvbU1hcmdpbjtcblx0XHRcdH1cblx0XHRcdGlmIChjaGFydC5leHRyYVRvcE1hcmdpbikge1xuXHRcdFx0XHRjaGFydC5wbG90VG9wICs9IGNoYXJ0LmV4dHJhVG9wTWFyZ2luO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFza2lwQXhlcykge1xuXHRcdFx0XHR0aGlzLmdldEF4aXNNYXJnaW5zKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldEF4aXNNYXJnaW5zOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGF4aXNPZmZzZXQgPSBjaGFydC5heGlzT2Zmc2V0ID0gWzAsIDAsIDAsIDBdLCAvLyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcblx0XHRcdFx0bWFyZ2luID0gY2hhcnQubWFyZ2luO1xuXHRcdFx0XG5cdFx0XHQvLyBwcmUtcmVuZGVyIGF4ZXMgdG8gZ2V0IGxhYmVscyBvZmZzZXQgd2lkdGhcblx0XHRcdGlmIChjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMpIHtcblx0XHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGF4aXMuZ2V0T2Zmc2V0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdGhlIGF4aXMgb2Zmc2V0c1xuXHRcdFx0ZWFjaChtYXJnaW5OYW1lcywgZnVuY3Rpb24gKG0sIHNpZGUpIHtcblx0XHRcdFx0aWYgKCFkZWZpbmVkKG1hcmdpbltzaWRlXSkpIHtcblx0XHRcdFx0XHRjaGFydFttXSArPSBheGlzT2Zmc2V0W3NpZGVdO1xuXHRcdFx0XHR9XHRcdFxuXHRcdFx0fSk7XG5cblx0XHRcdGNoYXJ0LnNldENoYXJ0U2l6ZSgpO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlc2l6ZSB0aGUgY2hhcnQgdG8gaXRzIGNvbnRhaW5lciBpZiBzaXplIGlzIG5vdCBleHBsaWNpdGx5IHNldFxuXHRcdCAqL1xuXHRcdHJlZmxvdzogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlclRvID0gY2hhcnQucmVuZGVyVG8sXG5cdFx0XHRcdHdpZHRoID0gb3B0aW9uc0NoYXJ0LndpZHRoIHx8IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICd3aWR0aCcpLFxuXHRcdFx0XHRoZWlnaHQgPSBvcHRpb25zQ2hhcnQuaGVpZ2h0IHx8IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICdoZWlnaHQnKSxcblx0XHRcdFx0dGFyZ2V0ID0gZSA/IGUudGFyZ2V0IDogd2luLCAvLyAjODA1IC0gTW9vVG9vbHMgZG9lc24ndCBzdXBwbHkgZVxuXHRcdFx0XHRkb1JlZmxvdyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoY2hhcnQuY29udGFpbmVyKSB7IC8vIEl0IG1heSBoYXZlIGJlZW4gZGVzdHJveWVkIGluIHRoZSBtZWFudGltZSAoIzEyNTcpXG5cdFx0XHRcdFx0XHRjaGFydC5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGNoYXJ0Lmhhc1VzZXJTaXplID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBjaGVja3MgZm9yIGRpc3BsYXk6bm9uZS4gVGFyZ2V0IGlzIGRvYyBpbiBJRTggYW5kIE9wZXJhLFxuXHRcdFx0Ly8gd2luIGluIEZpcmVmb3gsIENocm9tZSBhbmQgSUU5LlxuXHRcdFx0aWYgKCFjaGFydC5oYXNVc2VyU2l6ZSAmJiAhY2hhcnQuaXNQcmludGluZyAmJiB3aWR0aCAmJiBoZWlnaHQgJiYgKHRhcmdldCA9PT0gd2luIHx8IHRhcmdldCA9PT0gZG9jKSkgeyAvLyAjMTA5M1xuXHRcdFx0XHRpZiAod2lkdGggIT09IGNoYXJ0LmNvbnRhaW5lcldpZHRoIHx8IGhlaWdodCAhPT0gY2hhcnQuY29udGFpbmVySGVpZ2h0KSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KGNoYXJ0LnJlZmxvd1RpbWVvdXQpO1xuXHRcdFx0XHRcdGlmIChlKSB7IC8vIENhbGxlZCBmcm9tIHdpbmRvdy5yZXNpemVcblx0XHRcdFx0XHRcdGNoYXJ0LnJlZmxvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRvUmVmbG93LCAxMDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7IC8vIENhbGxlZCBkaXJlY3RseSAoIzIyMjQpXG5cdFx0XHRcdFx0XHRkb1JlZmxvdygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjaGFydC5jb250YWluZXJXaWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRjaGFydC5jb250YWluZXJIZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZCB0aGUgZXZlbnQgaGFuZGxlcnMgbmVjZXNzYXJ5IGZvciBhdXRvIHJlc2l6aW5nXG5cdFx0ICovXG5cdFx0aW5pdFJlZmxvdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0cmVmbG93ID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRjaGFydC5yZWZsb3coZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XG5cdFx0XHRhZGRFdmVudCh3aW4sICdyZXNpemUnLCByZWZsb3cpO1xuXHRcdFx0YWRkRXZlbnQoY2hhcnQsICdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZW1vdmVFdmVudCh3aW4sICdyZXNpemUnLCByZWZsb3cpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlc2l6ZSB0aGUgY2hhcnQgdG8gYSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fEJvb2xlYW59IGFuaW1hdGlvblxuXHRcdCAqL1xuXHRcdHNldFNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0V2lkdGgsXG5cdFx0XHRcdGNoYXJ0SGVpZ2h0LFxuXHRcdFx0XHRmaXJlRW5kUmVzaXplO1xuXG5cdFx0XHQvLyBIYW5kbGUgdGhlIGlzUmVzaXppbmcgY291bnRlclxuXHRcdFx0Y2hhcnQuaXNSZXNpemluZyArPSAxO1xuXHRcdFx0ZmlyZUVuZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGNoYXJ0KSB7XG5cdFx0XHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnZW5kUmVzaXplJywgbnVsbCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Y2hhcnQuaXNSZXNpemluZyAtPSAxO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzZXQgdGhlIGFuaW1hdGlvbiBmb3IgdGhlIGN1cnJlbnQgcHJvY2Vzc1xuXHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXG5cdFx0XHRjaGFydC5vbGRDaGFydEhlaWdodCA9IGNoYXJ0LmNoYXJ0SGVpZ2h0O1xuXHRcdFx0Y2hhcnQub2xkQ2hhcnRXaWR0aCA9IGNoYXJ0LmNoYXJ0V2lkdGg7XG5cdFx0XHRpZiAoZGVmaW5lZCh3aWR0aCkpIHtcblx0XHRcdFx0Y2hhcnQuY2hhcnRXaWR0aCA9IGNoYXJ0V2lkdGggPSBtYXRoTWF4KDAsIG1hdGhSb3VuZCh3aWR0aCkpO1xuXHRcdFx0XHRjaGFydC5oYXNVc2VyU2l6ZSA9ICEhY2hhcnRXaWR0aDtcblx0XHRcdH1cblx0XHRcdGlmIChkZWZpbmVkKGhlaWdodCkpIHtcblx0XHRcdFx0Y2hhcnQuY2hhcnRIZWlnaHQgPSBjaGFydEhlaWdodCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKGhlaWdodCkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNpemUgdGhlIGNvbnRhaW5lciB3aXRoIHRoZSBnbG9iYWwgYW5pbWF0aW9uIGFwcGxpZWQgaWYgZW5hYmxlZCAoIzI1MDMpXG5cdFx0XHQoZ2xvYmFsQW5pbWF0aW9uID8gYW5pbWF0ZSA6IGNzcykoY2hhcnQuY29udGFpbmVyLCB7XG5cdFx0XHRcdHdpZHRoOiBjaGFydFdpZHRoICsgUFgsXG5cdFx0XHRcdGhlaWdodDogY2hhcnRIZWlnaHQgKyBQWFxuXHRcdFx0fSwgZ2xvYmFsQW5pbWF0aW9uKTtcblxuXHRcdFx0Y2hhcnQuc2V0Q2hhcnRTaXplKHRydWUpO1xuXHRcdFx0Y2hhcnQucmVuZGVyZXIuc2V0U2l6ZShjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgYW5pbWF0aW9uKTtcblxuXHRcdFx0Ly8gaGFuZGxlIGF4ZXNcblx0XHRcdGNoYXJ0Lm1heFRpY2tzID0gbnVsbDtcblx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0YXhpcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0YXhpcy5zZXRTY2FsZSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIG1ha2Ugc3VyZSBub24tY2FydGVzaWFuIHNlcmllcyBhcmUgYWxzbyBoYW5kbGVkXG5cdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRcdHNlcmllLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0fSk7XG5cblx0XHRcdGNoYXJ0LmlzRGlydHlMZWdlbmQgPSB0cnVlOyAvLyBmb3JjZSBsZWdlbmQgcmVkcmF3XG5cdFx0XHRjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTsgLy8gZm9yY2UgcmVkcmF3IG9mIHBsb3QgYW5kIGNoYXJ0IGJvcmRlclxuXG5cdFx0XHRjaGFydC5sYXlPdXRUaXRsZXMoKTsgLy8gIzI4NTdcblx0XHRcdGNoYXJ0LmdldE1hcmdpbnMoKTtcblxuXHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cblxuXHRcdFx0Y2hhcnQub2xkQ2hhcnRIZWlnaHQgPSBudWxsO1xuXHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAncmVzaXplJyk7XG5cblx0XHRcdC8vIGZpcmUgZW5kUmVzaXplIGFuZCBzZXQgaXNSZXNpemluZyBiYWNrXG5cdFx0XHQvLyBJZiBhbmltYXRpb24gaXMgZGlzYWJsZWQsIGZpcmUgd2l0aG91dCBkZWxheVxuXHRcdFx0aWYgKGdsb2JhbEFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcblx0XHRcdFx0ZmlyZUVuZFJlc2l6ZSgpO1xuXHRcdFx0fSBlbHNlIHsgLy8gZWxzZSBzZXQgYSB0aW1lb3V0IHdpdGggdGhlIGFuaW1hdGlvbiBkdXJhdGlvblxuXHRcdFx0XHRzZXRUaW1lb3V0KGZpcmVFbmRSZXNpemUsIChnbG9iYWxBbmltYXRpb24gJiYgZ2xvYmFsQW5pbWF0aW9uLmR1cmF0aW9uKSB8fCA1MDApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHB1YmxpYyBjaGFydCBwcm9wZXJ0aWVzLiBUaGlzIGlzIGRvbmUgYmVmb3JlIGFuZCBhZnRlciB0aGUgcHJlLXJlbmRlclxuXHRcdCAqIHRvIGRldGVybWluZSBtYXJnaW4gc2l6ZXNcblx0XHQgKi9cblx0XHRzZXRDaGFydFNpemU6IGZ1bmN0aW9uIChza2lwQXhlcykge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0Y2hhcnRXaWR0aCA9IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRcdGNoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdHNwYWNpbmcgPSBjaGFydC5zcGFjaW5nLFxuXHRcdFx0XHRjbGlwT2Zmc2V0ID0gY2hhcnQuY2xpcE9mZnNldCxcblx0XHRcdFx0Y2xpcFgsXG5cdFx0XHRcdGNsaXBZLFxuXHRcdFx0XHRwbG90TGVmdCxcblx0XHRcdFx0cGxvdFRvcCxcblx0XHRcdFx0cGxvdFdpZHRoLFxuXHRcdFx0XHRwbG90SGVpZ2h0LFxuXHRcdFx0XHRwbG90Qm9yZGVyV2lkdGg7XG5cblx0XHRcdGNoYXJ0LnBsb3RMZWZ0ID0gcGxvdExlZnQgPSBtYXRoUm91bmQoY2hhcnQucGxvdExlZnQpO1xuXHRcdFx0Y2hhcnQucGxvdFRvcCA9IHBsb3RUb3AgPSBtYXRoUm91bmQoY2hhcnQucGxvdFRvcCk7XG5cdFx0XHRjaGFydC5wbG90V2lkdGggPSBwbG90V2lkdGggPSBtYXRoTWF4KDAsIG1hdGhSb3VuZChjaGFydFdpZHRoIC0gcGxvdExlZnQgLSBjaGFydC5tYXJnaW5SaWdodCkpO1xuXHRcdFx0Y2hhcnQucGxvdEhlaWdodCA9IHBsb3RIZWlnaHQgPSBtYXRoTWF4KDAsIG1hdGhSb3VuZChjaGFydEhlaWdodCAtIHBsb3RUb3AgLSBjaGFydC5tYXJnaW5Cb3R0b20pKTtcblxuXHRcdFx0Y2hhcnQucGxvdFNpemVYID0gaW52ZXJ0ZWQgPyBwbG90SGVpZ2h0IDogcGxvdFdpZHRoO1xuXHRcdFx0Y2hhcnQucGxvdFNpemVZID0gaW52ZXJ0ZWQgPyBwbG90V2lkdGggOiBwbG90SGVpZ2h0O1xuXHRcdFx0XG5cdFx0XHRjaGFydC5wbG90Qm9yZGVyV2lkdGggPSBvcHRpb25zQ2hhcnQucGxvdEJvcmRlcldpZHRoIHx8IDA7XG5cblx0XHRcdC8vIFNldCBib3hlcyB1c2VkIGZvciBhbGlnbm1lbnRcblx0XHRcdGNoYXJ0LnNwYWNpbmdCb3ggPSByZW5kZXJlci5zcGFjaW5nQm94ID0ge1xuXHRcdFx0XHR4OiBzcGFjaW5nWzNdLFxuXHRcdFx0XHR5OiBzcGFjaW5nWzBdLFxuXHRcdFx0XHR3aWR0aDogY2hhcnRXaWR0aCAtIHNwYWNpbmdbM10gLSBzcGFjaW5nWzFdLFxuXHRcdFx0XHRoZWlnaHQ6IGNoYXJ0SGVpZ2h0IC0gc3BhY2luZ1swXSAtIHNwYWNpbmdbMl1cblx0XHRcdH07XG5cdFx0XHRjaGFydC5wbG90Qm94ID0gcmVuZGVyZXIucGxvdEJveCA9IHtcblx0XHRcdFx0eDogcGxvdExlZnQsXG5cdFx0XHRcdHk6IHBsb3RUb3AsXG5cdFx0XHRcdHdpZHRoOiBwbG90V2lkdGgsXG5cdFx0XHRcdGhlaWdodDogcGxvdEhlaWdodFxuXHRcdFx0fTtcblxuXHRcdFx0cGxvdEJvcmRlcldpZHRoID0gMiAqIG1hdGhGbG9vcihjaGFydC5wbG90Qm9yZGVyV2lkdGggLyAyKTtcblx0XHRcdGNsaXBYID0gbWF0aENlaWwobWF0aE1heChwbG90Qm9yZGVyV2lkdGgsIGNsaXBPZmZzZXRbM10pIC8gMik7XG5cdFx0XHRjbGlwWSA9IG1hdGhDZWlsKG1hdGhNYXgocGxvdEJvcmRlcldpZHRoLCBjbGlwT2Zmc2V0WzBdKSAvIDIpO1xuXHRcdFx0Y2hhcnQuY2xpcEJveCA9IHtcblx0XHRcdFx0eDogY2xpcFgsIFxuXHRcdFx0XHR5OiBjbGlwWSwgXG5cdFx0XHRcdHdpZHRoOiBtYXRoRmxvb3IoY2hhcnQucGxvdFNpemVYIC0gbWF0aE1heChwbG90Qm9yZGVyV2lkdGgsIGNsaXBPZmZzZXRbMV0pIC8gMiAtIGNsaXBYKSwgXG5cdFx0XHRcdGhlaWdodDogbWF0aE1heCgwLCBtYXRoRmxvb3IoY2hhcnQucGxvdFNpemVZIC0gbWF0aE1heChwbG90Qm9yZGVyV2lkdGgsIGNsaXBPZmZzZXRbMl0pIC8gMiAtIGNsaXBZKSlcblx0XHRcdH07XG5cblx0XHRcdGlmICghc2tpcEF4ZXMpIHtcblx0XHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGF4aXMuc2V0QXhpc1NpemUoKTtcblx0XHRcdFx0XHRheGlzLnNldEF4aXNUcmFuc2xhdGlvbigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbCBtYXJnaW5zIGJlZm9yZSBhdXRvIHNpemUgbWFyZ2lucyBhcmUgYXBwbGllZFxuXHRcdCAqL1xuXHRcdHJlc2V0TWFyZ2luczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcztcblxuXHRcdFx0ZWFjaChtYXJnaW5OYW1lcywgZnVuY3Rpb24gKG0sIHNpZGUpIHtcblx0XHRcdFx0Y2hhcnRbbV0gPSBwaWNrKGNoYXJ0Lm1hcmdpbltzaWRlXSwgY2hhcnQuc3BhY2luZ1tzaWRlXSk7XG5cdFx0XHR9KTtcblx0XHRcdGNoYXJ0LmF4aXNPZmZzZXQgPSBbMCwgMCwgMCwgMF07IC8vIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuXHRcdFx0Y2hhcnQuY2xpcE9mZnNldCA9IFswLCAwLCAwLCAwXTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyB0aGUgYm9yZGVycyBhbmQgYmFja2dyb3VuZHMgZm9yIGNoYXJ0IGFuZCBwbG90IGFyZWFcblx0XHQgKi9cblx0XHRkcmF3Q2hhcnRCb3g6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdGNoYXJ0V2lkdGggPSBjaGFydC5jaGFydFdpZHRoLFxuXHRcdFx0XHRjaGFydEhlaWdodCA9IGNoYXJ0LmNoYXJ0SGVpZ2h0LFxuXHRcdFx0XHRjaGFydEJhY2tncm91bmQgPSBjaGFydC5jaGFydEJhY2tncm91bmQsXG5cdFx0XHRcdHBsb3RCYWNrZ3JvdW5kID0gY2hhcnQucGxvdEJhY2tncm91bmQsXG5cdFx0XHRcdHBsb3RCb3JkZXIgPSBjaGFydC5wbG90Qm9yZGVyLFxuXHRcdFx0XHRwbG90QkdJbWFnZSA9IGNoYXJ0LnBsb3RCR0ltYWdlLFxuXHRcdFx0XHRjaGFydEJvcmRlcldpZHRoID0gb3B0aW9uc0NoYXJ0LmJvcmRlcldpZHRoIHx8IDAsXG5cdFx0XHRcdGNoYXJ0QmFja2dyb3VuZENvbG9yID0gb3B0aW9uc0NoYXJ0LmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0cGxvdEJhY2tncm91bmRDb2xvciA9IG9wdGlvbnNDaGFydC5wbG90QmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRwbG90QmFja2dyb3VuZEltYWdlID0gb3B0aW9uc0NoYXJ0LnBsb3RCYWNrZ3JvdW5kSW1hZ2UsXG5cdFx0XHRcdHBsb3RCb3JkZXJXaWR0aCA9IG9wdGlvbnNDaGFydC5wbG90Qm9yZGVyV2lkdGggfHwgMCxcblx0XHRcdFx0bWduLFxuXHRcdFx0XHRiZ0F0dHIsXG5cdFx0XHRcdHBsb3RMZWZ0ID0gY2hhcnQucGxvdExlZnQsXG5cdFx0XHRcdHBsb3RUb3AgPSBjaGFydC5wbG90VG9wLFxuXHRcdFx0XHRwbG90V2lkdGggPSBjaGFydC5wbG90V2lkdGgsXG5cdFx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0LFxuXHRcdFx0XHRwbG90Qm94ID0gY2hhcnQucGxvdEJveCxcblx0XHRcdFx0Y2xpcFJlY3QgPSBjaGFydC5jbGlwUmVjdCxcblx0XHRcdFx0Y2xpcEJveCA9IGNoYXJ0LmNsaXBCb3g7XG5cblx0XHRcdC8vIENoYXJ0IGFyZWFcblx0XHRcdG1nbiA9IGNoYXJ0Qm9yZGVyV2lkdGggKyAob3B0aW9uc0NoYXJ0LnNoYWRvdyA/IDggOiAwKTtcblxuXHRcdFx0aWYgKGNoYXJ0Qm9yZGVyV2lkdGggfHwgY2hhcnRCYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdFx0aWYgKCFjaGFydEJhY2tncm91bmQpIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRiZ0F0dHIgPSB7XG5cdFx0XHRcdFx0XHRmaWxsOiBjaGFydEJhY2tncm91bmRDb2xvciB8fCBOT05FXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiAoY2hhcnRCb3JkZXJXaWR0aCkgeyAvLyAjOTgwXG5cdFx0XHRcdFx0XHRiZ0F0dHIuc3Ryb2tlID0gb3B0aW9uc0NoYXJ0LmJvcmRlckNvbG9yO1xuXHRcdFx0XHRcdFx0YmdBdHRyWydzdHJva2Utd2lkdGgnXSA9IGNoYXJ0Qm9yZGVyV2lkdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNoYXJ0LmNoYXJ0QmFja2dyb3VuZCA9IHJlbmRlcmVyLnJlY3QobWduIC8gMiwgbWduIC8gMiwgY2hhcnRXaWR0aCAtIG1nbiwgY2hhcnRIZWlnaHQgLSBtZ24sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnNDaGFydC5ib3JkZXJSYWRpdXMsIGNoYXJ0Qm9yZGVyV2lkdGgpXG5cdFx0XHRcdFx0XHQuYXR0cihiZ0F0dHIpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoUFJFRklYICsgJ2JhY2tncm91bmQnKVxuXHRcdFx0XHRcdFx0LmFkZCgpXG5cdFx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnNDaGFydC5zaGFkb3cpO1xuXG5cdFx0XHRcdH0gZWxzZSB7IC8vIHJlc2l6ZVxuXHRcdFx0XHRcdGNoYXJ0QmFja2dyb3VuZC5hbmltYXRlKFxuXHRcdFx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kLmNyaXNwKHsgd2lkdGg6IGNoYXJ0V2lkdGggLSBtZ24sIGhlaWdodDogY2hhcnRIZWlnaHQgLSBtZ24gfSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gUGxvdCBiYWNrZ3JvdW5kXG5cdFx0XHRpZiAocGxvdEJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0XHRpZiAoIXBsb3RCYWNrZ3JvdW5kKSB7XG5cdFx0XHRcdFx0Y2hhcnQucGxvdEJhY2tncm91bmQgPSByZW5kZXJlci5yZWN0KHBsb3RMZWZ0LCBwbG90VG9wLCBwbG90V2lkdGgsIHBsb3RIZWlnaHQsIDApXG5cdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdGZpbGw6IHBsb3RCYWNrZ3JvdW5kQ29sb3Jcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuYWRkKClcblx0XHRcdFx0XHRcdC5zaGFkb3cob3B0aW9uc0NoYXJ0LnBsb3RTaGFkb3cpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBsb3RCYWNrZ3JvdW5kLmFuaW1hdGUocGxvdEJveCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwbG90QmFja2dyb3VuZEltYWdlKSB7XG5cdFx0XHRcdGlmICghcGxvdEJHSW1hZ2UpIHtcblx0XHRcdFx0XHRjaGFydC5wbG90QkdJbWFnZSA9IHJlbmRlcmVyLmltYWdlKHBsb3RCYWNrZ3JvdW5kSW1hZ2UsIHBsb3RMZWZ0LCBwbG90VG9wLCBwbG90V2lkdGgsIHBsb3RIZWlnaHQpXG5cdFx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGxvdEJHSW1hZ2UuYW5pbWF0ZShwbG90Qm94KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBQbG90IGNsaXBcblx0XHRcdGlmICghY2xpcFJlY3QpIHtcblx0XHRcdFx0Y2hhcnQuY2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdChjbGlwQm94KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsaXBSZWN0LmFuaW1hdGUoe1xuXHRcdFx0XHRcdHdpZHRoOiBjbGlwQm94LndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogY2xpcEJveC5oZWlnaHRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBsb3QgYXJlYSBib3JkZXJcblx0XHRcdGlmIChwbG90Qm9yZGVyV2lkdGgpIHtcblx0XHRcdFx0aWYgKCFwbG90Qm9yZGVyKSB7XG5cdFx0XHRcdFx0Y2hhcnQucGxvdEJvcmRlciA9IHJlbmRlcmVyLnJlY3QocGxvdExlZnQsIHBsb3RUb3AsIHBsb3RXaWR0aCwgcGxvdEhlaWdodCwgMCwgLXBsb3RCb3JkZXJXaWR0aClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zQ2hhcnQucGxvdEJvcmRlckNvbG9yLFxuXHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogcGxvdEJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdFx0XHRmaWxsOiBOT05FLFxuXHRcdFx0XHRcdFx0XHR6SW5kZXg6IDFcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGxvdEJvcmRlci5hbmltYXRlKFxuXHRcdFx0XHRcdFx0cGxvdEJvcmRlci5jcmlzcCh7IHg6IHBsb3RMZWZ0LCB5OiBwbG90VG9wLCB3aWR0aDogcGxvdFdpZHRoLCBoZWlnaHQ6IHBsb3RIZWlnaHQsIHN0cm9rZVdpZHRoOiAtcGxvdEJvcmRlcldpZHRoIH0pIC8vIzMyODIgcGxvdEJvcmRlciBzaG91bGQgYmUgbmVnYXRpdmVcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlc2V0XG5cdFx0XHRjaGFydC5pc0RpcnR5Qm94ID0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERldGVjdCB3aGV0aGVyIGEgY2VydGFpbiBjaGFydCBwcm9wZXJ0eSBpcyBuZWVkZWQgYmFzZWQgb24gaW5zcGVjdGluZyBpdHMgb3B0aW9uc1xuXHRcdCAqIGFuZCBzZXJpZXMuIFRoaXMgbWFpbmx5IGFwcGxpZXMgdG8gdGhlIGNoYXJ0LmludmVydCBwcm9wZXJ0eSwgYW5kIGluIGV4dGVuc2lvbnMgdG8gXG5cdFx0ICogdGhlIGNoYXJ0LmFuZ3VsYXIgYW5kIGNoYXJ0LnBvbGFyIHByb3BlcnRpZXMuXG5cdFx0ICovXG5cdFx0cHJvcEZyb21TZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdGtsYXNzLFxuXHRcdFx0XHRzZXJpZXNPcHRpb25zID0gY2hhcnQub3B0aW9ucy5zZXJpZXMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHZhbHVlO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRlYWNoKFsnaW52ZXJ0ZWQnLCAnYW5ndWxhcicsICdwb2xhciddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGUgZGVmYXVsdCBzZXJpZXMgdHlwZSdzIGNsYXNzXG5cdFx0XHRcdGtsYXNzID0gc2VyaWVzVHlwZXNbb3B0aW9uc0NoYXJ0LnR5cGUgfHwgb3B0aW9uc0NoYXJ0LmRlZmF1bHRTZXJpZXNUeXBlXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEdldCB0aGUgdmFsdWUgZnJvbSBhdmFpbGFibGUgY2hhcnQtd2lkZSBwcm9wZXJ0aWVzXG5cdFx0XHRcdHZhbHVlID0gKFxuXHRcdFx0XHRcdGNoYXJ0W2tleV0gfHwgLy8gMS4gaXQgaXMgc2V0IGJlZm9yZVxuXHRcdFx0XHRcdG9wdGlvbnNDaGFydFtrZXldIHx8IC8vIDIuIGl0IGlzIHNldCBpbiB0aGUgb3B0aW9uc1xuXHRcdFx0XHRcdChrbGFzcyAmJiBrbGFzcy5wcm90b3R5cGVba2V5XSkgLy8gMy4gaXQncyBkZWZhdWx0IHNlcmllcyBjbGFzcyByZXF1aXJlcyBpdFxuXHRcdFx0XHQpO1xuXHRcdFxuXHRcdFx0XHQvLyA0LiBDaGVjayBpZiBhbnkgdGhlIGNoYXJ0J3Mgc2VyaWVzIHJlcXVpcmUgaXRcblx0XHRcdFx0aSA9IHNlcmllc09wdGlvbnMgJiYgc2VyaWVzT3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICghdmFsdWUgJiYgaS0tKSB7XG5cdFx0XHRcdFx0a2xhc3MgPSBzZXJpZXNUeXBlc1tzZXJpZXNPcHRpb25zW2ldLnR5cGVdO1xuXHRcdFx0XHRcdGlmIChrbGFzcyAmJiBrbGFzcy5wcm90b3R5cGVba2V5XSkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHQvLyBTZXQgdGhlIGNoYXJ0IHByb3BlcnR5XG5cdFx0XHRcdGNoYXJ0W2tleV0gPSB2YWx1ZTtcdFxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGluayB0d28gb3IgbW9yZSBzZXJpZXMgdG9nZXRoZXIuIFRoaXMgaXMgZG9uZSBpbml0aWFsbHkgZnJvbSBDaGFydC5yZW5kZXIsXG5cdFx0ICogYW5kIGFmdGVyIENoYXJ0LmFkZFNlcmllcyBhbmQgU2VyaWVzLnJlbW92ZS5cblx0XHQgKi9cblx0XHRsaW5rU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRjaGFydFNlcmllcyA9IGNoYXJ0LnNlcmllcztcblxuXHRcdFx0Ly8gUmVzZXQgbGlua3Ncblx0XHRcdGVhY2goY2hhcnRTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0c2VyaWVzLmxpbmtlZFNlcmllcy5sZW5ndGggPSAwO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IG5ldyBsaW5rc1xuXHRcdFx0ZWFjaChjaGFydFNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHR2YXIgbGlua2VkVG8gPSBzZXJpZXMub3B0aW9ucy5saW5rZWRUbztcblx0XHRcdFx0aWYgKGlzU3RyaW5nKGxpbmtlZFRvKSkge1xuXHRcdFx0XHRcdGlmIChsaW5rZWRUbyA9PT0gJzpwcmV2aW91cycpIHtcblx0XHRcdFx0XHRcdGxpbmtlZFRvID0gY2hhcnQuc2VyaWVzW3Nlcmllcy5pbmRleCAtIDFdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsaW5rZWRUbyA9IGNoYXJ0LmdldChsaW5rZWRUbyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChsaW5rZWRUbykge1xuXHRcdFx0XHRcdFx0bGlua2VkVG8ubGlua2VkU2VyaWVzLnB1c2goc2VyaWVzKTtcblx0XHRcdFx0XHRcdHNlcmllcy5saW5rZWRQYXJlbnQgPSBsaW5rZWRUbztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgc2VyaWVzIGZvciB0aGUgY2hhcnRcblx0XHQgKi9cblx0XHRyZW5kZXJTZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGVhY2godGhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRzZXJpZS50cmFuc2xhdGUoKTtcblx0XHRcdFx0c2VyaWUucmVuZGVyKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIGxhYmVscyBmb3IgdGhlIGNoYXJ0XG5cdFx0ICovXG5cdFx0cmVuZGVyTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRsYWJlbHMgPSBjaGFydC5vcHRpb25zLmxhYmVscztcblx0XHRcdGlmIChsYWJlbHMuaXRlbXMpIHtcblx0XHRcdFx0ZWFjaChsYWJlbHMuaXRlbXMsIGZ1bmN0aW9uIChsYWJlbCkge1xuXHRcdFx0XHRcdHZhciBzdHlsZSA9IGV4dGVuZChsYWJlbHMuc3R5bGUsIGxhYmVsLnN0eWxlKSxcblx0XHRcdFx0XHRcdHggPSBwSW50KHN0eWxlLmxlZnQpICsgY2hhcnQucGxvdExlZnQsXG5cdFx0XHRcdFx0XHR5ID0gcEludChzdHlsZS50b3ApICsgY2hhcnQucGxvdFRvcCArIDEyO1xuXG5cdFx0XHRcdFx0Ly8gZGVsZXRlIHRvIHByZXZlbnQgcmV3cml0aW5nIGluIElFXG5cdFx0XHRcdFx0ZGVsZXRlIHN0eWxlLmxlZnQ7XG5cdFx0XHRcdFx0ZGVsZXRlIHN0eWxlLnRvcDtcblxuXHRcdFx0XHRcdGNoYXJ0LnJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0XHRsYWJlbC5odG1sLFxuXHRcdFx0XHRcdFx0eCxcblx0XHRcdFx0XHRcdHlcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IDIgfSlcblx0XHRcdFx0XHQuY3NzKHN0eWxlKVxuXHRcdFx0XHRcdC5hZGQoKTtcblxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIGFsbCBncmFwaGljcyBmb3IgdGhlIGNoYXJ0XG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRheGVzID0gY2hhcnQuYXhlcyxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0b3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMsXG5cdFx0XHRcdHRlbXBXaWR0aCxcblx0XHRcdFx0dGVtcEhlaWdodCxcblx0XHRcdFx0cmVkb0hvcml6b250YWwsXG5cdFx0XHRcdHJlZG9WZXJ0aWNhbDtcblxuXHRcdFx0Ly8gVGl0bGVcblx0XHRcdGNoYXJ0LnNldFRpdGxlKCk7XG5cblxuXHRcdFx0Ly8gTGVnZW5kXG5cdFx0XHRjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKGNoYXJ0LCBvcHRpb25zLmxlZ2VuZCk7XG5cblx0XHRcdGNoYXJ0LmdldFN0YWNrcygpOyAvLyByZW5kZXIgc3RhY2tzXG5cblx0XHRcdC8vIEdldCBjaGFydCBtYXJnaW5zXG5cdFx0XHRjaGFydC5nZXRNYXJnaW5zKHRydWUpO1xuXHRcdFx0Y2hhcnQuc2V0Q2hhcnRTaXplKCk7XG5cblx0XHRcdC8vIFJlY29yZCBwcmVsaW1pbmFyeSBkaW1lbnNpb25zIGZvciBsYXRlciBjb21wYXJpc29uXG5cdFx0XHR0ZW1wV2lkdGggPSBjaGFydC5wbG90V2lkdGg7XG5cdFx0XHR0ZW1wSGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQgLSAxMzsgLy8gMTMgaXMgdGhlIG1vc3QgY29tbW9uIGhlaWdodCBvZiBYIGF4aXMgbGFiZWxzXG5cblx0XHRcdC8vIEdldCBtYXJnaW5zIGJ5IHByZS1yZW5kZXJpbmcgYXhlc1xuXHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRheGlzLnNldFNjYWxlKCk7XG5cdFx0XHR9KTtcblx0XHRcdGNoYXJ0LmdldEF4aXNNYXJnaW5zKCk7XG5cblx0XHRcdC8vIElmIHRoZSBwbG90IGFyZWEgc2l6ZSBoYXMgY2hhbmdlZCBzaWduaWZpY2FudGx5LCBjYWxjdWxhdGUgdGljayBwb3NpdGlvbnMgYWdhaW5cblx0XHRcdHJlZG9Ib3Jpem9udGFsID0gdGVtcFdpZHRoIC8gY2hhcnQucGxvdFdpZHRoID4gMS4yO1xuXHRcdFx0cmVkb1ZlcnRpY2FsID0gdGVtcEhlaWdodCAvIGNoYXJ0LnBsb3RIZWlnaHQgPiAxLjE7XG5cblx0XHRcdGlmIChyZWRvSG9yaXpvbnRhbCB8fCByZWRvVmVydGljYWwpIHtcblxuXHRcdFx0XHRjaGFydC5tYXhUaWNrcyA9IG51bGw7IC8vIHJlc2V0IGZvciBzZWNvbmQgcGFzc1xuXHRcdFx0XHRlYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0aWYgKChheGlzLmhvcml6ICYmIHJlZG9Ib3Jpem9udGFsKSB8fCAoIWF4aXMuaG9yaXogJiYgcmVkb1ZlcnRpY2FsKSkge1xuXHRcdFx0XHRcdFx0YXhpcy5zZXRUaWNrSW50ZXJ2YWwodHJ1ZSk7IC8vIHVwZGF0ZSB0byByZWZsZWN0IHRoZSBuZXcgbWFyZ2luc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNoYXJ0LmdldE1hcmdpbnMoKTsgLy8gc2Vjb25kIHBhc3MgdG8gY2hlY2sgZm9yIG5ldyBsYWJlbHNcblx0XHRcdH1cblxuXHRcdFx0Ly8gRHJhdyB0aGUgYm9yZGVycyBhbmQgYmFja2dyb3VuZHNcblx0XHRcdGNoYXJ0LmRyYXdDaGFydEJveCgpO1x0XHRcblxuXG5cdFx0XHQvLyBBeGVzXG5cdFx0XHRpZiAoY2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzKSB7XG5cdFx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRheGlzLnJlbmRlcigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIHNlcmllc1xuXHRcdFx0aWYgKCFjaGFydC5zZXJpZXNHcm91cCkge1xuXHRcdFx0XHRjaGFydC5zZXJpZXNHcm91cCA9IHJlbmRlcmVyLmcoJ3Nlcmllcy1ncm91cCcpXG5cdFx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IDMgfSlcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHR9XG5cdFx0XHRjaGFydC5yZW5kZXJTZXJpZXMoKTtcblxuXHRcdFx0Ly8gTGFiZWxzXG5cdFx0XHRjaGFydC5yZW5kZXJMYWJlbHMoKTtcblxuXHRcdFx0Ly8gQ3JlZGl0c1xuXHRcdFx0Y2hhcnQuc2hvd0NyZWRpdHMob3B0aW9ucy5jcmVkaXRzKTtcblxuXHRcdFx0Ly8gU2V0IGZsYWdcblx0XHRcdGNoYXJ0Lmhhc1JlbmRlcmVkID0gdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTaG93IGNoYXJ0IGNyZWRpdHMgYmFzZWQgb24gY29uZmlnIG9wdGlvbnNcblx0XHQgKi9cblx0XHRzaG93Q3JlZGl0czogZnVuY3Rpb24gKGNyZWRpdHMpIHtcblx0XHRcdGlmIChjcmVkaXRzLmVuYWJsZWQgJiYgIXRoaXMuY3JlZGl0cykge1xuXHRcdFx0XHR0aGlzLmNyZWRpdHMgPSB0aGlzLnJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0Y3JlZGl0cy50ZXh0LFxuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0MFxuXHRcdFx0XHQpXG5cdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKGNyZWRpdHMuaHJlZikge1xuXHRcdFx0XHRcdFx0bG9jYXRpb24uaHJlZiA9IGNyZWRpdHMuaHJlZjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRhbGlnbjogY3JlZGl0cy5wb3NpdGlvbi5hbGlnbixcblx0XHRcdFx0XHR6SW5kZXg6IDhcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyhjcmVkaXRzLnN0eWxlKVxuXHRcdFx0XHQuYWRkKClcblx0XHRcdFx0LmFsaWduKGNyZWRpdHMucG9zaXRpb24pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDbGVhbiB1cCBtZW1vcnkgdXNhZ2Vcblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRheGVzID0gY2hhcnQuYXhlcyxcblx0XHRcdFx0c2VyaWVzID0gY2hhcnQuc2VyaWVzLFxuXHRcdFx0XHRjb250YWluZXIgPSBjaGFydC5jb250YWluZXIsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHBhcmVudE5vZGUgPSBjb250YWluZXIgJiYgY29udGFpbmVyLnBhcmVudE5vZGU7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gZmlyZSB0aGUgY2hhcnQuZGVzdG95IGV2ZW50XG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdkZXN0cm95Jyk7XG5cdFx0XHRcblx0XHRcdC8vIERlbGV0ZSB0aGUgY2hhcnQgZnJvbSBjaGFydHMgbG9va3VwIGFycmF5XG5cdFx0XHRjaGFydHNbY2hhcnQuaW5kZXhdID0gVU5ERUZJTkVEO1xuXHRcdFx0Y2hhcnRDb3VudC0tO1xuXHRcdFx0Y2hhcnQucmVuZGVyVG8ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWhpZ2hjaGFydHMtY2hhcnQnKTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGV2ZW50c1xuXHRcdFx0cmVtb3ZlRXZlbnQoY2hhcnQpO1xuXG5cdFx0XHQvLyA9PT09IERlc3Ryb3kgY29sbGVjdGlvbnM6XG5cdFx0XHQvLyBEZXN0cm95IGF4ZXNcblx0XHRcdGkgPSBheGVzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0YXhlc1tpXSA9IGF4ZXNbaV0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXN0cm95IGVhY2ggc2VyaWVzXG5cdFx0XHRpID0gc2VyaWVzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0c2VyaWVzW2ldID0gc2VyaWVzW2ldLmRlc3Ryb3koKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gPT09PSBEZXN0cm95IGNoYXJ0IHByb3BlcnRpZXM6XG5cdFx0XHRlYWNoKFsndGl0bGUnLCAnc3VidGl0bGUnLCAnY2hhcnRCYWNrZ3JvdW5kJywgJ3Bsb3RCYWNrZ3JvdW5kJywgJ3Bsb3RCR0ltYWdlJywgXG5cdFx0XHRcdFx0J3Bsb3RCb3JkZXInLCAnc2VyaWVzR3JvdXAnLCAnY2xpcFJlY3QnLCAnY3JlZGl0cycsICdwb2ludGVyJywgJ3Njcm9sbGVyJywgXG5cdFx0XHRcdFx0J3JhbmdlU2VsZWN0b3InLCAnbGVnZW5kJywgJ3Jlc2V0Wm9vbUJ1dHRvbicsICd0b29sdGlwJywgJ3JlbmRlcmVyJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdHZhciBwcm9wID0gY2hhcnRbbmFtZV07XG5cblx0XHRcdFx0aWYgKHByb3AgJiYgcHJvcC5kZXN0cm95KSB7XG5cdFx0XHRcdFx0Y2hhcnRbbmFtZV0gPSBwcm9wLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHJlbW92ZSBjb250YWluZXIgYW5kIGFsbCBTVkdcblx0XHRcdGlmIChjb250YWluZXIpIHsgLy8gY2FuIGJyZWFrIGluIElFIHdoZW4gZGVzdHJveWVkIGJlZm9yZSBmaW5pc2hlZCBsb2FkaW5nXG5cdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0cmVtb3ZlRXZlbnQoY29udGFpbmVyKTtcblx0XHRcdFx0aWYgKHBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHRkaXNjYXJkRWxlbWVudChjb250YWluZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2xlYW4gaXQgYWxsIHVwXG5cdFx0XHRmb3IgKGkgaW4gY2hhcnQpIHtcblx0XHRcdFx0ZGVsZXRlIGNoYXJ0W2ldO1xuXHRcdFx0fVxuXG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogVk1MIG5hbWVzcGFjZXMgY2FuJ3QgYmUgYWRkZWQgdW50aWwgYWZ0ZXIgY29tcGxldGUuIExpc3RlbmluZ1xuXHRcdCAqIGZvciBQZXJpbmkncyBkb1Njcm9sbCBoYWNrIGlzIG5vdCBlbm91Z2guXG5cdFx0ICovXG5cdFx0aXNSZWFkeVRvUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzO1xuXG5cdFx0XHQvLyBOb3RlOiBpbiBzcGl0ZSBvZiBKU0xpbnQncyBjb21wbGFpbnRzLCB3aW4gPT0gd2luLnRvcCBpcyByZXF1aXJlZFxuXHRcdFx0Lypqc2xpbnQgZXFlcTogdHJ1ZSovXG5cdFx0XHRpZiAoKCFoYXNTVkcgJiYgKHdpbiA9PSB3aW4udG9wICYmIGRvYy5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSkgfHwgKHVzZUNhblZHICYmICF3aW4uY2FudmcpKSB7XG5cdFx0XHQvKmpzbGludCBlcWVxOiBmYWxzZSovXG5cdFx0XHRcdGlmICh1c2VDYW5WRykge1xuXHRcdFx0XHRcdC8vIERlbGF5IHJlbmRlcmluZyB1bnRpbCBjYW52ZyBsaWJyYXJ5IGlzIGRvd25sb2FkZWQgYW5kIHJlYWR5XG5cdFx0XHRcdFx0Q2FuVkdDb250cm9sbGVyLnB1c2goZnVuY3Rpb24gKCkgeyBjaGFydC5maXJzdFJlbmRlcigpOyB9LCBjaGFydC5vcHRpb25zLmdsb2JhbC5jYW52YXNUb29sc1VSTCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jLmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRkb2MuZGV0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGNoYXJ0LmZpcnN0UmVuZGVyKTtcblx0XHRcdFx0XHRcdGlmIChkb2MucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHRcdFx0XHRcdFx0XHRjaGFydC5maXJzdFJlbmRlcigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQcmVwYXJlIGZvciBmaXJzdCByZW5kZXJpbmcgYWZ0ZXIgYWxsIGRhdGEgYXJlIGxvYWRlZFxuXHRcdCAqL1xuXHRcdGZpcnN0UmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gY2hhcnQub3B0aW9ucyxcblx0XHRcdFx0Y2FsbGJhY2sgPSBjaGFydC5jYWxsYmFjaztcblxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciB0aGUgY2hhcnQgaXMgcmVhZHkgdG8gcmVuZGVyXG5cdFx0XHRpZiAoIWNoYXJ0LmlzUmVhZHlUb1JlbmRlcigpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBjb250YWluZXJcblx0XHRcdGNoYXJ0LmdldENvbnRhaW5lcigpO1xuXG5cdFx0XHQvLyBSdW4gYW4gZWFybHkgZXZlbnQgYWZ0ZXIgdGhlIGNvbnRhaW5lciBhbmQgcmVuZGVyZXIgYXJlIGVzdGFibGlzaGVkXG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdpbml0Jyk7XG5cblx0XHRcdFxuXHRcdFx0Y2hhcnQucmVzZXRNYXJnaW5zKCk7XG5cdFx0XHRjaGFydC5zZXRDaGFydFNpemUoKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBjb21tb24gY2hhcnQgcHJvcGVydGllcyAobWFpbmx5IGludmVydCkgZnJvbSB0aGUgZ2l2ZW4gc2VyaWVzXG5cdFx0XHRjaGFydC5wcm9wRnJvbVNlcmllcygpO1xuXG5cdFx0XHQvLyBnZXQgYXhlc1xuXHRcdFx0Y2hhcnQuZ2V0QXhlcygpO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIHRoZSBzZXJpZXNcblx0XHRcdGVhY2gob3B0aW9ucy5zZXJpZXMgfHwgW10sIGZ1bmN0aW9uIChzZXJpZU9wdGlvbnMpIHtcblx0XHRcdFx0Y2hhcnQuaW5pdFNlcmllcyhzZXJpZU9wdGlvbnMpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGNoYXJ0LmxpbmtTZXJpZXMoKTtcblxuXHRcdFx0Ly8gUnVuIGFuIGV2ZW50IGFmdGVyIGF4ZXMgYW5kIHNlcmllcyBhcmUgaW5pdGlhbGl6ZWQsIGJ1dCBiZWZvcmUgcmVuZGVyLiBBdCB0aGlzIHN0YWdlLFxuXHRcdFx0Ly8gdGhlIHNlcmllcyBkYXRhIGlzIGluZGV4ZWQgYW5kIGNhY2hlZCBpbiB0aGUgeERhdGEgYW5kIHlEYXRhIGFycmF5cywgc28gd2UgY2FuIGFjY2Vzc1xuXHRcdFx0Ly8gdGhvc2UgYmVmb3JlIHJlbmRlcmluZy4gVXNlZCBpbiBIaWdoc3RvY2suIFxuXHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnYmVmb3JlUmVuZGVyJyk7IFxuXG5cdFx0XHQvLyBkZXBlbmRzIG9uIGludmVydGVkIGFuZCBvbiBtYXJnaW5zIGJlaW5nIHNldFxuXHRcdFx0aWYgKEhpZ2hjaGFydHMuUG9pbnRlcikge1xuXHRcdFx0XHRjaGFydC5wb2ludGVyID0gbmV3IFBvaW50ZXIoY2hhcnQsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC5yZW5kZXIoKTtcblxuXHRcdFx0Ly8gYWRkIGNhbnZhc1xuXHRcdFx0Y2hhcnQucmVuZGVyZXIuZHJhdygpO1xuXHRcdFx0Ly8gcnVuIGNhbGxiYWNrc1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KGNoYXJ0LCBbY2hhcnRdKTtcblx0XHRcdH1cblx0XHRcdGVhY2goY2hhcnQuY2FsbGJhY2tzLCBmdW5jdGlvbiAoZm4pIHtcblx0XHRcdFx0aWYgKGNoYXJ0LmluZGV4ICE9PSBVTkRFRklORUQpIHsgLy8gQ2hhcnQgZGVzdHJveWVkIGluIGl0cyBvd24gY2FsbGJhY2sgKCMzNjAwKVxuXHRcdFx0XHRcdGZuLmFwcGx5KGNoYXJ0LCBbY2hhcnRdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIEZpcmUgdGhlIGxvYWQgZXZlbnRcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2xvYWQnKTtcdFx0XG5cdFx0XHRcblx0XHRcdC8vIElmIHRoZSBjaGFydCB3YXMgcmVuZGVyZWQgb3V0c2lkZSB0aGUgdG9wIGNvbnRhaW5lciwgcHV0IGl0IGJhY2sgaW4gKCMzNjc5KVxuXHRcdFx0Y2hhcnQuY2xvbmVSZW5kZXJUbyh0cnVlKTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQqIENyZWF0ZXMgYXJyYXlzIGZvciBzcGFjaW5nIGFuZCBtYXJnaW4gZnJvbSBnaXZlbiBvcHRpb25zLlxuXHRcdCovXG5cdFx0c3BsYXNoQXJyYXk6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBvVmFyID0gb3B0aW9uc1t0YXJnZXRdLFxuXHRcdFx0XHR0QXJyYXkgPSBpc09iamVjdChvVmFyKSA/IG9WYXIgOiBbb1Zhciwgb1Zhciwgb1Zhciwgb1Zhcl07XG5cblx0XHRcdHJldHVybiBbcGljayhvcHRpb25zW3RhcmdldCArICdUb3AnXSwgdEFycmF5WzBdKSxcblx0XHRcdFx0XHRwaWNrKG9wdGlvbnNbdGFyZ2V0ICsgJ1JpZ2h0J10sIHRBcnJheVsxXSksXG5cdFx0XHRcdFx0cGljayhvcHRpb25zW3RhcmdldCArICdCb3R0b20nXSwgdEFycmF5WzJdKSxcblx0XHRcdFx0XHRwaWNrKG9wdGlvbnNbdGFyZ2V0ICsgJ0xlZnQnXSwgdEFycmF5WzNdKV07XG5cdFx0fVxuXHR9OyAvLyBlbmQgQ2hhcnRcblxuXHR2YXIgQ2VudGVyZWRTZXJpZXNNaXhpbiA9IEhpZ2hjaGFydHMuQ2VudGVyZWRTZXJpZXNNaXhpbiA9IHtcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgcGllIGJhc2VkIG9uIHRoZSBzaXplIGFuZCBjZW50ZXIgb3B0aW9ucyByZWxhdGl2ZSB0byB0aGUgIFxuXHRcdCAqIHBsb3QgYXJlYS4gQm9ycm93ZWQgYnkgdGhlIHBvbGFyIGFuZCBnYXVnZSBzZXJpZXMgdHlwZXMuXG5cdFx0ICovXG5cdFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHNsaWNpbmdSb29tID0gMiAqIChvcHRpb25zLnNsaWNlZE9mZnNldCB8fCAwKSxcblx0XHRcdFx0aGFuZGxlU2xpY2luZ1Jvb20sXG5cdFx0XHRcdHBsb3RXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aCAtIDIgKiBzbGljaW5nUm9vbSxcblx0XHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQgLSAyICogc2xpY2luZ1Jvb20sXG5cdFx0XHRcdGNlbnRlck9wdGlvbiA9IG9wdGlvbnMuY2VudGVyLFxuXHRcdFx0XHRwb3NpdGlvbnMgPSBbcGljayhjZW50ZXJPcHRpb25bMF0sICc1MCUnKSwgcGljayhjZW50ZXJPcHRpb25bMV0sICc1MCUnKSwgb3B0aW9ucy5zaXplIHx8ICcxMDAlJywgb3B0aW9ucy5pbm5lclNpemUgfHwgMF0sXG5cdFx0XHRcdHNtYWxsZXN0U2l6ZSA9IG1hdGhNaW4ocGxvdFdpZHRoLCBwbG90SGVpZ2h0KSxcblx0XHRcdFx0aXNQZXJjZW50LFxuXHRcdFx0XHRpLFxuXHRcdFx0XHR2YWx1ZTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7ICsraSkge1xuXHRcdFx0XHR2YWx1ZSA9IHBvc2l0aW9uc1tpXTtcblx0XHRcdFx0aXNQZXJjZW50ID0gLyUkLy50ZXN0KHZhbHVlKTtcblx0XHRcdFx0aGFuZGxlU2xpY2luZ1Jvb20gPSBpIDwgMiB8fCAoaSA9PT0gMiAmJiBpc1BlcmNlbnQpO1xuXHRcdFx0XHRwb3NpdGlvbnNbaV0gPSAoaXNQZXJjZW50ID9cblx0XHRcdFx0XHQvLyBpID09IDA6IGNlbnRlclgsIHJlbGF0aXZlIHRvIHdpZHRoXG5cdFx0XHRcdFx0Ly8gaSA9PSAxOiBjZW50ZXJZLCByZWxhdGl2ZSB0byBoZWlnaHRcblx0XHRcdFx0XHQvLyBpID09IDI6IHNpemUsIHJlbGF0aXZlIHRvIHNtYWxsZXN0U2l6ZVxuXHRcdFx0XHRcdC8vIGkgPT0gMzogaW5uZXJTaXplLCByZWxhdGl2ZSB0byBzaXplXG5cdFx0XHRcdFx0W3Bsb3RXaWR0aCwgcGxvdEhlaWdodCwgc21hbGxlc3RTaXplLCBwb3NpdGlvbnNbMl1dW2ldICpcblx0XHRcdFx0XHRcdHBJbnQodmFsdWUpIC8gMTAwIDpcblx0XHRcdFx0XHRwSW50KHZhbHVlKSkgKyAoaGFuZGxlU2xpY2luZ1Jvb20gPyBzbGljaW5nUm9vbSA6IDApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBvc2l0aW9ucztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBQb2ludCBvYmplY3QgYW5kIHByb3RvdHlwZS4gSW5oZXJpdGFibGUgYW5kIHVzZWQgYXMgYmFzZSBmb3IgUGllUG9pbnRcblx0ICovXG5cdHZhciBQb2ludCA9IGZ1bmN0aW9uICgpIHt9O1xuXHRQb2ludC5wcm90b3R5cGUgPSB7XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBwb2ludFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXMgVGhlIHNlcmllcyBvYmplY3QgY29udGFpbmluZyB0aGlzIHBvaW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIGRhdGEgaW4gZWl0aGVyIG51bWJlciwgYXJyYXkgb3Igb2JqZWN0IGZvcm1hdFxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChzZXJpZXMsIG9wdGlvbnMsIHgpIHtcblxuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0Y29sb3JzO1xuXHRcdFx0cG9pbnQuc2VyaWVzID0gc2VyaWVzO1xuXHRcdFx0cG9pbnQuY29sb3IgPSBzZXJpZXMuY29sb3I7IC8vICMzNDQ1XG5cdFx0XHRwb2ludC5hcHBseU9wdGlvbnMob3B0aW9ucywgeCk7XG5cdFx0XHRwb2ludC5wb2ludEF0dHIgPSB7fTtcblxuXHRcdFx0aWYgKHNlcmllcy5vcHRpb25zLmNvbG9yQnlQb2ludCkge1xuXHRcdFx0XHRjb2xvcnMgPSBzZXJpZXMub3B0aW9ucy5jb2xvcnMgfHwgc2VyaWVzLmNoYXJ0Lm9wdGlvbnMuY29sb3JzO1xuXHRcdFx0XHRwb2ludC5jb2xvciA9IHBvaW50LmNvbG9yIHx8IGNvbG9yc1tzZXJpZXMuY29sb3JDb3VudGVyKytdO1xuXHRcdFx0XHQvLyBsb29wIGJhY2sgdG8gemVyb1xuXHRcdFx0XHRpZiAoc2VyaWVzLmNvbG9yQ291bnRlciA9PT0gY29sb3JzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHNlcmllcy5jb2xvckNvdW50ZXIgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy5jaGFydC5wb2ludENvdW50Kys7XG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBBcHBseSB0aGUgb3B0aW9ucyBjb250YWluaW5nIHRoZSB4IGFuZCB5IGRhdGEgYW5kIHBvc3NpYmxlIHNvbWUgZXh0cmEgcHJvcGVydGllcy5cblx0XHQgKiBUaGlzIGlzIGNhbGxlZCBvbiBwb2ludCBpbml0IG9yIGZyb20gcG9pbnQudXBkYXRlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0XHQgKi9cblx0XHRhcHBseU9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zLCB4KSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdHBvaW50VmFsS2V5ID0gc2VyaWVzLm9wdGlvbnMucG9pbnRWYWxLZXkgfHwgc2VyaWVzLnBvaW50VmFsS2V5O1xuXG5cdFx0XHRvcHRpb25zID0gUG9pbnQucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0XHQvLyBjb3B5IG9wdGlvbnMgZGlyZWN0bHkgdG8gcG9pbnRcblx0XHRcdGV4dGVuZChwb2ludCwgb3B0aW9ucyk7XG5cdFx0XHRwb2ludC5vcHRpb25zID0gcG9pbnQub3B0aW9ucyA/IGV4dGVuZChwb2ludC5vcHRpb25zLCBvcHRpb25zKSA6IG9wdGlvbnM7XG5cblx0XHRcdC8vIEZvciBoaWdoZXIgZGltZW5zaW9uIHNlcmllcyB0eXBlcy4gRm9yIGluc3RhbmNlLCBmb3IgcmFuZ2VzLCBwb2ludC55IGlzIG1hcHBlZCB0byBwb2ludC5sb3cuXG5cdFx0XHRpZiAocG9pbnRWYWxLZXkpIHtcblx0XHRcdFx0cG9pbnQueSA9IHBvaW50W3BvaW50VmFsS2V5XTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm8geCBpcyBzZXQgYnkgbm93LCBnZXQgYXV0byBpbmNyZW1lbnRlZCB2YWx1ZS4gQWxsIHBvaW50cyBtdXN0IGhhdmUgYW5cblx0XHRcdC8vIHggdmFsdWUsIGhvd2V2ZXIgdGhlIHkgdmFsdWUgY2FuIGJlIG51bGwgdG8gY3JlYXRlIGEgZ2FwIGluIHRoZSBzZXJpZXNcblx0XHRcdGlmIChwb2ludC54ID09PSBVTkRFRklORUQgJiYgc2VyaWVzKSB7XG5cdFx0XHRcdHBvaW50LnggPSB4ID09PSBVTkRFRklORUQgPyBzZXJpZXMuYXV0b0luY3JlbWVudCgpIDogeDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUcmFuc2Zvcm0gbnVtYmVyIG9yIGFycmF5IGNvbmZpZ3MgaW50byBvYmplY3RzXG5cdFx0ICovXG5cdFx0b3B0aW9uc1RvT2JqZWN0OiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFx0dmFyIHJldCA9IHt9LFxuXHRcdFx0XHRzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdFx0cG9pbnRBcnJheU1hcCA9IHNlcmllcy5wb2ludEFycmF5TWFwIHx8IFsneSddLFxuXHRcdFx0XHR2YWx1ZUNvdW50ID0gcG9pbnRBcnJheU1hcC5sZW5ndGgsXG5cdFx0XHRcdGZpcnN0SXRlbVR5cGUsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRqID0gMDtcblxuXHRcdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyB8fCBvcHRpb25zID09PSBudWxsKSB7XG5cdFx0XHRcdHJldFtwb2ludEFycmF5TWFwWzBdXSA9IG9wdGlvbnM7XG5cblx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShvcHRpb25zKSkge1xuXHRcdFx0XHQvLyB3aXRoIGxlYWRpbmcgeCB2YWx1ZVxuXHRcdFx0XHRpZiAob3B0aW9ucy5sZW5ndGggPiB2YWx1ZUNvdW50KSB7XG5cdFx0XHRcdFx0Zmlyc3RJdGVtVHlwZSA9IHR5cGVvZiBvcHRpb25zWzBdO1xuXHRcdFx0XHRcdGlmIChmaXJzdEl0ZW1UeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0cmV0Lm5hbWUgPSBvcHRpb25zWzBdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZmlyc3RJdGVtVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdHJldC54ID0gb3B0aW9uc1swXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChqIDwgdmFsdWVDb3VudCkge1xuXHRcdFx0XHRcdHJldFtwb2ludEFycmF5TWFwW2orK11dID0gb3B0aW9uc1tpKytdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRyZXQgPSBvcHRpb25zO1xuXG5cdFx0XHRcdC8vIFRoaXMgaXMgdGhlIGZhc3Rlc3Qgd2F5IHRvIGRldGVjdCBpZiB0aGVyZSBhcmUgaW5kaXZpZHVhbCBwb2ludCBkYXRhTGFiZWxzIHRoYXQgbmVlZFxuXHRcdFx0XHQvLyB0byBiZSBjb25zaWRlcmVkIGluIGRyYXdEYXRhTGFiZWxzLiBUaGVzZSBjYW4gb25seSBvY2N1ciBpbiBvYmplY3QgY29uZmlncy5cblx0XHRcdFx0aWYgKG9wdGlvbnMuZGF0YUxhYmVscykge1xuXHRcdFx0XHRcdHNlcmllcy5faGFzUG9pbnRMYWJlbHMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2FtZSBhcHByb2FjaCBhcyBhYm92ZSBmb3IgbWFya2Vyc1xuXHRcdFx0XHRpZiAob3B0aW9ucy5tYXJrZXIpIHtcblx0XHRcdFx0XHRzZXJpZXMuX2hhc1BvaW50TWFya2VycyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3kgYSBwb2ludCB0byBjbGVhciBtZW1vcnkuIEl0cyByZWZlcmVuY2Ugc3RpbGwgc3RheXMgaW4gc2VyaWVzLmRhdGEuXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0aG92ZXJQb2ludHMgPSBjaGFydC5ob3ZlclBvaW50cyxcblx0XHRcdFx0cHJvcDtcblxuXHRcdFx0Y2hhcnQucG9pbnRDb3VudC0tO1xuXG5cdFx0XHRpZiAoaG92ZXJQb2ludHMpIHtcblx0XHRcdFx0cG9pbnQuc2V0U3RhdGUoKTtcblx0XHRcdFx0ZXJhc2UoaG92ZXJQb2ludHMsIHBvaW50KTtcblx0XHRcdFx0aWYgKCFob3ZlclBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjaGFydC5ob3ZlclBvaW50cyA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdFx0aWYgKHBvaW50ID09PSBjaGFydC5ob3ZlclBvaW50KSB7XG5cdFx0XHRcdHBvaW50Lm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGFsbCBldmVudHNcblx0XHRcdGlmIChwb2ludC5ncmFwaGljIHx8IHBvaW50LmRhdGFMYWJlbCkgeyAvLyByZW1vdmVFdmVudCBhbmQgZGVzdHJveUVsZW1lbnRzIGFyZSBwZXJmb3JtYW5jZSBleHBlbnNpdmVcblx0XHRcdFx0cmVtb3ZlRXZlbnQocG9pbnQpO1xuXHRcdFx0XHRwb2ludC5kZXN0cm95RWxlbWVudHMoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBvaW50LmxlZ2VuZEl0ZW0pIHsgLy8gcGllcyBoYXZlIGxlZ2VuZCBpdGVtc1xuXHRcdFx0XHRjaGFydC5sZWdlbmQuZGVzdHJveUl0ZW0ocG9pbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHByb3AgaW4gcG9pbnQpIHtcblx0XHRcdFx0cG9pbnRbcHJvcF0gPSBudWxsO1xuXHRcdFx0fVxuXG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBTVkcgZWxlbWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb2ludFxuXHRcdCAqL1xuXHRcdGRlc3Ryb3lFbGVtZW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0cHJvcHMgPSBbJ2dyYXBoaWMnLCAnZGF0YUxhYmVsJywgJ2RhdGFMYWJlbFVwcGVyJywgJ2dyb3VwJywgJ2Nvbm5lY3RvcicsICdzaGFkb3dHcm91cCddLFxuXHRcdFx0XHRwcm9wLFxuXHRcdFx0XHRpID0gNjtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0XHRpZiAocG9pbnRbcHJvcF0pIHtcblx0XHRcdFx0XHRwb2ludFtwcm9wXSA9IHBvaW50W3Byb3BdLmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdGhlIGNvbmZpZ3VyYXRpb24gaGFzaCBuZWVkZWQgZm9yIHRoZSBkYXRhIGxhYmVsIGFuZCB0b29sdGlwIGZvcm1hdHRlcnNcblx0XHQgKi9cblx0XHRnZXRMYWJlbENvbmZpZzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcztcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHBvaW50LmNhdGVnb3J5LFxuXHRcdFx0XHR5OiBwb2ludC55LFxuXHRcdFx0XHRrZXk6IHBvaW50Lm5hbWUgfHwgcG9pbnQuY2F0ZWdvcnksXG5cdFx0XHRcdHNlcmllczogcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRwb2ludDogcG9pbnQsXG5cdFx0XHRcdHBlcmNlbnRhZ2U6IHBvaW50LnBlcmNlbnRhZ2UsXG5cdFx0XHRcdHRvdGFsOiBwb2ludC50b3RhbCB8fCBwb2ludC5zdGFja1RvdGFsXG5cdFx0XHR9O1xuXHRcdH0sXHRcblxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZGFibGUgbWV0aG9kIGZvciBmb3JtYXR0aW5nIGVhY2ggcG9pbnQncyB0b29sdGlwIGxpbmVcblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgdG8gYmUgY29uY2F0ZW5hdGVkIGluIHRvIHRoZSBjb21tb24gdG9vbHRpcCB0ZXh0XG5cdFx0ICovXG5cdFx0dG9vbHRpcEZvcm1hdHRlcjogZnVuY3Rpb24gKHBvaW50Rm9ybWF0KSB7XG5cblx0XHRcdC8vIEluc2VydCBvcHRpb25zIGZvciB2YWx1ZURlY2ltYWxzLCB2YWx1ZVByZWZpeCwgYW5kIHZhbHVlU3VmZml4XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcy5zZXJpZXMsXG5cdFx0XHRcdHNlcmllc1Rvb2x0aXBPcHRpb25zID0gc2VyaWVzLnRvb2x0aXBPcHRpb25zLFxuXHRcdFx0XHR2YWx1ZURlY2ltYWxzID0gcGljayhzZXJpZXNUb29sdGlwT3B0aW9ucy52YWx1ZURlY2ltYWxzLCAnJyksXG5cdFx0XHRcdHZhbHVlUHJlZml4ID0gc2VyaWVzVG9vbHRpcE9wdGlvbnMudmFsdWVQcmVmaXggfHwgJycsXG5cdFx0XHRcdHZhbHVlU3VmZml4ID0gc2VyaWVzVG9vbHRpcE9wdGlvbnMudmFsdWVTdWZmaXggfHwgJyc7XG5cblx0XHRcdC8vIExvb3Agb3ZlciB0aGUgcG9pbnQgYXJyYXkgbWFwIGFuZCByZXBsYWNlIHVuZm9ybWF0dGVkIHZhbHVlcyB3aXRoIHNwcmludGYgZm9ybWF0dGluZyBtYXJrdXBcblx0XHRcdGVhY2goc2VyaWVzLnBvaW50QXJyYXlNYXAgfHwgWyd5J10sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0a2V5ID0gJ3twb2ludC4nICsga2V5OyAvLyB3aXRob3V0IHRoZSBjbG9zaW5nIGJyYWNrZXRcblx0XHRcdFx0aWYgKHZhbHVlUHJlZml4IHx8IHZhbHVlU3VmZml4KSB7XG5cdFx0XHRcdFx0cG9pbnRGb3JtYXQgPSBwb2ludEZvcm1hdC5yZXBsYWNlKGtleSArICd9JywgdmFsdWVQcmVmaXggKyBrZXkgKyAnfScgKyB2YWx1ZVN1ZmZpeCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9pbnRGb3JtYXQgPSBwb2ludEZvcm1hdC5yZXBsYWNlKGtleSArICd9Jywga2V5ICsgJzosLicgKyB2YWx1ZURlY2ltYWxzICsgJ2Z9Jyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGZvcm1hdChwb2ludEZvcm1hdCwge1xuXHRcdFx0XHRwb2ludDogdGhpcyxcblx0XHRcdFx0c2VyaWVzOiB0aGlzLnNlcmllc1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpcmUgYW4gZXZlbnQgb24gdGhlIFBvaW50IG9iamVjdC4gTXVzdCBub3QgYmUgcmVuYW1lZCB0byBmaXJlRXZlbnQsIGFzIHRoaXNcblx0XHQgKiBjYXVzZXMgYSBuYW1lIGNsYXNoIGluIE1vb1Rvb2xzXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEFyZ3MgQWRkaXRpb25hbCBldmVudCBhcmd1bWVudHNcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWZhdWx0RnVuY3Rpb24gRGVmYXVsdCBldmVudCBoYW5kbGVyXG5cdFx0ICovXG5cdFx0ZmlyZVBvaW50RXZlbnQ6IGZ1bmN0aW9uIChldmVudFR5cGUsIGV2ZW50QXJncywgZGVmYXVsdEZ1bmN0aW9uKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zO1xuXG5cdFx0XHQvLyBsb2FkIGV2ZW50IGhhbmRsZXJzIG9uIGRlbWFuZCB0byBzYXZlIHRpbWUgb24gbW91c2VvdmVyL291dFxuXHRcdFx0aWYgKHNlcmllc09wdGlvbnMucG9pbnQuZXZlbnRzW2V2ZW50VHlwZV0gfHwgKHBvaW50Lm9wdGlvbnMgJiYgcG9pbnQub3B0aW9ucy5ldmVudHMgJiYgcG9pbnQub3B0aW9ucy5ldmVudHNbZXZlbnRUeXBlXSkpIHtcblx0XHRcdFx0dGhpcy5pbXBvcnRFdmVudHMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGRlZmF1bHQgaGFuZGxlciBpZiBpbiBzZWxlY3Rpb24gbW9kZVxuXHRcdFx0aWYgKGV2ZW50VHlwZSA9PT0gJ2NsaWNrJyAmJiBzZXJpZXNPcHRpb25zLmFsbG93UG9pbnRTZWxlY3QpIHtcblx0XHRcdFx0ZGVmYXVsdEZ1bmN0aW9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdFx0Ly8gQ29udHJvbCBrZXkgaXMgZm9yIFdpbmRvd3MsIG1ldGEgKD0gQ21kIGtleSkgZm9yIE1hYywgU2hpZnQgZm9yIE9wZXJhXG5cdFx0XHRcdFx0cG9pbnQuc2VsZWN0KG51bGwsIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGZpcmVFdmVudCh0aGlzLCBldmVudFR5cGUsIGV2ZW50QXJncywgZGVmYXVsdEZ1bmN0aW9uKTtcblx0XHR9XG5cdH07LyoqXG5cdCAqIEBjbGFzc0Rlc2NyaXB0aW9uIFRoZSBiYXNlIGZ1bmN0aW9uIHdoaWNoIGFsbCBvdGhlciBzZXJpZXMgdHlwZXMgaW5oZXJpdCBmcm9tLiBUaGUgZGF0YSBpbiB0aGUgc2VyaWVzIGlzIHN0b3JlZFxuXHQgKiBpbiB2YXJpb3VzIGFycmF5cy5cblx0ICpcblx0ICogLSBGaXJzdCwgc2VyaWVzLm9wdGlvbnMuZGF0YSBjb250YWlucyBhbGwgdGhlIG9yaWdpbmFsIGNvbmZpZyBvcHRpb25zIGZvclxuXHQgKiBlYWNoIHBvaW50IHdoZXRoZXIgYWRkZWQgYnkgb3B0aW9ucyBvciBtZXRob2RzIGxpa2Ugc2VyaWVzLmFkZFBvaW50LlxuXHQgKiAtIE5leHQsIHNlcmllcy5kYXRhIGNvbnRhaW5zIHRob3NlIHZhbHVlcyBjb252ZXJ0ZWQgdG8gcG9pbnRzLCBidXQgaW4gY2FzZSB0aGUgc2VyaWVzIGRhdGEgbGVuZ3RoXG5cdCAqIGV4Y2VlZHMgdGhlIGNyb3BUaHJlc2hvbGQsIG9yIGlmIHRoZSBkYXRhIGlzIGdyb3VwZWQsIHNlcmllcy5kYXRhIGRvZXNuJ3QgY29udGFpbiBhbGwgdGhlIHBvaW50cy4gSXRcblx0ICogb25seSBjb250YWlucyB0aGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWQgb24gZGVtYW5kLlxuXHQgKiAtIFRoZW4gdGhlcmUncyBzZXJpZXMucG9pbnRzIHRoYXQgY29udGFpbnMgYWxsIGN1cnJlbnRseSB2aXNpYmxlIHBvaW50IG9iamVjdHMuIEluIGNhc2Ugb2YgY3JvcHBpbmcsXG5cdCAqIHRoZSBjcm9wcGVkLWF3YXkgcG9pbnRzIGFyZSBub3QgcGFydCBvZiB0aGlzIGFycmF5LiBUaGUgc2VyaWVzLnBvaW50cyBhcnJheSBzdGFydHMgYXQgc2VyaWVzLmNyb3BTdGFydFxuXHQgKiBjb21wYXJlZCB0byBzZXJpZXMuZGF0YSBhbmQgc2VyaWVzLm9wdGlvbnMuZGF0YS4gSWYgaG93ZXZlciB0aGUgc2VyaWVzIGRhdGEgaXMgZ3JvdXBlZCwgdGhlc2UgY2FuJ3Rcblx0ICogYmUgY29ycmVsYXRlZCBvbmUgdG8gb25lLlxuXHQgKiAtIHNlcmllcy54RGF0YSBhbmQgc2VyaWVzLnByb2Nlc3NlZFhEYXRhIGNvbnRhaW4gY2xlYW4geCB2YWx1ZXMsIGVxdWl2YWxlbnQgdG8gc2VyaWVzLmRhdGEgYW5kIHNlcmllcy5wb2ludHMuXG5cdCAqIC0gc2VyaWVzLnlEYXRhIGFuZCBzZXJpZXMucHJvY2Vzc2VkWURhdGEgY29udGFpbiBjbGVhbiB4IHZhbHVlcywgZXF1aXZhbGVudCB0byBzZXJpZXMuZGF0YSBhbmQgc2VyaWVzLnBvaW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHR2YXIgU2VyaWVzID0gSGlnaGNoYXJ0cy5TZXJpZXMgPSBmdW5jdGlvbiAoKSB7fTtcblxuXHRTZXJpZXMucHJvdG90eXBlID0ge1xuXG5cdFx0aXNDYXJ0ZXNpYW46IHRydWUsXG5cdFx0dHlwZTogJ2xpbmUnLFxuXHRcdHBvaW50Q2xhc3M6IFBvaW50LFxuXHRcdHNvcnRlZDogdHJ1ZSwgLy8gcmVxdWlyZXMgdGhlIGRhdGEgdG8gYmUgc29ydGVkXG5cdFx0cmVxdWlyZVNvcnRpbmc6IHRydWUsXG5cdFx0cG9pbnRBdHRyVG9PcHRpb25zOiB7IC8vIG1hcHBpbmcgYmV0d2VlbiBTVkcgYXR0cmlidXRlcyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW9uc1xuXHRcdFx0c3Ryb2tlOiAnbGluZUNvbG9yJyxcblx0XHRcdCdzdHJva2Utd2lkdGgnOiAnbGluZVdpZHRoJyxcblx0XHRcdGZpbGw6ICdmaWxsQ29sb3InLFxuXHRcdFx0cjogJ3JhZGl1cydcblx0XHR9LFxuXHRcdGF4aXNUeXBlczogWyd4QXhpcycsICd5QXhpcyddLFxuXHRcdGNvbG9yQ291bnRlcjogMCxcblx0XHRwYXJhbGxlbEFycmF5czogWyd4JywgJ3knXSwgLy8gZWFjaCBwb2ludCdzIHggYW5kIHkgdmFsdWVzIGFyZSBzdG9yZWQgaW4gdGhpcy54RGF0YSBhbmQgdGhpcy55RGF0YVxuXHRcdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGV2ZW50VHlwZSxcblx0XHRcdFx0ZXZlbnRzLFxuXHRcdFx0XHRjaGFydFNlcmllcyA9IGNoYXJ0LnNlcmllcyxcblx0XHRcdFx0c29ydEJ5SW5kZXggPSBmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBwaWNrKGEub3B0aW9ucy5pbmRleCwgYS5faSkgLSBwaWNrKGIub3B0aW9ucy5pbmRleCwgYi5faSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdHNlcmllcy5jaGFydCA9IGNoYXJ0O1xuXHRcdFx0c2VyaWVzLm9wdGlvbnMgPSBvcHRpb25zID0gc2VyaWVzLnNldE9wdGlvbnMob3B0aW9ucyk7IC8vIG1lcmdlIHdpdGggcGxvdE9wdGlvbnNcblx0XHRcdHNlcmllcy5saW5rZWRTZXJpZXMgPSBbXTtcblxuXHRcdFx0Ly8gYmluZCB0aGUgYXhlc1xuXHRcdFx0c2VyaWVzLmJpbmRBeGVzKCk7XG5cblx0XHRcdC8vIHNldCBzb21lIHZhcmlhYmxlc1xuXHRcdFx0ZXh0ZW5kKHNlcmllcywge1xuXHRcdFx0XHRuYW1lOiBvcHRpb25zLm5hbWUsXG5cdFx0XHRcdHN0YXRlOiBOT1JNQUxfU1RBVEUsXG5cdFx0XHRcdHBvaW50QXR0cjoge30sXG5cdFx0XHRcdHZpc2libGU6IG9wdGlvbnMudmlzaWJsZSAhPT0gZmFsc2UsIC8vIHRydWUgYnkgZGVmYXVsdFxuXHRcdFx0XHRzZWxlY3RlZDogb3B0aW9ucy5zZWxlY3RlZCA9PT0gdHJ1ZSAvLyBmYWxzZSBieSBkZWZhdWx0XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gc3BlY2lhbFxuXHRcdFx0aWYgKHVzZUNhblZHKSB7XG5cdFx0XHRcdG9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyc1xuXHRcdFx0ZXZlbnRzID0gb3B0aW9ucy5ldmVudHM7XG5cdFx0XHRmb3IgKGV2ZW50VHlwZSBpbiBldmVudHMpIHtcblx0XHRcdFx0YWRkRXZlbnQoc2VyaWVzLCBldmVudFR5cGUsIGV2ZW50c1tldmVudFR5cGVdKTtcblx0XHRcdH1cblx0XHRcdGlmIChcblx0XHRcdFx0KGV2ZW50cyAmJiBldmVudHMuY2xpY2spIHx8XG5cdFx0XHRcdChvcHRpb25zLnBvaW50ICYmIG9wdGlvbnMucG9pbnQuZXZlbnRzICYmIG9wdGlvbnMucG9pbnQuZXZlbnRzLmNsaWNrKSB8fFxuXHRcdFx0XHRvcHRpb25zLmFsbG93UG9pbnRTZWxlY3Rcblx0XHRcdCkge1xuXHRcdFx0XHRjaGFydC5ydW5UcmFja2VyQ2xpY2sgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMuZ2V0Q29sb3IoKTtcblx0XHRcdHNlcmllcy5nZXRTeW1ib2woKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhXG5cdFx0XHRlYWNoKHNlcmllcy5wYXJhbGxlbEFycmF5cywgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRzZXJpZXNba2V5ICsgJ0RhdGEnXSA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRzZXJpZXMuc2V0RGF0YShvcHRpb25zLmRhdGEsIGZhbHNlKTtcblxuXHRcdFx0Ly8gTWFyayBjYXJ0ZXNpYW5cblx0XHRcdGlmIChzZXJpZXMuaXNDYXJ0ZXNpYW4pIHtcblx0XHRcdFx0Y2hhcnQuaGFzQ2FydGVzaWFuU2VyaWVzID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVnaXN0ZXIgaXQgaW4gdGhlIGNoYXJ0XG5cdFx0XHRjaGFydFNlcmllcy5wdXNoKHNlcmllcyk7XG5cdFx0XHRzZXJpZXMuX2kgPSBjaGFydFNlcmllcy5sZW5ndGggLSAxO1xuXG5cdFx0XHQvLyBTb3J0IHNlcmllcyBhY2NvcmRpbmcgdG8gaW5kZXggb3B0aW9uICgjMjQ4LCAjMTEyMywgIzI0NTYpXG5cdFx0XHRzdGFibGVTb3J0KGNoYXJ0U2VyaWVzLCBzb3J0QnlJbmRleCk7XG5cdFx0XHRpZiAodGhpcy55QXhpcykge1xuXHRcdFx0XHRzdGFibGVTb3J0KHRoaXMueUF4aXMuc2VyaWVzLCBzb3J0QnlJbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdGVhY2goY2hhcnRTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcblx0XHRcdFx0c2VyaWVzLmluZGV4ID0gaTtcblx0XHRcdFx0c2VyaWVzLm5hbWUgPSBzZXJpZXMubmFtZSB8fCAnU2VyaWVzICcgKyAoaSArIDEpO1xuXHRcdFx0fSk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSB4QXhpcyBhbmQgeUF4aXMgcHJvcGVydGllcyBvZiBjYXJ0ZXNpYW4gc2VyaWVzLCBhbmQgcmVnaXN0ZXIgdGhlIHNlcmllc1xuXHRcdCAqIGluIHRoZSBheGlzLnNlcmllcyBhcnJheVxuXHRcdCAqL1xuXHRcdGJpbmRBeGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0YXhpc09wdGlvbnM7XG5cblx0XHRcdGVhY2goc2VyaWVzLmF4aXNUeXBlcyB8fCBbXSwgZnVuY3Rpb24gKEFYSVMpIHsgLy8gcmVwZWF0IGZvciB4QXhpcyBhbmQgeUF4aXNcblxuXHRcdFx0XHRlYWNoKGNoYXJ0W0FYSVNdLCBmdW5jdGlvbiAoYXhpcykgeyAvLyBsb29wIHRocm91Z2ggdGhlIGNoYXJ0J3MgYXhpcyBvYmplY3RzXG5cdFx0XHRcdFx0YXhpc09wdGlvbnMgPSBheGlzLm9wdGlvbnM7XG5cblx0XHRcdFx0XHQvLyBhcHBseSBpZiB0aGUgc2VyaWVzIHhBeGlzIG9yIHlBeGlzIG9wdGlvbiBtYXRoY2hlcyB0aGUgbnVtYmVyIG9mIHRoZVxuXHRcdFx0XHRcdC8vIGF4aXMsIG9yIGlmIHVuZGVmaW5lZCwgdXNlIHRoZSBmaXJzdCBheGlzXG5cdFx0XHRcdFx0aWYgKChzZXJpZXNPcHRpb25zW0FYSVNdID09PSBheGlzT3B0aW9ucy5pbmRleCkgfHxcblx0XHRcdFx0XHRcdFx0KHNlcmllc09wdGlvbnNbQVhJU10gIT09IFVOREVGSU5FRCAmJiBzZXJpZXNPcHRpb25zW0FYSVNdID09PSBheGlzT3B0aW9ucy5pZCkgfHxcblx0XHRcdFx0XHRcdFx0KHNlcmllc09wdGlvbnNbQVhJU10gPT09IFVOREVGSU5FRCAmJiBheGlzT3B0aW9ucy5pbmRleCA9PT0gMCkpIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmVnaXN0ZXIgdGhpcyBzZXJpZXMgaW4gdGhlIGF4aXMuc2VyaWVzIGxvb2t1cFxuXHRcdFx0XHRcdFx0YXhpcy5zZXJpZXMucHVzaChzZXJpZXMpO1xuXG5cdFx0XHRcdFx0XHQvLyBzZXQgdGhpcyBzZXJpZXMueEF4aXMgb3Igc2VyaWVzLnlBeGlzIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0c2VyaWVzW0FYSVNdID0gYXhpcztcblxuXHRcdFx0XHRcdFx0Ly8gbWFyayBkaXJ0eSBmb3IgcmVkcmF3XG5cdFx0XHRcdFx0XHRheGlzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gVGhlIHNlcmllcyBuZWVkcyBhbiBYIGFuZCBhbiBZIGF4aXNcblx0XHRcdFx0aWYgKCFzZXJpZXNbQVhJU10gJiYgc2VyaWVzLm9wdGlvbmFsQXhpcyAhPT0gQVhJUykge1xuXHRcdFx0XHRcdGVycm9yKDE4LCB0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRm9yIHNpbXBsZSBzZXJpZXMgdHlwZXMgbGlrZSBsaW5lIGFuZCBjb2x1bW4sIHRoZSBkYXRhIHZhbHVlcyBhcmUgaGVsZCBpbiBhcnJheXMgbGlrZVxuXHRcdCAqIHhEYXRhIGFuZCB5RGF0YSBmb3IgcXVpY2sgbG9va3VwIHRvIGZpbmQgZXh0cmVtZXMgYW5kIG1vcmUuIEZvciBtdWx0aWRpbWVuc2lvbmFsIHNlcmllc1xuXHRcdCAqIGxpa2UgYnViYmxlIGFuZCBtYXAsIHRoaXMgY2FuIGJlIGV4dGVuZGVkIHdpdGggYXJyYXlzIGxpa2UgekRhdGEgYW5kIHZhbHVlRGF0YSBieVxuXHRcdCAqIGFkZGluZyB0byB0aGUgc2VyaWVzLnBhcmFsbGVsQXJyYXlzIGFycmF5LlxuXHRcdCAqL1xuXHRcdHVwZGF0ZVBhcmFsbGVsQXJyYXlzOiBmdW5jdGlvbiAocG9pbnQsIGkpIHtcblx0XHRcdHZhciBzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdGZuID0gdHlwZW9mIGkgPT09ICdudW1iZXInID9cblx0XHRcdFx0XHQgLy8gSW5zZXJ0IHRoZSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gcG9zaXRpb25cblx0XHRcdFx0XHRmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsID0ga2V5ID09PSAneScgJiYgc2VyaWVzLnRvWURhdGEgPyBzZXJpZXMudG9ZRGF0YShwb2ludCkgOiBwb2ludFtrZXldO1xuXHRcdFx0XHRcdFx0c2VyaWVzW2tleSArICdEYXRhJ11baV0gPSB2YWw7XG5cdFx0XHRcdFx0fSA6XG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIG1ldGhvZCBzcGVjaWZpZWQgaW4gaSB3aXRoIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzIGFzIGFyZ3VtZW50c1xuXHRcdFx0XHRcdGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdEFycmF5LnByb3RvdHlwZVtpXS5hcHBseShzZXJpZXNba2V5ICsgJ0RhdGEnXSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMikpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdGVhY2goc2VyaWVzLnBhcmFsbGVsQXJyYXlzLCBmbik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhbiBhdXRvIGluY3JlbWVudGVkIHggdmFsdWUgYmFzZWQgb24gdGhlIHBvaW50U3RhcnQgYW5kIHBvaW50SW50ZXJ2YWwgb3B0aW9ucy5cblx0XHQgKiBUaGlzIGlzIG9ubHkgdXNlZCBpZiBhbiB4IHZhbHVlIGlzIG5vdCBnaXZlbiBmb3IgdGhlIHBvaW50IHRoYXQgY2FsbHMgYXV0b0luY3JlbWVudC5cblx0XHQgKi9cblx0XHRhdXRvSW5jcmVtZW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR4SW5jcmVtZW50ID0gdGhpcy54SW5jcmVtZW50LFxuXHRcdFx0XHRkYXRlLFxuXHRcdFx0XHRwb2ludEludGVydmFsLFxuXHRcdFx0XHRwb2ludEludGVydmFsVW5pdCA9IG9wdGlvbnMucG9pbnRJbnRlcnZhbFVuaXQ7XG5cdFx0XHRcblx0XHRcdHhJbmNyZW1lbnQgPSBwaWNrKHhJbmNyZW1lbnQsIG9wdGlvbnMucG9pbnRTdGFydCwgMCk7XG5cdFx0XHRcblx0XHRcdHRoaXMucG9pbnRJbnRlcnZhbCA9IHBvaW50SW50ZXJ2YWwgPSBwaWNrKHRoaXMucG9pbnRJbnRlcnZhbCwgb3B0aW9ucy5wb2ludEludGVydmFsLCAxKTtcblx0XHRcdFxuXHRcdFx0Ly8gQWRkZWQgY29kZSBmb3IgcG9pbnRJbnRlcnZhbCBzdHJpbmdzXG5cdFx0XHRpZiAocG9pbnRJbnRlcnZhbFVuaXQgPT09ICdtb250aCcgfHwgcG9pbnRJbnRlcnZhbFVuaXQgPT09ICd5ZWFyJykge1xuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoeEluY3JlbWVudCk7XG5cdFx0XHRcdGRhdGUgPSAocG9pbnRJbnRlcnZhbFVuaXQgPT09ICdtb250aCcpID9cblx0XHRcdFx0XHQrZGF0ZVtzZXRNb250aF0oZGF0ZVtnZXRNb250aF0oKSArIHBvaW50SW50ZXJ2YWwpIDpcblx0XHRcdFx0XHQrZGF0ZVtzZXRGdWxsWWVhcl0oZGF0ZVtnZXRGdWxsWWVhcl0oKSArIHBvaW50SW50ZXJ2YWwpO1xuXHRcdFx0XHRwb2ludEludGVydmFsID0gZGF0ZSAtIHhJbmNyZW1lbnQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMueEluY3JlbWVudCA9IHhJbmNyZW1lbnQgKyBwb2ludEludGVydmFsO1xuXHRcdFx0cmV0dXJuIHhJbmNyZW1lbnQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERpdmlkZSB0aGUgc2VyaWVzIGRhdGEgaW50byBzZWdtZW50cyBkaXZpZGVkIGJ5IG51bGwgdmFsdWVzLlxuXHRcdCAqL1xuXHRcdGdldFNlZ21lbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0bGFzdE51bGwgPSAtMSxcblx0XHRcdFx0c2VnbWVudHMgPSBbXSxcblx0XHRcdFx0aSxcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdFx0cG9pbnRzTGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdFx0aWYgKHBvaW50c0xlbmd0aCkgeyAvLyBubyBhY3Rpb24gcmVxdWlyZWQgZm9yIFtdXG5cblx0XHRcdFx0Ly8gaWYgY29ubmVjdCBudWxscywganVzdCByZW1vdmUgbnVsbCBwb2ludHNcblx0XHRcdFx0aWYgKHNlcmllcy5vcHRpb25zLmNvbm5lY3ROdWxscykge1xuXHRcdFx0XHRcdGkgPSBwb2ludHNMZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdFx0aWYgKHBvaW50c1tpXS55ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHBvaW50cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRzZWdtZW50cyA9IFtwb2ludHNdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBlbHNlLCBzcGxpdCBvbiBudWxsIHBvaW50c1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQsIGkpIHtcblx0XHRcdFx0XHRcdGlmIChwb2ludC55ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpID4gbGFzdE51bGwgKyAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VnbWVudHMucHVzaChwb2ludHMuc2xpY2UobGFzdE51bGwgKyAxLCBpKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bGFzdE51bGwgPSBpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSBwb2ludHNMZW5ndGggLSAxKSB7IC8vIGxhc3QgdmFsdWVcblx0XHRcdFx0XHRcdFx0c2VnbWVudHMucHVzaChwb2ludHMuc2xpY2UobGFzdE51bGwgKyAxLCBpICsgMSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZ2lzdGVyIGl0XG5cdFx0XHRzZXJpZXMuc2VnbWVudHMgPSBzZWdtZW50cztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBzZXJpZXMgb3B0aW9ucyBieSBtZXJnaW5nIGZyb20gdGhlIG9wdGlvbnMgdHJlZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtT3B0aW9uc1xuXHRcdCAqL1xuXHRcdHNldE9wdGlvbnM6IGZ1bmN0aW9uIChpdGVtT3B0aW9ucykge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0Y2hhcnRPcHRpb25zID0gY2hhcnQub3B0aW9ucyxcblx0XHRcdFx0cGxvdE9wdGlvbnMgPSBjaGFydE9wdGlvbnMucGxvdE9wdGlvbnMsXG5cdFx0XHRcdHVzZXJPcHRpb25zID0gY2hhcnQudXNlck9wdGlvbnMgfHwge30sXG5cdFx0XHRcdHVzZXJQbG90T3B0aW9ucyA9IHVzZXJPcHRpb25zLnBsb3RPcHRpb25zIHx8IHt9LFxuXHRcdFx0XHR0eXBlT3B0aW9ucyA9IHBsb3RPcHRpb25zW3RoaXMudHlwZV0sXG5cdFx0XHRcdG9wdGlvbnMsXG5cdFx0XHRcdHpvbmVzO1xuXG5cdFx0XHR0aGlzLnVzZXJPcHRpb25zID0gaXRlbU9wdGlvbnM7XG5cblx0XHRcdC8vIEdlbmVyYWwgc2VyaWVzIG9wdGlvbnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgdHlwZSBvcHRpb25zIGJlY2F1c2Ugb3RoZXJ3aXNlLCBkZWZhdWx0XG5cdFx0XHQvLyB0eXBlIG9wdGlvbnMgbGlrZSBjb2x1bW4uYW5pbWF0aW9uIHdvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBnZW5lcmFsIG9wdGlvbi5cblx0XHRcdC8vIEJ1dCBpc3N1ZXMgaGF2ZSBiZWVuIHJhaXNlZCBoZXJlICgjMzg4MSksIGFuZCB0aGUgc29sdXRpb24gbWF5IGJlIHRvIGRpc3Rpbmd1aXNoIFxuXHRcdFx0Ly8gYmV0d2VlbiBkZWZhdWx0IG9wdGlvbiBhbmQgdXNlck9wdGlvbnMgbGlrZSBpbiB0aGUgdG9vbHRpcCBiZWxvdy5cblx0XHRcdG9wdGlvbnMgPSBtZXJnZShcblx0XHRcdFx0dHlwZU9wdGlvbnMsXG5cdFx0XHRcdHBsb3RPcHRpb25zLnNlcmllcyxcblx0XHRcdFx0aXRlbU9wdGlvbnNcblx0XHRcdCk7XG5cblx0XHRcdC8vIFRoZSB0b29sdGlwIG9wdGlvbnMgYXJlIG1lcmdlZCBiZXR3ZWVuIGdsb2JhbCBhbmQgc2VyaWVzIHNwZWNpZmljIG9wdGlvbnNcblx0XHRcdHRoaXMudG9vbHRpcE9wdGlvbnMgPSBtZXJnZShcblx0XHRcdFx0ZGVmYXVsdE9wdGlvbnMudG9vbHRpcCxcblx0XHRcdFx0ZGVmYXVsdE9wdGlvbnMucGxvdE9wdGlvbnNbdGhpcy50eXBlXS50b29sdGlwLFxuXHRcdFx0XHR1c2VyT3B0aW9ucy50b29sdGlwLFxuXHRcdFx0XHR1c2VyUGxvdE9wdGlvbnMuc2VyaWVzICYmIHVzZXJQbG90T3B0aW9ucy5zZXJpZXMudG9vbHRpcCxcblx0XHRcdFx0dXNlclBsb3RPcHRpb25zW3RoaXMudHlwZV0gJiYgdXNlclBsb3RPcHRpb25zW3RoaXMudHlwZV0udG9vbHRpcCxcblx0XHRcdFx0aXRlbU9wdGlvbnMudG9vbHRpcFxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gRGVsZXRlIG1hcmtlciBvYmplY3QgaWYgbm90IGFsbG93ZWQgKCMxMTI1KVxuXHRcdFx0aWYgKHR5cGVPcHRpb25zLm1hcmtlciA9PT0gbnVsbCkge1xuXHRcdFx0XHRkZWxldGUgb3B0aW9ucy5tYXJrZXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBjb2xvciB6b25lc1xuXHRcdFx0dGhpcy56b25lQXhpcyA9IG9wdGlvbnMuem9uZUF4aXM7XG5cdFx0XHR6b25lcyA9IHRoaXMuem9uZXMgPSAob3B0aW9ucy56b25lcyB8fCBbXSkuc2xpY2UoKTtcblx0XHRcdGlmICgob3B0aW9ucy5uZWdhdGl2ZUNvbG9yIHx8IG9wdGlvbnMubmVnYXRpdmVGaWxsQ29sb3IpICYmICFvcHRpb25zLnpvbmVzKSB7XG5cdFx0XHRcdHpvbmVzLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBvcHRpb25zW3RoaXMuem9uZUF4aXMgKyAnVGhyZXNob2xkJ10gfHwgb3B0aW9ucy50aHJlc2hvbGQgfHwgMCxcblx0XHRcdFx0XHRjb2xvcjogb3B0aW9ucy5uZWdhdGl2ZUNvbG9yLFxuXHRcdFx0XHRcdGZpbGxDb2xvcjogb3B0aW9ucy5uZWdhdGl2ZUZpbGxDb2xvclxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGlmICh6b25lcy5sZW5ndGgpIHsgLy8gUHVzaCBvbmUgZXh0cmEgem9uZSBmb3IgdGhlIHJlc3Rcblx0XHRcdFx0aWYgKGRlZmluZWQoem9uZXNbem9uZXMubGVuZ3RoIC0gMV0udmFsdWUpKSB7XG5cdFx0XHRcdFx0em9uZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRjb2xvcjogdGhpcy5jb2xvcixcblx0XHRcdFx0XHRcdGZpbGxDb2xvcjogdGhpcy5maWxsQ29sb3Jcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdGlvbnM7XG5cdFx0fSxcblxuXHRcdGdldEN5Y2xpYzogZnVuY3Rpb24gKHByb3AsIHZhbHVlLCBkZWZhdWx0cykge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdHVzZXJPcHRpb25zID0gdGhpcy51c2VyT3B0aW9ucyxcblx0XHRcdFx0aW5kZXhOYW1lID0gJ18nICsgcHJvcCArICdJbmRleCcsXG5cdFx0XHRcdGNvdW50ZXJOYW1lID0gcHJvcCArICdDb3VudGVyJztcblxuXHRcdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRpZiAoZGVmaW5lZCh1c2VyT3B0aW9uc1tpbmRleE5hbWVdKSkgeyAvLyBhZnRlciBTZXJpZXMudXBkYXRlKClcblx0XHRcdFx0XHRpID0gdXNlck9wdGlvbnNbaW5kZXhOYW1lXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1c2VyT3B0aW9uc1tpbmRleE5hbWVdID0gaSA9IHRoaXMuY2hhcnRbY291bnRlck5hbWVdICUgZGVmYXVsdHMubGVuZ3RoO1xuXHRcdFx0XHRcdHRoaXMuY2hhcnRbY291bnRlck5hbWVdICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBkZWZhdWx0c1tpXTtcblx0XHRcdH1cblx0XHRcdHRoaXNbcHJvcF0gPSB2YWx1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBzZXJpZXMnIGNvbG9yXG5cdFx0ICovXG5cdFx0Z2V0Q29sb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmNvbG9yQnlQb2ludCkge1xuXHRcdFx0XHR0aGlzLmdldEN5Y2xpYygnY29sb3InLCB0aGlzLm9wdGlvbnMuY29sb3IgfHwgZGVmYXVsdFBsb3RPcHRpb25zW3RoaXMudHlwZV0uY29sb3IsIHRoaXMuY2hhcnQub3B0aW9ucy5jb2xvcnMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBzZXJpZXMnIHN5bWJvbFxuXHRcdCAqL1xuXHRcdGdldFN5bWJvbDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllc01hcmtlck9wdGlvbiA9IHRoaXMub3B0aW9ucy5tYXJrZXI7XG5cblx0XHRcdHRoaXMuZ2V0Q3ljbGljKCdzeW1ib2wnLCBzZXJpZXNNYXJrZXJPcHRpb24uc3ltYm9sLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuc3ltYm9scyk7XG5cblx0XHRcdC8vIGRvbid0IHN1YnN0cmFjdCByYWRpdXMgaW4gaW1hZ2Ugc3ltYm9scyAoIzYwNClcblx0XHRcdGlmICgvXnVybC8udGVzdCh0aGlzLnN5bWJvbCkpIHtcblx0XHRcdFx0c2VyaWVzTWFya2VyT3B0aW9uLnJhZGl1cyA9IDA7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRyYXdMZWdlbmRTeW1ib2w6IExlZ2VuZFN5bWJvbE1peGluLmRyYXdMaW5lTWFya2VyLFxuXG5cdFx0LyoqXG5cdFx0ICogUmVwbGFjZSB0aGUgc2VyaWVzIGRhdGEgd2l0aCBhIG5ldyBzZXQgb2YgZGF0YVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHJlZHJhd1xuXHRcdCAqL1xuXHRcdHNldERhdGE6IGZ1bmN0aW9uIChkYXRhLCByZWRyYXcsIGFuaW1hdGlvbiwgdXBkYXRlUG9pbnRzKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0b2xkRGF0YSA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRcdG9sZERhdGFMZW5ndGggPSAob2xkRGF0YSAmJiBvbGREYXRhLmxlbmd0aCkgfHwgMCxcblx0XHRcdFx0ZGF0YUxlbmd0aCxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0Zmlyc3RQb2ludCA9IG51bGwsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHRoYXNDYXRlZ29yaWVzID0geEF4aXMgJiYgISF4QXhpcy5jYXRlZ29yaWVzLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHR0dXJib1RocmVzaG9sZCA9IG9wdGlvbnMudHVyYm9UaHJlc2hvbGQsXG5cdFx0XHRcdHB0LFxuXHRcdFx0XHR4RGF0YSA9IHRoaXMueERhdGEsXG5cdFx0XHRcdHlEYXRhID0gdGhpcy55RGF0YSxcblx0XHRcdFx0cG9pbnRBcnJheU1hcCA9IHNlcmllcy5wb2ludEFycmF5TWFwLFxuXHRcdFx0XHR2YWx1ZUNvdW50ID0gcG9pbnRBcnJheU1hcCAmJiBwb2ludEFycmF5TWFwLmxlbmd0aDtcblxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgW107XG5cdFx0XHRkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHRcdC8vIElmIHRoZSBwb2ludCBjb3VudCBpcyB0aGUgc2FtZSBhcyBpcyB3YXMsIGp1c3QgcnVuIFBvaW50LnVwZGF0ZSB3aGljaCBpc1xuXHRcdFx0Ly8gY2hlYXBlciwgYWxsb3dzIGFuaW1hdGlvbiwgYW5kIGtlZXBzIHJlZmVyZW5jZXMgdG8gcG9pbnRzLlxuXHRcdFx0aWYgKHVwZGF0ZVBvaW50cyAhPT0gZmFsc2UgJiYgZGF0YUxlbmd0aCAmJiBvbGREYXRhTGVuZ3RoID09PSBkYXRhTGVuZ3RoICYmICFzZXJpZXMuY3JvcHBlZCAmJiAhc2VyaWVzLmhhc0dyb3VwZWREYXRhICYmIHNlcmllcy52aXNpYmxlKSB7XG5cdFx0XHRcdGVhY2goZGF0YSwgZnVuY3Rpb24gKHBvaW50LCBpKSB7XG5cdFx0XHRcdFx0b2xkRGF0YVtpXS51cGRhdGUocG9pbnQsIGZhbHNlLCBudWxsLCBmYWxzZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFJlc2V0IHByb3BlcnRpZXNcblx0XHRcdFx0c2VyaWVzLnhJbmNyZW1lbnQgPSBudWxsO1xuXHRcdFx0XHRzZXJpZXMucG9pbnRSYW5nZSA9IGhhc0NhdGVnb3JpZXMgPyAxIDogb3B0aW9ucy5wb2ludFJhbmdlO1xuXG5cdFx0XHRcdHNlcmllcy5jb2xvckNvdW50ZXIgPSAwOyAvLyBmb3Igc2VyaWVzIHdpdGggY29sb3JCeVBvaW50ICgjMTU0Nylcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFVwZGF0ZSBwYXJhbGxlbCBhcnJheXNcblx0XHRcdFx0ZWFjaCh0aGlzLnBhcmFsbGVsQXJyYXlzLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0c2VyaWVzW2tleSArICdEYXRhJ10ubGVuZ3RoID0gMDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gSW4gdHVyYm8gbW9kZSwgb25seSBvbmUtIG9yIHR3b2RpbWVuc2lvbmFsIGFycmF5cyBvZiBudW1iZXJzIGFyZSBhbGxvd2VkLiBUaGVcblx0XHRcdFx0Ly8gZmlyc3QgdmFsdWUgaXMgdGVzdGVkLCBhbmQgd2UgYXNzdW1lIHRoYXQgYWxsIHRoZSByZXN0IGFyZSBkZWZpbmVkIHRoZSBzYW1lXG5cdFx0XHRcdC8vIHdheS4gQWx0aG91Z2ggdGhlICdmb3InIGxvb3BzIGFyZSBzaW1pbGFyLCB0aGV5IGFyZSByZXBlYXRlZCBpbnNpZGUgZWFjaFxuXHRcdFx0XHQvLyBpZi1lbHNlIGNvbmRpdGlvbmFsIGZvciBtYXggcGVyZm9ybWFuY2UuXG5cdFx0XHRcdGlmICh0dXJib1RocmVzaG9sZCAmJiBkYXRhTGVuZ3RoID4gdHVyYm9UaHJlc2hvbGQpIHtcblxuXHRcdFx0XHRcdC8vIGZpbmQgdGhlIGZpcnN0IG5vbi1udWxsIHBvaW50XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKGZpcnN0UG9pbnQgPT09IG51bGwgJiYgaSA8IGRhdGFMZW5ndGgpIHtcblx0XHRcdFx0XHRcdGZpcnN0UG9pbnQgPSBkYXRhW2ldO1xuXHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0aWYgKGlzTnVtYmVyKGZpcnN0UG9pbnQpKSB7IC8vIGFzc3VtZSBhbGwgcG9pbnRzIGFyZSBudW1iZXJzXG5cdFx0XHRcdFx0XHR2YXIgeCA9IHBpY2sob3B0aW9ucy5wb2ludFN0YXJ0LCAwKSxcblx0XHRcdFx0XHRcdFx0cG9pbnRJbnRlcnZhbCA9IHBpY2sob3B0aW9ucy5wb2ludEludGVydmFsLCAxKTtcblxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR4RGF0YVtpXSA9IHg7XG5cdFx0XHRcdFx0XHRcdHlEYXRhW2ldID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdFx0eCArPSBwb2ludEludGVydmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2VyaWVzLnhJbmNyZW1lbnQgPSB4O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShmaXJzdFBvaW50KSkgeyAvLyBhc3N1bWUgYWxsIHBvaW50cyBhcmUgYXJyYXlzXG5cdFx0XHRcdFx0XHRpZiAodmFsdWVDb3VudCkgeyAvLyBbeCwgbG93LCBoaWdoXSBvciBbeCwgbywgaCwgbCwgY11cblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHB0ID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdFx0XHR4RGF0YVtpXSA9IHB0WzBdO1xuXHRcdFx0XHRcdFx0XHRcdHlEYXRhW2ldID0gcHQuc2xpY2UoMSwgdmFsdWVDb3VudCArIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBbeCwgeV1cblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHB0ID0gZGF0YVtpXTtcblx0XHRcdFx0XHRcdFx0XHR4RGF0YVtpXSA9IHB0WzBdO1xuXHRcdFx0XHRcdFx0XHRcdHlEYXRhW2ldID0gcHRbMV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXJyb3IoMTIpOyAvLyBIaWdoY2hhcnRzIGV4cGVjdHMgY29uZmlncyB0byBiZSBudW1iZXJzIG9yIGFycmF5cyBpbiB0dXJibyBtb2RlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChkYXRhW2ldICE9PSBVTkRFRklORUQpIHsgLy8gc3RyYXkgY29tbWFzIGluIG9sZElFXG5cdFx0XHRcdFx0XHRcdHB0ID0geyBzZXJpZXM6IHNlcmllcyB9O1xuXHRcdFx0XHRcdFx0XHRzZXJpZXMucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KHB0LCBbZGF0YVtpXV0pO1xuXHRcdFx0XHRcdFx0XHRzZXJpZXMudXBkYXRlUGFyYWxsZWxBcnJheXMocHQsIGkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaGFzQ2F0ZWdvcmllcyAmJiBwdC5uYW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0eEF4aXMubmFtZXNbcHQueF0gPSBwdC5uYW1lOyAvLyAjMjA0NlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yZ2V0dGluZyB0byBjYXN0IHN0cmluZ3MgdG8gbnVtYmVycyBpcyBhIGNvbW1vbiBjYXZlYXQgd2hlbiBoYW5kbGluZyBDU1Ygb3IgSlNPTlxuXHRcdFx0XHRpZiAoaXNTdHJpbmcoeURhdGFbMF0pKSB7XG5cdFx0XHRcdFx0ZXJyb3IoMTQsIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VyaWVzLmRhdGEgPSBbXTtcblx0XHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdC8vc2VyaWVzLnpEYXRhID0gekRhdGE7XG5cblx0XHRcdFx0Ly8gZGVzdHJveSBvbGQgcG9pbnRzXG5cdFx0XHRcdGkgPSBvbGREYXRhTGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0aWYgKG9sZERhdGFbaV0gJiYgb2xkRGF0YVtpXS5kZXN0cm95KSB7XG5cdFx0XHRcdFx0XHRvbGREYXRhW2ldLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZXNldCBtaW5SYW5nZSAoIzg3OClcblx0XHRcdFx0aWYgKHhBeGlzKSB7XG5cdFx0XHRcdFx0eEF4aXMubWluUmFuZ2UgPSB4QXhpcy51c2VyTWluUmFuZ2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWRyYXdcblx0XHRcdFx0c2VyaWVzLmlzRGlydHkgPSBzZXJpZXMuaXNEaXJ0eURhdGEgPSBjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTtcblx0XHRcdFx0YW5pbWF0aW9uID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByb2Nlc3MgdGhlIGRhdGEgYnkgY3JvcHBpbmcgYXdheSB1bnVzZWQgZGF0YSBwb2ludHMgaWYgdGhlIHNlcmllcyBpcyBsb25nZXJcblx0XHQgKiB0aGFuIHRoZSBjcm9wIHRocmVzaG9sZC4gVGhpcyBzYXZlcyBjb21wdXRpbmcgdGltZSBmb3IgbGFnZSBzZXJpZXMuXG5cdFx0ICovXG5cdFx0cHJvY2Vzc0RhdGE6IGZ1bmN0aW9uIChmb3JjZSkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHByb2Nlc3NlZFhEYXRhID0gc2VyaWVzLnhEYXRhLCAvLyBjb3BpZWQgZHVyaW5nIHNsaWNlIG9wZXJhdGlvbiBiZWxvd1xuXHRcdFx0XHRwcm9jZXNzZWRZRGF0YSA9IHNlcmllcy55RGF0YSxcblx0XHRcdFx0ZGF0YUxlbmd0aCA9IHByb2Nlc3NlZFhEYXRhLmxlbmd0aCxcblx0XHRcdFx0Y3JvcHBlZERhdGEsXG5cdFx0XHRcdGNyb3BTdGFydCA9IDAsXG5cdFx0XHRcdGNyb3BwZWQsXG5cdFx0XHRcdGRpc3RhbmNlLFxuXHRcdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSxcblx0XHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHRcdGksIC8vIGxvb3AgdmFyaWFibGVcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRjcm9wVGhyZXNob2xkID0gb3B0aW9ucy5jcm9wVGhyZXNob2xkLFxuXHRcdFx0XHRpc0NhcnRlc2lhbiA9IHNlcmllcy5pc0NhcnRlc2lhbixcblx0XHRcdFx0eEV4dHJlbWVzLFxuXHRcdFx0XHRtaW4sXG5cdFx0XHRcdG1heDtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlcmllcyBkYXRhIG9yIGF4ZXMgaGF2ZW4ndCBjaGFuZ2VkLCBkb24ndCBnbyB0aHJvdWdoIHRoaXMuIFJldHVybiBmYWxzZSB0byBwYXNzXG5cdFx0XHQvLyB0aGUgbWVzc2FnZSBvbiB0byBvdmVycmlkZSBtZXRob2RzIGxpa2UgaW4gZGF0YSBncm91cGluZy5cblx0XHRcdGlmIChpc0NhcnRlc2lhbiAmJiAhc2VyaWVzLmlzRGlydHkgJiYgIXhBeGlzLmlzRGlydHkgJiYgIXNlcmllcy55QXhpcy5pc0RpcnR5ICYmICFmb3JjZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh4QXhpcykge1xuXHRcdFx0XHR4RXh0cmVtZXMgPSB4QXhpcy5nZXRFeHRyZW1lcygpOyAvLyBjb3JyZWN0ZWQgZm9yIGxvZyBheGlzICgjMzA1Mylcblx0XHRcdFx0bWluID0geEV4dHJlbWVzLm1pbjtcblx0XHRcdFx0bWF4ID0geEV4dHJlbWVzLm1heDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gb3B0aW9uYWxseSBmaWx0ZXIgb3V0IHBvaW50cyBvdXRzaWRlIHRoZSBwbG90IGFyZWFcblx0XHRcdGlmIChpc0NhcnRlc2lhbiAmJiBzZXJpZXMuc29ydGVkICYmICghY3JvcFRocmVzaG9sZCB8fCBkYXRhTGVuZ3RoID4gY3JvcFRocmVzaG9sZCB8fCBzZXJpZXMuZm9yY2VDcm9wKSkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gaXQncyBvdXRzaWRlIGN1cnJlbnQgZXh0cmVtZXNcblx0XHRcdFx0aWYgKHByb2Nlc3NlZFhEYXRhW2RhdGFMZW5ndGggLSAxXSA8IG1pbiB8fCBwcm9jZXNzZWRYRGF0YVswXSA+IG1heCkge1xuXHRcdFx0XHRcdHByb2Nlc3NlZFhEYXRhID0gW107XG5cdFx0XHRcdFx0cHJvY2Vzc2VkWURhdGEgPSBbXTtcblxuXHRcdFx0XHQvLyBvbmx5IGNyb3AgaWYgaXQncyBhY3R1YWxseSBzcGlsbGluZyBvdXRcblx0XHRcdFx0fSBlbHNlIGlmIChwcm9jZXNzZWRYRGF0YVswXSA8IG1pbiB8fCBwcm9jZXNzZWRYRGF0YVtkYXRhTGVuZ3RoIC0gMV0gPiBtYXgpIHtcblx0XHRcdFx0XHRjcm9wcGVkRGF0YSA9IHRoaXMuY3JvcERhdGEoc2VyaWVzLnhEYXRhLCBzZXJpZXMueURhdGEsIG1pbiwgbWF4KTtcblx0XHRcdFx0XHRwcm9jZXNzZWRYRGF0YSA9IGNyb3BwZWREYXRhLnhEYXRhO1xuXHRcdFx0XHRcdHByb2Nlc3NlZFlEYXRhID0gY3JvcHBlZERhdGEueURhdGE7XG5cdFx0XHRcdFx0Y3JvcFN0YXJ0ID0gY3JvcHBlZERhdGEuc3RhcnQ7XG5cdFx0XHRcdFx0Y3JvcHBlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBGaW5kIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGJldHdlZW4gcHJvY2Vzc2VkIHBvaW50c1xuXHRcdFx0Zm9yIChpID0gcHJvY2Vzc2VkWERhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0ZGlzdGFuY2UgPSBwcm9jZXNzZWRYRGF0YVtpXSAtIHByb2Nlc3NlZFhEYXRhW2kgLSAxXTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA+IDAgJiYgKGNsb3Nlc3RQb2ludFJhbmdlID09PSBVTkRFRklORUQgfHwgZGlzdGFuY2UgPCBjbG9zZXN0UG9pbnRSYW5nZSkpIHtcblx0XHRcdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSA9IGRpc3RhbmNlO1xuXG5cdFx0XHRcdC8vIFVuc29ydGVkIGRhdGEgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgbGluZSB0b29sdGlwLCBhcyB3ZWxsIGFzIGRhdGEgZ3JvdXBpbmcgYW5kXG5cdFx0XHRcdC8vIG5hdmlnYXRpb24gaW4gU3RvY2sgY2hhcnRzICgjNzI1KSBhbmQgd2lkdGggY2FsY3VsYXRpb24gb2YgY29sdW1ucyAoIzE5MDApXG5cdFx0XHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAwICYmIHNlcmllcy5yZXF1aXJlU29ydGluZykge1xuXHRcdFx0XHRcdGVycm9yKDE1KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWNvcmQgdGhlIHByb3BlcnRpZXNcblx0XHRcdHNlcmllcy5jcm9wcGVkID0gY3JvcHBlZDsgLy8gdW5kZWZpbmVkIG9yIHRydWVcblx0XHRcdHNlcmllcy5jcm9wU3RhcnQgPSBjcm9wU3RhcnQ7XG5cdFx0XHRzZXJpZXMucHJvY2Vzc2VkWERhdGEgPSBwcm9jZXNzZWRYRGF0YTtcblx0XHRcdHNlcmllcy5wcm9jZXNzZWRZRGF0YSA9IHByb2Nlc3NlZFlEYXRhO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5wb2ludFJhbmdlID09PSBudWxsKSB7IC8vIG51bGwgbWVhbnMgYXV0bywgYXMgZm9yIGNvbHVtbnMsIGNhbmRsZXN0aWNrcyBhbmQgT0hMQ1xuXHRcdFx0XHRzZXJpZXMucG9pbnRSYW5nZSA9IGNsb3Nlc3RQb2ludFJhbmdlIHx8IDE7XG5cdFx0XHR9XG5cdFx0XHRzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2UgPSBjbG9zZXN0UG9pbnRSYW5nZTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJdGVyYXRlIG92ZXIgeERhdGEgYW5kIGNyb3AgdmFsdWVzIGJldHdlZW4gbWluIGFuZCBtYXguIFJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgY3JvcCBzdGFydC9lbmRcblx0XHQgKiBjcm9wcGVkIHhEYXRhIHdpdGggY29ycmVzcG9uZGluZyBwYXJ0IG9mIHlEYXRhLCBkYXRhTWluIGFuZCBkYXRhTWF4IHdpdGhpbiB0aGUgY3JvcHBlZCByYW5nZVxuXHRcdCAqL1xuXHRcdGNyb3BEYXRhOiBmdW5jdGlvbiAoeERhdGEsIHlEYXRhLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIGRhdGFMZW5ndGggPSB4RGF0YS5sZW5ndGgsXG5cdFx0XHRcdGNyb3BTdGFydCA9IDAsXG5cdFx0XHRcdGNyb3BFbmQgPSBkYXRhTGVuZ3RoLFxuXHRcdFx0XHRjcm9wU2hvdWxkZXIgPSBwaWNrKHRoaXMuY3JvcFNob3VsZGVyLCAxKSwgLy8gbGluZS10eXBlIHNlcmllcyBuZWVkIG9uZSBwb2ludCBvdXRzaWRlXG5cdFx0XHRcdGk7XG5cblx0XHRcdC8vIGl0ZXJhdGUgdXAgdG8gZmluZCBzbGljZSBzdGFydFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoeERhdGFbaV0gPj0gbWluKSB7XG5cdFx0XHRcdFx0Y3JvcFN0YXJ0ID0gbWF0aE1heCgwLCBpIC0gY3JvcFNob3VsZGVyKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9jZWVkIHRvIGZpbmQgc2xpY2UgZW5kXG5cdFx0XHRmb3IgKDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoeERhdGFbaV0gPiBtYXgpIHtcblx0XHRcdFx0XHRjcm9wRW5kID0gaSArIGNyb3BTaG91bGRlcjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4RGF0YTogeERhdGEuc2xpY2UoY3JvcFN0YXJ0LCBjcm9wRW5kKSxcblx0XHRcdFx0eURhdGE6IHlEYXRhLnNsaWNlKGNyb3BTdGFydCwgY3JvcEVuZCksXG5cdFx0XHRcdHN0YXJ0OiBjcm9wU3RhcnQsXG5cdFx0XHRcdGVuZDogY3JvcEVuZFxuXHRcdFx0fTtcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBHZW5lcmF0ZSB0aGUgZGF0YSBwb2ludCBhZnRlciB0aGUgZGF0YSBoYXMgYmVlbiBwcm9jZXNzZWQgYnkgY3JvcHBpbmcgYXdheVxuXHRcdCAqIHVudXNlZCBwb2ludHMgYW5kIG9wdGlvbmFsbHkgZ3JvdXBlZCBpbiBIaWdoY2hhcnRzIFN0b2NrLlxuXHRcdCAqL1xuXHRcdGdlbmVyYXRlUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRkYXRhT3B0aW9ucyA9IG9wdGlvbnMuZGF0YSxcblx0XHRcdFx0ZGF0YSA9IHNlcmllcy5kYXRhLFxuXHRcdFx0XHRkYXRhTGVuZ3RoLFxuXHRcdFx0XHRwcm9jZXNzZWRYRGF0YSA9IHNlcmllcy5wcm9jZXNzZWRYRGF0YSxcblx0XHRcdFx0cHJvY2Vzc2VkWURhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWURhdGEsXG5cdFx0XHRcdHBvaW50Q2xhc3MgPSBzZXJpZXMucG9pbnRDbGFzcyxcblx0XHRcdFx0cHJvY2Vzc2VkRGF0YUxlbmd0aCA9IHByb2Nlc3NlZFhEYXRhLmxlbmd0aCxcblx0XHRcdFx0Y3JvcFN0YXJ0ID0gc2VyaWVzLmNyb3BTdGFydCB8fCAwLFxuXHRcdFx0XHRjdXJzb3IsXG5cdFx0XHRcdGhhc0dyb3VwZWREYXRhID0gc2VyaWVzLmhhc0dyb3VwZWREYXRhLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0cG9pbnRzID0gW10sXG5cdFx0XHRcdGk7XG5cblx0XHRcdGlmICghZGF0YSAmJiAhaGFzR3JvdXBlZERhdGEpIHtcblx0XHRcdFx0dmFyIGFyciA9IFtdO1xuXHRcdFx0XHRhcnIubGVuZ3RoID0gZGF0YU9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRkYXRhID0gc2VyaWVzLmRhdGEgPSBhcnI7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwcm9jZXNzZWREYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y3Vyc29yID0gY3JvcFN0YXJ0ICsgaTtcblx0XHRcdFx0aWYgKCFoYXNHcm91cGVkRGF0YSkge1xuXHRcdFx0XHRcdGlmIChkYXRhW2N1cnNvcl0pIHtcblx0XHRcdFx0XHRcdHBvaW50ID0gZGF0YVtjdXJzb3JdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGF0YU9wdGlvbnNbY3Vyc29yXSAhPT0gVU5ERUZJTkVEKSB7IC8vICM5NzBcblx0XHRcdFx0XHRcdGRhdGFbY3Vyc29yXSA9IHBvaW50ID0gKG5ldyBwb2ludENsYXNzKCkpLmluaXQoc2VyaWVzLCBkYXRhT3B0aW9uc1tjdXJzb3JdLCBwcm9jZXNzZWRYRGF0YVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvaW50c1tpXSA9IHBvaW50O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHNwbGF0IHRoZSB5IGRhdGEgaW4gY2FzZSBvZiBvaGxjIGRhdGEgYXJyYXlcblx0XHRcdFx0XHRwb2ludHNbaV0gPSAobmV3IHBvaW50Q2xhc3MoKSkuaW5pdChzZXJpZXMsIFtwcm9jZXNzZWRYRGF0YVtpXV0uY29uY2F0KHNwbGF0KHByb2Nlc3NlZFlEYXRhW2ldKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBvaW50c1tpXS5pbmRleCA9IGN1cnNvcjsgLy8gRm9yIGZhc3RlciBhY2Nlc3MgaW4gUG9pbnQudXBkYXRlXG5cdFx0XHR9XG5cblx0XHRcdC8vIEhpZGUgY3JvcHBlZC1hd2F5IHBvaW50cyAtIHRoaXMgb25seSBydW5zIHdoZW4gdGhlIG51bWJlciBvZiBwb2ludHMgaXMgYWJvdmUgY3JvcFRocmVzaG9sZCwgb3Igd2hlblxuXHRcdFx0Ly8gc3dpdGhjaGluZyB2aWV3IGZyb20gbm9uLWdyb3VwZWQgZGF0YSB0byBncm91cGVkIGRhdGEgKCM2MzcpXG5cdFx0XHRpZiAoZGF0YSAmJiAocHJvY2Vzc2VkRGF0YUxlbmd0aCAhPT0gKGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCkgfHwgaGFzR3JvdXBlZERhdGEpKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaSA9PT0gY3JvcFN0YXJ0ICYmICFoYXNHcm91cGVkRGF0YSkgeyAvLyB3aGVuIGhhcyBncm91cGVkIGRhdGEsIGNsZWFyIGFsbCBwb2ludHNcblx0XHRcdFx0XHRcdGkgKz0gcHJvY2Vzc2VkRGF0YUxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRhdGFbaV0pIHtcblx0XHRcdFx0XHRcdGRhdGFbaV0uZGVzdHJveUVsZW1lbnRzKCk7XG5cdFx0XHRcdFx0XHRkYXRhW2ldLnBsb3RYID0gVU5ERUZJTkVEOyAvLyAjMTAwM1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRzZXJpZXMucG9pbnRzID0gcG9pbnRzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGUgWSBleHRyZW1lcyBmb3IgdmlzaWJsZSBkYXRhXG5cdFx0ICovXG5cdFx0Z2V0RXh0cmVtZXM6IGZ1bmN0aW9uICh5RGF0YSkge1xuXHRcdFx0dmFyIHhBeGlzID0gdGhpcy54QXhpcyxcblx0XHRcdFx0eUF4aXMgPSB0aGlzLnlBeGlzLFxuXHRcdFx0XHR4RGF0YSA9IHRoaXMucHJvY2Vzc2VkWERhdGEsXG5cdFx0XHRcdHlEYXRhTGVuZ3RoLFxuXHRcdFx0XHRhY3RpdmVZRGF0YSA9IFtdLFxuXHRcdFx0XHRhY3RpdmVDb3VudGVyID0gMCxcblx0XHRcdFx0eEV4dHJlbWVzID0geEF4aXMuZ2V0RXh0cmVtZXMoKSwgLy8gIzIxMTcsIG5lZWQgdG8gY29tcGVuc2F0ZSBmb3IgbG9nIFggYXhpc1xuXHRcdFx0XHR4TWluID0geEV4dHJlbWVzLm1pbixcblx0XHRcdFx0eE1heCA9IHhFeHRyZW1lcy5tYXgsXG5cdFx0XHRcdHZhbGlkVmFsdWUsXG5cdFx0XHRcdHdpdGhpblJhbmdlLFxuXHRcdFx0XHRkYXRhTWluLFxuXHRcdFx0XHRkYXRhTWF4LFxuXHRcdFx0XHR4LFxuXHRcdFx0XHR5LFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRqO1xuXG5cdFx0XHR5RGF0YSA9IHlEYXRhIHx8IHRoaXMuc3RhY2tlZFlEYXRhIHx8IHRoaXMucHJvY2Vzc2VkWURhdGE7XG5cdFx0XHR5RGF0YUxlbmd0aCA9IHlEYXRhLmxlbmd0aDtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHlEYXRhTGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0XHR4ID0geERhdGFbaV07XG5cdFx0XHRcdHkgPSB5RGF0YVtpXTtcblxuXHRcdFx0XHQvLyBGb3IgcG9pbnRzIHdpdGhpbiB0aGUgdmlzaWJsZSByYW5nZSwgaW5jbHVkaW5nIHRoZSBmaXJzdCBwb2ludCBvdXRzaWRlIHRoZVxuXHRcdFx0XHQvLyB2aXNpYmxlIHJhbmdlLCBjb25zaWRlciB5IGV4dHJlbWVzXG5cdFx0XHRcdHZhbGlkVmFsdWUgPSB5ICE9PSBudWxsICYmIHkgIT09IFVOREVGSU5FRCAmJiAoIXlBeGlzLmlzTG9nIHx8ICh5Lmxlbmd0aCB8fCB5ID4gMCkpO1xuXHRcdFx0XHR3aXRoaW5SYW5nZSA9IHRoaXMuZ2V0RXh0cmVtZXNGcm9tQWxsIHx8IHRoaXMuY3JvcHBlZCB8fCAoKHhEYXRhW2kgKyAxXSB8fCB4KSA+PSB4TWluICYmXG5cdFx0XHRcdFx0KHhEYXRhW2kgLSAxXSB8fCB4KSA8PSB4TWF4KTtcblxuXHRcdFx0XHRpZiAodmFsaWRWYWx1ZSAmJiB3aXRoaW5SYW5nZSkge1xuXG5cdFx0XHRcdFx0aiA9IHkubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChqKSB7IC8vIGFycmF5LCBsaWtlIG9obGMgb3IgcmFuZ2UgZGF0YVxuXHRcdFx0XHRcdFx0d2hpbGUgKGotLSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoeVtqXSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGFjdGl2ZVlEYXRhW2FjdGl2ZUNvdW50ZXIrK10gPSB5W2pdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFjdGl2ZVlEYXRhW2FjdGl2ZUNvdW50ZXIrK10gPSB5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5kYXRhTWluID0gcGljayhkYXRhTWluLCBhcnJheU1pbihhY3RpdmVZRGF0YSkpO1xuXHRcdFx0dGhpcy5kYXRhTWF4ID0gcGljayhkYXRhTWF4LCBhcnJheU1heChhY3RpdmVZRGF0YSkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUcmFuc2xhdGUgZGF0YSBwb2ludHMgZnJvbSByYXcgZGF0YSB2YWx1ZXMgdG8gY2hhcnQgc3BlY2lmaWMgcG9zaXRpb25pbmcgZGF0YVxuXHRcdCAqIG5lZWRlZCBsYXRlciBpbiBkcmF3UG9pbnRzLCBkcmF3R3JhcGggYW5kIGRyYXdUcmFja2VyLlxuXHRcdCAqL1xuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLnByb2Nlc3NlZFhEYXRhKSB7IC8vIGhpZGRlbiBzZXJpZXNcblx0XHRcdFx0dGhpcy5wcm9jZXNzRGF0YSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0c3RhY2tpbmcgPSBvcHRpb25zLnN0YWNraW5nLFxuXHRcdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdFx0Y2F0ZWdvcmllcyA9IHhBeGlzLmNhdGVnb3JpZXMsXG5cdFx0XHRcdHlBeGlzID0gc2VyaWVzLnlBeGlzLFxuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0XHRkYXRhTGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdFx0aGFzTW9kaWZ5VmFsdWUgPSAhIXNlcmllcy5tb2RpZnlWYWx1ZSxcblx0XHRcdFx0aSxcblx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPSBvcHRpb25zLnBvaW50UGxhY2VtZW50LFxuXHRcdFx0XHRkeW5hbWljYWxseVBsYWNlZCA9IHBvaW50UGxhY2VtZW50ID09PSAnYmV0d2VlbicgfHwgaXNOdW1iZXIocG9pbnRQbGFjZW1lbnQpLFxuXHRcdFx0XHR0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCxcblx0XHRcdFx0cGxvdFgsXG5cdFx0XHRcdHBsb3RZLFxuXHRcdFx0XHRsYXN0UGxvdFgsXG5cdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlUHggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cdFx0XHQvLyBUcmFuc2xhdGUgZWFjaCBwb2ludFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbaV0sXG5cdFx0XHRcdFx0eFZhbHVlID0gcG9pbnQueCxcblx0XHRcdFx0XHR5VmFsdWUgPSBwb2ludC55LFxuXHRcdFx0XHRcdHlCb3R0b20gPSBwb2ludC5sb3csXG5cdFx0XHRcdFx0c3RhY2sgPSBzdGFja2luZyAmJiB5QXhpcy5zdGFja3NbKHNlcmllcy5uZWdTdGFja3MgJiYgeVZhbHVlIDwgdGhyZXNob2xkID8gJy0nIDogJycpICsgc2VyaWVzLnN0YWNrS2V5XSxcblx0XHRcdFx0XHRwb2ludFN0YWNrLFxuXHRcdFx0XHRcdHN0YWNrVmFsdWVzO1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgZGlzYWxsb3dlZCB5IHZhbHVlcyBmb3IgbG9nIGF4ZXMgKCMzNDM0KVxuXHRcdFx0XHRpZiAoeUF4aXMuaXNMb2cgJiYgeVZhbHVlICE9PSBudWxsICYmIHlWYWx1ZSA8PSAwKSB7XG5cdFx0XHRcdFx0cG9pbnQueSA9IHlWYWx1ZSA9IG51bGw7XG5cdFx0XHRcdFx0ZXJyb3IoMTApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IHRoZSBwbG90WCB0cmFuc2xhdGlvblxuXHRcdFx0XHRwb2ludC5wbG90WCA9IHBsb3RYID0geEF4aXMudHJhbnNsYXRlKHhWYWx1ZSwgMCwgMCwgMCwgMSwgcG9pbnRQbGFjZW1lbnQsIHRoaXMudHlwZSA9PT0gJ2ZsYWdzJyk7IC8vIE1hdGgucm91bmQgZml4ZXMgIzU5MVxuXG5cblx0XHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBib3R0b20geSB2YWx1ZSBmb3Igc3RhY2tlZCBzZXJpZXNcblx0XHRcdFx0aWYgKHN0YWNraW5nICYmIHNlcmllcy52aXNpYmxlICYmIHN0YWNrICYmIHN0YWNrW3hWYWx1ZV0pIHtcblxuXHRcdFx0XHRcdHBvaW50U3RhY2sgPSBzdGFja1t4VmFsdWVdO1xuXHRcdFx0XHRcdHN0YWNrVmFsdWVzID0gcG9pbnRTdGFjay5wb2ludHNbc2VyaWVzLmluZGV4ICsgJywnICsgaV07XG5cdFx0XHRcdFx0eUJvdHRvbSA9IHN0YWNrVmFsdWVzWzBdO1xuXHRcdFx0XHRcdHlWYWx1ZSA9IHN0YWNrVmFsdWVzWzFdO1xuXG5cdFx0XHRcdFx0aWYgKHlCb3R0b20gPT09IDApIHtcblx0XHRcdFx0XHRcdHlCb3R0b20gPSBwaWNrKHRocmVzaG9sZCwgeUF4aXMubWluKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHlBeGlzLmlzTG9nICYmIHlCb3R0b20gPD0gMCkgeyAvLyAjMTIwMCwgIzEyMzJcblx0XHRcdFx0XHRcdHlCb3R0b20gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBvaW50LnRvdGFsID0gcG9pbnQuc3RhY2tUb3RhbCA9IHBvaW50U3RhY2sudG90YWw7XG5cdFx0XHRcdFx0cG9pbnQucGVyY2VudGFnZSA9IHBvaW50U3RhY2sudG90YWwgJiYgKHBvaW50LnkgLyBwb2ludFN0YWNrLnRvdGFsICogMTAwKTtcblx0XHRcdFx0XHRwb2ludC5zdGFja1kgPSB5VmFsdWU7XG5cblx0XHRcdFx0XHQvLyBQbGFjZSB0aGUgc3RhY2sgbGFiZWxcblx0XHRcdFx0XHRwb2ludFN0YWNrLnNldE9mZnNldChzZXJpZXMucG9pbnRYT2Zmc2V0IHx8IDAsIHNlcmllcy5iYXJXIHx8IDApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdHJhbnNsYXRlZCB5Qm90dG9tIG9yIHJlbW92ZSBpdFxuXHRcdFx0XHRwb2ludC55Qm90dG9tID0gZGVmaW5lZCh5Qm90dG9tKSA/XG5cdFx0XHRcdFx0eUF4aXMudHJhbnNsYXRlKHlCb3R0b20sIDAsIDEsIDAsIDEpIDpcblx0XHRcdFx0XHRudWxsO1xuXG5cdFx0XHRcdC8vIGdlbmVyYWwgaG9vaywgdXNlZCBmb3IgSGlnaHN0b2NrIGNvbXBhcmUgbW9kZVxuXHRcdFx0XHRpZiAoaGFzTW9kaWZ5VmFsdWUpIHtcblx0XHRcdFx0XHR5VmFsdWUgPSBzZXJpZXMubW9kaWZ5VmFsdWUoeVZhbHVlLCBwb2ludCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIHRoZSBwbG90WSB2YWx1ZSwgcmVzZXQgaXQgZm9yIHJlZHJhd3Ncblx0XHRcdFx0cG9pbnQucGxvdFkgPSBwbG90WSA9ICh0eXBlb2YgeVZhbHVlID09PSAnbnVtYmVyJyAmJiB5VmFsdWUgIT09IEluZmluaXR5KSA/XG5cdFx0XHRcdFx0bWF0aE1pbihtYXRoTWF4KC0xZTUsIHlBeGlzLnRyYW5zbGF0ZSh5VmFsdWUsIDAsIDEsIDAsIDEpKSwgMWU1KSA6IC8vICMzMjAxXG5cdFx0XHRcdFx0VU5ERUZJTkVEO1xuXHRcdFx0XHRwb2ludC5pc0luc2lkZSA9IHBsb3RZICE9PSBVTkRFRklORUQgJiYgcGxvdFkgPj0gMCAmJiBwbG90WSA8PSB5QXhpcy5sZW4gJiYgLy8gIzM1MTlcblx0XHRcdFx0XHRwbG90WCA+PSAwICYmIHBsb3RYIDw9IHhBeGlzLmxlbjtcblxuXG5cdFx0XHRcdC8vIFNldCBjbGllbnQgcmVsYXRlZCBwb3NpdGlvbnMgZm9yIG1vdXNlIHRyYWNraW5nXG5cdFx0XHRcdHBvaW50LmNsaWVudFggPSBkeW5hbWljYWxseVBsYWNlZCA/IHhBeGlzLnRyYW5zbGF0ZSh4VmFsdWUsIDAsIDAsIDAsIDEpIDogcGxvdFg7IC8vICMxNTE0XG5cblx0XHRcdFx0cG9pbnQubmVnYXRpdmUgPSBwb2ludC55IDwgKHRocmVzaG9sZCB8fCAwKTtcblxuXHRcdFx0XHQvLyBzb21lIEFQSSBkYXRhXG5cdFx0XHRcdHBvaW50LmNhdGVnb3J5ID0gY2F0ZWdvcmllcyAmJiBjYXRlZ29yaWVzW3BvaW50LnhdICE9PSBVTkRFRklORUQgP1xuXHRcdFx0XHRcdGNhdGVnb3JpZXNbcG9pbnQueF0gOiBwb2ludC54O1xuXG5cdFx0XHRcdC8vIERldGVybWluZSBhdXRvIGVuYWJsaW5nIG9mIG1hcmtlcnMgKCMzNjM1KVxuXHRcdFx0XHRpZiAoaSkge1xuXHRcdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlUHggPSBtYXRoTWluKGNsb3Nlc3RQb2ludFJhbmdlUHgsIG1hdGhBYnMocGxvdFggLSBsYXN0UGxvdFgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0UGxvdFggPSBwbG90WDtcblxuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2VQeCA9IGNsb3Nlc3RQb2ludFJhbmdlUHg7XG5cblx0XHRcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIGNyb3BwZWQgZGF0YSwgYnVpbGQgdGhlIHNlZ21lbnRzXG5cdFx0XHRzZXJpZXMuZ2V0U2VnbWVudHMoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBjbGlwcGluZyBmb3IgdGhlIHNlcmllcy4gRm9yIGFuaW1hdGVkIHNlcmllcyBpdCBpcyBjYWxsZWQgdHdpY2UsIGZpcnN0IHRvIGluaXRpYXRlXG5cdFx0ICogYW5pbWF0aW5nIHRoZSBjbGlwIHRoZW4gdGhlIHNlY29uZCB0aW1lIHdpdGhvdXQgdGhlIGFuaW1hdGlvbiB0byBzZXQgdGhlIGZpbmFsIGNsaXAuXG5cdFx0ICovXG5cdFx0c2V0Q2xpcDogZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0c2VyaWVzQ2xpcEJveCA9IHRoaXMuY2xpcEJveCxcblx0XHRcdFx0Y2xpcEJveCA9IHNlcmllc0NsaXBCb3ggfHwgY2hhcnQuY2xpcEJveCxcblx0XHRcdFx0c2hhcmVkQ2xpcEtleSA9IHRoaXMuc2hhcmVkQ2xpcEtleSB8fCBbJ19zaGFyZWRDbGlwJywgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5kdXJhdGlvbiwgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5lYXNpbmcsIGNsaXBCb3guaGVpZ2h0XS5qb2luKCcsJyksXG5cdFx0XHRcdGNsaXBSZWN0ID0gY2hhcnRbc2hhcmVkQ2xpcEtleV0sXG5cdFx0XHRcdG1hcmtlckNsaXBSZWN0ID0gY2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ107XG5cblx0XHRcdC8vIElmIGEgY2xpcHBpbmcgcmVjdGFuZ2xlIHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBpcyBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgY2hhcnQsIHVzZSB0aGF0LlxuXHRcdFx0aWYgKCFjbGlwUmVjdCkge1xuXG5cdFx0XHRcdC8vIFdoZW4gYW5pbWF0aW9uIGlzIHNldCwgcHJlcGFyZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnNcblx0XHRcdFx0aWYgKGFuaW1hdGlvbikgeyBcblx0XHRcdFx0XHRjbGlwQm94LndpZHRoID0gMDtcblxuXHRcdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddID0gbWFya2VyQ2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdChcblx0XHRcdFx0XHRcdC05OSwgLy8gaW5jbHVkZSB0aGUgd2lkdGggb2YgdGhlIGZpcnN0IG1hcmtlclxuXHRcdFx0XHRcdFx0aW52ZXJ0ZWQgPyAtY2hhcnQucGxvdExlZnQgOiAtY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0XHRcdDk5LFxuXHRcdFx0XHRcdFx0aW52ZXJ0ZWQgPyBjaGFydC5jaGFydFdpZHRoIDogY2hhcnQuY2hhcnRIZWlnaHRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXldID0gY2xpcFJlY3QgPSByZW5kZXJlci5jbGlwUmVjdChjbGlwQm94KTtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdGNsaXBSZWN0LmNvdW50ICs9IDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpcCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5ncm91cC5jbGlwKGFuaW1hdGlvbiB8fCBzZXJpZXNDbGlwQm94ID8gY2xpcFJlY3QgOiBjaGFydC5jbGlwUmVjdCk7XG5cdFx0XHRcdHRoaXMubWFya2VyR3JvdXAuY2xpcChtYXJrZXJDbGlwUmVjdCk7XG5cdFx0XHRcdHRoaXMuc2hhcmVkQ2xpcEtleSA9IHNoYXJlZENsaXBLZXk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSB0aGUgc2hhcmVkIGNsaXBwaW5nIHJlY3RhbmNnbGUgd2hlbiBhbGwgc2VyaWVzIGFyZSBzaG93blxuXHRcdFx0aWYgKCFhbmltYXRpb24pIHtcblx0XHRcdFx0Y2xpcFJlY3QuY291bnQgLT0gMTtcblx0XHRcdFx0aWYgKGNsaXBSZWN0LmNvdW50IDw9IDAgJiYgc2hhcmVkQ2xpcEtleSAmJiBjaGFydFtzaGFyZWRDbGlwS2V5XSkge1xuXHRcdFx0XHRcdGlmICghc2VyaWVzQ2xpcEJveCkge1xuXHRcdFx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleV0gPSBjaGFydFtzaGFyZWRDbGlwS2V5XS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXSkge1xuXHRcdFx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10gPSBjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFuaW1hdGUgaW4gdGhlIHNlcmllc1xuXHRcdCAqL1xuXHRcdGFuaW1hdGU6IGZ1bmN0aW9uIChpbml0KSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdGNsaXBSZWN0LFxuXHRcdFx0XHRhbmltYXRpb24gPSBzZXJpZXMub3B0aW9ucy5hbmltYXRpb24sXG5cdFx0XHRcdHNoYXJlZENsaXBLZXk7XG5cblx0XHRcdC8vIEFuaW1hdGlvbiBvcHRpb24gaXMgc2V0IHRvIHRydWVcblx0XHRcdGlmIChhbmltYXRpb24gJiYgIWlzT2JqZWN0KGFuaW1hdGlvbikpIHtcblx0XHRcdFx0YW5pbWF0aW9uID0gZGVmYXVsdFBsb3RPcHRpb25zW3Nlcmllcy50eXBlXS5hbmltYXRpb247XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluaXRpYWxpemUgdGhlIGFuaW1hdGlvbi4gU2V0IHVwIHRoZSBjbGlwcGluZyByZWN0YW5nbGUuXG5cdFx0XHRpZiAoaW5pdCkge1xuXG5cdFx0XHRcdHNlcmllcy5zZXRDbGlwKGFuaW1hdGlvbik7XG5cblx0XHRcdC8vIFJ1biB0aGUgYW5pbWF0aW9uXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzaGFyZWRDbGlwS2V5ID0gdGhpcy5zaGFyZWRDbGlwS2V5O1xuXHRcdFx0XHRjbGlwUmVjdCA9IGNoYXJ0W3NoYXJlZENsaXBLZXldO1xuXHRcdFx0XHRpZiAoY2xpcFJlY3QpIHtcblx0XHRcdFx0XHRjbGlwUmVjdC5hbmltYXRlKHtcblx0XHRcdFx0XHRcdHdpZHRoOiBjaGFydC5wbG90U2l6ZVhcblx0XHRcdFx0XHR9LCBhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXSkge1xuXHRcdFx0XHRcdGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddLmFuaW1hdGUoe1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LnBsb3RTaXplWCArIDk5XG5cdFx0XHRcdFx0fSwgYW5pbWF0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERlbGV0ZSB0aGlzIGZ1bmN0aW9uIHRvIGFsbG93IGl0IG9ubHkgb25jZVxuXHRcdFx0XHRzZXJpZXMuYW5pbWF0ZSA9IG51bGw7XG5cdCBcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBydW5zIGFmdGVyIGFuaW1hdGlvbiB0byBsYW5kIG9uIHRoZSBmaW5hbCBwbG90IGNsaXBwaW5nXG5cdFx0ICovXG5cdFx0YWZ0ZXJBbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnNldENsaXAoKTtcblx0XHRcdGZpcmVFdmVudCh0aGlzLCAnYWZ0ZXJBbmltYXRlJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgdGhlIG1hcmtlcnNcblx0XHQgKi9cblx0XHRkcmF3UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0cG9pbnRBdHRyLFxuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0cGxvdFgsXG5cdFx0XHRcdHBsb3RZLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0cmFkaXVzLFxuXHRcdFx0XHRzeW1ib2wsXG5cdFx0XHRcdGlzSW1hZ2UsXG5cdFx0XHRcdGdyYXBoaWMsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0c2VyaWVzTWFya2VyT3B0aW9ucyA9IG9wdGlvbnMubWFya2VyLFxuXHRcdFx0XHRzZXJpZXNQb2ludEF0dHIgPSBzZXJpZXMucG9pbnRBdHRyWycnXSxcblx0XHRcdFx0cG9pbnRNYXJrZXJPcHRpb25zLFxuXHRcdFx0XHRoYXNQb2ludE1hcmtlcixcblx0XHRcdFx0ZW5hYmxlZCxcblx0XHRcdFx0aXNJbnNpZGUsXG5cdFx0XHRcdG1hcmtlckdyb3VwID0gc2VyaWVzLm1hcmtlckdyb3VwLFxuXHRcdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdFx0Z2xvYmFsbHlFbmFibGVkID0gcGljayhcblx0XHRcdFx0XHRzZXJpZXNNYXJrZXJPcHRpb25zLmVuYWJsZWQsIFxuXHRcdFx0XHRcdHhBeGlzLmlzUmFkaWFsLFxuXHRcdFx0XHRcdHNlcmllcy5jbG9zZXN0UG9pbnRSYW5nZVB4ID4gMiAqIHNlcmllc01hcmtlck9wdGlvbnMucmFkaXVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdGlmIChzZXJpZXNNYXJrZXJPcHRpb25zLmVuYWJsZWQgIT09IGZhbHNlIHx8IHNlcmllcy5faGFzUG9pbnRNYXJrZXJzKSB7XG5cblx0XHRcdFx0aSA9IHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdFx0XHRwbG90WCA9IG1hdGhGbG9vcihwb2ludC5wbG90WCk7IC8vICMxODQzXG5cdFx0XHRcdFx0cGxvdFkgPSBwb2ludC5wbG90WTtcblx0XHRcdFx0XHRncmFwaGljID0gcG9pbnQuZ3JhcGhpYztcblx0XHRcdFx0XHRwb2ludE1hcmtlck9wdGlvbnMgPSBwb2ludC5tYXJrZXIgfHwge307XG5cdFx0XHRcdFx0aGFzUG9pbnRNYXJrZXIgPSAhIXBvaW50Lm1hcmtlcjtcblx0XHRcdFx0XHRlbmFibGVkID0gKGdsb2JhbGx5RW5hYmxlZCAmJiBwb2ludE1hcmtlck9wdGlvbnMuZW5hYmxlZCA9PT0gVU5ERUZJTkVEKSB8fCBwb2ludE1hcmtlck9wdGlvbnMuZW5hYmxlZDtcblx0XHRcdFx0XHRpc0luc2lkZSA9IHBvaW50LmlzSW5zaWRlO1xuXG5cdFx0XHRcdFx0Ly8gb25seSBkcmF3IHRoZSBwb2ludCBpZiB5IGlzIGRlZmluZWRcblx0XHRcdFx0XHRpZiAoZW5hYmxlZCAmJiBwbG90WSAhPT0gVU5ERUZJTkVEICYmICFpc05hTihwbG90WSkgJiYgcG9pbnQueSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzaG9ydGN1dHNcblx0XHRcdFx0XHRcdHBvaW50QXR0ciA9IHBvaW50LnBvaW50QXR0cltwb2ludC5zZWxlY3RlZCA/IFNFTEVDVF9TVEFURSA6IE5PUk1BTF9TVEFURV0gfHwgc2VyaWVzUG9pbnRBdHRyO1xuXHRcdFx0XHRcdFx0cmFkaXVzID0gcG9pbnRBdHRyLnI7XG5cdFx0XHRcdFx0XHRzeW1ib2wgPSBwaWNrKHBvaW50TWFya2VyT3B0aW9ucy5zeW1ib2wsIHNlcmllcy5zeW1ib2wpO1xuXHRcdFx0XHRcdFx0aXNJbWFnZSA9IHN5bWJvbC5pbmRleE9mKCd1cmwnKSA9PT0gMDtcblxuXHRcdFx0XHRcdFx0aWYgKGdyYXBoaWMpIHsgLy8gdXBkYXRlXG5cdFx0XHRcdFx0XHRcdGdyYXBoaWNbaXNJbnNpZGUgPyAnc2hvdycgOiAnaGlkZSddKHRydWUpIC8vIFNpbmNlIHRoZSBtYXJrZXIgZ3JvdXAgaXNuJ3QgY2xpcHBlZCwgZWFjaCBpbmRpdmlkdWFsIG1hcmtlciBtdXN0IGJlIHRvZ2dsZWRcblx0XHRcdFx0XHRcdFx0XHQuYW5pbWF0ZShleHRlbmQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0eDogcGxvdFggLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR5OiBwbG90WSAtIHJhZGl1c1xuXHRcdFx0XHRcdFx0XHRcdH0sIGdyYXBoaWMuc3ltYm9sTmFtZSA/IHsgLy8gZG9uJ3QgYXBwbHkgdG8gaW1hZ2Ugc3ltYm9scyAjNTA3XG5cdFx0XHRcdFx0XHRcdFx0XHR3aWR0aDogMiAqIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRcdGhlaWdodDogMiAqIHJhZGl1c1xuXHRcdFx0XHRcdFx0XHRcdH0gOiB7fSkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpc0luc2lkZSAmJiAocmFkaXVzID4gMCB8fCBpc0ltYWdlKSkge1xuXHRcdFx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYyA9IGNoYXJ0LnJlbmRlcmVyLnN5bWJvbChcblx0XHRcdFx0XHRcdFx0XHRzeW1ib2wsXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFggLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFkgLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0MiAqIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHQyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGhhc1BvaW50TWFya2VyID8gcG9pbnRNYXJrZXJPcHRpb25zIDogc2VyaWVzTWFya2VyT3B0aW9uc1xuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdC5hdHRyKHBvaW50QXR0cilcblx0XHRcdFx0XHRcdFx0LmFkZChtYXJrZXJHcm91cCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGdyYXBoaWMpIHtcblx0XHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljLmRlc3Ryb3koKTsgLy8gIzEyNjlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IHN0YXRlIHByb3BlcnRpZXMgZnJvbSBBUEkgbmFtaW5nIGNvbnZlbnRpb25zIHRvIFNWRyBhdHRyaWJ1dGVzXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBUEkgb3B0aW9ucyBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gYmFzZTEgU1ZHIGF0dHJpYnV0ZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGJhc2UyIFNlY29uZCBsZXZlbCBTVkcgYXR0cmlidXRlIG9iamVjdCB0byBpbmhlcml0IGZyb21cblx0XHQgKi9cblx0XHRjb252ZXJ0QXR0cmliczogZnVuY3Rpb24gKG9wdGlvbnMsIGJhc2UxLCBiYXNlMiwgYmFzZTMpIHtcblx0XHRcdHZhciBjb252ZXJzaW9uID0gdGhpcy5wb2ludEF0dHJUb09wdGlvbnMsXG5cdFx0XHRcdGF0dHIsXG5cdFx0XHRcdG9wdGlvbixcblx0XHRcdFx0b2JqID0ge307XG5cblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0YmFzZTEgPSBiYXNlMSB8fCB7fTtcblx0XHRcdGJhc2UyID0gYmFzZTIgfHwge307XG5cdFx0XHRiYXNlMyA9IGJhc2UzIHx8IHt9O1xuXG5cdFx0XHRmb3IgKGF0dHIgaW4gY29udmVyc2lvbikge1xuXHRcdFx0XHRvcHRpb24gPSBjb252ZXJzaW9uW2F0dHJdO1xuXHRcdFx0XHRvYmpbYXR0cl0gPSBwaWNrKG9wdGlvbnNbb3B0aW9uXSwgYmFzZTFbYXR0cl0sIGJhc2UyW2F0dHJdLCBiYXNlM1thdHRyXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHN0YXRlIGF0dHJpYnV0ZXMuIEVhY2ggc2VyaWVzIHR5cGUgaGFzIGl0cyBvd24gc2V0IG9mIGF0dHJpYnV0ZXNcblx0XHQgKiB0aGF0IGFyZSBhbGxvd2VkIHRvIGNoYW5nZSBvbiBhIHBvaW50J3Mgc3RhdGUgY2hhbmdlLiBTZXJpZXMgd2lkZSBhdHRyaWJ1dGVzIGFyZSBzdG9yZWQgZm9yXG5cdFx0ICogYWxsIHNlcmllcywgYW5kIGFkZGl0aW9uYWxseSBwb2ludCBzcGVjaWZpYyBhdHRyaWJ1dGVzIGFyZSBzdG9yZWQgZm9yIGFsbFxuXHRcdCAqIHBvaW50cyB3aXRoIGluZGl2aWR1YWwgbWFya2VyIG9wdGlvbnMuIElmIHN1Y2ggb3B0aW9ucyBhcmUgbm90IGRlZmluZWQgZm9yIHRoZSBwb2ludCxcblx0XHQgKiBhIHJlZmVyZW5jZSB0byB0aGUgc2VyaWVzIHdpZGUgYXR0cmlidXRlcyBpcyBzdG9yZWQgaW4gcG9pbnQucG9pbnRBdHRyLlxuXHRcdCAqL1xuXHRcdGdldEF0dHJpYnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdG5vcm1hbE9wdGlvbnMgPSBkZWZhdWx0UGxvdE9wdGlvbnNbc2VyaWVzLnR5cGVdLm1hcmtlciA/IHNlcmllc09wdGlvbnMubWFya2VyIDogc2VyaWVzT3B0aW9ucyxcblx0XHRcdFx0c3RhdGVPcHRpb25zID0gbm9ybWFsT3B0aW9ucy5zdGF0ZXMsXG5cdFx0XHRcdHN0YXRlT3B0aW9uc0hvdmVyID0gc3RhdGVPcHRpb25zW0hPVkVSX1NUQVRFXSxcblx0XHRcdFx0cG9pbnRTdGF0ZU9wdGlvbnNIb3Zlcixcblx0XHRcdFx0c2VyaWVzQ29sb3IgPSBzZXJpZXMuY29sb3IsXG5cdFx0XHRcdHNlcmllc05lZ2F0aXZlQ29sb3IgPSBzZXJpZXMub3B0aW9ucy5uZWdhdGl2ZUNvbG9yLFxuXHRcdFx0XHRub3JtYWxEZWZhdWx0cyA9IHtcblx0XHRcdFx0XHRzdHJva2U6IHNlcmllc0NvbG9yLFxuXHRcdFx0XHRcdGZpbGw6IHNlcmllc0NvbG9yXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMgfHwgW10sIC8vICM5Mjdcblx0XHRcdFx0aSxcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdHNlcmllc1BvaW50QXR0ciA9IFtdLFxuXHRcdFx0XHRwb2ludEF0dHIsXG5cdFx0XHRcdHBvaW50QXR0clRvT3B0aW9ucyA9IHNlcmllcy5wb2ludEF0dHJUb09wdGlvbnMsXG5cdFx0XHRcdGhhc1BvaW50U3BlY2lmaWNPcHRpb25zID0gc2VyaWVzLmhhc1BvaW50U3BlY2lmaWNPcHRpb25zLFxuXHRcdFx0XHRkZWZhdWx0TGluZUNvbG9yID0gbm9ybWFsT3B0aW9ucy5saW5lQ29sb3IsXG5cdFx0XHRcdGRlZmF1bHRGaWxsQ29sb3IgPSBub3JtYWxPcHRpb25zLmZpbGxDb2xvcixcblx0XHRcdFx0dHVyYm9UaHJlc2hvbGQgPSBzZXJpZXNPcHRpb25zLnR1cmJvVGhyZXNob2xkLFxuXHRcdFx0XHR6b25lcyA9IHNlcmllcy56b25lcyxcblx0XHRcdFx0em9uZUF4aXMgPSBzZXJpZXMuem9uZUF4aXMgfHwgJ3knLFxuXHRcdFx0XHRhdHRyLFxuXHRcdFx0XHRrZXk7XG5cblx0XHRcdC8vIHNlcmllcyB0eXBlIHNwZWNpZmljIG1vZGlmaWNhdGlvbnNcblx0XHRcdGlmIChzZXJpZXNPcHRpb25zLm1hcmtlcikgeyAvLyBsaW5lLCBzcGxpbmUsIGFyZWEsIGFyZWFzcGxpbmUsIHNjYXR0ZXJcblxuXHRcdFx0XHQvLyBpZiBubyBob3ZlciByYWRpdXMgaXMgZ2l2ZW4sIGRlZmF1bHQgdG8gbm9ybWFsIHJhZGl1cyArIDJcblx0XHRcdFx0c3RhdGVPcHRpb25zSG92ZXIucmFkaXVzID0gc3RhdGVPcHRpb25zSG92ZXIucmFkaXVzIHx8IG5vcm1hbE9wdGlvbnMucmFkaXVzICsgc3RhdGVPcHRpb25zSG92ZXIucmFkaXVzUGx1cztcblx0XHRcdFx0c3RhdGVPcHRpb25zSG92ZXIubGluZVdpZHRoID0gc3RhdGVPcHRpb25zSG92ZXIubGluZVdpZHRoIHx8IG5vcm1hbE9wdGlvbnMubGluZVdpZHRoICsgc3RhdGVPcHRpb25zSG92ZXIubGluZVdpZHRoUGx1cztcblxuXHRcdFx0fSBlbHNlIHsgLy8gY29sdW1uLCBiYXIsIHBpZVxuXG5cdFx0XHRcdC8vIGlmIG5vIGhvdmVyIGNvbG9yIGlzIGdpdmVuLCBicmlnaHRlbiB0aGUgbm9ybWFsIGNvbG9yXG5cdFx0XHRcdHN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yID0gc3RhdGVPcHRpb25zSG92ZXIuY29sb3IgfHxcblx0XHRcdFx0XHRDb2xvcihzdGF0ZU9wdGlvbnNIb3Zlci5jb2xvciB8fCBzZXJpZXNDb2xvcilcblx0XHRcdFx0XHRcdC5icmlnaHRlbihzdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzKS5nZXQoKTtcblxuXHRcdFx0XHQvLyBpZiBubyBob3ZlciBuZWdhdGl2ZUNvbG9yIGlzIGdpdmVuLCBicmlnaHRlbiB0aGUgbm9ybWFsIG5lZ2F0aXZlQ29sb3Jcblx0XHRcdFx0c3RhdGVPcHRpb25zSG92ZXIubmVnYXRpdmVDb2xvciA9IHN0YXRlT3B0aW9uc0hvdmVyLm5lZ2F0aXZlQ29sb3IgfHxcblx0XHRcdFx0XHRDb2xvcihzdGF0ZU9wdGlvbnNIb3Zlci5uZWdhdGl2ZUNvbG9yIHx8IHNlcmllc05lZ2F0aXZlQ29sb3IpXG5cdFx0XHRcdFx0XHQuYnJpZ2h0ZW4oc3RhdGVPcHRpb25zSG92ZXIuYnJpZ2h0bmVzcykuZ2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYWwgcG9pbnQgYXR0cmlidXRlcyBmb3IgdGhlIHNlcmllcyBub3JtYWwgc3RhdGVcblx0XHRcdHNlcmllc1BvaW50QXR0cltOT1JNQUxfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKG5vcm1hbE9wdGlvbnMsIG5vcm1hbERlZmF1bHRzKTtcblxuXHRcdFx0Ly8gSE9WRVJfU1RBVEUgYW5kIFNFTEVDVF9TVEFURSBzdGF0ZXMgaW5oZXJpdCBmcm9tIG5vcm1hbCBzdGF0ZSBleGNlcHQgdGhlIGRlZmF1bHQgcmFkaXVzXG5cdFx0XHRlYWNoKFtIT1ZFUl9TVEFURSwgU0VMRUNUX1NUQVRFXSwgZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0XHRcdHNlcmllc1BvaW50QXR0cltzdGF0ZV0gPVxuXHRcdFx0XHRcdFx0c2VyaWVzLmNvbnZlcnRBdHRyaWJzKHN0YXRlT3B0aW9uc1tzdGF0ZV0sIHNlcmllc1BvaW50QXR0cltOT1JNQUxfU1RBVEVdKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBzZXQgaXRcblx0XHRcdHNlcmllcy5wb2ludEF0dHIgPSBzZXJpZXNQb2ludEF0dHI7XG5cblxuXHRcdFx0Ly8gR2VuZXJhdGUgdGhlIHBvaW50LXNwZWNpZmljIGF0dHJpYnV0ZSBjb2xsZWN0aW9ucyBpZiBzcGVjaWZpYyBwb2ludFxuXHRcdFx0Ly8gb3B0aW9ucyBhcmUgZ2l2ZW4uIElmIG5vdCwgY3JlYXRlIGEgcmVmZXJhbmNlIHRvIHRoZSBzZXJpZXMgd2lkZSBwb2ludFxuXHRcdFx0Ly8gYXR0cmlidXRlc1xuXHRcdFx0aSA9IHBvaW50cy5sZW5ndGg7XG5cdFx0XHRpZiAoIXR1cmJvVGhyZXNob2xkIHx8IGkgPCB0dXJib1RocmVzaG9sZCB8fCBoYXNQb2ludFNwZWNpZmljT3B0aW9ucykge1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdFx0bm9ybWFsT3B0aW9ucyA9IChwb2ludC5vcHRpb25zICYmIHBvaW50Lm9wdGlvbnMubWFya2VyKSB8fCBwb2ludC5vcHRpb25zO1xuXHRcdFx0XHRcdGlmIChub3JtYWxPcHRpb25zICYmIG5vcm1hbE9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdG5vcm1hbE9wdGlvbnMucmFkaXVzID0gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoem9uZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2YXIgaiA9IDAsXG5cdFx0XHRcdFx0XHRcdHRocmVzaG9sZCA9IHpvbmVzW2pdO1xuXHRcdFx0XHRcdFx0d2hpbGUgKHBvaW50W3pvbmVBeGlzXSA+PSB0aHJlc2hvbGQudmFsdWUpIHtcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR0aHJlc2hvbGQgPSB6b25lc1srK2pdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRwb2ludC5jb2xvciA9IHBvaW50LmZpbGxDb2xvciA9IHRocmVzaG9sZC5jb2xvcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRoYXNQb2ludFNwZWNpZmljT3B0aW9ucyA9IHNlcmllc09wdGlvbnMuY29sb3JCeVBvaW50IHx8IHBvaW50LmNvbG9yOyAvLyAjODY4XG5cblx0XHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaGFzIHNwZWNpZmljIHZpc3VhbCBvcHRpb25zXG5cdFx0XHRcdFx0aWYgKHBvaW50Lm9wdGlvbnMpIHtcblx0XHRcdFx0XHRcdGZvciAoa2V5IGluIHBvaW50QXR0clRvT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0XHRpZiAoZGVmaW5lZChub3JtYWxPcHRpb25zW3BvaW50QXR0clRvT3B0aW9uc1trZXldXSkpIHtcblx0XHRcdFx0XHRcdFx0XHRoYXNQb2ludFNwZWNpZmljT3B0aW9ucyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBhIHNwZWNpZmljIG1hcmtlciBjb25maWcgb2JqZWN0IGlzIGRlZmluZWQgZm9yIHRoZSBpbmRpdmlkdWFsIHBvaW50OlxuXHRcdFx0XHRcdC8vIGNyZWF0ZSBpdCdzIG93biBhdHRyaWJ1dGUgY29sbGVjdGlvblxuXHRcdFx0XHRcdGlmIChoYXNQb2ludFNwZWNpZmljT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0bm9ybWFsT3B0aW9ucyA9IG5vcm1hbE9wdGlvbnMgfHwge307XG5cdFx0XHRcdFx0XHRwb2ludEF0dHIgPSBbXTtcblx0XHRcdFx0XHRcdHN0YXRlT3B0aW9ucyA9IG5vcm1hbE9wdGlvbnMuc3RhdGVzIHx8IHt9OyAvLyByZWFzc2lnbiBmb3IgaW5kaXZpZHVhbCBwb2ludFxuXHRcdFx0XHRcdFx0cG9pbnRTdGF0ZU9wdGlvbnNIb3ZlciA9IHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0gPSBzdGF0ZU9wdGlvbnNbSE9WRVJfU1RBVEVdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgY29sb3JzIGZvciBjb2x1bW4gYW5kIHBpZXNcblx0XHRcdFx0XHRcdGlmICghc2VyaWVzT3B0aW9ucy5tYXJrZXIpIHsgLy8gY29sdW1uLCBiYXIsIHBvaW50XG5cdFx0XHRcdFx0XHRcdC8vIElmIG5vIGhvdmVyIGNvbG9yIGlzIGdpdmVuLCBicmlnaHRlbiB0aGUgbm9ybWFsIGNvbG9yLiAjMTYxOSwgIzI1Nzlcblx0XHRcdFx0XHRcdFx0cG9pbnRTdGF0ZU9wdGlvbnNIb3Zlci5jb2xvciA9IHBvaW50U3RhdGVPcHRpb25zSG92ZXIuY29sb3IgfHwgKCFwb2ludC5vcHRpb25zLmNvbG9yICYmIHN0YXRlT3B0aW9uc0hvdmVyWyhwb2ludC5uZWdhdGl2ZSAmJiBzZXJpZXNOZWdhdGl2ZUNvbG9yID8gJ25lZ2F0aXZlQ29sb3InIDogJ2NvbG9yJyldKSB8fFxuXHRcdFx0XHRcdFx0XHRcdENvbG9yKHBvaW50LmNvbG9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmJyaWdodGVuKHBvaW50U3RhdGVPcHRpb25zSG92ZXIuYnJpZ2h0bmVzcyB8fCBzdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmdldCgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBub3JtYWwgcG9pbnQgc3RhdGUgaW5oZXJpdHMgc2VyaWVzIHdpZGUgbm9ybWFsIHN0YXRlXG5cdFx0XHRcdFx0XHRhdHRyID0geyBjb2xvcjogcG9pbnQuY29sb3IgfTsgLy8gIzg2OFxuXHRcdFx0XHRcdFx0aWYgKCFkZWZhdWx0RmlsbENvbG9yKSB7IC8vIEluZGl2aWR1YWwgcG9pbnQgY29sb3Igb3IgbmVnYXRpdmUgY29sb3IgbWFya2VycyAoIzIyMTkpXG5cdFx0XHRcdFx0XHRcdGF0dHIuZmlsbENvbG9yID0gcG9pbnQuY29sb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIWRlZmF1bHRMaW5lQ29sb3IpIHtcblx0XHRcdFx0XHRcdFx0YXR0ci5saW5lQ29sb3IgPSBwb2ludC5jb2xvcjsgLy8gQnViYmxlcyB0YWtlIHBvaW50IGNvbG9yLCBsaW5lIG1hcmtlcnMgdXNlIHdoaXRlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwb2ludEF0dHJbTk9STUFMX1NUQVRFXSA9IHNlcmllcy5jb252ZXJ0QXR0cmlicyhleHRlbmQoYXR0ciwgbm9ybWFsT3B0aW9ucyksIHNlcmllc1BvaW50QXR0cltOT1JNQUxfU1RBVEVdKTtcblxuXHRcdFx0XHRcdFx0Ly8gaW5oZXJpdCBmcm9tIHBvaW50IG5vcm1hbCBhbmQgc2VyaWVzIGhvdmVyXG5cdFx0XHRcdFx0XHRwb2ludEF0dHJbSE9WRVJfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKFxuXHRcdFx0XHRcdFx0XHRzdGF0ZU9wdGlvbnNbSE9WRVJfU1RBVEVdLFxuXHRcdFx0XHRcdFx0XHRzZXJpZXNQb2ludEF0dHJbSE9WRVJfU1RBVEVdLFxuXHRcdFx0XHRcdFx0XHRwb2ludEF0dHJbTk9STUFMX1NUQVRFXVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gaW5oZXJpdCBmcm9tIHBvaW50IG5vcm1hbCBhbmQgc2VyaWVzIGhvdmVyXG5cdFx0XHRcdFx0XHRwb2ludEF0dHJbU0VMRUNUX1NUQVRFXSA9IHNlcmllcy5jb252ZXJ0QXR0cmlicyhcblx0XHRcdFx0XHRcdFx0c3RhdGVPcHRpb25zW1NFTEVDVF9TVEFURV0sXG5cdFx0XHRcdFx0XHRcdHNlcmllc1BvaW50QXR0cltTRUxFQ1RfU1RBVEVdLFxuXHRcdFx0XHRcdFx0XHRwb2ludEF0dHJbTk9STUFMX1NUQVRFXVxuXHRcdFx0XHRcdFx0KTtcblxuXG5cdFx0XHRcdFx0Ly8gbm8gbWFya2VyIGNvbmZpZyBvYmplY3QgaXMgY3JlYXRlZDogY29weSBhIHJlZmVyZW5jZSB0byB0aGUgc2VyaWVzLXdpZGVcblx0XHRcdFx0XHQvLyBhdHRyaWJ1dGUgY29sbGVjdGlvblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb2ludEF0dHIgPSBzZXJpZXNQb2ludEF0dHI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cG9pbnQucG9pbnRBdHRyID0gcG9pbnRBdHRyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENsZWFyIERPTSBvYmplY3RzIGFuZCBmcmVlIHVwIG1lbW9yeVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0aXNzdWUxMzQgPSAvQXBwbGVXZWJLaXRcXC81MzMvLnRlc3QodXNlckFnZW50KSxcblx0XHRcdFx0ZGVzdHJveSxcblx0XHRcdFx0aSxcblx0XHRcdFx0ZGF0YSA9IHNlcmllcy5kYXRhIHx8IFtdLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0cHJvcCxcblx0XHRcdFx0YXhpcztcblxuXHRcdFx0Ly8gYWRkIGV2ZW50IGhvb2tcblx0XHRcdGZpcmVFdmVudChzZXJpZXMsICdkZXN0cm95Jyk7XG5cblx0XHRcdC8vIHJlbW92ZSBhbGwgZXZlbnRzXG5cdFx0XHRyZW1vdmVFdmVudChzZXJpZXMpO1xuXG5cdFx0XHQvLyBlcmFzZSBmcm9tIGF4ZXNcblx0XHRcdGVhY2goc2VyaWVzLmF4aXNUeXBlcyB8fCBbXSwgZnVuY3Rpb24gKEFYSVMpIHtcblx0XHRcdFx0YXhpcyA9IHNlcmllc1tBWElTXTtcblx0XHRcdFx0aWYgKGF4aXMpIHtcblx0XHRcdFx0XHRlcmFzZShheGlzLnNlcmllcywgc2VyaWVzKTtcblx0XHRcdFx0XHRheGlzLmlzRGlydHkgPSBheGlzLmZvcmNlUmVkcmF3ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHJlbW92ZSBsZWdlbmQgaXRlbXNcblx0XHRcdGlmIChzZXJpZXMubGVnZW5kSXRlbSkge1xuXHRcdFx0XHRzZXJpZXMuY2hhcnQubGVnZW5kLmRlc3Ryb3lJdGVtKHNlcmllcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlc3Ryb3kgYWxsIHBvaW50cyB3aXRoIHRoZWlyIGVsZW1lbnRzXG5cdFx0XHRpID0gZGF0YS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHBvaW50ID0gZGF0YVtpXTtcblx0XHRcdFx0aWYgKHBvaW50ICYmIHBvaW50LmRlc3Ryb3kpIHtcblx0XHRcdFx0XHRwb2ludC5kZXN0cm95KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHNlcmllcy5wb2ludHMgPSBudWxsO1xuXG5cdFx0XHQvLyBDbGVhciB0aGUgYW5pbWF0aW9uIHRpbWVvdXQgaWYgd2UgYXJlIGRlc3Ryb3lpbmcgdGhlIHNlcmllcyBkdXJpbmcgaW5pdGlhbCBhbmltYXRpb25cblx0XHRcdGNsZWFyVGltZW91dChzZXJpZXMuYW5pbWF0aW9uVGltZW91dCk7XG5cblx0XHRcdC8vIGRlc3Ryb3kgYWxsIFNWR0VsZW1lbnRzIGFzc29jaWF0ZWQgdG8gdGhlIHNlcmllc1xuXHRcdFx0ZWFjaChbJ2FyZWEnLCAnZ3JhcGgnLCAnZGF0YUxhYmVsc0dyb3VwJywgJ2dyb3VwJywgJ21hcmtlckdyb3VwJywgJ3RyYWNrZXInLFxuXHRcdFx0XHRcdCdncmFwaE5lZycsICdhcmVhTmVnJywgJ3Bvc0NsaXAnLCAnbmVnQ2xpcCddLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0XHRpZiAoc2VyaWVzW3Byb3BdKSB7XG5cblx0XHRcdFx0XHQvLyBpc3N1ZSAxMzQgd29ya2Fyb3VuZFxuXHRcdFx0XHRcdGRlc3Ryb3kgPSBpc3N1ZTEzNCAmJiBwcm9wID09PSAnZ3JvdXAnID9cblx0XHRcdFx0XHRcdCdoaWRlJyA6XG5cdFx0XHRcdFx0XHQnZGVzdHJveSc7XG5cblx0XHRcdFx0XHRzZXJpZXNbcHJvcF1bZGVzdHJveV0oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHJlbW92ZSBmcm9tIGhvdmVyU2VyaWVzXG5cdFx0XHRpZiAoY2hhcnQuaG92ZXJTZXJpZXMgPT09IHNlcmllcykge1xuXHRcdFx0XHRjaGFydC5ob3ZlclNlcmllcyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlcmFzZShjaGFydC5zZXJpZXMsIHNlcmllcyk7XG5cblx0XHRcdC8vIGNsZWFyIGFsbCBtZW1iZXJzXG5cdFx0XHRmb3IgKHByb3AgaW4gc2VyaWVzKSB7XG5cdFx0XHRcdGRlbGV0ZSBzZXJpZXNbcHJvcF07XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0aGUgZ3JhcGggcGF0aCBvZiBhIHNlZ21lbnRcblx0XHQgKi9cblx0XHRnZXRTZWdtZW50UGF0aDogZnVuY3Rpb24gKHNlZ21lbnQpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRzZWdtZW50UGF0aCA9IFtdLFxuXHRcdFx0XHRzdGVwID0gc2VyaWVzLm9wdGlvbnMuc3RlcDtcblxuXHRcdFx0Ly8gYnVpbGQgdGhlIHNlZ21lbnQgbGluZVxuXHRcdFx0ZWFjaChzZWdtZW50LCBmdW5jdGlvbiAocG9pbnQsIGkpIHtcblxuXHRcdFx0XHR2YXIgcGxvdFggPSBwb2ludC5wbG90WCxcblx0XHRcdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdGxhc3RQb2ludDtcblxuXHRcdFx0XHRpZiAoc2VyaWVzLmdldFBvaW50U3BsaW5lKSB7IC8vIGdlbmVyYXRlIHRoZSBzcGxpbmUgYXMgZGVmaW5lZCBpbiB0aGUgU3BsaW5lU2VyaWVzIG9iamVjdFxuXHRcdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2guYXBwbHkoc2VnbWVudFBhdGgsIHNlcmllcy5nZXRQb2ludFNwbGluZShzZWdtZW50LCBwb2ludCwgaSkpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBtb3ZlVG8gb3IgbGluZVRvXG5cdFx0XHRcdFx0c2VnbWVudFBhdGgucHVzaChpID8gTCA6IE0pO1xuXG5cdFx0XHRcdFx0Ly8gc3RlcCBsaW5lP1xuXHRcdFx0XHRcdGlmIChzdGVwICYmIGkpIHtcblx0XHRcdFx0XHRcdGxhc3RQb2ludCA9IHNlZ21lbnRbaSAtIDFdO1xuXHRcdFx0XHRcdFx0aWYgKHN0ZXAgPT09ICdyaWdodCcpIHtcblx0XHRcdFx0XHRcdFx0c2VnbWVudFBhdGgucHVzaChcblx0XHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFlcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChzdGVwID09PSAnY2VudGVyJykge1xuXHRcdFx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdChsYXN0UG9pbnQucGxvdFggKyBwbG90WCkgLyAyLFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RQb2ludC5wbG90WSxcblx0XHRcdFx0XHRcdFx0XHQobGFzdFBvaW50LnBsb3RYICsgcGxvdFgpIC8gMixcblx0XHRcdFx0XHRcdFx0XHRwbG90WVxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdHBsb3RYLFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RQb2ludC5wbG90WVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG5vcm1hbCBsaW5lIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0cG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0XHRwb2ludC5wbG90WVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gc2VnbWVudFBhdGg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgZ3JhcGggcGF0aFxuXHRcdCAqL1xuXHRcdGdldEdyYXBoUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGdyYXBoUGF0aCA9IFtdLFxuXHRcdFx0XHRzZWdtZW50UGF0aCxcblx0XHRcdFx0c2luZ2xlUG9pbnRzID0gW107IC8vIHVzZWQgaW4gZHJhd1RyYWNrZXJcblxuXHRcdFx0Ly8gRGl2aWRlIGludG8gc2VnbWVudHMgYW5kIGJ1aWxkIGdyYXBoIGFuZCBhcmVhIHBhdGhzXG5cdFx0XHRlYWNoKHNlcmllcy5zZWdtZW50cywgZnVuY3Rpb24gKHNlZ21lbnQpIHtcblxuXHRcdFx0XHRzZWdtZW50UGF0aCA9IHNlcmllcy5nZXRTZWdtZW50UGF0aChzZWdtZW50KTtcblxuXHRcdFx0XHQvLyBhZGQgdGhlIHNlZ21lbnQgdG8gdGhlIGdyYXBoLCBvciBhIHNpbmdsZSBwb2ludCBmb3IgdHJhY2tpbmdcblx0XHRcdFx0aWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGdyYXBoUGF0aCA9IGdyYXBoUGF0aC5jb25jYXQoc2VnbWVudFBhdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNpbmdsZVBvaW50cy5wdXNoKHNlZ21lbnRbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUmVjb3JkIGl0IGZvciB1c2UgaW4gZHJhd0dyYXBoIGFuZCBkcmF3VHJhY2tlciwgYW5kIHJldHVybiBncmFwaFBhdGhcblx0XHRcdHNlcmllcy5zaW5nbGVQb2ludHMgPSBzaW5nbGVQb2ludHM7XG5cdFx0XHRzZXJpZXMuZ3JhcGhQYXRoID0gZ3JhcGhQYXRoO1xuXG5cdFx0XHRyZXR1cm4gZ3JhcGhQYXRoO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgdGhlIGFjdHVhbCBncmFwaFxuXHRcdCAqL1xuXHRcdGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHByb3BzID0gW1snZ3JhcGgnLCBvcHRpb25zLmxpbmVDb2xvciB8fCB0aGlzLmNvbG9yLCBvcHRpb25zLmRhc2hTdHlsZV1dLFxuXHRcdFx0XHRsaW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aCxcblx0XHRcdFx0cm91bmRDYXAgPSBvcHRpb25zLmxpbmVjYXAgIT09ICdzcXVhcmUnLFxuXHRcdFx0XHRncmFwaFBhdGggPSB0aGlzLmdldEdyYXBoUGF0aCgpLFxuXHRcdFx0XHRmaWxsQ29sb3IgPSAodGhpcy5maWxsR3JhcGggJiYgdGhpcy5jb2xvcikgfHwgTk9ORSwgLy8gcG9seWdvbiBzZXJpZXMgdXNlIGZpbGxlZCBncmFwaFxuXHRcdFx0XHR6b25lcyA9IHRoaXMuem9uZXM7XG5cblx0XHRcdGVhY2goem9uZXMsIGZ1bmN0aW9uICh0aHJlc2hvbGQsIGkpIHtcblx0XHRcdFx0cHJvcHMucHVzaChbJ2NvbG9yR3JhcGgnICsgaSwgdGhyZXNob2xkLmNvbG9yIHx8IHNlcmllcy5jb2xvciwgdGhyZXNob2xkLmRhc2hTdHlsZSB8fCBvcHRpb25zLmRhc2hTdHlsZV0pO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIERyYXcgdGhlIGdyYXBoXG5cdFx0XHRlYWNoKHByb3BzLCBmdW5jdGlvbiAocHJvcCwgaSkge1xuXHRcdFx0XHR2YXIgZ3JhcGhLZXkgPSBwcm9wWzBdLFxuXHRcdFx0XHRcdGdyYXBoID0gc2VyaWVzW2dyYXBoS2V5XSxcblx0XHRcdFx0XHRhdHRyaWJzO1xuXG5cdFx0XHRcdGlmIChncmFwaCkge1xuXHRcdFx0XHRcdHN0b3AoZ3JhcGgpOyAvLyBjYW5jZWwgcnVubmluZyBhbmltYXRpb25zLCAjNDU5XG5cdFx0XHRcdFx0Z3JhcGguYW5pbWF0ZSh7IGQ6IGdyYXBoUGF0aCB9KTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKChsaW5lV2lkdGggfHwgZmlsbENvbG9yKSAmJiBncmFwaFBhdGgubGVuZ3RoKSB7IC8vICMxNDg3XG5cdFx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRcdHN0cm9rZTogcHJvcFsxXSxcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBsaW5lV2lkdGgsXG5cdFx0XHRcdFx0XHRmaWxsOiBmaWxsQ29sb3IsXG5cdFx0XHRcdFx0XHR6SW5kZXg6IDEgLy8gIzEwNjlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmIChwcm9wWzJdKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzLmRhc2hzdHlsZSA9IHByb3BbMl07XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyb3VuZENhcCkge1xuXHRcdFx0XHRcdFx0YXR0cmlic1snc3Ryb2tlLWxpbmVjYXAnXSA9IGF0dHJpYnNbJ3N0cm9rZS1saW5lam9pbiddID0gJ3JvdW5kJztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZXJpZXNbZ3JhcGhLZXldID0gc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoZ3JhcGhQYXRoKVxuXHRcdFx0XHRcdFx0LmF0dHIoYXR0cmlicylcblx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKVxuXHRcdFx0XHRcdFx0LnNoYWRvdygoaSA8IDIpICYmIG9wdGlvbnMuc2hhZG93KTsgLy8gYWRkIHNoYWRvdyB0byBub3JtYWwgc2VyaWVzICgwKSBvciB0byBmaXJzdCB6b25lICgxKSAjMzkzMlxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2xpcCB0aGUgZ3JhcGhzIGludG8gdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBjb2xvdXJlZCBncmFwaHNcblx0XHQgKi9cblx0XHRhcHBseVpvbmVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHR6b25lcyA9IHRoaXMuem9uZXMsXG5cdFx0XHRcdHRyYW5zbGF0ZWRGcm9tLFxuXHRcdFx0XHR0cmFuc2xhdGVkVG8sXG5cdFx0XHRcdGNsaXBzID0gdGhpcy5jbGlwcyB8fCBbXSxcblx0XHRcdFx0Y2xpcEF0dHIsXG5cdFx0XHRcdGdyYXBoID0gdGhpcy5ncmFwaCxcblx0XHRcdFx0YXJlYSA9IHRoaXMuYXJlYSxcblx0XHRcdFx0Y2hhcnRTaXplTWF4ID0gbWF0aE1heChjaGFydC5jaGFydFdpZHRoLCBjaGFydC5jaGFydEhlaWdodCksXG5cdFx0XHRcdHpvbmVBeGlzID0gdGhpcy56b25lQXhpcyB8fCAneScsXG5cdFx0XHRcdGF4aXMgPSB0aGlzW3pvbmVBeGlzICsgJ0F4aXMnXSxcblx0XHRcdFx0cmV2ZXJzZWQgPSBheGlzLnJldmVyc2VkLFxuXHRcdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdGlnbm9yZVpvbmVzID0gZmFsc2U7XG5cblx0XHRcdGlmICh6b25lcy5sZW5ndGggJiYgKGdyYXBoIHx8IGFyZWEpKSB7XG5cdFx0XHRcdC8vIFRoZSB1c2Ugb2YgdGhlIENvbG9yIFRocmVzaG9sZCBhc3N1bWVzIHRoZXJlIGFyZSBubyBnYXBzXG5cdFx0XHRcdC8vIHNvIGl0IGlzIHNhZmUgdG8gaGlkZSB0aGUgb3JpZ2luYWwgZ3JhcGggYW5kIGFyZWFcblx0XHRcdFx0Z3JhcGguaGlkZSgpO1xuXHRcdFx0XHRpZiAoYXJlYSkgeyBhcmVhLmhpZGUoKTsgfVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgY2xpcHNcblx0XHRcdFx0ZWFjaCh6b25lcywgZnVuY3Rpb24gKHRocmVzaG9sZCwgaSkge1xuXHRcdFx0XHRcdHRyYW5zbGF0ZWRGcm9tID0gcGljayh0cmFuc2xhdGVkVG8sIChyZXZlcnNlZCA/IChob3JpeiA/IGNoYXJ0LnBsb3RXaWR0aCA6IDApIDogKGhvcml6ID8gMCA6IGF4aXMudG9QaXhlbHMoYXhpcy5taW4pKSkpO1xuXHRcdFx0XHRcdHRyYW5zbGF0ZWRUbyA9IG1hdGhSb3VuZChheGlzLnRvUGl4ZWxzKHBpY2sodGhyZXNob2xkLnZhbHVlLCBheGlzLm1heCksIHRydWUpKTtcblxuXHRcdFx0XHRcdGlmIChpZ25vcmVab25lcykge1xuXHRcdFx0XHRcdFx0dHJhbnNsYXRlZEZyb20gPSB0cmFuc2xhdGVkVG8gPSBheGlzLnRvUGl4ZWxzKGF4aXMubWF4KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYXhpcy5pc1hBeGlzKSB7XG5cdFx0XHRcdFx0XHRjbGlwQXR0ciA9IHtcblx0XHRcdFx0XHRcdFx0eDogcmV2ZXJzZWQgPyB0cmFuc2xhdGVkVG8gOiB0cmFuc2xhdGVkRnJvbSxcblx0XHRcdFx0XHRcdFx0eTogMCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IE1hdGguYWJzKHRyYW5zbGF0ZWRGcm9tIC0gdHJhbnNsYXRlZFRvKSwgXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogY2hhcnRTaXplTWF4XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0aWYgKCFob3Jpeikge1xuXHRcdFx0XHRcdFx0XHRjbGlwQXR0ci54ID0gY2hhcnQucGxvdEhlaWdodCAtIGNsaXBBdHRyLng7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsaXBBdHRyID0ge1xuXHRcdFx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdFx0XHR5OiByZXZlcnNlZCA/IHRyYW5zbGF0ZWRGcm9tIDogdHJhbnNsYXRlZFRvLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogY2hhcnRTaXplTWF4LCBcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBNYXRoLmFicyh0cmFuc2xhdGVkRnJvbSAtIHRyYW5zbGF0ZWRUbylcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRpZiAoaG9yaXopIHtcblx0XHRcdFx0XHRcdFx0Y2xpcEF0dHIueSA9IGNoYXJ0LnBsb3RXaWR0aCAtIGNsaXBBdHRyLnk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBcblxuXHRcdFx0XHRcdC8vLyBWTUwgU1VQUFBPUlRcblx0XHRcdFx0XHRpZiAoY2hhcnQuaW52ZXJ0ZWQgJiYgcmVuZGVyZXIuaXNWTUwpIHtcblx0XHRcdFx0XHRcdGlmIChheGlzLmlzWEF4aXMpIHtcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y2xpcEF0dHIgPSB7XG5cdFx0XHRcdFx0XHRcdFx0eDogMCxcblx0XHRcdFx0XHRcdFx0XHR5OiByZXZlcnNlZCA/IHRyYW5zbGF0ZWRGcm9tIDogdHJhbnNsYXRlZFRvLFxuXHRcdFx0XHRcdFx0XHRcdGhlaWdodDogY2xpcEF0dHIud2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LmNoYXJ0V2lkdGhcblx0XHRcdFx0XHRcdFx0fTtcdFx0XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1x0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGNsaXBBdHRyID0ge1xuXHRcdFx0XHRcdFx0XHRcdHg6IGNsaXBBdHRyLnkgLSBjaGFydC5wbG90TGVmdCAtIGNoYXJ0LnNwYWNpbmdCb3gueCxcblx0XHRcdFx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiBjbGlwQXR0ci5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBjaGFydC5jaGFydEhlaWdodFxuXHRcdFx0XHRcdFx0XHR9O1x0XG5cdFx0XHRcdFx0XHR9XHRcdFx0XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8vIEVORCBPRiBWTUwgU1VQUE9SVFxuXG5cdFx0XHRcdFx0aWYgKGNsaXBzW2ldKSB7XG5cdFx0XHRcdFx0XHRjbGlwc1tpXS5hbmltYXRlKGNsaXBBdHRyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xpcHNbaV0gPSByZW5kZXJlci5jbGlwUmVjdChjbGlwQXR0cik7XG5cblx0XHRcdFx0XHRcdHNlcmllc1snY29sb3JHcmFwaCcgKyBpXS5jbGlwKGNsaXBzW2ldKTtcblxuXHRcdFx0XHRcdFx0aWYgKGFyZWEpIHtcblx0XHRcdFx0XHRcdFx0c2VyaWVzWydjb2xvckFyZWEnICsgaV0uY2xpcChjbGlwc1tpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGlmIHRoaXMgem9uZSBleHRlbmRzIG91dCBvZiB0aGUgYXhpcywgaWdub3JlIHRoZSBvdGhlcnNcblx0XHRcdFx0XHRpZ25vcmVab25lcyA9IHRocmVzaG9sZC52YWx1ZSA+IGF4aXMubWF4O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5jbGlwcyA9IGNsaXBzO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIGFuZCBwZXJmb3JtIGdyb3VwIGludmVyc2lvbiBvbiBzZXJpZXMuZ3JvdXAgYW5kIHNlcmllcy5tYXJrZXJHcm91cFxuXHRcdCAqL1xuXHRcdGludmVydEdyb3VwczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0O1xuXG5cdFx0XHQvLyBQaWUsIGdvIGF3YXkgKCMxNzM2KVxuXHRcdFx0aWYgKCFzZXJpZXMueEF4aXMpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBIGZpeGVkIHNpemUgaXMgbmVlZGVkIGZvciBpbnZlcnNpb24gdG8gd29ya1xuXHRcdFx0ZnVuY3Rpb24gc2V0SW52ZXJ0KCkge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IHtcblx0XHRcdFx0XHR3aWR0aDogc2VyaWVzLnlBeGlzLmxlbixcblx0XHRcdFx0XHRoZWlnaHQ6IHNlcmllcy54QXhpcy5sZW5cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRlYWNoKFsnZ3JvdXAnLCAnbWFya2VyR3JvdXAnXSwgZnVuY3Rpb24gKGdyb3VwTmFtZSkge1xuXHRcdFx0XHRcdGlmIChzZXJpZXNbZ3JvdXBOYW1lXSkge1xuXHRcdFx0XHRcdFx0c2VyaWVzW2dyb3VwTmFtZV0uYXR0cihzaXplKS5pbnZlcnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRhZGRFdmVudChjaGFydCwgJ3Jlc2l6ZScsIHNldEludmVydCk7IC8vIGRvIGl0IG9uIHJlc2l6ZVxuXHRcdFx0YWRkRXZlbnQoc2VyaWVzLCAnZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmVtb3ZlRXZlbnQoY2hhcnQsICdyZXNpemUnLCBzZXRJbnZlcnQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIERvIGl0IG5vd1xuXHRcdFx0c2V0SW52ZXJ0KCk7IC8vIGRvIGl0IG5vd1xuXG5cdFx0XHQvLyBPbiBzdWJzZXF1ZW50IHJlbmRlciBhbmQgcmVkcmF3LCBqdXN0IGRvIHNldEludmVydCB3aXRob3V0IHNldHRpbmcgdXAgZXZlbnRzIGFnYWluXG5cdFx0XHRzZXJpZXMuaW52ZXJ0R3JvdXBzID0gc2V0SW52ZXJ0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZW5lcmFsIGFic3RyYWN0aW9uIGZvciBjcmVhdGluZyBwbG90IGdyb3VwcyBsaWtlIHNlcmllcy5ncm91cCwgc2VyaWVzLmRhdGFMYWJlbHNHcm91cCBhbmRcblx0XHQgKiBzZXJpZXMubWFya2VyR3JvdXAuIE9uIHN1YnNlcXVlbnQgY2FsbHMsIHRoZSBncm91cCB3aWxsIG9ubHkgYmUgYWRqdXN0ZWQgdG8gdGhlIHVwZGF0ZWQgcGxvdCBzaXplLlxuXHRcdCAqL1xuXHRcdHBsb3RHcm91cDogZnVuY3Rpb24gKHByb3AsIG5hbWUsIHZpc2liaWxpdHksIHpJbmRleCwgcGFyZW50KSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzW3Byb3BdLFxuXHRcdFx0XHRpc05ldyA9ICFncm91cDtcblxuXHRcdFx0Ly8gR2VuZXJhdGUgaXQgb24gZmlyc3QgY2FsbFxuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdHRoaXNbcHJvcF0gPSBncm91cCA9IHRoaXMuY2hhcnQucmVuZGVyZXIuZyhuYW1lKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdHZpc2liaWxpdHk6IHZpc2liaWxpdHksXG5cdFx0XHRcdFx0XHR6SW5kZXg6IHpJbmRleCB8fCAwLjEgLy8gSUU4IG5lZWRzIHRoaXNcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQocGFyZW50KTtcblx0XHRcdH1cblx0XHRcdC8vIFBsYWNlIGl0IG9uIGZpcnN0IGFuZCBzdWJzZXF1ZW50IChyZWRyYXcpIGNhbGxzXG5cdFx0XHRncm91cFtpc05ldyA/ICdhdHRyJyA6ICdhbmltYXRlJ10odGhpcy5nZXRQbG90Qm94KCkpO1xuXHRcdFx0cmV0dXJuIGdyb3VwO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHRyYW5zbGF0aW9uIGFuZCBzY2FsZSBmb3IgdGhlIHBsb3QgYXJlYSBvZiB0aGlzIHNlcmllc1xuXHRcdCAqL1xuXHRcdGdldFBsb3RCb3g6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHhBeGlzID0gdGhpcy54QXhpcyxcblx0XHRcdFx0eUF4aXMgPSB0aGlzLnlBeGlzO1xuXG5cdFx0XHQvLyBTd2FwIGF4ZXMgZm9yIGludmVydGVkICgjMjMzOSlcblx0XHRcdGlmIChjaGFydC5pbnZlcnRlZCkge1xuXHRcdFx0XHR4QXhpcyA9IHlBeGlzO1xuXHRcdFx0XHR5QXhpcyA9IHRoaXMueEF4aXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0cmFuc2xhdGVYOiB4QXhpcyA/IHhBeGlzLmxlZnQgOiBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0dHJhbnNsYXRlWTogeUF4aXMgPyB5QXhpcy50b3AgOiBjaGFydC5wbG90VG9wLFxuXHRcdFx0XHRzY2FsZVg6IDEsIC8vICMxNjIzXG5cdFx0XHRcdHNjYWxlWTogMVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIHRoZSBncmFwaCBhbmQgbWFya2Vyc1xuXHRcdCAqL1xuXHRcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRncm91cCxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRhbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbixcblx0XHRcdFx0Ly8gQW5pbWF0aW9uIGRvZXNuJ3Qgd29yayBpbiBJRTggcXVpcmtzIHdoZW4gdGhlIGdyb3VwIGRpdiBpcyBoaWRkZW4sXG5cdFx0XHRcdC8vIGFuZCBsb29rcyBiYWQgaW4gb3RoZXIgb2xkSUVcblx0XHRcdFx0YW5pbUR1cmF0aW9uID0gKGFuaW1hdGlvbiAmJiAhIXNlcmllcy5hbmltYXRlICYmIGNoYXJ0LnJlbmRlcmVyLmlzU1ZHICYmIHBpY2soYW5pbWF0aW9uLmR1cmF0aW9uLCA1MDApKSB8fCAwLFxuXHRcdFx0XHR2aXNpYmlsaXR5ID0gc2VyaWVzLnZpc2libGUgPyBWSVNJQkxFIDogSElEREVOLFxuXHRcdFx0XHR6SW5kZXggPSBvcHRpb25zLnpJbmRleCxcblx0XHRcdFx0aGFzUmVuZGVyZWQgPSBzZXJpZXMuaGFzUmVuZGVyZWQsXG5cdFx0XHRcdGNoYXJ0U2VyaWVzR3JvdXAgPSBjaGFydC5zZXJpZXNHcm91cDtcblxuXHRcdFx0Ly8gdGhlIGdyb3VwXG5cdFx0XHRncm91cCA9IHNlcmllcy5wbG90R3JvdXAoXG5cdFx0XHRcdCdncm91cCcsXG5cdFx0XHRcdCdzZXJpZXMnLFxuXHRcdFx0XHR2aXNpYmlsaXR5LFxuXHRcdFx0XHR6SW5kZXgsXG5cdFx0XHRcdGNoYXJ0U2VyaWVzR3JvdXBcblx0XHRcdCk7XG5cblx0XHRcdHNlcmllcy5tYXJrZXJHcm91cCA9IHNlcmllcy5wbG90R3JvdXAoXG5cdFx0XHRcdCdtYXJrZXJHcm91cCcsXG5cdFx0XHRcdCdtYXJrZXJzJyxcblx0XHRcdFx0dmlzaWJpbGl0eSxcblx0XHRcdFx0ekluZGV4LFxuXHRcdFx0XHRjaGFydFNlcmllc0dyb3VwXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBpbml0aWF0ZSB0aGUgYW5pbWF0aW9uXG5cdFx0XHRpZiAoYW5pbUR1cmF0aW9uKSB7XG5cdFx0XHRcdHNlcmllcy5hbmltYXRlKHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWNoZSBhdHRyaWJ1dGVzIGZvciBzaGFwZXNcblx0XHRcdHNlcmllcy5nZXRBdHRyaWJzKCk7XG5cblx0XHRcdC8vIFNWR1JlbmRlcmVyIG5lZWRzIHRvIGtub3cgdGhpcyBiZWZvcmUgZHJhd2luZyBlbGVtZW50cyAoIzEwODksICMxNzk1KVxuXHRcdFx0Z3JvdXAuaW52ZXJ0ZWQgPSBzZXJpZXMuaXNDYXJ0ZXNpYW4gPyBjaGFydC5pbnZlcnRlZCA6IGZhbHNlO1xuXG5cdFx0XHQvLyBkcmF3IHRoZSBncmFwaCBpZiBhbnlcblx0XHRcdGlmIChzZXJpZXMuZHJhd0dyYXBoKSB7XG5cdFx0XHRcdHNlcmllcy5kcmF3R3JhcGgoKTtcblx0XHRcdFx0c2VyaWVzLmFwcGx5Wm9uZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0ZWFjaChzZXJpZXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0aWYgKHBvaW50LnJlZHJhdykge1xuXHRcdFx0XHRcdHBvaW50LnJlZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gZHJhdyB0aGUgZGF0YSBsYWJlbHMgKGlubiBwaWVzIHRoZXkgZ28gYmVmb3JlIHRoZSBwb2ludHMpXG5cdFx0XHRpZiAoc2VyaWVzLmRyYXdEYXRhTGFiZWxzKSB7XG5cdFx0XHRcdHNlcmllcy5kcmF3RGF0YUxhYmVscygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkcmF3IHRoZSBwb2ludHNcblx0XHRcdGlmIChzZXJpZXMudmlzaWJsZSkge1xuXHRcdFx0XHRzZXJpZXMuZHJhd1BvaW50cygpO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vIGRyYXcgdGhlIG1vdXNlIHRyYWNraW5nIGFyZWFcblx0XHRcdGlmIChzZXJpZXMuZHJhd1RyYWNrZXIgJiYgc2VyaWVzLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0c2VyaWVzLmRyYXdUcmFja2VyKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBpbnZlcnRlZCBzZXJpZXMgYW5kIHRyYWNrZXIgZ3JvdXBzXG5cdFx0XHRpZiAoY2hhcnQuaW52ZXJ0ZWQpIHtcblx0XHRcdFx0c2VyaWVzLmludmVydEdyb3VwcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsIGNsaXBwaW5nLCBtdXN0IGJlIGRlZmluZWQgYWZ0ZXIgaW52ZXJ0aW5nIGdyb3VwcyBmb3IgVk1MLiBBcHBsaWVzIHRvIGNvbHVtbnMgZXRjLiAoIzM4MzkpLlxuXHRcdFx0aWYgKG9wdGlvbnMuY2xpcCAhPT0gZmFsc2UgJiYgIXNlcmllcy5zaGFyZWRDbGlwS2V5ICYmICFoYXNSZW5kZXJlZCkge1xuXHRcdFx0XHRncm91cC5jbGlwKGNoYXJ0LmNsaXBSZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUnVuIHRoZSBhbmltYXRpb25cblx0XHRcdGlmIChhbmltRHVyYXRpb24pIHtcblx0XHRcdFx0c2VyaWVzLmFuaW1hdGUoKTtcblx0XHRcdH0gXG5cblx0XHRcdC8vIENhbGwgdGhlIGFmdGVyQW5pbWF0ZSBmdW5jdGlvbiBvbiBhbmltYXRpb24gY29tcGxldGUgKGJ1dCBkb24ndCBvdmVyd3JpdGUgdGhlIGFuaW1hdGlvbi5jb21wbGV0ZSBvcHRpb25cblx0XHRcdC8vIHdoaWNoIHNob3VsZCBiZSBhdmFpbGFibGUgdG8gdGhlIHVzZXIpLlxuXHRcdFx0aWYgKCFoYXNSZW5kZXJlZCkge1xuXHRcdFx0XHRpZiAoYW5pbUR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0c2VyaWVzLmFuaW1hdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHNlcmllcy5hZnRlckFuaW1hdGUoKTtcblx0XHRcdFx0XHR9LCBhbmltRHVyYXRpb24pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlcmllcy5hZnRlckFuaW1hdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5RGF0YSA9IGZhbHNlOyAvLyBtZWFucyBkYXRhIGlzIGluIGFjY29yZGFuY2Ugd2l0aCB3aGF0IHlvdSBzZWVcblx0XHRcdC8vIChTZWUgIzMyMikgc2VyaWVzLmlzRGlydHkgPSBzZXJpZXMuaXNEaXJ0eURhdGEgPSBmYWxzZTsgLy8gbWVhbnMgZGF0YSBpcyBpbiBhY2NvcmRhbmNlIHdpdGggd2hhdCB5b3Ugc2VlXG5cdFx0XHRzZXJpZXMuaGFzUmVuZGVyZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZWRyYXcgdGhlIHNlcmllcyBhZnRlciBhbiB1cGRhdGUgaW4gdGhlIGF4ZXMuXG5cdFx0ICovXG5cdFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHdhc0RpcnR5RGF0YSA9IHNlcmllcy5pc0RpcnR5RGF0YSwgLy8gY2FjaGUgaXQgaGVyZSBhcyBpdCBpcyBzZXQgdG8gZmFsc2UgaW4gcmVuZGVyLCBidXQgdXNlZCBhZnRlclxuXHRcdFx0XHR3YXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5LFxuXHRcdFx0XHRncm91cCA9IHNlcmllcy5ncm91cCxcblx0XHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHRcdHlBeGlzID0gc2VyaWVzLnlBeGlzO1xuXG5cdFx0XHQvLyByZXBvc2l0aW9uIG9uIHJlc2l6ZVxuXHRcdFx0aWYgKGdyb3VwKSB7XG5cdFx0XHRcdGlmIChjaGFydC5pbnZlcnRlZCkge1xuXHRcdFx0XHRcdGdyb3VwLmF0dHIoe1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LnBsb3RXaWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogY2hhcnQucGxvdEhlaWdodFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z3JvdXAuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWDogcGljayh4QXhpcyAmJiB4QXhpcy5sZWZ0LCBjaGFydC5wbG90TGVmdCksXG5cdFx0XHRcdFx0dHJhbnNsYXRlWTogcGljayh5QXhpcyAmJiB5QXhpcy50b3AsIGNoYXJ0LnBsb3RUb3ApXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMudHJhbnNsYXRlKCk7XG5cdFx0XHRzZXJpZXMucmVuZGVyKCk7XG5cdFx0XHRpZiAod2FzRGlydHlEYXRhKSB7XG5cdFx0XHRcdGZpcmVFdmVudChzZXJpZXMsICd1cGRhdGVkRGF0YScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHdhc0RpcnR5IHx8IHdhc0RpcnR5RGF0YSkge1x0XHRcdC8vICMzOTQ1IHJlY2FsY3VsYXRlIHRoZSBrZHRyZWUgd2hlbiBkaXJ0eVxuXHRcdFx0XHRkZWxldGUgdGhpcy5rZFRyZWU7IC8vICMzODY4IHJlY2FsY3VsYXRlIHRoZSBrZHRyZWUgd2l0aCBkaXJ0eSBkYXRhXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEtEIFRyZWUgJiYgUG9pbnRTZWFyY2hpbmcgSW1wbGVtZW50YXRpb25cblx0XHQgKi9cblxuXHRcdGtkRGltZW5zaW9uczogMSxcblx0XHRrZFRyZWU6IG51bGwsXG5cdFx0a2RBeGlzQXJyYXk6IFsnY2xpZW50WCcsICdwbG90WSddLFxuXHRcdGtkQ29tcGFyZXI6ICdkaXN0WCcsXG5cblx0XHRzZWFyY2hQb2ludDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXMsXG5cdFx0XHRcdGludmVydGVkID0gc2VyaWVzLmNoYXJ0LmludmVydGVkO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWFyY2hLRFRyZWUoe1xuXHRcdFx0XHRjbGllbnRYOiBpbnZlcnRlZCA/IHhBeGlzLmxlbiAtIGUuY2hhcnRZICsgeEF4aXMucG9zIDogZS5jaGFydFggLSB4QXhpcy5wb3MsXG5cdFx0XHRcdHBsb3RZOiBpbnZlcnRlZCA/IHlBeGlzLmxlbiAtIGUuY2hhcnRYICsgeUF4aXMucG9zIDogZS5jaGFydFkgLSB5QXhpcy5wb3Ncblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRidWlsZEtEVHJlZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGRpbWVuc2lvbnMgPSBzZXJpZXMua2REaW1lbnNpb25zO1xuXG5cdFx0XHQvLyBJbnRlcm5hbCBmdW5jdGlvblxuXHRcdFx0ZnVuY3Rpb24gX2tkdHJlZShwb2ludHMsIGRlcHRoLCBkaW1lbnNpb25zKSB7XG5cdFx0XHRcdHZhciBheGlzLCBtZWRpYW4sIGxlbmd0aCA9IHBvaW50cyAmJiBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmIChsZW5ndGgpIHtcblxuXHRcdFx0XHRcdC8vIGFsdGVybmF0ZSBiZXR3ZWVuIHRoZSBheGlzXG5cdFx0XHRcdFx0YXhpcyA9IHNlcmllcy5rZEF4aXNBcnJheVtkZXB0aCAlIGRpbWVuc2lvbnNdO1xuXG5cdFx0XHRcdFx0Ly8gc29ydCBwb2ludCBhcnJheVxuXHRcdFx0XHRcdHBvaW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhW2F4aXNdIC0gYltheGlzXTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0bWVkaWFuID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBidWlsZCBhbmQgcmV0dXJuIG5vZGVcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0cG9pbnQ6IHBvaW50c1ttZWRpYW5dLFxuXHRcdFx0XHRcdFx0bGVmdDogX2tkdHJlZShwb2ludHMuc2xpY2UoMCwgbWVkaWFuKSwgZGVwdGggKyAxLCBkaW1lbnNpb25zKSxcblx0XHRcdFx0XHRcdHJpZ2h0OiBfa2R0cmVlKHBvaW50cy5zbGljZShtZWRpYW4gKyAxKSwgZGVwdGggKyAxLCBkaW1lbnNpb25zKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSByZWN1cnNpdmUgYnVpbGQgcHJvY2VzcyB3aXRoIGEgY2xvbmUgb2YgdGhlIHBvaW50cyBhcnJheSBhbmQgbnVsbCBwb2ludHMgZmlsdGVyZWQgb3V0ICgjMzg3Mylcblx0XHRcdGZ1bmN0aW9uIHN0YXJ0UmVjdXJzaXZlKCkge1xuXHRcdFx0XHR2YXIgcG9pbnRzID0gZ3JlcChzZXJpZXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcG9pbnQueSAhPT0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNlcmllcy5rZFRyZWUgPSBfa2R0cmVlKHBvaW50cywgZGltZW5zaW9ucywgZGltZW5zaW9ucyk7XHRcdFxuXHRcdFx0fVxuXG5cdFx0XHRkZWxldGUgc2VyaWVzLmtkVHJlZTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlcmllcy5vcHRpb25zLmtkU3luYykgeyAgLy8gRm9yIHRlc3RpbmcgdG9vbHRpcHMsIGRvbid0IGJ1aWxkIGFzeW5jXG5cdFx0XHRcdHN0YXJ0UmVjdXJzaXZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXRUaW1lb3V0KHN0YXJ0UmVjdXJzaXZlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2VhcmNoS0RUcmVlOiBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRrZENvbXBhcmVyID0gdGhpcy5rZENvbXBhcmVyLFxuXHRcdFx0XHRrZFggPSB0aGlzLmtkQXhpc0FycmF5WzBdLFxuXHRcdFx0XHRrZFkgPSB0aGlzLmtkQXhpc0FycmF5WzFdO1xuXG5cdFx0XHQvLyBJbnRlcm5hbCBmdW5jdGlvblxuXHRcdFx0ZnVuY3Rpb24gX2Rpc3RhbmNlKHAxLCBwMikge1xuXHRcdFx0XHR2YXIgeCA9IChkZWZpbmVkKHAxW2tkWF0pICYmIGRlZmluZWQocDJba2RYXSkpID8gTWF0aC5wb3cocDFba2RYXSAtIHAyW2tkWF0sIDIpIDogbnVsbCxcblx0XHRcdFx0XHR5ID0gKGRlZmluZWQocDFba2RZXSkgJiYgZGVmaW5lZChwMltrZFldKSkgPyBNYXRoLnBvdyhwMVtrZFldIC0gcDJba2RZXSwgMikgOiBudWxsLFxuXHRcdFx0XHRcdHIgPSAoeCB8fCAwKSArICh5IHx8IDApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGRpc3RYOiBkZWZpbmVkKHgpID8gTWF0aC5zcXJ0KHgpIDogTnVtYmVyLk1BWF9WQUxVRSxcblx0XHRcdFx0XHRkaXN0WTogZGVmaW5lZCh5KSA/IE1hdGguc3FydCh5KSA6IE51bWJlci5NQVhfVkFMVUUsXG5cdFx0XHRcdFx0ZGlzdFI6IGRlZmluZWQocikgPyBNYXRoLnNxcnQocikgOiBOdW1iZXIuTUFYX1ZBTFVFXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBfc2VhcmNoKHNlYXJjaCwgdHJlZSwgZGVwdGgsIGRpbWVuc2lvbnMpIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gdHJlZS5wb2ludCxcblx0XHRcdFx0XHRheGlzID0gc2VyaWVzLmtkQXhpc0FycmF5W2RlcHRoICUgZGltZW5zaW9uc10sXG5cdFx0XHRcdFx0dGRpc3QsXG5cdFx0XHRcdFx0c2lkZUEsXG5cdFx0XHRcdFx0c2lkZUIsXG5cdFx0XHRcdFx0cmV0ID0gcG9pbnQsXG5cdFx0XHRcdFx0blBvaW50MSxcblx0XHRcdFx0XHRuUG9pbnQyO1xuXHRcdFx0XHRwb2ludC5kaXN0ID0gX2Rpc3RhbmNlKHNlYXJjaCwgcG9pbnQpO1xuXG5cdFx0XHRcdC8vIFBpY2sgc2lkZSBiYXNlZCBvbiBkaXN0YW5jZSB0byBzcGxpdHRpbmcgcG9pbnRcblx0XHRcdFx0dGRpc3QgPSBzZWFyY2hbYXhpc10gLSBwb2ludFtheGlzXTtcblx0XHRcdFx0c2lkZUEgPSB0ZGlzdCA8IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG5cdFx0XHRcdC8vIEVuZCBvZiB0cmVlXG5cdFx0XHRcdGlmICh0cmVlW3NpZGVBXSkge1xuXHRcdFx0XHRcdG5Qb2ludDEgPV9zZWFyY2goc2VhcmNoLCB0cmVlW3NpZGVBXSwgZGVwdGggKyAxLCBkaW1lbnNpb25zKTtcblxuXHRcdFx0XHRcdHJldCA9IChuUG9pbnQxLmRpc3Rba2RDb21wYXJlcl0gPCByZXQuZGlzdFtrZENvbXBhcmVyXSA/IG5Qb2ludDEgOiBwb2ludCk7XG5cblx0XHRcdFx0XHRzaWRlQiA9IHRkaXN0IDwgMCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cdFx0XHRcdFx0aWYgKHRyZWVbc2lkZUJdKSB7XG5cdFx0XHRcdFx0XHQvLyBjb21wYXJlIGRpc3RhbmNlIHRvIGN1cnJlbnQgYmVzdCB0byBzcGxpdHRpbmcgcG9pbnQgdG8gZGVjaWRlIHdldGhlciB0byBjaGVjayBzaWRlIEIgb3Igbm90XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5zcXJ0KHRkaXN0KnRkaXN0KSA8IHJldC5kaXN0W2tkQ29tcGFyZXJdKSB7XG5cdFx0XHRcdFx0XHRcdG5Qb2ludDIgPSBfc2VhcmNoKHNlYXJjaCwgdHJlZVtzaWRlQl0sIGRlcHRoICsgMSwgZGltZW5zaW9ucyk7XG5cdFx0XHRcdFx0XHRcdHJldCA9IChuUG9pbnQyLmRpc3Rba2RDb21wYXJlcl0gPCByZXQuZGlzdFtrZENvbXBhcmVyXSA/IG5Qb2ludDIgOiByZXQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMua2RUcmVlKSB7XG5cdFx0XHRcdHRoaXMuYnVpbGRLRFRyZWUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMua2RUcmVlKSB7XG5cdFx0XHRcdHJldHVybiBfc2VhcmNoKHBvaW50LCBcblx0XHRcdFx0XHR0aGlzLmtkVHJlZSwgdGhpcy5rZERpbWVuc2lvbnMsIHRoaXMua2REaW1lbnNpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fTsgLy8gZW5kIFNlcmllcyBwcm90b3R5cGVcblxuXHQvKipcblx0ICogVGhlIGNsYXNzIGZvciBzdGFjayBpdGVtc1xuXHQgKi9cblx0ZnVuY3Rpb24gU3RhY2tJdGVtKGF4aXMsIG9wdGlvbnMsIGlzTmVnYXRpdmUsIHgsIHN0YWNrT3B0aW9uKSB7XG5cdFx0XG5cdFx0dmFyIGludmVydGVkID0gYXhpcy5jaGFydC5pbnZlcnRlZDtcblxuXHRcdHRoaXMuYXhpcyA9IGF4aXM7XG5cblx0XHQvLyBUZWxscyBpZiB0aGUgc3RhY2sgaXMgbmVnYXRpdmVcblx0XHR0aGlzLmlzTmVnYXRpdmUgPSBpc05lZ2F0aXZlO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgb3B0aW9ucyB0byBiZSBhYmxlIHRvIHN0eWxlIHRoZSBsYWJlbFxuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHQvLyBTYXZlIHRoZSB4IHZhbHVlIHRvIGJlIGFibGUgdG8gcG9zaXRpb24gdGhlIGxhYmVsIGxhdGVyXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdC8vIEluaXRpYWxpemUgdG90YWwgdmFsdWVcblx0XHR0aGlzLnRvdGFsID0gbnVsbDtcblxuXHRcdC8vIFRoaXMgd2lsbCBrZWVwIGVhY2ggcG9pbnRzJyBleHRyZW1lcyBzdG9yZWQgYnkgc2VyaWVzLmluZGV4IGFuZCBwb2ludCBpbmRleFxuXHRcdHRoaXMucG9pbnRzID0ge307XG5cblx0XHQvLyBTYXZlIHRoZSBzdGFjayBvcHRpb24gb24gdGhlIHNlcmllcyBjb25maWd1cmF0aW9uIG9iamVjdCwgYW5kIHdoZXRoZXIgdG8gdHJlYXQgaXQgYXMgcGVyY2VudFxuXHRcdHRoaXMuc3RhY2sgPSBzdGFja09wdGlvbjtcblxuXHRcdC8vIFRoZSBhbGlnbiBvcHRpb25zIGFuZCB0ZXh0IGFsaWduIHZhcmllcyBvbiB3aGV0aGVyIHRoZSBzdGFjayBpcyBuZWdhdGl2ZSBhbmRcblx0XHQvLyBpZiB0aGUgY2hhcnQgaXMgaW52ZXJ0ZWQgb3Igbm90LlxuXHRcdC8vIEZpcnN0IHRlc3QgdGhlIHVzZXIgc3VwcGxpZWQgdmFsdWUsIHRoZW4gdXNlIHRoZSBkeW5hbWljLlxuXHRcdHRoaXMuYWxpZ25PcHRpb25zID0ge1xuXHRcdFx0YWxpZ246IG9wdGlvbnMuYWxpZ24gfHwgKGludmVydGVkID8gKGlzTmVnYXRpdmUgPyAnbGVmdCcgOiAncmlnaHQnKSA6ICdjZW50ZXInKSxcblx0XHRcdHZlcnRpY2FsQWxpZ246IG9wdGlvbnMudmVydGljYWxBbGlnbiB8fCAoaW52ZXJ0ZWQgPyAnbWlkZGxlJyA6IChpc05lZ2F0aXZlID8gJ2JvdHRvbScgOiAndG9wJykpLFxuXHRcdFx0eTogcGljayhvcHRpb25zLnksIGludmVydGVkID8gNCA6IChpc05lZ2F0aXZlID8gMTQgOiAtNikpLFxuXHRcdFx0eDogcGljayhvcHRpb25zLngsIGludmVydGVkID8gKGlzTmVnYXRpdmUgPyAtNiA6IDYpIDogMClcblx0XHR9O1xuXG5cdFx0dGhpcy50ZXh0QWxpZ24gPSBvcHRpb25zLnRleHRBbGlnbiB8fCAoaW52ZXJ0ZWQgPyAoaXNOZWdhdGl2ZSA/ICdyaWdodCcgOiAnbGVmdCcpIDogJ2NlbnRlcicpO1xuXHR9XG5cblx0U3RhY2tJdGVtLnByb3RvdHlwZSA9IHtcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRkZXN0cm95T2JqZWN0UHJvcGVydGllcyh0aGlzLCB0aGlzLmF4aXMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXJzIHRoZSBzdGFjayB0b3RhbCBsYWJlbCBhbmQgYWRkcyBpdCB0byB0aGUgc3RhY2sgbGFiZWwgZ3JvdXAuXG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoZ3JvdXApIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRmb3JtYXRPcHRpb24gPSBvcHRpb25zLmZvcm1hdCxcblx0XHRcdFx0c3RyID0gZm9ybWF0T3B0aW9uID9cblx0XHRcdFx0XHRmb3JtYXQoZm9ybWF0T3B0aW9uLCB0aGlzKSA6IFxuXHRcdFx0XHRcdG9wdGlvbnMuZm9ybWF0dGVyLmNhbGwodGhpcyk7ICAvLyBmb3JtYXQgdGhlIHRleHQgaW4gdGhlIGxhYmVsXG5cblx0XHRcdC8vIENoYW5nZSB0aGUgdGV4dCB0byByZWZsZWN0IHRoZSBuZXcgdG90YWwgYW5kIHNldCB2aXNpYmlsaXR5IHRvIGhpZGRlbiBpbiBjYXNlIHRoZSBzZXJpZSBpcyBoaWRkZW5cblx0XHRcdGlmICh0aGlzLmxhYmVsKSB7XG5cdFx0XHRcdHRoaXMubGFiZWwuYXR0cih7dGV4dDogc3RyLCB2aXNpYmlsaXR5OiBISURERU59KTtcblx0XHRcdC8vIENyZWF0ZSBuZXcgbGFiZWxcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubGFiZWwgPVxuXHRcdFx0XHRcdHRoaXMuYXhpcy5jaGFydC5yZW5kZXJlci50ZXh0KHN0ciwgbnVsbCwgbnVsbCwgb3B0aW9ucy51c2VIVE1MKVx0XHQvLyBkdW1teSBwb3NpdGlvbnMsIGFjdHVhbCBwb3NpdGlvbiB1cGRhdGVkIHdpdGggc2V0T2Zmc2V0IG1ldGhvZCBpbiBjb2x1bW5zZXJpZXNcblx0XHRcdFx0XHRcdC5jc3Mob3B0aW9ucy5zdHlsZSlcdFx0XHRcdC8vIGFwcGx5IHN0eWxlXG5cdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdGFsaWduOiB0aGlzLnRleHRBbGlnbixcdFx0XHRcdC8vIGZpeCB0aGUgdGV4dC1hbmNob3Jcblx0XHRcdFx0XHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXHQvLyByb3RhdGlvblxuXHRcdFx0XHRcdFx0XHR2aXNpYmlsaXR5OiBISURERU5cdFx0XHRcdFx0Ly8gaGlkZGVuIHVudGlsIHNldE9mZnNldCBpcyBjYWxsZWRcblx0XHRcdFx0XHRcdH0pXHRcdFx0XHRcblx0XHRcdFx0XHRcdC5hZGQoZ3JvdXApO1x0XHRcdFx0XHRcdFx0Ly8gYWRkIHRvIHRoZSBsYWJlbHMtZ3JvdXBcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0cyB0aGUgb2Zmc2V0IHRoYXQgdGhlIHN0YWNrIGhhcyBmcm9tIHRoZSB4IHZhbHVlIGFuZCByZXBvc2l0aW9ucyB0aGUgbGFiZWwuXG5cdFx0ICovXG5cdFx0c2V0T2Zmc2V0OiBmdW5jdGlvbiAoeE9mZnNldCwgeFdpZHRoKSB7XG5cdFx0XHR2YXIgc3RhY2tJdGVtID0gdGhpcyxcblx0XHRcdFx0YXhpcyA9IHN0YWNrSXRlbS5heGlzLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRcdG5lZyA9IHRoaXMuaXNOZWdhdGl2ZSxcdFx0XHRcdFx0XHRcdC8vIHNwZWNpYWwgdHJlYXRtZW50IGlzIG5lZWRlZCBmb3IgbmVnYXRpdmUgc3RhY2tzXG5cdFx0XHRcdHkgPSBheGlzLnRyYW5zbGF0ZShheGlzLnVzZVBlcmNlbnRhZ2UgPyAxMDAgOiB0aGlzLnRvdGFsLCAwLCAwLCAwLCAxKSwgLy8gc3RhY2sgdmFsdWUgdHJhbnNsYXRlZCBtYXBwZWQgdG8gY2hhcnQgY29vcmRpbmF0ZXNcblx0XHRcdFx0eVplcm8gPSBheGlzLnRyYW5zbGF0ZSgwKSxcdFx0XHRcdFx0XHQvLyBzdGFjayBvcmlnaW5cblx0XHRcdFx0aCA9IG1hdGhBYnMoeSAtIHlaZXJvKSxcdFx0XHRcdFx0XHRcdC8vIHN0YWNrIGhlaWdodFxuXHRcdFx0XHR4ID0gY2hhcnQueEF4aXNbMF0udHJhbnNsYXRlKHRoaXMueCkgKyB4T2Zmc2V0LFx0Ly8gc3RhY2sgeCBwb3NpdGlvblxuXHRcdFx0XHRwbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCxcblx0XHRcdFx0c3RhY2tCb3ggPSB7XHQvLyB0aGlzIGlzIHRoZSBib3ggZm9yIHRoZSBjb21wbGV0ZSBzdGFja1xuXHRcdFx0XHRcdHg6IGludmVydGVkID8gKG5lZyA/IHkgOiB5IC0gaCkgOiB4LFxuXHRcdFx0XHRcdHk6IGludmVydGVkID8gcGxvdEhlaWdodCAtIHggLSB4V2lkdGggOiAobmVnID8gKHBsb3RIZWlnaHQgLSB5IC0gaCkgOiBwbG90SGVpZ2h0IC0geSksXG5cdFx0XHRcdFx0d2lkdGg6IGludmVydGVkID8gaCA6IHhXaWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGludmVydGVkID8geFdpZHRoIDogaFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRsYWJlbCA9IHRoaXMubGFiZWwsXG5cdFx0XHRcdGFsaWduQXR0cjtcblx0XHRcdFxuXHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdGxhYmVsLmFsaWduKHRoaXMuYWxpZ25PcHRpb25zLCBudWxsLCBzdGFja0JveCk7XHQvLyBhbGlnbiB0aGUgbGFiZWwgdG8gdGhlIGJveFxuXHRcdFx0XHRcdFxuXHRcdFx0XHQvLyBTZXQgdmlzaWJpbGl0eSAoIzY3OClcblx0XHRcdFx0YWxpZ25BdHRyID0gbGFiZWwuYWxpZ25BdHRyO1xuXHRcdFx0XHRsYWJlbFt0aGlzLm9wdGlvbnMuY3JvcCA9PT0gZmFsc2UgfHwgY2hhcnQuaXNJbnNpZGVQbG90KGFsaWduQXR0ci54LCBhbGlnbkF0dHIueSkgPyAnc2hvdycgOiAnaGlkZSddKHRydWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXG5cdC8vIFN0YWNraW5nIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgQXhpcyBwcm90b3R5cGVcblxuXHQvKipcblx0ICogQnVpbGQgdGhlIHN0YWNrcyBmcm9tIHRvcCBkb3duXG5cdCAqL1xuXHRBeGlzLnByb3RvdHlwZS5idWlsZFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2VyaWVzID0gdGhpcy5zZXJpZXMsXG5cdFx0XHRyZXZlcnNlZFN0YWNrcyA9IHBpY2sodGhpcy5vcHRpb25zLnJldmVyc2VkU3RhY2tzLCB0cnVlKSxcblx0XHRcdGkgPSBzZXJpZXMubGVuZ3RoO1xuXHRcdGlmICghdGhpcy5pc1hBeGlzKSB7XG5cdFx0XHR0aGlzLnVzZVBlcmNlbnRhZ2UgPSBmYWxzZTtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0c2VyaWVzW3JldmVyc2VkU3RhY2tzID8gaSA6IHNlcmllcy5sZW5ndGggLSBpIC0gMV0uc2V0U3RhY2tlZFBvaW50cygpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTG9vcCB1cCBhZ2FpbiB0byBjb21wdXRlIHBlcmNlbnQgc3RhY2tcblx0XHRcdGlmICh0aGlzLnVzZVBlcmNlbnRhZ2UpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHNlcmllc1tpXS5zZXRQZXJjZW50U3RhY2tzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0QXhpcy5wcm90b3R5cGUucmVuZGVyU3RhY2tUb3RhbHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdHN0YWNrcyA9IGF4aXMuc3RhY2tzLFxuXHRcdFx0c3RhY2tLZXksIFxuXHRcdFx0b25lU3RhY2ssIFxuXHRcdFx0c3RhY2tDYXRlZ29yeSxcblx0XHRcdHN0YWNrVG90YWxHcm91cCA9IGF4aXMuc3RhY2tUb3RhbEdyb3VwO1xuXG5cdFx0Ly8gQ3JlYXRlIGEgc2VwYXJhdGUgZ3JvdXAgZm9yIHRoZSBzdGFjayB0b3RhbCBsYWJlbHNcblx0XHRpZiAoIXN0YWNrVG90YWxHcm91cCkge1xuXHRcdFx0YXhpcy5zdGFja1RvdGFsR3JvdXAgPSBzdGFja1RvdGFsR3JvdXAgPVxuXHRcdFx0XHRyZW5kZXJlci5nKCdzdGFjay1sYWJlbHMnKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdHZpc2liaWxpdHk6IFZJU0lCTEUsXG5cdFx0XHRcdFx0XHR6SW5kZXg6IDZcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHR9XG5cblx0XHQvLyBwbG90TGVmdC9Ub3Agd2lsbCBjaGFuZ2Ugd2hlbiB5IGF4aXMgZ2V0cyB3aWRlciBzbyB3ZSBuZWVkIHRvIHRyYW5zbGF0ZSB0aGVcblx0XHQvLyBzdGFja1RvdGFsR3JvdXAgYXQgZXZlcnkgcmVuZGVyIGNhbGwuIFNlZSBidWcgIzUwNiBhbmQgIzUxNlxuXHRcdHN0YWNrVG90YWxHcm91cC50cmFuc2xhdGUoY2hhcnQucGxvdExlZnQsIGNoYXJ0LnBsb3RUb3ApO1xuXG5cdFx0Ly8gUmVuZGVyIGVhY2ggc3RhY2sgdG90YWxcblx0XHRmb3IgKHN0YWNrS2V5IGluIHN0YWNrcykge1xuXHRcdFx0b25lU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldO1xuXHRcdFx0Zm9yIChzdGFja0NhdGVnb3J5IGluIG9uZVN0YWNrKSB7XG5cdFx0XHRcdG9uZVN0YWNrW3N0YWNrQ2F0ZWdvcnldLnJlbmRlcihzdGFja1RvdGFsR3JvdXApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXG5cdC8vIFN0YWNraW5nIG1ldGhvZHMgZGVmbmllZCBmb3IgU2VyaWVzIHByb3RvdHlwZVxuXG5cdC8qKlxuXHQgKiBBZGRzIHNlcmllcycgcG9pbnRzIHZhbHVlIHRvIGNvcnJlc3BvbmRpbmcgc3RhY2tcblx0ICovXG5cdFNlcmllcy5wcm90b3R5cGUuc2V0U3RhY2tlZFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5zdGFja2luZyB8fCAodGhpcy52aXNpYmxlICE9PSB0cnVlICYmIHRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMgIT09IGZhbHNlKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0eERhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWERhdGEsXG5cdFx0XHR5RGF0YSA9IHNlcmllcy5wcm9jZXNzZWRZRGF0YSxcblx0XHRcdHN0YWNrZWRZRGF0YSA9IFtdLFxuXHRcdFx0eURhdGFMZW5ndGggPSB5RGF0YS5sZW5ndGgsXG5cdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHR0aHJlc2hvbGQgPSBzZXJpZXNPcHRpb25zLnRocmVzaG9sZCxcblx0XHRcdHN0YWNrT3B0aW9uID0gc2VyaWVzT3B0aW9ucy5zdGFjayxcblx0XHRcdHN0YWNraW5nID0gc2VyaWVzT3B0aW9ucy5zdGFja2luZyxcblx0XHRcdHN0YWNrS2V5ID0gc2VyaWVzLnN0YWNrS2V5LFxuXHRcdFx0bmVnS2V5ID0gJy0nICsgc3RhY2tLZXksXG5cdFx0XHRuZWdTdGFja3MgPSBzZXJpZXMubmVnU3RhY2tzLFxuXHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXMsXG5cdFx0XHRzdGFja3MgPSB5QXhpcy5zdGFja3MsXG5cdFx0XHRvbGRTdGFja3MgPSB5QXhpcy5vbGRTdGFja3MsXG5cdFx0XHRpc05lZ2F0aXZlLFxuXHRcdFx0c3RhY2ssXG5cdFx0XHRvdGhlcixcblx0XHRcdGtleSxcblx0XHRcdHBvaW50S2V5LFxuXHRcdFx0aSxcblx0XHRcdHgsXG5cdFx0XHR5O1xuXG5cdFx0Ly8gbG9vcCBvdmVyIHRoZSBub24tbnVsbCB5IHZhbHVlcyBhbmQgcmVhZCB0aGVtIGludG8gYSBsb2NhbCBhcnJheVxuXHRcdGZvciAoaSA9IDA7IGkgPCB5RGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHR4ID0geERhdGFbaV07XG5cdFx0XHR5ID0geURhdGFbaV07XG5cdFx0XHRwb2ludEtleSA9IHNlcmllcy5pbmRleCArICcsJyArIGk7XG5cblx0XHRcdC8vIFJlYWQgc3RhY2tlZCB2YWx1ZXMgaW50byBhIHN0YWNrIGJhc2VkIG9uIHRoZSB4IHZhbHVlLFxuXHRcdFx0Ly8gdGhlIHNpZ24gb2YgeSBhbmQgdGhlIHN0YWNrIGtleS4gU3RhY2tpbmcgaXMgYWxzbyBoYW5kbGVkIGZvciBudWxsIHZhbHVlcyAoIzczOSlcblx0XHRcdGlzTmVnYXRpdmUgPSBuZWdTdGFja3MgJiYgeSA8IHRocmVzaG9sZDtcblx0XHRcdGtleSA9IGlzTmVnYXRpdmUgPyBuZWdLZXkgOiBzdGFja0tleTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGVtcHR5IG9iamVjdCBmb3IgdGhpcyBzdGFjayBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldFxuXHRcdFx0aWYgKCFzdGFja3Nba2V5XSkge1xuXHRcdFx0XHRzdGFja3Nba2V5XSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0aWFsaXplIFN0YWNrSXRlbSBmb3IgdGhpcyB4XG5cdFx0XHRpZiAoIXN0YWNrc1trZXldW3hdKSB7XG5cdFx0XHRcdGlmIChvbGRTdGFja3Nba2V5XSAmJiBvbGRTdGFja3Nba2V5XVt4XSkge1xuXHRcdFx0XHRcdHN0YWNrc1trZXldW3hdID0gb2xkU3RhY2tzW2tleV1beF07XG5cdFx0XHRcdFx0c3RhY2tzW2tleV1beF0udG90YWwgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YWNrc1trZXldW3hdID0gbmV3IFN0YWNrSXRlbSh5QXhpcywgeUF4aXMub3B0aW9ucy5zdGFja0xhYmVscywgaXNOZWdhdGl2ZSwgeCwgc3RhY2tPcHRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBTdGFja0l0ZW0gZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0IGZpcnN0XG5cdFx0XHRzdGFjayA9IHN0YWNrc1trZXldW3hdO1xuXHRcdFx0c3RhY2sucG9pbnRzW3BvaW50S2V5XSA9IFtzdGFjay5jdW0gfHwgMF07XG5cblx0XHRcdC8vIEFkZCB2YWx1ZSB0byB0aGUgc3RhY2sgdG90YWxcblx0XHRcdGlmIChzdGFja2luZyA9PT0gJ3BlcmNlbnQnKSB7XG5cblx0XHRcdFx0Ly8gUGVyY2VudCBzdGFja2VkIGNvbHVtbiwgdG90YWxzIGFyZSB0aGUgc2FtZSBmb3IgdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBzdGFja3Ncblx0XHRcdFx0b3RoZXIgPSBpc05lZ2F0aXZlID8gc3RhY2tLZXkgOiBuZWdLZXk7XG5cdFx0XHRcdGlmIChuZWdTdGFja3MgJiYgc3RhY2tzW290aGVyXSAmJiBzdGFja3Nbb3RoZXJdW3hdKSB7XG5cdFx0XHRcdFx0b3RoZXIgPSBzdGFja3Nbb3RoZXJdW3hdO1xuXHRcdFx0XHRcdHN0YWNrLnRvdGFsID0gb3RoZXIudG90YWwgPSBtYXRoTWF4KG90aGVyLnRvdGFsLCBzdGFjay50b3RhbCkgKyBtYXRoQWJzKHkpIHx8IDA7XG5cblx0XHRcdFx0Ly8gUGVyY2VudCBzdGFja2VkIGFyZWFzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhY2sudG90YWwgPSBjb3JyZWN0RmxvYXQoc3RhY2sudG90YWwgKyAobWF0aEFicyh5KSB8fCAwKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YWNrLnRvdGFsID0gY29ycmVjdEZsb2F0KHN0YWNrLnRvdGFsICsgKHkgfHwgMCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGFjay5jdW0gPSAoc3RhY2suY3VtIHx8IDApICsgKHkgfHwgMCk7XG5cblx0XHRcdHN0YWNrLnBvaW50c1twb2ludEtleV0ucHVzaChzdGFjay5jdW0pO1xuXHRcdFx0c3RhY2tlZFlEYXRhW2ldID0gc3RhY2suY3VtO1xuXG5cdFx0fVxuXG5cdFx0aWYgKHN0YWNraW5nID09PSAncGVyY2VudCcpIHtcblx0XHRcdHlBeGlzLnVzZVBlcmNlbnRhZ2UgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RhY2tlZFlEYXRhID0gc3RhY2tlZFlEYXRhOyAvLyBUbyBiZSB1c2VkIGluIGdldEV4dHJlbWVzXG5cblx0XHQvLyBSZXNldCBvbGQgc3RhY2tzXG5cdFx0eUF4aXMub2xkU3RhY2tzID0ge307XG5cdH07XG5cblx0LyoqXG5cdCAqIEl0ZXJhdGUgb3ZlciBhbGwgc3RhY2tzIGFuZCBjb21wdXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZXMgdG8gcGVyY2VudFxuXHQgKi9cblx0U2VyaWVzLnByb3RvdHlwZS5zZXRQZXJjZW50U3RhY2tzID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0c3RhY2tLZXkgPSBzZXJpZXMuc3RhY2tLZXksXG5cdFx0XHRzdGFja3MgPSBzZXJpZXMueUF4aXMuc3RhY2tzLFxuXHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBzZXJpZXMucHJvY2Vzc2VkWERhdGE7XG5cblx0XHRlYWNoKFtzdGFja0tleSwgJy0nICsgc3RhY2tLZXldLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR2YXIgaSA9IHByb2Nlc3NlZFhEYXRhLmxlbmd0aCxcblx0XHRcdFx0eCxcblx0XHRcdFx0c3RhY2ssXG5cdFx0XHRcdHBvaW50RXh0cmVtZXMsXG5cdFx0XHRcdHRvdGFsRmFjdG9yO1xuXG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHggPSBwcm9jZXNzZWRYRGF0YVtpXTtcblx0XHRcdFx0c3RhY2sgPSBzdGFja3Nba2V5XSAmJiBzdGFja3Nba2V5XVt4XTtcblx0XHRcdFx0cG9pbnRFeHRyZW1lcyA9IHN0YWNrICYmIHN0YWNrLnBvaW50c1tzZXJpZXMuaW5kZXggKyAnLCcgKyBpXTtcblx0XHRcdFx0aWYgKHBvaW50RXh0cmVtZXMpIHtcblx0XHRcdFx0XHR0b3RhbEZhY3RvciA9IHN0YWNrLnRvdGFsID8gMTAwIC8gc3RhY2sudG90YWwgOiAwO1xuXHRcdFx0XHRcdHBvaW50RXh0cmVtZXNbMF0gPSBjb3JyZWN0RmxvYXQocG9pbnRFeHRyZW1lc1swXSAqIHRvdGFsRmFjdG9yKTsgLy8gWSBib3R0b20gdmFsdWVcblx0XHRcdFx0XHRwb2ludEV4dHJlbWVzWzFdID0gY29ycmVjdEZsb2F0KHBvaW50RXh0cmVtZXNbMV0gKiB0b3RhbEZhY3Rvcik7IC8vIFkgdmFsdWVcblx0XHRcdFx0XHRzZXJpZXMuc3RhY2tlZFlEYXRhW2ldID0gcG9pbnRFeHRyZW1lc1sxXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdC8vIEV4dGVuZCB0aGUgQ2hhcnQgcHJvdG90eXBlIGZvciBkeW5hbWljIG1ldGhvZHNcblx0ZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgc2VyaWVzIGR5bmFtaWNhbGx5IGFmdGVyICB0aW1lXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgY29uZmlnIG9wdGlvbnNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdyBXaGV0aGVyIHRvIHJlZHJhdyB0aGUgY2hhcnQgYWZ0ZXIgYWRkaW5nLiBEZWZhdWx0cyB0byB0cnVlLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdFx0ICogICAgY29uZmlndXJhdGlvblxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBzZXJpZXMgVGhlIG5ld2x5IGNyZWF0ZWQgc2VyaWVzIG9iamVjdFxuXHRcdCAqL1xuXHRcdGFkZFNlcmllczogZnVuY3Rpb24gKG9wdGlvbnMsIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc2VyaWVzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXM7XG5cblx0XHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTsgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuXG5cdFx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2FkZFNlcmllcycsIHsgb3B0aW9uczogb3B0aW9ucyB9LCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0c2VyaWVzID0gY2hhcnQuaW5pdFNlcmllcyhvcHRpb25zKTtcblxuXHRcdFx0XHRcdGNoYXJ0LmlzRGlydHlMZWdlbmQgPSB0cnVlOyAvLyB0aGUgc2VyaWVzIGFycmF5IGlzIG91dCBvZiBzeW5jIHdpdGggdGhlIGRpc3BsYXlcblx0XHRcdFx0XHRjaGFydC5saW5rU2VyaWVzKCk7XG5cdFx0XHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNlcmllcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdCAgICAgKiBBZGQgYW4gYXhpcyB0byB0aGUgY2hhcnRcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBheGlzIG9wdGlvblxuXHQgICAgICogQHBhcmFtIHtCb29sZWFufSBpc1ggV2hldGhlciBpdCBpcyBhbiBYIGF4aXMgb3IgYSB2YWx1ZSBheGlzXG5cdCAgICAgKi9cblx0XHRhZGRBeGlzOiBmdW5jdGlvbiAob3B0aW9ucywgaXNYLCByZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIGtleSA9IGlzWCA/ICd4QXhpcycgOiAneUF4aXMnLFxuXHRcdFx0XHRjaGFydE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGF4aXM7XG5cblx0XHRcdC8qanNsaW50IHVudXNlZDogZmFsc2UqL1xuXHRcdFx0YXhpcyA9IG5ldyBBeGlzKHRoaXMsIG1lcmdlKG9wdGlvbnMsIHtcblx0XHRcdFx0aW5kZXg6IHRoaXNba2V5XS5sZW5ndGgsXG5cdFx0XHRcdGlzWDogaXNYXG5cdFx0XHR9KSk7XG5cdFx0XHQvKmpzbGludCB1bnVzZWQ6IHRydWUqL1xuXG5cdFx0XHQvLyBQdXNoIHRoZSBuZXcgYXhpcyBvcHRpb25zIHRvIHRoZSBjaGFydCBvcHRpb25zXG5cdFx0XHRjaGFydE9wdGlvbnNba2V5XSA9IHNwbGF0KGNoYXJ0T3B0aW9uc1trZXldIHx8IHt9KTtcblx0XHRcdGNoYXJ0T3B0aW9uc1trZXldLnB1c2gob3B0aW9ucyk7XG5cblx0XHRcdGlmIChwaWNrKHJlZHJhdywgdHJ1ZSkpIHtcblx0XHRcdFx0dGhpcy5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGltIHRoZSBjaGFydCBhbmQgc2hvdyBhIGxvYWRpbmcgdGV4dCBvciBzeW1ib2xcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEFuIG9wdGlvbmFsIHRleHQgdG8gc2hvdyBpbiB0aGUgbG9hZGluZyBsYWJlbCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG9uZVxuXHRcdCAqL1xuXHRcdHNob3dMb2FkaW5nOiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gY2hhcnQub3B0aW9ucyxcblx0XHRcdFx0bG9hZGluZ0RpdiA9IGNoYXJ0LmxvYWRpbmdEaXYsXG5cdFx0XHRcdGxvYWRpbmdPcHRpb25zID0gb3B0aW9ucy5sb2FkaW5nLFxuXHRcdFx0XHRzZXRMb2FkaW5nU2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAobG9hZGluZ0Rpdikge1xuXHRcdFx0XHRcdFx0Y3NzKGxvYWRpbmdEaXYsIHtcblx0XHRcdFx0XHRcdFx0bGVmdDogY2hhcnQucGxvdExlZnQgKyBQWCxcblx0XHRcdFx0XHRcdFx0dG9wOiBjaGFydC5wbG90VG9wICsgUFgsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBjaGFydC5wbG90V2lkdGggKyBQWCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBjaGFydC5wbG90SGVpZ2h0ICsgUFhcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSBsYXllciBhdCB0aGUgZmlyc3QgY2FsbFxuXHRcdFx0aWYgKCFsb2FkaW5nRGl2KSB7XG5cdFx0XHRcdGNoYXJ0LmxvYWRpbmdEaXYgPSBsb2FkaW5nRGl2ID0gY3JlYXRlRWxlbWVudChESVYsIHtcblx0XHRcdFx0XHRjbGFzc05hbWU6IFBSRUZJWCArICdsb2FkaW5nJ1xuXHRcdFx0XHR9LCBleHRlbmQobG9hZGluZ09wdGlvbnMuc3R5bGUsIHtcblx0XHRcdFx0XHR6SW5kZXg6IDEwLFxuXHRcdFx0XHRcdGRpc3BsYXk6IE5PTkVcblx0XHRcdFx0fSksIGNoYXJ0LmNvbnRhaW5lcik7XG5cblx0XHRcdFx0Y2hhcnQubG9hZGluZ1NwYW4gPSBjcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdCdzcGFuJyxcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdGxvYWRpbmdPcHRpb25zLmxhYmVsU3R5bGUsXG5cdFx0XHRcdFx0bG9hZGluZ0RpdlxuXHRcdFx0XHQpO1xuXHRcdFx0XHRhZGRFdmVudChjaGFydCwgJ3JlZHJhdycsIHNldExvYWRpbmdTaXplKTsgLy8gIzEwODBcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIHRleHRcblx0XHRcdGNoYXJ0LmxvYWRpbmdTcGFuLmlubmVySFRNTCA9IHN0ciB8fCBvcHRpb25zLmxhbmcubG9hZGluZztcblxuXHRcdFx0Ly8gc2hvdyBpdFxuXHRcdFx0aWYgKCFjaGFydC5sb2FkaW5nU2hvd24pIHtcblx0XHRcdFx0Y3NzKGxvYWRpbmdEaXYsIHtcblx0XHRcdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0XHRcdGRpc3BsYXk6ICcnXHRcdFx0XHRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGFuaW1hdGUobG9hZGluZ0Rpdiwge1xuXHRcdFx0XHRcdG9wYWNpdHk6IGxvYWRpbmdPcHRpb25zLnN0eWxlLm9wYWNpdHlcblx0XHRcdFx0fSwge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiBsb2FkaW5nT3B0aW9ucy5zaG93RHVyYXRpb24gfHwgMFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2hhcnQubG9hZGluZ1Nob3duID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHNldExvYWRpbmdTaXplKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhpZGUgdGhlIGxvYWRpbmcgbGF5ZXJcblx0XHQgKi9cblx0XHRoaWRlTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGxvYWRpbmdEaXYgPSB0aGlzLmxvYWRpbmdEaXY7XG5cblx0XHRcdGlmIChsb2FkaW5nRGl2KSB7XG5cdFx0XHRcdGFuaW1hdGUobG9hZGluZ0Rpdiwge1xuXHRcdFx0XHRcdG9wYWNpdHk6IDBcblx0XHRcdFx0fSwge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmxvYWRpbmcuaGlkZUR1cmF0aW9uIHx8IDEwMCxcblx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Y3NzKGxvYWRpbmdEaXYsIHsgZGlzcGxheTogTk9ORSB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5sb2FkaW5nU2hvd24gPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIGV4dGVuZCB0aGUgUG9pbnQgcHJvdG90eXBlIGZvciBkeW5hbWljIG1ldGhvZHNcblx0ZXh0ZW5kKFBvaW50LnByb3RvdHlwZSwge1xuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgcG9pbnQgd2l0aCBuZXcgb3B0aW9ucyAodHlwaWNhbGx5IHgveSBkYXRhKSBhbmQgb3B0aW9uYWxseSByZWRyYXcgdGhlIHNlcmllcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBvaW50IG9wdGlvbnMgYXMgZGVmaW5lZCBpbiB0aGUgc2VyaWVzLmRhdGEgYXJyYXlcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdyBXaGV0aGVyIHRvIHJlZHJhdyB0aGUgY2hhcnQgb3Igd2FpdCBmb3IgYW4gZXhwbGljaXQgY2FsbFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdFx0ICogICAgY29uZmlndXJhdGlvblxuXHRcdCAqXG5cdFx0ICovXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucywgcmVkcmF3LCBhbmltYXRpb24sIHJ1bkV2ZW50KSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRuYW1lcyA9IHNlcmllcy54QXhpcyAmJiBzZXJpZXMueEF4aXMubmFtZXM7XG5cblx0XHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTtcblxuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHRcdHBvaW50LmFwcGx5T3B0aW9ucyhvcHRpb25zKTtcblxuXHRcdFx0XHQvLyBVcGRhdGUgdmlzdWFsc1xuXHRcdFx0XHRpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgIWlzQXJyYXkob3B0aW9ucykpIHtcblx0XHRcdFx0XHQvLyBEZWZlciB0aGUgYWN0dWFsIHJlZHJhdyB1bnRpbCBnZXRBdHRyaWJzIGhhcyBiZWVuIGNhbGxlZCAoIzMyNjApXG5cdFx0XHRcdFx0cG9pbnQucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKGdyYXBoaWMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXIgJiYgb3B0aW9ucy5tYXJrZXIuc3ltYm9sKSB7XG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYyA9IGdyYXBoaWMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGdyYXBoaWMuYXR0cihwb2ludC5wb2ludEF0dHJbcG9pbnQuc3RhdGUgfHwgJyddKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kYXRhTGFiZWxzICYmIHBvaW50LmRhdGFMYWJlbCkgeyAvLyAjMjQ2OFxuXHRcdFx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cG9pbnQucmVkcmF3ID0gbnVsbDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVjb3JkIGNoYW5nZXMgaW4gdGhlIHBhcmFsbGVsIGFycmF5c1xuXHRcdFx0XHRpID0gcG9pbnQuaW5kZXg7XG5cdFx0XHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwb2ludCwgaSk7XG5cdFx0XHRcdGlmIChuYW1lcyAmJiBwb2ludC5uYW1lKSB7XG5cdFx0XHRcdFx0bmFtZXNbcG9pbnQueF0gPSBwb2ludC5uYW1lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VyaWVzT3B0aW9ucy5kYXRhW2ldID0gcG9pbnQub3B0aW9ucztcblxuXHRcdFx0XHQvLyByZWRyYXdcblx0XHRcdFx0c2VyaWVzLmlzRGlydHkgPSBzZXJpZXMuaXNEaXJ0eURhdGEgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIXNlcmllcy5maXhlZEJveCAmJiBzZXJpZXMuaGFzQ2FydGVzaWFuU2VyaWVzKSB7IC8vICMxOTA2LCAjMjMyMFxuXHRcdFx0XHRcdGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNoYXJ0LmxlZ2VuZC5kaXNwbGF5ICYmIHNlcmllc09wdGlvbnMubGVnZW5kVHlwZSA9PT0gJ3BvaW50JykgeyAvLyAjMTgzMSwgIzE4ODUsICMzOTM0XG5cdFx0XHRcdFx0c2VyaWVzLnVwZGF0ZVRvdGFscygpO1xuXHRcdFx0XHRcdGNoYXJ0LmxlZ2VuZC5jbGVhckl0ZW1zKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpcmUgdGhlIGV2ZW50IHdpdGggYSBkZWZhdWx0IGhhbmRsZXIgb2YgZG9pbmcgdGhlIHVwZGF0ZVxuXHRcdFx0aWYgKHJ1bkV2ZW50ID09PSBmYWxzZSkgeyAvLyBXaGVuIGNhbGxlZCBmcm9tIHNldERhdGFcblx0XHRcdFx0dXBkYXRlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludC5maXJlUG9pbnRFdmVudCgndXBkYXRlJywgeyBvcHRpb25zOiBvcHRpb25zIH0sIHVwZGF0ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhIHBvaW50IGFuZCBvcHRpb25hbGx5IHJlZHJhdyB0aGUgc2VyaWVzIGFuZCBpZiBuZWNlc3NhcnkgdGhlIGF4ZXNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdyBXaGV0aGVyIHRvIHJlZHJhdyB0aGUgY2hhcnQgb3Igd2FpdCBmb3IgYW4gZXhwbGljaXQgY2FsbFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdFx0ICogICAgY29uZmlndXJhdGlvblxuXHRcdCAqL1xuXHRcdHJlbW92ZTogZnVuY3Rpb24gKHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0XHR0aGlzLnNlcmllcy5yZW1vdmVQb2ludChpbkFycmF5KHRoaXMsIHRoaXMuc2VyaWVzLmRhdGEpLCByZWRyYXcsIGFuaW1hdGlvbik7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBFeHRlbmQgdGhlIHNlcmllcyBwcm90b3R5cGUgZm9yIGR5bmFtaWMgbWV0aG9kc1xuXHRleHRlbmQoU2VyaWVzLnByb3RvdHlwZSwge1xuXHRcdC8qKlxuXHRcdCAqIEFkZCBhIHBvaW50IGR5bmFtaWNhbGx5IGFmdGVyIGNoYXJ0IGxvYWQgdGltZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBvaW50IG9wdGlvbnMgYXMgZ2l2ZW4gaW4gc2VyaWVzLmRhdGFcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdyBXaGV0aGVyIHRvIHJlZHJhdyB0aGUgY2hhcnQgb3Igd2FpdCBmb3IgYW4gZXhwbGljaXQgY2FsbFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hpZnQgSWYgc2hpZnQgaXMgdHJ1ZSwgYSBwb2ludCBpcyBzaGlmdGVkIG9mZiB0aGUgc3RhcnRcblx0XHQgKiAgICBvZiB0aGUgc2VyaWVzIGFzIG9uZSBpcyBhcHBlbmRlZCB0byB0aGUgZW5kLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdFx0ICogICAgY29uZmlndXJhdGlvblxuXHRcdCAqL1xuXHRcdGFkZFBvaW50OiBmdW5jdGlvbiAob3B0aW9ucywgcmVkcmF3LCBzaGlmdCwgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRkYXRhID0gc2VyaWVzLmRhdGEsXG5cdFx0XHRcdGdyYXBoID0gc2VyaWVzLmdyYXBoLFxuXHRcdFx0XHRhcmVhID0gc2VyaWVzLmFyZWEsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRuYW1lcyA9IHNlcmllcy54QXhpcyAmJiBzZXJpZXMueEF4aXMubmFtZXMsXG5cdFx0XHRcdGN1cnJlbnRTaGlmdCA9IChncmFwaCAmJiBncmFwaC5zaGlmdCkgfHwgMCxcblx0XHRcdFx0ZGF0YU9wdGlvbnMgPSBzZXJpZXNPcHRpb25zLmRhdGEsXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRpc0luVGhlTWlkZGxlLFxuXHRcdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YSxcblx0XHRcdFx0eCxcblx0XHRcdFx0aTtcblxuXHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXG5cdFx0XHQvLyBNYWtlIGdyYXBoIGFuaW1hdGUgc2lkZXdheXNcblx0XHRcdGlmIChzaGlmdCkge1xuXHRcdFx0XHRlYWNoKFtncmFwaCwgYXJlYSwgc2VyaWVzLmdyYXBoTmVnLCBzZXJpZXMuYXJlYU5lZ10sIGZ1bmN0aW9uIChzaGFwZSkge1xuXHRcdFx0XHRcdGlmIChzaGFwZSkge1xuXHRcdFx0XHRcdFx0c2hhcGUuc2hpZnQgPSBjdXJyZW50U2hpZnQgKyAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJlYSkge1xuXHRcdFx0XHRhcmVhLmlzQXJlYSA9IHRydWU7IC8vIG5lZWRlZCBpbiBhbmltYXRpb24sIGJvdGggd2l0aCBhbmQgd2l0aG91dCBzaGlmdFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcHRpb25hbCByZWRyYXcsIGRlZmF1bHRzIHRvIHRydWVcblx0XHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTtcblxuXHRcdFx0Ly8gR2V0IG9wdGlvbnMgYW5kIHB1c2ggdGhlIHBvaW50IHRvIHhEYXRhLCB5RGF0YSBhbmQgc2VyaWVzLm9wdGlvbnMuIEluIHNlcmllcy5nZW5lcmF0ZVBvaW50c1xuXHRcdFx0Ly8gdGhlIFBvaW50IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZCBvbiBkZW1hbmQgYW5kIHB1c2hlZCB0byB0aGUgc2VyaWVzLmRhdGEgYXJyYXkuXG5cdFx0XHRwb2ludCA9IHsgc2VyaWVzOiBzZXJpZXMgfTtcblx0XHRcdHNlcmllcy5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkocG9pbnQsIFtvcHRpb25zXSk7XG5cdFx0XHR4ID0gcG9pbnQueDtcblxuXHRcdFx0Ly8gR2V0IHRoZSBpbnNlcnRpb24gcG9pbnRcblx0XHRcdGkgPSB4RGF0YS5sZW5ndGg7XG5cdFx0XHRpZiAoc2VyaWVzLnJlcXVpcmVTb3J0aW5nICYmIHggPCB4RGF0YVtpIC0gMV0pIHtcblx0XHRcdFx0aXNJblRoZU1pZGRsZSA9IHRydWU7XG5cdFx0XHRcdHdoaWxlIChpICYmIHhEYXRhW2kgLSAxXSA+IHgpIHtcblx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c2VyaWVzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHBvaW50LCAnc3BsaWNlJywgaSwgMCwgMCk7IC8vIGluc2VydCB1bmRlZmluZWQgaXRlbVxuXHRcdFx0c2VyaWVzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHBvaW50LCBpKTsgLy8gdXBkYXRlIGl0XG5cblx0XHRcdGlmIChuYW1lcyAmJiBwb2ludC5uYW1lKSB7XG5cdFx0XHRcdG5hbWVzW3hdID0gcG9pbnQubmFtZTtcblx0XHRcdH1cblx0XHRcdGRhdGFPcHRpb25zLnNwbGljZShpLCAwLCBvcHRpb25zKTtcblxuXHRcdFx0aWYgKGlzSW5UaGVNaWRkbGUpIHtcblx0XHRcdFx0c2VyaWVzLmRhdGEuc3BsaWNlKGksIDAsIG51bGwpO1xuXHRcdFx0XHRzZXJpZXMucHJvY2Vzc0RhdGEoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2VuZXJhdGUgcG9pbnRzIHRvIGJlIGFkZGVkIHRvIHRoZSBsZWdlbmQgKCMxMzI5KVxuXHRcdFx0aWYgKHNlcmllc09wdGlvbnMubGVnZW5kVHlwZSA9PT0gJ3BvaW50Jykge1xuXHRcdFx0XHRzZXJpZXMuZ2VuZXJhdGVQb2ludHMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hpZnQgdGhlIGZpcnN0IHBvaW50IG9mZiB0aGUgcGFyYWxsZWwgYXJyYXlzXG5cdFx0XHQvLyB0b2RvOiBjb25zaWRlciBzZXJpZXMucmVtb3ZlUG9pbnQoaSkgbWV0aG9kXG5cdFx0XHRpZiAoc2hpZnQpIHtcblx0XHRcdFx0aWYgKGRhdGFbMF0gJiYgZGF0YVswXS5yZW1vdmUpIHtcblx0XHRcdFx0XHRkYXRhWzBdLnJlbW92ZShmYWxzZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YS5zaGlmdCgpO1xuXHRcdFx0XHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwb2ludCwgJ3NoaWZ0Jyk7XG5cblx0XHRcdFx0XHRkYXRhT3B0aW9ucy5zaGlmdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0c2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0c2VyaWVzLmlzRGlydHlEYXRhID0gdHJ1ZTtcblx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0c2VyaWVzLmdldEF0dHJpYnMoKTsgLy8gIzE5Mzdcblx0XHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhIHBvaW50IChyZW5kZXJlZCBvciBub3QpLCBieSBpbmRleFxuXHRcdCAqL1xuXHRcdHJlbW92ZVBvaW50OiBmdW5jdGlvbiAoaSwgcmVkcmF3LCBhbmltYXRpb24pIHtcblxuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdFx0cG9pbnQgPSBkYXRhW2ldLFxuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0aWYgKGRhdGEubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRwb2ludHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRzZXJpZXMudXBkYXRlUGFyYWxsZWxBcnJheXMocG9pbnQgfHwgeyBzZXJpZXM6IHNlcmllcyB9LCAnc3BsaWNlJywgaSwgMSk7XG5cblx0XHRcdFx0XHRpZiAocG9pbnQpIHtcblx0XHRcdFx0XHRcdHBvaW50LmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyByZWRyYXdcblx0XHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0c2VyaWVzLmlzRGlydHlEYXRhID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdFx0XHRjaGFydC5yZWRyYXcoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KTtcblx0XHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTtcblxuXHRcdFx0Ly8gRmlyZSB0aGUgZXZlbnQgd2l0aCBhIGRlZmF1bHQgaGFuZGxlciBvZiByZW1vdmluZyB0aGUgcG9pbnRcblx0XHRcdGlmIChwb2ludCkge1xuXHRcdFx0XHRwb2ludC5maXJlUG9pbnRFdmVudCgncmVtb3ZlJywgbnVsbCwgcmVtb3ZlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYSBzZXJpZXMgYW5kIG9wdGlvbmFsbHkgcmVkcmF3IHRoZSBjaGFydFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0IG9yIHdhaXQgZm9yIGFuIGV4cGxpY2l0IGNhbGxcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHRcdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0XHQgKi9cblxuXHRcdHJlbW92ZTogZnVuY3Rpb24gKHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHRcdGlmICghc2VyaWVzLmlzUmVtb3ZpbmcpIHsgIC8qIHByZXZlbnQgdHJpZ2dlcmluZyBuYXRpdmUgZXZlbnQgaW4galF1ZXJ5XG5cdFx0XHRcdFx0KGNhbGxpbmcgdGhlIHJlbW92ZSBmdW5jdGlvbiBmcm9tIHRoZSByZW1vdmUgZXZlbnQpICovXG5cdFx0XHRcdHNlcmllcy5pc1JlbW92aW5nID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBmaXJlIHRoZSBldmVudCB3aXRoIGEgZGVmYXVsdCBoYW5kbGVyIG9mIHJlbW92aW5nIHRoZSBwb2ludFxuXHRcdFx0XHRmaXJlRXZlbnQoc2VyaWVzLCAncmVtb3ZlJywgbnVsbCwgZnVuY3Rpb24gKCkge1xuXG5cblx0XHRcdFx0XHQvLyBkZXN0cm95IGVsZW1lbnRzXG5cdFx0XHRcdFx0c2VyaWVzLmRlc3Ryb3koKTtcblxuXG5cdFx0XHRcdFx0Ly8gcmVkcmF3XG5cdFx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUxlZ2VuZCA9IGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdFx0XHRcdGNoYXJ0LmxpbmtTZXJpZXMoKTtcblxuXHRcdFx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0XHRcdGNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdH1cblx0XHRcdHNlcmllcy5pc1JlbW92aW5nID0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgc2VyaWVzIHdpdGggYSBuZXcgc2V0IG9mIG9wdGlvbnNcblx0XHQgKi9cblx0XHR1cGRhdGU6IGZ1bmN0aW9uIChuZXdPcHRpb25zLCByZWRyYXcpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdC8vIG11c3QgdXNlIHVzZXIgb3B0aW9ucyB3aGVuIGNoYW5naW5nIHR5cGUgYmVjYXVzZSB0aGlzLm9wdGlvbnMgaXMgbWVyZ2VkXG5cdFx0XHRcdC8vIGluIHdpdGggdHlwZSBzcGVjaWZpYyBwbG90T3B0aW9uc1xuXHRcdFx0XHRvbGRPcHRpb25zID0gdGhpcy51c2VyT3B0aW9ucyxcblx0XHRcdFx0b2xkVHlwZSA9IHRoaXMudHlwZSxcblx0XHRcdFx0cHJvdG8gPSBzZXJpZXNUeXBlc1tvbGRUeXBlXS5wcm90b3R5cGUsXG5cdFx0XHRcdHByZXNlcnZlID0gWydncm91cCcsICdtYXJrZXJHcm91cCcsICdkYXRhTGFiZWxzR3JvdXAnXSxcblx0XHRcdFx0bjtcblxuXHRcdFx0Ly8gSWYgd2UncmUgY2hhbmdpbmcgdHlwZSBvciB6SW5kZXgsIGNyZWF0ZSBuZXcgZ3JvdXBzICgjMzM4MCwgIzM0MDQpXG5cdFx0XHRpZiAoKG5ld09wdGlvbnMudHlwZSAmJiBuZXdPcHRpb25zLnR5cGUgIT09IG9sZFR5cGUpIHx8IG5ld09wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHJlc2VydmUubGVuZ3RoID0gMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIGdyb3VwcyBhcmUgbm90IGRlc3Ryb3llZCAoIzMwOTQpXG5cdFx0XHRlYWNoKHByZXNlcnZlLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0XHRwcmVzZXJ2ZVtwcm9wXSA9IHNlcmllc1twcm9wXTtcblx0XHRcdFx0ZGVsZXRlIHNlcmllc1twcm9wXTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBEbyB0aGUgbWVyZ2UsIHdpdGggc29tZSBmb3JjZWQgb3B0aW9uc1xuXHRcdFx0bmV3T3B0aW9ucyA9IG1lcmdlKG9sZE9wdGlvbnMsIHtcblx0XHRcdFx0YW5pbWF0aW9uOiBmYWxzZSxcblx0XHRcdFx0aW5kZXg6IHRoaXMuaW5kZXgsXG5cdFx0XHRcdHBvaW50U3RhcnQ6IHRoaXMueERhdGFbMF0gLy8gd2hlbiB1cGRhdGluZyBhZnRlciBhZGRQb2ludFxuXHRcdFx0fSwgeyBkYXRhOiB0aGlzLm9wdGlvbnMuZGF0YSB9LCBuZXdPcHRpb25zKTtcblxuXHRcdFx0Ly8gRGVzdHJveSB0aGUgc2VyaWVzIGFuZCBkZWxldGUgYWxsIHByb3BlcnRpZXMuIFJlaW5zZXJ0IGFsbCBtZXRob2RzIFxuXHRcdFx0Ly8gYW5kIHByb3BlcnRpZXMgZnJvbSB0aGUgbmV3IHR5cGUgcHJvdG90eXBlICgjMjI3MCwgIzM3MTkpXG5cdFx0XHR0aGlzLnJlbW92ZShmYWxzZSk7XG5cdFx0XHRmb3IgKG4gaW4gcHJvdG8pIHtcblx0XHRcdFx0dGhpc1tuXSA9IFVOREVGSU5FRDtcblx0XHRcdH1cblx0XHRcdGV4dGVuZCh0aGlzLCBzZXJpZXNUeXBlc1tuZXdPcHRpb25zLnR5cGUgfHwgb2xkVHlwZV0ucHJvdG90eXBlKTtcblxuXHRcdFx0Ly8gUmUtcmVnaXN0ZXIgZ3JvdXBzICgjMzA5NClcblx0XHRcdGVhY2gocHJlc2VydmUsIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdHNlcmllc1twcm9wXSA9IHByZXNlcnZlW3Byb3BdO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuaW5pdChjaGFydCwgbmV3T3B0aW9ucyk7XG5cdFx0XHRjaGFydC5saW5rU2VyaWVzKCk7IC8vIExpbmtzIGFyZSBsb3N0IGluIHRoaXMucmVtb3ZlICgjMzAyOClcblx0XHRcdGlmIChwaWNrKHJlZHJhdywgdHJ1ZSkpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8vIEV4dGVuZCB0aGUgQXhpcy5wcm90b3R5cGUgZm9yIGR5bmFtaWMgbWV0aG9kc1xuXHRleHRlbmQoQXhpcy5wcm90b3R5cGUsIHtcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgYXhpcyB3aXRoIGEgbmV3IG9wdGlvbnMgc3RydWN0dXJlXG5cdFx0ICovXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAobmV3T3B0aW9ucywgcmVkcmF3KSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXG5cdFx0XHRuZXdPcHRpb25zID0gY2hhcnQub3B0aW9uc1t0aGlzLmNvbGxdW3RoaXMub3B0aW9ucy5pbmRleF0gPSBtZXJnZSh0aGlzLnVzZXJPcHRpb25zLCBuZXdPcHRpb25zKTtcblxuXHRcdFx0dGhpcy5kZXN0cm95KHRydWUpO1xuXHRcdFx0dGhpcy5fYWRkZWRQbG90TEIgPSBVTkRFRklORUQ7IC8vICMxNjExLCAjMjg4N1xuXG5cdFx0XHR0aGlzLmluaXQoY2hhcnQsIGV4dGVuZChuZXdPcHRpb25zLCB7IGV2ZW50czogVU5ERUZJTkVEIH0pKTtcblxuXHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHRpZiAocGljayhyZWRyYXcsIHRydWUpKSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0ICAgICAqIFJlbW92ZSB0aGUgYXhpcyBmcm9tIHRoZSBjaGFydFxuXHQgICAgICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAocmVkcmF3KSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRrZXkgPSB0aGlzLmNvbGwsIC8vIHhBeGlzIG9yIHlBeGlzXG5cdFx0XHRcdGF4aXNTZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdFx0aSA9IGF4aXNTZXJpZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBSZW1vdmUgYXNzb2NpYXRlZCBzZXJpZXMgKCMyNjg3KVxuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRpZiAoYXhpc1Nlcmllc1tpXSkge1xuXHRcdFx0XHRcdGF4aXNTZXJpZXNbaV0ucmVtb3ZlKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIGF4aXNcblx0XHRcdGVyYXNlKGNoYXJ0LmF4ZXMsIHRoaXMpO1xuXHRcdFx0ZXJhc2UoY2hhcnRba2V5XSwgdGhpcyk7XG5cdFx0XHRjaGFydC5vcHRpb25zW2tleV0uc3BsaWNlKHRoaXMub3B0aW9ucy5pbmRleCwgMSk7XG5cdFx0XHRlYWNoKGNoYXJ0W2tleV0sIGZ1bmN0aW9uIChheGlzLCBpKSB7IC8vIFJlLWluZGV4LCAjMTcwNlxuXHRcdFx0XHRheGlzLm9wdGlvbnMuaW5kZXggPSBpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXG5cdFx0XHRpZiAocGljayhyZWRyYXcsIHRydWUpKSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIGF4aXMgdGl0bGUgYnkgb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHNldFRpdGxlOiBmdW5jdGlvbiAobmV3VGl0bGVPcHRpb25zLCByZWRyYXcpIHtcblx0XHRcdHRoaXMudXBkYXRlKHsgdGl0bGU6IG5ld1RpdGxlT3B0aW9ucyB9LCByZWRyYXcpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgbmV3IGF4aXMgY2F0ZWdvcmllcyBhbmQgb3B0aW9uYWxseSByZWRyYXdcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBjYXRlZ29yaWVzXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXdcblx0XHQgKi9cblx0XHRzZXRDYXRlZ29yaWVzOiBmdW5jdGlvbiAoY2F0ZWdvcmllcywgcmVkcmF3KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZSh7IGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMgfSwgcmVkcmF3KTtcblx0XHR9XG5cblx0fSk7XG5cblxuXHQvKipcblx0ICogTGluZVNlcmllcyBvYmplY3Rcblx0ICovXG5cdHZhciBMaW5lU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzKTtcblx0c2VyaWVzVHlwZXMubGluZSA9IExpbmVTZXJpZXM7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBhcmVhXG5cdCAqL1xuXHRkZWZhdWx0UGxvdE9wdGlvbnMuYXJlYSA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zLCB7XG5cdFx0dGhyZXNob2xkOiAwXG5cdFx0Ly8gdHJhY2tCeUFyZWE6IGZhbHNlLFxuXHRcdC8vIGxpbmVDb2xvcjogbnVsbCwgLy8gb3ZlcnJpZGVzIGNvbG9yLCBidXQgbGV0cyBmaWxsQ29sb3IgYmUgdW5hbHRlcmVkXG5cdFx0Ly8gZmlsbE9wYWNpdHk6IDAuNzUsXG5cdFx0Ly8gZmlsbENvbG9yOiBudWxsXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBBcmVhU2VyaWVzIG9iamVjdFxuXHQgKi9cblx0dmFyIEFyZWFTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0XHR0eXBlOiAnYXJlYScsXG5cdFx0LyoqXG5cdFx0ICogRm9yIHN0YWNrcywgZG9uJ3Qgc3BsaXQgc2VnbWVudHMgb24gbnVsbCB2YWx1ZXMuIEluc3RlYWQsIGRyYXcgbnVsbCB2YWx1ZXMgd2l0aCBcblx0XHQgKiBubyBtYXJrZXIuIEFsc28gaW5zZXJ0IGR1bW15IHBvaW50cyBmb3IgYW55IFggcG9zaXRpb24gdGhhdCBleGlzdHMgaW4gb3RoZXIgc2VyaWVzXG5cdFx0ICogaW4gdGhlIHN0YWNrLlxuXHRcdCAqLyBcblx0XHRnZXRTZWdtZW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRcdHNlZ21lbnQgPSBbXSxcblx0XHRcdFx0a2V5cyA9IFtdLFxuXHRcdFx0XHR4QXhpcyA9IHRoaXMueEF4aXMsXG5cdFx0XHRcdHlBeGlzID0gdGhpcy55QXhpcyxcblx0XHRcdFx0c3RhY2sgPSB5QXhpcy5zdGFja3NbdGhpcy5zdGFja0tleV0sXG5cdFx0XHRcdHBvaW50TWFwID0ge30sXG5cdFx0XHRcdHBsb3RYLFxuXHRcdFx0XHRwbG90WSxcblx0XHRcdFx0cG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRcdGNvbm5lY3ROdWxscyA9IHRoaXMub3B0aW9ucy5jb25uZWN0TnVsbHMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHg7XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3RhY2tpbmcgJiYgIXRoaXMuY3JvcHBlZCkgeyAvLyBjcm9wcGVkIGNhdXNlcyBhcnRlZmFjdHMgaW4gU3RvY2ssIGFuZCBwZXJmIGlzc3VlXG5cdFx0XHRcdC8vIENyZWF0ZSBhIG1hcCB3aGVyZSB3ZSBjYW4gcXVpY2tseSBsb29rIHVwIHRoZSBwb2ludHMgYnkgdGhlaXIgWCB2YWx1ZS5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBvaW50TWFwW3BvaW50c1tpXS54XSA9IHBvaW50c1tpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNvcnQgdGhlIGtleXMgKCMxNjUxKVxuXHRcdFx0XHRmb3IgKHggaW4gc3RhY2spIHtcblx0XHRcdFx0XHRpZiAoc3RhY2tbeF0udG90YWwgIT09IG51bGwpIHsgLy8gbnVsbGVkIGFmdGVyIHN3aXRjaGluZyBiZXR3ZWVuIGdyb3VwaW5nIGFuZCBub3QgKCMxNjUxLCAjMjMzNilcblx0XHRcdFx0XHRcdGtleXMucHVzaCgreCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBhIC0gYjtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0ZWFjaChrZXlzLCBmdW5jdGlvbiAoeCkge1xuXHRcdFx0XHRcdHZhciB5ID0gMCxcblx0XHRcdFx0XHRcdHN0YWNrUG9pbnQ7XG5cblx0XHRcdFx0XHRpZiAoY29ubmVjdE51bGxzICYmICghcG9pbnRNYXBbeF0gfHwgcG9pbnRNYXBbeF0ueSA9PT0gbnVsbCkpIHsgLy8gIzE4MzZcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdC8vIFRoZSBwb2ludCBleGlzdHMsIHB1c2ggaXQgdG8gdGhlIHNlZ21lbnRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvaW50TWFwW3hdKSB7XG5cdFx0XHRcdFx0XHRzZWdtZW50LnB1c2gocG9pbnRNYXBbeF0pO1xuXG5cdFx0XHRcdFx0Ly8gVGhlcmUgaXMgbm8gcG9pbnQgZm9yIHRoaXMgWCB2YWx1ZSBpbiB0aGlzIHNlcmllcywgc28gd2UgXG5cdFx0XHRcdFx0Ly8gaW5zZXJ0IGEgZHVtbXkgcG9pbnQgaW4gb3JkZXIgZm9yIHRoZSBhcmVhcyB0byBiZSBkcmF3blxuXHRcdFx0XHRcdC8vIGNvcnJlY3RseS5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBMb29wIGRvd24gdGhlIHN0YWNrIHRvIGZpbmQgdGhlIHNlcmllcyBiZWxvdyB0aGlzIG9uZSB0aGF0IGhhc1xuXHRcdFx0XHRcdFx0Ly8gYSB2YWx1ZSAoIzE5OTEpXG5cdFx0XHRcdFx0XHRmb3IgKGkgPSBzZXJpZXMuaW5kZXg7IGkgPD0geUF4aXMuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWNrUG9pbnQgPSBzdGFja1t4XS5wb2ludHNbaSArICcsJyArIHhdO1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RhY2tQb2ludCkge1xuXHRcdFx0XHRcdFx0XHRcdHkgPSBzdGFja1BvaW50WzFdO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHBsb3RYID0geEF4aXMudHJhbnNsYXRlKHgpO1xuXHRcdFx0XHRcdFx0cGxvdFkgPSB5QXhpcy50b1BpeGVscyh5LCB0cnVlKTtcblx0XHRcdFx0XHRcdHNlZ21lbnQucHVzaCh7IFxuXHRcdFx0XHRcdFx0XHR5OiBudWxsLCBcblx0XHRcdFx0XHRcdFx0cGxvdFg6IHBsb3RYLFxuXHRcdFx0XHRcdFx0XHRjbGllbnRYOiBwbG90WCwgXG5cdFx0XHRcdFx0XHRcdHBsb3RZOiBwbG90WSwgXG5cdFx0XHRcdFx0XHRcdHlCb3R0b206IHBsb3RZLFxuXHRcdFx0XHRcdFx0XHRvbk1vdXNlT3Zlcjogbm9vcFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoc2VnbWVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFNlcmllcy5wcm90b3R5cGUuZ2V0U2VnbWVudHMuY2FsbCh0aGlzKTtcblx0XHRcdFx0c2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNlZ21lbnRzID0gc2VnbWVudHM7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBFeHRlbmQgdGhlIGJhc2UgU2VyaWVzIGdldFNlZ21lbnRQYXRoIG1ldGhvZCBieSBhZGRpbmcgdGhlIHBhdGggZm9yIHRoZSBhcmVhLlxuXHRcdCAqIFRoaXMgcGF0aCBpcyBwdXNoZWQgdG8gdGhlIHNlcmllcy5hcmVhUGF0aCBwcm9wZXJ0eS5cblx0XHQgKi9cblx0XHRnZXRTZWdtZW50UGF0aDogZnVuY3Rpb24gKHNlZ21lbnQpIHtcblx0XHRcdFxuXHRcdFx0dmFyIHNlZ21lbnRQYXRoID0gU2VyaWVzLnByb3RvdHlwZS5nZXRTZWdtZW50UGF0aC5jYWxsKHRoaXMsIHNlZ21lbnQpLCAvLyBjYWxsIGJhc2UgbWV0aG9kXG5cdFx0XHRcdGFyZWFTZWdtZW50UGF0aCA9IFtdLmNvbmNhdChzZWdtZW50UGF0aCksIC8vIHdvcmsgb24gYSBjb3B5IGZvciB0aGUgYXJlYSBwYXRoXG5cdFx0XHRcdGksXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHNlZ0xlbmd0aCA9IHNlZ21lbnRQYXRoLmxlbmd0aCxcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCA9IHRoaXMueUF4aXMuZ2V0VGhyZXNob2xkKG9wdGlvbnMudGhyZXNob2xkKSwgLy8gIzIxODFcblx0XHRcdFx0eUJvdHRvbTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlZ0xlbmd0aCA9PT0gMykgeyAvLyBmb3IgYW5pbWF0aW9uIGZyb20gMSB0byB0d28gcG9pbnRzXG5cdFx0XHRcdGFyZWFTZWdtZW50UGF0aC5wdXNoKEwsIHNlZ21lbnRQYXRoWzFdLCBzZWdtZW50UGF0aFsyXSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5zdGFja2luZyAmJiAhdGhpcy5jbG9zZWRTdGFja3MpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEZvbGxvdyBzdGFjayBiYWNrLiBUb2RvOiBpbXBsZW1lbnQgYXJlYXNwbGluZS4gQSBnZW5lcmFsIHNvbHV0aW9uIGNvdWxkIGJlIHRvIFxuXHRcdFx0XHQvLyByZXZlcnNlIHRoZSBlbnRpcmUgZ3JhcGhQYXRoIG9mIHRoZSBwcmV2aW91cyBzZXJpZXMsIHRob3VnaCBtYXkgYmUgaGFyZCB3aXRoXG5cdFx0XHRcdC8vIHNwbGluZXMgYW5kIHdpdGggc2VyaWVzIHdpdGggZGlmZmVyZW50IGV4dHJlbWVzXG5cdFx0XHRcdGZvciAoaSA9IHNlZ21lbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblxuXHRcdFx0XHRcdHlCb3R0b20gPSBwaWNrKHNlZ21lbnRbaV0ueUJvdHRvbSwgdHJhbnNsYXRlZFRocmVzaG9sZCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdC8vIHN0ZXAgbGluZT9cblx0XHRcdFx0XHRpZiAoaSA8IHNlZ21lbnQubGVuZ3RoIC0gMSAmJiBvcHRpb25zLnN0ZXApIHtcblx0XHRcdFx0XHRcdGFyZWFTZWdtZW50UGF0aC5wdXNoKHNlZ21lbnRbaSArIDFdLnBsb3RYLCB5Qm90dG9tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YXJlYVNlZ21lbnRQYXRoLnB1c2goc2VnbWVudFtpXS5wbG90WCwgeUJvdHRvbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHsgLy8gZm9sbG93IHplcm8gbGluZSBiYWNrXG5cdFx0XHRcdHRoaXMuY2xvc2VTZWdtZW50KGFyZWFTZWdtZW50UGF0aCwgc2VnbWVudCwgdHJhbnNsYXRlZFRocmVzaG9sZCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFyZWFQYXRoID0gdGhpcy5hcmVhUGF0aC5jb25jYXQoYXJlYVNlZ21lbnRQYXRoKTtcblx0XHRcdHJldHVybiBzZWdtZW50UGF0aDtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZGFibGUgbWV0aG9kIHRvIGNsb3NlIHRoZSBzZWdtZW50IHBhdGggb2YgYW4gYXJlYS4gVGhpcyBpcyBvdmVycmlkZGVuIGluIHBvbGFyIFxuXHRcdCAqIGNoYXJ0cy5cblx0XHQgKi9cblx0XHRjbG9zZVNlZ21lbnQ6IGZ1bmN0aW9uIChwYXRoLCBzZWdtZW50LCB0cmFuc2xhdGVkVGhyZXNob2xkKSB7XG5cdFx0XHRwYXRoLnB1c2goXG5cdFx0XHRcdEwsXG5cdFx0XHRcdHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSAxXS5wbG90WCxcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCxcblx0XHRcdFx0TCxcblx0XHRcdFx0c2VnbWVudFswXS5wbG90WCxcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZFxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERyYXcgdGhlIGdyYXBoIGFuZCB0aGUgdW5kZXJseWluZyBhcmVhLiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgU2VyaWVzIGJhc2Vcblx0XHQgKiBmdW5jdGlvbiBhbmQgYWRkcyB0aGUgYXJlYS4gVGhlIGFyZWFQYXRoIGlzIGNhbGN1bGF0ZWQgaW4gdGhlIGdldFNlZ21lbnRQYXRoXG5cdFx0ICogbWV0aG9kIGNhbGxlZCBmcm9tIFNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoLlxuXHRcdCAqL1xuXHRcdGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XG5cdFx0XHQvLyBEZWZpbmUgb3IgcmVzZXQgYXJlYVBhdGhcblx0XHRcdHRoaXMuYXJlYVBhdGggPSBbXTtcblx0XHRcdFxuXHRcdFx0Ly8gQ2FsbCB0aGUgYmFzZSBtZXRob2Rcblx0XHRcdFNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoLmFwcGx5KHRoaXMpO1xuXHRcdFx0XG5cdFx0XHQvLyBEZWZpbmUgbG9jYWwgdmFyaWFibGVzXG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0YXJlYVBhdGggPSB0aGlzLmFyZWFQYXRoLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR6b25lcyA9IHRoaXMuem9uZXMsXG5cdFx0XHRcdHByb3BzID0gW1snYXJlYScsIHRoaXMuY29sb3IsIG9wdGlvbnMuZmlsbENvbG9yXV07IC8vIGFyZWEgbmFtZSwgbWFpbiBjb2xvciwgZmlsbCBjb2xvclxuXHRcdFx0XG5cdFx0XHRlYWNoKHpvbmVzLCBmdW5jdGlvbiAodGhyZXNob2xkLCBpKSB7XG5cdFx0XHRcdHByb3BzLnB1c2goWydjb2xvckFyZWEnICsgaSwgdGhyZXNob2xkLmNvbG9yIHx8IHNlcmllcy5jb2xvciwgdGhyZXNob2xkLmZpbGxDb2xvciB8fCBvcHRpb25zLmZpbGxDb2xvcl0pO1xuXHRcdFx0fSk7XG5cdFx0XHRlYWNoKHByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0XHR2YXIgYXJlYUtleSA9IHByb3BbMF0sXG5cdFx0XHRcdFx0YXJlYSA9IHNlcmllc1thcmVhS2V5XTtcblx0XHRcdFx0XHRcblx0XHRcdFx0Ly8gQ3JlYXRlIG9yIHVwZGF0ZSB0aGUgYXJlYVxuXHRcdFx0XHRpZiAoYXJlYSkgeyAvLyB1cGRhdGVcblx0XHRcdFx0XHRhcmVhLmFuaW1hdGUoeyBkOiBhcmVhUGF0aCB9KTtcblx0XHRcblx0XHRcdFx0fSBlbHNlIHsgLy8gY3JlYXRlXG5cdFx0XHRcdFx0c2VyaWVzW2FyZWFLZXldID0gc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoYXJlYVBhdGgpXG5cdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdGZpbGw6IHBpY2soXG5cdFx0XHRcdFx0XHRcdFx0cHJvcFsyXSxcblx0XHRcdFx0XHRcdFx0XHRDb2xvcihwcm9wWzFdKS5zZXRPcGFjaXR5KHBpY2sob3B0aW9ucy5maWxsT3BhY2l0eSwgMC43NSkpLmdldCgpXG5cdFx0XHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0XHRcdHpJbmRleDogMCAvLyAjMTA2OVxuXHRcdFx0XHRcdFx0fSkuYWRkKHNlcmllcy5ncm91cCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlXG5cdH0pO1xuXG5cdHNlcmllc1R5cGVzLmFyZWEgPSBBcmVhU2VyaWVzO1xuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHNwbGluZVxuXHQgKi9cblx0ZGVmYXVsdFBsb3RPcHRpb25zLnNwbGluZSA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zKTtcblxuXHQvKipcblx0ICogU3BsaW5lU2VyaWVzIG9iamVjdFxuXHQgKi9cblx0dmFyIFNwbGluZVNlcmllcyA9IGV4dGVuZENsYXNzKFNlcmllcywge1xuXHRcdHR5cGU6ICdzcGxpbmUnLFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBzcGxpbmUgc2VnbWVudCBmcm9tIGEgZ2l2ZW4gcG9pbnQncyBwcmV2aW91cyBuZWlnaGJvdXIgdG8gdGhlIGdpdmVuIHBvaW50XG5cdFx0ICovXG5cdFx0Z2V0UG9pbnRTcGxpbmU6IGZ1bmN0aW9uIChzZWdtZW50LCBwb2ludCwgaSkge1xuXHRcdFx0dmFyIHNtb290aGluZyA9IDEuNSwgLy8gMSBtZWFucyBjb250cm9sIHBvaW50cyBtaWR3YXkgYmV0d2VlbiBwb2ludHMsIDIgbWVhbnMgMS8zIGZyb20gdGhlIHBvaW50LCAzIGlzIDEvNCBldGNcblx0XHRcdFx0ZGVub20gPSBzbW9vdGhpbmcgKyAxLFxuXHRcdFx0XHRwbG90WCA9IHBvaW50LnBsb3RYLFxuXHRcdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZLFxuXHRcdFx0XHRsYXN0UG9pbnQgPSBzZWdtZW50W2kgLSAxXSxcblx0XHRcdFx0bmV4dFBvaW50ID0gc2VnbWVudFtpICsgMV0sXG5cdFx0XHRcdGxlZnRDb250WCxcblx0XHRcdFx0bGVmdENvbnRZLFxuXHRcdFx0XHRyaWdodENvbnRYLFxuXHRcdFx0XHRyaWdodENvbnRZLFxuXHRcdFx0XHRyZXQ7XG5cblx0XHRcdC8vIGZpbmQgY29udHJvbCBwb2ludHNcblx0XHRcdGlmIChsYXN0UG9pbnQgJiYgbmV4dFBvaW50KSB7XG5cdFx0XHRcblx0XHRcdFx0dmFyIGxhc3RYID0gbGFzdFBvaW50LnBsb3RYLFxuXHRcdFx0XHRcdGxhc3RZID0gbGFzdFBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdG5leHRYID0gbmV4dFBvaW50LnBsb3RYLFxuXHRcdFx0XHRcdG5leHRZID0gbmV4dFBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdGNvcnJlY3Rpb247XG5cblx0XHRcdFx0bGVmdENvbnRYID0gKHNtb290aGluZyAqIHBsb3RYICsgbGFzdFgpIC8gZGVub207XG5cdFx0XHRcdGxlZnRDb250WSA9IChzbW9vdGhpbmcgKiBwbG90WSArIGxhc3RZKSAvIGRlbm9tO1xuXHRcdFx0XHRyaWdodENvbnRYID0gKHNtb290aGluZyAqIHBsb3RYICsgbmV4dFgpIC8gZGVub207XG5cdFx0XHRcdHJpZ2h0Q29udFkgPSAoc21vb3RoaW5nICogcGxvdFkgKyBuZXh0WSkgLyBkZW5vbTtcblxuXHRcdFx0XHQvLyBoYXZlIHRoZSB0d28gY29udHJvbCBwb2ludHMgbWFrZSBhIHN0cmFpZ2h0IGxpbmUgdGhyb3VnaCBtYWluIHBvaW50XG5cdFx0XHRcdGNvcnJlY3Rpb24gPSAoKHJpZ2h0Q29udFkgLSBsZWZ0Q29udFkpICogKHJpZ2h0Q29udFggLSBwbG90WCkpIC9cblx0XHRcdFx0XHQocmlnaHRDb250WCAtIGxlZnRDb250WCkgKyBwbG90WSAtIHJpZ2h0Q29udFk7XG5cblx0XHRcdFx0bGVmdENvbnRZICs9IGNvcnJlY3Rpb247XG5cdFx0XHRcdHJpZ2h0Q29udFkgKz0gY29ycmVjdGlvbjtcblxuXHRcdFx0XHQvLyB0byBwcmV2ZW50IGZhbHNlIGV4dHJlbWVzLCBjaGVjayB0aGF0IGNvbnRyb2wgcG9pbnRzIGFyZSBiZXR3ZWVuXG5cdFx0XHRcdC8vIG5laWdoYm91cmluZyBwb2ludHMnIHkgdmFsdWVzXG5cdFx0XHRcdGlmIChsZWZ0Q29udFkgPiBsYXN0WSAmJiBsZWZ0Q29udFkgPiBwbG90WSkge1xuXHRcdFx0XHRcdGxlZnRDb250WSA9IG1hdGhNYXgobGFzdFksIHBsb3RZKTtcblx0XHRcdFx0XHRyaWdodENvbnRZID0gMiAqIHBsb3RZIC0gbGVmdENvbnRZOyAvLyBtaXJyb3Igb2YgbGVmdCBjb250cm9sIHBvaW50XG5cdFx0XHRcdH0gZWxzZSBpZiAobGVmdENvbnRZIDwgbGFzdFkgJiYgbGVmdENvbnRZIDwgcGxvdFkpIHtcblx0XHRcdFx0XHRsZWZ0Q29udFkgPSBtYXRoTWluKGxhc3RZLCBwbG90WSk7XG5cdFx0XHRcdFx0cmlnaHRDb250WSA9IDIgKiBwbG90WSAtIGxlZnRDb250WTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmlnaHRDb250WSA+IG5leHRZICYmIHJpZ2h0Q29udFkgPiBwbG90WSkge1xuXHRcdFx0XHRcdHJpZ2h0Q29udFkgPSBtYXRoTWF4KG5leHRZLCBwbG90WSk7XG5cdFx0XHRcdFx0bGVmdENvbnRZID0gMiAqIHBsb3RZIC0gcmlnaHRDb250WTtcblx0XHRcdFx0fSBlbHNlIGlmIChyaWdodENvbnRZIDwgbmV4dFkgJiYgcmlnaHRDb250WSA8IHBsb3RZKSB7XG5cdFx0XHRcdFx0cmlnaHRDb250WSA9IG1hdGhNaW4obmV4dFksIHBsb3RZKTtcblx0XHRcdFx0XHRsZWZ0Q29udFkgPSAyICogcGxvdFkgLSByaWdodENvbnRZO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVjb3JkIGZvciBkcmF3aW5nIGluIG5leHQgcG9pbnRcblx0XHRcdFx0cG9pbnQucmlnaHRDb250WCA9IHJpZ2h0Q29udFg7XG5cdFx0XHRcdHBvaW50LnJpZ2h0Q29udFkgPSByaWdodENvbnRZO1xuXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFZpc3VhbGl6ZSBjb250cm9sIHBvaW50cyBmb3IgZGVidWdnaW5nXG5cdFx0XHQvKlxuXHRcdFx0aWYgKGxlZnRDb250WCkge1xuXHRcdFx0XHR0aGlzLmNoYXJ0LnJlbmRlcmVyLmNpcmNsZShsZWZ0Q29udFggKyB0aGlzLmNoYXJ0LnBsb3RMZWZ0LCBsZWZ0Q29udFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3AsIDIpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0c3Ryb2tlOiAncmVkJyxcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiAxLFxuXHRcdFx0XHRcdFx0ZmlsbDogJ25vbmUnXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdHRoaXMuY2hhcnQucmVuZGVyZXIucGF0aChbJ00nLCBsZWZ0Q29udFggKyB0aGlzLmNoYXJ0LnBsb3RMZWZ0LCBsZWZ0Q29udFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdFx0J0wnLCBwbG90WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHBsb3RZICsgdGhpcy5jaGFydC5wbG90VG9wXSlcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6ICdyZWQnLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDFcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0dGhpcy5jaGFydC5yZW5kZXJlci5jaXJjbGUocmlnaHRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHJpZ2h0Q29udFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3AsIDIpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0c3Ryb2tlOiAnZ3JlZW4nLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDEsXG5cdFx0XHRcdFx0XHRmaWxsOiAnbm9uZSdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0dGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKFsnTScsIHJpZ2h0Q29udFggKyB0aGlzLmNoYXJ0LnBsb3RMZWZ0LCByaWdodENvbnRZICsgdGhpcy5jaGFydC5wbG90VG9wLFxuXHRcdFx0XHRcdCdMJywgcGxvdFggKyB0aGlzLmNoYXJ0LnBsb3RMZWZ0LCBwbG90WSArIHRoaXMuY2hhcnQucGxvdFRvcF0pXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0c3Ryb2tlOiAnZ3JlZW4nLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDFcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdH1cblx0XHRcdCovXG5cblx0XHRcdC8vIG1vdmVUbyBvciBsaW5lVG9cblx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRyZXQgPSBbTSwgcGxvdFgsIHBsb3RZXTtcblx0XHRcdH0gZWxzZSB7IC8vIGN1cnZlIGZyb20gbGFzdCBwb2ludCB0byB0aGlzXG5cdFx0XHRcdHJldCA9IFtcblx0XHRcdFx0XHQnQycsXG5cdFx0XHRcdFx0bGFzdFBvaW50LnJpZ2h0Q29udFggfHwgbGFzdFBvaW50LnBsb3RYLFxuXHRcdFx0XHRcdGxhc3RQb2ludC5yaWdodENvbnRZIHx8IGxhc3RQb2ludC5wbG90WSxcblx0XHRcdFx0XHRsZWZ0Q29udFggfHwgcGxvdFgsXG5cdFx0XHRcdFx0bGVmdENvbnRZIHx8IHBsb3RZLFxuXHRcdFx0XHRcdHBsb3RYLFxuXHRcdFx0XHRcdHBsb3RZXG5cdFx0XHRcdF07XG5cdFx0XHRcdGxhc3RQb2ludC5yaWdodENvbnRYID0gbGFzdFBvaW50LnJpZ2h0Q29udFkgPSBudWxsOyAvLyByZXNldCBmb3IgdXBkYXRpbmcgc2VyaWVzIGxhdGVyXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fSk7XG5cdHNlcmllc1R5cGVzLnNwbGluZSA9IFNwbGluZVNlcmllcztcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFyZWFzcGxpbmVcblx0ICovXG5cdGRlZmF1bHRQbG90T3B0aW9ucy5hcmVhc3BsaW5lID0gbWVyZ2UoZGVmYXVsdFBsb3RPcHRpb25zLmFyZWEpO1xuXG5cdC8qKlxuXHQgKiBBcmVhU3BsaW5lU2VyaWVzIG9iamVjdFxuXHQgKi9cblx0dmFyIGFyZWFQcm90byA9IEFyZWFTZXJpZXMucHJvdG90eXBlLFxuXHRcdEFyZWFTcGxpbmVTZXJpZXMgPSBleHRlbmRDbGFzcyhTcGxpbmVTZXJpZXMsIHtcblx0XHRcdHR5cGU6ICdhcmVhc3BsaW5lJyxcblx0XHRcdGNsb3NlZFN0YWNrczogdHJ1ZSwgLy8gaW5zdGVhZCBvZiBmb2xsb3dpbmcgdGhlIHByZXZpb3VzIGdyYXBoIGJhY2ssIGZvbGxvdyB0aGUgdGhyZXNob2xkIGJhY2tcblx0XHRcdFxuXHRcdFx0Ly8gTWl4IGluIG1ldGhvZHMgZnJvbSB0aGUgYXJlYSBzZXJpZXNcblx0XHRcdGdldFNlZ21lbnRQYXRoOiBhcmVhUHJvdG8uZ2V0U2VnbWVudFBhdGgsXG5cdFx0XHRjbG9zZVNlZ21lbnQ6IGFyZWFQcm90by5jbG9zZVNlZ21lbnQsXG5cdFx0XHRkcmF3R3JhcGg6IGFyZWFQcm90by5kcmF3R3JhcGgsXG5cdFx0XHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlXG5cdFx0fSk7XG5cblx0c2VyaWVzVHlwZXMuYXJlYXNwbGluZSA9IEFyZWFTcGxpbmVTZXJpZXM7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBjb2x1bW5cblx0ICovXG5cdGRlZmF1bHRQbG90T3B0aW9ucy5jb2x1bW4gPSBtZXJnZShkZWZhdWx0U2VyaWVzT3B0aW9ucywge1xuXHRcdGJvcmRlckNvbG9yOiAnI0ZGRkZGRicsXG5cdFx0Ly9ib3JkZXJXaWR0aDogMSxcblx0XHRib3JkZXJSYWRpdXM6IDAsXG5cdFx0Ly9jb2xvckJ5UG9pbnQ6IHVuZGVmaW5lZCxcblx0XHRncm91cFBhZGRpbmc6IDAuMixcblx0XHQvL2dyb3VwaW5nOiB0cnVlLFxuXHRcdG1hcmtlcjogbnVsbCwgLy8gcG9pbnQgb3B0aW9ucyBhcmUgc3BlY2lmaWVkIGluIHRoZSBiYXNlIG9wdGlvbnNcblx0XHRwb2ludFBhZGRpbmc6IDAuMSxcblx0XHQvL3BvaW50V2lkdGg6IG51bGwsXG5cdFx0bWluUG9pbnRMZW5ndGg6IDAsXG5cdFx0Y3JvcFRocmVzaG9sZDogNTAsIC8vIHdoZW4gdGhlcmUgYXJlIG1vcmUgcG9pbnRzLCB0aGV5IHdpbGwgbm90IGFuaW1hdGUgb3V0IG9mIHRoZSBjaGFydCBvbiB4QXhpcy5zZXRFeHRyZW1lc1xuXHRcdHBvaW50UmFuZ2U6IG51bGwsIC8vIG51bGwgbWVhbnMgYXV0bywgbWVhbmluZyAxIGluIGEgY2F0ZWdvcml6ZWQgYXhpcyBhbmQgbGVhc3QgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgaWYgbm90IGNhdGVnb3JpZXNcblx0XHRzdGF0ZXM6IHtcblx0XHRcdGhvdmVyOiB7XG5cdFx0XHRcdGJyaWdodG5lc3M6IDAuMSxcblx0XHRcdFx0c2hhZG93OiBmYWxzZSxcblx0XHRcdFx0aGFsbzogZmFsc2Vcblx0XHRcdH0sXG5cdFx0XHRzZWxlY3Q6IHtcblx0XHRcdFx0Y29sb3I6ICcjQzBDMEMwJyxcblx0XHRcdFx0Ym9yZGVyQ29sb3I6ICcjMDAwMDAwJyxcblx0XHRcdFx0c2hhZG93OiBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGF0YUxhYmVsczoge1xuXHRcdFx0YWxpZ246IG51bGwsIC8vIGF1dG9cblx0XHRcdHZlcnRpY2FsQWxpZ246IG51bGwsIC8vIGF1dG9cblx0XHRcdHk6IG51bGxcblx0XHR9LFxuXHRcdHN0aWNreVRyYWNraW5nOiBmYWxzZSxcblx0XHR0b29sdGlwOiB7XG5cdFx0XHRkaXN0YW5jZTogNlxuXHRcdH0sXG5cdFx0dGhyZXNob2xkOiAwXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBDb2x1bW5TZXJpZXMgb2JqZWN0XG5cdCAqL1xuXHR2YXIgQ29sdW1uU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzLCB7XG5cdFx0dHlwZTogJ2NvbHVtbicsXG5cdFx0cG9pbnRBdHRyVG9PcHRpb25zOiB7IC8vIG1hcHBpbmcgYmV0d2VlbiBTVkcgYXR0cmlidXRlcyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW9uc1xuXHRcdFx0c3Ryb2tlOiAnYm9yZGVyQ29sb3InLFxuXHRcdFx0ZmlsbDogJ2NvbG9yJyxcblx0XHRcdHI6ICdib3JkZXJSYWRpdXMnXG5cdFx0fSxcblx0XHRjcm9wU2hvdWxkZXI6IDAsXG5cdFx0ZGlyZWN0VG91Y2g6IHRydWUsIC8vIFdoZW4gdG9vbHRpcCBpcyBub3Qgc2hhcmVkLCB0aGlzIHNlcmllcyAoYW5kIGRlcml2YXRpdmVzKSByZXF1aXJlcyBkaXJlY3QgdG91Y2gvaG92ZXIuIEtELXRyZWUgZG9lcyBub3QgYXBwbHkuXG5cdFx0dHJhY2tlckdyb3VwczogWydncm91cCcsICdkYXRhTGFiZWxzR3JvdXAnXSxcblx0XHRuZWdTdGFja3M6IHRydWUsIC8vIHVzZSBzZXBhcmF0ZSBuZWdhdGl2ZSBzdGFja3MsIHVubGlrZSBhcmVhIHN0YWNrcyB3aGVyZSBhIG5lZ2F0aXZlIFxuXHRcdFx0Ly8gcG9pbnQgaXMgc3Vic3RyYWN0ZWQgZnJvbSBwcmV2aW91cyAoIzE5MTApXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSB0aGUgc2VyaWVzXG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblxuXHRcdFx0Ly8gaWYgdGhlIHNlcmllcyBpcyBhZGRlZCBkeW5hbWljYWxseSwgZm9yY2UgcmVkcmF3IG9mIG90aGVyXG5cdFx0XHQvLyBzZXJpZXMgYWZmZWN0ZWQgYnkgYSBuZXcgY29sdW1uXG5cdFx0XHRpZiAoY2hhcnQuaGFzUmVuZGVyZWQpIHtcblx0XHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRcdGlmIChvdGhlclNlcmllcy50eXBlID09PSBzZXJpZXMudHlwZSkge1xuXHRcdFx0XHRcdFx0b3RoZXJTZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSB3aWR0aCBhbmQgeCBvZmZzZXQgb2YgdGhlIGNvbHVtbnMgYWRqdXN0ZWQgZm9yIGdyb3VwaW5nLCBncm91cFBhZGRpbmcsIHBvaW50UGFkZGluZyxcblx0XHQgKiBwb2ludFdpZHRoIGV0Yy4gXG5cdFx0ICovXG5cdFx0Z2V0Q29sdW1uTWV0cmljczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXMsXG5cdFx0XHRcdHJldmVyc2VkWEF4aXMgPSB4QXhpcy5yZXZlcnNlZCxcblx0XHRcdFx0c3RhY2tLZXksXG5cdFx0XHRcdHN0YWNrR3JvdXBzID0ge30sXG5cdFx0XHRcdGNvbHVtbkluZGV4LFxuXHRcdFx0XHRjb2x1bW5Db3VudCA9IDA7XG5cblx0XHRcdC8vIEdldCB0aGUgdG90YWwgbnVtYmVyIG9mIGNvbHVtbiB0eXBlIHNlcmllcy5cblx0XHRcdC8vIFRoaXMgaXMgY2FsbGVkIG9uIGV2ZXJ5IHNlcmllcy4gQ29uc2lkZXIgbW92aW5nIHRoaXMgbG9naWMgdG8gYVxuXHRcdFx0Ly8gY2hhcnQub3JkZXJTdGFja3MoKSBmdW5jdGlvbiBhbmQgY2FsbCBpdCBvbiBpbml0LCBhZGRTZXJpZXMgYW5kIHJlbW92ZVNlcmllc1xuXHRcdFx0aWYgKG9wdGlvbnMuZ3JvdXBpbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGNvbHVtbkNvdW50ID0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVhY2goc2VyaWVzLmNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKG90aGVyU2VyaWVzKSB7XG5cdFx0XHRcdFx0dmFyIG90aGVyT3B0aW9ucyA9IG90aGVyU2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdFx0XHRvdGhlcllBeGlzID0gb3RoZXJTZXJpZXMueUF4aXM7XG5cdFx0XHRcdFx0aWYgKG90aGVyU2VyaWVzLnR5cGUgPT09IHNlcmllcy50eXBlICYmIG90aGVyU2VyaWVzLnZpc2libGUgJiZcblx0XHRcdFx0XHRcdFx0eUF4aXMubGVuID09PSBvdGhlcllBeGlzLmxlbiAmJiB5QXhpcy5wb3MgPT09IG90aGVyWUF4aXMucG9zKSB7ICAvLyAjNjQyLCAjMjA4NlxuXHRcdFx0XHRcdFx0aWYgKG90aGVyT3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0XHRcdFx0XHRzdGFja0tleSA9IG90aGVyU2VyaWVzLnN0YWNrS2V5O1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RhY2tHcm91cHNbc3RhY2tLZXldID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdFx0XHRzdGFja0dyb3Vwc1tzdGFja0tleV0gPSBjb2x1bW5Db3VudCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbHVtbkluZGV4ID0gc3RhY2tHcm91cHNbc3RhY2tLZXldO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChvdGhlck9wdGlvbnMuZ3JvdXBpbmcgIT09IGZhbHNlKSB7IC8vICMxMTYyXG5cdFx0XHRcdFx0XHRcdGNvbHVtbkluZGV4ID0gY29sdW1uQ291bnQrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG90aGVyU2VyaWVzLmNvbHVtbkluZGV4ID0gY29sdW1uSW5kZXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNhdGVnb3J5V2lkdGggPSBtYXRoTWluKFxuXHRcdFx0XHRcdG1hdGhBYnMoeEF4aXMudHJhbnNBKSAqICh4QXhpcy5vcmRpbmFsU2xvcGUgfHwgb3B0aW9ucy5wb2ludFJhbmdlIHx8IHhBeGlzLmNsb3Nlc3RQb2ludFJhbmdlIHx8IHhBeGlzLnRpY2tJbnRlcnZhbCB8fCAxKSwgLy8gIzI2MTBcblx0XHRcdFx0XHR4QXhpcy5sZW4gLy8gIzE1MzVcblx0XHRcdFx0KSxcblx0XHRcdFx0Z3JvdXBQYWRkaW5nID0gY2F0ZWdvcnlXaWR0aCAqIG9wdGlvbnMuZ3JvdXBQYWRkaW5nLFxuXHRcdFx0XHRncm91cFdpZHRoID0gY2F0ZWdvcnlXaWR0aCAtIDIgKiBncm91cFBhZGRpbmcsXG5cdFx0XHRcdHBvaW50T2Zmc2V0V2lkdGggPSBncm91cFdpZHRoIC8gY29sdW1uQ291bnQsXG5cdFx0XHRcdG9wdGlvblBvaW50V2lkdGggPSBvcHRpb25zLnBvaW50V2lkdGgsXG5cdFx0XHRcdHBvaW50UGFkZGluZyA9IGRlZmluZWQob3B0aW9uUG9pbnRXaWR0aCkgPyAocG9pbnRPZmZzZXRXaWR0aCAtIG9wdGlvblBvaW50V2lkdGgpIC8gMiA6XG5cdFx0XHRcdFx0cG9pbnRPZmZzZXRXaWR0aCAqIG9wdGlvbnMucG9pbnRQYWRkaW5nLFxuXHRcdFx0XHRwb2ludFdpZHRoID0gcGljayhvcHRpb25Qb2ludFdpZHRoLCBwb2ludE9mZnNldFdpZHRoIC0gMiAqIHBvaW50UGFkZGluZyksIC8vIGV4YWN0IHBvaW50IHdpZHRoLCB1c2VkIGluIHBvbGFyIGNoYXJ0c1xuXHRcdFx0XHRjb2xJbmRleCA9IChyZXZlcnNlZFhBeGlzID8gXG5cdFx0XHRcdFx0Y29sdW1uQ291bnQgLSAoc2VyaWVzLmNvbHVtbkluZGV4IHx8IDApIDogLy8gIzEyNTFcblx0XHRcdFx0XHRzZXJpZXMuY29sdW1uSW5kZXgpIHx8IDAsXG5cdFx0XHRcdHBvaW50WE9mZnNldCA9IHBvaW50UGFkZGluZyArIChncm91cFBhZGRpbmcgKyBjb2xJbmRleCAqXG5cdFx0XHRcdFx0cG9pbnRPZmZzZXRXaWR0aCAtIChjYXRlZ29yeVdpZHRoIC8gMikpICpcblx0XHRcdFx0XHQocmV2ZXJzZWRYQXhpcyA/IC0xIDogMSk7XG5cblx0XHRcdC8vIFNhdmUgaXQgZm9yIHJlYWRpbmcgaW4gbGlua2VkIHNlcmllcyAoRXJyb3IgYmFycyBwYXJ0aWN1bGFybHkpXG5cdFx0XHRyZXR1cm4gKHNlcmllcy5jb2x1bW5NZXRyaWNzID0geyBcblx0XHRcdFx0d2lkdGg6IHBvaW50V2lkdGgsIFxuXHRcdFx0XHRvZmZzZXQ6IHBvaW50WE9mZnNldCBcblx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNsYXRlIGVhY2ggcG9pbnQgdG8gdGhlIHBsb3QgYXJlYSBjb29yZGluYXRlIHN5c3RlbSBhbmQgZmluZCBzaGFwZSBwb3NpdGlvbnNcblx0XHQgKi9cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRib3JkZXJXaWR0aCA9IHNlcmllcy5ib3JkZXJXaWR0aCA9IHBpY2soXG5cdFx0XHRcdFx0b3B0aW9ucy5ib3JkZXJXaWR0aCwgXG5cdFx0XHRcdFx0c2VyaWVzLmNsb3Nlc3RQb2ludFJhbmdlICogc2VyaWVzLnhBeGlzLnRyYW5zQSA8IDIgPyAwIDogMSAvLyAjMzYzNVxuXHRcdFx0XHQpLFxuXHRcdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdFx0dGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQsXG5cdFx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQgPSBzZXJpZXMudHJhbnNsYXRlZFRocmVzaG9sZCA9IHlBeGlzLmdldFRocmVzaG9sZCh0aHJlc2hvbGQpLFxuXHRcdFx0XHRtaW5Qb2ludExlbmd0aCA9IHBpY2sob3B0aW9ucy5taW5Qb2ludExlbmd0aCwgNSksXG5cdFx0XHRcdG1ldHJpY3MgPSBzZXJpZXMuZ2V0Q29sdW1uTWV0cmljcygpLFxuXHRcdFx0XHRwb2ludFdpZHRoID0gbWV0cmljcy53aWR0aCxcblx0XHRcdFx0c2VyaWVzQmFyVyA9IHNlcmllcy5iYXJXID0gbWF0aE1heChwb2ludFdpZHRoLCAxICsgMiAqIGJvcmRlcldpZHRoKSwgLy8gcG9zdHByb2Nlc3NlZCBmb3IgYm9yZGVyIHdpZHRoXG5cdFx0XHRcdHBvaW50WE9mZnNldCA9IHNlcmllcy5wb2ludFhPZmZzZXQgPSBtZXRyaWNzLm9mZnNldCxcblx0XHRcdFx0eENyaXNwID0gLShib3JkZXJXaWR0aCAlIDIgPyAwLjUgOiAwKSxcblx0XHRcdFx0eUNyaXNwID0gYm9yZGVyV2lkdGggJSAyID8gMC41IDogMTtcblxuXHRcdFx0aWYgKGNoYXJ0LnJlbmRlcmVyLmlzVk1MICYmIGNoYXJ0LmludmVydGVkKSB7XG5cdFx0XHRcdHlDcmlzcCArPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXaGVuIHRoZSBwb2ludFBhZGRpbmcgaXMgMCwgd2Ugd2FudCB0aGUgY29sdW1ucyB0byBiZSBwYWNrZWQgdGlnaHRseSwgc28gd2UgYWxsb3cgaW5kaXZpZHVhbFxuXHRcdFx0Ly8gY29sdW1ucyB0byBoYXZlIGluZGl2aWR1YWwgc2l6ZXMuIFdoZW4gcG9pbnRQYWRkaW5nIGlzIGdyZWF0ZXIsIHdlIHN0cml2ZSBmb3IgZXF1YWwtd2lkdGhcblx0XHRcdC8vIGNvbHVtbnMgKCMyNjk0KS5cblx0XHRcdGlmIChvcHRpb25zLnBvaW50UGFkZGluZykge1xuXHRcdFx0XHRzZXJpZXNCYXJXID0gbWF0aENlaWwoc2VyaWVzQmFyVyk7XG5cdFx0XHR9XG5cblx0XHRcdFNlcmllcy5wcm90b3R5cGUudHJhbnNsYXRlLmFwcGx5KHNlcmllcyk7XG5cblx0XHRcdC8vIFJlY29yZCB0aGUgbmV3IHZhbHVlc1xuXHRcdFx0ZWFjaChzZXJpZXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0dmFyIHlCb3R0b20gPSBwaWNrKHBvaW50LnlCb3R0b20sIHRyYW5zbGF0ZWRUaHJlc2hvbGQpLFxuXHRcdFx0XHRcdHBsb3RZID0gbWF0aE1pbihtYXRoTWF4KC05OTkgLSB5Qm90dG9tLCBwb2ludC5wbG90WSksIHlBeGlzLmxlbiArIDk5OSArIHlCb3R0b20pLCAvLyBEb24ndCBkcmF3IHRvbyBmYXIgb3V0c2lkZSBwbG90IGFyZWEgKCMxMzAzLCAjMjI0MSlcblx0XHRcdFx0XHRiYXJYID0gcG9pbnQucGxvdFggKyBwb2ludFhPZmZzZXQsXG5cdFx0XHRcdFx0YmFyVyA9IHNlcmllc0JhclcsXG5cdFx0XHRcdFx0YmFyWSA9IG1hdGhNaW4ocGxvdFksIHlCb3R0b20pLFxuXHRcdFx0XHRcdHJpZ2h0LFxuXHRcdFx0XHRcdGJvdHRvbSxcblx0XHRcdFx0XHRmcm9tVG9wLFxuXHRcdFx0XHRcdGJhckggPSBtYXRoTWF4KHBsb3RZLCB5Qm90dG9tKSAtIGJhclk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG9wdGlvbnMubWluUG9pbnRMZW5ndGhcblx0XHRcdFx0aWYgKG1hdGhBYnMoYmFySCkgPCBtaW5Qb2ludExlbmd0aCkge1xuXHRcdFx0XHRcdGlmIChtaW5Qb2ludExlbmd0aCkge1xuXHRcdFx0XHRcdFx0YmFySCA9IG1pblBvaW50TGVuZ3RoO1xuXHRcdFx0XHRcdFx0YmFyWSA9XG5cdFx0XHRcdFx0XHRcdG1hdGhSb3VuZChtYXRoQWJzKGJhclkgLSB0cmFuc2xhdGVkVGhyZXNob2xkKSA+IG1pblBvaW50TGVuZ3RoID8gLy8gc3RhY2tlZFxuXHRcdFx0XHRcdFx0XHRcdHlCb3R0b20gLSBtaW5Qb2ludExlbmd0aCA6IC8vIGtlZXAgcG9zaXRpb25cblx0XHRcdFx0XHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkIC0gKHlBeGlzLnRyYW5zbGF0ZShwb2ludC55LCAwLCAxLCAwLCAxKSA8PSB0cmFuc2xhdGVkVGhyZXNob2xkID8gbWluUG9pbnRMZW5ndGggOiAwKSk7IC8vIHVzZSBleGFjdCB5QXhpcy50cmFuc2xhdGlvbiAoIzE0ODUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FjaGUgZm9yIGFjY2VzcyBpbiBwb2xhclxuXHRcdFx0XHRwb2ludC5iYXJYID0gYmFyWDtcblx0XHRcdFx0cG9pbnQucG9pbnRXaWR0aCA9IHBvaW50V2lkdGg7XG5cblx0XHRcdFx0Ly8gRml4IHRoZSB0b29sdGlwIG9uIGNlbnRlciBvZiBncm91cGVkIGNvbHVtbnMgKCMxMjE2LCAjNDI0LCAjMzY0OClcblx0XHRcdFx0cG9pbnQudG9vbHRpcFBvcyA9IGNoYXJ0LmludmVydGVkID8gXG5cdFx0XHRcdFx0W3lBeGlzLmxlbiArIHlBeGlzLnBvcyAtIGNoYXJ0LnBsb3RMZWZ0IC0gcGxvdFksIHNlcmllcy54QXhpcy5sZW4gLSBiYXJYIC0gYmFyVyAvIDJdIDogXG5cdFx0XHRcdFx0W2JhclggKyBiYXJXIC8gMiwgcGxvdFkgKyB5QXhpcy5wb3MgLSBjaGFydC5wbG90VG9wXTtcblxuXHRcdFx0XHQvLyBSb3VuZCBvZmYgdG8gb2J0YWluIGNyaXNwIGVkZ2VzIGFuZCBhdm9pZCBvdmVybGFwcGluZyB3aXRoIG5laWdoYm91cnMgKCMyNjk0KVxuXHRcdFx0XHRyaWdodCA9IG1hdGhSb3VuZChiYXJYICsgYmFyVykgKyB4Q3Jpc3A7XG5cdFx0XHRcdGJhclggPSBtYXRoUm91bmQoYmFyWCkgKyB4Q3Jpc3A7XG5cdFx0XHRcdGJhclcgPSByaWdodCAtIGJhclg7XG5cblx0XHRcdFx0ZnJvbVRvcCA9IG1hdGhBYnMoYmFyWSkgPCAwLjU7XG5cdFx0XHRcdGJvdHRvbSA9IG1hdGhNaW4obWF0aFJvdW5kKGJhclkgKyBiYXJIKSArIHlDcmlzcCwgOWU0KTsgLy8gIzM1NzVcblx0XHRcdFx0YmFyWSA9IG1hdGhSb3VuZChiYXJZKSArIHlDcmlzcDtcblx0XHRcdFx0YmFySCA9IGJvdHRvbSAtIGJhclk7XG5cblx0XHRcdFx0Ly8gVG9wIGVkZ2VzIGFyZSBleGNlcHRpb25zXG5cdFx0XHRcdGlmIChmcm9tVG9wKSB7XG5cdFx0XHRcdFx0YmFyWSAtPSAxO1xuXHRcdFx0XHRcdGJhckggKz0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlZ2lzdGVyIHNoYXBlIHR5cGUgYW5kIGFyZ3VtZW50cyB0byBiZSB1c2VkIGluIGRyYXdQb2ludHNcblx0XHRcdFx0cG9pbnQuc2hhcGVUeXBlID0gJ3JlY3QnO1xuXHRcdFx0XHRwb2ludC5zaGFwZUFyZ3MgPSB7XG5cdFx0XHRcdFx0eDogYmFyWCxcblx0XHRcdFx0XHR5OiBiYXJZLFxuXHRcdFx0XHRcdHdpZHRoOiBiYXJXLFxuXHRcdFx0XHRcdGhlaWdodDogYmFySFxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9KTtcblxuXHRcdH0sXG5cblx0XHRnZXRTeW1ib2w6IG5vb3AsXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVXNlIGEgc29saWQgcmVjdGFuZ2xlIGxpa2UgdGhlIGFyZWEgc2VyaWVzIHR5cGVzXG5cdFx0ICovXG5cdFx0ZHJhd0xlZ2VuZFN5bWJvbDogTGVnZW5kU3ltYm9sTWl4aW4uZHJhd1JlY3RhbmdsZSxcblx0XHRcblx0XHRcblx0XHQvKipcblx0XHQgKiBDb2x1bW5zIGhhdmUgbm8gZ3JhcGhcblx0XHQgKi9cblx0XHRkcmF3R3JhcGg6IG5vb3AsXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSBjb2x1bW5zLiBGb3IgYmFycywgdGhlIHNlcmllcy5ncm91cCBpcyByb3RhdGVkLCBzbyB0aGUgc2FtZSBjb29yZGluYXRlc1xuXHRcdCAqIGFwcGx5IGZvciBjb2x1bW5zIGFuZCBiYXJzLiBUaGlzIG1ldGhvZCBpcyBpbmhlcml0ZWQgYnkgc2NhdHRlciBzZXJpZXMuXG5cdFx0ICpcblx0XHQgKi9cblx0XHRkcmF3UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdGFuaW1hdGlvbkxpbWl0ID0gb3B0aW9ucy5hbmltYXRpb25MaW1pdCB8fCAyNTAsXG5cdFx0XHRcdHNoYXBlQXJncyxcblx0XHRcdFx0cG9pbnRBdHRyO1xuXG5cdFx0XHQvLyBkcmF3IHRoZSBjb2x1bW5zXG5cdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHR2YXIgcGxvdFkgPSBwb2ludC5wbG90WSxcblx0XHRcdFx0XHRncmFwaGljID0gcG9pbnQuZ3JhcGhpYyxcblx0XHRcdFx0XHRib3JkZXJBdHRyO1xuXG5cdFx0XHRcdGlmIChwbG90WSAhPT0gVU5ERUZJTkVEICYmICFpc05hTihwbG90WSkgJiYgcG9pbnQueSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHNoYXBlQXJncyA9IHBvaW50LnNoYXBlQXJncztcblxuXHRcdFx0XHRcdGJvcmRlckF0dHIgPSBkZWZpbmVkKHNlcmllcy5ib3JkZXJXaWR0aCkgPyB7XG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogc2VyaWVzLmJvcmRlcldpZHRoXG5cdFx0XHRcdFx0fSA6IHt9O1xuXG5cdFx0XHRcdFx0cG9pbnRBdHRyID0gcG9pbnQucG9pbnRBdHRyW3BvaW50LnNlbGVjdGVkID8gU0VMRUNUX1NUQVRFIDogTk9STUFMX1NUQVRFXSB8fCBzZXJpZXMucG9pbnRBdHRyW05PUk1BTF9TVEFURV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGdyYXBoaWMpIHsgLy8gdXBkYXRlXG5cdFx0XHRcdFx0XHRzdG9wKGdyYXBoaWMpO1xuXHRcdFx0XHRcdFx0Z3JhcGhpYy5hdHRyKGJvcmRlckF0dHIpW2NoYXJ0LnBvaW50Q291bnQgPCBhbmltYXRpb25MaW1pdCA/ICdhbmltYXRlJyA6ICdhdHRyJ10obWVyZ2Uoc2hhcGVBcmdzKSk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYyA9IGdyYXBoaWMgPSByZW5kZXJlcltwb2ludC5zaGFwZVR5cGVdKHNoYXBlQXJncylcblx0XHRcdFx0XHRcdFx0LmF0dHIoYm9yZGVyQXR0cilcblx0XHRcdFx0XHRcdFx0LmF0dHIocG9pbnRBdHRyKVxuXHRcdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5ncm91cClcblx0XHRcdFx0XHRcdFx0LnNoYWRvdyhvcHRpb25zLnNoYWRvdywgbnVsbCwgb3B0aW9ucy5zdGFja2luZyAmJiAhb3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKGdyYXBoaWMpIHtcblx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYy5kZXN0cm95KCk7IC8vICMxMjY5XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBbmltYXRlIHRoZSBjb2x1bW4gaGVpZ2h0cyBvbmUgYnkgb25lIGZyb20gemVyb1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCBXaGV0aGVyIHRvIGluaXRpYWxpemUgdGhlIGFuaW1hdGlvbiBvciBydW4gaXRcblx0XHQgKi9cblx0XHRhbmltYXRlOiBmdW5jdGlvbiAoaW5pdCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHlBeGlzID0gdGhpcy55QXhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRpbnZlcnRlZCA9IHRoaXMuY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRcdGF0dHIgPSB7fSxcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZDtcblxuXHRcdFx0aWYgKGhhc1NWRykgeyAvLyBWTUwgaXMgdG9vIHNsb3cgYW55d2F5XG5cdFx0XHRcdGlmIChpbml0KSB7XG5cdFx0XHRcdFx0YXR0ci5zY2FsZVkgPSAwLjAwMTtcblx0XHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkID0gbWF0aE1pbih5QXhpcy5wb3MgKyB5QXhpcy5sZW4sIG1hdGhNYXgoeUF4aXMucG9zLCB5QXhpcy50b1BpeGVscyhvcHRpb25zLnRocmVzaG9sZCkpKTtcblx0XHRcdFx0XHRpZiAoaW52ZXJ0ZWQpIHtcblx0XHRcdFx0XHRcdGF0dHIudHJhbnNsYXRlWCA9IHRyYW5zbGF0ZWRUaHJlc2hvbGQgLSB5QXhpcy5sZW47XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGF0dHIudHJhbnNsYXRlWSA9IHRyYW5zbGF0ZWRUaHJlc2hvbGQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlcmllcy5ncm91cC5hdHRyKGF0dHIpO1xuXG5cdFx0XHRcdH0gZWxzZSB7IC8vIHJ1biB0aGUgYW5pbWF0aW9uXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0YXR0ci5zY2FsZVkgPSAxO1xuXHRcdFx0XHRcdGF0dHJbaW52ZXJ0ZWQgPyAndHJhbnNsYXRlWCcgOiAndHJhbnNsYXRlWSddID0geUF4aXMucG9zO1xuXHRcdFx0XHRcdHNlcmllcy5ncm91cC5hbmltYXRlKGF0dHIsIHNlcmllcy5vcHRpb25zLmFuaW1hdGlvbik7XG5cblx0XHRcdFx0XHQvLyBkZWxldGUgdGhpcyBmdW5jdGlvbiB0byBhbGxvdyBpdCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRzZXJpZXMuYW5pbWF0ZSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSB0aGlzIHNlcmllcyBmcm9tIHRoZSBjaGFydFxuXHRcdCAqL1xuXHRcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0O1xuXG5cdFx0XHQvLyBjb2x1bW4gYW5kIGJhciBzZXJpZXMgYWZmZWN0cyBvdGhlciBzZXJpZXMgb2YgdGhlIHNhbWUgdHlwZVxuXHRcdFx0Ly8gYXMgdGhleSBhcmUgZWl0aGVyIHN0YWNrZWQgb3IgZ3JvdXBlZFxuXHRcdFx0aWYgKGNoYXJ0Lmhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdGVhY2goY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAob3RoZXJTZXJpZXMpIHtcblx0XHRcdFx0XHRpZiAob3RoZXJTZXJpZXMudHlwZSA9PT0gc2VyaWVzLnR5cGUpIHtcblx0XHRcdFx0XHRcdG90aGVyU2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdFNlcmllcy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHNlcmllcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH0pO1xuXHRzZXJpZXNUeXBlcy5jb2x1bW4gPSBDb2x1bW5TZXJpZXM7XG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYmFyXG5cdCAqL1xuXHRkZWZhdWx0UGxvdE9wdGlvbnMuYmFyID0gbWVyZ2UoZGVmYXVsdFBsb3RPcHRpb25zLmNvbHVtbik7XG5cdC8qKlxuXHQgKiBUaGUgQmFyIHNlcmllcyBjbGFzc1xuXHQgKi9cblx0dmFyIEJhclNlcmllcyA9IGV4dGVuZENsYXNzKENvbHVtblNlcmllcywge1xuXHRcdHR5cGU6ICdiYXInLFxuXHRcdGludmVydGVkOiB0cnVlXG5cdH0pO1xuXHRzZXJpZXNUeXBlcy5iYXIgPSBCYXJTZXJpZXM7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBzY2F0dGVyXG5cdCAqL1xuXHRkZWZhdWx0UGxvdE9wdGlvbnMuc2NhdHRlciA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zLCB7XG5cdFx0bGluZVdpZHRoOiAwLFxuXHRcdG1hcmtlcjoge1xuXHRcdFx0ZW5hYmxlZDogdHJ1ZSAvLyBPdmVycmlkZXMgYXV0by1lbmFibGluZyBpbiBsaW5lIHNlcmllcyAoIzM2NDcpXG5cdFx0fSxcblx0XHR0b29sdGlwOiB7XG5cdFx0XHRoZWFkZXJGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImNvbG9yOntzZXJpZXMuY29sb3J9XCI+XFx1MjVDRjwvc3Bhbj4gPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHg7XCI+IHtzZXJpZXMubmFtZX08L3NwYW4+PGJyLz4nLFxuXHRcdFx0cG9pbnRGb3JtYXQ6ICd4OiA8Yj57cG9pbnQueH08L2I+PGJyLz55OiA8Yj57cG9pbnQueX08L2I+PGJyLz4nXG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogVGhlIHNjYXR0ZXIgc2VyaWVzIGNsYXNzXG5cdCAqL1xuXHR2YXIgU2NhdHRlclNlcmllcyA9IGV4dGVuZENsYXNzKFNlcmllcywge1xuXHRcdHR5cGU6ICdzY2F0dGVyJyxcblx0XHRzb3J0ZWQ6IGZhbHNlLFxuXHRcdHJlcXVpcmVTb3J0aW5nOiBmYWxzZSxcblx0XHRub1NoYXJlZFRvb2x0aXA6IHRydWUsXG5cdFx0dHJhY2tlckdyb3VwczogWydncm91cCcsICdtYXJrZXJHcm91cCcsICdkYXRhTGFiZWxzR3JvdXAnXSxcblx0XHR0YWtlT3JkaW5hbFBvc2l0aW9uOiBmYWxzZSwgLy8gIzIzNDJcblx0XHRrZERpbWVuc2lvbnM6IDIsXG5cdFx0a2RDb21wYXJlcjogJ2Rpc3RSJyxcblx0XHRkcmF3R3JhcGg6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMubGluZVdpZHRoKSB7XG5cdFx0XHRcdFNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRzZXJpZXNUeXBlcy5zY2F0dGVyID0gU2NhdHRlclNlcmllcztcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHBpZVxuXHQgKi9cblx0ZGVmYXVsdFBsb3RPcHRpb25zLnBpZSA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zLCB7XG5cdFx0Ym9yZGVyQ29sb3I6ICcjRkZGRkZGJyxcblx0XHRib3JkZXJXaWR0aDogMSxcblx0XHRjZW50ZXI6IFtudWxsLCBudWxsXSxcblx0XHRjbGlwOiBmYWxzZSxcblx0XHRjb2xvckJ5UG9pbnQ6IHRydWUsIC8vIGFsd2F5cyB0cnVlIGZvciBwaWVzXG5cdFx0ZGF0YUxhYmVsczoge1xuXHRcdFx0Ly8gYWxpZ246IG51bGwsXG5cdFx0XHQvLyBjb25uZWN0b3JXaWR0aDogMSxcblx0XHRcdC8vIGNvbm5lY3RvckNvbG9yOiBwb2ludC5jb2xvcixcblx0XHRcdC8vIGNvbm5lY3RvclBhZGRpbmc6IDUsXG5cdFx0XHRkaXN0YW5jZTogMzAsXG5cdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0Zm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7IC8vICMyOTQ1XG5cdFx0XHRcdHJldHVybiB0aGlzLnBvaW50Lm5hbWU7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gc29mdENvbm5lY3RvcjogdHJ1ZSxcblx0XHRcdHg6IDBcblx0XHRcdC8vIHk6IDBcblx0XHR9LFxuXHRcdGlnbm9yZUhpZGRlblBvaW50OiB0cnVlLFxuXHRcdC8vaW5uZXJTaXplOiAwLFxuXHRcdGxlZ2VuZFR5cGU6ICdwb2ludCcsXG5cdFx0bWFya2VyOiBudWxsLCAvLyBwb2ludCBvcHRpb25zIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGJhc2Ugb3B0aW9uc1xuXHRcdHNpemU6IG51bGwsXG5cdFx0c2hvd0luTGVnZW5kOiBmYWxzZSxcblx0XHRzbGljZWRPZmZzZXQ6IDEwLFxuXHRcdHN0YXRlczoge1xuXHRcdFx0aG92ZXI6IHtcblx0XHRcdFx0YnJpZ2h0bmVzczogMC4xLFxuXHRcdFx0XHRzaGFkb3c6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdGlja3lUcmFja2luZzogZmFsc2UsXG5cdFx0dG9vbHRpcDoge1xuXHRcdFx0Zm9sbG93UG9pbnRlcjogdHJ1ZVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEV4dGVuZGVkIHBvaW50IG9iamVjdCBmb3IgcGllc1xuXHQgKi9cblx0dmFyIFBpZVBvaW50ID0gZXh0ZW5kQ2xhc3MoUG9pbnQsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWF0ZSB0aGUgcGllIHNsaWNlXG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRQb2ludC5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHR0b2dnbGVTbGljZTtcblxuXHRcdFx0ZXh0ZW5kKHBvaW50LCB7XG5cdFx0XHRcdHZpc2libGU6IHBvaW50LnZpc2libGUgIT09IGZhbHNlLFxuXHRcdFx0XHRuYW1lOiBwaWNrKHBvaW50Lm5hbWUsICdTbGljZScpXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gYWRkIGV2ZW50IGxpc3RlbmVyIGZvciBzZWxlY3Rcblx0XHRcdHRvZ2dsZVNsaWNlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0cG9pbnQuc2xpY2UoZS50eXBlID09PSAnc2VsZWN0Jyk7XG5cdFx0XHR9O1xuXHRcdFx0YWRkRXZlbnQocG9pbnQsICdzZWxlY3QnLCB0b2dnbGVTbGljZSk7XG5cdFx0XHRhZGRFdmVudChwb2ludCwgJ3Vuc2VsZWN0JywgdG9nZ2xlU2xpY2UpO1xuXG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcGllIHNsaWNlXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSB2aXMgV2hldGhlciB0byBzaG93IHRoZSBzbGljZSBvciBub3QuIElmIHVuZGVmaW5lZCwgdGhlXG5cdFx0ICogICAgdmlzaWJpbGl0eSBpcyB0b2dnbGVkXG5cdFx0ICovXG5cdFx0c2V0VmlzaWJsZTogZnVuY3Rpb24gKHZpcykge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0ZG9SZWRyYXcgPSAhc2VyaWVzLmlzRGlydHkgJiYgc2VyaWVzLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQ7XG5cblx0XHRcdC8vIGlmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCB0b2dnbGUgdmlzaWJpbGl0eVxuXHRcdFx0cG9pbnQudmlzaWJsZSA9IHBvaW50Lm9wdGlvbnMudmlzaWJsZSA9IHZpcyA9IHZpcyA9PT0gVU5ERUZJTkVEID8gIXBvaW50LnZpc2libGUgOiB2aXM7XG5cdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhW2luQXJyYXkocG9pbnQsIHNlcmllcy5kYXRhKV0gPSBwb2ludC5vcHRpb25zOyAvLyB1cGRhdGUgdXNlck9wdGlvbnMuZGF0YVxuXG5cdFx0XHQvLyBTaG93IGFuZCBoaWRlIGFzc29jaWF0ZWQgZWxlbWVudHNcblx0XHRcdGVhY2goWydncmFwaGljJywgJ2RhdGFMYWJlbCcsICdjb25uZWN0b3InLCAnc2hhZG93R3JvdXAnXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRpZiAocG9pbnRba2V5XSkge1xuXHRcdFx0XHRcdHBvaW50W2tleV1bdmlzID8gJ3Nob3cnIDogJ2hpZGUnXSh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChwb2ludC5sZWdlbmRJdGVtKSB7XG5cdFx0XHRcdGlmIChjaGFydC5oYXNSZW5kZXJlZCkge1xuXHRcdFx0XHRcdHNlcmllcy51cGRhdGVUb3RhbHMoKTtcblx0XHRcdFx0XHRjaGFydC5sZWdlbmQuY2xlYXJJdGVtcygpO1xuXHRcdFx0XHRcdGlmICghZG9SZWRyYXcpIHtcblx0XHRcdFx0XHRcdGNoYXJ0LmxlZ2VuZC5yZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hhcnQubGVnZW5kLmNvbG9yaXplSXRlbShwb2ludCwgdmlzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIGlnbm9yZSBoaWRkZW4gc2xpY2VzXG5cdFx0XHRpZiAoZG9SZWRyYXcpIHtcblx0XHRcdFx0c2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IG9yIHRvZ2dsZSB3aGV0aGVyIHRoZSBzbGljZSBpcyBjdXQgb3V0IGZyb20gdGhlIHBpZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2xpY2VkIFdoZW4gdW5kZWZpbmVkLCB0aGUgc2xpY2Ugc3RhdGUgaXMgdG9nZ2xlZFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydC4gVHJ1ZSBieSBkZWZhdWx0LlxuXHRcdCAqL1xuXHRcdHNsaWNlOiBmdW5jdGlvbiAoc2xpY2VkLCByZWRyYXcsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0dHJhbnNsYXRpb247XG5cblx0XHRcdHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KTtcblxuXHRcdFx0Ly8gcmVkcmF3IGlzIHRydWUgYnkgZGVmYXVsdFxuXHRcdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0XHQvLyBpZiBjYWxsZWQgd2l0aG91dCBhbiBhcmd1bWVudCwgdG9nZ2xlXG5cdFx0XHRwb2ludC5zbGljZWQgPSBwb2ludC5vcHRpb25zLnNsaWNlZCA9IHNsaWNlZCA9IGRlZmluZWQoc2xpY2VkKSA/IHNsaWNlZCA6ICFwb2ludC5zbGljZWQ7XG5cdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhW2luQXJyYXkocG9pbnQsIHNlcmllcy5kYXRhKV0gPSBwb2ludC5vcHRpb25zOyAvLyB1cGRhdGUgdXNlck9wdGlvbnMuZGF0YVxuXG5cdFx0XHR0cmFuc2xhdGlvbiA9IHNsaWNlZCA/IHBvaW50LnNsaWNlZFRyYW5zbGF0aW9uIDoge1xuXHRcdFx0XHR0cmFuc2xhdGVYOiAwLFxuXHRcdFx0XHR0cmFuc2xhdGVZOiAwXG5cdFx0XHR9O1xuXG5cdFx0XHRwb2ludC5ncmFwaGljLmFuaW1hdGUodHJhbnNsYXRpb24pO1xuXHRcdFx0XG5cdFx0XHRpZiAocG9pbnQuc2hhZG93R3JvdXApIHtcblx0XHRcdFx0cG9pbnQuc2hhZG93R3JvdXAuYW5pbWF0ZSh0cmFuc2xhdGlvbik7XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0aGFsb1BhdGg6IGZ1bmN0aW9uIChzaXplKSB7XG5cdFx0XHR2YXIgc2hhcGVBcmdzID0gdGhpcy5zaGFwZUFyZ3MsXG5cdFx0XHRcdGNoYXJ0ID0gdGhpcy5zZXJpZXMuY2hhcnQ7XG5cblx0XHRcdHJldHVybiB0aGlzLnNsaWNlZCB8fCAhdGhpcy52aXNpYmxlID8gW10gOiB0aGlzLnNlcmllcy5jaGFydC5yZW5kZXJlci5zeW1ib2xzLmFyYyhjaGFydC5wbG90TGVmdCArIHNoYXBlQXJncy54LCBjaGFydC5wbG90VG9wICsgc2hhcGVBcmdzLnksIHNoYXBlQXJncy5yICsgc2l6ZSwgc2hhcGVBcmdzLnIgKyBzaXplLCB7XG5cdFx0XHRcdGlubmVyUjogdGhpcy5zaGFwZUFyZ3Mucixcblx0XHRcdFx0c3RhcnQ6IHNoYXBlQXJncy5zdGFydCxcblx0XHRcdFx0ZW5kOiBzaGFwZUFyZ3MuZW5kXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgUGllIHNlcmllcyBjbGFzc1xuXHQgKi9cblx0dmFyIFBpZVNlcmllcyA9IHtcblx0XHR0eXBlOiAncGllJyxcblx0XHRpc0NhcnRlc2lhbjogZmFsc2UsXG5cdFx0cG9pbnRDbGFzczogUGllUG9pbnQsXG5cdFx0cmVxdWlyZVNvcnRpbmc6IGZhbHNlLFxuXHRcdG5vU2hhcmVkVG9vbHRpcDogdHJ1ZSxcblx0XHR0cmFja2VyR3JvdXBzOiBbJ2dyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCddLFxuXHRcdGF4aXNUeXBlczogW10sXG5cdFx0cG9pbnRBdHRyVG9PcHRpb25zOiB7IC8vIG1hcHBpbmcgYmV0d2VlbiBTVkcgYXR0cmlidXRlcyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW9uc1xuXHRcdFx0c3Ryb2tlOiAnYm9yZGVyQ29sb3InLFxuXHRcdFx0J3N0cm9rZS13aWR0aCc6ICdib3JkZXJXaWR0aCcsXG5cdFx0XHRmaWxsOiAnY29sb3InXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBpZXMgaGF2ZSBvbmUgY29sb3IgZWFjaCBwb2ludFxuXHRcdCAqL1xuXHRcdGdldENvbG9yOiBub29wLFxuXG5cdFx0LyoqXG5cdFx0ICogQW5pbWF0ZSB0aGUgcGllcyBpblxuXHRcdCAqL1xuXHRcdGFuaW1hdGU6IGZ1bmN0aW9uIChpbml0KSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdFx0c3RhcnRBbmdsZVJhZCA9IHNlcmllcy5zdGFydEFuZ2xlUmFkO1xuXG5cdFx0XHRpZiAoIWluaXQpIHtcblx0XHRcdFx0ZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdHZhciBncmFwaGljID0gcG9pbnQuZ3JhcGhpYyxcblx0XHRcdFx0XHRcdGFyZ3MgPSBwb2ludC5zaGFwZUFyZ3M7XG5cblx0XHRcdFx0XHRpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdFx0Ly8gc3RhcnQgdmFsdWVzXG5cdFx0XHRcdFx0XHRncmFwaGljLmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRyOiBzZXJpZXMuY2VudGVyWzNdIC8gMiwgLy8gYW5pbWF0ZSBmcm9tIGlubmVyIHJhZGl1cyAoIzc3OSlcblx0XHRcdFx0XHRcdFx0c3RhcnQ6IHN0YXJ0QW5nbGVSYWQsXG5cdFx0XHRcdFx0XHRcdGVuZDogc3RhcnRBbmdsZVJhZFxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8vIGFuaW1hdGVcblx0XHRcdFx0XHRcdGdyYXBoaWMuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0XHRcdHI6IGFyZ3Mucixcblx0XHRcdFx0XHRcdFx0c3RhcnQ6IGFyZ3Muc3RhcnQsXG5cdFx0XHRcdFx0XHRcdGVuZDogYXJncy5lbmRcblx0XHRcdFx0XHRcdH0sIHNlcmllcy5vcHRpb25zLmFuaW1hdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBkZWxldGUgdGhpcyBmdW5jdGlvbiB0byBhbGxvdyBpdCBvbmx5IG9uY2Vcblx0XHRcdFx0c2VyaWVzLmFuaW1hdGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHRlbmQgdGhlIGJhc2ljIHNldERhdGEgbWV0aG9kIGJ5IHJ1bm5pbmcgcHJvY2Vzc0RhdGEgYW5kIGdlbmVyYXRlUG9pbnRzIGltbWVkaWF0ZWx5LFxuXHRcdCAqIGluIG9yZGVyIHRvIGFjY2VzcyB0aGUgcG9pbnRzIGZyb20gdGhlIGxlZ2VuZC5cblx0XHQgKi9cblx0XHRzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSwgcmVkcmF3LCBhbmltYXRpb24sIHVwZGF0ZVBvaW50cykge1xuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5zZXREYXRhLmNhbGwodGhpcywgZGF0YSwgZmFsc2UsIGFuaW1hdGlvbiwgdXBkYXRlUG9pbnRzKTtcblx0XHRcdHRoaXMucHJvY2Vzc0RhdGEoKTtcblx0XHRcdHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcblx0XHRcdGlmIChwaWNrKHJlZHJhdywgdHJ1ZSkpIHtcblx0XHRcdFx0dGhpcy5jaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdH0gXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlY29tcHV0ZSB0b3RhbCBjaGFydCBzdW0gYW5kIHVwZGF0ZSBwZXJjZW50YWdlcyBvZiBwb2ludHMuXG5cdFx0ICovXG5cdFx0dXBkYXRlVG90YWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0dG90YWwgPSAwLFxuXHRcdFx0XHRwb2ludHMsXG5cdFx0XHRcdGxlbixcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdGlnbm9yZUhpZGRlblBvaW50ID0gdGhpcy5vcHRpb25zLmlnbm9yZUhpZGRlblBvaW50O1xuXG5cdFx0XHQvLyBQb3B1bGF0ZSBsb2NhbCB2YXJzXG5cdFx0XHRwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRcdGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcblx0XHRcdC8vIEdldCB0aGUgdG90YWwgc3VtXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cblx0XHRcdFx0Ly8gRGlzYWxsb3cgbmVnYXRpdmUgdmFsdWVzICgjMTUzMCwgIzM2MjMpXG5cdFx0XHRcdGlmIChwb2ludC55IDwgMCkge1xuXHRcdFx0XHRcdHBvaW50LnkgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR0b3RhbCArPSAoaWdub3JlSGlkZGVuUG9pbnQgJiYgIXBvaW50LnZpc2libGUpID8gMCA6IHBvaW50Lnk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRvdGFsID0gdG90YWw7XG5cblx0XHRcdC8vIFNldCBlYWNoIHBvaW50J3MgcHJvcGVydGllc1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdFx0XHQvL3BvaW50LnBlcmNlbnRhZ2UgPSAodG90YWwgPD0gMCB8fCBpZ25vcmVIaWRkZW5Qb2ludCAmJiAhcG9pbnQudmlzaWJsZSkgPyAwIDogcG9pbnQueSAvIHRvdGFsICogMTAwO1xuXHRcdFx0XHRwb2ludC5wZXJjZW50YWdlID0gKHRvdGFsID4gMCAmJiAocG9pbnQudmlzaWJsZSB8fCAhaWdub3JlSGlkZGVuUG9pbnQpKSA/IHBvaW50LnkgLyB0b3RhbCAqIDEwMCA6IDA7XG5cdFx0XHRcdHBvaW50LnRvdGFsID0gdG90YWw7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZCB0aGUgZ2VuZXJhdGVQb2ludHMgbWV0aG9kIGJ5IGFkZGluZyB0b3RhbCBhbmQgcGVyY2VudGFnZSBwcm9wZXJ0aWVzIHRvIGVhY2ggcG9pbnRcblx0XHQgKi9cblx0XHRnZW5lcmF0ZVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5nZW5lcmF0ZVBvaW50cy5jYWxsKHRoaXMpO1xuXHRcdFx0dGhpcy51cGRhdGVUb3RhbHMoKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIERvIHRyYW5zbGF0aW9uIGZvciBwaWUgc2xpY2VzXG5cdFx0ICovXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAocG9zaXRpb25zKSB7XG5cdFx0XHR0aGlzLmdlbmVyYXRlUG9pbnRzKCk7XG5cdFx0XHRcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjdW11bGF0aXZlID0gMCxcblx0XHRcdFx0cHJlY2lzaW9uID0gMTAwMCwgLy8gaXNzdWUgIzE3MlxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdHNsaWNlZE9mZnNldCA9IG9wdGlvbnMuc2xpY2VkT2Zmc2V0LFxuXHRcdFx0XHRjb25uZWN0b3JPZmZzZXQgPSBzbGljZWRPZmZzZXQgKyBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRzdGFydCxcblx0XHRcdFx0ZW5kLFxuXHRcdFx0XHRhbmdsZSxcblx0XHRcdFx0c3RhcnRBbmdsZSA9IG9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwLFxuXHRcdFx0XHRzdGFydEFuZ2xlUmFkID0gc2VyaWVzLnN0YXJ0QW5nbGVSYWQgPSBtYXRoUEkgLyAxODAgKiAoc3RhcnRBbmdsZSAtIDkwKSxcblx0XHRcdFx0ZW5kQW5nbGVSYWQgPSBzZXJpZXMuZW5kQW5nbGVSYWQgPSBtYXRoUEkgLyAxODAgKiAoKHBpY2sob3B0aW9ucy5lbmRBbmdsZSwgc3RhcnRBbmdsZSArIDM2MCkpIC0gOTApLFxuXHRcdFx0XHRjaXJjID0gZW5kQW5nbGVSYWQgLSBzdGFydEFuZ2xlUmFkLCAvLzIgKiBtYXRoUEksXG5cdFx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRcdHJhZGl1c1gsIC8vIHRoZSB4IGNvbXBvbmVudCBvZiB0aGUgcmFkaXVzIHZlY3RvciBmb3IgYSBnaXZlbiBwb2ludFxuXHRcdFx0XHRyYWRpdXNZLFxuXHRcdFx0XHRsYWJlbERpc3RhbmNlID0gb3B0aW9ucy5kYXRhTGFiZWxzLmRpc3RhbmNlLFxuXHRcdFx0XHRpZ25vcmVIaWRkZW5Qb2ludCA9IG9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQsXG5cdFx0XHRcdGksXG5cdFx0XHRcdGxlbiA9IHBvaW50cy5sZW5ndGgsXG5cdFx0XHRcdHBvaW50O1xuXG5cdFx0XHQvLyBHZXQgcG9zaXRpb25zIC0gZWl0aGVyIGFuIGludGVnZXIgb3IgYSBwZXJjZW50YWdlIHN0cmluZyBtdXN0IGJlIGdpdmVuLlxuXHRcdFx0Ly8gSWYgcG9zaXRpb25zIGFyZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIsIHdlJ3JlIGluIGEgcmVjdXJzaXZlIGxvb3AgZm9yIGFkanVzdGluZ1xuXHRcdFx0Ly8gc3BhY2UgZm9yIGRhdGEgbGFiZWxzLlxuXHRcdFx0aWYgKCFwb3NpdGlvbnMpIHtcblx0XHRcdFx0c2VyaWVzLmNlbnRlciA9IHBvc2l0aW9ucyA9IHNlcmllcy5nZXRDZW50ZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgeCB2YWx1ZSBmcm9tIGEgZ2l2ZW4geSwgdXNlZCBmb3IgYW50aWNvbGxpc2lvbiBsb2dpYyBpbiBkYXRhIGxhYmVsc1xuXHRcdFx0c2VyaWVzLmdldFggPSBmdW5jdGlvbiAoeSwgbGVmdCkge1xuXG5cdFx0XHRcdGFuZ2xlID0gbWF0aC5hc2luKG1hdGhNaW4oKHkgLSBwb3NpdGlvbnNbMV0pIC8gKHBvc2l0aW9uc1syXSAvIDIgKyBsYWJlbERpc3RhbmNlKSwgMSkpO1xuXG5cdFx0XHRcdHJldHVybiBwb3NpdGlvbnNbMF0gK1xuXHRcdFx0XHRcdChsZWZ0ID8gLTEgOiAxKSAqXG5cdFx0XHRcdFx0KG1hdGhDb3MoYW5nbGUpICogKHBvc2l0aW9uc1syXSAvIDIgKyBsYWJlbERpc3RhbmNlKSk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgdGhlIGdlb21ldHJ5IGZvciBlYWNoIHBvaW50XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XG5cdFx0XHRcdHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gc2V0IHN0YXJ0IGFuZCBlbmQgYW5nbGVcblx0XHRcdFx0c3RhcnQgPSBzdGFydEFuZ2xlUmFkICsgKGN1bXVsYXRpdmUgKiBjaXJjKTtcblx0XHRcdFx0aWYgKCFpZ25vcmVIaWRkZW5Qb2ludCB8fCBwb2ludC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0Y3VtdWxhdGl2ZSArPSBwb2ludC5wZXJjZW50YWdlIC8gMTAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVuZCA9IHN0YXJ0QW5nbGVSYWQgKyAoY3VtdWxhdGl2ZSAqIGNpcmMpO1xuXG5cdFx0XHRcdC8vIHNldCB0aGUgc2hhcGVcblx0XHRcdFx0cG9pbnQuc2hhcGVUeXBlID0gJ2FyYyc7XG5cdFx0XHRcdHBvaW50LnNoYXBlQXJncyA9IHtcblx0XHRcdFx0XHR4OiBwb3NpdGlvbnNbMF0sXG5cdFx0XHRcdFx0eTogcG9zaXRpb25zWzFdLFxuXHRcdFx0XHRcdHI6IHBvc2l0aW9uc1syXSAvIDIsXG5cdFx0XHRcdFx0aW5uZXJSOiBwb3NpdGlvbnNbM10gLyAyLFxuXHRcdFx0XHRcdHN0YXJ0OiBtYXRoUm91bmQoc3RhcnQgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uLFxuXHRcdFx0XHRcdGVuZDogbWF0aFJvdW5kKGVuZCAqIHByZWNpc2lvbikgLyBwcmVjaXNpb25cblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBUaGUgYW5nbGUgbXVzdCBzdGF5IHdpdGhpbiAtOTAgYW5kIDI3MCAoIzI2NDUpXG5cdFx0XHRcdGFuZ2xlID0gKGVuZCArIHN0YXJ0KSAvIDI7XG5cdFx0XHRcdGlmIChhbmdsZSA+IDEuNSAqIG1hdGhQSSkge1xuXHRcdFx0XHRcdGFuZ2xlIC09IDIgKiBtYXRoUEk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYW5nbGUgPCAtbWF0aFBJIC8gMikge1xuXHRcdFx0XHRcdGFuZ2xlICs9IDIgKiBtYXRoUEk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDZW50ZXIgZm9yIHRoZSBzbGljZWQgb3V0IHNsaWNlXG5cdFx0XHRcdHBvaW50LnNsaWNlZFRyYW5zbGF0aW9uID0ge1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVg6IG1hdGhSb3VuZChtYXRoQ29zKGFuZ2xlKSAqIHNsaWNlZE9mZnNldCksXG5cdFx0XHRcdFx0dHJhbnNsYXRlWTogbWF0aFJvdW5kKG1hdGhTaW4oYW5nbGUpICogc2xpY2VkT2Zmc2V0KVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIHNldCB0aGUgYW5jaG9yIHBvaW50IGZvciB0b29sdGlwc1xuXHRcdFx0XHRyYWRpdXNYID0gbWF0aENvcyhhbmdsZSkgKiBwb3NpdGlvbnNbMl0gLyAyO1xuXHRcdFx0XHRyYWRpdXNZID0gbWF0aFNpbihhbmdsZSkgKiBwb3NpdGlvbnNbMl0gLyAyO1xuXHRcdFx0XHRwb2ludC50b29sdGlwUG9zID0gW1xuXHRcdFx0XHRcdHBvc2l0aW9uc1swXSArIHJhZGl1c1ggKiAwLjcsXG5cdFx0XHRcdFx0cG9zaXRpb25zWzFdICsgcmFkaXVzWSAqIDAuN1xuXHRcdFx0XHRdO1xuXHRcdFx0XHRcblx0XHRcdFx0cG9pbnQuaGFsZiA9IGFuZ2xlIDwgLW1hdGhQSSAvIDIgfHwgYW5nbGUgPiBtYXRoUEkgLyAyID8gMSA6IDA7XG5cdFx0XHRcdHBvaW50LmFuZ2xlID0gYW5nbGU7XG5cblx0XHRcdFx0Ly8gc2V0IHRoZSBhbmNob3IgcG9pbnQgZm9yIGRhdGEgbGFiZWxzXG5cdFx0XHRcdGNvbm5lY3Rvck9mZnNldCA9IG1hdGhNaW4oY29ubmVjdG9yT2Zmc2V0LCBsYWJlbERpc3RhbmNlIC8gMik7IC8vICMxNjc4XG5cdFx0XHRcdHBvaW50LmxhYmVsUG9zID0gW1xuXHRcdFx0XHRcdHBvc2l0aW9uc1swXSArIHJhZGl1c1ggKyBtYXRoQ29zKGFuZ2xlKSAqIGxhYmVsRGlzdGFuY2UsIC8vIGZpcnN0IGJyZWFrIG9mIGNvbm5lY3RvclxuXHRcdFx0XHRcdHBvc2l0aW9uc1sxXSArIHJhZGl1c1kgKyBtYXRoU2luKGFuZ2xlKSAqIGxhYmVsRGlzdGFuY2UsIC8vIGEvYVxuXHRcdFx0XHRcdHBvc2l0aW9uc1swXSArIHJhZGl1c1ggKyBtYXRoQ29zKGFuZ2xlKSAqIGNvbm5lY3Rvck9mZnNldCwgLy8gc2Vjb25kIGJyZWFrLCByaWdodCBvdXRzaWRlIHBpZVxuXHRcdFx0XHRcdHBvc2l0aW9uc1sxXSArIHJhZGl1c1kgKyBtYXRoU2luKGFuZ2xlKSAqIGNvbm5lY3Rvck9mZnNldCwgLy8gYS9hXG5cdFx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCwgLy8gbGFuZGluZyBwb2ludCBmb3IgY29ubmVjdG9yXG5cdFx0XHRcdFx0cG9zaXRpb25zWzFdICsgcmFkaXVzWSwgLy8gYS9hXG5cdFx0XHRcdFx0bGFiZWxEaXN0YW5jZSA8IDAgPyAvLyBhbGlnbm1lbnRcblx0XHRcdFx0XHRcdCdjZW50ZXInIDpcblx0XHRcdFx0XHRcdHBvaW50LmhhbGYgPyAncmlnaHQnIDogJ2xlZnQnLCAvLyBhbGlnbm1lbnRcblx0XHRcdFx0XHRhbmdsZSAvLyBjZW50ZXIgYW5nbGVcblx0XHRcdFx0XTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0ZHJhd0dyYXBoOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyB0aGUgZGF0YSBwb2ludHNcblx0XHQgKi9cblx0XHRkcmF3UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdGdyb3VwVHJhbnNsYXRpb24sXG5cdFx0XHRcdC8vY2VudGVyLFxuXHRcdFx0XHRncmFwaGljLFxuXHRcdFx0XHQvL2dyb3VwLFxuXHRcdFx0XHRzaGFkb3cgPSBzZXJpZXMub3B0aW9ucy5zaGFkb3csXG5cdFx0XHRcdHNoYWRvd0dyb3VwLFxuXHRcdFx0XHRzaGFwZUFyZ3M7XG5cblx0XHRcdGlmIChzaGFkb3cgJiYgIXNlcmllcy5zaGFkb3dHcm91cCkge1xuXHRcdFx0XHRzZXJpZXMuc2hhZG93R3JvdXAgPSByZW5kZXJlci5nKCdzaGFkb3cnKVxuXHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZHJhdyB0aGUgc2xpY2VzXG5cdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRncmFwaGljID0gcG9pbnQuZ3JhcGhpYztcblx0XHRcdFx0c2hhcGVBcmdzID0gcG9pbnQuc2hhcGVBcmdzO1xuXHRcdFx0XHRzaGFkb3dHcm91cCA9IHBvaW50LnNoYWRvd0dyb3VwO1xuXG5cdFx0XHRcdC8vIHB1dCB0aGUgc2hhZG93IGJlaGluZCBhbGwgcG9pbnRzXG5cdFx0XHRcdGlmIChzaGFkb3cgJiYgIXNoYWRvd0dyb3VwKSB7XG5cdFx0XHRcdFx0c2hhZG93R3JvdXAgPSBwb2ludC5zaGFkb3dHcm91cCA9IHJlbmRlcmVyLmcoJ3NoYWRvdycpXG5cdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5zaGFkb3dHcm91cCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiB0aGUgcG9pbnQgaXMgc2xpY2VkLCB1c2Ugc3BlY2lhbCB0cmFuc2xhdGlvbiwgZWxzZSB1c2UgcGxvdCBhcmVhIHRyYXNsYXRpb25cblx0XHRcdFx0Z3JvdXBUcmFuc2xhdGlvbiA9IHBvaW50LnNsaWNlZCA/IHBvaW50LnNsaWNlZFRyYW5zbGF0aW9uIDoge1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVg6IDAsXG5cdFx0XHRcdFx0dHJhbnNsYXRlWTogMFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vZ3JvdXAudHJhbnNsYXRlKGdyb3VwVHJhbnNsYXRpb25bMF0sIGdyb3VwVHJhbnNsYXRpb25bMV0pO1xuXHRcdFx0XHRpZiAoc2hhZG93R3JvdXApIHtcblx0XHRcdFx0XHRzaGFkb3dHcm91cC5hdHRyKGdyb3VwVHJhbnNsYXRpb24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZHJhdyB0aGUgc2xpY2Vcblx0XHRcdFx0aWYgKGdyYXBoaWMpIHtcblx0XHRcdFx0XHRncmFwaGljLmFuaW1hdGUoZXh0ZW5kKHNoYXBlQXJncywgZ3JvdXBUcmFuc2xhdGlvbikpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljID0gcmVuZGVyZXJbcG9pbnQuc2hhcGVUeXBlXShzaGFwZUFyZ3MpXG5cdFx0XHRcdFx0XHQuc2V0UmFkaWFsUmVmZXJlbmNlKHNlcmllcy5jZW50ZXIpXG5cdFx0XHRcdFx0XHQuYXR0cihcblx0XHRcdFx0XHRcdFx0cG9pbnQucG9pbnRBdHRyW3BvaW50LnNlbGVjdGVkID8gU0VMRUNUX1NUQVRFIDogTk9STUFMX1NUQVRFXVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmF0dHIoeyBcblx0XHRcdFx0XHRcdFx0J3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCdcblx0XHRcdFx0XHRcdFx0Ly96SW5kZXg6IDEgLy8gIzI3MjIgKHJldmVyc2VkKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hdHRyKGdyb3VwVHJhbnNsYXRpb24pXG5cdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5ncm91cClcblx0XHRcdFx0XHRcdC5zaGFkb3coc2hhZG93LCBzaGFkb3dHcm91cCk7XHRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGRldGVjdCBwb2ludCBzcGVjaWZpYyB2aXNpYmlsaXR5ICgjMjQzMClcblx0XHRcdFx0aWYgKHBvaW50LnZpc2libGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHBvaW50LnNldFZpc2libGUocG9pbnQudmlzaWJsZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSk7XG5cblx0XHR9LFxuXG5cblx0XHRzZWFyY2hQb2ludDogbm9vcCxcblxuXHRcdC8qKlxuXHRcdCAqIFV0aWxpdHkgZm9yIHNvcnRpbmcgZGF0YSBsYWJlbHNcblx0XHQgKi9cblx0XHRzb3J0QnlBbmdsZTogZnVuY3Rpb24gKHBvaW50cywgc2lnbikge1xuXHRcdFx0cG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEuYW5nbGUgIT09IHVuZGVmaW5lZCAmJiAoYi5hbmdsZSAtIGEuYW5nbGUpICogc2lnbjtcblx0XHRcdH0pO1xuXHRcdH0sXHRcdFxuXG5cdFx0LyoqXG5cdFx0ICogVXNlIGEgc2ltcGxlIHN5bWJvbCBmcm9tIExlZ2VuZFN5bWJvbE1peGluXG5cdFx0ICovXG5cdFx0ZHJhd0xlZ2VuZFN5bWJvbDogTGVnZW5kU3ltYm9sTWl4aW4uZHJhd1JlY3RhbmdsZSxcblxuXHRcdC8qKlxuXHRcdCAqIFVzZSB0aGUgZ2V0Q2VudGVyIG1ldGhvZCBmcm9tIGRyYXdMZWdlbmRTeW1ib2xcblx0XHQgKi9cblx0XHRnZXRDZW50ZXI6IENlbnRlcmVkU2VyaWVzTWl4aW4uZ2V0Q2VudGVyLFxuXG5cdFx0LyoqXG5cdFx0ICogUGllcyBkb24ndCBoYXZlIHBvaW50IG1hcmtlciBzeW1ib2xzXG5cdFx0ICovXG5cdFx0Z2V0U3ltYm9sOiBub29wXG5cblx0fTtcblx0UGllU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzLCBQaWVTZXJpZXMpO1xuXHRzZXJpZXNUeXBlcy5waWUgPSBQaWVTZXJpZXM7XG5cblx0LyoqXG5cdCAqIERyYXcgdGhlIGRhdGEgbGFiZWxzXG5cdCAqL1xuXHRTZXJpZXMucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRjdXJzb3IgPSBzZXJpZXNPcHRpb25zLmN1cnNvcixcblx0XHRcdG9wdGlvbnMgPSBzZXJpZXNPcHRpb25zLmRhdGFMYWJlbHMsXG5cdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0cG9pbnRPcHRpb25zLFxuXHRcdFx0Z2VuZXJhbE9wdGlvbnMsXG5cdFx0XHRoYXNSZW5kZXJlZCA9IHNlcmllcy5oYXNSZW5kZXJlZCB8fCAwLFxuXHRcdFx0c3RyLFxuXHRcdFx0ZGF0YUxhYmVsc0dyb3VwLFxuXHRcdFx0cmVuZGVyZXIgPSBzZXJpZXMuY2hhcnQucmVuZGVyZXI7XG5cblx0XHRpZiAob3B0aW9ucy5lbmFibGVkIHx8IHNlcmllcy5faGFzUG9pbnRMYWJlbHMpIHtcblxuXHRcdFx0Ly8gUHJvY2VzcyBkZWZhdWx0IGFsaWdubWVudCBvZiBkYXRhIGxhYmVscyBmb3IgY29sdW1uc1xuXHRcdFx0aWYgKHNlcmllcy5kbFByb2Nlc3NPcHRpb25zKSB7XG5cdFx0XHRcdHNlcmllcy5kbFByb2Nlc3NPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgYSBzZXBhcmF0ZSBncm91cCBmb3IgdGhlIGRhdGEgbGFiZWxzIHRvIGF2b2lkIHJvdGF0aW9uXG5cdFx0XHRkYXRhTGFiZWxzR3JvdXAgPSBzZXJpZXMucGxvdEdyb3VwKFxuXHRcdFx0XHQnZGF0YUxhYmVsc0dyb3VwJyxcblx0XHRcdFx0J2RhdGEtbGFiZWxzJyxcblx0XHRcdFx0b3B0aW9ucy5kZWZlciA/IEhJRERFTiA6IFZJU0lCTEUsXG5cdFx0XHRcdG9wdGlvbnMuekluZGV4IHx8IDZcblx0XHRcdCk7XG5cblx0XHRcdGlmIChwaWNrKG9wdGlvbnMuZGVmZXIsIHRydWUpKSB7XG5cdFx0XHRcdGRhdGFMYWJlbHNHcm91cC5hdHRyKHsgb3BhY2l0eTogK2hhc1JlbmRlcmVkIH0pOyAvLyAjMzMwMFxuXHRcdFx0XHRpZiAoIWhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdFx0YWRkRXZlbnQoc2VyaWVzLCAnYWZ0ZXJBbmltYXRlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKHNlcmllcy52aXNpYmxlKSB7IC8vICMzMDIzLCAjMzAyNFxuXHRcdFx0XHRcdFx0XHRkYXRhTGFiZWxzR3JvdXAuc2hvdygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsc0dyb3VwW3Nlcmllc09wdGlvbnMuYW5pbWF0aW9uID8gJ2FuaW1hdGUnIDogJ2F0dHInXSh7IG9wYWNpdHk6IDEgfSwgeyBkdXJhdGlvbjogMjAwIH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2UgdGhlIGxhYmVscyBmb3IgZWFjaCBwb2ludFxuXHRcdFx0Z2VuZXJhbE9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0ZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXG5cdFx0XHRcdHZhciBlbmFibGVkLFxuXHRcdFx0XHRcdGRhdGFMYWJlbCA9IHBvaW50LmRhdGFMYWJlbCxcblx0XHRcdFx0XHRsYWJlbENvbmZpZyxcblx0XHRcdFx0XHRhdHRyLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0cm90YXRpb24sXG5cdFx0XHRcdFx0Y29ubmVjdG9yID0gcG9pbnQuY29ubmVjdG9yLFxuXHRcdFx0XHRcdGlzTmV3ID0gdHJ1ZSxcblx0XHRcdFx0XHRzdHlsZSxcblx0XHRcdFx0XHRtb3JlU3R5bGUgPSB7fTtcblxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgaWYgZWFjaCBkYXRhIGxhYmVsIGlzIGVuYWJsZWRcblx0XHRcdFx0cG9pbnRPcHRpb25zID0gcG9pbnQuZGxPcHRpb25zIHx8IChwb2ludC5vcHRpb25zICYmIHBvaW50Lm9wdGlvbnMuZGF0YUxhYmVscyk7IC8vIGRsT3B0aW9ucyBpcyB1c2VkIGluIHRyZWVtYXBzXG5cdFx0XHRcdGVuYWJsZWQgPSBwaWNrKHBvaW50T3B0aW9ucyAmJiBwb2ludE9wdGlvbnMuZW5hYmxlZCwgZ2VuZXJhbE9wdGlvbnMuZW5hYmxlZCk7IC8vICMyMjgyXG5cblxuXHRcdFx0XHQvLyBJZiB0aGUgcG9pbnQgaXMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBkZXN0cm95IGl0LiAjNjc4LCAjODIwXG5cdFx0XHRcdGlmIChkYXRhTGFiZWwgJiYgIWVuYWJsZWQpIHtcblx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwgPSBkYXRhTGFiZWwuZGVzdHJveSgpO1xuXG5cdFx0XHRcdC8vIEluZGl2aWR1YWwgbGFiZWxzIGFyZSBkaXNhYmxlZCBpZiB0aGUgYXJlIGV4cGxpY2l0bHkgZGlzYWJsZWRcblx0XHRcdFx0Ly8gaW4gdGhlIHBvaW50IG9wdGlvbnMsIG9yIGlmIHRoZXkgZmFsbCBvdXRzaWRlIHRoZSBwbG90IGFyZWEuXG5cdFx0XHRcdH0gZWxzZSBpZiAoZW5hYmxlZCkge1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGluZGl2aWR1YWwgb3B0aW9ucyBzdHJ1Y3R1cmUgdGhhdCBjYW4gYmUgZXh0ZW5kZWQgd2l0aG91dFxuXHRcdFx0XHRcdC8vIGFmZmVjdGluZyBvdGhlcnNcblx0XHRcdFx0XHRvcHRpb25zID0gbWVyZ2UoZ2VuZXJhbE9wdGlvbnMsIHBvaW50T3B0aW9ucyk7XG5cdFx0XHRcdFx0c3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG5cdFx0XHRcdFx0cm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBzdHJpbmdcblx0XHRcdFx0XHRsYWJlbENvbmZpZyA9IHBvaW50LmdldExhYmVsQ29uZmlnKCk7XG5cdFx0XHRcdFx0c3RyID0gb3B0aW9ucy5mb3JtYXQgP1xuXHRcdFx0XHRcdFx0Zm9ybWF0KG9wdGlvbnMuZm9ybWF0LCBsYWJlbENvbmZpZykgOlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIuY2FsbChsYWJlbENvbmZpZywgb3B0aW9ucyk7XG5cblx0XHRcdFx0XHQvLyBEZXRlcm1pbmUgdGhlIGNvbG9yXG5cdFx0XHRcdFx0c3R5bGUuY29sb3IgPSBwaWNrKG9wdGlvbnMuY29sb3IsIHN0eWxlLmNvbG9yLCBzZXJpZXMuY29sb3IsICdibGFjaycpO1xuXG5cblx0XHRcdFx0XHQvLyB1cGRhdGUgZXhpc3RpbmcgbGFiZWxcblx0XHRcdFx0XHRpZiAoZGF0YUxhYmVsKSB7XG5cblx0XHRcdFx0XHRcdGlmIChkZWZpbmVkKHN0cikpIHtcblx0XHRcdFx0XHRcdFx0ZGF0YUxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dDogc3RyXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGlzTmV3ID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vICMxNDM3IC0gdGhlIGxhYmVsIGlzIHNob3duIGNvbmRpdGlvbmFsbHlcblx0XHRcdFx0XHRcdFx0cG9pbnQuZGF0YUxhYmVsID0gZGF0YUxhYmVsID0gZGF0YUxhYmVsLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0aWYgKGNvbm5lY3Rvcikge1xuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmNvbm5lY3RvciA9IGNvbm5lY3Rvci5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNyZWF0ZSBuZXcgbGFiZWxcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGRlZmluZWQoc3RyKSkge1xuXHRcdFx0XHRcdFx0YXR0ciA9IHtcblx0XHRcdFx0XHRcdFx0Ly9hbGlnbjogYWxpZ24sXG5cdFx0XHRcdFx0XHRcdGZpbGw6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRcdFx0XHRzdHJva2U6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdFx0XHRyOiBvcHRpb25zLmJvcmRlclJhZGl1cyB8fCAwLFxuXHRcdFx0XHRcdFx0XHRyb3RhdGlvbjogcm90YXRpb24sXG5cdFx0XHRcdFx0XHRcdHBhZGRpbmc6IG9wdGlvbnMucGFkZGluZyxcblx0XHRcdFx0XHRcdFx0ekluZGV4OiAxXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBHZXQgYXV0b21hdGVkIGNvbnRyYXN0IGNvbG9yXG5cdFx0XHRcdFx0XHRpZiAoc3R5bGUuY29sb3IgPT09ICdjb250cmFzdCcpIHtcblx0XHRcdFx0XHRcdFx0bW9yZVN0eWxlLmNvbG9yID0gb3B0aW9ucy5pbnNpZGUgfHwgb3B0aW9ucy5kaXN0YW5jZSA8IDAgfHwgISFzZXJpZXNPcHRpb25zLnN0YWNraW5nID8gXG5cdFx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuZ2V0Q29udHJhc3QocG9pbnQuY29sb3IgfHwgc2VyaWVzLmNvbG9yKSA6IFxuXHRcdFx0XHRcdFx0XHRcdCcjMDAwMDAwJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjdXJzb3IpIHtcblx0XHRcdFx0XHRcdFx0bW9yZVN0eWxlLmN1cnNvciA9IGN1cnNvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgdW51c2VkIGF0dHJpYnV0ZXMgKCM5NDcpXG5cdFx0XHRcdFx0XHRmb3IgKG5hbWUgaW4gYXR0cikge1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0cltuYW1lXSA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIGF0dHJbbmFtZV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsID0gcmVuZGVyZXJbcm90YXRpb24gPyAndGV4dCcgOiAnbGFiZWwnXSggLy8gbGFiZWxzIGRvbid0IHN1cHBvcnQgcm90YXRpb25cblx0XHRcdFx0XHRcdFx0c3RyLFxuXHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHQtOTk5LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zLnNoYXBlLFxuXHRcdFx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zLnVzZUhUTUxcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hdHRyKGF0dHIpXG5cdFx0XHRcdFx0XHQuY3NzKGV4dGVuZChzdHlsZSwgbW9yZVN0eWxlKSlcblx0XHRcdFx0XHRcdC5hZGQoZGF0YUxhYmVsc0dyb3VwKVxuXHRcdFx0XHRcdFx0LnNoYWRvdyhvcHRpb25zLnNoYWRvdyk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZGF0YUxhYmVsKSB7XG5cdFx0XHRcdFx0XHQvLyBOb3cgdGhlIGRhdGEgbGFiZWwgaXMgY3JlYXRlZCBhbmQgcGxhY2VkIGF0IDAsMCwgc28gd2UgbmVlZCB0byBhbGlnbiBpdFxuXHRcdFx0XHRcdFx0c2VyaWVzLmFsaWduRGF0YUxhYmVsKHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsIG51bGwsIGlzTmV3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQWxpZ24gZWFjaCBpbmRpdmlkdWFsIGRhdGEgbGFiZWxcblx0ICovXG5cdFNlcmllcy5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWwgPSBmdW5jdGlvbiAocG9pbnQsIGRhdGFMYWJlbCwgb3B0aW9ucywgYWxpZ25UbywgaXNOZXcpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdHBsb3RYID0gcGljayhwb2ludC5wbG90WCwgLTk5OSksXG5cdFx0XHRwbG90WSA9IHBpY2socG9pbnQucGxvdFksIC05OTkpLFxuXHRcdFx0YkJveCA9IGRhdGFMYWJlbC5nZXRCQm94KCksXG5cdFx0XHRiYXNlbGluZSA9IGNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKG9wdGlvbnMuc3R5bGUuZm9udFNpemUpLmIsXG5cdFx0XHRyb3RDb3JyLCAvLyByb3RhdGlvbiBjb3JyZWN0aW9uXG5cdFx0XHQvLyBNYXRoLnJvdW5kIGZvciByb3VuZGluZyBlcnJvcnMgKCMyNjgzKSwgYWxpZ25UbyB0byBhbGxvdyBjb2x1bW4gbGFiZWxzICgjMjcwMClcblx0XHRcdHZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgKHBvaW50LnNlcmllcy5mb3JjZURMIHx8IGNoYXJ0LmlzSW5zaWRlUGxvdChwbG90WCwgbWF0aFJvdW5kKHBsb3RZKSwgaW52ZXJ0ZWQpIHx8XG5cdFx0XHRcdChhbGlnblRvICYmIGNoYXJ0LmlzSW5zaWRlUGxvdChwbG90WCwgaW52ZXJ0ZWQgPyBhbGlnblRvLnggKyAxIDogYWxpZ25Uby55ICsgYWxpZ25Uby5oZWlnaHQgLSAxLCBpbnZlcnRlZCkpKSxcblx0XHRcdGFsaWduQXR0cjsgLy8gdGhlIGZpbmFsIHBvc2l0aW9uO1xuXG5cdFx0aWYgKHZpc2libGUpIHtcblxuXHRcdFx0Ly8gVGhlIGFsaWdubWVudCBib3ggaXMgYSBzaW5ndWxhciBwb2ludFxuXHRcdFx0YWxpZ25UbyA9IGV4dGVuZCh7XG5cdFx0XHRcdHg6IGludmVydGVkID8gY2hhcnQucGxvdFdpZHRoIC0gcGxvdFkgOiBwbG90WCxcblx0XHRcdFx0eTogbWF0aFJvdW5kKGludmVydGVkID8gY2hhcnQucGxvdEhlaWdodCAtIHBsb3RYIDogcGxvdFkpLFxuXHRcdFx0XHR3aWR0aDogMCxcblx0XHRcdFx0aGVpZ2h0OiAwXG5cdFx0XHR9LCBhbGlnblRvKTtcblxuXHRcdFx0Ly8gQWRkIHRoZSB0ZXh0IHNpemUgZm9yIGFsaWdubWVudCBjYWxjdWxhdGlvblxuXHRcdFx0ZXh0ZW5kKG9wdGlvbnMsIHtcblx0XHRcdFx0d2lkdGg6IGJCb3gud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogYkJveC5oZWlnaHRcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBbGxvdyBhIGhvb2sgZm9yIGNoYW5naW5nIGFsaWdubWVudCBpbiB0aGUgbGFzdCBtb21lbnQsIHRoZW4gZG8gdGhlIGFsaWdubWVudFxuXHRcdFx0aWYgKG9wdGlvbnMucm90YXRpb24pIHsgLy8gRmFuY3kgYm94IGFsaWdubWVudCBpc24ndCBzdXBwb3J0ZWQgZm9yIHJvdGF0ZWQgdGV4dFxuXHRcdFx0XHRyb3RDb3JyID0gY2hhcnQucmVuZGVyZXIucm90Q29ycihiYXNlbGluZSwgb3B0aW9ucy5yb3RhdGlvbik7IC8vICMzNzIzXG5cdFx0XHRcdGRhdGFMYWJlbFtpc05ldyA/ICdhdHRyJyA6ICdhbmltYXRlJ10oe1xuXHRcdFx0XHRcdFx0eDogYWxpZ25Uby54ICsgb3B0aW9ucy54ICsgYWxpZ25Uby53aWR0aCAvIDIgKyByb3RDb3JyLngsXG5cdFx0XHRcdFx0XHR5OiBhbGlnblRvLnkgKyBvcHRpb25zLnkgKyBhbGlnblRvLmhlaWdodCAvIDJcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hdHRyKHsgLy8gIzMwMDNcblx0XHRcdFx0XHRcdGFsaWduOiBvcHRpb25zLmFsaWduXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhTGFiZWwuYWxpZ24ob3B0aW9ucywgbnVsbCwgYWxpZ25Ubyk7XG5cdFx0XHRcdGFsaWduQXR0ciA9IGRhdGFMYWJlbC5hbGlnbkF0dHI7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGp1c3RpZnkgb3IgY3JvcFxuXHRcdFx0XHRpZiAocGljayhvcHRpb25zLm92ZXJmbG93LCAnanVzdGlmeScpID09PSAnanVzdGlmeScpIHtcblx0XHRcdFx0XHR0aGlzLmp1c3RpZnlEYXRhTGFiZWwoZGF0YUxhYmVsLCBvcHRpb25zLCBhbGlnbkF0dHIsIGJCb3gsIGFsaWduVG8sIGlzTmV3KTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHBpY2sob3B0aW9ucy5jcm9wLCB0cnVlKSkge1xuXHRcdFx0XHRcdC8vIE5vdyBjaGVjayB0aGF0IHRoZSBkYXRhIGxhYmVsIGlzIHdpdGhpbiB0aGUgcGxvdCBhcmVhXG5cdFx0XHRcdFx0dmlzaWJsZSA9IGNoYXJ0LmlzSW5zaWRlUGxvdChhbGlnbkF0dHIueCwgYWxpZ25BdHRyLnkpICYmIGNoYXJ0LmlzSW5zaWRlUGxvdChhbGlnbkF0dHIueCArIGJCb3gud2lkdGgsIGFsaWduQXR0ci55ICsgYkJveC5oZWlnaHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXaGVuIHdlJ3JlIHVzaW5nIGEgc2hhcGUsIG1ha2UgaXQgcG9zc2libGUgd2l0aCBhIGNvbm5lY3RvciBvciBhbiBhcnJvdyBwb2ludGluZyB0byB0aGllIHBvaW50XG5cdFx0XHRcdGlmIChvcHRpb25zLnNoYXBlKSB7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsLmF0dHIoe1xuXHRcdFx0XHRcdFx0YW5jaG9yWDogcG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0XHRhbmNob3JZOiBwb2ludC5wbG90WVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTaG93IG9yIGhpZGUgYmFzZWQgb24gdGhlIGZpbmFsIGFsaWduZWQgcG9zaXRpb25cblx0XHRpZiAoIXZpc2libGUpIHtcblx0XHRcdGRhdGFMYWJlbC5hdHRyKHsgeTogLTk5OSB9KTtcblx0XHRcdGRhdGFMYWJlbC5wbGFjZWQgPSBmYWxzZTsgLy8gZG9uJ3QgYW5pbWF0ZSBiYWNrIGluXG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIElmIGRhdGEgbGFiZWxzIGZhbGwgcGFydGx5IG91dHNpZGUgdGhlIHBsb3QgYXJlYSwgYWxpZ24gdGhlbSBiYWNrIGluLCBpbiBhIHdheSB0aGF0XG5cdCAqIGRvZXNuJ3QgaGlkZSB0aGUgcG9pbnQuXG5cdCAqL1xuXHRTZXJpZXMucHJvdG90eXBlLmp1c3RpZnlEYXRhTGFiZWwgPSBmdW5jdGlvbiAoZGF0YUxhYmVsLCBvcHRpb25zLCBhbGlnbkF0dHIsIGJCb3gsIGFsaWduVG8sIGlzTmV3KSB7XG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdGFsaWduID0gb3B0aW9ucy5hbGlnbixcblx0XHRcdHZlcnRpY2FsQWxpZ24gPSBvcHRpb25zLnZlcnRpY2FsQWxpZ24sXG5cdFx0XHRvZmYsXG5cdFx0XHRqdXN0aWZpZWQsXG5cdFx0XHRwYWRkaW5nID0gZGF0YUxhYmVsLmJveCA/IDAgOiAoZGF0YUxhYmVsLnBhZGRpbmcgfHwgMCk7XG5cblx0XHQvLyBPZmYgbGVmdFxuXHRcdG9mZiA9IGFsaWduQXR0ci54ICsgcGFkZGluZztcblx0XHRpZiAob2ZmIDwgMCkge1xuXHRcdFx0aWYgKGFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHRcdG9wdGlvbnMuYWxpZ24gPSAnbGVmdCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLnggPSAtb2ZmO1xuXHRcdFx0fVxuXHRcdFx0anVzdGlmaWVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPZmYgcmlnaHRcblx0XHRvZmYgPSBhbGlnbkF0dHIueCArIGJCb3gud2lkdGggLSBwYWRkaW5nO1xuXHRcdGlmIChvZmYgPiBjaGFydC5wbG90V2lkdGgpIHtcblx0XHRcdGlmIChhbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdG9wdGlvbnMuYWxpZ24gPSAncmlnaHQnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9ucy54ID0gY2hhcnQucGxvdFdpZHRoIC0gb2ZmO1xuXHRcdFx0fVxuXHRcdFx0anVzdGlmaWVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPZmYgdG9wXG5cdFx0b2ZmID0gYWxpZ25BdHRyLnkgKyBwYWRkaW5nO1xuXHRcdGlmIChvZmYgPCAwKSB7XG5cdFx0XHRpZiAodmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdFx0b3B0aW9ucy52ZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLnkgPSAtb2ZmO1xuXHRcdFx0fVxuXHRcdFx0anVzdGlmaWVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPZmYgYm90dG9tXG5cdFx0b2ZmID0gYWxpZ25BdHRyLnkgKyBiQm94LmhlaWdodCAtIHBhZGRpbmc7XG5cdFx0aWYgKG9mZiA+IGNoYXJ0LnBsb3RIZWlnaHQpIHtcblx0XHRcdGlmICh2ZXJ0aWNhbEFsaWduID09PSAndG9wJykge1xuXHRcdFx0XHRvcHRpb25zLnZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMueSA9IGNoYXJ0LnBsb3RIZWlnaHQgLSBvZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChqdXN0aWZpZWQpIHtcblx0XHRcdGRhdGFMYWJlbC5wbGFjZWQgPSAhaXNOZXc7XG5cdFx0XHRkYXRhTGFiZWwuYWxpZ24ob3B0aW9ucywgbnVsbCwgYWxpZ25Ubyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVycmlkZSB0aGUgYmFzZSBkcmF3RGF0YUxhYmVscyBtZXRob2QgYnkgcGllIHNwZWNpZmljIGZ1bmN0aW9uYWxpdHlcblx0ICovXG5cdGlmIChzZXJpZXNUeXBlcy5waWUpIHtcblx0XHRzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMuZGF0YUxhYmVscyxcblx0XHRcdFx0Y29ubmVjdG9yUGFkZGluZyA9IHBpY2sob3B0aW9ucy5jb25uZWN0b3JQYWRkaW5nLCAxMCksXG5cdFx0XHRcdGNvbm5lY3RvcldpZHRoID0gcGljayhvcHRpb25zLmNvbm5lY3RvcldpZHRoLCAxKSxcblx0XHRcdFx0cGxvdFdpZHRoID0gY2hhcnQucGxvdFdpZHRoLFxuXHRcdFx0XHRwbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCxcblx0XHRcdFx0Y29ubmVjdG9yLFxuXHRcdFx0XHRjb25uZWN0b3JQYXRoLFxuXHRcdFx0XHRzb2Z0Q29ubmVjdG9yID0gcGljayhvcHRpb25zLnNvZnRDb25uZWN0b3IsIHRydWUpLFxuXHRcdFx0XHRkaXN0YW5jZU9wdGlvbiA9IG9wdGlvbnMuZGlzdGFuY2UsXG5cdFx0XHRcdHNlcmllc0NlbnRlciA9IHNlcmllcy5jZW50ZXIsXG5cdFx0XHRcdHJhZGl1cyA9IHNlcmllc0NlbnRlclsyXSAvIDIsXG5cdFx0XHRcdGNlbnRlclkgPSBzZXJpZXNDZW50ZXJbMV0sXG5cdFx0XHRcdG91dHNpZGUgPSBkaXN0YW5jZU9wdGlvbiA+IDAsXG5cdFx0XHRcdGRhdGFMYWJlbCxcblx0XHRcdFx0ZGF0YUxhYmVsV2lkdGgsXG5cdFx0XHRcdGxhYmVsUG9zLFxuXHRcdFx0XHRsYWJlbEhlaWdodCxcblx0XHRcdFx0aGFsdmVzID0gWy8vIGRpdmlkZSB0aGUgcG9pbnRzIGludG8gcmlnaHQgYW5kIGxlZnQgaGFsdmVzIGZvciBhbnRpIGNvbGxpc2lvblxuXHRcdFx0XHRcdFtdLCAvLyByaWdodFxuXHRcdFx0XHRcdFtdICAvLyBsZWZ0XG5cdFx0XHRcdF0sXG5cdFx0XHRcdHgsXG5cdFx0XHRcdHksXG5cdFx0XHRcdHZpc2liaWxpdHksXG5cdFx0XHRcdHJhbmtBcnIsXG5cdFx0XHRcdGksXG5cdFx0XHRcdGosXG5cdFx0XHRcdG92ZXJmbG93ID0gWzAsIDAsIDAsIDBdLCAvLyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcblx0XHRcdFx0c29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGIueSAtIGEueTtcblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gZ2V0IG91dCBpZiBub3QgZW5hYmxlZFxuXHRcdFx0aWYgKCFzZXJpZXMudmlzaWJsZSB8fCAoIW9wdGlvbnMuZW5hYmxlZCAmJiAhc2VyaWVzLl9oYXNQb2ludExhYmVscykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBydW4gcGFyZW50IG1ldGhvZFxuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscy5hcHBseShzZXJpZXMpO1xuXG5cdFx0XHQvLyBhcnJhbmdlIHBvaW50cyBmb3IgZGV0ZWN0aW9uIGNvbGxpc2lvblxuXHRcdFx0ZWFjaChkYXRhLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCAmJiBwb2ludC52aXNpYmxlKSB7IC8vICM0MDcsICMyNTEwXG5cdFx0XHRcdFx0aGFsdmVzW3BvaW50LmhhbGZdLnB1c2gocG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0LyogTG9vcCBvdmVyIHRoZSBwb2ludHMgaW4gZWFjaCBoYWxmLCBzdGFydGluZyBmcm9tIHRoZSB0b3AgYW5kIGJvdHRvbVxuXHRcdFx0ICogb2YgdGhlIHBpZSB0byBkZXRlY3Qgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuXHRcdFx0ICovXG5cdFx0XHRpID0gMjtcblx0XHRcdHdoaWxlIChpLS0pIHtcblxuXHRcdFx0XHR2YXIgc2xvdHMgPSBbXSxcblx0XHRcdFx0XHRzbG90c0xlbmd0aCxcblx0XHRcdFx0XHR1c2VkU2xvdHMgPSBbXSxcblx0XHRcdFx0XHRwb2ludHMgPSBoYWx2ZXNbaV0sXG5cdFx0XHRcdFx0cG9zLFxuXHRcdFx0XHRcdGJvdHRvbSxcblx0XHRcdFx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuXHRcdFx0XHRcdHNsb3RJbmRleDtcblxuXHRcdFx0XHRpZiAoIWxlbmd0aCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU29ydCBieSBhbmdsZVxuXHRcdFx0XHRzZXJpZXMuc29ydEJ5QW5nbGUocG9pbnRzLCBpIC0gMC41KTtcblxuXHRcdFx0XHQvLyBBc3N1bWUgZXF1YWwgbGFiZWwgaGVpZ2h0cyBvbiBlaXRoZXIgaGVtaXNwaGVyZSAoIzI2MzApXG5cdFx0XHRcdGogPSBsYWJlbEhlaWdodCA9IDA7XG5cdFx0XHRcdHdoaWxlICghbGFiZWxIZWlnaHQgJiYgcG9pbnRzW2pdKSB7IC8vICMxNTY5XG5cdFx0XHRcdFx0bGFiZWxIZWlnaHQgPSBwb2ludHNbal0gJiYgcG9pbnRzW2pdLmRhdGFMYWJlbCAmJiAocG9pbnRzW2pdLmRhdGFMYWJlbC5nZXRCQm94KCkuaGVpZ2h0IHx8IDIxKTsgLy8gMjEgaXMgZm9yICM5Njhcblx0XHRcdFx0XHRqKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPbmx5IGRvIGFudGktY29sbGlzaW9uIHdoZW4gd2UgYXJlIG91dHNpZGUgdGhlIHBpZSBhbmQgaGF2ZSBjb25uZWN0b3JzICgjODU2KVxuXHRcdFx0XHRpZiAoZGlzdGFuY2VPcHRpb24gPiAwKSB7XG5cblx0XHRcdFx0XHQvLyBCdWlsZCB0aGUgc2xvdHNcblx0XHRcdFx0XHRib3R0b20gPSBtYXRoTWluKGNlbnRlclkgKyByYWRpdXMgKyBkaXN0YW5jZU9wdGlvbiwgY2hhcnQucGxvdEhlaWdodCk7XG5cdFx0XHRcdFx0Zm9yIChwb3MgPSBtYXRoTWF4KDAsIGNlbnRlclkgLSByYWRpdXMgLSBkaXN0YW5jZU9wdGlvbik7IHBvcyA8PSBib3R0b207IHBvcyArPSBsYWJlbEhlaWdodCkge1xuXHRcdFx0XHRcdFx0c2xvdHMucHVzaChwb3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzbG90c0xlbmd0aCA9IHNsb3RzLmxlbmd0aDtcblxuXG5cdFx0XHRcdFx0LyogVmlzdWFsaXplIHRoZSBzbG90c1xuXHRcdFx0XHRcdGlmICghc2VyaWVzLnNsb3RFbGVtZW50cykge1xuXHRcdFx0XHRcdFx0c2VyaWVzLnNsb3RFbGVtZW50cyA9IFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0c2VyaWVzLnNsb3RFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0uZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRzZXJpZXMuc2xvdEVsZW1lbnRzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0c2xvdHMuZm9yRWFjaChmdW5jdGlvbiAocG9zLCBubykge1xuXHRcdFx0XHRcdFx0dmFyIHNsb3RYID0gc2VyaWVzLmdldFgocG9zLCBpKSArIGNoYXJ0LnBsb3RMZWZ0IC0gKGkgPyAxMDAgOiAwKSxcblx0XHRcdFx0XHRcdFx0c2xvdFkgPSBwb3MgKyBjaGFydC5wbG90VG9wO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAoIWlzTmFOKHNsb3RYKSkge1xuXHRcdFx0XHRcdFx0XHRzZXJpZXMuc2xvdEVsZW1lbnRzLnB1c2goY2hhcnQucmVuZGVyZXIucmVjdChzbG90WCwgc2xvdFkgLSA3LCAxMDAsIGxhYmVsSGVpZ2h0LCAxKVxuXHRcdFx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0c3Ryb2tlOiAnc2lsdmVyJyxcblx0XHRcdFx0XHRcdFx0XHRcdGZpbGw6ICdyZ2JhKDAsMCwyNTUsMC4xKSdcblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdC5hZGQoKSk7XG5cdFx0XHRcdFx0XHRcdHNlcmllcy5zbG90RWxlbWVudHMucHVzaChjaGFydC5yZW5kZXJlci50ZXh0KCdTbG90ICcrIG5vLCBzbG90WCwgc2xvdFkgKyA0KVxuXHRcdFx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpbGw6ICdzaWx2ZXInXG5cdFx0XHRcdFx0XHRcdFx0fSkuYWRkKCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdC8vICovXG5cblx0XHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbW9yZSB2YWx1ZXMgdGhhbiBhdmFpbGFibGUgc2xvdHMsIHJlbW92ZSBsb3dlc3QgdmFsdWVzXG5cdFx0XHRcdFx0aWYgKGxlbmd0aCA+IHNsb3RzTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBjcmVhdGUgYW4gYXJyYXkgZm9yIHNvcnRpbmcgYW5kIHJhbmtpbmcgdGhlIHBvaW50cyB3aXRoaW4gZWFjaCBxdWFydGVyXG5cdFx0XHRcdFx0XHRyYW5rQXJyID0gW10uY29uY2F0KHBvaW50cyk7XG5cdFx0XHRcdFx0XHRyYW5rQXJyLnNvcnQoc29ydCk7XG5cdFx0XHRcdFx0XHRqID0gbGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGotLSkge1xuXHRcdFx0XHRcdFx0XHRyYW5rQXJyW2pdLnJhbmsgPSBqO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aiA9IGxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChqLS0pIHtcblx0XHRcdFx0XHRcdFx0aWYgKHBvaW50c1tqXS5yYW5rID49IHNsb3RzTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRzLnNwbGljZShqLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBUaGUgbGFiZWwgZ29lcyB0byB0aGUgbmVhcmVzdCBvcGVuIHNsb3QsIGJ1dCBub3QgY2xvc2VyIHRvIHRoZSBlZGdlIHRoYW5cblx0XHRcdFx0XHQvLyB0aGUgbGFiZWwncyBpbmRleC5cblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcblxuXHRcdFx0XHRcdFx0cG9pbnQgPSBwb2ludHNbal07XG5cdFx0XHRcdFx0XHRsYWJlbFBvcyA9IHBvaW50LmxhYmVsUG9zO1xuXG5cdFx0XHRcdFx0XHR2YXIgY2xvc2VzdCA9IDk5OTksXG5cdFx0XHRcdFx0XHRcdGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHRzbG90STtcblxuXHRcdFx0XHRcdFx0Ly8gZmluZCB0aGUgY2xvc2VzdCBzbG90IGluZGV4XG5cdFx0XHRcdFx0XHRmb3IgKHNsb3RJID0gMDsgc2xvdEkgPCBzbG90c0xlbmd0aDsgc2xvdEkrKykge1xuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZSA9IG1hdGhBYnMoc2xvdHNbc2xvdEldIC0gbGFiZWxQb3NbMV0pO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPCBjbG9zZXN0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdCA9IGRpc3RhbmNlO1xuXHRcdFx0XHRcdFx0XHRcdHNsb3RJbmRleCA9IHNsb3RJO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoYXQgc2xvdCBpbmRleCBpcyBjbG9zZXIgdG8gdGhlIGVkZ2VzIG9mIHRoZSBzbG90cywgbW92ZSBpdFxuXHRcdFx0XHRcdFx0Ly8gdG8gdGhlIGNsb3Nlc3QgYXBwcm9wcmlhdGUgc2xvdFxuXHRcdFx0XHRcdFx0aWYgKHNsb3RJbmRleCA8IGogJiYgc2xvdHNbal0gIT09IG51bGwpIHsgLy8gY2x1c3RlciBhdCB0aGUgdG9wXG5cdFx0XHRcdFx0XHRcdHNsb3RJbmRleCA9IGo7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNsb3RzTGVuZ3RoICA8IGxlbmd0aCAtIGogKyBzbG90SW5kZXggJiYgc2xvdHNbal0gIT09IG51bGwpIHsgLy8gY2x1c3RlciBhdCB0aGUgYm90dG9tXG5cdFx0XHRcdFx0XHRcdHNsb3RJbmRleCA9IHNsb3RzTGVuZ3RoIC0gbGVuZ3RoICsgajtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHNsb3RzW3Nsb3RJbmRleF0gPT09IG51bGwpIHsgLy8gbWFrZSBzdXJlIGl0IGlzIG5vdCB0YWtlblxuXHRcdFx0XHRcdFx0XHRcdHNsb3RJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBTbG90IGlzIHRha2VuLCBmaW5kIG5leHQgZnJlZSBzbG90IGJlbG93LiBJbiB0aGUgbmV4dCBydW4sIHRoZSBuZXh0IHNsaWNlIHdpbGwgZmluZCB0aGVcblx0XHRcdFx0XHRcdFx0Ly8gc2xvdCBhYm92ZSB0aGVzZSwgYmVjYXVzZSBpdCBpcyB0aGUgY2xvc2VzdCBvbmVcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHNsb3RzW3Nsb3RJbmRleF0gPT09IG51bGwpIHsgLy8gbWFrZSBzdXJlIGl0IGlzIG5vdCB0YWtlblxuXHRcdFx0XHRcdFx0XHRcdHNsb3RJbmRleCsrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHVzZWRTbG90cy5wdXNoKHsgaTogc2xvdEluZGV4LCB5OiBzbG90c1tzbG90SW5kZXhdIH0pO1xuXHRcdFx0XHRcdFx0c2xvdHNbc2xvdEluZGV4XSA9IG51bGw7IC8vIG1hcmsgYXMgdGFrZW5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc29ydCB0aGVtIGluIG9yZGVyIHRvIGZpbGwgaW4gZnJvbSB0aGUgdG9wXG5cdFx0XHRcdFx0dXNlZFNsb3RzLnNvcnQoc29ydCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3cgdGhlIHVzZWQgc2xvdHMgYXJlIHNvcnRlZCwgZmlsbCB0aGVtIHVwIHNlcXVlbnRpYWxseVxuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcblxuXHRcdFx0XHRcdHZhciBzbG90LCBuYXR1cmFsWTtcblxuXHRcdFx0XHRcdHBvaW50ID0gcG9pbnRzW2pdO1xuXHRcdFx0XHRcdGxhYmVsUG9zID0gcG9pbnQubGFiZWxQb3M7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsO1xuXHRcdFx0XHRcdHZpc2liaWxpdHkgPSBwb2ludC52aXNpYmxlID09PSBmYWxzZSA/IEhJRERFTiA6IFZJU0lCTEU7XG5cdFx0XHRcdFx0bmF0dXJhbFkgPSBsYWJlbFBvc1sxXTtcblxuXHRcdFx0XHRcdGlmIChkaXN0YW5jZU9wdGlvbiA+IDApIHtcblx0XHRcdFx0XHRcdHNsb3QgPSB1c2VkU2xvdHMucG9wKCk7XG5cdFx0XHRcdFx0XHRzbG90SW5kZXggPSBzbG90Lmk7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBzbG90IG5leHQgdG8gY3VycnJlbnQgc2xvdCBpcyBmcmVlLCB0aGUgeSB2YWx1ZSBpcyBhbGxvd2VkXG5cdFx0XHRcdFx0XHQvLyB0byBmYWxsIGJhY2sgdG8gdGhlIG5hdHVyYWwgcG9zaXRpb25cblx0XHRcdFx0XHRcdHkgPSBzbG90Lnk7XG5cdFx0XHRcdFx0XHRpZiAoKG5hdHVyYWxZID4geSAmJiBzbG90c1tzbG90SW5kZXggKyAxXSAhPT0gbnVsbCkgfHxcblx0XHRcdFx0XHRcdFx0XHQobmF0dXJhbFkgPCB5ICYmICBzbG90c1tzbG90SW5kZXggLSAxXSAhPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRcdFx0eSA9IG1hdGhNaW4obWF0aE1heCgwLCBuYXR1cmFsWSksIGNoYXJ0LnBsb3RIZWlnaHQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHkgPSBuYXR1cmFsWTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBnZXQgdGhlIHggLSB1c2UgdGhlIG5hdHVyYWwgeCBwb3NpdGlvbiBmb3IgZmlyc3QgYW5kIGxhc3Qgc2xvdCwgdG8gcHJldmVudCB0aGUgdG9wXG5cdFx0XHRcdFx0Ly8gYW5kIGJvdHRvbiBzbGljZSBjb25uZWN0b3JzIGZyb20gdG91Y2hpbmcgZWFjaCBvdGhlciBvbiBlaXRoZXIgc2lkZVxuXHRcdFx0XHRcdHggPSBvcHRpb25zLmp1c3RpZnkgP1xuXHRcdFx0XHRcdFx0c2VyaWVzQ2VudGVyWzBdICsgKGkgPyAtMSA6IDEpICogKHJhZGl1cyArIGRpc3RhbmNlT3B0aW9uKSA6XG5cdFx0XHRcdFx0XHRzZXJpZXMuZ2V0WCh5ID09PSBjZW50ZXJZIC0gcmFkaXVzIC0gZGlzdGFuY2VPcHRpb24gfHwgeSA9PT0gY2VudGVyWSArIHJhZGl1cyArIGRpc3RhbmNlT3B0aW9uID8gbmF0dXJhbFkgOiB5LCBpKTtcblxuXG5cdFx0XHRcdFx0Ly8gUmVjb3JkIHRoZSBwbGFjZW1lbnQgYW5kIHZpc2liaWxpdHlcblx0XHRcdFx0XHRkYXRhTGFiZWwuX2F0dHIgPSB7XG5cdFx0XHRcdFx0XHR2aXNpYmlsaXR5OiB2aXNpYmlsaXR5LFxuXHRcdFx0XHRcdFx0YWxpZ246IGxhYmVsUG9zWzZdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRkYXRhTGFiZWwuX3BvcyA9IHtcblx0XHRcdFx0XHRcdHg6IHggKyBvcHRpb25zLnggK1xuXHRcdFx0XHRcdFx0XHQoeyBsZWZ0OiBjb25uZWN0b3JQYWRkaW5nLCByaWdodDogLWNvbm5lY3RvclBhZGRpbmcgfVtsYWJlbFBvc1s2XV0gfHwgMCksXG5cdFx0XHRcdFx0XHR5OiB5ICsgb3B0aW9ucy55IC0gMTAgLy8gMTAgaXMgZm9yIHRoZSBiYXNlbGluZSAobGFiZWwgdnMgdGV4dClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGRhdGFMYWJlbC5jb25uWCA9IHg7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsLmNvbm5ZID0geTtcblxuXG5cdFx0XHRcdFx0Ly8gRGV0ZWN0IG92ZXJmbG93aW5nIGRhdGEgbGFiZWxzXG5cdFx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaXplID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWxXaWR0aCA9IGRhdGFMYWJlbC53aWR0aDtcblx0XHRcdFx0XHRcdC8vIE92ZXJmbG93IGxlZnRcblx0XHRcdFx0XHRcdGlmICh4IC0gZGF0YUxhYmVsV2lkdGggPCBjb25uZWN0b3JQYWRkaW5nKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJmbG93WzNdID0gbWF0aE1heChtYXRoUm91bmQoZGF0YUxhYmVsV2lkdGggLSB4ICsgY29ubmVjdG9yUGFkZGluZyksIG92ZXJmbG93WzNdKTtcblxuXHRcdFx0XHRcdFx0Ly8gT3ZlcmZsb3cgcmlnaHRcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeCArIGRhdGFMYWJlbFdpZHRoID4gcGxvdFdpZHRoIC0gY29ubmVjdG9yUGFkZGluZykge1xuXHRcdFx0XHRcdFx0XHRvdmVyZmxvd1sxXSA9IG1hdGhNYXgobWF0aFJvdW5kKHggKyBkYXRhTGFiZWxXaWR0aCAtIHBsb3RXaWR0aCArIGNvbm5lY3RvclBhZGRpbmcpLCBvdmVyZmxvd1sxXSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE92ZXJmbG93IHRvcFxuXHRcdFx0XHRcdFx0aWYgKHkgLSBsYWJlbEhlaWdodCAvIDIgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJmbG93WzBdID0gbWF0aE1heChtYXRoUm91bmQoLXkgKyBsYWJlbEhlaWdodCAvIDIpLCBvdmVyZmxvd1swXSk7XG5cblx0XHRcdFx0XHRcdC8vIE92ZXJmbG93IGxlZnRcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeSArIGxhYmVsSGVpZ2h0IC8gMiA+IHBsb3RIZWlnaHQpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmZsb3dbMl0gPSBtYXRoTWF4KG1hdGhSb3VuZCh5ICsgbGFiZWxIZWlnaHQgLyAyIC0gcGxvdEhlaWdodCksIG92ZXJmbG93WzJdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gZm9yIGVhY2ggcG9pbnRcblx0XHRcdH0gLy8gZm9yIGVhY2ggaGFsZlxuXG5cdFx0XHQvLyBEbyBub3QgYXBwbHkgdGhlIGZpbmFsIHBsYWNlbWVudCBhbmQgZHJhdyB0aGUgY29ubmVjdG9ycyB1bnRpbCB3ZSBoYXZlIHZlcmlmaWVkXG5cdFx0XHQvLyB0aGF0IGxhYmVscyBhcmUgbm90IHNwaWxsaW5nIG92ZXIuXG5cdFx0XHRpZiAoYXJyYXlNYXgob3ZlcmZsb3cpID09PSAwIHx8IHRoaXMudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3cob3ZlcmZsb3cpKSB7XG5cblx0XHRcdFx0Ly8gUGxhY2UgdGhlIGxhYmVscyBpbiB0aGUgZmluYWwgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5wbGFjZURhdGFMYWJlbHMoKTtcblxuXHRcdFx0XHQvLyBEcmF3IHRoZSBjb25uZWN0b3JzXG5cdFx0XHRcdGlmIChvdXRzaWRlICYmIGNvbm5lY3RvcldpZHRoKSB7XG5cdFx0XHRcdFx0ZWFjaCh0aGlzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0XHRjb25uZWN0b3IgPSBwb2ludC5jb25uZWN0b3I7XG5cdFx0XHRcdFx0XHRsYWJlbFBvcyA9IHBvaW50LmxhYmVsUG9zO1xuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsO1xuXG5cdFx0XHRcdFx0XHRpZiAoZGF0YUxhYmVsICYmIGRhdGFMYWJlbC5fcG9zKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2liaWxpdHkgPSBkYXRhTGFiZWwuX2F0dHIudmlzaWJpbGl0eTtcblx0XHRcdFx0XHRcdFx0eCA9IGRhdGFMYWJlbC5jb25uWDtcblx0XHRcdFx0XHRcdFx0eSA9IGRhdGFMYWJlbC5jb25uWTtcblx0XHRcdFx0XHRcdFx0Y29ubmVjdG9yUGF0aCA9IHNvZnRDb25uZWN0b3IgPyBbXG5cdFx0XHRcdFx0XHRcdFx0TSxcblx0XHRcdFx0XHRcdFx0XHR4ICsgKGxhYmVsUG9zWzZdID09PSAnbGVmdCcgPyA1IDogLTUpLCB5LCAvLyBlbmQgb2YgdGhlIHN0cmluZyBhdCB0aGUgbGFiZWxcblx0XHRcdFx0XHRcdFx0XHQnQycsXG5cdFx0XHRcdFx0XHRcdFx0eCwgeSwgLy8gZmlyc3QgYnJlYWssIG5leHQgdG8gdGhlIGxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGxhYmVsUG9zWzJdIC0gbGFiZWxQb3NbNF0sIDIgKiBsYWJlbFBvc1szXSAtIGxhYmVsUG9zWzVdLFxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsUG9zWzJdLCBsYWJlbFBvc1szXSwgLy8gc2Vjb25kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFBvc1s0XSwgbGFiZWxQb3NbNV0gLy8gYmFzZVxuXHRcdFx0XHRcdFx0XHRdIDogW1xuXHRcdFx0XHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0XHRcdFx0eCArIChsYWJlbFBvc1s2XSA9PT0gJ2xlZnQnID8gNSA6IC01KSwgeSwgLy8gZW5kIG9mIHRoZSBzdHJpbmcgYXQgdGhlIGxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFBvc1syXSwgbGFiZWxQb3NbM10sIC8vIHNlY29uZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWxQb3NbNF0sIGxhYmVsUG9zWzVdIC8vIGJhc2Vcblx0XHRcdFx0XHRcdFx0XTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoY29ubmVjdG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29ubmVjdG9yLmFuaW1hdGUoeyBkOiBjb25uZWN0b3JQYXRoIH0pO1xuXHRcdFx0XHRcdFx0XHRcdGNvbm5lY3Rvci5hdHRyKCd2aXNpYmlsaXR5JywgdmlzaWJpbGl0eSk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5jb25uZWN0b3IgPSBjb25uZWN0b3IgPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIucGF0aChjb25uZWN0b3JQYXRoKS5hdHRyKHtcblx0XHRcdFx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBjb25uZWN0b3JXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9ucy5jb25uZWN0b3JDb2xvciB8fCBwb2ludC5jb2xvciB8fCAnIzYwNjA2MCcsXG5cdFx0XHRcdFx0XHRcdFx0XHR2aXNpYmlsaXR5OiB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHQvL3pJbmRleDogMCAvLyAjMjcyMiAocmV2ZXJzZWQpXG5cdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5kYXRhTGFiZWxzR3JvdXApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbm5lY3Rvcikge1xuXHRcdFx0XHRcdFx0XHRwb2ludC5jb25uZWN0b3IgPSBjb25uZWN0b3IuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvKipcblx0XHQgKiBQZXJmb3JtIHRoZSBmaW5hbCBwbGFjZW1lbnQgb2YgdGhlIGRhdGEgbGFiZWxzIGFmdGVyIHdlIGhhdmUgdmVyaWZpZWQgdGhhdCB0aGV5XG5cdFx0ICogZmFsbCB3aXRoaW4gdGhlIHBsb3QgYXJlYS5cblx0XHQgKi9cblx0XHRzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLnBsYWNlRGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGVhY2godGhpcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHR2YXIgZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsLFxuXHRcdFx0XHRcdF9wb3M7XG5cblx0XHRcdFx0aWYgKGRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdF9wb3MgPSBkYXRhTGFiZWwuX3Bvcztcblx0XHRcdFx0XHRpZiAoX3Bvcykge1xuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsLmF0dHIoZGF0YUxhYmVsLl9hdHRyKTtcblx0XHRcdFx0XHRcdGRhdGFMYWJlbFtkYXRhTGFiZWwubW92ZWQgPyAnYW5pbWF0ZScgOiAnYXR0ciddKF9wb3MpO1xuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsLm1vdmVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsLmF0dHIoeyB5OiAtOTk5IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdHNlcmllc1R5cGVzLnBpZS5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWwgPSAgbm9vcDtcblxuXHRcdC8qKlxuXHRcdCAqIFZlcmlmeSB3aGV0aGVyIHRoZSBkYXRhIGxhYmVscyBhcmUgYWxsb3dlZCB0byBkcmF3LCBvciB3ZSBzaG91bGQgcnVuIG1vcmUgdHJhbnNsYXRpb24gYW5kIGRhdGFcblx0XHQgKiBsYWJlbCBwb3NpdGlvbmluZyB0byBrZWVwIHRoZW0gaW5zaWRlIHRoZSBwbG90IGFyZWEuIFJldHVybnMgdHJ1ZSB3aGVuIGRhdGEgbGFiZWxzIGFyZSByZWFkeVxuXHRcdCAqIHRvIGRyYXcuXG5cdFx0ICovXG5cdFx0c2VyaWVzVHlwZXMucGllLnByb3RvdHlwZS52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdyA9IGZ1bmN0aW9uIChvdmVyZmxvdykge1xuXG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5jZW50ZXIsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGNlbnRlck9wdGlvbiA9IG9wdGlvbnMuY2VudGVyLFxuXHRcdFx0XHRtaW5TaXplID0gb3B0aW9ucy5taW5TaXplIHx8IDgwLFxuXHRcdFx0XHRuZXdTaXplID0gbWluU2l6ZSxcblx0XHRcdFx0cmV0O1xuXG5cdFx0XHQvLyBIYW5kbGUgaG9yaXpvbnRhbCBzaXplIGFuZCBjZW50ZXJcblx0XHRcdGlmIChjZW50ZXJPcHRpb25bMF0gIT09IG51bGwpIHsgLy8gRml4ZWQgY2VudGVyXG5cdFx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KGNlbnRlclsyXSAtIG1hdGhNYXgob3ZlcmZsb3dbMV0sIG92ZXJmbG93WzNdKSwgbWluU2l6ZSk7XG5cblx0XHRcdH0gZWxzZSB7IC8vIEF1dG8gY2VudGVyXG5cdFx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KFxuXHRcdFx0XHRcdGNlbnRlclsyXSAtIG92ZXJmbG93WzFdIC0gb3ZlcmZsb3dbM10sIC8vIGhvcml6b250YWwgb3ZlcmZsb3dcblx0XHRcdFx0XHRtaW5TaXplXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNlbnRlclswXSArPSAob3ZlcmZsb3dbM10gLSBvdmVyZmxvd1sxXSkgLyAyOyAvLyBob3Jpem9udGFsIGNlbnRlclxuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgdmVydGljYWwgc2l6ZSBhbmQgY2VudGVyXG5cdFx0XHRpZiAoY2VudGVyT3B0aW9uWzFdICE9PSBudWxsKSB7IC8vIEZpeGVkIGNlbnRlclxuXHRcdFx0XHRuZXdTaXplID0gbWF0aE1heChtYXRoTWluKG5ld1NpemUsIGNlbnRlclsyXSAtIG1hdGhNYXgob3ZlcmZsb3dbMF0sIG92ZXJmbG93WzJdKSksIG1pblNpemUpO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyBBdXRvIGNlbnRlclxuXHRcdFx0XHRuZXdTaXplID0gbWF0aE1heChcblx0XHRcdFx0XHRtYXRoTWluKFxuXHRcdFx0XHRcdFx0bmV3U2l6ZSxcblx0XHRcdFx0XHRcdGNlbnRlclsyXSAtIG92ZXJmbG93WzBdIC0gb3ZlcmZsb3dbMl0gLy8gdmVydGljYWwgb3ZlcmZsb3dcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdG1pblNpemVcblx0XHRcdFx0KTtcblx0XHRcdFx0Y2VudGVyWzFdICs9IChvdmVyZmxvd1swXSAtIG92ZXJmbG93WzJdKSAvIDI7IC8vIHZlcnRpY2FsIGNlbnRlclxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgc2l6ZSBtdXN0IGJlIGRlY3JlYXNlZCwgd2UgbmVlZCB0byBydW4gdHJhbnNsYXRlIGFuZCBkcmF3RGF0YUxhYmVscyBhZ2FpblxuXHRcdFx0aWYgKG5ld1NpemUgPCBjZW50ZXJbMl0pIHtcblx0XHRcdFx0Y2VudGVyWzJdID0gbmV3U2l6ZTtcblx0XHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRcdFx0ZWFjaCh0aGlzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdFx0cG9pbnQuZGF0YUxhYmVsLl9wb3MgPSBudWxsOyAvLyByZXNldFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHRoaXMuZHJhd0RhdGFMYWJlbHMpIHtcblx0XHRcdFx0XHR0aGlzLmRyYXdEYXRhTGFiZWxzKCk7XG5cdFx0XHRcdH1cblx0XHRcdC8vIEVsc2UsIHJldHVybiB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIHBpZSBhbmQgaXRzIGxhYmVscyBpcyB3aXRoaW4gdGhlIHBsb3QgYXJlYVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fTtcblx0fVxuXG5cdGlmIChzZXJpZXNUeXBlcy5jb2x1bW4pIHtcblxuXHRcdC8qKlxuXHRcdCAqIE92ZXJyaWRlIHRoZSBiYXNpYyBkYXRhIGxhYmVsIGFsaWdubWVudCBieSBhZGp1c3RpbmcgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29sdW1uXG5cdFx0ICovXG5cdFx0c2VyaWVzVHlwZXMuY29sdW1uLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9IGZ1bmN0aW9uIChwb2ludCwgZGF0YUxhYmVsLCBvcHRpb25zLCAgYWxpZ25UbywgaXNOZXcpIHtcblx0XHRcdHZhciBpbnZlcnRlZCA9IHRoaXMuY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0ZGxCb3ggPSBwb2ludC5kbEJveCB8fCBwb2ludC5zaGFwZUFyZ3MsIC8vIGRhdGEgbGFiZWwgYm94IGZvciBhbGlnbm1lbnRcblx0XHRcdFx0YmVsb3cgPSBwb2ludC5iZWxvdyB8fCAocG9pbnQucGxvdFkgPiBwaWNrKHRoaXMudHJhbnNsYXRlZFRocmVzaG9sZCwgc2VyaWVzLnlBeGlzLmxlbikpLFxuXHRcdFx0XHRpbnNpZGUgPSBwaWNrKG9wdGlvbnMuaW5zaWRlLCAhIXRoaXMub3B0aW9ucy5zdGFja2luZyk7IC8vIGRyYXcgaXQgaW5zaWRlIHRoZSBib3g/XG5cblx0XHRcdC8vIEFsaWduIHRvIHRoZSBjb2x1bW4gaXRzZWxmLCBvciB0aGUgdG9wIG9mIGl0XG5cdFx0XHRpZiAoZGxCb3gpIHsgLy8gQXJlYSByYW5nZSB1c2VzIHRoaXMgbWV0aG9kIGJ1dCBub3QgYWxpZ25Ub1xuXHRcdFx0XHRhbGlnblRvID0gbWVyZ2UoZGxCb3gpO1xuXG5cdFx0XHRcdGlmIChpbnZlcnRlZCkge1xuXHRcdFx0XHRcdGFsaWduVG8gPSB7XG5cdFx0XHRcdFx0XHR4OiBzZXJpZXMueUF4aXMubGVuIC0gYWxpZ25Uby55IC0gYWxpZ25Uby5oZWlnaHQsXG5cdFx0XHRcdFx0XHR5OiBzZXJpZXMueEF4aXMubGVuIC0gYWxpZ25Uby54IC0gYWxpZ25Uby53aWR0aCxcblx0XHRcdFx0XHRcdHdpZHRoOiBhbGlnblRvLmhlaWdodCxcblx0XHRcdFx0XHRcdGhlaWdodDogYWxpZ25Uby53aWR0aFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb21wdXRlIHRoZSBhbGlnbm1lbnQgYm94XG5cdFx0XHRcdGlmICghaW5zaWRlKSB7XG5cdFx0XHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdFx0XHRhbGlnblRvLnggKz0gYmVsb3cgPyAwIDogYWxpZ25Uby53aWR0aDtcblx0XHRcdFx0XHRcdGFsaWduVG8ud2lkdGggPSAwO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhbGlnblRvLnkgKz0gYmVsb3cgPyBhbGlnblRvLmhlaWdodCA6IDA7XG5cdFx0XHRcdFx0XHRhbGlnblRvLmhlaWdodCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gV2hlbiBhbGlnbm1lbnQgaXMgdW5kZWZpbmVkICh0eXBpY2FsbHkgY29sdW1ucyBhbmQgYmFycyksIGRpc3BsYXkgdGhlIGluZGl2aWR1YWxcblx0XHRcdC8vIHBvaW50IGJlbG93IG9yIGFib3ZlIHRoZSBwb2ludCBkZXBlbmRpbmcgb24gdGhlIHRocmVzaG9sZFxuXHRcdFx0b3B0aW9ucy5hbGlnbiA9IHBpY2soXG5cdFx0XHRcdG9wdGlvbnMuYWxpZ24sXG5cdFx0XHRcdCFpbnZlcnRlZCB8fCBpbnNpZGUgPyAnY2VudGVyJyA6IGJlbG93ID8gJ3JpZ2h0JyA6ICdsZWZ0J1xuXHRcdFx0KTtcblx0XHRcdG9wdGlvbnMudmVydGljYWxBbGlnbiA9IHBpY2soXG5cdFx0XHRcdG9wdGlvbnMudmVydGljYWxBbGlnbixcblx0XHRcdFx0aW52ZXJ0ZWQgfHwgaW5zaWRlID8gJ21pZGRsZScgOiBiZWxvdyA/ICd0b3AnIDogJ2JvdHRvbSdcblx0XHRcdCk7XG5cblx0XHRcdC8vIENhbGwgdGhlIHBhcmVudCBtZXRob2Rcblx0XHRcdFNlcmllcy5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWwuY2FsbCh0aGlzLCBwb2ludCwgZGF0YUxhYmVsLCBvcHRpb25zLCBhbGlnblRvLCBpc05ldyk7XG5cdFx0fTtcblx0fVxuXG5cblxuXHQvKipcblx0ICogSGlnaGNoYXJ0cyBKUyB2NC4xLjQtbW9kaWZpZWQgKClcblx0ICogSGlnaGNoYXJ0cyBtb2R1bGUgdG8gaGlkZSBvdmVybGFwcGluZyBkYXRhIGxhYmVscy4gVGhpcyBtb2R1bGUgaXMgaW5jbHVkZWQgYnkgZGVmYXVsdCBpbiBIaWdobWFwcy5cblx0ICpcblx0ICogKGMpIDIwMTAtMjAxNCBUb3JzdGVpbiBIb25zaVxuXHQgKlxuXHQgKiBMaWNlbnNlOiB3d3cuaGlnaGNoYXJ0cy5jb20vbGljZW5zZVxuXHQgKi9cblxuXHQvKmdsb2JhbCBIaWdoY2hhcnRzLCBIaWdoY2hhcnRzQWRhcHRlciAqL1xuXHQoZnVuY3Rpb24gKEgpIHtcblx0XHR2YXIgQ2hhcnQgPSBILkNoYXJ0LFxuXHRcdFx0ZWFjaCA9IEguZWFjaCxcblx0XHRcdGFkZEV2ZW50ID0gSGlnaGNoYXJ0c0FkYXB0ZXIuYWRkRXZlbnQ7XG5cblx0XHQvLyBDb2xsZWN0IHBvdGVuc2lhbCBvdmVybGFwcGluZyBkYXRhIGxhYmVscy4gU3RhY2sgbGFiZWxzIHByb2JhYmx5IGRvbid0IG5lZWQgdG8gYmUgXG5cdFx0Ly8gY29uc2lkZXJlZCBiZWNhdXNlIHRoZXkgYXJlIHVzdWFsbHkgYWNjb21wYW5pZWQgYnkgZGF0YSBsYWJlbHMgdGhhdCBsaWUgaW5zaWRlIHRoZSBjb2x1bW5zLlxuXHRcdENoYXJ0LnByb3RvdHlwZS5jYWxsYmFja3MucHVzaChmdW5jdGlvbiAoY2hhcnQpIHtcblx0XHRcdGZ1bmN0aW9uIGNvbGxlY3RBbmRIaWRlKCkge1xuXHRcdFx0XHR2YXIgbGFiZWxzID0gW107XG5cblx0XHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0XHR2YXIgZGxPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMuZGF0YUxhYmVscztcblx0XHRcdFx0XHRpZiAoKGRsT3B0aW9ucy5lbmFibGVkIHx8IHNlcmllcy5faGFzUG9pbnRMYWJlbHMpICYmICFkbE9wdGlvbnMuYWxsb3dPdmVybGFwICYmIHNlcmllcy52aXNpYmxlKSB7IC8vICMzODY2XG5cdFx0XHRcdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkgeyBcblx0XHRcdFx0XHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbC5sYWJlbHJhbmsgPSBwb2ludC5sYWJlbHJhbms7XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWxzLnB1c2gocG9pbnQuZGF0YUxhYmVsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2hhcnQuaGlkZU92ZXJsYXBwaW5nTGFiZWxzKGxhYmVscyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERvIGl0IG5vdyAuLi5cblx0XHRcdGNvbGxlY3RBbmRIaWRlKCk7XG5cblx0XHRcdC8vIC4uLiBhbmQgYWZ0ZXIgZWFjaCBjaGFydCByZWRyYXdcblx0XHRcdGFkZEV2ZW50KGNoYXJ0LCAncmVkcmF3JywgY29sbGVjdEFuZEhpZGUpO1xuXG5cdFx0fSk7XG5cblx0XHQvKipcblx0XHQgKiBIaWRlIG92ZXJsYXBwaW5nIGxhYmVscy4gTGFiZWxzIGFyZSBtb3ZlZCBhbmQgZmFkZWQgaW4gYW5kIG91dCBvbiB6b29tIHRvIHByb3ZpZGUgYSBzbW9vdGggXG5cdFx0ICogdmlzdWFsIGltcmVzc2lvbi5cblx0XHQgKi9cdFx0XG5cdFx0Q2hhcnQucHJvdG90eXBlLmhpZGVPdmVybGFwcGluZ0xhYmVscyA9IGZ1bmN0aW9uIChsYWJlbHMpIHtcblxuXHRcdFx0dmFyIGxlbiA9IGxhYmVscy5sZW5ndGgsXG5cdFx0XHRcdGxhYmVsLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRqLFxuXHRcdFx0XHRsYWJlbDEsXG5cdFx0XHRcdGxhYmVsMixcblx0XHRcdFx0aW50ZXJzZWN0UmVjdCA9IGZ1bmN0aW9uIChwb3MxLCBwb3MyLCBzaXplMSwgc2l6ZTIpIHtcblx0XHRcdFx0XHRyZXR1cm4gIShcblx0XHRcdFx0XHRcdHBvczIueCA+IHBvczEueCArIHNpemUxLndpZHRoIHx8XG5cdFx0XHRcdFx0XHRwb3MyLnggKyBzaXplMi53aWR0aCA8IHBvczEueCB8fFxuXHRcdFx0XHRcdFx0cG9zMi55ID4gcG9zMS55ICsgc2l6ZTEuaGVpZ2h0IHx8XG5cdFx0XHRcdFx0XHRwb3MyLnkgKyBzaXplMi5oZWlnaHQgPCBwb3MxLnlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9O1xuXHRcdFxuXHRcdFx0Ly8gTWFyayB3aXRoIGluaXRpYWwgb3BhY2l0eVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGxhYmVsID0gbGFiZWxzW2ldO1xuXHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRsYWJlbC5vbGRPcGFjaXR5ID0gbGFiZWwub3BhY2l0eTtcblx0XHRcdFx0XHRsYWJlbC5uZXdPcGFjaXR5ID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXRlY3Qgb3ZlcmxhcHBpbmcgbGFiZWxzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bGFiZWwxID0gbGFiZWxzW2ldO1xuXG5cdFx0XHRcdGZvciAoaiA9IGkgKyAxOyBqIDwgbGVuOyArK2opIHtcblx0XHRcdFx0XHRsYWJlbDIgPSBsYWJlbHNbal07XG5cdFx0XHRcdFx0aWYgKGxhYmVsMSAmJiBsYWJlbDIgJiYgbGFiZWwxLnBsYWNlZCAmJiBsYWJlbDIucGxhY2VkICYmIGxhYmVsMS5uZXdPcGFjaXR5ICE9PSAwICYmIGxhYmVsMi5uZXdPcGFjaXR5ICE9PSAwICYmIFxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RSZWN0KGxhYmVsMS5hbGlnbkF0dHIsIGxhYmVsMi5hbGlnbkF0dHIsIGxhYmVsMSwgbGFiZWwyKSkge1xuXHRcdFx0XHRcdFx0KGxhYmVsMS5sYWJlbHJhbmsgPCBsYWJlbDIubGFiZWxyYW5rID8gbGFiZWwxIDogbGFiZWwyKS5uZXdPcGFjaXR5ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSGlkZSBvciBzaG93XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bGFiZWwgPSBsYWJlbHNbaV07XG5cdFx0XHRcdGlmIChsYWJlbCkge1xuXHRcdFx0XHRcdGlmIChsYWJlbC5vbGRPcGFjaXR5ICE9PSBsYWJlbC5uZXdPcGFjaXR5ICYmIGxhYmVsLnBsYWNlZCkge1xuXHRcdFx0XHRcdFx0bGFiZWwuYWxpZ25BdHRyLm9wYWNpdHkgPSBsYWJlbC5uZXdPcGFjaXR5O1xuXHRcdFx0XHRcdFx0bGFiZWxbbGFiZWwuaXNPbGQgJiYgbGFiZWwubmV3T3BhY2l0eSA/ICdhbmltYXRlJyA6ICdhdHRyJ10obGFiZWwuYWxpZ25BdHRyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFiZWwuaXNPbGQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHR9KEhpZ2hjaGFydHMpKTsvKipcblx0ICogVHJhY2tlck1peGluIGZvciBwb2ludHMgYW5kIGdyYXBoc1xuXHQgKi9cblxuXHR2YXIgVHJhY2tlck1peGluID0gSGlnaGNoYXJ0cy5UcmFja2VyTWl4aW4gPSB7XG5cblx0XHRkcmF3VHJhY2tlclBvaW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHBvaW50ZXIgPSBjaGFydC5wb2ludGVyLFxuXHRcdFx0XHRjdXJzb3IgPSBzZXJpZXMub3B0aW9ucy5jdXJzb3IsXG5cdFx0XHRcdGNzcyA9IGN1cnNvciAmJiB7IGN1cnNvcjogY3Vyc29yIH0sXG5cdFx0XHRcdG9uTW91c2VPdmVyID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQsXG5cdFx0XHRcdFx0cG9pbnQ7XG5cblx0XHRcdFx0XHR3aGlsZSAodGFyZ2V0ICYmICFwb2ludCkge1xuXHRcdFx0XHRcdFx0cG9pbnQgPSB0YXJnZXQucG9pbnQ7XG5cdFx0XHRcdFx0XHR0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocG9pbnQgIT09IFVOREVGSU5FRCAmJiBwb2ludCAhPT0gY2hhcnQuaG92ZXJQb2ludCkgeyAvLyB1bmRlZmluZWQgb24gZ3JhcGggaW4gc2NhdHRlcmNoYXJ0XG5cdFx0XHRcdFx0XHRwb2ludC5vbk1vdXNlT3ZlcihlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdC8vIEFkZCByZWZlcmVuY2UgdG8gdGhlIHBvaW50XG5cdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRpZiAocG9pbnQuZ3JhcGhpYykge1xuXHRcdFx0XHRcdHBvaW50LmdyYXBoaWMuZWxlbWVudC5wb2ludCA9IHBvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwb2ludC5kYXRhTGFiZWwpIHtcblx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwuZWxlbWVudC5wb2ludCA9IHBvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQWRkIHRoZSBldmVudCBsaXN0ZW5lcnMsIHdlIG5lZWQgdG8gZG8gdGhpcyBvbmx5IG9uY2Vcblx0XHRcdGlmICghc2VyaWVzLl9oYXNUcmFja2luZykge1xuXHRcdFx0XHRlYWNoKHNlcmllcy50cmFja2VyR3JvdXBzLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0aWYgKHNlcmllc1trZXldKSB7IC8vIHdlIGRvbid0IGFsd2F5cyBoYXZlIGRhdGFMYWJlbHNHcm91cFxuXHRcdFx0XHRcdFx0c2VyaWVzW2tleV1cblx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKFBSRUZJWCArICd0cmFja2VyJylcblx0XHRcdFx0XHRcdFx0Lm9uKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcilcblx0XHRcdFx0XHRcdFx0Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7IHBvaW50ZXIub25UcmFja2VyTW91c2VPdXQoZSk7IH0pXG5cdFx0XHRcdFx0XHRcdC5jc3MoY3NzKTtcblx0XHRcdFx0XHRcdGlmIChoYXNUb3VjaCkge1xuXHRcdFx0XHRcdFx0XHRzZXJpZXNba2V5XS5vbigndG91Y2hzdGFydCcsIG9uTW91c2VPdmVyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzZXJpZXMuX2hhc1RyYWNraW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyB0aGUgdHJhY2tlciBvYmplY3QgdGhhdCBzaXRzIGFib3ZlIGFsbCBkYXRhIGxhYmVscyBhbmQgbWFya2VycyB0b1xuXHRcdCAqIHRyYWNrIG1vdXNlIGV2ZW50cyBvbiB0aGUgZ3JhcGggb3IgcG9pbnRzLiBGb3IgdGhlIGxpbmUgdHlwZSBjaGFydHNcblx0XHQgKiB0aGUgdHJhY2tlciB1c2VzIHRoZSBzYW1lIGdyYXBoUGF0aCwgYnV0IHdpdGggYSBncmVhdGVyIHN0cm9rZSB3aWR0aFxuXHRcdCAqIGZvciBiZXR0ZXIgY29udHJvbC5cblx0XHQgKi9cblx0XHRkcmF3VHJhY2tlckdyYXBoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHR0cmFja0J5QXJlYSA9IG9wdGlvbnMudHJhY2tCeUFyZWEsXG5cdFx0XHRcdHRyYWNrZXJQYXRoID0gW10uY29uY2F0KHRyYWNrQnlBcmVhID8gc2VyaWVzLmFyZWFQYXRoIDogc2VyaWVzLmdyYXBoUGF0aCksXG5cdFx0XHRcdHRyYWNrZXJQYXRoTGVuZ3RoID0gdHJhY2tlclBhdGgubGVuZ3RoLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdHNuYXAgPSBjaGFydC5vcHRpb25zLnRvb2x0aXAuc25hcCxcblx0XHRcdFx0dHJhY2tlciA9IHNlcmllcy50cmFja2VyLFxuXHRcdFx0XHRjdXJzb3IgPSBvcHRpb25zLmN1cnNvcixcblx0XHRcdFx0Y3NzID0gY3Vyc29yICYmIHsgY3Vyc29yOiBjdXJzb3IgfSxcblx0XHRcdFx0c2luZ2xlUG9pbnRzID0gc2VyaWVzLnNpbmdsZVBvaW50cyxcblx0XHRcdFx0c2luZ2xlUG9pbnQsXG5cdFx0XHRcdGksXG5cdFx0XHRcdG9uTW91c2VPdmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyAhPT0gc2VyaWVzKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMub25Nb3VzZU92ZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qXG5cdFx0XHRcdCAqIEVtcGlyaWNhbCBsb3dlc3QgcG9zc2libGUgb3BhY2l0aWVzIGZvciBUUkFDS0VSX0ZJTEwgZm9yIGFuIGVsZW1lbnQgdG8gc3RheSBpbnZpc2libGUgYnV0IGNsaWNrYWJsZVxuXHRcdFx0XHQgKiBJRTY6IDAuMDAyXG5cdFx0XHRcdCAqIElFNzogMC4wMDJcblx0XHRcdFx0ICogSUU4OiAwLjAwMlxuXHRcdFx0XHQgKiBJRTk6IDAuMDAwMDAwMDAwMDEgKHVubGltaXRlZClcblx0XHRcdFx0ICogSUUxMDogMC4wMDAxIChleHBvcnRpbmcgb25seSlcblx0XHRcdFx0ICogRkY6IDAuMDAwMDAwMDAwMDEgKHVubGltaXRlZClcblx0XHRcdFx0ICogQ2hyb21lOiAwLjAwMDAwMVxuXHRcdFx0XHQgKiBTYWZhcmk6IDAuMDAwMDAxXG5cdFx0XHRcdCAqIE9wZXJhOiAwLjAwMDAwMDAwMDAxICh1bmxpbWl0ZWQpXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRUUkFDS0VSX0ZJTEwgPSAncmdiYSgxOTIsMTkyLDE5MiwnICsgKGhhc1NWRyA/IDAuMDAwMSA6IDAuMDAyKSArICcpJztcblxuXHRcdFx0Ly8gRXh0ZW5kIGVuZCBwb2ludHMuIEEgYmV0dGVyIHdheSB3b3VsZCBiZSB0byB1c2Ugcm91bmQgbGluZWNhcHMsXG5cdFx0XHQvLyBidXQgdGhvc2UgYXJlIG5vdCBjbGlja2FibGUgaW4gVk1MLlxuXHRcdFx0aWYgKHRyYWNrZXJQYXRoTGVuZ3RoICYmICF0cmFja0J5QXJlYSkge1xuXHRcdFx0XHRpID0gdHJhY2tlclBhdGhMZW5ndGggKyAxO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0aWYgKHRyYWNrZXJQYXRoW2ldID09PSBNKSB7IC8vIGV4dGVuZCBsZWZ0IHNpZGVcblx0XHRcdFx0XHRcdHRyYWNrZXJQYXRoLnNwbGljZShpICsgMSwgMCwgdHJhY2tlclBhdGhbaSArIDFdIC0gc25hcCwgdHJhY2tlclBhdGhbaSArIDJdLCBMKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChpICYmIHRyYWNrZXJQYXRoW2ldID09PSBNKSB8fCBpID09PSB0cmFja2VyUGF0aExlbmd0aCkgeyAvLyBleHRlbmQgcmlnaHQgc2lkZVxuXHRcdFx0XHRcdFx0dHJhY2tlclBhdGguc3BsaWNlKGksIDAsIEwsIHRyYWNrZXJQYXRoW2kgLSAyXSArIHNuYXAsIHRyYWNrZXJQYXRoW2kgLSAxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhhbmRsZSBzaW5nbGUgcG9pbnRzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2luZ2xlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNpbmdsZVBvaW50ID0gc2luZ2xlUG9pbnRzW2ldO1xuXHRcdFx0XHR0cmFja2VyUGF0aC5wdXNoKE0sIHNpbmdsZVBvaW50LnBsb3RYIC0gc25hcCwgc2luZ2xlUG9pbnQucGxvdFksXG5cdFx0XHRcdEwsIHNpbmdsZVBvaW50LnBsb3RYICsgc25hcCwgc2luZ2xlUG9pbnQucGxvdFkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkcmF3IHRoZSB0cmFja2VyXG5cdFx0XHRpZiAodHJhY2tlcikge1xuXHRcdFx0XHR0cmFja2VyLmF0dHIoeyBkOiB0cmFja2VyUGF0aCB9KTtcblx0XHRcdH0gZWxzZSB7IC8vIGNyZWF0ZVxuXG5cdFx0XHRcdHNlcmllcy50cmFja2VyID0gcmVuZGVyZXIucGF0aCh0cmFja2VyUGF0aClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdCdzdHJva2UtbGluZWpvaW4nOiAncm91bmQnLCAvLyAjMTIyNVxuXHRcdFx0XHRcdHZpc2liaWxpdHk6IHNlcmllcy52aXNpYmxlID8gVklTSUJMRSA6IEhJRERFTixcblx0XHRcdFx0XHRzdHJva2U6IFRSQUNLRVJfRklMTCxcblx0XHRcdFx0XHRmaWxsOiB0cmFja0J5QXJlYSA/IFRSQUNLRVJfRklMTCA6IE5PTkUsXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCcgOiBvcHRpb25zLmxpbmVXaWR0aCArICh0cmFja0J5QXJlYSA/IDAgOiAyICogc25hcCksXG5cdFx0XHRcdFx0ekluZGV4OiAyXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKTtcblxuXHRcdFx0XHQvLyBUaGUgdHJhY2tlciBpcyBhZGRlZCB0byB0aGUgc2VyaWVzIGdyb3VwLCB3aGljaCBpcyBjbGlwcGVkLCBidXQgaXMgY292ZXJlZFxuXHRcdFx0XHQvLyBieSB0aGUgbWFya2VyIGdyb3VwLiBTbyB0aGUgbWFya2VyIGdyb3VwIGFsc28gbmVlZHMgdG8gY2FwdHVyZSBldmVudHMuXG5cdFx0XHRcdGVhY2goW3Nlcmllcy50cmFja2VyLCBzZXJpZXMubWFya2VyR3JvdXBdLCBmdW5jdGlvbiAodHJhY2tlcikge1xuXHRcdFx0XHRcdHRyYWNrZXIuYWRkQ2xhc3MoUFJFRklYICsgJ3RyYWNrZXInKVxuXHRcdFx0XHRcdFx0Lm9uKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcilcblx0XHRcdFx0XHRcdC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZSkgeyBwb2ludGVyLm9uVHJhY2tlck1vdXNlT3V0KGUpOyB9KVxuXHRcdFx0XHRcdFx0LmNzcyhjc3MpO1xuXG5cdFx0XHRcdFx0aWYgKGhhc1RvdWNoKSB7XG5cdFx0XHRcdFx0XHR0cmFja2VyLm9uKCd0b3VjaHN0YXJ0Jywgb25Nb3VzZU92ZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHQvKiBFbmQgVHJhY2tlck1peGluICovXG5cblxuXHQvKipcblx0ICogQWRkIHRyYWNraW5nIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBzZXJpZXMgZ3JvdXAsIHNvIHRoZSBwb2ludCBncmFwaGljc1xuXHQgKiB0aGVtc2VsdmVzIGFjdCBhcyB0cmFja2Vyc1xuXHQgKi8gXG5cblx0aWYgKHNlcmllc1R5cGVzLmNvbHVtbikge1xuXHRcdENvbHVtblNlcmllcy5wcm90b3R5cGUuZHJhd1RyYWNrZXIgPSBUcmFja2VyTWl4aW4uZHJhd1RyYWNrZXJQb2ludDtcdFxuXHR9XG5cblx0aWYgKHNlcmllc1R5cGVzLnBpZSkge1xuXHRcdHNlcmllc1R5cGVzLnBpZS5wcm90b3R5cGUuZHJhd1RyYWNrZXIgPSBUcmFja2VyTWl4aW4uZHJhd1RyYWNrZXJQb2ludDtcblx0fVxuXG5cdGlmIChzZXJpZXNUeXBlcy5zY2F0dGVyKSB7XG5cdFx0U2NhdHRlclNlcmllcy5wcm90b3R5cGUuZHJhd1RyYWNrZXIgPSBUcmFja2VyTWl4aW4uZHJhd1RyYWNrZXJQb2ludDtcblx0fVxuXG5cdC8qIFxuXHQgKiBFeHRlbmQgTGVnZW5kIGZvciBpdGVtIGV2ZW50cyBcblx0ICovIFxuXHRleHRlbmQoTGVnZW5kLnByb3RvdHlwZSwge1xuXG5cdFx0c2V0SXRlbUV2ZW50czogZnVuY3Rpb24gKGl0ZW0sIGxlZ2VuZEl0ZW0sIHVzZUhUTUwsIGl0ZW1TdHlsZSwgaXRlbUhpZGRlblN0eWxlKSB7XG5cdFx0dmFyIGxlZ2VuZCA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSBldmVudHMgb24gdGhlIGl0ZW0gZ3JvdXAsIG9yIGluIGNhc2Ugb2YgdXNlSFRNTCwgdGhlIGl0ZW0gaXRzZWxmICgjMTI0OSlcblx0XHQodXNlSFRNTCA/IGxlZ2VuZEl0ZW0gOiBpdGVtLmxlZ2VuZEdyb3VwKS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpdGVtLnNldFN0YXRlKEhPVkVSX1NUQVRFKTtcblx0XHRcdFx0bGVnZW5kSXRlbS5jc3MobGVnZW5kLm9wdGlvbnMuaXRlbUhvdmVyU3R5bGUpO1xuXHRcdFx0fSlcblx0XHRcdC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGxlZ2VuZEl0ZW0uY3NzKGl0ZW0udmlzaWJsZSA/IGl0ZW1TdHlsZSA6IGl0ZW1IaWRkZW5TdHlsZSk7XG5cdFx0XHRcdGl0ZW0uc2V0U3RhdGUoKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdHZhciBzdHJMZWdlbmRJdGVtQ2xpY2sgPSAnbGVnZW5kSXRlbUNsaWNrJyxcblx0XHRcdFx0XHRmbkxlZ2VuZEl0ZW1DbGljayA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGl0ZW0uc2V0VmlzaWJsZSgpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdC8vIFBhc3Mgb3ZlciB0aGUgY2xpY2svdG91Y2ggZXZlbnQuICM0LlxuXHRcdFx0XHRldmVudCA9IHtcblx0XHRcdFx0XHRicm93c2VyRXZlbnQ6IGV2ZW50XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gY2xpY2sgdGhlIG5hbWUgb3Igc3ltYm9sXG5cdFx0XHRcdGlmIChpdGVtLmZpcmVQb2ludEV2ZW50KSB7IC8vIHBvaW50XG5cdFx0XHRcdFx0aXRlbS5maXJlUG9pbnRFdmVudChzdHJMZWdlbmRJdGVtQ2xpY2ssIGV2ZW50LCBmbkxlZ2VuZEl0ZW1DbGljayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmlyZUV2ZW50KGl0ZW0sIHN0ckxlZ2VuZEl0ZW1DbGljaywgZXZlbnQsIGZuTGVnZW5kSXRlbUNsaWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGNyZWF0ZUNoZWNrYm94Rm9ySXRlbTogZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBsZWdlbmQgPSB0aGlzO1xuXG5cdFx0XHRpdGVtLmNoZWNrYm94ID0gY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG5cdFx0XHRcdHR5cGU6ICdjaGVja2JveCcsXG5cdFx0XHRcdGNoZWNrZWQ6IGl0ZW0uc2VsZWN0ZWQsXG5cdFx0XHRcdGRlZmF1bHRDaGVja2VkOiBpdGVtLnNlbGVjdGVkIC8vIHJlcXVpcmVkIGJ5IElFN1xuXHRcdFx0fSwgbGVnZW5kLm9wdGlvbnMuaXRlbUNoZWNrYm94U3R5bGUsIGxlZ2VuZC5jaGFydC5jb250YWluZXIpO1xuXG5cdFx0XHRhZGRFdmVudChpdGVtLmNoZWNrYm94LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0ZmlyZUV2ZW50KGl0ZW0uc2VyaWVzIHx8IGl0ZW0sICdjaGVja2JveENsaWNrJywgeyAvLyAjMzcxMlxuXHRcdFx0XHRcdFx0Y2hlY2tlZDogdGFyZ2V0LmNoZWNrZWQsXG5cdFx0XHRcdFx0XHRpdGVtOiBpdGVtXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpdGVtLnNlbGVjdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cdFxuXHR9KTtcblxuXHQvKiBcblx0ICogQWRkIHBvaW50ZXIgY3Vyc29yIHRvIGxlZ2VuZCBpdGVtc3R5bGUgaW4gZGVmYXVsdE9wdGlvbnNcblx0ICovXG5cdGRlZmF1bHRPcHRpb25zLmxlZ2VuZC5pdGVtU3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuXG5cblx0LyogXG5cdCAqIEV4dGVuZCB0aGUgQ2hhcnQgb2JqZWN0IHdpdGggaW50ZXJhY3Rpb25cblx0ICovXG5cblx0ZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwge1xuXHRcdC8qKlxuXHRcdCAqIERpc3BsYXkgdGhlIHpvb20gYnV0dG9uXG5cdFx0ICovXG5cdFx0c2hvd1Jlc2V0Wm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0bGFuZyA9IGRlZmF1bHRPcHRpb25zLmxhbmcsXG5cdFx0XHRcdGJ0bk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmNoYXJ0LnJlc2V0Wm9vbUJ1dHRvbixcblx0XHRcdFx0dGhlbWUgPSBidG5PcHRpb25zLnRoZW1lLFxuXHRcdFx0XHRzdGF0ZXMgPSB0aGVtZS5zdGF0ZXMsXG5cdFx0XHRcdGFsaWduVG8gPSBidG5PcHRpb25zLnJlbGF0aXZlVG8gPT09ICdjaGFydCcgPyBudWxsIDogJ3Bsb3RCb3gnO1xuXHRcdFx0XHRcblx0XHRcdHRoaXMucmVzZXRab29tQnV0dG9uID0gY2hhcnQucmVuZGVyZXIuYnV0dG9uKGxhbmcucmVzZXRab29tLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoKSB7IGNoYXJ0Lnpvb21PdXQoKTsgfSwgdGhlbWUsIHN0YXRlcyAmJiBzdGF0ZXMuaG92ZXIpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRhbGlnbjogYnRuT3B0aW9ucy5wb3NpdGlvbi5hbGlnbixcblx0XHRcdFx0XHR0aXRsZTogbGFuZy5yZXNldFpvb21UaXRsZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkKClcblx0XHRcdFx0LmFsaWduKGJ0bk9wdGlvbnMucG9zaXRpb24sIGZhbHNlLCBhbGlnblRvKTtcblx0XHRcdFx0XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFpvb20gb3V0IHRvIDE6MVxuXHRcdCAqL1xuXHRcdHpvb21PdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXM7XG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdzZWxlY3Rpb24nLCB7IHJlc2V0U2VsZWN0aW9uOiB0cnVlIH0sIGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdGNoYXJ0Lnpvb20oKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBab29tIGludG8gYSBnaXZlbiBwb3J0aW9uIG9mIHRoZSBjaGFydCBnaXZlbiBieSBheGlzIGNvb3JkaW5hdGVzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdFx0ICovXG5cdFx0em9vbTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRoYXNab29tZWQsXG5cdFx0XHRcdHBvaW50ZXIgPSBjaGFydC5wb2ludGVyLFxuXHRcdFx0XHRkaXNwbGF5QnV0dG9uID0gZmFsc2UsXG5cdFx0XHRcdHJlc2V0Wm9vbUJ1dHRvbjtcblxuXHRcdFx0Ly8gSWYgem9vbSBpcyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHJlc2V0IHRoZSBheGVzXG5cdFx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LnJlc2V0U2VsZWN0aW9uKSB7XG5cdFx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRoYXNab29tZWQgPSBheGlzLnpvb20oKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgeyAvLyBlbHNlLCB6b29tIGluIG9uIGFsbCBheGVzXG5cdFx0XHRcdGVhY2goZXZlbnQueEF4aXMuY29uY2F0KGV2ZW50LnlBeGlzKSwgZnVuY3Rpb24gKGF4aXNEYXRhKSB7XG5cdFx0XHRcdFx0dmFyIGF4aXMgPSBheGlzRGF0YS5heGlzLFxuXHRcdFx0XHRcdFx0aXNYQXhpcyA9IGF4aXMuaXNYQXhpcztcblxuXHRcdFx0XHRcdC8vIGRvbid0IHpvb20gbW9yZSB0aGFuIG1pblJhbmdlXG5cdFx0XHRcdFx0aWYgKHBvaW50ZXJbaXNYQXhpcyA/ICd6b29tWCcgOiAnem9vbVknXSB8fCBwb2ludGVyW2lzWEF4aXMgPyAncGluY2hYJyA6ICdwaW5jaFknXSkge1xuXHRcdFx0XHRcdFx0aGFzWm9vbWVkID0gYXhpcy56b29tKGF4aXNEYXRhLm1pbiwgYXhpc0RhdGEubWF4KTtcblx0XHRcdFx0XHRcdGlmIChheGlzLmRpc3BsYXlCdG4pIHtcblx0XHRcdFx0XHRcdFx0ZGlzcGxheUJ1dHRvbiA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gU2hvdyBvciBoaWRlIHRoZSBSZXNldCB6b29tIGJ1dHRvblxuXHRcdFx0cmVzZXRab29tQnV0dG9uID0gY2hhcnQucmVzZXRab29tQnV0dG9uO1xuXHRcdFx0aWYgKGRpc3BsYXlCdXR0b24gJiYgIXJlc2V0Wm9vbUJ1dHRvbikge1xuXHRcdFx0XHRjaGFydC5zaG93UmVzZXRab29tKCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFkaXNwbGF5QnV0dG9uICYmIGlzT2JqZWN0KHJlc2V0Wm9vbUJ1dHRvbikpIHtcblx0XHRcdFx0Y2hhcnQucmVzZXRab29tQnV0dG9uID0gcmVzZXRab29tQnV0dG9uLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHRcdFxuXG5cdFx0XHQvLyBSZWRyYXdcblx0XHRcdGlmIChoYXNab29tZWQpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KFxuXHRcdFx0XHRcdHBpY2soY2hhcnQub3B0aW9ucy5jaGFydC5hbmltYXRpb24sIGV2ZW50ICYmIGV2ZW50LmFuaW1hdGlvbiwgY2hhcnQucG9pbnRDb3VudCA8IDEwMCkgLy8gYW5pbWF0aW9uXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBhbiB0aGUgY2hhcnQgYnkgZHJhZ2dpbmcgdGhlIG1vdXNlIGFjcm9zcyB0aGUgcGFuZS4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcblx0XHQgKiBvbiBtb3VzZSBtb3ZlLCBhbmQgdGhlIGRpc3RhbmNlIHRvIHBhbiBpcyBjb21wdXRlZCBmcm9tIGNoYXJ0WCBjb21wYXJlZCB0b1xuXHRcdCAqIHRoZSBmaXJzdCBjaGFydFggcG9zaXRpb24gaW4gdGhlIGRyYWdnaW5nIG9wZXJhdGlvbi5cblx0XHQgKi9cblx0XHRwYW46IGZ1bmN0aW9uIChlLCBwYW5uaW5nKSB7XG5cblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGhvdmVyUG9pbnRzID0gY2hhcnQuaG92ZXJQb2ludHMsXG5cdFx0XHRcdGRvUmVkcmF3O1xuXG5cdFx0XHQvLyByZW1vdmUgYWN0aXZlIHBvaW50cyBmb3Igc2hhcmVkIHRvb2x0aXBcblx0XHRcdGlmIChob3ZlclBvaW50cykge1xuXHRcdFx0XHRlYWNoKGhvdmVyUG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0ZWFjaChwYW5uaW5nID09PSAneHknID8gWzEsIDBdIDogWzFdLCBmdW5jdGlvbiAoaXNYKSB7IC8vIHh5IGlzIHVzZWQgaW4gbWFwc1xuXHRcdFx0XHR2YXIgbW91c2VQb3MgPSBlW2lzWCA/ICdjaGFydFgnIDogJ2NoYXJ0WSddLFxuXHRcdFx0XHRcdGF4aXMgPSBjaGFydFtpc1ggPyAneEF4aXMnIDogJ3lBeGlzJ11bMF0sXG5cdFx0XHRcdFx0c3RhcnRQb3MgPSBjaGFydFtpc1ggPyAnbW91c2VEb3duWCcgOiAnbW91c2VEb3duWSddLFxuXHRcdFx0XHRcdGhhbGZQb2ludFJhbmdlID0gKGF4aXMucG9pbnRSYW5nZSB8fCAwKSAvIDIsXG5cdFx0XHRcdFx0ZXh0cmVtZXMgPSBheGlzLmdldEV4dHJlbWVzKCksXG5cdFx0XHRcdFx0bmV3TWluID0gYXhpcy50b1ZhbHVlKHN0YXJ0UG9zIC0gbW91c2VQb3MsIHRydWUpICsgaGFsZlBvaW50UmFuZ2UsXG5cdFx0XHRcdFx0bmV3TWF4ID0gYXhpcy50b1ZhbHVlKHN0YXJ0UG9zICsgY2hhcnRbaXNYID8gJ3Bsb3RXaWR0aCcgOiAncGxvdEhlaWdodCddIC0gbW91c2VQb3MsIHRydWUpIC0gaGFsZlBvaW50UmFuZ2UsXG5cdFx0XHRcdFx0Z29pbmdMZWZ0ID0gc3RhcnRQb3MgPiBtb3VzZVBvczsgLy8gIzM2MTNcblxuXHRcdFx0XHRpZiAoYXhpcy5zZXJpZXMubGVuZ3RoICYmIFxuXHRcdFx0XHRcdFx0KGdvaW5nTGVmdCB8fCBuZXdNaW4gPiBtYXRoTWluKGV4dHJlbWVzLmRhdGFNaW4sIGV4dHJlbWVzLm1pbikpICYmIFxuXHRcdFx0XHRcdFx0KCFnb2luZ0xlZnQgfHwgbmV3TWF4IDwgbWF0aE1heChleHRyZW1lcy5kYXRhTWF4LCBleHRyZW1lcy5tYXgpKSkge1xuXHRcdFx0XHRcdGF4aXMuc2V0RXh0cmVtZXMobmV3TWluLCBuZXdNYXgsIGZhbHNlLCBmYWxzZSwgeyB0cmlnZ2VyOiAncGFuJyB9KTtcblx0XHRcdFx0XHRkb1JlZHJhdyA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjaGFydFtpc1ggPyAnbW91c2VEb3duWCcgOiAnbW91c2VEb3duWSddID0gbW91c2VQb3M7IC8vIHNldCBuZXcgcmVmZXJlbmNlIGZvciBuZXh0IHJ1blxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChkb1JlZHJhdykge1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0Y3NzKGNoYXJ0LmNvbnRhaW5lciwgeyBjdXJzb3I6ICdtb3ZlJyB9KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qXG5cdCAqIEV4dGVuZCB0aGUgUG9pbnQgb2JqZWN0IHdpdGggaW50ZXJhY3Rpb25cblx0ICovXG5cdGV4dGVuZChQb2ludC5wcm90b3R5cGUsIHtcblx0XHQvKipcblx0XHQgKiBUb2dnbGUgdGhlIHNlbGVjdGlvbiBzdGF0dXMgb2YgYSBwb2ludFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2VsZWN0ZWQgV2hldGhlciB0byBzZWxlY3Qgb3IgdW5zZWxlY3QgdGhlIHBvaW50LlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWNjdW11bGF0ZSBXaGV0aGVyIHRvIGFkZCB0byB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBCeSBkZWZhdWx0LFxuXHRcdCAqXHRcdCB0aGlzIGhhcHBlbnMgaWYgdGhlIGNvbnRyb2wga2V5IChDbWQgb24gTWFjKSB3YXMgcHJlc3NlZCBkdXJpbmcgY2xpY2tpbmcuXG5cdFx0ICovXG5cdFx0c2VsZWN0OiBmdW5jdGlvbiAoc2VsZWN0ZWQsIGFjY3VtdWxhdGUpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cblx0XHRcdHNlbGVjdGVkID0gcGljayhzZWxlY3RlZCwgIXBvaW50LnNlbGVjdGVkKTtcblxuXHRcdFx0Ly8gZmlyZSB0aGUgZXZlbnQgd2l0aCB0aGUgZGVmYWx1dCBoYW5kbGVyXG5cdFx0XHRwb2ludC5maXJlUG9pbnRFdmVudChzZWxlY3RlZCA/ICdzZWxlY3QnIDogJ3Vuc2VsZWN0JywgeyBhY2N1bXVsYXRlOiBhY2N1bXVsYXRlIH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cG9pbnQuc2VsZWN0ZWQgPSBwb2ludC5vcHRpb25zLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRcdHNlcmllcy5vcHRpb25zLmRhdGFbaW5BcnJheShwb2ludCwgc2VyaWVzLmRhdGEpXSA9IHBvaW50Lm9wdGlvbnM7XG5cblx0XHRcdFx0cG9pbnQuc2V0U3RhdGUoc2VsZWN0ZWQgJiYgU0VMRUNUX1NUQVRFKTtcblxuXHRcdFx0XHQvLyB1bnNlbGVjdCBhbGwgb3RoZXIgcG9pbnRzIHVubGVzcyBDdHJsIG9yIENtZCArIGNsaWNrXG5cdFx0XHRcdGlmICghYWNjdW11bGF0ZSkge1xuXHRcdFx0XHRcdGVhY2goY2hhcnQuZ2V0U2VsZWN0ZWRQb2ludHMoKSwgZnVuY3Rpb24gKGxvb3BQb2ludCkge1xuXHRcdFx0XHRcdFx0aWYgKGxvb3BQb2ludC5zZWxlY3RlZCAmJiBsb29wUG9pbnQgIT09IHBvaW50KSB7XG5cdFx0XHRcdFx0XHRcdGxvb3BQb2ludC5zZWxlY3RlZCA9IGxvb3BQb2ludC5vcHRpb25zLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdHNlcmllcy5vcHRpb25zLmRhdGFbaW5BcnJheShsb29wUG9pbnQsIHNlcmllcy5kYXRhKV0gPSBsb29wUG9pbnQub3B0aW9ucztcblx0XHRcdFx0XHRcdFx0bG9vcFBvaW50LnNldFN0YXRlKE5PUk1BTF9TVEFURSk7XG5cdFx0XHRcdFx0XHRcdFx0bG9vcFBvaW50LmZpcmVQb2ludEV2ZW50KCd1bnNlbGVjdCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUnVucyBvbiBtb3VzZSBvdmVyIHRoZSBwb2ludFxuXHRcdCAqL1xuXHRcdG9uTW91c2VPdmVyOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0dG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXAsXG5cdFx0XHRcdGhvdmVyUG9pbnQgPSBjaGFydC5ob3ZlclBvaW50O1xuXG5cdFx0XHRpZiAoY2hhcnQuaG92ZXJTZXJpZXMgIT09IHNlcmllcykge1xuXHRcdFx0XHRzZXJpZXMub25Nb3VzZU92ZXIoKTtcblx0XHRcdH1cdFx0XG5cblx0XHRcdC8vIHNldCBub3JtYWwgc3RhdGUgdG8gcHJldmlvdXMgc2VyaWVzXG5cdFx0XHRpZiAoaG92ZXJQb2ludCAmJiBob3ZlclBvaW50ICE9PSBwb2ludCkge1xuXHRcdFx0XHRob3ZlclBvaW50Lm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJpZ2dlciB0aGUgZXZlbnRcblx0XHRcdHBvaW50LmZpcmVQb2ludEV2ZW50KCdtb3VzZU92ZXInKTtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSB0b29sdGlwXG5cdFx0XHRpZiAodG9vbHRpcCAmJiAoIXRvb2x0aXAuc2hhcmVkIHx8IHNlcmllcy5ub1NoYXJlZFRvb2x0aXApKSB7XG5cdFx0XHRcdHRvb2x0aXAucmVmcmVzaChwb2ludCwgZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhvdmVyIHRoaXNcblx0XHRcdHBvaW50LnNldFN0YXRlKEhPVkVSX1NUQVRFKTtcblx0XHRcdGNoYXJ0LmhvdmVyUG9pbnQgPSBwb2ludDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUnVucyBvbiBtb3VzZSBvdXQgZnJvbSB0aGUgcG9pbnRcblx0XHQgKi9cblx0XHRvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLnNlcmllcy5jaGFydCxcblx0XHRcdFx0aG92ZXJQb2ludHMgPSBjaGFydC5ob3ZlclBvaW50cztcblxuXHRcdFx0dGhpcy5maXJlUG9pbnRFdmVudCgnbW91c2VPdXQnKTtcblxuXHRcdFx0aWYgKCFob3ZlclBvaW50cyB8fCBpbkFycmF5KHRoaXMsIGhvdmVyUG9pbnRzKSA9PT0gLTEpIHsgLy8gIzg4NywgIzIyNDBcblx0XHRcdFx0dGhpcy5zZXRTdGF0ZSgpO1xuXHRcdFx0XHRjaGFydC5ob3ZlclBvaW50ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW1wb3J0IGV2ZW50cyBmcm9tIHRoZSBzZXJpZXMnIGFuZCBwb2ludCdzIG9wdGlvbnMuIE9ubHkgZG8gaXQgb25cblx0XHQgKiBkZW1hbmQsIHRvIHNhdmUgcHJvY2Vzc2luZyB0aW1lIG9uIGhvdmVyaW5nLlxuXHRcdCAqL1xuXHRcdGltcG9ydEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLmhhc0ltcG9ydGVkRXZlbnRzKSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdFx0b3B0aW9ucyA9IG1lcmdlKHBvaW50LnNlcmllcy5vcHRpb25zLnBvaW50LCBwb2ludC5vcHRpb25zKSxcblx0XHRcdFx0XHRldmVudHMgPSBvcHRpb25zLmV2ZW50cyxcblx0XHRcdFx0XHRldmVudFR5cGU7XG5cblx0XHRcdFx0cG9pbnQuZXZlbnRzID0gZXZlbnRzO1xuXG5cdFx0XHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHRcdGFkZEV2ZW50KHBvaW50LCBldmVudFR5cGUsIGV2ZW50c1tldmVudFR5cGVdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmhhc0ltcG9ydGVkRXZlbnRzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHBvaW50J3Mgc3RhdGVcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGVcblx0XHQgKi9cblx0XHRzZXRTdGF0ZTogZnVuY3Rpb24gKHN0YXRlLCBtb3ZlKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRwbG90WCA9IHBvaW50LnBsb3RYLFxuXHRcdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdHN0YXRlT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLnN0YXRlcyxcblx0XHRcdFx0bWFya2VyT3B0aW9ucyA9IGRlZmF1bHRQbG90T3B0aW9uc1tzZXJpZXMudHlwZV0ubWFya2VyICYmIHNlcmllcy5vcHRpb25zLm1hcmtlcixcblx0XHRcdFx0bm9ybWFsRGlzYWJsZWQgPSBtYXJrZXJPcHRpb25zICYmICFtYXJrZXJPcHRpb25zLmVuYWJsZWQsXG5cdFx0XHRcdG1hcmtlclN0YXRlT3B0aW9ucyA9IG1hcmtlck9wdGlvbnMgJiYgbWFya2VyT3B0aW9ucy5zdGF0ZXNbc3RhdGVdLFxuXHRcdFx0XHRzdGF0ZURpc2FibGVkID0gbWFya2VyU3RhdGVPcHRpb25zICYmIG1hcmtlclN0YXRlT3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSxcblx0XHRcdFx0c3RhdGVNYXJrZXJHcmFwaGljID0gc2VyaWVzLnN0YXRlTWFya2VyR3JhcGhpYyxcblx0XHRcdFx0cG9pbnRNYXJrZXIgPSBwb2ludC5tYXJrZXIgfHwge30sXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRyYWRpdXMsXG5cdFx0XHRcdGhhbG8gPSBzZXJpZXMuaGFsbyxcblx0XHRcdFx0aGFsb09wdGlvbnMsXG5cdFx0XHRcdG5ld1N5bWJvbCxcblx0XHRcdFx0cG9pbnRBdHRyO1xuXG5cdFx0XHRzdGF0ZSA9IHN0YXRlIHx8IE5PUk1BTF9TVEFURTsgLy8gZW1wdHkgc3RyaW5nXG5cdFx0XHRwb2ludEF0dHIgPSBwb2ludC5wb2ludEF0dHJbc3RhdGVdIHx8IHNlcmllcy5wb2ludEF0dHJbc3RhdGVdO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdFx0Ly8gYWxyZWFkeSBoYXMgdGhpcyBzdGF0ZVxuXHRcdFx0XHRcdChzdGF0ZSA9PT0gcG9pbnQuc3RhdGUgJiYgIW1vdmUpIHx8XG5cdFx0XHRcdFx0Ly8gc2VsZWN0ZWQgcG9pbnRzIGRvbid0IHJlc3BvbmQgdG8gaG92ZXJcblx0XHRcdFx0XHQocG9pbnQuc2VsZWN0ZWQgJiYgc3RhdGUgIT09IFNFTEVDVF9TVEFURSkgfHxcblx0XHRcdFx0XHQvLyBzZXJpZXMnIHN0YXRlIG9wdGlvbnMgaXMgZGlzYWJsZWRcblx0XHRcdFx0XHQoc3RhdGVPcHRpb25zW3N0YXRlXSAmJiBzdGF0ZU9wdGlvbnNbc3RhdGVdLmVuYWJsZWQgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdC8vIGdlbmVyYWwgcG9pbnQgbWFya2VyJ3Mgc3RhdGUgb3B0aW9ucyBpcyBkaXNhYmxlZFxuXHRcdFx0XHRcdChzdGF0ZSAmJiAoc3RhdGVEaXNhYmxlZCB8fCAobm9ybWFsRGlzYWJsZWQgJiYgbWFya2VyU3RhdGVPcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSkpIHx8XG5cdFx0XHRcdFx0Ly8gaW5kaXZpZHVhbCBwb2ludCBtYXJrZXIncyBzdGF0ZSBvcHRpb25zIGlzIGRpc2FibGVkXG5cdFx0XHRcdFx0KHN0YXRlICYmIHBvaW50TWFya2VyLnN0YXRlcyAmJiBwb2ludE1hcmtlci5zdGF0ZXNbc3RhdGVdICYmIHBvaW50TWFya2VyLnN0YXRlc1tzdGF0ZV0uZW5hYmxlZCA9PT0gZmFsc2UpIC8vICMxNjEwXG5cblx0XHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwbHkgaG92ZXIgc3R5bGVzIHRvIHRoZSBleGlzdGluZyBwb2ludFxuXHRcdFx0aWYgKHBvaW50LmdyYXBoaWMpIHtcblx0XHRcdFx0cmFkaXVzID0gbWFya2VyT3B0aW9ucyAmJiBwb2ludC5ncmFwaGljLnN5bWJvbE5hbWUgJiYgcG9pbnRBdHRyLnI7XG5cdFx0XHRcdHBvaW50LmdyYXBoaWMuYXR0cihtZXJnZShcblx0XHRcdFx0XHRwb2ludEF0dHIsXG5cdFx0XHRcdFx0cmFkaXVzID8geyAvLyBuZXcgc3ltYm9sIGF0dHJpYnV0ZXMgKCM1MDcsICM2MTIpXG5cdFx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdHk6IHBsb3RZIC0gcmFkaXVzLFxuXHRcdFx0XHRcdFx0d2lkdGg6IDIgKiByYWRpdXMsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IDIgKiByYWRpdXNcblx0XHRcdFx0XHR9IDoge31cblx0XHRcdFx0KSk7XG5cblx0XHRcdFx0Ly8gWm9vbWluZyBpbiBmcm9tIGEgcmFuZ2Ugd2l0aCBubyBtYXJrZXJzIHRvIGEgcmFuZ2Ugd2l0aCBtYXJrZXJzXG5cdFx0XHRcdGlmIChzdGF0ZU1hcmtlckdyYXBoaWMpIHtcblx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMuaGlkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBpZiBhIGdyYXBoaWMgaXMgbm90IGFwcGxpZWQgdG8gZWFjaCBwb2ludCBpbiB0aGUgbm9ybWFsIHN0YXRlLCBjcmVhdGUgYSBzaGFyZWRcblx0XHRcdFx0Ly8gZ3JhcGhpYyBmb3IgdGhlIGhvdmVyIHN0YXRlXG5cdFx0XHRcdGlmIChzdGF0ZSAmJiBtYXJrZXJTdGF0ZU9wdGlvbnMpIHtcblx0XHRcdFx0XHRyYWRpdXMgPSBtYXJrZXJTdGF0ZU9wdGlvbnMucmFkaXVzO1xuXHRcdFx0XHRcdG5ld1N5bWJvbCA9IHBvaW50TWFya2VyLnN5bWJvbCB8fCBzZXJpZXMuc3ltYm9sO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHBvaW50IGhhcyBhbm90aGVyIHN5bWJvbCB0aGFuIHRoZSBwcmV2aW91cyBvbmUsIHRocm93IGF3YXkgdGhlXG5cdFx0XHRcdFx0Ly8gc3RhdGUgbWFya2VyIGdyYXBoaWMgYW5kIGZvcmNlIGEgbmV3IG9uZSAoIzE0NTkpXG5cdFx0XHRcdFx0aWYgKHN0YXRlTWFya2VyR3JhcGhpYyAmJiBzdGF0ZU1hcmtlckdyYXBoaWMuY3VycmVudFN5bWJvbCAhPT0gbmV3U3ltYm9sKSB7XG5cdFx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMgPSBzdGF0ZU1hcmtlckdyYXBoaWMuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFkZCBhIG5ldyBzdGF0ZSBtYXJrZXIgZ3JhcGhpY1xuXHRcdFx0XHRcdGlmICghc3RhdGVNYXJrZXJHcmFwaGljKSB7XG5cdFx0XHRcdFx0XHRpZiAobmV3U3ltYm9sKSB7XG5cdFx0XHRcdFx0XHRcdHNlcmllcy5zdGF0ZU1hcmtlckdyYXBoaWMgPSBzdGF0ZU1hcmtlckdyYXBoaWMgPSBjaGFydC5yZW5kZXJlci5zeW1ib2woXG5cdFx0XHRcdFx0XHRcdFx0bmV3U3ltYm9sLFxuXHRcdFx0XHRcdFx0XHRcdHBsb3RYIC0gcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdHBsb3RZIC0gcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdDIgKiByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0MiAqIHJhZGl1c1xuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdC5hdHRyKHBvaW50QXR0cilcblx0XHRcdFx0XHRcdFx0LmFkZChzZXJpZXMubWFya2VyR3JvdXApO1xuXHRcdFx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMuY3VycmVudFN5bWJvbCA9IG5ld1N5bWJvbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE1vdmUgdGhlIGV4aXN0aW5nIGdyYXBoaWNcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhdGVNYXJrZXJHcmFwaGljW21vdmUgPyAnYW5pbWF0ZScgOiAnYXR0ciddKHsgLy8gIzEwNTRcblx0XHRcdFx0XHRcdFx0eDogcGxvdFggLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdHk6IHBsb3RZIC0gcmFkaXVzXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc3RhdGVNYXJrZXJHcmFwaGljKSB7XG5cdFx0XHRcdFx0c3RhdGVNYXJrZXJHcmFwaGljW3N0YXRlICYmIGNoYXJ0LmlzSW5zaWRlUGxvdChwbG90WCwgcGxvdFksIGNoYXJ0LmludmVydGVkKSA/ICdzaG93JyA6ICdoaWRlJ10oKTsgLy8gIzI0NTBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IG1lIHlvdXIgaGFsb1xuXHRcdFx0aGFsb09wdGlvbnMgPSBzdGF0ZU9wdGlvbnNbc3RhdGVdICYmIHN0YXRlT3B0aW9uc1tzdGF0ZV0uaGFsbztcblx0XHRcdGlmIChoYWxvT3B0aW9ucyAmJiBoYWxvT3B0aW9ucy5zaXplKSB7XG5cdFx0XHRcdGlmICghaGFsbykge1xuXHRcdFx0XHRcdHNlcmllcy5oYWxvID0gaGFsbyA9IGNoYXJ0LnJlbmRlcmVyLnBhdGgoKVxuXHRcdFx0XHRcdFx0LmFkZChjaGFydC5zZXJpZXNHcm91cCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGFsby5hdHRyKGV4dGVuZCh7XG5cdFx0XHRcdFx0ZmlsbDogQ29sb3IocG9pbnQuY29sb3IgfHwgc2VyaWVzLmNvbG9yKS5zZXRPcGFjaXR5KGhhbG9PcHRpb25zLm9wYWNpdHkpLmdldCgpXG5cdFx0XHRcdH0sIGhhbG9PcHRpb25zLmF0dHJpYnV0ZXMpKVttb3ZlID8gJ2FuaW1hdGUnIDogJ2F0dHInXSh7XG5cdFx0XHRcdFx0ZDogcG9pbnQuaGFsb1BhdGgoaGFsb09wdGlvbnMuc2l6ZSlcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKGhhbG8pIHtcblx0XHRcdFx0aGFsby5hdHRyKHsgZDogW10gfSk7XG5cdFx0XHR9XG5cblx0XHRcdHBvaW50LnN0YXRlID0gc3RhdGU7XG5cdFx0fSxcblxuXHRcdGhhbG9QYXRoOiBmdW5jdGlvbiAoc2l6ZSkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0cGxvdEJveCA9IHNlcmllcy5nZXRQbG90Qm94KCksXG5cdFx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQ7XG5cblx0XHRcdHJldHVybiBjaGFydC5yZW5kZXJlci5zeW1ib2xzLmNpcmNsZShcblx0XHRcdFx0cGxvdEJveC50cmFuc2xhdGVYICsgKGludmVydGVkID8gc2VyaWVzLnlBeGlzLmxlbiAtIHRoaXMucGxvdFkgOiB0aGlzLnBsb3RYKSAtIHNpemUsIFxuXHRcdFx0XHRwbG90Qm94LnRyYW5zbGF0ZVkgKyAoaW52ZXJ0ZWQgPyBzZXJpZXMueEF4aXMubGVuIC0gdGhpcy5wbG90WCA6IHRoaXMucGxvdFkpIC0gc2l6ZSwgXG5cdFx0XHRcdHNpemUgKiAyLCBcblx0XHRcdFx0c2l6ZSAqIDJcblx0XHRcdCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKlxuXHQgKiBFeHRlbmQgdGhlIFNlcmllcyBvYmplY3Qgd2l0aCBpbnRlcmFjdGlvblxuXHQgKi9cblxuXHRleHRlbmQoU2VyaWVzLnByb3RvdHlwZSwge1xuXHRcdC8qKlxuXHRcdCAqIFNlcmllcyBtb3VzZSBvdmVyIGhhbmRsZXJcblx0XHQgKi9cblx0XHRvbk1vdXNlT3ZlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRob3ZlclNlcmllcyA9IGNoYXJ0LmhvdmVyU2VyaWVzO1xuXG5cdFx0XHQvLyBzZXQgbm9ybWFsIHN0YXRlIHRvIHByZXZpb3VzIHNlcmllc1xuXHRcdFx0aWYgKGhvdmVyU2VyaWVzICYmIGhvdmVyU2VyaWVzICE9PSBzZXJpZXMpIHtcblx0XHRcdFx0aG92ZXJTZXJpZXMub25Nb3VzZU91dCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cmlnZ2VyIHRoZSBldmVudCwgYnV0IHRvIHNhdmUgcHJvY2Vzc2luZyB0aW1lLFxuXHRcdFx0Ly8gb25seSBpZiBkZWZpbmVkXG5cdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuZXZlbnRzLm1vdXNlT3Zlcikge1xuXHRcdFx0XHRmaXJlRXZlbnQoc2VyaWVzLCAnbW91c2VPdmVyJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhvdmVyIHRoaXNcblx0XHRcdHNlcmllcy5zZXRTdGF0ZShIT1ZFUl9TVEFURSk7XG5cdFx0XHRjaGFydC5ob3ZlclNlcmllcyA9IHNlcmllcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2VyaWVzIG1vdXNlIG91dCBoYW5kbGVyXG5cdFx0ICovXG5cdFx0b25Nb3VzZU91dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gdHJpZ2dlciB0aGUgZXZlbnQgb25seSBpZiBsaXN0ZW5lcnMgZXhpc3Rcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHR0b29sdGlwID0gY2hhcnQudG9vbHRpcCxcblx0XHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQ7XG5cblx0XHRcdC8vIHRyaWdnZXIgbW91c2Ugb3V0IG9uIHRoZSBwb2ludCwgd2hpY2ggbXVzdCBiZSBpbiB0aGlzIHNlcmllc1xuXHRcdFx0aWYgKGhvdmVyUG9pbnQpIHtcblx0XHRcdFx0aG92ZXJQb2ludC5vbk1vdXNlT3V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZpcmUgdGhlIG1vdXNlIG91dCBldmVudFxuXHRcdFx0aWYgKHNlcmllcyAmJiBvcHRpb25zLmV2ZW50cy5tb3VzZU91dCkge1xuXHRcdFx0XHRmaXJlRXZlbnQoc2VyaWVzLCAnbW91c2VPdXQnKTtcblx0XHRcdH1cblxuXG5cdFx0XHQvLyBoaWRlIHRoZSB0b29sdGlwXG5cdFx0XHRpZiAodG9vbHRpcCAmJiAhb3B0aW9ucy5zdGlja3lUcmFja2luZyAmJiAoIXRvb2x0aXAuc2hhcmVkIHx8IHNlcmllcy5ub1NoYXJlZFRvb2x0aXApKSB7XG5cdFx0XHRcdHRvb2x0aXAuaGlkZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgbm9ybWFsIHN0YXRlXG5cdFx0XHRzZXJpZXMuc2V0U3RhdGUoKTtcblx0XHRcdGNoYXJ0LmhvdmVyU2VyaWVzID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBzdGF0ZSBvZiB0aGUgZ3JhcGhcblx0XHQgKi9cblx0XHRzZXRTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRncmFwaCA9IHNlcmllcy5ncmFwaCxcblx0XHRcdFx0Z3JhcGhOZWcgPSBzZXJpZXMuZ3JhcGhOZWcsXG5cdFx0XHRcdHN0YXRlT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGVzLFxuXHRcdFx0XHRsaW5lV2lkdGggPSBvcHRpb25zLmxpbmVXaWR0aCxcblx0XHRcdFx0YXR0cmlicztcblxuXHRcdFx0c3RhdGUgPSBzdGF0ZSB8fCBOT1JNQUxfU1RBVEU7XG5cblx0XHRcdGlmIChzZXJpZXMuc3RhdGUgIT09IHN0YXRlKSB7XG5cdFx0XHRcdHNlcmllcy5zdGF0ZSA9IHN0YXRlO1xuXG5cdFx0XHRcdGlmIChzdGF0ZU9wdGlvbnNbc3RhdGVdICYmIHN0YXRlT3B0aW9uc1tzdGF0ZV0uZW5hYmxlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc3RhdGUpIHtcblx0XHRcdFx0XHRsaW5lV2lkdGggPSAoc3RhdGVPcHRpb25zW3N0YXRlXS5saW5lV2lkdGggfHwgbGluZVdpZHRoKSArIChzdGF0ZU9wdGlvbnNbc3RhdGVdLmxpbmVXaWR0aFBsdXMgfHwgMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JhcGggJiYgIWdyYXBoLmRhc2hzdHlsZSkgeyAvLyBob3ZlciBpcyB0dXJuZWQgb2ZmIGZvciBkYXNoZWQgbGluZXMgaW4gVk1MXG5cdFx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBsaW5lV2lkdGhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIHVzZSBhdHRyIGJlY2F1c2UgYW5pbWF0ZSB3aWxsIGNhdXNlIGFueSBvdGhlciBhbmltYXRpb24gb24gdGhlIGdyYXBoIHRvIHN0b3Bcblx0XHRcdFx0XHRncmFwaC5hdHRyKGF0dHJpYnMpO1xuXHRcdFx0XHRcdGlmIChncmFwaE5lZykge1xuXHRcdFx0XHRcdFx0Z3JhcGhOZWcuYXR0cihhdHRyaWJzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBncmFwaFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHZpcyB7Qm9vbGVhbn0gVHJ1ZSB0byBzaG93IHRoZSBzZXJpZXMsIGZhbHNlIHRvIGhpZGUuIElmIFVOREVGSU5FRCxcblx0XHQgKlx0XHRcdFx0dGhlIHZpc2liaWxpdHkgaXMgdG9nZ2xlZC5cblx0XHQgKi9cblx0XHRzZXRWaXNpYmxlOiBmdW5jdGlvbiAodmlzLCByZWRyYXcpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0bGVnZW5kSXRlbSA9IHNlcmllcy5sZWdlbmRJdGVtLFxuXHRcdFx0XHRzaG93T3JIaWRlLFxuXHRcdFx0XHRpZ25vcmVIaWRkZW5TZXJpZXMgPSBjaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyxcblx0XHRcdFx0b2xkVmlzaWJpbGl0eSA9IHNlcmllcy52aXNpYmxlO1xuXG5cdFx0XHQvLyBpZiBjYWxsZWQgd2l0aG91dCBhbiBhcmd1bWVudCwgdG9nZ2xlIHZpc2liaWxpdHlcblx0XHRcdHNlcmllcy52aXNpYmxlID0gdmlzID0gc2VyaWVzLnVzZXJPcHRpb25zLnZpc2libGUgPSB2aXMgPT09IFVOREVGSU5FRCA/ICFvbGRWaXNpYmlsaXR5IDogdmlzO1xuXHRcdFx0c2hvd09ySGlkZSA9IHZpcyA/ICdzaG93JyA6ICdoaWRlJztcblxuXHRcdFx0Ly8gc2hvdyBvciBoaWRlIGVsZW1lbnRzXG5cdFx0XHRlYWNoKFsnZ3JvdXAnLCAnZGF0YUxhYmVsc0dyb3VwJywgJ21hcmtlckdyb3VwJywgJ3RyYWNrZXInXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRpZiAoc2VyaWVzW2tleV0pIHtcblx0XHRcdFx0XHRzZXJpZXNba2V5XVtzaG93T3JIaWRlXSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXG5cdFx0XHQvLyBoaWRlIHRvb2x0aXAgKCMxMzYxKVxuXHRcdFx0aWYgKGNoYXJ0LmhvdmVyU2VyaWVzID09PSBzZXJpZXMgfHwgKGNoYXJ0LmhvdmVyUG9pbnQgJiYgY2hhcnQuaG92ZXJQb2ludC5zZXJpZXMpID09PSBzZXJpZXMpIHtcblx0XHRcdFx0c2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblxuXG5cdFx0XHRpZiAobGVnZW5kSXRlbSkge1xuXHRcdFx0XHRjaGFydC5sZWdlbmQuY29sb3JpemVJdGVtKHNlcmllcywgdmlzKTtcblx0XHRcdH1cblxuXG5cdFx0XHQvLyByZXNjYWxlIG9yIGFkYXB0IHRvIHJlc2l6ZWQgY2hhcnRcblx0XHRcdHNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdC8vIGluIGEgc3RhY2ssIGFsbCBvdGhlciBzZXJpZXMgYXJlIGFmZmVjdGVkXG5cdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuc3RhY2tpbmcpIHtcblx0XHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRcdGlmIChvdGhlclNlcmllcy5vcHRpb25zLnN0YWNraW5nICYmIG90aGVyU2VyaWVzLnZpc2libGUpIHtcblx0XHRcdFx0XHRcdG90aGVyU2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNob3cgb3IgaGlkZSBsaW5rZWQgc2VyaWVzXG5cdFx0XHRlYWNoKHNlcmllcy5saW5rZWRTZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRvdGhlclNlcmllcy5zZXRWaXNpYmxlKHZpcywgZmFsc2UpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChpZ25vcmVIaWRkZW5TZXJpZXMpIHtcblx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVkcmF3ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoKTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgc2hvd09ySGlkZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNob3cgdGhlIGdyYXBoXG5cdFx0ICovXG5cdFx0c2hvdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5zZXRWaXNpYmxlKHRydWUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaWRlIHRoZSBncmFwaFxuXHRcdCAqL1xuXHRcdGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgZ3JhcGhcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSBzZWxlY3RlZCB7Qm9vbGVhbn0gVHJ1ZSB0byBzZWxlY3QgdGhlIHNlcmllcywgZmFsc2UgdG8gdW5zZWxlY3QuIElmXG5cdFx0ICpcdFx0XHRcdFVOREVGSU5FRCwgdGhlIHNlbGVjdGlvbiBzdGF0ZSBpcyB0b2dnbGVkLlxuXHRcdCAqL1xuXHRcdHNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcztcblx0XHRcdC8vIGlmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCB0b2dnbGVcblx0XHRcdHNlcmllcy5zZWxlY3RlZCA9IHNlbGVjdGVkID0gKHNlbGVjdGVkID09PSBVTkRFRklORUQpID8gIXNlcmllcy5zZWxlY3RlZCA6IHNlbGVjdGVkO1xuXG5cdFx0XHRpZiAoc2VyaWVzLmNoZWNrYm94KSB7XG5cdFx0XHRcdHNlcmllcy5jaGVja2JveC5jaGVja2VkID0gc2VsZWN0ZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmVFdmVudChzZXJpZXMsIHNlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5zZWxlY3QnKTtcblx0XHR9LFxuXG5cdFx0ZHJhd1RyYWNrZXI6IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlckdyYXBoXG5cdH0pO1xuXHQvLyBnbG9iYWwgdmFyaWFibGVzXG5cdGV4dGVuZChIaWdoY2hhcnRzLCB7XG5cdFx0XG5cdFx0Ly8gQ29uc3RydWN0b3JzXG5cdFx0Q29sb3I6IENvbG9yLFxuXHRcdFBvaW50OiBQb2ludCxcblx0XHRUaWNrOiBUaWNrLFx0XG5cdFx0UmVuZGVyZXI6IFJlbmRlcmVyLFxuXHRcdFNWR0VsZW1lbnQ6IFNWR0VsZW1lbnQsXG5cdFx0U1ZHUmVuZGVyZXI6IFNWR1JlbmRlcmVyLFxuXHRcdFxuXHRcdC8vIFZhcmlvdXNcblx0XHRhcnJheU1pbjogYXJyYXlNaW4sXG5cdFx0YXJyYXlNYXg6IGFycmF5TWF4LFxuXHRcdGNoYXJ0czogY2hhcnRzLFxuXHRcdGRhdGVGb3JtYXQ6IGRhdGVGb3JtYXQsXG5cdFx0ZXJyb3I6IGVycm9yLFxuXHRcdGZvcm1hdDogZm9ybWF0LFxuXHRcdHBhdGhBbmltOiBwYXRoQW5pbSxcblx0XHRnZXRPcHRpb25zOiBnZXRPcHRpb25zLFxuXHRcdGhhc0JpZGlCdWc6IGhhc0JpZGlCdWcsXG5cdFx0aXNUb3VjaERldmljZTogaXNUb3VjaERldmljZSxcblx0XHRzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXHRcdGFkZEV2ZW50OiBhZGRFdmVudCxcblx0XHRyZW1vdmVFdmVudDogcmVtb3ZlRXZlbnQsXG5cdFx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblx0XHRkaXNjYXJkRWxlbWVudDogZGlzY2FyZEVsZW1lbnQsXG5cdFx0Y3NzOiBjc3MsXG5cdFx0ZWFjaDogZWFjaCxcblx0XHRtYXA6IG1hcCxcblx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0c3BsYXQ6IHNwbGF0LFxuXHRcdGV4dGVuZENsYXNzOiBleHRlbmRDbGFzcyxcblx0XHRwSW50OiBwSW50LFxuXHRcdHN2ZzogaGFzU1ZHLFxuXHRcdGNhbnZhczogdXNlQ2FuVkcsXG5cdFx0dm1sOiAhaGFzU1ZHICYmICF1c2VDYW5WRyxcblx0XHRwcm9kdWN0OiBQUk9EVUNULFxuXHRcdHZlcnNpb246IFZFUlNJT05cblx0fSk7XG5cblx0fSgpKTtcblxuXG5cdC8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cblx0bW9kdWxlLmV4cG9ydHMgPSBIaWdoY2hhcnRzXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbiIsInZhciB3YXJuaW5nID0gcmVxdWlyZSgnLi9saWIvd2FybmluZycpO1xud2FybmluZyhcbiAgZmFsc2UsXG4gICdyZXF1aXJlKFwicmVhY3QvYWRkb25zXCIpIGlzIGRlcHJlY2F0ZWQuICcgK1xuICAnQWNjZXNzIHVzaW5nIHJlcXVpcmUoXCJyZWFjdC9hZGRvbnMve2FkZG9ufVwiKSBpbnN0ZWFkLidcbik7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3RXaXRoQWRkb25zJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2xpYi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cCcpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEF1dG9Gb2N1c01peGluXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZShcIi4vZmluZERPTU5vZGVcIik7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZShcIi4vZm9jdXNOb2RlXCIpO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSB7XG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICBmb2N1c05vZGUoZmluZERPTU5vZGUodGhpcykpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNNaXhpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoXCIuL0V2ZW50UHJvcGFnYXRvcnNcIik7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUgPSByZXF1aXJlKFwiLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVcIik7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcIik7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0lucHV0RXZlbnRcIik7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQsIHRvcExldmVsVHlwZXMudG9wUGFzdGVdXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZSwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQodG9wTGV2ZWxUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCB8fCBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTQ29yZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogVGhlIENTU0NvcmUgbW9kdWxlIHNwZWNpZmllcyB0aGUgQVBJIChhbmQgaW1wbGVtZW50cyBtb3N0IG9mIHRoZSBtZXRob2RzKVxuICogdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRlYWxpbmcgd2l0aCB0aGUgZGlzcGxheSBvZiBlbGVtZW50cyAodmlhIHRoZWlyXG4gKiBDU1MgY2xhc3NlcyBhbmQgdmlzaWJpbGl0eSBvbiBzY3JlZW4uIEl0IGlzIGFuIEFQSSBmb2N1c2VkIG9uIG11dGF0aW5nIHRoZVxuICogZGlzcGxheSBhbmQgbm90IHJlYWRpbmcgaXQgYXMgbm8gbG9naWNhbCBzdGF0ZSBzaG91bGQgYmUgZW5jb2RlZCBpbiB0aGVcbiAqIGRpc3BsYXkgb2YgZWxlbWVudHMuXG4gKi9cblxudmFyIENTU0NvcmUgPSB7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGNsYXNzIHBhc3NlZCBpbiB0byB0aGUgZWxlbWVudCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIGFkZENsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgISEvXFxzLy50ZXN0KGNsYXNzTmFtZSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnQ1NTQ29yZS5hZGRDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuIFwiJXNcIiBjb250YWlucyAnICsgJ211bHRpcGxlIGNsYXNzZXMuJywgY2xhc3NOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKCFDU1NDb3JlLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGNsYXNzIHBhc3NlZCBpbiBmcm9tIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG4gICAqL1xuICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICEhL1xccy8udGVzdChjbGFzc05hbWUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0NTU0NvcmUucmVtb3ZlQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLiBcIiVzXCIgY29udGFpbnMgJyArICdtdWx0aXBsZSBjbGFzc2VzLicsIGNsYXNzTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIGlmIChDU1NDb3JlLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKD86XFxcXHN8JCknLCAnZycpLCAnJDEnKS5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gbXVsdGlwbGUgc3BhY2VzIHRvIG9uZVxuICAgICAgICAucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpOyAvLyB0cmltIHRoZSBlbmRzXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gYWRkIG9yIHJlbW92ZSBhIGNsYXNzIGZyb20gYW4gZWxlbWVudCBiYXNlZCBvbiBhIGNvbmRpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcGFyYW0geyp9IGJvb2wgY29uZGl0aW9uIHRvIHdoZXRoZXIgdG8gYWRkIG9yIHJlbW92ZSB0aGUgY2xhc3NcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG4gICAqL1xuICBjb25kaXRpb25DbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSwgYm9vbCkge1xuICAgIHJldHVybiAoYm9vbCA/IENTU0NvcmUuYWRkQ2xhc3MgOiBDU1NDb3JlLnJlbW92ZUNsYXNzKShlbGVtZW50LCBjbGFzc05hbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3Mgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTU5vZGV8RE9NV2luZG93fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MsIGZhbHNlIGlmIG5vdFxuICAgKi9cbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAhIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdDU1MuaGFzQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPiAtMTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU0NvcmU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogTW9zdCBzdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1bnNldCBieSBkb2luZyAuc3R5bGVbcHJvcF0gPSAnJyBidXQgSUU4XG4gKiBkb2Vzbid0IGxpa2UgZG9pbmcgdGhhdCB3aXRoIHNob3J0aGFuZCBwcm9wZXJ0aWVzIHNvIGZvciB0aGUgcHJvcGVydGllcyB0aGF0XG4gKiBJRTggYnJlYWtzIG9uLCB3aGljaCBhcmUgbGlzdGVkIGhlcmUsIHdlIGluc3RlYWQgdW5zZXQgZWFjaCBvZiB0aGVcbiAqIGluZGl2aWR1YWwgcHJvcGVydGllcy4gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzg1LlxuICogVGhlIDQtdmFsdWUgJ2Nsb2NrJyBwcm9wZXJ0aWVzIGxpa2UgbWFyZ2luLCBwYWRkaW5nLCBib3JkZXItd2lkdGggc2VlbSB0b1xuICogYmVoYXZlIHdpdGhvdXQgYW55IHByb2JsZW1zLiBDdXJpb3VzbHksIGxpc3Qtc3R5bGUgd29ya3MgdG9vIHdpdGhvdXQgYW55XG4gKiBzcGVjaWFsIHByb2RkaW5nLlxuICovXG52YXIgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zID0ge1xuICBiYWNrZ3JvdW5kOiB7XG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvbjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5T3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0NTU1Byb3BlcnR5XCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoXCIuL2NhbWVsaXplU3R5bGVOYW1lXCIpO1xudmFyIGRhbmdlcm91c1N0eWxlVmFsdWUgPSByZXF1aXJlKFwiLi9kYW5nZXJvdXNTdHlsZVZhbHVlXCIpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoXCIuL2h5cGhlbmF0ZVN0eWxlTmFtZVwiKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoXCIuL21lbW9pemVTdHJpbmdPbmx5XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSkpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkgKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcykge1xuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2FsbGJhY2tRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xuICogYmUgbm90aWZpZWQgd2hlbiB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBJbnN0ZWFkLCB1c2UgYENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKClgLlxuICpcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcbiAqIEBpbXBsZW1lbnRzIFBvb2xlZENsYXNzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xufVxuXG5hc3NpZ24oQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBDb250ZXh0IHRvIGNhbGwgYGNhbGxiYWNrYCB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWU6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCBbXTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzIHx8IFtdO1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGFsbCBlbnF1ZXVlZCBjYWxsYmFja3MgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgaXMgaW52b2tlZCBhZnRlclxuICAgKiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnlBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICEoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWUnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxiYWNrUXVldWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENoYW5nZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZShcIi4vaXNFdmVudFN1cHBvcnRlZFwiKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKFwiLi9pc1RleHRJbnB1dEVsZW1lbnRcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DaGFuZ2U6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNoYW5nZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UsIHRvcExldmVsVHlwZXMudG9wQ2xpY2ssIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wSW5wdXQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgPT09ICdTRUxFQ1QnIHx8IGVsZW0ubm9kZU5hbWUgPT09ICdJTlBVVCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbnZhciBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gU2VlIGBoYW5kbGVDaGFuZ2VgIGNvbW1lbnQgYmVsb3dcbiAgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gaXNFdmVudFN1cHBvcnRlZCgnY2hhbmdlJykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDgpO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgYWN0aXZlRWxlbWVudElELCBuYXRpdmVFdmVudCk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZSgpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJRCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SUQgPSB0YXJnZXRJRDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0ge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd2YWx1ZScpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY3RpdmVFbGVtZW50LCAndmFsdWUnLCBuZXdWYWx1ZVByb3ApO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xufVxuXG4vKipcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJRDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lID09PSAnSU5QVVQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDbGljaykge1xuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuXG4gICAgdmFyIGdldFRhcmdldElERnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGlmIChkb2VzQ2hhbmdlRXZlbnRCdWJibGUpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRTtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SURGdW5jKSB7XG4gICAgICB2YXIgdGFyZ2V0SUQgPSBnZXRUYXJnZXRJREZ1bmModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gICAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCB0YXJnZXRJRCwgbmF0aXZlRXZlbnQpO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDbGllbnRSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuZXh0UmVhY3RSb290SW5kZXggPSAwO1xuXG52YXIgQ2xpZW50UmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5leHRSZWFjdFJvb3RJbmRleCsrO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFJlYWN0Um9vdEluZGV4OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01DaGlsZHJlbk9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGFuZ2VyID0gcmVxdWlyZShcIi4vRGFuZ2VyXCIpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNcIik7XG5cbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoXCIuL3NldFRleHRDb250ZW50XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBpbmRleCkge1xuICAvLyBCeSBleHBsb2l0aW5nIGFycmF5cyByZXR1cm5pbmcgYHVuZGVmaW5lZGAgZm9yIGFuIHVuZGVmaW5lZCBpbmRleCwgd2UgY2FuXG4gIC8vIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIEhvd2V2ZXIsIHVzaW5nIGB1bmRlZmluZWRgIGlzIG5vdCBhbGxvd2VkIGJ5IGFsbFxuICAvLyBicm93c2VycyBzbyB3ZSBtdXN0IHJlcGxhY2UgaXQgd2l0aCBgbnVsbGAuXG5cbiAgLy8gZml4IHJlbmRlciBvcmRlciBlcnJvciBpbiBzYWZhcmlcbiAgLy8gSUU4IHdpbGwgdGhyb3cgZXJyb3Igd2hlbiBpbmRleCBvdXQgb2YgbGlzdCBzaXplLlxuICB2YXIgYmVmb3JlQ2hpbGQgPSBpbmRleCA+PSBwYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID8gbnVsbCA6IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5pdGVtKGluZGV4KTtcblxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIGJlZm9yZUNoaWxkKTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciB1cGRhdGluZyB3aXRoIERPTSBjaGlsZHJlbi5cbiAqL1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHtcblxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHVwZGF0ZVRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwTGlzdCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbiAodXBkYXRlcywgbWFya3VwTGlzdCkge1xuICAgIHZhciB1cGRhdGU7XG4gICAgLy8gTWFwcGluZyBmcm9tIHBhcmVudCBJRHMgdG8gaW5pdGlhbCBjaGlsZCBvcmRlcmluZ3MuXG4gICAgdmFyIGluaXRpYWxDaGlsZHJlbiA9IG51bGw7XG4gICAgLy8gTGlzdCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgYmUgbW92ZWQgb3IgcmVtb3ZlZC5cbiAgICB2YXIgdXBkYXRlZENoaWxkcmVuID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdXBkYXRlID0gdXBkYXRlc1tpXTtcbiAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyB8fCB1cGRhdGUudHlwZSA9PT0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRJbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgIHZhciB1cGRhdGVkQ2hpbGQgPSB1cGRhdGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzW3VwZGF0ZWRJbmRleF07XG4gICAgICAgIHZhciBwYXJlbnRJRCA9IHVwZGF0ZS5wYXJlbnRJRDtcblxuICAgICAgICAhdXBkYXRlZENoaWxkID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NVcGRhdGVzKCk6IFVuYWJsZSB0byBmaW5kIGNoaWxkICVzIG9mIGVsZW1lbnQuIFRoaXMgJyArICdwcm9iYWJseSBtZWFucyB0aGUgRE9NIHdhcyB1bmV4cGVjdGVkbHkgbXV0YXRlZCAoZS5nLiwgYnkgdGhlICcgKyAnYnJvd3NlciksIHVzdWFsbHkgZHVlIHRvIGZvcmdldHRpbmcgYSA8dGJvZHk+IHdoZW4gdXNpbmcgdGFibGVzLCAnICsgJ25lc3RpbmcgdGFncyBsaWtlIDxmb3JtPiwgPHA+LCBvciA8YT4sIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgJyArICdpbiBhbiA8c3ZnPiBwYXJlbnQuIFRyeSBpbnNwZWN0aW5nIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZWxlbWVudCAnICsgJ3dpdGggUmVhY3QgSUQgYCVzYC4nLCB1cGRhdGVkSW5kZXgsIHBhcmVudElEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaW5pdGlhbENoaWxkcmVuID0gaW5pdGlhbENoaWxkcmVuIHx8IHt9O1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdID0gaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXSB8fCBbXTtcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXVt1cGRhdGVkSW5kZXhdID0gdXBkYXRlZENoaWxkO1xuXG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbiA9IHVwZGF0ZWRDaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgdXBkYXRlZENoaWxkcmVuLnB1c2godXBkYXRlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZWRNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAobWFya3VwTGlzdCk7XG5cbiAgICAvLyBSZW1vdmUgdXBkYXRlZCBjaGlsZHJlbiBmaXJzdCBzbyB0aGF0IGB0b0luZGV4YCBpcyBjb25zaXN0ZW50LlxuICAgIGlmICh1cGRhdGVkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdXBkYXRlZENoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbltqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVwZGF0ZWRDaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgcmVuZGVyZWRNYXJrdXBbdXBkYXRlLm1hcmt1cEluZGV4XSwgdXBkYXRlLnRvSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkc6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgaW5pdGlhbENoaWxkcmVuW3VwZGF0ZS5wYXJlbnRJRF1bdXBkYXRlLmZyb21JbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQ6XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQodXBkYXRlLnBhcmVudE5vZGUsIHVwZGF0ZS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREU6XG4gICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkIGJ5IHRoZSBmb3ItbG9vcCBhYm92ZS5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfQVRUUklCVVRFOiAxLFxuICBNVVNUX1VTRV9QUk9QRVJUWTogMixcbiAgSEFTX1NJREVfRUZGRUNUUzogNCxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDgsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAxNixcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDMyIHwgMTYsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDY0LFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTVByb3BlcnR5TmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01Qcm9wZXJ0eU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBpZiAoZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpIHtcbiAgICAgIERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5wdXNoKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIURPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnICsgJ1xcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5ICcgKyAnaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgJyArICdpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW3Byb3BOYW1lXSA9IHRydWU7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2F0dHJpYnV0ZU5hbWVdID0gcHJvcE5hbWU7XG4gICAgICAgIERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbcHJvcE5hbWVdID0gYXR0cmlidXRlTmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbcHJvcE5hbWVdID0gbG93ZXJDYXNlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVzcGFjZVtwcm9wTmFtZV0gPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVzcGFjZVtwcm9wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5nZXRQcm9wZXJ0eU5hbWVbcHJvcE5hbWVdID0gRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBET01Qcm9wZXJ0eU5hbWVzW3Byb3BOYW1lXSA6IHByb3BOYW1lO1xuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRNdXRhdGlvbk1ldGhvZFtwcm9wTmFtZV0gPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0TXV0YXRpb25NZXRob2RbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgIERPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbcHJvcE5hbWVdID0gY2hlY2tNYXNrKHByb3BDb25maWcsIERPTVByb3BlcnR5SW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURSk7XG4gICAgICBET01Qcm9wZXJ0eS5tdXN0VXNlUHJvcGVydHlbcHJvcE5hbWVdID0gY2hlY2tNYXNrKHByb3BDb25maWcsIERPTVByb3BlcnR5SW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKTtcbiAgICAgIERPTVByb3BlcnR5Lmhhc1NpZGVFZmZlY3RzW3Byb3BOYW1lXSA9IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBET01Qcm9wZXJ0eUluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTKTtcbiAgICAgIERPTVByb3BlcnR5Lmhhc0Jvb2xlYW5WYWx1ZVtwcm9wTmFtZV0gPSBjaGVja01hc2socHJvcENvbmZpZywgRE9NUHJvcGVydHlJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpO1xuICAgICAgRE9NUHJvcGVydHkuaGFzTnVtZXJpY1ZhbHVlW3Byb3BOYW1lXSA9IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBET01Qcm9wZXJ0eUluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSk7XG4gICAgICBET01Qcm9wZXJ0eS5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZVtwcm9wTmFtZV0gPSBjaGVja01hc2socHJvcENvbmZpZywgRE9NUHJvcGVydHlJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpO1xuICAgICAgRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtwcm9wTmFtZV0gPSBjaGVja01hc2socHJvcENvbmZpZywgRE9NUHJvcGVydHlJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSk7XG5cbiAgICAgICEoIURPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbcHJvcE5hbWVdIHx8ICFET01Qcm9wZXJ0eS5tdXN0VXNlUHJvcGVydHlbcHJvcE5hbWVdKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogQ2Fubm90IHJlcXVpcmUgdXNpbmcgYm90aCBhdHRyaWJ1dGUgYW5kIHByb3BlcnR5OiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAhKERPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0gfHwgIURPTVByb3BlcnR5Lmhhc1NpZGVFZmZlY3RzW3Byb3BOYW1lXSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFByb3BlcnRpZXMgdGhhdCBoYXZlIHNpZGUgZWZmZWN0cyBtdXN0IHVzZSBwcm9wZXJ0eTogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgISghIURPTVByb3BlcnR5Lmhhc0Jvb2xlYW5WYWx1ZVtwcm9wTmFtZV0gKyAhIURPTVByb3BlcnR5Lmhhc051bWVyaWNWYWx1ZVtwcm9wTmFtZV0gKyAhIURPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbcHJvcE5hbWVdIDw9IDEpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgJyArICdudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG52YXIgZGVmYXVsdFZhbHVlQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBET01Qcm9wZXJ0eSBleHBvcnRzIGxvb2t1cCBvYmplY3RzIHRoYXQgY2FuIGJlIHVzZWQgbGlrZSBmdW5jdGlvbnM6XG4gKlxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2lkJ11cbiAqICAgdHJ1ZVxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2Zvb2JhciddXG4gKiAgIHVuZGVmaW5lZFxuICpcbiAqIEFsdGhvdWdoIHRoaXMgbWF5IGJlIGNvbmZ1c2luZywgaXQgcGVyZm9ybXMgYmV0dGVyIGluIGdlbmVyYWwuXG4gKlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktZXhpc3RzXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1taXNzaW5nXG4gKi9cbnZhciBET01Qcm9wZXJ0eSA9IHtcblxuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHN0YW5kYXJkIHByb3BlcnR5LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgaXNTdGFuZGFyZE5hbWU6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCBuYW1lcyB0byBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBkaWZmZXIuIEF0dHJpYnV0ZVxuICAgKiBuYW1lcyBhcmUgdXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldEF0dHJpYnV0ZU5hbWU6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCBuYW1lcyB0byBuYW1lc3BhY2VzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlTmFtZXNwYWNlOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gcHJvcGVydGllcyBvbiBET00gbm9kZSBpbnN0YW5jZXMuXG4gICAqIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UHJvcGVydHlOYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gbXV0YXRpb24gbWV0aG9kcy4gVGhpcyB3aWxsIG9ubHkgZXhpc3QgaWZcbiAgICogbXV0YXRpb24gY2Fubm90IGJlIHNldCBzaW1wbHkgYnkgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRNdXRhdGlvbk1ldGhvZDoge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgbXVzdFVzZUF0dHJpYnV0ZToge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgdXNpbmcgYCpBdHRyaWJ1dGUoKWAuXG4gICAqIChUaGlzIGluY2x1ZGVzIGFueXRoaW5nIHRoYXQgZmFpbHMgYDxwcm9wTmFtZT4gaW4gPGVsZW1lbnQ+YC4pXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBtdXN0VXNlUHJvcGVydHk6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBzZXR0aW5nIGEgdmFsdWUgY2F1c2VzIHNpZGUgZWZmZWN0cyBzdWNoIGFzIHRyaWdnZXJpbmdcbiAgICogcmVzb3VyY2VzIHRvIGJlIGxvYWRlZCBvciB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzLiBXZSBtdXN0IGVuc3VyZSB0aGF0XG4gICAqIHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBpZiBpdCBoYXMgY2hhbmdlZC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGhhc1NpZGVFZmZlY3RzOiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNCb29sZWFuVmFsdWU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYVxuICAgKiBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGhhc051bWVyaWNWYWx1ZToge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuIFJlbW92ZWRcbiAgICogd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlbiBzdHJpY3RseSBlcXVhbFxuICAgKiB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiB7fSxcblxuICAvKipcbiAgICogQWxsIG9mIHRoZSBpc0N1c3RvbUF0dHJpYnV0ZSgpIGZ1bmN0aW9ucyB0aGF0IGhhdmUgYmVlbiBpbmplY3RlZC5cbiAgICovXG4gIF9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uczogW10sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIGN1c3RvbSBhdHRyaWJ1dGUuXG4gICAqIEBtZXRob2RcbiAgICovXG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXNDdXN0b21BdHRyaWJ1dGVGbiA9IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uc1tpXTtcbiAgICAgIGlmIChpc0N1c3RvbUF0dHJpYnV0ZUZuKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgZm9yIGEgRE9NIHByb3BlcnR5IChpLmUuLCBub3QgYW5cbiAgICogYXR0cmlidXRlKS4gTW9zdCBkZWZhdWx0IHZhbHVlcyBhcmUgJycgb3IgZmFsc2UsIGJ1dCBub3QgYWxsLiBXb3JzZSB5ZXQsXG4gICAqIHNvbWUgKGluIHBhcnRpY3VsYXIsIGB0eXBlYCkgdmFyeSBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgZWxlbWVudC5cbiAgICpcbiAgICogVE9ETzogSXMgaXQgYmV0dGVyIHRvIGdyYWIgYWxsIHRoZSBwb3NzaWJsZSBwcm9wZXJ0aWVzIHdoZW4gY3JlYXRpbmcgYW5cbiAgICogZWxlbWVudCB0byBhdm9pZCBoYXZpbmcgdG8gY3JlYXRlIHRoZSBzYW1lIGVsZW1lbnQgdHdpY2U/XG4gICAqL1xuICBnZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGVOYW1lLCBwcm9wKSB7XG4gICAgdmFyIG5vZGVEZWZhdWx0cyA9IGRlZmF1bHRWYWx1ZUNhY2hlW25vZGVOYW1lXTtcbiAgICB2YXIgdGVzdEVsZW1lbnQ7XG4gICAgaWYgKCFub2RlRGVmYXVsdHMpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZUNhY2hlW25vZGVOYW1lXSA9IG5vZGVEZWZhdWx0cyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIShwcm9wIGluIG5vZGVEZWZhdWx0cykpIHtcbiAgICAgIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICBub2RlRGVmYXVsdHNbcHJvcF0gPSB0ZXN0RWxlbWVudFtwcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVEZWZhdWx0c1twcm9wXTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcblxudmFyIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXJcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IERPTVByb3BlcnR5Lmhhc0Jvb2xlYW5WYWx1ZVtuYW1lXSAmJiAhdmFsdWUgfHwgRE9NUHJvcGVydHkuaGFzTnVtZXJpY1ZhbHVlW25hbWVdICYmIGlzTmFOKHZhbHVlKSB8fCBET01Qcm9wZXJ0eS5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZVtuYW1lXSAmJiB2YWx1ZSA8IDEgfHwgRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtuYW1lXSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbmlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHZhciByZWFjdFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICAgIGtleTogdHJ1ZSxcbiAgICByZWY6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgd2FyblVua25vd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHJlYWN0UHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcmVhY3RQcm9wc1tuYW1lXSB8fCB3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAvLyBGb3Igbm93LCBvbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgc3VnZ2VzdGVkIGNvcnJlY3Rpb24uIFRoaXMgcHJldmVudHNcbiAgICAvLyBsb2dnaW5nIHRvbyBtdWNoIHdoZW4gdXNpbmcgdHJhbnNmZXJQcm9wc1RvLlxuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHN0YW5kYXJkTmFtZSA9PSBudWxsLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBJRCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuZXNjYXBlZCBJRC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9ySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKGlkKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KG5hbWUpICYmIERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW25hbWVdKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUobmFtZSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NUHJvcGVydHkuZ2V0QXR0cmlidXRlTmFtZVtuYW1lXTtcbiAgICAgIGlmIChET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbbmFtZV0gfHwgRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtuYW1lXSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWVbbmFtZV0pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IERPTVByb3BlcnR5LmdldE11dGF0aW9uTWV0aG9kW25hbWVdO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUobmFtZSwgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkubXVzdFVzZUF0dHJpYnV0ZVtuYW1lXSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbbmFtZV07XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lc3BhY2VbbmFtZV07XG4gICAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBET01Qcm9wZXJ0eS5nZXRQcm9wZXJ0eU5hbWVbbmFtZV07XG4gICAgICAgIC8vIE11c3QgZXhwbGljaXRseSBjYXN0IHZhbHVlcyBmb3IgSEFTX1NJREVfRUZGRUNUUy1wcm9wZXJ0aWVzIHRvIHRoZVxuICAgICAgICAvLyBwcm9wZXJ0eSB0eXBlIGJlZm9yZSBjb21wYXJpbmc7IG9ubHkgYHZhbHVlYCBkb2VzIGFuZCBpcyBzdHJpbmcuXG4gICAgICAgIGlmICghRE9NUHJvcGVydHkuaGFzU2lkZUVmZmVjdHNbbmFtZV0gfHwgJycgKyBub2RlW3Byb3BOYW1lXSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KG5hbWUpICYmIERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW25hbWVdKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBET01Qcm9wZXJ0eS5nZXRNdXRhdGlvbk1ldGhvZFtuYW1lXTtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5tdXN0VXNlQXR0cmlidXRlW25hbWVdKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbbmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gRE9NUHJvcGVydHkuZ2V0UHJvcGVydHlOYW1lW25hbWVdO1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gRE9NUHJvcGVydHkuZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHkobm9kZS5ub2RlTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICBpZiAoIURPTVByb3BlcnR5Lmhhc1NpZGVFZmZlY3RzW25hbWVdIHx8ICcnICsgbm9kZVtwcm9wTmFtZV0gIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGFuZ2VyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKFwiLi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXBcIik7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoXCIuL2dldE1hcmt1cFdyYXBcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgT1BFTl9UQUdfTkFNRV9FWFAgPSAvXig8W14gXFwvPl0rKS87XG52YXIgUkVTVUxUX0lOREVYX0FUVFIgPSAnZGF0YS1kYW5nZXItaW5kZXgnO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIGZyb20gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIE5PVEU6IEV4dHJhY3RpbmcgdGhlIGBub2RlTmFtZWAgZG9lcyBub3QgcmVxdWlyZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaFxuICogYmVjYXVzZSB3ZSBtYWtlIGFzc3VtcHRpb25zIGFib3V0IFJlYWN0LWdlbmVyYXRlZCBtYXJrdXAgKGkuZS4gdGhlcmUgYXJlIG5vXG4gKiBzcGFjZXMgc3Vycm91bmRpbmcgdGhlIG9wZW5pbmcgdGFnIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgYXR0cmlidXRlKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9leHRyYWN0LW5vZGVuYW1lXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICByZXR1cm4gbWFya3VwLnN1YnN0cmluZygxLCBtYXJrdXAuaW5kZXhPZignICcpKTtcbn1cblxudmFyIERhbmdlciA9IHtcblxuICAvKipcbiAgICogUmVuZGVycyBtYXJrdXAgaW50byBhbiBhcnJheSBvZiBub2Rlcy4gVGhlIG1hcmt1cCBpcyBleHBlY3RlZCB0byByZW5kZXJcbiAgICogaW50byBhIGxpc3Qgb2Ygcm9vdCBub2Rlcy4gQWxzbywgdGhlIGxlbmd0aCBvZiBgcmVzdWx0TGlzdGAgYW5kXG4gICAqIGBtYXJrdXBMaXN0YCBzaG91bGQgYmUgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwTGlzdCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzIHRvIHJlbmRlci5cbiAgICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudD59IExpc3Qgb2YgcmVuZGVyZWQgbm9kZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXBMaXN0KSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhIHdvcmtlciAnICsgJ3RocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgZ2xvYmFsbHkgJyArICdiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSAnICsgJ1JlYWN0LnJlbmRlclRvU3RyaW5nIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbm9kZU5hbWU7XG4gICAgdmFyIG1hcmt1cEJ5Tm9kZU5hbWUgPSB7fTtcbiAgICAvLyBHcm91cCBtYXJrdXAgYnkgYG5vZGVOYW1lYCBpZiBhIHdyYXAgaXMgbmVjZXNzYXJ5LCBlbHNlIGJ5ICcqJy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmt1cExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICFtYXJrdXBMaXN0W2ldID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVuZGVyTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwTGlzdFtpXSk7XG4gICAgICBub2RlTmFtZSA9IGdldE1hcmt1cFdyYXAobm9kZU5hbWUpID8gbm9kZU5hbWUgOiAnKic7XG4gICAgICBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSA9IG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdIHx8IFtdO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV1baV0gPSBtYXJrdXBMaXN0W2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0TGlzdCA9IFtdO1xuICAgIHZhciByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID0gMDtcbiAgICBmb3IgKG5vZGVOYW1lIGluIG1hcmt1cEJ5Tm9kZU5hbWUpIHtcbiAgICAgIGlmICghbWFya3VwQnlOb2RlTmFtZS5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbWFya3VwTGlzdEJ5Tm9kZU5hbWUgPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXTtcblxuICAgICAgLy8gVGhpcyBmb3ItaW4gbG9vcCBza2lwcyB0aGUgaG9sZXMgb2YgdGhlIHNwYXJzZSBhcnJheS4gVGhlIG9yZGVyIG9mXG4gICAgICAvLyBpdGVyYXRpb24gc2hvdWxkIGZvbGxvdyB0aGUgb3JkZXIgb2YgYXNzaWdubWVudCwgd2hpY2ggaGFwcGVucyB0byBtYXRjaFxuICAgICAgLy8gbnVtZXJpY2FsIGluZGV4IG9yZGVyLCBidXQgd2UgZG9uJ3QgcmVseSBvbiB0aGF0LlxuICAgICAgdmFyIHJlc3VsdEluZGV4O1xuICAgICAgZm9yIChyZXN1bHRJbmRleCBpbiBtYXJrdXBMaXN0QnlOb2RlTmFtZSkge1xuICAgICAgICBpZiAobWFya3VwTGlzdEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpKSB7XG4gICAgICAgICAgdmFyIG1hcmt1cCA9IG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XTtcblxuICAgICAgICAgIC8vIFB1c2ggdGhlIHJlcXVlc3RlZCBtYXJrdXAgd2l0aCBhbiBhZGRpdGlvbmFsIFJFU1VMVF9JTkRFWF9BVFRSXG4gICAgICAgICAgLy8gYXR0cmlidXRlLiAgSWYgdGhlIG1hcmt1cCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgPCBjaGFyYWN0ZXIsIGl0XG4gICAgICAgICAgLy8gd2lsbCBiZSBkaXNjYXJkZWQgYmVsb3cgKHdpdGggYW4gYXBwcm9wcmlhdGUgY29uc29sZS5lcnJvcikuXG4gICAgICAgICAgbWFya3VwTGlzdEJ5Tm9kZU5hbWVbcmVzdWx0SW5kZXhdID0gbWFya3VwLnJlcGxhY2UoT1BFTl9UQUdfTkFNRV9FWFAsXG4gICAgICAgICAgLy8gVGhpcyBpbmRleCB3aWxsIGJlIHBhcnNlZCBiYWNrIG91dCBiZWxvdy5cbiAgICAgICAgICAnJDEgJyArIFJFU1VMVF9JTkRFWF9BVFRSICsgJz1cIicgKyByZXN1bHRJbmRleCArICdcIiAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW5kZXIgZWFjaCBncm91cCBvZiBtYXJrdXAgd2l0aCBzaW1pbGFyIHdyYXBwaW5nIGBub2RlTmFtZWAuXG4gICAgICB2YXIgcmVuZGVyTm9kZXMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwTGlzdEJ5Tm9kZU5hbWUuam9pbignJyksIGVtcHR5RnVuY3Rpb24gLy8gRG8gbm90aGluZyBzcGVjaWFsIHdpdGggPHNjcmlwdD4gdGFncy5cbiAgICAgICk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVuZGVyTm9kZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIHJlbmRlck5vZGUgPSByZW5kZXJOb2Rlc1tqXTtcbiAgICAgICAgaWYgKHJlbmRlck5vZGUuaGFzQXR0cmlidXRlICYmIHJlbmRlck5vZGUuaGFzQXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKSkge1xuXG4gICAgICAgICAgcmVzdWx0SW5kZXggPSArcmVuZGVyTm9kZS5nZXRBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpO1xuICAgICAgICAgIHJlbmRlck5vZGUucmVtb3ZlQXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcblxuICAgICAgICAgICEhcmVzdWx0TGlzdC5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBBc3NpZ25pbmcgdG8gYW4gYWxyZWFkeS1vY2N1cGllZCByZXN1bHQgaW5kZXguJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgcmVzdWx0TGlzdFtyZXN1bHRJbmRleF0gPSByZW5kZXJOb2RlO1xuXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbWF0Y2ggcmVzdWx0TGlzdC5sZW5ndGggYW5kIG1hcmt1cExpc3QubGVuZ3RoIHdoZW5cbiAgICAgICAgICAvLyB3ZSdyZSBkb25lLlxuICAgICAgICAgIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRGFuZ2VyOiBEaXNjYXJkaW5nIHVuZXhwZWN0ZWQgbm9kZTonLCByZW5kZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsdGhvdWdoIHJlc3VsdExpc3Qgd2FzIHBvcHVsYXRlZCBvdXQgb2Ygb3JkZXIsIGl0IHNob3VsZCBub3cgYmUgYSBkZW5zZVxuICAgIC8vIGFycmF5LlxuICAgICEocmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9PT0gcmVzdWx0TGlzdC5sZW5ndGgpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogRGlkIG5vdCBhc3NpZ24gdG8gZXZlcnkgaW5kZXggb2YgcmVzdWx0TGlzdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAhKHJlc3VsdExpc3QubGVuZ3RoID09PSBtYXJrdXBMaXN0Lmxlbmd0aCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBFeHBlY3RlZCBtYXJrdXAgdG8gcmVuZGVyICVzIG5vZGVzLCBidXQgcmVuZGVyZWQgJXMuJywgbWFya3VwTGlzdC5sZW5ndGgsIHJlc3VsdExpc3QubGVuZ3RoKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gcmVzdWx0TGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSAnICsgJ3dvcmtlciB0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlICcgKyAnZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArICdSZWFjdC5yZW5kZXJUb1N0cmluZyBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIW1hcmt1cCA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIShvbGRDaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSAnICsgJzxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgJyArICdhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSAnICsgJ3NlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdC5yZW5kZXJUb1N0cmluZygpLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYW5nZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW2tleU9mKHsgUmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2ltcGxlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgVGFwRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IENoYW5nZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNlbGVjdEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgQW5hbHl0aWNzRXZlbnRQbHVnaW46IG51bGwgfSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljTW91c2VFdmVudFwiKTtcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbnZhciBnZXRGaXJzdFJlYWN0RE9NID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUVudGVyOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlTGVhdmU6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH1cbn07XG5cbnZhciBleHRyYWN0ZWRFdmVudHMgPSBbbnVsbCwgbnVsbF07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQgJiYgdG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcikge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBpbiBvciBtb3VzZSBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW47XG4gICAgaWYgKHRvcExldmVsVGFyZ2V0LndpbmRvdyA9PT0gdG9wTGV2ZWxUYXJnZXQpIHtcbiAgICAgIC8vIGB0b3BMZXZlbFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSB0b3BMZXZlbFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbSwgdG87XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCkge1xuICAgICAgZnJvbSA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgdG8gPSBnZXRGaXJzdFJlYWN0RE9NKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50KSB8fCB3aW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb20gPSB3aW47XG4gICAgICB0byA9IHRvcExldmVsVGFyZ2V0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21JRCA9IGZyb20gPyBSZWFjdE1vdW50LmdldElEKGZyb20pIDogJyc7XG4gICAgdmFyIHRvSUQgPSB0byA/IFJlYWN0TW91bnQuZ2V0SUQodG8pIDogJyc7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlTGVhdmUsIGZyb21JRCwgbmF0aXZlRXZlbnQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG87XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvSUQsIG5hdGl2ZUV2ZW50KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpO1xuXG4gICAgZXh0cmFjdGVkRXZlbnRzWzBdID0gbGVhdmU7XG4gICAgZXh0cmFjdGVkRXZlbnRzWzFdID0gZW50ZXI7XG5cbiAgICByZXR1cm4gZXh0cmFjdGVkRXZlbnRzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0ga2V5TWlycm9yKHsgYnViYmxlZDogbnVsbCwgY2FwdHVyZWQ6IG51bGwgfSk7XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICB0b3BCbHVyOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcEVycm9yOiBudWxsLFxuICB0b3BGb2N1czogbnVsbCxcbiAgdG9wSW5wdXQ6IG51bGwsXG4gIHRvcEtleURvd246IG51bGwsXG4gIHRvcEtleVByZXNzOiBudWxsLFxuICB0b3BLZXlVcDogbnVsbCxcbiAgdG9wTG9hZDogbnVsbCxcbiAgdG9wTW91c2VEb3duOiBudWxsLFxuICB0b3BNb3VzZU1vdmU6IG51bGwsXG4gIHRvcE1vdXNlT3V0OiBudWxsLFxuICB0b3BNb3VzZU92ZXI6IG51bGwsXG4gIHRvcE1vdXNlVXA6IG51bGwsXG4gIHRvcFBhc3RlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6IG51bGwsXG4gIHRvcFN1Ym1pdDogbnVsbCxcbiAgdG9wVGV4dElucHV0OiBudWxsLFxuICB0b3BUb3VjaENhbmNlbDogbnVsbCxcbiAgdG9wVG91Y2hFbmQ6IG51bGwsXG4gIHRvcFRvdWNoTW92ZTogbnVsbCxcbiAgdG9wVG91Y2hTdGFydDogbnVsbCxcbiAgdG9wV2hlZWw6IG51bGxcbn0pO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMsXG4gIFByb3BhZ2F0aW9uUGhhc2VzOiBQcm9wYWdhdGlvblBoYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbnN0YW50czsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICghdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luUmVnaXN0cnlcIik7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luVXRpbHNcIik7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoXCIuL2FjY3VtdWxhdGVJbnRvXCIpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoXCIuL2ZvckVhY2hBY2N1bXVsYXRlZFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICB2YXIgZXhlY3V0ZURpc3BhdGNoID0gRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2g7XG4gICAgLy8gUGx1Z2lucyBjYW4gcHJvdmlkZSBjdXN0b20gYmVoYXZpb3Igd2hlbiBkaXNwYXRjaGluZyBldmVudHMuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQoZXZlbnQpO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmV4ZWN1dGVEaXNwYXRjaCkge1xuICAgICAgZXhlY3V0ZURpc3BhdGNoID0gUGx1Z2luTW9kdWxlLmV4ZWN1dGVEaXNwYXRjaDtcbiAgICB9XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIGV4ZWN1dGVEaXNwYXRjaCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogLSBgSW5zdGFuY2VIYW5kbGVgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IHBlcmZvcm1zIGxvZ2ljYWwgdHJhdmVyc2FscyBvZiBET01cbiAqICAgaGllcmFyY2h5IGdpdmVuIGlkcyBvZiB0aGUgbG9naWNhbCBET00gZWxlbWVudHMgaW52b2x2ZWQuXG4gKi9cbnZhciBJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKSB7XG4gIHZhciB2YWxpZCA9IEluc3RhbmNlSGFuZGxlICYmIEluc3RhbmNlSGFuZGxlLnRyYXZlcnNlVHdvUGhhc2UgJiYgSW5zdGFuY2VIYW5kbGUudHJhdmVyc2VFbnRlckxlYXZlO1xuICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyh2YWxpZCwgJ0luc3RhbmNlSGFuZGxlIG5vdCBpbmplY3RlZCBiZWZvcmUgdXNlIScpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEluamVjdGVkTW91bnRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0TW91bnQ6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEluamVjdGVkSW5zdGFuY2VIYW5kbGVcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0SW5zdGFuY2VIYW5kbGU6IGZ1bmN0aW9uIChJbmplY3RlZEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBJbnN0YW5jZUhhbmRsZSA9IEluamVjdGVkSW5zdGFuY2VIYW5kbGU7XG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSW5zdGFuY2VIYW5kbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG5cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXWAuIElzIGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgISh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkICVzIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IHR5cGUgJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSB8fCAobGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdID0ge30pO1xuICAgIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIHJldHVybiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSAmJiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSByZWdpc3RyYXRpb24gYmFuay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKi9cbiAgZGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIGRlbGV0ZSBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGlkKSB7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSk7XG4gICAgISFldmVudFF1ZXVlID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyAnICsgJ2FuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblJlZ2lzdHJ5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluICcgKyAndGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhUGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgJyArICdtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gUGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICsgJ2V2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzIGFuZFxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHtcblxuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAgICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24gKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgICEhRXZlbnRQbHVnaW5PcmRlciA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gJyArICdvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBFdmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24gKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IFBsdWdpbk1vZHVsZSkge1xuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zICcgKyAndXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVdIHx8IG51bGw7XG4gICAgfVxuICAgIGZvciAodmFyIHBoYXNlIGluIGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAoIWRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW5Nb2R1bGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRFdmVudFBsdWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAobmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnMubGVuZ3RoID0gMDtcblxuICAgIHZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcykge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBNb3VudGA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBkb20gSURzIGFuZFxuICogICBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgaW5qZWN0aW9uID0ge1xuICBNb3VudDogbnVsbCxcbiAgaW5qZWN0TW91bnQ6IGZ1bmN0aW9uIChJbmplY3RlZE1vdW50KSB7XG4gICAgaW5qZWN0aW9uLk1vdW50ID0gSW5qZWN0ZWRNb3VudDtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoSW5qZWN0ZWRNb3VudCAmJiBJbmplY3RlZE1vdW50LmdldE5vZGUgJiYgSW5qZWN0ZWRNb3VudC5nZXRJRCwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50KC4uLik6IEluamVjdGVkIE1vdW50ICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZSBvciBnZXRJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGlkc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaElEcyk7XG4gICAgdmFyIElEc0xlbiA9IGlkc0lzQXJyID8gZGlzcGF0Y2hJRHMubGVuZ3RoIDogZGlzcGF0Y2hJRHMgPyAxIDogMDtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoaWRzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIElEc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNiKGV2ZW50LCBsaXN0ZW5lciwgaWQpYC4gQXZvaWRzIHVzaW5nIGNhbGwgaWYgbm8gc2NvcGUgaXNcbiAqIHByb3ZpZGVkLiBUaGUgYChsaXN0ZW5lcixpZClgIHBhaXIgZWZmZWN0aXZlbHkgZm9ybXMgdGhlIFwiZGlzcGF0Y2hcIiBidXQgYXJlXG4gKiBrZXB0IHNlcGFyYXRlIHRvIGNvbnNlcnZlIG1lbW9yeS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEV2ZW50RGlzcGF0Y2goZXZlbnQsIGNiKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgY2IoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaElEc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgY2IoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaElEcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2goKS5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gaWQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgbGlzdGVuZXIsIGRvbUlEKSB7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBpbmplY3Rpb24uTW91bnQuZ2V0Tm9kZShkb21JRCk7XG4gIHZhciByZXR1cm5WYWx1ZSA9IGxpc3RlbmVyKGV2ZW50LCBkb21JRCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgY2IpIHtcbiAgZm9yRWFjaEV2ZW50RGlzcGF0Y2goZXZlbnQsIGNiKTtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zIHRydWUsIG9yXG4gKiBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaElEc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSURzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJRHMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJRHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpcmVjdERpc3BhdGNoKGV2ZW50KSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIHZhciBkaXNwYXRjaExpc3RlbmVyID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRCA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgISFBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXIpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2V4ZWN1dGVEaXJlY3REaXNwYXRjaCguLi4pOiBJbnZhbGlkIGBldmVudGAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQsIGRpc3BhdGNoSUQpIDogbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbH0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cbmZ1bmN0aW9uIGhhc0Rpc3BhdGNoZXMoZXZlbnQpIHtcbiAgcmV0dXJuICEhZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xufVxuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0aWVzIHRoYXQgYXJlIHVzZWZ1bCBpbiBjcmVhdGluZyBjdXN0b20gRXZlbnQgUGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSB7XG4gIGlzRW5kaXNoOiBpc0VuZGlzaCxcbiAgaXNNb3ZlaXNoOiBpc01vdmVpc2gsXG4gIGlzU3RhcnRpc2g6IGlzU3RhcnRpc2gsXG5cbiAgZXhlY3V0ZURpcmVjdERpc3BhdGNoOiBleGVjdXRlRGlyZWN0RGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaDogZXhlY3V0ZURpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXROb2RlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldE5vZGUoaWQpO1xuICB9LFxuICBnZXRJRDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldElEKG5vZGUpO1xuICB9LFxuXG4gIGluamVjdGlvbjogaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5IdWJcIik7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZShcIi4vYWNjdW11bGF0ZUludG9cIik7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZShcIi4vZm9yRWFjaEFjY3VtdWxhdGVkXCIpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBFdmVudENvbnN0YW50cy5Qcm9wYWdhdGlvblBoYXNlcztcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpZCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoZG9tSUQsIHVwd2FyZHMsIGV2ZW50KSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZG9tSUQsICdEaXNwYXRjaGluZyBpZCBtdXN0IG5vdCBiZSBudWxsJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHBoYXNlID0gdXB3YXJkcyA/IFByb3BhZ2F0aW9uUGhhc2VzLmJ1YmJsZWQgOiBQcm9wYWdhdGlvblBoYXNlcy5jYXB0dXJlZDtcbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGRvbUlELCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGRvbUlEKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2FuIG5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VUd29QaGFzZShldmVudC5kaXNwYXRjaE1hcmtlciwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VUd29QaGFzZVNraXBUYXJnZXQoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGlkLCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaElEcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaElEcywgaWQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKSB7XG4gIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tSUQsIHRvSUQsIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFeGVjdXRpb25FbnZpcm9ubWVudFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoXCIuL2dldFRleHRDb250ZW50QWNjZXNzb3JcIik7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmFzc2lnbihGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gdGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gdGhpcy5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEhUTUxET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIE1VU1RfVVNFX0FUVFJJQlVURSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NJREVfRUZGRUNUUyA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIGhhc1NWRztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIGltcGxlbWVudGF0aW9uID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb247XG4gIGhhc1NWRyA9IGltcGxlbWVudGF0aW9uICYmIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiYgaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZScsICcxLjEnKTtcbn1cblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKGRhdGF8YXJpYSktW2Etel9dW2EtelxcZF8uXFwtXSokLyksXG4gIFByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWNjZXB0OiBudWxsLFxuICAgIGFjY2VwdENoYXJzZXQ6IG51bGwsXG4gICAgYWNjZXNzS2V5OiBudWxsLFxuICAgIGFjdGlvbjogbnVsbCxcbiAgICBhbGxvd0Z1bGxTY3JlZW46IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGFsbG93VHJhbnNwYXJlbmN5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgYWx0OiBudWxsLFxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvQ29tcGxldGU6IG51bGwsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNNaXhpblxuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNlbGxQYWRkaW5nOiBudWxsLFxuICAgIGNlbGxTcGFjaW5nOiBudWxsLFxuICAgIGNoYXJTZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjaGVja2VkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNsYXNzSUQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBUbyBzZXQgY2xhc3NOYW1lIG9uIFNWRyBlbGVtZW50cywgaXQncyBuZWNlc3NhcnkgdG8gdXNlIC5zZXRBdHRyaWJ1dGU7XG4gICAgLy8gdGhpcyB3b3JrcyBvbiBIVE1MIGVsZW1lbnRzIHRvbyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IElFOC4gQ29udmVuaWVudGx5LFxuICAgIC8vIElFOCBkb2Vzbid0IHN1cHBvcnQgU1ZHIGFuZCBzbyB3ZSBjYW4gc2ltcGx5IHVzZSB0aGUgYXR0cmlidXRlIGluXG4gICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IFNWRyBhbmQgdGhlIHByb3BlcnR5IGluIGJyb3dzZXJzIHRoYXQgZG9uJ3QsXG4gICAgLy8gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIEhUTUwgb3IgU1ZHLlxuICAgIGNsYXNzTmFtZTogaGFzU1ZHID8gTVVTVF9VU0VfQVRUUklCVVRFIDogTVVTVF9VU0VfUFJPUEVSVFksXG4gICAgY29sczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29sU3BhbjogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogbnVsbCxcbiAgICBjb250ZXh0TWVudTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNvbnRyb2xzOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogbnVsbCxcbiAgICBjcm9zc09yaWdpbjogbnVsbCxcbiAgICBkYXRhOiBudWxsLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiBudWxsLFxuICAgIGRpc2FibGVkOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IG51bGwsXG4gICAgZW5jVHlwZTogbnVsbCxcbiAgICBmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybUFjdGlvbjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1FbmNUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybU1ldGhvZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtVGFyZ2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnJhbWVCb3JkZXI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoZWFkZXJzOiBudWxsLFxuICAgIGhlaWdodDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGhpZGRlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlnaDogbnVsbCxcbiAgICBocmVmOiBudWxsLFxuICAgIGhyZWZMYW5nOiBudWxsLFxuICAgIGh0bWxGb3I6IG51bGwsXG4gICAgaHR0cEVxdWl2OiBudWxsLFxuICAgIGljb246IG51bGwsXG4gICAgaWQ6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGxhYmVsOiBudWxsLFxuICAgIGxhbmc6IG51bGwsXG4gICAgbGlzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGxvb3A6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiBudWxsLFxuICAgIG1hbmlmZXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFyZ2luSGVpZ2h0OiBudWxsLFxuICAgIG1hcmdpbldpZHRoOiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1lZGlhR3JvdXA6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtaW5MZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiBudWxsLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IG51bGwsXG4gICAgcGF0dGVybjogbnVsbCxcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwb3N0ZXI6IG51bGwsXG4gICAgcHJlbG9hZDogbnVsbCxcbiAgICByYWRpb0dyb3VwOiBudWxsLFxuICAgIHJlYWRPbmx5OiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlbDogbnVsbCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJvd3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IG51bGwsXG4gICAgc2FuZGJveDogbnVsbCxcbiAgICBzY29wZTogbnVsbCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogbnVsbCxcbiAgICBzZWFtbGVzczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IG51bGwsXG4gICAgc2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiBudWxsLFxuICAgIHNyYzogbnVsbCxcbiAgICBzcmNEb2M6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIHNyY1NldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHRhYkluZGV4OiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0aXRsZTogbnVsbCxcbiAgICB0eXBlOiBudWxsLFxuICAgIHVzZU1hcDogbnVsbCxcbiAgICB2YWx1ZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfU0lERV9FRkZFQ1RTLFxuICAgIHdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgd21vZGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogbnVsbCxcbiAgICBhdXRvQ29ycmVjdDogbnVsbCxcbiAgICAvLyBpdGVtUHJvcCwgaXRlbVNjb3BlLCBpdGVtVHlwZSBhcmUgZm9yXG4gICAgLy8gTWljcm9kYXRhIHN1cHBvcnQuIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtUHJvcDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGl0ZW1TY29wZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaXRlbVJlZjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIHByb3BlcnR5IGlzIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogbnVsbCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7XG4gICAgYXV0b0NhcGl0YWxpemU6ICdhdXRvY2FwaXRhbGl6ZScsXG4gICAgYXV0b0NvbXBsZXRlOiAnYXV0b2NvbXBsZXRlJyxcbiAgICBhdXRvQ29ycmVjdDogJ2F1dG9jb3JyZWN0JyxcbiAgICBhdXRvRm9jdXM6ICdhdXRvZm9jdXMnLFxuICAgIGF1dG9QbGF5OiAnYXV0b3BsYXknLFxuICAgIC8vIGBlbmNvZGluZ2AgaXMgZXF1aXZhbGVudCB0byBgZW5jdHlwZWAsIElFOCBsYWNrcyBhbiBgZW5jdHlwZWAgc2V0dGVyLlxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjZG9tLWZzLWVuY29kaW5nXG4gICAgZW5jVHlwZTogJ2VuY29kaW5nJyxcbiAgICBocmVmTGFuZzogJ2hyZWZsYW5nJyxcbiAgICByYWRpb0dyb3VwOiAncmFkaW9ncm91cCcsXG4gICAgc3BlbGxDaGVjazogJ3NwZWxsY2hlY2snLFxuICAgIHNyY0RvYzogJ3NyY2RvYycsXG4gICAgc3JjU2V0OiAnc3Jjc2V0J1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTGlua2VkU3RhdGVNaXhpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdExpbmsgPSByZXF1aXJlKFwiLi9SZWFjdExpbmtcIik7XG52YXIgUmVhY3RTdGF0ZVNldHRlcnMgPSByZXF1aXJlKFwiLi9SZWFjdFN0YXRlU2V0dGVyc1wiKTtcblxuLyoqXG4gKiBBIHNpbXBsZSBtaXhpbiBhcm91bmQgUmVhY3RMaW5rLmZvclN0YXRlKCkuXG4gKi9cbnZhciBMaW5rZWRTdGF0ZU1peGluID0ge1xuICAvKipcbiAgICogQ3JlYXRlIGEgUmVhY3RMaW5rIHRoYXQncyBsaW5rZWQgdG8gcGFydCBvZiB0aGlzIGNvbXBvbmVudCdzIHN0YXRlLiBUaGVcbiAgICogUmVhY3RMaW5rIHdpbGwgaGF2ZSB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGlzLnN0YXRlW2tleV0gYW5kIHdpbGwgY2FsbFxuICAgKiBzZXRTdGF0ZSgpIHdoZW4gYSBjaGFuZ2UgaXMgcmVxdWVzdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0YXRlIGtleSB0byB1cGRhdGUuIE5vdGU6IHlvdSBtYXkgd2FudCB0byB1c2Uga2V5T2YoKVxuICAgKiBpZiB5b3UncmUgdXNpbmcgR29vZ2xlIENsb3N1cmUgQ29tcGlsZXIgYWR2YW5jZWQgbW9kZS5cbiAgICogQHJldHVybiB7UmVhY3RMaW5rfSBSZWFjdExpbmsgaW5zdGFuY2UgbGlua2luZyB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBsaW5rU3RhdGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3IFJlYWN0TGluayh0aGlzLnN0YXRlW2tleV0sIFJlYWN0U3RhdGVTZXR0ZXJzLmNyZWF0ZVN0YXRlS2V5U2V0dGVyKHRoaXMsIGtleSkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFN0YXRlTWl4aW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlc1wiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSAnICsgJ2NoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCAnICsgJ3RvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuICcgKyAnSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWQgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gJyArICd1c2UgY2hlY2tlZExpbmsnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZSBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVMaW5rZWRWYWx1ZUNoYW5nZShlKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHRoaXMucHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZS50YXJnZXQudmFsdWUpO1xufVxuXG4vKipcbiAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBlIGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgKi9cbmZ1bmN0aW9uIF9oYW5kbGVMaW5rZWRDaGVja0NoYW5nZShlKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHRoaXMucHJvcHMuY2hlY2tlZExpbmsucmVxdWVzdENoYW5nZShlLnRhcmdldC5jaGVja2VkKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBNaXhpbjoge1xuICAgIHByb3BUeXBlczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBSZWFjdFByb3BUeXBlcy5mdW5jXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gY2hhbmdlIGNhbGxiYWNrIGVpdGhlciBmcm9tIG9uQ2hhbmdlIHByb3Agb3IgbGluay5cbiAgICovXG4gIGdldE9uQ2hhbmdlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBfaGFuZGxlTGlua2VkVmFsdWVDaGFuZ2U7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gX2hhbmRsZUxpbmtlZENoZWNrQ2hhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy5vbkNoYW5nZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRWYWx1ZVV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBMb2NhbEV2ZW50VHJhcE1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKFwiLi9hY2N1bXVsYXRlSW50b1wiKTtcbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoXCIuL2ZpbmRET01Ob2RlXCIpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoXCIuL2ZvckVhY2hBY2N1bXVsYXRlZFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbmZ1bmN0aW9uIHJlbW92ZShldmVudCkge1xuICBldmVudC5yZW1vdmUoKTtcbn1cblxudmFyIExvY2FsRXZlbnRUcmFwTWl4aW4gPSB7XG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSkge1xuICAgICF0aGlzLmlzTW91bnRlZCgpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCByZW5kZXJzIHRvIG51bGwgb3IgaWYgYW5vdGhlciBjb21wb25lbnQgZmF0YWxzIGFuZCBjYXVzZXNcbiAgICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgICB2YXIgbm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICFub2RlID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0xvY2FsRXZlbnRUcmFwTWl4aW4udHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGlzdGVuZXIgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgbm9kZSk7XG4gICAgdGhpcy5fbG9jYWxFdmVudExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgfSxcblxuICAvLyB0cmFwQ2FwdHVyZWRFdmVudCB3b3VsZCBsb29rIG5lYXJseSBpZGVudGljYWwuIFdlIGRvbid0IGltcGxlbWVudCB0aGF0XG4gIC8vIG1ldGhvZCBiZWNhdXNlIGl0IGlzbid0IGN1cnJlbnRseSBuZWVkZWQuXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbG9jYWxFdmVudExpc3RlbmVycykge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMsIHJlbW92ZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsRXZlbnRUcmFwTWl4aW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIE9iamVjdC5hc3NpZ25cbiAqL1xuXG4vLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnblxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZXMpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiB0YXJnZXQgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBuZXh0SW5kZXggPSAxOyBuZXh0SW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBuZXh0SW5kZXgrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW25leHRJbmRleF07XG4gICAgaWYgKG5leHRTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSBPYmplY3QobmV4dFNvdXJjZSk7XG5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCBhY2Nlc3NvcnMgbm9yIHByb3hpZXMuIFRoZXJlZm9yZSB0aGlzXG4gICAgLy8gY29weSBjYW5ub3QgdGhyb3cuIElmIHdlIGV2ZXIgc3VwcG9ydGVkIHRoaXMgdGhlbiB3ZSBtdXN0IGhhbmRsZVxuICAgIC8vIGV4Y2VwdGlvbnMgYW5kIHNpZGUtZWZmZWN0cy4gV2UgZG9uJ3Qgc3VwcG9ydCBzeW1ib2xzIHNvIHRoZXkgd29uJ3RcbiAgICAvLyBiZSB0cmFuc2ZlcnJlZC5cblxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUG9vbGVkQ2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChpbnN0YW5jZS5kZXN0cnVjdG9yKSB7XG4gICAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICB9XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMgKG9wdGlvbmFsKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNsaWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NQ2xpZW50XCIpO1xudmFyIFJlYWN0RE9NU2VydmVyID0gcmVxdWlyZShcIi4vUmVhY3RET01TZXJ2ZXJcIik7XG52YXIgUmVhY3RJc29tb3JwaGljID0gcmVxdWlyZShcIi4vUmVhY3RJc29tb3JwaGljXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcblxudmFyIFJlYWN0ID0ge307XG5cbmFzc2lnbihSZWFjdCwgUmVhY3RJc29tb3JwaGljKTtcbmFzc2lnbihSZWFjdCwgUmVhY3RET01DbGllbnQpO1xuYXNzaWduKFJlYWN0LCBSZWFjdERPTVNlcnZlcik7XG5cblJlYWN0LnZlcnNpb24gPSAnMC4xNC4wLWFscGhhMyc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VNYXBcIik7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoXCIuL2ZpbmRET01Ob2RlXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgZGlkV2FybktleSA9ICdfZ2V0RE9NTm9kZURpZFdhcm4nO1xuXG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICogQGZpbmFsXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldERPTU5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyh0aGlzLmNvbnN0cnVjdG9yW2RpZFdhcm5LZXldLCAnJXMuZ2V0RE9NTm9kZSguLi4pIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJyArICdSZWFjdC5maW5kRE9NTm9kZShpbnN0YW5jZSkgaW5zdGVhZC4nLCBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5nZXROYW1lKCkgfHwgdGhpcy50YWdOYW1lIHx8ICdVbmtub3duJykgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb25zdHJ1Y3RvcltkaWRXYXJuS2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblJlZ2lzdHJ5XCIpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEV2ZW50RW1pdHRlck1peGluXCIpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoXCIuL1ZpZXdwb3J0TWV0cmljc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL2lzRXZlbnRTdXBwb3J0ZWRcIik7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdEV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnQgcGx1Z2dhYmxlXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcbi8vIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZVxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKCdteUlEJywgJ29uQ2xpY2snLCBteUZ1bmN0aW9uKTtcbiAqXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IGFzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xuXG4gIC8qKlxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcbiAgICovXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgKlxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gICAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gICAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICAgKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICpcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8IGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wQmx1cl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wRm9jdXNdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogTk9URTogU2Nyb2xsIGV2ZW50cyBkbyBub3QgYnViYmxlLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9zY3JvbGwuaHRtbFxuICAgKi9cbiAgZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luSHViLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5IdWIucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cbiAgcHV0TGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyLFxuXG4gIGdldExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcixcblxuICBkZWxldGVMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXIsXG5cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnNcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcblxudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gUmVhY3QuY3JlYXRlRmFjdG9yeShyZXF1aXJlKFwiLi9SZWFjdFRyYW5zaXRpb25Hcm91cFwiKSk7XG52YXIgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkocmVxdWlyZShcIi4vUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZFwiKSk7XG5cbnZhciBSZWFjdENTU1RyYW5zaXRpb25Hcm91cCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdENTU1RyYW5zaXRpb25Hcm91cCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdHJhbnNpdGlvbk5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICB0cmFuc2l0aW9uQXBwZWFyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uRW50ZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHRyYW5zaXRpb25MZWF2ZTogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbkFwcGVhcjogZmFsc2UsXG4gICAgICB0cmFuc2l0aW9uRW50ZXI6IHRydWUsXG4gICAgICB0cmFuc2l0aW9uTGVhdmU6IHRydWVcbiAgICB9O1xuICB9LFxuXG4gIF93cmFwQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGNoaWxkRmFjdG9yeSBzbyB0aGF0XG4gICAgLy8gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCBjYW4gcmVjZWl2ZSB1cGRhdGVzIHRvIG5hbWUsIGVudGVyLCBhbmRcbiAgICAvLyBsZWF2ZSB3aGlsZSBpdCBpcyBsZWF2aW5nLlxuICAgIHJldHVybiBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkKHtcbiAgICAgIG5hbWU6IHRoaXMucHJvcHMudHJhbnNpdGlvbk5hbWUsXG4gICAgICBhcHBlYXI6IHRoaXMucHJvcHMudHJhbnNpdGlvbkFwcGVhcixcbiAgICAgIGVudGVyOiB0aGlzLnByb3BzLnRyYW5zaXRpb25FbnRlcixcbiAgICAgIGxlYXZlOiB0aGlzLnByb3BzLnRyYW5zaXRpb25MZWF2ZVxuICAgIH0sIGNoaWxkKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RUcmFuc2l0aW9uR3JvdXAoYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IGNoaWxkRmFjdG9yeTogdGhpcy5fd3JhcENoaWxkIH0pKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwiLi9SZWFjdFwiKTtcblxudmFyIENTU0NvcmUgPSByZXF1aXJlKFwiLi9DU1NDb3JlXCIpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHJlcXVpcmUoXCIuL1JlYWN0VHJhbnNpdGlvbkV2ZW50c1wiKTtcblxudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoXCIuL29ubHlDaGlsZFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLy8gV2UgZG9uJ3QgcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTSB1bnRpbCB3ZSByZWNlaXZlIGFuIGFuaW1hdGlvbmVuZCBvclxuLy8gdHJhbnNpdGlvbmVuZCBldmVudC4gSWYgdGhlIHVzZXIgc2NyZXdzIHVwIGFuZCBmb3JnZXRzIHRvIGFkZCBhbiBhbmltYXRpb25cbi8vIHRoZWlyIG5vZGUgd2lsbCBiZSBzdHVjayBpbiB0aGUgRE9NIGZvcmV2ZXIsIHNvIHdlIGRldGVjdCBpZiBhbiBhbmltYXRpb25cbi8vIGRvZXMgbm90IHN0YXJ0IGFuZCBpZiBpdCBkb2Vzbid0LCB3ZSBqdXN0IGNhbGwgdGhlIGVuZCBsaXN0ZW5lciBpbW1lZGlhdGVseS5cbnZhciBUSUNLID0gMTc7XG52YXIgTk9fRVZFTlRfVElNRU9VVCA9IDUwMDA7XG5cbnZhciBub0V2ZW50TGlzdGVuZXIgPSBudWxsO1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBub0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICd0cmFuc2l0aW9uKCk6IHRyaWVkIHRvIHBlcmZvcm0gYW4gYW5pbWF0aW9uIHdpdGhvdXQgJyArICdhbiBhbmltYXRpb25lbmQgb3IgdHJhbnNpdGlvbmVuZCBldmVudCBhZnRlciB0aW1lb3V0ICgnICsgJyVzbXMpLiBZb3Ugc2hvdWxkIGVpdGhlciBkaXNhYmxlIHRoaXMgJyArICd0cmFuc2l0aW9uIGluIEpTIG9yIGFkZCBhIENTUyBhbmltYXRpb24vdHJhbnNpdGlvbi4nLCBOT19FVkVOVF9USU1FT1VUKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCcsXG5cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24gKGFuaW1hdGlvblR5cGUsIGZpbmlzaENhbGxiYWNrKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5uYW1lICsgJy0nICsgYW5pbWF0aW9uVHlwZTtcbiAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gY2xhc3NOYW1lICsgJy1hY3RpdmUnO1xuICAgIHZhciBub0V2ZW50VGltZW91dCA9IG51bGw7XG5cbiAgICB2YXIgZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG5vRXZlbnRUaW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgQ1NTQ29yZS5yZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuICAgICAgQ1NTQ29yZS5yZW1vdmVDbGFzcyhub2RlLCBhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgICBSZWFjdFRyYW5zaXRpb25FdmVudHMucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRMaXN0ZW5lcik7XG5cbiAgICAgIC8vIFVzdWFsbHkgdGhpcyBvcHRpb25hbCBjYWxsYmFjayBpcyB1c2VkIGZvciBpbmZvcm1pbmcgYW4gb3duZXIgb2ZcbiAgICAgIC8vIGEgbGVhdmUgYW5pbWF0aW9uIGFuZCB0ZWxsaW5nIGl0IHRvIHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICBpZiAoZmluaXNoQ2FsbGJhY2spIHtcbiAgICAgICAgZmluaXNoQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUmVhY3RUcmFuc2l0aW9uRXZlbnRzLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kTGlzdGVuZXIpO1xuXG4gICAgQ1NTQ29yZS5hZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuXG4gICAgLy8gTmVlZCB0byBkbyB0aGlzIHRvIGFjdHVhbGx5IHRyaWdnZXIgYSB0cmFuc2l0aW9uLlxuICAgIHRoaXMucXVldWVDbGFzcyhhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIG5vRXZlbnRUaW1lb3V0ID0gc2V0VGltZW91dChub0V2ZW50TGlzdGVuZXIsIE5PX0VWRU5UX1RJTUVPVVQpO1xuICAgIH1cbiAgfSxcblxuICBxdWV1ZUNsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZS5wdXNoKGNsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmZsdXNoQ2xhc3NOYW1lUXVldWUsIFRJQ0spO1xuICAgIH1cbiAgfSxcblxuICBmbHVzaENsYXNzTmFtZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgIHRoaXMuY2xhc3NOYW1lUXVldWUuZm9yRWFjaChDU1NDb3JlLmFkZENsYXNzLmJpbmQoQ1NTQ29yZSwgUmVhY3QuZmluZERPTU5vZGUodGhpcykpKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZSA9IFtdO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxBcHBlYXI6IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuYXBwZWFyKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2FwcGVhcicsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxFbnRlcjogZnVuY3Rpb24gKGRvbmUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5lbnRlcikge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdlbnRlcicsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxMZWF2ZTogZnVuY3Rpb24gKGRvbmUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5sZWF2ZSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdsZWF2ZScsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvbmx5Q2hpbGQodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRSZWNvbmNpbGVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoXCIuL1JlYWN0UmVjb25jaWxlclwiKTtcblxudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoXCIuL2ZsYXR0ZW5DaGlsZHJlblwiKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XCIpO1xuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMpO1xuICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgLy8gVGhlIHJlbmRlcmVkIGNoaWxkcmVuIG11c3QgYmUgdHVybmVkIGludG8gaW5zdGFuY2VzIGFzIHRoZXkncmVcbiAgICAgICAgLy8gbW91bnRlZC5cbiAgICAgICAgdmFyIGNoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCBudWxsKTtcbiAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBjaGlsZEluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkTm9kZXMgTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGhhdmUgYSB3YXkgdG8gdHJhY2sgbW92ZXMgaGVyZSBidXQgaWYgd2UgdXNlIGl0ZXJhdG9yc1xuICAgIC8vIGluc3RlYWQgb2YgZm9yLi5pbiB3ZSBjYW4gemlwIHRoZSBpdGVyYXRvcnMgYW5kIGNoZWNrIGlmIGFuIGl0ZW0gaGFzXG4gICAgLy8gbW92ZWQuXG4gICAgLy8gVE9ETzogSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgcmV0dXJuIHRoZSBwcmV2Q2hpbGRyZW4gb2JqZWN0IHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcXVpY2tseSBiYWlsb3V0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGROb2Rlcyk7XG4gICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDaGlsZCwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gcHJldkNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIG51bGwpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBuZXh0Q2hpbGRJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5tb3VudCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHJlbmRlcmVkQ2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAocmVuZGVyZWRDaGlsZHJlbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkUmVjb25jaWxlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RGcmFnbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RnJhZ21lbnRcIik7XG5cbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZShcIi4vdHJhdmVyc2VBbGxDaGlsZHJlblwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnRocmVlQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGJvb2tLZWVwaW5nID0gdHJhdmVyc2VDb250ZXh0O1xuICBib29rS2VlcGluZy5mdW5jLmNhbGwoYm9va0tlZXBpbmcuY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuYy5cbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIHRocmVlQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGJvb2tLZWVwaW5nID0gdHJhdmVyc2VDb250ZXh0O1xuICB2YXIgbWFwUmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0O1xuXG4gIHZhciBrZXlVbmlxdWUgPSBtYXBSZXN1bHRbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhrZXlVbmlxdWUsICdSZWFjdENoaWxkcmVuLm1hcCguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIG5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGtleVVuaXF1ZSkge1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGJvb2tLZWVwaW5nLmZ1bmMuY2FsbChib29rS2VlcGluZy5jb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gICAgbWFwUmVzdWx0W25hbWVdID0gbWFwcGVkQ2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIFRPRE86IFRoaXMgbWF5IGxpa2VseSBicmVhayBhbnkgY2FsbHMgdG8gYFJlYWN0Q2hpbGRyZW4ubWFwYCB0aGF0IHdlcmVcbiAqIHByZXZpb3VzbHkgcmVseWluZyBvbiB0aGUgZmFjdCB0aGF0IHdlIGd1YXJkZWQgYWdhaW5zdCBudWxsIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBtYXBGdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gbWFwQ29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIG1hcFJlc3VsdCA9IHt9O1xuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKG1hcFJlc3VsdCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbiAgcmV0dXJuIFJlYWN0RnJhZ21lbnQuY3JlYXRlKG1hcFJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoXCIuL1JlYWN0RXJyb3JVdGlsc1wiKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZU1hcFwiKTtcbnZhciBSZWFjdExpZmVDeWNsZSA9IHJlcXVpcmUoXCIuL1JlYWN0TGlmZUN5Y2xlXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcIik7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlUXVldWVcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIE1JWElOU19LRVkgPSBrZXlPZih7IG1peGluczogbnVsbCB9KTtcblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICovXG52YXIgU3BlY1BvbGljeSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZSBieSB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBvciBtaXhpbi5cbiAgICovXG4gIERFRklORV9PTkNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBieSBib3RoIHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIGFuZCBtaXhpbnMuXG4gICAqIFN1YnNlcXVlbnQgZGVmaW5pdGlvbnMgd2lsbCBiZSBjaGFpbmVkLiBUaGVzZSBtZXRob2RzIG11c3QgcmV0dXJuIHZvaWQuXG4gICAqL1xuICBERUZJTkVfTUFOWTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIG92ZXJyaWRpbmcgdGhlIGJhc2UgY2xhc3MuXG4gICAqL1xuICBPVkVSUklERV9CQVNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgc2ltaWxhciB0byBERUZJTkVfTUFOWSwgZXhjZXB0IHdlIGFzc3VtZSB0aGV5IHJldHVyblxuICAgKiBvYmplY3RzLiBXZSB0cnkgdG8gbWVyZ2UgdGhlIGtleXMgb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgYWxsIHRoZSBtaXhlZCBpblxuICAgKiBmdW5jdGlvbnMuIElmIHRoZXJlIGlzIGEga2V5IGNvbmZsaWN0IHdlIHRocm93LlxuICAgKi9cbiAgREVGSU5FX01BTllfTUVSR0VEOiBudWxsXG59KTtcblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbi8qKlxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAqIG9yIG5hdGl2ZSBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAqXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgKiB1cGRhdGUuXG4gICAqXG4gICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAqXG4gICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogU3BlY1BvbGljeS5PVkVSUklERV9CQVNFXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH0sXG4gIG1peGluczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLCBjb250ZXh0VHlwZXMpO1xuICB9LFxuICAvKipcbiAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgbm90IGluIF9fREVWX19cbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSAnICsgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgKyAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgKyAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlICcgKyAndG8gYSBtaXhpbi4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzc2VzLlxuICovXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICBpZiAoIXNwZWMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGNsYXNzIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQ7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBpZiAoIXByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcFtuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICsgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSAobmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVMpO1xuICAgICEhaXNSZXNlcnZlZCA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgJyArICdwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgJyArICdhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlICcgKyAnY29uc3RydWN0b3IuJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gKG5hbWUgaW4gQ29uc3RydWN0b3IpO1xuICAgICEhaXNJbmhlcml0ZWQgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICsgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgKyAnZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICEob25lW2tleV0gPT09IHVuZGVmaW5lZCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICsgJ1RyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0ICcgKyAnbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvICcgKyAnZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyAnICsgJ3dpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGJsb2NrLXNjb3BlZC12YXIsIG5vLXVuZGVmICovXG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIGZvciAodmFyIGF1dG9CaW5kS2V5IGluIGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICBpZiAoY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcC5oYXNPd25Qcm9wZXJ0eShhdXRvQmluZEtleSkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwW2F1dG9CaW5kS2V5XTtcbiAgICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBSZWFjdEVycm9yVXRpbHMuZ3VhcmQobWV0aG9kLCBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgKyAnLicgKyBhdXRvQmluZEtleSkpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdHlwZURlcHJlY2F0aW9uRGVzY3JpcHRvciA9IHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IHRoaXMuZGlzcGxheU5hbWUgfHwgdGhpcy5uYW1lIHx8ICdDb21wb25lbnQnO1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnJXMudHlwZSBpcyBkZXByZWNhdGVkLiBVc2UgJXMgZGlyZWN0bHkgdG8gYWNjZXNzIHRoZSBjbGFzcy4nLCBkaXNwbGF5TmFtZSwgZGlzcGxheU5hbWUpIDogdW5kZWZpbmVkO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgIHZhbHVlOiB0aGlzXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcyk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlICE9PSBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlNb3VudGluZ0luc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHVibGljXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZXRQcm9wczogZnVuY3Rpb24gKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRQcm9wcyh0aGlzLCBwYXJ0aWFsUHJvcHMpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZSBhbGwgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVwbGFjZVByb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVByb3BzKHRoaXMsIG5ld1Byb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGlzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9O1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExlZ2FjeSBob29rXG4gICAgQ29uc3RydWN0b3IudHlwZSA9IENvbnN0cnVjdG9yO1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsICd0eXBlJywgdHlwZURlcHJlY2F0aW9uRGVzY3JpcHRvcik7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENsYXNzO1xuXG4vLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHkgKGVzNS1zaGltL3NoYW0gdG9vKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZVF1ZXVlXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgJyArICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgZ2V0RE9NTm9kZTogWydnZXRET01Ob2RlJywgJ1VzZSBSZWFjdC5maW5kRE9NTm9kZShjb21wb25lbnQpIGluc3RlYWQuJ10sXG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VQcm9wczogWydyZXBsYWNlUHJvcHMnLCAnSW5zdGVhZCwgY2FsbCBSZWFjdC5yZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXSxcbiAgICBzZXRQcm9wczogWydzZXRQcm9wcycsICdJbnN0ZWFkLCBjYWxsIFJlYWN0LnJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnQ7XG5cbi8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eSAoZXM1LXNoaW0vc2hhbSB0b28pIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9SZWFjdERPTUlET3BlcmF0aW9uc1wiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzLFxuXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCxcblxuICAvKipcbiAgICogSWYgYSBwYXJ0aWN1bGFyIGVudmlyb25tZW50IHJlcXVpcmVzIHRoYXQgc29tZSByZXNvdXJjZXMgYmUgY2xlYW5lZCB1cCxcbiAgICogc3BlY2lmeSB0aGlzIGluIHRoZSBpbmplY3RlZCBNaXhpbi4gSW4gdGhlIERPTSwgd2Ugd291bGQgbGlrZWx5IHdhbnQgdG9cbiAgICogcHVyZ2UgYW55IGNhY2hlZCBub2RlIElEIGxvb2t1cHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChyb290Tm9kZUlEKSB7XG4gICAgUmVhY3RNb3VudC5wdXJnZUlEKHJvb3ROb2RlSUQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGVudmlyb25tZW50IGRlcGVuZGVudCBjbGVhbnVwIGhvb2suIChzZXJ2ZXIgdnMuXG4gICAqIGJyb3dzZXIgZXRjKS4gRXhhbXBsZTogQSBicm93c2VyIHN5c3RlbSBjYWNoZXMgRE9NIG5vZGVzIGJhc2VkIG9uIGNvbXBvbmVudFxuICAgKiBJRCBhbmQgbXVzdCByZW1vdmUgdGhhdCBjYWNoZSBlbnRyeSB3aGVuIHRoaXMgaW5zdGFuY2UgaXMgdW5tb3VudGVkLlxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCA9IGVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzaGFsbG93Q29tcGFyZSA9IHJlcXVpcmUoXCIuL3NoYWxsb3dDb21wYXJlXCIpO1xuXG4vKipcbiAqIElmIHlvdXIgUmVhY3QgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIGlzIFwicHVyZVwiLCBlLmcuIGl0IHdpbGwgcmVuZGVyIHRoZVxuICogc2FtZSByZXN1bHQgZ2l2ZW4gdGhlIHNhbWUgcHJvcHMgYW5kIHN0YXRlLCBwcm92aWRlIHRoaXMgTWl4aW4gZm9yIGFcbiAqIGNvbnNpZGVyYWJsZSBwZXJmb3JtYW5jZSBib29zdC5cbiAqXG4gKiBNb3N0IFJlYWN0IGNvbXBvbmVudHMgaGF2ZSBwdXJlIHJlbmRlciBmdW5jdGlvbnMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIHZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPVxuICogICAgIHJlcXVpcmUoJ1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbicpO1xuICogICBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluXSxcbiAqXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9PmZvbzwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIE5vdGU6IFRoaXMgb25seSBjaGVja3Mgc2hhbGxvdyBlcXVhbGl0eSBmb3IgcHJvcHMgYW5kIHN0YXRlLiBJZiB0aGVzZSBjb250YWluXG4gKiBjb21wbGV4IGRhdGEgc3RydWN0dXJlcyB0aGlzIG1peGluIG1heSBoYXZlIGZhbHNlLW5lZ2F0aXZlcyBmb3IgZGVlcGVyXG4gKiBkaWZmZXJlbmNlcy4gT25seSBtaXhpbiB0byBjb21wb25lbnRzIHdoaWNoIGhhdmUgc2ltcGxlIHByb3BzIGFuZCBzdGF0ZSwgb3JcbiAqIHVzZSBgZm9yY2VVcGRhdGUoKWAgd2hlbiB5b3Uga25vdyBkZWVwIGRhdGEgc3RydWN0dXJlcyBoYXZlIGNoYW5nZWQuXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPSB7XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuIHNoYWxsb3dDb21wYXJlKHRoaXMsIG5leHRQcm9wcywgbmV4dFN0YXRlKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnRcIik7XG52YXIgUmVhY3RDb250ZXh0ID0gcmVxdWlyZShcIi4vUmVhY3RDb250ZXh0XCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFZhbGlkYXRvclwiKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZU1hcFwiKTtcbnZhciBSZWFjdExpZmVDeWNsZSA9IHJlcXVpcmUoXCIuL1JlYWN0TGlmZUN5Y2xlXCIpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3ROYXRpdmVDb21wb25lbnRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcIik7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZShcIi4vUmVhY3RSZWNvbmNpbGVyXCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKFwiLi9lbXB0eU9iamVjdFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkge1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl9pc1RvcExldmVsID0gZmFsc2U7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVzIGFuZCBSZWFjdFVwZGF0ZVF1ZXVlLlxuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gbmV4dE1vdW50SUQrKztcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuXG4gICAgdmFyIHB1YmxpY1Byb3BzID0gdGhpcy5fcHJvY2Vzc1Byb3BzKHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzKTtcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcbiAgICB2YXIgaW5zdCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQpO1xuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBsYXRlciBpbiBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50LCBidXQgYWRkIGFuIGVhcmx5XG4gICAgICAvLyB3YXJuaW5nIG5vdyB0byBoZWxwIGRlYnVnZ2luZ1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoaW5zdC5yZW5kZXIgIT0gbnVsbCwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgIGluIHlvdXIgJyArICdjb21wb25lbnQgb3IgeW91IG1heSBoYXZlIGFjY2lkZW50YWxseSB0cmllZCB0byByZW5kZXIgYW4gZWxlbWVudCAnICsgJ3dob3NlIHR5cGUgaXMgYSBmdW5jdGlvbiB0aGF0IGlzblxcJ3QgYSBSZWFjdCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIHZhciBwcmV2aW91c2x5TW91bnRpbmcgPSBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlNb3VudGluZ0luc3RhbmNlO1xuICAgIFJlYWN0TGlmZUN5Y2xlLmN1cnJlbnRseU1vdW50aW5nSW5zdGFuY2UgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RMaWZlQ3ljbGUuY3VycmVudGx5TW91bnRpbmdJbnN0YW5jZSA9IHByZXZpb3VzbHlNb3VudGluZztcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50LCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlIC8vIFRoZSB3cmFwcGluZyB0eXBlXG4gICAgKTtcblxuICAgIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgIGlmIChpbnN0LmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkTW91bnQsIGluc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIHZhciBwcmV2aW91c2x5VW5tb3VudGluZyA9IFJlYWN0TGlmZUN5Y2xlLmN1cnJlbnRseVVubW91bnRpbmdJbnN0YW5jZTtcbiAgICAgIFJlYWN0TGlmZUN5Y2xlLmN1cnJlbnRseVVubW91bnRpbmdJbnN0YW5jZSA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlVbm1vdW50aW5nSW5zdGFuY2UgPSBwcmV2aW91c2x5VW5tb3VudGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIC8vIFRoZXNlIGZpZWxkcyBkbyBub3QgcmVhbGx5IG5lZWQgdG8gYmUgcmVzZXQgc2luY2UgdGhpcyBvYmplY3QgaXMgbm9cbiAgICAvLyBsb25nZXIgYWNjZXNzaWJsZS5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2NoZWR1bGUgYSBwYXJ0aWFsIHVwZGF0ZSB0byB0aGUgcHJvcHMuIE9ubHkgdXNlZCBmb3IgaW50ZXJuYWwgdGVzdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRQcm9wc0ludGVybmFsOiBmdW5jdGlvbiAocGFydGlhbFByb3BzLCBjYWxsYmFjaykge1xuICAgIC8vIFRoaXMgaXMgYSBkZW9wdGltaXplZCBwYXRoLiBXZSBvcHRpbWl6ZSBmb3IgYWx3YXlzIGhhdmluZyBhbiBlbGVtZW50LlxuICAgIC8vIFRoaXMgY3JlYXRlcyBhbiBleHRyYSBpbnRlcm5hbCBlbGVtZW50LlxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5fcGVuZGluZ0VsZW1lbnQgfHwgdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMoZWxlbWVudCwgYXNzaWduKHt9LCBlbGVtZW50LnByb3BzLCBwYXJ0aWFsUHJvcHMpKTtcbiAgICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZSh0aGlzLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgQ29tcG9uZW50ID0gUmVhY3ROYXRpdmVDb21wb25lbnQuZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudC5nZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQgJiYgaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBpbnN0LmNvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhpbnN0LmNvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBpbnN0LmNvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgcHJvcHMgYnkgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcHJvcHMgYW5kXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWQuIERvZXMgbm90IG11dGF0ZSBpdHMgYXJndW1lbnQ7IHJldHVybnNcbiAgICogYSBuZXcgcHJvcHMgb2JqZWN0IHdpdGggZGVmYXVsdHMgbWVyZ2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudC5nZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgaWYgKENvbXBvbmVudC5wcm9wVHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LnByb3BUeXBlcywgbmV3UHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdQcm9wcztcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uIChwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICAgIC8vIFRPRE86IFN0b3AgdmFsaWRhdGluZyBwcm9wIHR5cGVzIGhlcmUgYW5kIG9ubHkgdXNlIHRoZSBlbGVtZW50XG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHRoaXMuZ2V0TmFtZSgpO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICAhKHR5cGVvZiBwcm9wVHlwZXNbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSAnICsgJ2Zyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gZXh0ZW5kIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgZXJyb3JzIGluXG4gICAgICAgICAgLy8gUmVhY3QucmVuZGVyIGNhbGxzLCBzbyBJJ20gYWJzdHJhY3RpbmcgaXQgYXdheSBpbnRvXG4gICAgICAgICAgLy8gYSBmdW5jdGlvbiB0byBtaW5pbWl6ZSByZWZhY3RvcmluZyBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKHRoaXMpO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uID09PSBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApIHtcbiAgICAgICAgICAgIC8vIFByZWZhY2UgZ2l2ZXMgdXMgc29tZXRoaW5nIHRvIGJsYWNrbGlzdCBpbiB3YXJuaW5nIG1vZHVsZVxuICAgICAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBDb250ZXh0IFR5cGVzOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50IHx8IHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlICE9PSBudWxsIHx8IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNoZWNrQW5kV2FybkZvck11dGF0ZWRQcm9wcyh0aGlzLl9jdXJyZW50RWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBuZXh0Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB2YXIgbmV4dFByb3BzID0gaW5zdC5wcm9wcztcblxuICAgIC8vIERpc3Rpbmd1aXNoIGJldHdlZW4gYSBwcm9wcyB1cGRhdGUgdmVyc3VzIGEgc2ltcGxlIHN0YXRlIHVwZGF0ZVxuICAgIGlmIChwcmV2UGFyZW50RWxlbWVudCAhPT0gbmV4dFBhcmVudEVsZW1lbnQpIHtcbiAgICAgIG5leHRDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQobmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgICBuZXh0UHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHMobmV4dFBhcmVudEVsZW1lbnQucHJvcHMpO1xuXG4gICAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgICAvLyBfcGVuZGluZ1N0YXRlUXVldWUgd2hpY2ggd2lsbCBlbnN1cmUgdGhhdCBhbnkgc3RhdGUgdXBkYXRlcyBnZXRzXG4gICAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG5cbiAgICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSB8fCAhaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUgfHwgaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyh0eXBlb2Ygc2hvdWxkVXBkYXRlICE9PSAndW5kZWZpbmVkJywgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgLy8gV2lsbCBzZXQgYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgLlxuICAgICAgdGhpcy5fcGVyZm9ybUNvbXBvbmVudFVwZGF0ZShuZXh0UGFyZW50RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IGEgY29tcG9uZW50IHNob3VsZCBub3QgdXBkYXRlLCB3ZSBzdGlsbCB3YW50XG4gICAgICAvLyB0byBzZXQgcHJvcHMgYW5kIHN0YXRlIGJ1dCB3ZSBzaG9ydGN1dCB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlLlxuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0UGFyZW50RWxlbWVudDtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBuZXh0VW5tYXNrZWRDb250ZXh0O1xuICAgICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICB9XG4gIH0sXG5cbiAgX3Byb2Nlc3NQZW5kaW5nU3RhdGU6IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcGVuZGluZ1N0YXRlUXVldWU7XG4gICAgdmFyIHJlcGxhY2UgPSB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICByZXR1cm4gaW5zdC5zdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZSAmJiBxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBxdWV1ZVswXTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjb21wb25lbnQncyBgcmVuZGVyYCBtZXRob2QgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlc2UgdHdvIElEcyBhcmUgYWN0dWFsbHkgdGhlIHNhbWUhIEJ1dCBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoYXQuXG4gICAgICB2YXIgdGhpc0lEID0gdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgIHZhciBwcmV2Q29tcG9uZW50SUQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX3Jvb3ROb2RlSUQ7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgdGhpc0lELCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogZnVuY3Rpb24gKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZWRDb21wb25lbnQgPT09ICd1bmRlZmluZWQnICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZENvbXBvbmVudDtcbiAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gUmVhY3RDb250ZXh0LmN1cnJlbnQ7XG4gICAgUmVhY3RDb250ZXh0LmN1cnJlbnQgPSB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9jb250ZXh0KTtcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDb250ZXh0LmN1cnJlbnQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgIShcbiAgICAvLyBUT0RPOiBBbiBgaXNWYWxpZE5vZGVgIGZ1bmN0aW9uIHdvdWxkIHByb2JhYmx5IGJlIG1vcmUgYXBwcm9wcmlhdGVcbiAgICAocmVuZGVyZWRDb21wb25lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRDb21wb25lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZENvbXBvbmVudCkpKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdENvbXBvbmVudCBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IFJlYWN0LnJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50JyxcbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnXG59KTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIE1peGluOiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29udGV4dFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZShcIi4vZW1wdHlPYmplY3RcIik7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBUaGUgY29udGV4dCBpcyBhdXRvbWF0aWNhbGx5IHBhc3NlZCBkb3duIHRoZSBjb21wb25lbnQgb3duZXJzaGlwIGhpZXJhcmNoeVxuICogYW5kIGlzIGFjY2Vzc2libGUgdmlhIGB0aGlzLmNvbnRleHRgIG9uIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50cy5cbiAqL1xudmFyIFJlYWN0Q29udGV4dCA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xuICBjdXJyZW50OiBlbXB0eU9iamVjdFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29udGV4dDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDdXJyZW50T3duZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDdXJyZW50T3duZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3JcIik7XG5cbnZhciBtYXBPYmplY3QgPSByZXF1aXJlKFwiLi9tYXBPYmplY3RcIik7XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUYWcgbmFtZSAoZS5nLiBgZGl2YCkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVET01GYWN0b3J5KHRhZykge1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHJldHVybiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeSh0YWcpO1xuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSh0YWcpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXG4gKiBUaGlzIGlzIGFsc28gYWNjZXNzaWJsZSB2aWEgYFJlYWN0LkRPTWAuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVhY3RET00gPSBtYXBPYmplY3Qoe1xuICBhOiAnYScsXG4gIGFiYnI6ICdhYmJyJyxcbiAgYWRkcmVzczogJ2FkZHJlc3MnLFxuICBhcmVhOiAnYXJlYScsXG4gIGFydGljbGU6ICdhcnRpY2xlJyxcbiAgYXNpZGU6ICdhc2lkZScsXG4gIGF1ZGlvOiAnYXVkaW8nLFxuICBiOiAnYicsXG4gIGJhc2U6ICdiYXNlJyxcbiAgYmRpOiAnYmRpJyxcbiAgYmRvOiAnYmRvJyxcbiAgYmlnOiAnYmlnJyxcbiAgYmxvY2txdW90ZTogJ2Jsb2NrcXVvdGUnLFxuICBib2R5OiAnYm9keScsXG4gIGJyOiAnYnInLFxuICBidXR0b246ICdidXR0b24nLFxuICBjYW52YXM6ICdjYW52YXMnLFxuICBjYXB0aW9uOiAnY2FwdGlvbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY29kZTogJ2NvZGUnLFxuICBjb2w6ICdjb2wnLFxuICBjb2xncm91cDogJ2NvbGdyb3VwJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRhbGlzdDogJ2RhdGFsaXN0JyxcbiAgZGQ6ICdkZCcsXG4gIGRlbDogJ2RlbCcsXG4gIGRldGFpbHM6ICdkZXRhaWxzJyxcbiAgZGZuOiAnZGZuJyxcbiAgZGlhbG9nOiAnZGlhbG9nJyxcbiAgZGl2OiAnZGl2JyxcbiAgZGw6ICdkbCcsXG4gIGR0OiAnZHQnLFxuICBlbTogJ2VtJyxcbiAgZW1iZWQ6ICdlbWJlZCcsXG4gIGZpZWxkc2V0OiAnZmllbGRzZXQnLFxuICBmaWdjYXB0aW9uOiAnZmlnY2FwdGlvbicsXG4gIGZpZ3VyZTogJ2ZpZ3VyZScsXG4gIGZvb3RlcjogJ2Zvb3RlcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgaDE6ICdoMScsXG4gIGgyOiAnaDInLFxuICBoMzogJ2gzJyxcbiAgaDQ6ICdoNCcsXG4gIGg1OiAnaDUnLFxuICBoNjogJ2g2JyxcbiAgaGVhZDogJ2hlYWQnLFxuICBoZWFkZXI6ICdoZWFkZXInLFxuICBoZ3JvdXA6ICdoZ3JvdXAnLFxuICBocjogJ2hyJyxcbiAgaHRtbDogJ2h0bWwnLFxuICBpOiAnaScsXG4gIGlmcmFtZTogJ2lmcmFtZScsXG4gIGltZzogJ2ltZycsXG4gIGlucHV0OiAnaW5wdXQnLFxuICBpbnM6ICdpbnMnLFxuICBrYmQ6ICdrYmQnLFxuICBrZXlnZW46ICdrZXlnZW4nLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGVnZW5kOiAnbGVnZW5kJyxcbiAgbGk6ICdsaScsXG4gIGxpbms6ICdsaW5rJyxcbiAgbWFpbjogJ21haW4nLFxuICBtYXA6ICdtYXAnLFxuICBtYXJrOiAnbWFyaycsXG4gIG1lbnU6ICdtZW51JyxcbiAgbWVudWl0ZW06ICdtZW51aXRlbScsXG4gIG1ldGE6ICdtZXRhJyxcbiAgbWV0ZXI6ICdtZXRlcicsXG4gIG5hdjogJ25hdicsXG4gIG5vc2NyaXB0OiAnbm9zY3JpcHQnLFxuICBvYmplY3Q6ICdvYmplY3QnLFxuICBvbDogJ29sJyxcbiAgb3B0Z3JvdXA6ICdvcHRncm91cCcsXG4gIG9wdGlvbjogJ29wdGlvbicsXG4gIG91dHB1dDogJ291dHB1dCcsXG4gIHA6ICdwJyxcbiAgcGFyYW06ICdwYXJhbScsXG4gIHBpY3R1cmU6ICdwaWN0dXJlJyxcbiAgcHJlOiAncHJlJyxcbiAgcHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHE6ICdxJyxcbiAgcnA6ICdycCcsXG4gIHJ0OiAncnQnLFxuICBydWJ5OiAncnVieScsXG4gIHM6ICdzJyxcbiAgc2FtcDogJ3NhbXAnLFxuICBzY3JpcHQ6ICdzY3JpcHQnLFxuICBzZWN0aW9uOiAnc2VjdGlvbicsXG4gIHNlbGVjdDogJ3NlbGVjdCcsXG4gIHNtYWxsOiAnc21hbGwnLFxuICBzb3VyY2U6ICdzb3VyY2UnLFxuICBzcGFuOiAnc3BhbicsXG4gIHN0cm9uZzogJ3N0cm9uZycsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdWI6ICdzdWInLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHN1cDogJ3N1cCcsXG4gIHRhYmxlOiAndGFibGUnLFxuICB0Ym9keTogJ3Rib2R5JyxcbiAgdGQ6ICd0ZCcsXG4gIHRleHRhcmVhOiAndGV4dGFyZWEnLFxuICB0Zm9vdDogJ3Rmb290JyxcbiAgdGg6ICd0aCcsXG4gIHRoZWFkOiAndGhlYWQnLFxuICB0aW1lOiAndGltZScsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0cjogJ3RyJyxcbiAgdHJhY2s6ICd0cmFjaycsXG4gIHU6ICd1JyxcbiAgdWw6ICd1bCcsXG4gICd2YXInOiAndmFyJyxcbiAgdmlkZW86ICd2aWRlbycsXG4gIHdicjogJ3dicicsXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogJ2NpcmNsZScsXG4gIGNsaXBQYXRoOiAnY2xpcFBhdGgnLFxuICBkZWZzOiAnZGVmcycsXG4gIGVsbGlwc2U6ICdlbGxpcHNlJyxcbiAgZzogJ2cnLFxuICBsaW5lOiAnbGluZScsXG4gIGxpbmVhckdyYWRpZW50OiAnbGluZWFyR3JhZGllbnQnLFxuICBtYXNrOiAnbWFzaycsXG4gIHBhdGg6ICdwYXRoJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwb2x5Z29uOiAncG9seWdvbicsXG4gIHBvbHlsaW5lOiAncG9seWxpbmUnLFxuICByYWRpYWxHcmFkaWVudDogJ3JhZGlhbEdyYWRpZW50JyxcbiAgcmVjdDogJ3JlY3QnLFxuICBzdG9wOiAnc3RvcCcsXG4gIHN2ZzogJ3N2ZycsXG4gIHRleHQ6ICd0ZXh0JyxcbiAgdHNwYW46ICd0c3BhbidcblxufSwgY3JlYXRlRE9NRmFjdG9yeSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQnV0dG9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSByZXF1aXJlKFwiLi9BdXRvRm9jdXNNaXhpblwiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKFwiLi9SZWFjdENsYXNzXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcblxudmFyIGJ1dHRvbiA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KCdidXR0b24nKTtcblxudmFyIG1vdXNlTGlzdGVuZXJOYW1lcyA9IGtleU1pcnJvcih7XG4gIG9uQ2xpY2s6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2s6IHRydWUsXG4gIG9uTW91c2VEb3duOiB0cnVlLFxuICBvbk1vdXNlTW92ZTogdHJ1ZSxcbiAgb25Nb3VzZVVwOiB0cnVlLFxuICBvbkNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Eb3VibGVDbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPGJ1dHRvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01CdXR0b24gPSBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTUJ1dHRvbicsXG4gIHRhZ05hbWU6ICdCVVRUT04nLFxuXG4gIG1peGluczogW0F1dG9Gb2N1c01peGluLCBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0ge307XG5cbiAgICAvLyBDb3B5IHRoZSBwcm9wczsgZXhjZXB0IHRoZSBtb3VzZSBsaXN0ZW5lcnMgaWYgd2UncmUgZGlzYWJsZWRcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wcm9wcykge1xuICAgICAgaWYgKHRoaXMucHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoIXRoaXMucHJvcHMuZGlzYWJsZWQgfHwgIW1vdXNlTGlzdGVuZXJOYW1lc1trZXldKSkge1xuICAgICAgICBwcm9wc1trZXldID0gdGhpcy5wcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidXR0b24ocHJvcHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQnV0dG9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNsaWVudFxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdERPTVRleHRDb21wb25lbnRcIik7XG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0SW5qZWN0aW9uXCIpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZUhhbmRsZXNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoXCIuL1JlYWN0UmVjb25jaWxlclwiKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZShcIi4vZmluZERPTU5vZGVcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIHJlbmRlciA9IFJlYWN0UGVyZi5tZWFzdXJlKCdSZWFjdCcsICdyZW5kZXInLCBSZWFjdE1vdW50LnJlbmRlcik7XG5cbnZhciBSZWFjdCA9IHtcbiAgY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50OiBSZWFjdE1vdW50LmNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudCxcbiAgY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50QnlJRDogUmVhY3RNb3VudC5jb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnRCeUlELFxuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG4gIHJlbmRlcjogcmVuZGVyLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGVcbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIEluc3RhbmNlSGFuZGxlczogUmVhY3RJbnN0YW5jZUhhbmRsZXMsXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyLFxuICAgIFRleHRDb21wb25lbnQ6IFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICB9KTtcbn1cblxuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcblxuICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSwgbG9vayBmb3IgdGhlIGRldnRvb2xzIG1hcmtlciBhbmQgcHJvdmlkZSBhIGRvd25sb2FkXG4gICAgLy8gbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEpIHtcbiAgICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21iYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgU3RyaW5nLnByb3RvdHlwZS50cmltLFxuXG4gICAgLy8gc2hhbXNcbiAgICBPYmplY3QuY3JlYXRlLCBPYmplY3QuZnJlZXplXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ09uZSBvciBtb3JlIEVTNSBzaGltL3NoYW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0NTU1Byb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcIik7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdE11bHRpQ2hpbGQgPSByZXF1aXJlKFwiLi9SZWFjdE11bHRpQ2hpbGRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKFwiLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKFwiLi9pc0V2ZW50U3VwcG9ydGVkXCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4vc2hhbGxvd0VxdWFsXCIpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlRE9NTmVzdGluZ1wiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIGRlbGV0ZUxpc3RlbmVyID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBTVFlMRSA9IGtleU9mKHsgc3R5bGU6IG51bGwgfSk7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG5cbnZhciBzdHlsZU11dGF0aW9uV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUoc3R5bGUxLCBzdHlsZTIsIGNvbXBvbmVudCkge1xuICBpZiAoc3R5bGUxID09IG51bGwgfHwgc3R5bGUyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNoYWxsb3dFcXVhbChzdHlsZTEsIHN0eWxlMikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5fdGFnO1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVyKSB7XG4gICAgb3duZXJOYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvd25lck5hbWUgKyAnfCcgKyBjb21wb25lbnROYW1lO1xuXG4gIGlmIChzdHlsZU11dGF0aW9uV2FybmluZy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0eWxlTXV0YXRpb25XYXJuaW5nW2hhc2hdID0gdHJ1ZTtcblxuICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ2Alc2Agd2FzIHBhc3NlZCBhIHN0eWxlIG9iamVjdCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gbXV0YXRlZC4gJyArICdNdXRhdGluZyBgc3R5bGVgIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIGNsb25pbmcgaXQgYmVmb3JlaGFuZC4gQ2hlY2sgJyArICd0aGUgYHJlbmRlcmAgJXMuIFByZXZpb3VzIHN0eWxlOiAlcy4gTXV0YXRlZCBzdHlsZTogJXMuJywgY29tcG9uZW50TmFtZSwgb3duZXIgPyAnb2YgYCcgKyBvd25lck5hbWUgKyAnYCcgOiAndXNpbmcgPCcgKyBjb21wb25lbnROYW1lICsgJz4nLCBKU09OLnN0cmluZ2lmeShzdHlsZTEpLCBKU09OLnN0cmluZ2lmeShzdHlsZTIpKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBPcHRpb25hbGx5IGluamVjdGFibGUgb3BlcmF0aW9ucyBmb3IgbXV0YXRpbmcgdGhlIERPTVxuICovXG52YXIgQmFja2VuZElET3BlcmF0aW9ucyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3Qgbm90IGhhdmUgYGNoaWxkcmVuYCBvciAnICsgJ3VzZSBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicsIGNvbXBvbmVudC5fdGFnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgJ19faHRtbCcgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuICcgKyAnUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcocHJvcHMuaW5uZXJIVE1MID09IG51bGwsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB1bmRlZmluZWQ7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdW5kZWZpbmVkO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgKyAnbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiAnICsgJ3VzaW5nIEpTWC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIsIHRyYW5zYWN0aW9uKSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxuICAgIC8vIGJ1YmJsZS5cbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhyZWdpc3RyYXRpb25OYW1lICE9PSAnb25TY3JvbGwnIHx8IGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpLCAnVGhpcyBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50JykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgdmFyIGRvYyA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgPyBjb250YWluZXIub3duZXJEb2N1bWVudCA6IGNvbnRhaW5lcjtcbiAgICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xuICB9XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpZDogaWQsXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHB1dExpc3RlbmVyKCkge1xuICB2YXIgbGlzdGVuZXJUb1B1dCA9IHRoaXM7XG4gIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0LmlkLCBsaXN0ZW5lclRvUHV0LnJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyVG9QdXQubGlzdGVuZXIpO1xufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwgY2FzZWQgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gICdhcmVhJzogdHJ1ZSxcbiAgJ2Jhc2UnOiB0cnVlLFxuICAnYnInOiB0cnVlLFxuICAnY29sJzogdHJ1ZSxcbiAgJ2VtYmVkJzogdHJ1ZSxcbiAgJ2hyJzogdHJ1ZSxcbiAgJ2ltZyc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlnZW4nOiB0cnVlLFxuICAnbGluayc6IHRydWUsXG4gICdtZXRhJzogdHJ1ZSxcbiAgJ3BhcmFtJzogdHJ1ZSxcbiAgJ3NvdXJjZSc6IHRydWUsXG4gICd0cmFjayc6IHRydWUsXG4gICd3YnInOiB0cnVlXG4gIC8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG59O1xuXG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gICdsaXN0aW5nJzogdHJ1ZSxcbiAgJ3ByZSc6IHRydWUsXG4gICd0ZXh0YXJlYSc6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IGFzc2lnbih7XG4gICdtZW51aXRlbSc6IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSAoe30pLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0LCBpbnN0KSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgLy8gUGFzcyBkb3duIG91ciB0YWcgbmFtZSB0byBjaGlsZCBjb21wb25lbnRzIGZvciB2YWxpZGF0aW9uIHB1cnBvc2VzXG4gICAgY29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gICAgdmFyIGluZm8gPSBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XTtcbiAgICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKGluZm8sIGluc3QuX3RhZywgaW5zdCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQodGFnKSB7XG4gIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gIHRoaXMuX3RhZyA9IHRhZztcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xufVxuXG5SZWFjdERPTUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdSZWFjdERPTUNvbXBvbmVudCc7XG5cblJlYWN0RE9NQ29tcG9uZW50Lk1peGluID0ge1xuXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFRoZSByb290IERPTSBJRCBmb3IgdGhpcyBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29tcHV0ZWQgbWFya3VwLlxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHMpO1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBpZiAoY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pIHtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKHRoaXMuX3RhZywgdGhpcywgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbik7XG4gICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICBpZiAoIXRhZ0NvbnRlbnQgJiYgb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddKSB7XG4gICAgICByZXR1cm4gdGFnT3BlbiArICcvPic7XG4gICAgfVxuICAgIHJldHVybiB0YWdPcGVuICsgJz4nICsgdGFnQ29udGVudCArICc8LycgKyB0aGlzLl90YWcgKyAnPic7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxuICAgKi9cbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl90YWc7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cEZvcklEID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHJldHVybiByZXQgKyAnICcgKyBtYXJrdXBGb3JJRDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnRlbnQgbWFya3VwLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRlbnRNYXJrdXA6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciByZXQgPSAnJztcbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIHByb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCwgdGhpcykpO1xuICAgICAgICByZXQgPSBtb3VudEltYWdlcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzW3RoaXMuX3RhZ10gJiYgcmV0LmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICByZXR1cm4gJ1xcbicgKyByZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBuYXRpdmUgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcbiAgICogYXR0YWNoZWQgdG8gdGhlIERPTS4gUmVjb25jaWxlcyB0aGUgcm9vdCBET00gbm9kZSwgdGhlbiByZWN1cnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldkVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzKTtcbiAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKHByZXZFbGVtZW50LnByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5fdXBkYXRlRE9NQ2hpbGRyZW4ocHJldkVsZW1lbnQucHJvcHMsIHRyYW5zYWN0aW9uLCBwcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQsIHRoaXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgcHJvcGVydGllcyBieSBkZXRlY3RpbmcgZGlmZmVyZW5jZXMgaW4gcHJvcGVydHkgdmFsdWVzIGFuZFxuICAgKiB1cGRhdGluZyB0aGUgRE9NIGFzIG5lY2Vzc2FyeS4gVGhpcyBmdW5jdGlvbiBpcyBwcm9iYWJseSB0aGUgc2luZ2xlIG1vc3RcbiAgICogY3JpdGljYWwgcGF0aCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgd2hldGhlciBjaGVja2luZyBmb3IgY2hhbmdlZCB2YWx1ZXMgaW4gbWVtb3J5IGFjdHVhbGx5XG4gICAqICAgICAgIGltcHJvdmVzIHBlcmZvcm1hbmNlIChlc3BlY2lhbGx5IHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cykuXG4gICAqIFRPRE86IEJlbmNobWFyayB0aGUgZWZmZWN0cyBvZiBwdXR0aW5nIHRoaXMgYXQgdGhlIHRvcCBzaW5jZSA5OSUgb2YgcHJvcHNcbiAgICogICAgICAgZG8gbm90IGNoYW5nZSBmb3IgYSBnaXZlbiByZWNvbmNpbGlhdGlvbi5cbiAgICogVE9ETzogQmVuY2htYXJrIGFyZWFzIHRoYXQgY2FuIGJlIGltcHJvdmVkIHdpdGggY2FjaGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHk7XG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobGFzdFByb3BzW3Byb3BLZXldKSB7XG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXG4gICAgICAgICAgLy8gbGlzdGVuZXIgKGUuZy4sIG9uQ2xpY2s9e251bGx9KVxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIEJhY2tlbmRJRE9wZXJhdGlvbnMuZGVsZXRlUHJvcGVydHlCeUlEKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgICB2YXIgbGFzdFByb3AgPSBwcm9wS2V5ID09PSBTVFlMRSA/IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5IDogbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUodGhpcy5fcHJldmlvdXNTdHlsZUNvcHksIHRoaXMuX3ByZXZpb3VzU3R5bGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG5leHRQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0UHJvcCA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gYXNzaWduKHt9LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgbmV4dFByb3AsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIEJhY2tlbmRJRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgQmFja2VuZElET3BlcmF0aW9ucy51cGRhdGVTdHlsZXNCeUlEKHRoaXMuX3Jvb3ROb2RlSUQsIHN0eWxlVXBkYXRlcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICBCYWNrZW5kSURPcGVyYXRpb25zLnVwZGF0ZUlubmVySFRNTEJ5SUQodGhpcy5fcm9vdE5vZGVJRCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RET01Db21wb25lbnQsICdSZWFjdERPTUNvbXBvbmVudCcsIHtcbiAgbW91bnRDb21wb25lbnQ6ICdtb3VudENvbXBvbmVudCcsXG4gIHVwZGF0ZUNvbXBvbmVudDogJ3VwZGF0ZUNvbXBvbmVudCdcbn0pO1xuXG5hc3NpZ24oUmVhY3RET01Db21wb25lbnQucHJvdG90eXBlLCBSZWFjdERPTUNvbXBvbmVudC5NaXhpbiwgUmVhY3RNdWx0aUNoaWxkLk1peGluKTtcblxuUmVhY3RET01Db21wb25lbnQuaW5qZWN0aW9uID0ge1xuICBpbmplY3RJRE9wZXJhdGlvbnM6IGZ1bmN0aW9uIChJRE9wZXJhdGlvbnMpIHtcbiAgICBSZWFjdERPTUNvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zID0gQmFja2VuZElET3BlcmF0aW9ucyA9IElET3BlcmF0aW9ucztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Gb3JtXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBMb2NhbEV2ZW50VHJhcE1peGluID0gcmVxdWlyZShcIi4vTG9jYWxFdmVudFRyYXBNaXhpblwiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKFwiLi9SZWFjdENsYXNzXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcblxudmFyIGZvcm0gPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSgnZm9ybScpO1xuXG4vKipcbiAqIFNpbmNlIG9uU3VibWl0IGRvZXNuJ3QgYnViYmxlIE9SIGNhcHR1cmUgb24gdGhlIHRvcCBsZXZlbCBpbiBJRTgsIHdlIG5lZWRcbiAqIHRvIGNhcHR1cmUgaXQgb24gdGhlIDxmb3JtPiBlbGVtZW50IGl0c2VsZi4gVGhlcmUgYXJlIGxvdHMgb2YgaGFja3Mgd2UgY291bGRcbiAqIGRvIHRvIGFjY29tcGxpc2ggdGhpcywgYnV0IHRoZSBtb3N0IHJlbGlhYmxlIGlzIHRvIG1ha2UgPGZvcm0+IGFcbiAqIGNvbXBvc2l0ZSBjb21wb25lbnQgYW5kIHVzZSBgY29tcG9uZW50RGlkTW91bnRgIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gKi9cbnZhciBSZWFjdERPTUZvcm0gPSBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTUZvcm0nLFxuICB0YWdOYW1lOiAnRk9STScsXG5cbiAgbWl4aW5zOiBbUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4sIExvY2FsRXZlbnRUcmFwTWl4aW5dLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IEluc3RlYWQgb2YgdXNpbmcgYFJlYWN0RE9NYCBkaXJlY3RseSwgd2Ugc2hvdWxkIHVzZSBKU1guIEhvd2V2ZXIsXG4gICAgLy8gYGpzaGludGAgZmFpbHMgdG8gcGFyc2UgSlNYIHNvIGluIG9yZGVyIGZvciBsaW50aW5nIHRvIHdvcmsgaW4gdGhlIG9wZW5cbiAgICAvLyBzb3VyY2UgcmVwbywgd2UgbmVlZCB0byBqdXN0IHVzZSBgUmVhY3RET00uZm9ybWAuXG4gICAgcmV0dXJuIGZvcm0odGhpcy5wcm9wcyk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BSZXNldCwgJ3Jlc2V0Jyk7XG4gICAgdGhpcy50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wU3VibWl0LCAnc3VibWl0Jyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRm9ybTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JRE9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vQ1NTUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTUNoaWxkcmVuT3BlcmF0aW9uc1wiKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoXCIuL3NldElubmVySFRNTFwiKTtcblxuLyoqXG4gKiBFcnJvcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgbm90IGJlIHVwZGF0ZWQgd2l0aCBgdXBkYXRlUHJvcGVydHlCeUlkKClgLlxuICpcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMgPSB7XG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlSW5uZXJIVE1MQnlJRCgpYC4nLFxuICBzdHlsZTogJ2BzdHlsZWAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZVN0eWxlc0J5SUQoKWAuJ1xufTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIHVzZWQgdG8gcHJvY2VzcyB1cGRhdGVzIHRvIERPTSBub2Rlcy4gVGhpcyBpcyBtYWRlIGluamVjdGFibGUgdmlhXG4gKiBgUmVhY3RET01Db21wb25lbnQuQmFja2VuZElET3BlcmF0aW9uc2AuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlIHdpdGggbmV3IHByb3BlcnR5IHZhbHVlcy4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHRvXG4gICAqIHVwZGF0ZSBET00gcHJvcGVydGllcyBpbiBgRE9NUHJvcGVydHlgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHZhbGlkIHByb3BlcnR5IG5hbWUsIHNlZSBgRE9NUHJvcGVydHlgLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlUHJvcGVydHlCeUlEOiBmdW5jdGlvbiAoaWQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICEhSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMuaGFzT3duUHJvcGVydHkobmFtZSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlUHJvcGVydHlCeUlEKC4uLik6ICVzJywgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlNbbmFtZV0pIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRhbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlIHRvIHJlbW92ZSBhIHByb3BlcnR5LiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gcmVtb3ZlXG4gICAqIERPTSBwcm9wZXJ0aWVzIGluIGBET01Qcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgcHJvcGVydHkgbmFtZSB0byByZW1vdmUsIHNlZSBgRE9NUHJvcGVydHlgLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRlbGV0ZVByb3BlcnR5QnlJRDogZnVuY3Rpb24gKGlkLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAhIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVByb3BlcnR5QnlJRCguLi4pOiAlcycsIElOVkFMSURfUFJPUEVSVFlfRVJST1JTW25hbWVdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUgd2l0aCBuZXcgc3R5bGUgdmFsdWVzLiBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhcyAnJyxcbiAgICogdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlcyBNYXBwaW5nIGZyb20gc3R5bGVzIHRvIHZhbHVlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVTdHlsZXNCeUlEOiBmdW5jdGlvbiAoaWQsIHN0eWxlcykge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlJ3MgaW5uZXJIVE1MLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBBbiBIVE1MIHN0cmluZy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVJbm5lckhUTUxCeUlEOiBmdW5jdGlvbiAoaWQsIGh0bWwpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgc2V0SW5uZXJIVE1MKG5vZGUsIGh0bWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUncyB0ZXh0IGNvbnRlbnQgc2V0IGJ5IGBwcm9wcy5jb250ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgVGV4dCBjb250ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZVRleHRDb250ZW50QnlJRDogZnVuY3Rpb24gKGlkLCBjb250ZW50KSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy51cGRhdGVUZXh0Q29udGVudChub2RlLCBjb250ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBET00gbm9kZSB0aGF0IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQgd2l0aCBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBjaGlsZCB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBEYW5nZXJvdXMgbWFya3VwIHRvIGluamVjdCBpbiBwbGFjZSBvZiBjaGlsZC5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0Rhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cH1cbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogZnVuY3Rpb24gKGlkLCBtYXJrdXApIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKG5vZGUsIG1hcmt1cCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXAgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IGZ1bmN0aW9uICh1cGRhdGVzLCBtYXJrdXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVwZGF0ZXNbaV0ucGFyZW50Tm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh1cGRhdGVzW2ldLnBhcmVudElEKTtcbiAgICB9XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKHVwZGF0ZXMsIG1hcmt1cCk7XG4gIH1cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdERPTUlET3BlcmF0aW9ucywgJ1JlYWN0RE9NSURPcGVyYXRpb25zJywge1xuICB1cGRhdGVQcm9wZXJ0eUJ5SUQ6ICd1cGRhdGVQcm9wZXJ0eUJ5SUQnLFxuICBkZWxldGVQcm9wZXJ0eUJ5SUQ6ICdkZWxldGVQcm9wZXJ0eUJ5SUQnLFxuICB1cGRhdGVTdHlsZXNCeUlEOiAndXBkYXRlU3R5bGVzQnlJRCcsXG4gIHVwZGF0ZUlubmVySFRNTEJ5SUQ6ICd1cGRhdGVJbm5lckhUTUxCeUlEJyxcbiAgdXBkYXRlVGV4dENvbnRlbnRCeUlEOiAndXBkYXRlVGV4dENvbnRlbnRCeUlEJyxcbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEJyxcbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiAnZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSWZyYW1lXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBMb2NhbEV2ZW50VHJhcE1peGluID0gcmVxdWlyZShcIi4vTG9jYWxFdmVudFRyYXBNaXhpblwiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKFwiLi9SZWFjdENsYXNzXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcblxudmFyIGlmcmFtZSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KCdpZnJhbWUnKTtcblxuLyoqXG4gKiBTaW5jZSBvbkxvYWQgZG9lc24ndCBidWJibGUgT1IgY2FwdHVyZSBvbiB0aGUgdG9wIGxldmVsIGluIElFOCwgd2UgbmVlZCB0b1xuICogY2FwdHVyZSBpdCBvbiB0aGUgPGlmcmFtZT4gZWxlbWVudCBpdHNlbGYuIFRoZXJlIGFyZSBsb3RzIG9mIGhhY2tzIHdlIGNvdWxkXG4gKiBkbyB0byBhY2NvbXBsaXNoIHRoaXMsIGJ1dCB0aGUgbW9zdCByZWxpYWJsZSBpcyB0byBtYWtlIDxpZnJhbWU+IGEgY29tcG9zaXRlXG4gKiBjb21wb25lbnQgYW5kIHVzZSBgY29tcG9uZW50RGlkTW91bnRgIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gKi9cbnZhciBSZWFjdERPTUlmcmFtZSA9IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NSWZyYW1lJyxcbiAgdGFnTmFtZTogJ0lGUkFNRScsXG5cbiAgbWl4aW5zOiBbUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4sIExvY2FsRXZlbnRUcmFwTWl4aW5dLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZnJhbWUodGhpcy5wcm9wcyk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlmcmFtZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JbWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIExvY2FsRXZlbnRUcmFwTWl4aW4gPSByZXF1aXJlKFwiLi9Mb2NhbEV2ZW50VHJhcE1peGluXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoXCIuL1JlYWN0Q2xhc3NcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xuXG52YXIgaW1nID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoJ2ltZycpO1xuXG4vKipcbiAqIFNpbmNlIG9uTG9hZCBkb2Vzbid0IGJ1YmJsZSBPUiBjYXB0dXJlIG9uIHRoZSB0b3AgbGV2ZWwgaW4gSUU4LCB3ZSBuZWVkIHRvXG4gKiBjYXB0dXJlIGl0IG9uIHRoZSA8aW1nPiBlbGVtZW50IGl0c2VsZi4gVGhlcmUgYXJlIGxvdHMgb2YgaGFja3Mgd2UgY291bGQgZG9cbiAqIHRvIGFjY29tcGxpc2ggdGhpcywgYnV0IHRoZSBtb3N0IHJlbGlhYmxlIGlzIHRvIG1ha2UgPGltZz4gYSBjb21wb3NpdGVcbiAqIGNvbXBvbmVudCBhbmQgdXNlIGBjb21wb25lbnREaWRNb3VudGAgdG8gYXR0YWNoIHRoZSBldmVudCBoYW5kbGVycy5cbiAqL1xudmFyIFJlYWN0RE9NSW1nID0gUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01JbWcnLFxuICB0YWdOYW1lOiAnSU1HJyxcblxuICBtaXhpbnM6IFtSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiwgTG9jYWxFdmVudFRyYXBNaXhpbl0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGltZyh0aGlzLnByb3BzKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJyk7XG4gICAgdGhpcy50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUltZzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JbnB1dFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEF1dG9Gb2N1c01peGluID0gcmVxdWlyZShcIi4vQXV0b0ZvY3VzTWl4aW5cIik7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKFwiLi9MaW5rZWRWYWx1ZVV0aWxzXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoXCIuL1JlYWN0Q2xhc3NcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKFwiLi9maW5kRE9NTm9kZVwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBpbnB1dCA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KCdpbnB1dCcpO1xuXG52YXIgaW5zdGFuY2VzQnlSZWFjdElEID0ge307XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICBpZiAodGhpcy5pc01vdW50ZWQoKSkge1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cbnZhciBSZWFjdERPTUlucHV0ID0gUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01JbnB1dCcsXG4gIHRhZ05hbWU6ICdJTlBVVCcsXG5cbiAgbWl4aW5zOiBbQXV0b0ZvY3VzTWl4aW4sIExpbmtlZFZhbHVlVXRpbHMuTWl4aW4sIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiB0aGlzLnByb3BzLmRlZmF1bHRDaGVja2VkIHx8IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiBkZWZhdWx0VmFsdWUgIT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIC8vIENsb25lIGB0aGlzLnByb3BzYCBzbyB3ZSBkb24ndCBtdXRhdGUgdGhlIGlucHV0LlxuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgdGhpcy5wcm9wcyk7XG5cbiAgICBwcm9wcy5kZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG4gICAgcHJvcHMuZGVmYXVsdFZhbHVlID0gbnVsbDtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcy5wcm9wcyk7XG4gICAgcHJvcHMudmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnN0YXRlLmluaXRpYWxWYWx1ZTtcblxuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHRoaXMucHJvcHMpO1xuICAgIHByb3BzLmNoZWNrZWQgPSBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogdGhpcy5zdGF0ZS5pbml0aWFsQ2hlY2tlZDtcblxuICAgIHByb3BzLm9uQ2hhbmdlID0gdGhpcy5faGFuZGxlQ2hhbmdlO1xuXG4gICAgcmV0dXJuIGlucHV0KHByb3BzLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCA9IFJlYWN0TW91bnQuZ2V0SUQoZmluZERPTU5vZGUodGhpcykpO1xuICAgIGluc3RhbmNlc0J5UmVhY3RJRFtpZF0gPSB0aGlzO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIGlkID0gUmVhY3RNb3VudC5nZXRJRChyb290Tm9kZSk7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RJRFtpZF07XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSB7XG4gICAgdmFyIHJvb3ROb2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgaWYgKHRoaXMucHJvcHMuY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShyb290Tm9kZSwgJ2NoZWNrZWQnLCB0aGlzLnByb3BzLmNoZWNrZWQgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcy5wcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShyb290Tm9kZSwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgb25DaGFuZ2UgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldE9uQ2hhbmdlKHRoaXMucHJvcHMpO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBvbkNoYW5nZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gICAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgICAvLyBpcyBpbXBvcnRhbnQgd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICBpZiAodGhpcy5wcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHJvb3ROb2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJJRCA9IFJlYWN0TW91bnQuZ2V0SUQob3RoZXJOb2RlKTtcbiAgICAgICAgIW90aGVySUQgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlICcgKyAnc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBvdGhlckluc3RhbmNlID0gaW5zdGFuY2VzQnlSZWFjdElEW290aGVySURdO1xuICAgICAgICAhb3RoZXJJbnN0YW5jZSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBVbmtub3duIHJhZGlvIGJ1dHRvbiBJRCAlcy4nLCBvdGhlcklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIG90aGVySW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTU9wdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL1JlYWN0Q2hpbGRyZW5cIik7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoXCIuL1JlYWN0Q2xhc3NcIik7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKFwiLi9SZWFjdERPTVNlbGVjdFwiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBvcHRpb24gPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSgnb3B0aW9uJyk7XG5cbnZhciB2YWx1ZUNvbnRleHRLZXkgPSBSZWFjdERPTVNlbGVjdC52YWx1ZUNvbnRleHRLZXk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NT3B0aW9uID0gUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01PcHRpb24nLFxuICB0YWdOYW1lOiAnT1BUSU9OJyxcblxuICBtaXhpbnM6IFtSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHsgc2VsZWN0ZWQ6IG51bGwgfTtcbiAgfSxcblxuICBjb250ZXh0VHlwZXM6IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9ialt2YWx1ZUNvbnRleHRLZXldID0gUmVhY3RQcm9wVHlwZXMuYW55O1xuICAgIHJldHVybiBvYmo7XG4gIH0pKCksXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHRoaXMucHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnIHZpYSBwYXJlbnQtYmFzZWQgY29udGV4dFxuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHZhciBzZWxlY3RWYWx1ZSA9IGNvbnRleHRbdmFsdWVDb250ZXh0S2V5XTtcblxuICAgIC8vIElmIGNvbnRleHQga2V5IGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSBza2lwIHByb3BzXG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtpXSA9PT0gJycgKyB0aGlzLnByb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gJycgKyB0aGlzLnByb3BzLnZhbHVlO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGVkOiBzZWxlY3RlZCB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFJlYWQgc3RhdGUgb25seSBmcm9tIGluaXRpYWwgbW91bnQgYmVjYXVzZSA8c2VsZWN0PiB1cGRhdGVzIHZhbHVlXG4gICAgLy8gbWFudWFsbHk7IHdlIG5lZWQgdGhlIGluaXRpYWwgc3RhdGUgb25seSBmb3Igc2VydmVyIHJlbmRlcmluZ1xuICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIHByb3BzID0gYXNzaWduKHt9LCBwcm9wcywgeyBzZWxlY3RlZDogdGhpcy5zdGF0ZS5zZWxlY3RlZCB9KTtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9ICcnO1xuXG4gICAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gICAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICBSZWFjdENoaWxkcmVuLmZvckVhY2godGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9wdGlvbihwcm9wcywgY29udGVudCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSByZXF1aXJlKFwiLi9BdXRvRm9jdXNNaXhpblwiKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZShcIi4vTGlua2VkVmFsdWVVdGlsc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKFwiLi9SZWFjdENsYXNzXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKFwiLi9maW5kRE9NTm9kZVwiKTtcblxudmFyIHNlbGVjdCA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KCdzZWxlY3QnKTtcblxudmFyIHZhbHVlQ29udGV4dEtleSA9ICdfX1JlYWN0RE9NU2VsZWN0X3ZhbHVlJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQoKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIGlmICh0aGlzLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgdGhpcy5fcGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcy5wcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdGhpcy5pc01vdW50ZWQoKSkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZWxlY3RWYWx1ZVR5cGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdUaGUgYCcgKyBwcm9wTmFtZSArICdgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignVGhlIGAnICsgcHJvcE5hbWUgKyAnYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBJbnN0YW5jZSBvZiBSZWFjdERPTVNlbGVjdFxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGNvbXBvbmVudCwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IGZpbmRET01Ob2RlKGNvbXBvbmVudCkub3B0aW9ucztcblxuICBpZiAoY29tcG9uZW50LnByb3BzLm11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTVNlbGVjdCcsXG4gIHRhZ05hbWU6ICdTRUxFQ1QnLFxuXG4gIG1peGluczogW0F1dG9Gb2N1c01peGluLCBMaW5rZWRWYWx1ZVV0aWxzLk1peGluLCBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgc3RhdGljczoge1xuICAgIHZhbHVlQ29udGV4dEtleTogdmFsdWVDb250ZXh0S2V5XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgZGVmYXVsdFZhbHVlOiBzZWxlY3RWYWx1ZVR5cGUsXG4gICAgdmFsdWU6IHNlbGVjdFZhbHVlVHlwZVxuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIFBhc3MgZG93biBpbml0aWFsIHZhbHVlIHNvIGluaXRpYWwgZ2VuZXJhdGVkIG1hcmt1cCBoYXMgY29ycmVjdFxuICAgIC8vIGBzZWxlY3RlZGAgYXR0cmlidXRlc1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcy5wcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGluaXRpYWxWYWx1ZTogdmFsdWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgaW5pdGlhbFZhbHVlOiB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSB9O1xuICAgIH1cbiAgfSxcblxuICBjaGlsZENvbnRleHRUeXBlczogKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgb2JqW3ZhbHVlQ29udGV4dEtleV0gPSBSZWFjdFByb3BUeXBlcy5hbnk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSkoKSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgb2JqW3ZhbHVlQ29udGV4dEtleV0gPSB0aGlzLnN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIC8vIENsb25lIGB0aGlzLnByb3BzYCBzbyB3ZSBkb24ndCBtdXRhdGUgdGhlIGlucHV0LlxuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgdGhpcy5wcm9wcyk7XG5cbiAgICBwcm9wcy5vbkNoYW5nZSA9IHRoaXMuX2hhbmRsZUNoYW5nZTtcbiAgICBwcm9wcy52YWx1ZSA9IG51bGw7XG5cbiAgICByZXR1cm4gc2VsZWN0KHByb3BzLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoZSBjb250ZXh0IHZhbHVlIGRvd25cbiAgICB0aGlzLnNldFN0YXRlKHsgaW5pdGlhbFZhbHVlOiBudWxsIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcy5wcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoIXByZXZQcm9wcy5tdWx0aXBsZSAhPT0gIXRoaXMucHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmICh0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIHRoaXMucHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX2hhbmRsZUNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHZhciBvbkNoYW5nZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0T25DaGFuZ2UodGhpcy5wcm9wcyk7XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IG9uQ2hhbmdlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX3BlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICAgIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Q7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKFwiLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XCIpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKFwiLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yXCIpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmICh0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSB0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnc2VsZWN0aW9uJyBpbiBkb2N1bWVudCAmJiAhKCdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyk7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlcnZlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0RGVmYXVsdEluamVjdGlvblwiKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZyA9IHJlcXVpcmUoXCIuL1JlYWN0U2VydmVyUmVuZGVyaW5nXCIpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciBSZWFjdERPTVNlcnZlciA9IHtcbiAgcmVuZGVyVG9TdHJpbmc6IFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlclRvU3RyaW5nLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyVG9TdGF0aWNNYXJrdXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZXJ2ZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFwiKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NQ29tcG9uZW50XCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKFwiLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcIik7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZShcIi4vdmFsaWRhdGVET01OZXN0aW5nXCIpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGluIGVsZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gdW5kZXJnb1xuICogdGhlIHNhbWUgcmVjb25jaWxpYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGVsZW1lbnRzLlxuICpcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxuICpcbiAqIEBjbGFzcyBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcykge307XG5cbmFzc2lnbihSZWFjdERPTVRleHRDb21wb25lbnQucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgcmVhbGx5IGEgUmVhY3RUZXh0IChSZWFjdE5vZGUpLCBub3QgYSBSZWFjdEVsZW1lbnRcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IHRleHQ7XG4gICAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcblxuICAgIC8vIFByb3BlcnRpZXNcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudEluZGV4ID0gMDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBpZiAoY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pIHtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKCdzcGFuJywgbnVsbCwgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG4gICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBpbiBhIGBzcGFuYCBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkIGFib3ZlLCBidXRcbiAgICAgIC8vIHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLFxuICAgICAgLy8gd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICc8c3BhbiAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHJvb3RJRCkgKyAnPicgKyBlc2NhcGVkVGV4dCArICc8L3NwYW4+JztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgUmVhY3RET01Db21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucy51cGRhdGVUZXh0Q29udGVudEJ5SUQodGhpcy5fcm9vdE5vZGVJRCwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50KHRoaXMuX3Jvb3ROb2RlSUQpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDtcblxuLy8gVGhpcyBjb25zdHJ1Y3RvciBhbmQgaXRzIGFyZ3VtZW50IGlzIGN1cnJlbnRseSB1c2VkIGJ5IG1vY2tzLiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRhcmVhXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSByZXF1aXJlKFwiLi9BdXRvRm9jdXNNaXhpblwiKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoXCIuL0xpbmtlZFZhbHVlVXRpbHNcIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoXCIuL2ZpbmRET01Ob2RlXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgdGV4dGFyZWEgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSgndGV4dGFyZWEnKTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIGlmICh0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbnZhciBSZWFjdERPTVRleHRhcmVhID0gUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01UZXh0YXJlYScsXG4gIHRhZ05hbWU6ICdURVhUQVJFQScsXG5cbiAgbWl4aW5zOiBbQXV0b0ZvY3VzTWl4aW4sIExpbmtlZFZhbHVlVXRpbHMuTWl4aW4sIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMucHJvcHMpO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBXZSBzYXZlIHRoZSBpbml0aWFsIHZhbHVlIHNvIHRoYXQgYFJlYWN0RE9NQ29tcG9uZW50YCBkb2Vzbid0IHVwZGF0ZVxuICAgICAgLy8gYHRleHRDb250ZW50YCAodW5uZWNlc3Nhcnkgc2luY2Ugd2UgdXBkYXRlIHZhbHVlKS5cbiAgICAgIC8vIFRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQnc1xuICAgICAgLy8gZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgICAgaW5pdGlhbFZhbHVlOiAnJyArICh2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBkZWZhdWx0VmFsdWUpXG4gICAgfTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDbG9uZSBgdGhpcy5wcm9wc2Agc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBpbnB1dC5cbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuXG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBwcm9wcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgIHByb3BzLnZhbHVlID0gbnVsbDtcbiAgICBwcm9wcy5vbkNoYW5nZSA9IHRoaXMuX2hhbmRsZUNoYW5nZTtcblxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gICAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC5cbiAgICByZXR1cm4gdGV4dGFyZWEocHJvcHMsIHRoaXMuc3RhdGUuaW5pdGlhbFZhbHVlKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMucHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgcm9vdE5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShyb290Tm9kZSwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgb25DaGFuZ2UgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldE9uQ2hhbmdlKHRoaXMucHJvcHMpO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBvbkNoYW5nZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbmFzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgY2FsbGJhY2soYSwgYiwgYywgZCwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vQmVmb3JlSW5wdXRFdmVudFBsdWdpblwiKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL0NoYW5nZUV2ZW50UGx1Z2luXCIpO1xudmFyIENsaWVudFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZShcIi4vQ2xpZW50UmVhY3RSb290SW5kZXhcIik7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKFwiLi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlclwiKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9FbnRlckxlYXZlRXZlbnRQbHVnaW5cIik7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKFwiLi9IVE1MRE9NUHJvcGVydHlDb25maWdcIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50XCIpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKFwiLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XCIpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RET01Db21wb25lbnRcIik7XG52YXIgUmVhY3RET01CdXR0b24gPSByZXF1aXJlKFwiLi9SZWFjdERPTUJ1dHRvblwiKTtcbnZhciBSZWFjdERPTUZvcm0gPSByZXF1aXJlKFwiLi9SZWFjdERPTUZvcm1cIik7XG52YXIgUmVhY3RET01JbWcgPSByZXF1aXJlKFwiLi9SZWFjdERPTUltZ1wiKTtcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NSURPcGVyYXRpb25zXCIpO1xudmFyIFJlYWN0RE9NSWZyYW1lID0gcmVxdWlyZShcIi4vUmVhY3RET01JZnJhbWVcIik7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NSW5wdXRcIik7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKFwiLi9SZWFjdERPTU9wdGlvblwiKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NU2VsZWN0XCIpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKFwiLi9SZWFjdERPTVRleHRhcmVhXCIpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NVGV4dENvbXBvbmVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0gcmVxdWlyZShcIi4vUmVhY3RFdmVudExpc3RlbmVyXCIpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RJbmplY3Rpb25cIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZU1hcFwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblwiKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL1NlbGVjdEV2ZW50UGx1Z2luXCIpO1xudmFyIFNlcnZlclJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZShcIi4vU2VydmVyUmVhY3RSb290SW5kZXhcIik7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9TaW1wbGVFdmVudFBsdWdpblwiKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoXCIuL1NWR0RPTVByb3BlcnR5Q29uZmlnXCIpO1xuXG52YXIgY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQgPSByZXF1aXJlKFwiLi9jcmVhdGVGdWxsUGFnZUNvbXBvbmVudFwiKTtcblxuZnVuY3Rpb24gYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzKHR5cGUpIHtcbiAgcmV0dXJuIFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3Moe1xuICAgIHRhZ05hbWU6IHR5cGUudG9VcHBlckNhc2UoKSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENvcHkgb3duZXIgZG93biBmb3IgZGVidWdnaW5nIGluZm9cbiAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcyk7XG4gICAgICByZXR1cm4gbmV3IFJlYWN0RWxlbWVudCh0eXBlLCBudWxsLCAvLyBrZXlcbiAgICAgIG51bGwsIC8vIHJlZlxuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyLCAvLyBvd25lclxuICAgICAgbnVsbCwgLy8gY29udGV4dFxuICAgICAgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0SW5zdGFuY2VIYW5kbGUoUmVhY3RJbnN0YW5jZUhhbmRsZXMpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RNb3VudChSZWFjdE1vdW50KTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5OYXRpdmVDb21wb25lbnQuaW5qZWN0QXV0b1dyYXBwZXIoYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzKTtcblxuICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoKSBvdGhlcndpc2UgdGhlIG1peGluXG4gIC8vIHdvbid0IGJlIGluY2x1ZGVkLlxuICBSZWFjdEluamVjdGlvbi5DbGFzcy5pbmplY3RNaXhpbihSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbik7XG5cbiAgUmVhY3RJbmplY3Rpb24uTmF0aXZlQ29tcG9uZW50LmluamVjdENvbXBvbmVudENsYXNzZXMoe1xuICAgICdidXR0b24nOiBSZWFjdERPTUJ1dHRvbixcbiAgICAnZm9ybSc6IFJlYWN0RE9NRm9ybSxcbiAgICAnaWZyYW1lJzogUmVhY3RET01JZnJhbWUsXG4gICAgJ2ltZyc6IFJlYWN0RE9NSW1nLFxuICAgICdpbnB1dCc6IFJlYWN0RE9NSW5wdXQsXG4gICAgJ29wdGlvbic6IFJlYWN0RE9NT3B0aW9uLFxuICAgICdzZWxlY3QnOiBSZWFjdERPTVNlbGVjdCxcbiAgICAndGV4dGFyZWEnOiBSZWFjdERPTVRleHRhcmVhLFxuXG4gICAgJ2h0bWwnOiBjcmVhdGVGdWxsUGFnZUNvbXBvbmVudCgnaHRtbCcpLFxuICAgICdoZWFkJzogY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoJ2hlYWQnKSxcbiAgICAnYm9keSc6IGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KCdib2R5JylcbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50KCdub3NjcmlwdCcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Sb290SW5kZXguaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXgoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gQ2xpZW50UmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggOiBTZXJ2ZXJSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NQ29tcG9uZW50LmluamVjdElET3BlcmF0aW9ucyhSZWFjdERPTUlET3BlcmF0aW9ucyk7XG5cbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuICAgIGlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xuICAgICAgdmFyIFJlYWN0RGVmYXVsdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdERlZmF1bHRQZXJmXCIpO1xuICAgICAgUmVhY3REZWZhdWx0UGVyZi5zdGFydCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMgPSByZXF1aXJlKFwiLi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSByZXF1aXJlKFwiLi9wZXJmb3JtYW5jZU5vd1wiKTtcblxuZnVuY3Rpb24gcm91bmRGbG9hdCh2YWwpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsICogMTAwKSAvIDEwMDtcbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUob2JqLCBrZXksIHZhbCkge1xuICBvYmpba2V5XSA9IChvYmpba2V5XSB8fCAwKSArIHZhbDtcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmYgPSB7XG4gIF9hbGxNZWFzdXJlbWVudHM6IFtdLCAvLyBsYXN0IGl0ZW0gaW4gdGhlIGxpc3QgaXMgdGhlIGN1cnJlbnQgb25lXG4gIF9tb3VudFN0YWNrOiBbMF0sXG4gIF9pbmplY3RlZDogZmFsc2UsXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVJlYWN0RGVmYXVsdFBlcmYuX2luamVjdGVkKSB7XG4gICAgICBSZWFjdFBlcmYuaW5qZWN0aW9uLmluamVjdE1lYXN1cmUoUmVhY3REZWZhdWx0UGVyZi5tZWFzdXJlKTtcbiAgICB9XG5cbiAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoID0gMDtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IHRydWU7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlID0gZmFsc2U7XG4gIH0sXG5cbiAgZ2V0TGFzdE1lYXN1cmVtZW50czogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gIH0sXG5cbiAgcHJpbnRFeGNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnQ29tcG9uZW50IGNsYXNzIG5hbWUnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdUb3RhbCBpbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmluY2x1c2l2ZSksXG4gICAgICAgICdFeGNsdXNpdmUgbW91bnQgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmV4Y2x1c2l2ZSksXG4gICAgICAgICdFeGNsdXNpdmUgcmVuZGVyIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIpLFxuICAgICAgICAnTW91bnQgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ1JlbmRlciB0aW1lIHBlciBpbnN0YW5jZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnJlbmRlciAvIGl0ZW0uY291bnQpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgLy8gVE9ETzogUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZSgpIGRvZXMgbm90IHJldHVybiB0aGUgY29ycmVjdFxuICAgIC8vIG51bWJlci5cbiAgfSxcblxuICBwcmludEluY2x1c2l2ZTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ0luY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0udGltZSksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBnZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMsIHRydWUpO1xuICAgIHJldHVybiBzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ093bmVyID4gY29tcG9uZW50JzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnV2FzdGVkIHRpbWUgKG1zKSc6IGl0ZW0udGltZSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG5cbiAgcHJpbnRXYXN0ZWQ6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIGNvbnNvbGUudGFibGUoUmVhY3REZWZhdWx0UGVyZi5nZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwKG1lYXN1cmVtZW50cykpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIHByaW50RE9NOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRET01TdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzdWx0W0RPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FXSA9IGl0ZW0uaWQ7XG4gICAgICByZXN1bHRbJ3R5cGUnXSA9IGl0ZW0udHlwZTtcbiAgICAgIHJlc3VsdFsnYXJncyddID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5hcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIF9yZWNvcmRXcml0ZTogZnVuY3Rpb24gKGlkLCBmbk5hbWUsIHRvdGFsVGltZSwgYXJncykge1xuICAgIC8vIFRPRE86IHRvdGFsVGltZSBpc24ndCB0aGF0IHVzZWZ1bCBzaW5jZSBpdCBkb2Vzbid0IGNvdW50IHBhaW50cy9yZWZsb3dzXG4gICAgdmFyIHdyaXRlcyA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0ud3JpdGVzO1xuICAgIHdyaXRlc1tpZF0gPSB3cml0ZXNbaWRdIHx8IFtdO1xuICAgIHdyaXRlc1tpZF0ucHVzaCh7XG4gICAgICB0eXBlOiBmbk5hbWUsXG4gICAgICB0aW1lOiB0b3RhbFRpbWUsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gIH0sXG5cbiAgbWVhc3VyZTogZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxUaW1lO1xuICAgICAgdmFyIHJ2O1xuICAgICAgdmFyIHN0YXJ0O1xuXG4gICAgICBpZiAoZm5OYW1lID09PSAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnIHx8IGZuTmFtZSA9PT0gJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnKSB7XG4gICAgICAgIC8vIEEgXCJtZWFzdXJlbWVudFwiIGlzIGEgc2V0IG9mIG1ldHJpY3MgcmVjb3JkZWQgZm9yIGVhY2ggZmx1c2guIFdlIHdhbnRcbiAgICAgICAgLy8gdG8gZ3JvdXAgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gZmx1c2ggdG9nZXRoZXIgc28gd2UgY2FuIGxvb2sgYXQgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCBhbmQgdGhlIERPTSBvcGVyYXRpb25zIHRoYXQgYWN0dWFsbHlcbiAgICAgICAgLy8gaGFwcGVuZWQgdG8gZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2YgXCJ3YXN0ZWQgd29ya1wiIHBlcmZvcm1lZC5cbiAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgICAgIGV4Y2x1c2l2ZToge30sXG4gICAgICAgICAgaW5jbHVzaXZlOiB7fSxcbiAgICAgICAgICByZW5kZXI6IHt9LFxuICAgICAgICAgIGNvdW50czoge30sXG4gICAgICAgICAgd3JpdGVzOiB7fSxcbiAgICAgICAgICBkaXNwbGF5TmFtZXM6IHt9LFxuICAgICAgICAgIHRvdGFsVGltZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0udG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnIHx8IG1vZHVsZU5hbWUgPT09ICdSZWFjdERPTUlET3BlcmF0aW9ucycpIHtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoZm5OYW1lID09PSAnX21vdW50SW1hZ2VJbnRvTm9kZScpIHtcbiAgICAgICAgICB2YXIgbW91bnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoYXJnc1sxXSk7XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUobW91bnRJRCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGZvcm1hdFxuICAgICAgICAgIGFyZ3NbMF0uZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVBcmdzID0ge307XG4gICAgICAgICAgICBpZiAodXBkYXRlLmZyb21JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MuZnJvbUluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudG9JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudG9JbmRleCA9IHVwZGF0ZS50b0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS50ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudGV4dENvbnRlbnQgPSB1cGRhdGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLm1hcmt1cEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy5tYXJrdXAgPSBhcmdzWzFdW3VwZGF0ZS5tYXJrdXBJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZSh1cGRhdGUucGFyZW50SUQsIHVwZGF0ZS50eXBlLCB0b3RhbFRpbWUsIHdyaXRlQXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmFzaWMgZm9ybWF0XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUoYXJnc1swXSwgZm5OYW1lLCB0b3RhbFRpbWUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKG1vZHVsZU5hbWUgPT09ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcgJiYgKGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICd1cGRhdGVDb21wb25lbnQnIHx8IC8vIFRPRE86IHJlY2VpdmVDb21wb25lbnQoKT9cbiAgICAgIGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnKSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb290Tm9kZUlEID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnID8gYXJnc1swXSA6IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICAgIHZhciBpc1JlbmRlciA9IGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnO1xuICAgICAgICB2YXIgaXNNb3VudCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JztcblxuICAgICAgICB2YXIgbW91bnRTdGFjayA9IFJlYWN0RGVmYXVsdFBlcmYuX21vdW50U3RhY2s7XG4gICAgICAgIHZhciBlbnRyeSA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuY291bnRzLCByb290Tm9kZUlELCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgbW91bnRTdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5yZW5kZXIsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIHZhciBzdWJNb3VudFRpbWUgPSBtb3VudFN0YWNrLnBvcCgpO1xuICAgICAgICAgIG1vdW50U3RhY2tbbW91bnRTdGFjay5sZW5ndGggLSAxXSArPSB0b3RhbFRpbWU7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuZXhjbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUgLSBzdWJNb3VudFRpbWUpO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5kaXNwbGF5TmFtZXNbcm9vdE5vZGVJRF0gPSB7XG4gICAgICAgICAgY3VycmVudDogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgb3duZXI6IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgOiAnPHJvb3Q+J1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcblxuLy8gRG9uJ3QgdHJ5IHRvIHNhdmUgdXNlcnMgbGVzcyB0aGFuIDEuMm1zIChhIG51bWJlciBJIG1hZGUgdXApXG52YXIgRE9OVF9DQVJFX1RIUkVTSE9MRCA9IDEuMjtcbnZhciBET01fT1BFUkFUSU9OX1RZUEVTID0ge1xuICAnX21vdW50SW1hZ2VJbnRvTm9kZSc6ICdzZXQgaW5uZXJIVE1MJyxcbiAgSU5TRVJUX01BUktVUDogJ3NldCBpbm5lckhUTUwnLFxuICBNT1ZFX0VYSVNUSU5HOiAnbW92ZScsXG4gIFJFTU9WRV9OT0RFOiAncmVtb3ZlJyxcbiAgVEVYVF9DT05URU5UOiAnc2V0IHRleHRDb250ZW50JyxcbiAgJ3VwZGF0ZVByb3BlcnR5QnlJRCc6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgJ2RlbGV0ZVByb3BlcnR5QnlJRCc6ICdkZWxldGUgYXR0cmlidXRlJyxcbiAgJ3VwZGF0ZVN0eWxlc0J5SUQnOiAndXBkYXRlIHN0eWxlcycsXG4gICd1cGRhdGVJbm5lckhUTUxCeUlEJzogJ3NldCBpbm5lckhUTUwnLFxuICAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEJzogJ3JlcGxhY2UnXG59O1xuXG5mdW5jdGlvbiBnZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKSB7XG4gIC8vIFRPRE86IHJldHVybiBudW1iZXIgb2YgRE9NIG9wcz8gY291bGQgYmUgbWlzbGVhZGluZy5cbiAgLy8gVE9ETzogbWVhc3VyZSBkcm9wcGVkIGZyYW1lcyBhZnRlciByZWNvbmNpbGU/XG4gIC8vIFRPRE86IGxvZyB0b3RhbCB0aW1lIG9mIGVhY2ggcmVjb25jaWxlIGFuZCB0aGUgdG9wLWxldmVsIGNvbXBvbmVudFxuICAvLyBjbGFzcyB0aGF0IHRyaWdnZXJlZCBpdC5cbiAgdmFyIHRvdGFsVGltZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHRvdGFsVGltZSArPSBtZWFzdXJlbWVudC50b3RhbFRpbWU7XG4gIH1cbiAgcmV0dXJuIHRvdGFsVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpIHtcbiAgdmFyIGl0ZW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciBpZDtcblxuICAgIGZvciAoaWQgaW4gbWVhc3VyZW1lbnQud3JpdGVzKSB7XG4gICAgICBtZWFzdXJlbWVudC53cml0ZXNbaWRdLmZvckVhY2goZnVuY3Rpb24gKHdyaXRlKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB0eXBlOiBET01fT1BFUkFUSU9OX1RZUEVTW3dyaXRlLnR5cGVdIHx8IHdyaXRlLnR5cGUsXG4gICAgICAgICAgYXJnczogd3JpdGUuYXJnc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBkaXNwbGF5TmFtZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSA9IGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIGluY2x1c2l2ZTogMCxcbiAgICAgICAgZXhjbHVzaXZlOiAwLFxuICAgICAgICByZW5kZXI6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuICAgICAgaWYgKG1lYXN1cmVtZW50LnJlbmRlcltpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0ucmVuZGVyICs9IG1lYXN1cmVtZW50LnJlbmRlcltpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmluY2x1c2l2ZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uY291bnQgKz0gbWVhc3VyZW1lbnQuY291bnRzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbWFrZSBhIHNvcnRlZCBhcnJheSB3aXRoIHRoZSByZXN1bHRzLlxuICB2YXIgYXJyID0gW107XG4gIGZvciAoZGlzcGxheU5hbWUgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgPj0gRE9OVF9DQVJFX1RIUkVTSE9MRCkge1xuICAgICAgYXJyLnB1c2goY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuZXhjbHVzaXZlIC0gYS5leGNsdXNpdmU7XG4gIH0pO1xuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCBvbmx5Q2xlYW4pIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB7fTtcbiAgdmFyIGluY2x1c2l2ZUtleTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG4gICAgdmFyIGNsZWFuQ29tcG9uZW50cztcblxuICAgIGlmIChvbmx5Q2xlYW4pIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50cyA9IGdldFVuY2hhbmdlZENvbXBvbmVudHMobWVhc3VyZW1lbnQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgICAgaWYgKG9ubHlDbGVhbiAmJiAhY2xlYW5Db21wb25lbnRzW2lkXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXTtcblxuICAgICAgLy8gSW5jbHVzaXZlIHRpbWUgaXMgbm90IHVzZWZ1bCBmb3IgbWFueSBjb21wb25lbnRzIHdpdGhvdXQga25vd2luZyB3aGVyZVxuICAgICAgLy8gdGhleSBhcmUgaW5zdGFudGlhdGVkLiBTbyB3ZSBhZ2dyZWdhdGUgaW5jbHVzaXZlIHRpbWUgd2l0aCBib3RoIHRoZVxuICAgICAgLy8gb3duZXIgYW5kIGN1cnJlbnQgZGlzcGxheU5hbWUgYXMgdGhlIGtleS5cbiAgICAgIGluY2x1c2l2ZUtleSA9IGRpc3BsYXlOYW1lLm93bmVyICsgJyA+ICcgKyBkaXNwbGF5TmFtZS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gPSBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gfHwge1xuICAgICAgICBjb21wb25lbnROYW1lOiBpbmNsdXNpdmVLZXksXG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGluY2x1c2l2ZUtleSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS50aW1lID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSk7XG4gICAgfVxuICB9XG5cbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi50aW1lIC0gYS50aW1lO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KSB7XG4gIC8vIEZvciBhIGdpdmVuIHJlY29uY2lsZSwgbG9vayBhdCB3aGljaCBjb21wb25lbnRzIGRpZCBub3QgYWN0dWFsbHlcbiAgLy8gcmVuZGVyIGFueXRoaW5nIHRvIHRoZSBET00gYW5kIHJldHVybiBhIG1hcHBpbmcgb2YgdGhlaXIgSUQgdG9cbiAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIHRoZSBlbnRpcmUgc3VidHJlZS5cbiAgdmFyIGNsZWFuQ29tcG9uZW50cyA9IHt9O1xuICB2YXIgZGlydHlMZWFmSURzID0gT2JqZWN0LmtleXMobWVhc3VyZW1lbnQud3JpdGVzKTtcbiAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgLy8gRm9yIGVhY2ggY29tcG9uZW50IHRoYXQgcmVuZGVyZWQsIHNlZSBpZiBhIGNvbXBvbmVudCB0aGF0IHRyaWdnZXJlZFxuICAgIC8vIGEgRE9NIG9wIGlzIGluIGl0cyBzdWJ0cmVlLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlydHlMZWFmSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZGlydHlMZWFmSURzW2ldLmluZGV4T2YoaWQpID09PSAwKSB7XG4gICAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0RpcnR5ICYmIG1lYXN1cmVtZW50LmNvdW50c1tpZF0gPiAwKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsZWFuQ29tcG9uZW50cztcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHtcbiAgZ2V0RXhjbHVzaXZlU3VtbWFyeTogZ2V0RXhjbHVzaXZlU3VtbWFyeSxcbiAgZ2V0SW5jbHVzaXZlU3VtbWFyeTogZ2V0SW5jbHVzaXZlU3VtbWFyeSxcbiAgZ2V0RE9NU3VtbWFyeTogZ2V0RE9NU3VtbWFyeSxcbiAgZ2V0VG90YWxUaW1lOiBnZXRUb3RhbFRpbWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbnRleHQgPSByZXF1aXJlKFwiLi9SZWFjdENvbnRleHRcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWVcbn07XG5cbi8qKlxuICogV2FybiBmb3IgbXV0YXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5mdW5jdGlvbiBkZWZpbmVXYXJuaW5nUHJvcGVydHkob2JqZWN0LCBrZXkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG5cbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmVba2V5XTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnRG9uXFwndCBzZXQgdGhlICVzIHByb3BlcnR5IG9mIHRoZSBSZWFjdCBlbGVtZW50LiBJbnN0ZWFkLCAnICsgJ3NwZWNpZnkgdGhlIGNvcnJlY3QgdmFsdWUgd2hlbiBpbml0aWFsbHkgY3JlYXRpbmcgdGhlIGVsZW1lbnQuJywga2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3N0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBpcyB1cGRhdGVkIHRvIHRydWUgaWYgdGhlIG1lbWJyYW5lIGlzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkLlxuICovXG52YXIgdXNlTXV0YXRpb25NZW1icmFuZSA9IGZhbHNlO1xuXG4vKipcbiAqIFdhcm4gZm9yIG11dGF0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGRlZmluZU11dGF0aW9uTWVtYnJhbmUocHJvdG90eXBlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHBzZXVkb0Zyb3plblByb3BlcnRpZXMgPSB7XG4gICAgICBwcm9wczogdHJ1ZVxuICAgIH07XG4gICAgZm9yICh2YXIga2V5IGluIHBzZXVkb0Zyb3plblByb3BlcnRpZXMpIHtcbiAgICAgIGRlZmluZVdhcm5pbmdQcm9wZXJ0eShwcm90b3R5cGUsIGtleSk7XG4gICAgfVxuICAgIHVzZU11dGF0aW9uTWVtYnJhbmUgPSB0cnVlO1xuICB9IGNhdGNoICh4KSB7fVxufVxuXG4vKipcbiAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBSZWFjdCBlbGVtZW50cy4gVGhpcyBpcyBvbmx5IHVzZWQgdG8gbWFrZSB0aGlzXG4gKiB3b3JrIHdpdGggYSBkeW5hbWljIGluc3RhbmNlb2YgY2hlY2suIE5vdGhpbmcgc2hvdWxkIGxpdmUgb24gdGhpcyBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBvd25lciwgY29udGV4dCwgcHJvcHMpIHtcbiAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5yZWYgPSByZWY7XG5cbiAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgdGhpcy5fb3duZXIgPSBvd25lcjtcblxuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgYW5kIHByb3BzIGFyZSBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCB0aGVtIG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgdGhpcy5fc3RvcmUgPSB7IHByb3BzOiBwcm9wcywgb3JpZ2luYWxQcm9wczogYXNzaWduKHt9LCBwcm9wcykgfTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgdGhpcy5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG5cbiAgICAvLyBXZSdyZSBub3QgYWxsb3dlZCB0byBzZXQgcHJvcHMgZGlyZWN0bHkgb24gdGhlIG9iamVjdCBzbyB3ZSBlYXJseVxuICAgIC8vIHJldHVybiBhbmQgcmVseSBvbiB0aGUgcHJvdG90eXBlIG1lbWJyYW5lIHRvIGZvcndhcmQgdG8gdGhlIGJhY2tpbmdcbiAgICAvLyBzdG9yZS5cbiAgICBpZiAodXNlTXV0YXRpb25NZW1icmFuZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB0aGlzLnByb3BzID0gcHJvcHM7XG59O1xuXG4vLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IGV4cG9zZSB0aGUgZnVuY3Rpb24gb24gdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5LlxuLy8gUmVhY3RFbGVtZW50IHNob3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuUmVhY3RFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgX2lzUmVhY3RFbGVtZW50OiB0cnVlXG59O1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBkZWZpbmVNdXRhdGlvbk1lbWJyYW5lKFJlYWN0RWxlbWVudC5wcm90b3R5cGUpO1xufVxuXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICByZWYgPSBjb25maWcucmVmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLnJlZjtcbiAgICBrZXkgPSBjb25maWcua2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBjb25maWcua2V5O1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wc1twcm9wTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIFJlYWN0Q29udGV4dC5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3UHJvcHMpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBuZXcgUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgb2xkRWxlbWVudC5rZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5fY29udGV4dCwgbmV3UHJvcHMpO1xuXG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgLy8gSWYgdGhlIGtleSBvbiB0aGUgb3JpZ2luYWwgaXMgdmFsaWQsIHRoZW4gdGhlIGNsb25lIGlzIHZhbGlkXG4gICAgbmV3RWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gb2xkRWxlbWVudC5fc3RvcmUudmFsaWRhdGVkO1xuICB9XG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChjb25maWcucmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgb3duZXIsIGVsZW1lbnQuX2NvbnRleHQsIHByb3BzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAvLyBSZWFjdFRlc3RVdGlscyBpcyBvZnRlbiB1c2VkIG91dHNpZGUgb2YgYmVmb3JlRWFjaCB3aGVyZSBhcyBSZWFjdCBpc1xuICAvLyB3aXRoaW4gaXQuIFRoaXMgbGVhZHMgdG8gdHdvIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgUmVhY3Qgb24gdGhlIHNhbWVcbiAgLy8gcGFnZS4gVG8gaWRlbnRpZnkgYSBlbGVtZW50IGZyb20gYSBkaWZmZXJlbnQgUmVhY3QgaW5zdGFuY2Ugd2UgdXNlXG4gIC8vIGEgZmxhZyBpbnN0ZWFkIG9mIGFuIGluc3RhbmNlb2YgY2hlY2suXG4gIHZhciBpc0VsZW1lbnQgPSAhIShvYmplY3QgJiYgb2JqZWN0Ll9pc1JlYWN0RWxlbWVudCk7XG4gIC8vIGlmIChpc0VsZW1lbnQgJiYgIShvYmplY3QgaW5zdGFuY2VvZiBSZWFjdEVsZW1lbnQpKSB7XG4gIC8vIFRoaXMgaXMgYW4gaW5kaWNhdG9yIHRoYXQgeW91J3JlIHVzaW5nIG11bHRpcGxlIHZlcnNpb25zIG9mIFJlYWN0IGF0IHRoZVxuICAvLyBzYW1lIHRpbWUuIFRoaXMgd2lsbCBzY3JldyB3aXRoIG93bmVyc2hpcCBhbmQgc3R1ZmYuIEZpeCBpdCwgcGxlYXNlLlxuICAvLyBUT0RPOiBXZSBjb3VsZCBwb3NzaWJseSB3YXJuIGhlcmUuXG4gIC8vIH1cbiAgcmV0dXJuIGlzRWxlbWVudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG4vLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHkiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50VmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RnJhZ21lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEZyYWdtZW50XCIpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0TmF0aXZlQ29tcG9uZW50XCIpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoXCIuL2dldEl0ZXJhdG9yRm5cIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbnZhciBOVU1FUklDX1BST1BFUlRZX1JFR0VYID0gL15cXGQrJC87XG5cbi8qKlxuICogR2V0cyB0aGUgaW5zdGFuY2UncyBuYW1lIGZvciB1c2UgaW4gd2FybmluZ3MuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBEaXNwbGF5IG5hbWUgb3IgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUoaW5zdGFuY2UpIHtcbiAgdmFyIHB1YmxpY0luc3RhbmNlID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgaWYgKCFwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lIHx8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50IG93bmVyJ3MgZGlzcGxheU5hbWUgZm9yIHVzZSBpbiB3YXJuaW5ncy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm4gez9zdHJpbmd9IERpc3BsYXkgbmFtZSBvciB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudE93bmVyRGlzcGxheU5hbWUoKSB7XG4gIHZhciBjdXJyZW50ID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgcmV0dXJuIGN1cnJlbnQgJiYgZ2V0TmFtZShjdXJyZW50KSB8fCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgd2FybkFuZE1vbml0b3JGb3JLZXlVc2UoJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicsIGVsZW1lbnQsIHBhcmVudFR5cGUpO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGtleSBpcyBiZWluZyBkZWZpbmVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eSBidXQgaGFzIGFuIGluY29ycmVjdFxuICogdmFsdWUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBDb21wb25lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eUtleShuYW1lLCBlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghTlVNRVJJQ19QUk9QRVJUWV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5BbmRNb25pdG9yRm9yS2V5VXNlKCdDaGlsZCBvYmplY3RzIHNob3VsZCBoYXZlIG5vbi1udW1lcmljIGtleXMgc28gb3JkZXJpbmcgaXMgcHJlc2VydmVkLicsIGVsZW1lbnQsIHBhcmVudFR5cGUpO1xufVxuXG4vKipcbiAqIFNoYXJlZCB3YXJuaW5nIGFuZCBtb25pdG9yaW5nIGNvZGUgZm9yIHRoZSBrZXkgd2FybmluZ3MuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgYmFzZSB3YXJuaW5nIHRoYXQgZ2V0cyBvdXRwdXQuXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBDb21wb25lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gd2FybkFuZE1vbml0b3JGb3JLZXlVc2UobWVzc2FnZSwgZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudE93bmVyRGlzcGxheU5hbWUoKTtcbiAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgdmFyIHVzZU5hbWUgPSBvd25lck5hbWUgfHwgcGFyZW50TmFtZTtcbiAgdmFyIG1lbW9pemVyID0gb3duZXJIYXNLZXlVc2VXYXJuaW5nW21lc3NhZ2VdIHx8IChvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZV0gPSB7fSk7XG4gIGlmIChtZW1vaXplci5oYXNPd25Qcm9wZXJ0eSh1c2VOYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBtZW1vaXplclt1c2VOYW1lXSA9IHRydWU7XG5cbiAgdmFyIHBhcmVudE9yT3duZXJBZGRlbmR1bSA9IG93bmVyTmFtZSA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIG93bmVyTmFtZSArICcuJyA6IHBhcmVudE5hbWUgPyAnIENoZWNrIHRoZSBSZWFjdC5yZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nIDogJyc7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyQWRkZW5kdW0gPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBOYW1lIG9mIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICB2YXIgY2hpbGRPd25lck5hbWUgPSBnZXROYW1lKGVsZW1lbnQuX293bmVyKTtcblxuICAgIGNoaWxkT3duZXJBZGRlbmR1bSA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGNoaWxkT3duZXJOYW1lICsgJy4nO1xuICB9XG5cbiAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsIG1lc3NhZ2UgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgcGFyZW50T3JPd25lckFkZGVuZHVtLCBjaGlsZE93bmVyQWRkZW5kdW0pIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgZnJhZ21lbnQgPSBSZWFjdEZyYWdtZW50LmV4dHJhY3RJZkZyYWdtZW50KG5vZGUpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGZyYWdtZW50KSB7XG4gICAgICAgIGlmIChmcmFnbWVudC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eUtleShrZXksIGZyYWdtZW50W2tleV0sIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgcHJvcFR5cGVzW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lLCB0eXBlb2YgZXJyb3IpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgd2FybmVkUHJvcHNNdXRhdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBXYXJuIGFib3V0IG11dGF0aW5nIHByb3BzIHdoZW4gc2V0dGluZyBgcHJvcE5hbWVgIG9uIGBlbGVtZW50YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgVGhlIHN0cmluZyBrZXkgd2l0aGluIHByb3BzIHRoYXQgd2FzIHNldFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gd2FybkZvclByb3BzTXV0YXRpb24ocHJvcE5hbWUsIGVsZW1lbnQpIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBlbGVtZW50TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB0eXBlLmRpc3BsYXlOYW1lO1xuICB2YXIgb3duZXJOYW1lID0gZWxlbWVudC5fb3duZXIgPyBlbGVtZW50Ll9vd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIDogbnVsbDtcblxuICB2YXIgd2FybmluZ0tleSA9IHByb3BOYW1lICsgJ3wnICsgZWxlbWVudE5hbWUgKyAnfCcgKyBvd25lck5hbWU7XG4gIGlmICh3YXJuZWRQcm9wc011dGF0aW9ucy5oYXNPd25Qcm9wZXJ0eSh3YXJuaW5nS2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuZWRQcm9wc011dGF0aW9uc1t3YXJuaW5nS2V5XSA9IHRydWU7XG5cbiAgdmFyIGVsZW1lbnRJbmZvID0gJyc7XG4gIGlmIChlbGVtZW50TmFtZSkge1xuICAgIGVsZW1lbnRJbmZvID0gJyA8JyArIGVsZW1lbnROYW1lICsgJyAvPic7XG4gIH1cbiAgdmFyIG93bmVySW5mbyA9ICcnO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgb3duZXJJbmZvID0gJyBUaGUgZWxlbWVudCB3YXMgY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJy4nO1xuICB9XG5cbiAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdEb25cXCd0IHNldCAucHJvcHMuJXMgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCVzLiBJbnN0ZWFkLCBzcGVjaWZ5IHRoZSAnICsgJ2NvcnJlY3QgdmFsdWUgd2hlbiBpbml0aWFsbHkgY3JlYXRpbmcgdGhlIGVsZW1lbnQgb3IgdXNlICcgKyAnUmVhY3QuY2xvbmVFbGVtZW50IHRvIG1ha2UgYSBuZXcgZWxlbWVudCB3aXRoIHVwZGF0ZWQgcHJvcHMuJXMnLCBwcm9wTmFtZSwgZWxlbWVudEluZm8sIG93bmVySW5mbykgOiB1bmRlZmluZWQ7XG59XG5cbi8vIElubGluZSBPYmplY3QuaXMgcG9seWZpbGxcbmZ1bmN0aW9uIGlzKGEsIGIpIHtcbiAgaWYgKGEgIT09IGEpIHtcbiAgICAvLyBOYU5cbiAgICByZXR1cm4gYiAhPT0gYjtcbiAgfVxuICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG4gICAgLy8gKy0wXG4gICAgcmV0dXJuIDEgLyBhID09PSAxIC8gYjtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCBjaGVjayBpZiBpdHMgcHJvcHMgaGF2ZSBiZWVuIG11dGF0ZWQgc2luY2UgZWxlbWVudFxuICogY3JlYXRpb24gKG9yIHRoZSBsYXN0IGNhbGwgdG8gdGhpcyBmdW5jdGlvbikuIEluIHBhcnRpY3VsYXIsIGNoZWNrIGlmIGFueVxuICogbmV3IHByb3BzIGhhdmUgYmVlbiBhZGRlZCwgd2hpY2ggd2UgY2FuJ3QgZGlyZWN0bHkgY2F0Y2ggYnkgZGVmaW5pbmcgd2FybmluZ1xuICogcHJvcGVydGllcyBvbiB0aGUgcHJvcHMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRQcm9wcyhlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUpIHtcbiAgICAvLyBFbGVtZW50IHdhcyBjcmVhdGVkIHVzaW5nIGBuZXcgUmVhY3RFbGVtZW50YCBkaXJlY3RseSBvciB3aXRoXG4gICAgLy8gYFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50YDsgc2tpcCBtdXRhdGlvbiBjaGVja2luZ1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbFByb3BzID0gZWxlbWVudC5fc3RvcmUub3JpZ2luYWxQcm9wcztcbiAgdmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGlmICghb3JpZ2luYWxQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgfHwgIWlzKG9yaWdpbmFsUHJvcHNbcHJvcE5hbWVdLCBwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHdhcm5Gb3JQcm9wc011dGF0aW9uKHByb3BOYW1lLCBlbGVtZW50KTtcblxuICAgICAgICAvLyBDb3B5IG92ZXIgdGhlIG5ldyB2YWx1ZSBzbyB0aGF0IHRoZSB0d28gcHJvcHMgb2JqZWN0cyBtYXRjaCBhZ2FpblxuICAgICAgICBvcmlnaW5hbFByb3BzW3Byb3BOYW1lXSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICBpZiAoISh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nKSkge1xuICAgIC8vIFRoaXMgaGFzIGFscmVhZHkgd2FybmVkLiBEb24ndCB0aHJvdy5cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRXh0cmFjdCB0aGUgY29tcG9uZW50IGNsYXNzIGZyb20gdGhlIGVsZW1lbnQuIENvbnZlcnRzIHN0cmluZyB0eXBlc1xuICAvLyB0byBhIGNvbXBvc2l0ZSBjbGFzcyB3aGljaCBtYXkgaGF2ZSBwcm9wVHlwZXMuXG4gIC8vIFRPRE86IFZhbGlkYXRpbmcgYSBzdHJpbmcncyBwcm9wVHlwZXMgaXMgbm90IGRlY291cGxlZCBmcm9tIHRoZVxuICAvLyByZW5kZXJpbmcgdGFyZ2V0IHdoaWNoIGlzIHByb2JsZW1hdGljLlxuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudC5nZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgaWYgKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcykge1xuICAgIGNoZWNrUHJvcFR5cGVzKG5hbWUsIGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNoZWNrQW5kV2FybkZvck11dGF0ZWRQcm9wczogY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFByb3BzLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBzaG91bGQgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgYm9vbGVhbiwgb3IgJyArICdudW1iZXIuIEl0IHNob3VsZCBiZSBhIHN0cmluZyAoZm9yIERPTSBlbGVtZW50cykgb3IgYSBSZWFjdENsYXNzICcgKyAnKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG4vLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHkgKGVzNS1zaGltL3NoYW0gdG9vKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlTWFwXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgY29tcG9uZW50O1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB0aGUgUmVhY3QgSURzIG9mIHRoZSBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgdG9cbi8vIGBudWxsYCAoaW4gcmVhbGl0eSBhIHBsYWNlaG9sZGVyIHN1Y2ggYXMgYG5vc2NyaXB0YClcbnZhciBudWxsQ29tcG9uZW50SURzUmVnaXN0cnkgPSB7fTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEVtcHR5Q29tcG9uZW50OiBmdW5jdGlvbiAoZW1wdHlDb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeShlbXB0eUNvbXBvbmVudCk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50VHlwZSA9IGZ1bmN0aW9uICgpIHt9O1xuUmVhY3RFbXB0eUNvbXBvbmVudFR5cGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpO1xuICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgcnVuIHRoZXNlIG1ldGhvZHMgaW4gdGhlIGNvcnJlY3Qgb3JkZXIsIHdlIHNob3VsZG4ndFxuICAvLyBuZWVkIHRoaXMgY2hlY2suIFdlJ3JlIGdvaW5nIHRvIGFzc3VtZSBpZiB3ZSdyZSBoZXJlIGl0IG1lYW5zIHdlIHJhblxuICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBhbHJlYWR5IHNvIHRoZXJlIGlzIG5vIGludGVybmFsIGluc3RhbmNlIChpdCBnZXRzXG4gIC8vIHJlbW92ZWQgYXMgcGFydCBvZiB0aGUgdW5tb3VudGluZyBwcm9jZXNzKS5cbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGludGVybmFsSW5zdGFuY2UuX3Jvb3ROb2RlSUQpO1xufTtcblJlYWN0RW1wdHlDb21wb25lbnRUeXBlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKTtcbiAgLy8gVE9ETzogR2V0IHJpZCBvZiB0aGlzIGNoZWNrLiBTZWUgVE9ETyBpbiBjb21wb25lbnREaWRNb3VudC5cbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaW50ZXJuYWxJbnN0YW5jZS5fcm9vdE5vZGVJRCk7XG59O1xuUmVhY3RFbXB0eUNvbXBvbmVudFR5cGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgIWNvbXBvbmVudCA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmV0dXJuIG51bGwgZnJvbSBhIHJlbmRlciwgYnV0IG5vIG51bGwgcGxhY2Vob2xkZXIgY29tcG9uZW50ICcgKyAnd2FzIGluamVjdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNvbXBvbmVudCgpO1xufTtcblxudmFyIGVtcHR5RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50KFJlYWN0RW1wdHlDb21wb25lbnRUeXBlKTtcblxuLyoqXG4gKiBNYXJrIHRoZSBjb21wb25lbnQgYXMgaGF2aW5nIHJlbmRlcmVkIHRvIG51bGwuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5W2lkXSA9IHRydWU7XG59XG5cbi8qKlxuICogVW5tYXJrIHRoZSBjb21wb25lbnQgYXMgaGF2aW5nIHJlbmRlcmVkIHRvIG51bGw6IGl0IHJlbmRlcnMgdG8gc29tZXRoaW5nIG5vdy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICovXG5mdW5jdGlvbiBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIGRlbGV0ZSBudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIHRvIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIHJldHVybiAhIW51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF07XG59XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0ge1xuICBlbXB0eUVsZW1lbnQ6IGVtcHR5RWxlbWVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uLFxuICBpc051bGxDb21wb25lbnRJRDogaXNOdWxsQ29tcG9uZW50SURcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFcnJvclV0aWxzXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGd1YXJkZWQgdmVyc2lvbiBvZiBhIGZ1bmN0aW9uLiBUaGlzIGlzIHN1cHBvc2VkIHRvIG1ha2UgZGVidWdnaW5nXG4gICAqIG9mIGV2ZW50IGhhbmRsZXJzIGVhc2llci4gVG8gYWlkIGRlYnVnZ2luZyB3aXRoIHRoZSBicm93c2VyJ3MgZGVidWdnZXIsXG4gICAqIHRoaXMgY3VycmVudGx5IHNpbXBseSByZXR1cm5zIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZ3VhcmRcbiAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAqL1xuICBndWFyZDogZnVuY3Rpb24gKGZ1bmMsIG5hbWUpIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVycm9yVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZSgpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGVudmlyb25tZW50IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50KTtcblxuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9FdmVudExpc3RlbmVyXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKFwiLi9nZXRFdmVudFRhcmdldFwiKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoXCIuL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uXCIpO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBwYXJlbnQgUmVhY3QgY29tcG9uZW50IG9mIGBub2RlYC5cbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FdmVudFRhcmdldH0gUGFyZW50IGNvbnRhaW5lciwgb3IgYG51bGxgIGlmIHRoZSBzcGVjaWZpZWQgbm9kZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBub3QgbmVzdGVkLlxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50KG5vZGUpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgdmFyIG5vZGVJRCA9IFJlYWN0TW91bnQuZ2V0SUQobm9kZSk7XG4gIHZhciByb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQobm9kZUlEKTtcbiAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQocm9vdElEKTtcbiAgdmFyIHBhcmVudCA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTShjb250YWluZXIpO1xuICByZXR1cm4gcGFyZW50O1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHRoaXMuYW5jZXN0b3JzID0gW107XG59XG5hc3NpZ24oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIH1cbn0pO1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZywgUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRvcExldmVsVGFyZ2V0ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSkgfHwgd2luZG93O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0b3BMZXZlbFRhcmdldDtcbiAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRvcExldmVsVGFyZ2V0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIHZhciB0b3BMZXZlbFRhcmdldElEID0gUmVhY3RNb3VudC5nZXRJRCh0b3BMZXZlbFRhcmdldCkgfHwgJyc7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBib29rS2VlcGluZy5uYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVNb25pdG9yKGNiKSB7XG4gIHZhciBzY3JvbGxQb3NpdGlvbiA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHdpbmRvdyk7XG4gIGNiKHNjcm9sbFBvc2l0aW9uKTtcbn1cblxudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHtcbiAgX2VuYWJsZWQ6IHRydWUsXG4gIF9oYW5kbGVUb3BMZXZlbDogbnVsbCxcblxuICBXSU5ET1dfSEFORExFOiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyB3aW5kb3cgOiBudWxsLFxuXG4gIHNldEhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0sXG5cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RnJhZ21lbnRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vKipcbiAqIFdlIHVzZWQgdG8gYWxsb3cga2V5ZWQgb2JqZWN0cyB0byBzZXJ2ZSBhcyBhIGNvbGxlY3Rpb24gb2YgUmVhY3RFbGVtZW50cyxcbiAqIG9yIG5lc3RlZCBzZXRzLiBUaGlzIGFsbG93ZWQgdXMgYSB3YXkgdG8gZXhwbGljaXRseSBrZXkgYSBzZXQgYSBmcmFnbWVudCBvZlxuICogY29tcG9uZW50cy4gVGhpcyBpcyBub3cgYmVpbmcgcmVwbGFjZWQgd2l0aCBhbiBvcGFxdWUgZGF0YSBzdHJ1Y3R1cmUuXG4gKiBUaGUgdXBncmFkZSBwYXRoIGlzIHRvIGNhbGwgUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50KHsga2V5OiB2YWx1ZSB9KSB0b1xuICogY3JlYXRlIGEga2V5ZWQgZnJhZ21lbnQuIFRoZSByZXN1bHRpbmcgZGF0YSBzdHJ1Y3R1cmUgaXMgb3BhcXVlLCBmb3Igbm93LlxuICovXG5cbmlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHZhciBmcmFnbWVudEtleSA9ICdfcmVhY3RGcmFnbWVudCc7XG4gIHZhciBkaWRXYXJuS2V5ID0gJ19yZWFjdERpZFdhcm4nO1xuICB2YXIgY2FuV2FybkZvclJlYWN0RnJhZ21lbnQgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIC8vIEZlYXR1cmUgdGVzdC4gRG9uJ3QgZXZlbiB0cnkgdG8gaXNzdWUgdGhpcyB3YXJuaW5nIGlmIHdlIGNhbid0IHVzZVxuICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLlxuXG4gICAgdmFyIGR1bW15ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgZnJhZ21lbnRLZXksIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiB0cnVlIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAna2V5JywgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGR1bW15IH0pO1xuXG4gICAgY2FuV2FybkZvclJlYWN0RnJhZ21lbnQgPSB0cnVlO1xuICB9IGNhdGNoICh4KSB7fVxuXG4gIHZhciBwcm94eVByb3BlcnR5QWNjZXNzV2l0aFdhcm5pbmcgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcodGhpc1tkaWRXYXJuS2V5XSwgJ0EgUmVhY3RGcmFnbWVudCBpcyBhbiBvcGFxdWUgdHlwZS4gQWNjZXNzaW5nIGFueSBvZiBpdHMgJyArICdwcm9wZXJ0aWVzIGlzIGRlcHJlY2F0ZWQuIFBhc3MgaXQgdG8gb25lIG9mIHRoZSBSZWFjdC5DaGlsZHJlbiAnICsgJ2hlbHBlcnMuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbZGlkV2FybktleV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpc1tmcmFnbWVudEtleV1ba2V5XTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyh0aGlzW2RpZFdhcm5LZXldLCAnQSBSZWFjdEZyYWdtZW50IGlzIGFuIGltbXV0YWJsZSBvcGFxdWUgdHlwZS4gTXV0YXRpbmcgaXRzICcgKyAncHJvcGVydGllcyBpcyBkZXByZWNhdGVkLicpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzW2RpZFdhcm5LZXldID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tmcmFnbWVudEtleV1ba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBpc3N1ZWRXYXJuaW5ncyA9IHt9O1xuXG4gIHZhciBkaWRXYXJuRm9yRnJhZ21lbnQgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAvLyBXZSB1c2UgdGhlIGtleXMgYW5kIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBhcyBhIGhldXJpc3RpYyB0byBkZWR1cGUgdGhlXG4gICAgLy8gd2FybmluZyB0byBhdm9pZCBzcGFtbWluZyB0b28gbXVjaC5cbiAgICB2YXIgZnJhZ21lbnRDYWNoZUtleSA9ICcnO1xuICAgIGZvciAodmFyIGtleSBpbiBmcmFnbWVudCkge1xuICAgICAgZnJhZ21lbnRDYWNoZUtleSArPSBrZXkgKyAnOicgKyB0eXBlb2YgZnJhZ21lbnRba2V5XSArICcsJztcbiAgICB9XG4gICAgdmFyIGFscmVhZHlXYXJuZWRPbmNlID0gISFpc3N1ZWRXYXJuaW5nc1tmcmFnbWVudENhY2hlS2V5XTtcbiAgICBpc3N1ZWRXYXJuaW5nc1tmcmFnbWVudENhY2hlS2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIGFscmVhZHlXYXJuZWRPbmNlO1xuICB9O1xufVxuXG52YXIgUmVhY3RGcmFnbWVudCA9IHtcbiAgLy8gV3JhcCBhIGtleWVkIG9iamVjdCBpbiBhbiBvcGFxdWUgcHJveHkgdGhhdCB3YXJucyB5b3UgaWYgeW91IGFjY2VzcyBhbnlcbiAgLy8gb2YgaXRzIHByb3BlcnRpZXMuXG4gIGNyZWF0ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcgfHwgIW9iamVjdCB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5hZGRvbnMuY3JlYXRlRnJhZ21lbnQgb25seSBhY2NlcHRzIGEgc2luZ2xlIG9iamVjdC4nLCBvYmplY3QpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChvYmplY3QpKSB7XG4gICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50IGRvZXMgbm90IGFjY2VwdCBhIFJlYWN0RWxlbWVudCAnICsgJ3dpdGhvdXQgYSB3cmFwcGVyIG9iamVjdC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5XYXJuRm9yUmVhY3RGcmFnbWVudCkge1xuICAgICAgICB2YXIgcHJveHkgPSB7fTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBmcmFnbWVudEtleSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBvYmplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgZGlkV2FybktleSwge1xuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIHByb3h5UHJvcGVydHlBY2Nlc3NXaXRoV2FybmluZyhwcm94eSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMocHJveHkpO1xuICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG4gIC8vIEV4dHJhY3QgdGhlIG9yaWdpbmFsIGtleWVkIG9iamVjdCBmcm9tIHRoZSBmcmFnbWVudCBvcGFxdWUgdHlwZS4gV2FybiBpZlxuICAvLyBhIHBsYWluIG9iamVjdCBpcyBwYXNzZWQgaGVyZS5cbiAgZXh0cmFjdDogZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGlmIChjYW5XYXJuRm9yUmVhY3RGcmFnbWVudCkge1xuICAgICAgICBpZiAoIWZyYWdtZW50W2ZyYWdtZW50S2V5XSkge1xuICAgICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGRpZFdhcm5Gb3JGcmFnbWVudChmcmFnbWVudCksICdBbnkgdXNlIG9mIGEga2V5ZWQgb2JqZWN0IHNob3VsZCBiZSB3cmFwcGVkIGluICcgKyAnUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50KG9iamVjdCkgYmVmb3JlIGJlaW5nIHBhc3NlZCBhcyBhICcgKyAnY2hpbGQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnbWVudFtmcmFnbWVudEtleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSxcbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGZyYWdtZW50IGFuZCBpZiBzbywgZXh0cmFjdCB0aGUga2V5ZWQgb2JqZWN0LiBJZiBpdFxuICAvLyBpcyBhIGZyYWdtZW50LWxpa2Ugb2JqZWN0LCB3YXJuIHRoYXQgaXQgc2hvdWxkIGJlIHdyYXBwZWQuIElnbm9yZSBpZiB3ZVxuICAvLyBjYW4ndCBkZXRlcm1pbmUgd2hhdCBraW5kIG9mIG9iamVjdCB0aGlzIGlzLlxuICBleHRyYWN0SWZGcmFnbWVudDogZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGlmIChjYW5XYXJuRm9yUmVhY3RGcmFnbWVudCkge1xuICAgICAgICAvLyBJZiBpdCBpcyB0aGUgb3BhcXVlIHR5cGUsIHJldHVybiB0aGUga2V5ZWQgb2JqZWN0LlxuICAgICAgICBpZiAoZnJhZ21lbnRbZnJhZ21lbnRLZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50W2ZyYWdtZW50S2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGVhY2ggcHJvcGVydHkgaWYgaXQgaGFzIGFuIGVsZW1lbnQsIGlmIGl0IGRvZXNcbiAgICAgICAgLy8gaXQgaXMgcHJvYmFibHkgbWVhbnQgYXMgYSBmcmFnbWVudCwgc28gd2UgY2FuIHdhcm4gZWFybHkuIERlZmVyLFxuICAgICAgICAvLyB0aGUgd2FybmluZyB0byBleHRyYWN0LlxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZnJhZ21lbnQpIHtcbiAgICAgICAgICBpZiAoZnJhZ21lbnQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZnJhZ21lbnRba2V5XSkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhIGZyYWdtZW50IG9iamVjdCwgd2Ugc2hvdWxkIHByb3ZpZGUgYW5cbiAgICAgICAgICAgIC8vIGVhcmx5IHdhcm5pbmcuXG4gICAgICAgICAgICByZXR1cm4gUmVhY3RGcmFnbWVudC5leHRyYWN0KGZyYWdtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RnJhZ21lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50XCIpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKFwiLi9SZWFjdENsYXNzXCIpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVtcHR5Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0TmF0aXZlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RET01Db21wb25lbnRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xudmFyIFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZShcIi4vUmVhY3RSb290SW5kZXhcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIENsYXNzOiBSZWFjdENsYXNzLmluamVjdGlvbixcbiAgRE9NQ29tcG9uZW50OiBSZWFjdERPTUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBOYXRpdmVDb21wb25lbnQ6IFJlYWN0TmF0aXZlQ29tcG9uZW50LmluamVjdGlvbixcbiAgUGVyZjogUmVhY3RQZXJmLmluamVjdGlvbixcbiAgUm9vdEluZGV4OiBSZWFjdFJvb3RJbmRleC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5wdXRTZWxlY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NU2VsZWN0aW9uXCIpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZShcIi4vY29udGFpbnNOb2RlXCIpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoXCIuL2ZvY3VzTm9kZVwiKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZShcIi4vZ2V0QWN0aXZlRWxlbWVudFwiKTtcblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG5cbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHJldHVybiBlbGVtICYmIChlbGVtLm5vZGVOYW1lID09PSAnSU5QVVQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IGVsZW0ubm9kZU5hbWUgPT09ICdURVhUQVJFQScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gICAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAgICovXG4gIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uIChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgaWYgKFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgfVxuICAgICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gICAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICAgKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICAgKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAgICovXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHNlbGVjdGlvbjtcblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlSGFuZGxlc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL1JlYWN0Um9vdEluZGV4XCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNFUEFSQVRPUl9MRU5HVEggPSBTRVBBUkFUT1IubGVuZ3RoO1xuXG4vKipcbiAqIE1heGltdW0gZGVwdGggb2YgdHJhdmVyc2FscyBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIHBvc3NpYmlsaXR5IG9mIGEgYmFkIElELlxuICovXG52YXIgTUFYX1RSRUVfREVQVEggPSAxMDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIERPTSBJRCBwcmVmaXggdG8gdXNlIHdoZW4gbW91bnRpbmcgUmVhY3QgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQSB1bmlxdWUgaW50ZWdlclxuICogQHJldHVybiB7c3RyaW5nfSBSZWFjdCByb290IElELlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEU3RyaW5nKGluZGV4KSB7XG4gIHJldHVybiBTRVBBUkFUT1IgKyBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2hhcmFjdGVyIGluIHRoZSBzdXBwbGllZCBJRCBpcyBhIHNlcGFyYXRvciBvciB0aGUgZW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yIG9yIGVuZCBvZiB0aGUgSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0JvdW5kYXJ5KGlkLCBpbmRleCkge1xuICByZXR1cm4gaWQuY2hhckF0KGluZGV4KSA9PT0gU0VQQVJBVE9SIHx8IGluZGV4ID09PSBpZC5sZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdXBwbGllZCBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELCBtYXliZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRJRChpZCkge1xuICByZXR1cm4gaWQgPT09ICcnIHx8IGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmNoYXJBdChpZC5sZW5ndGggLSAxKSAhPT0gU0VQQVJBVE9SO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZmlyc3QgSUQgaXMgYW4gYW5jZXN0b3Igb2Ygb3IgZXF1YWwgdG8gdGhlIHNlY29uZCBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRFxuICogQHBhcmFtIHtzdHJpbmd9IGRlc2NlbmRhbnRJRFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgYW5jZXN0b3JJRGAgaXMgYW4gYW5jZXN0b3Igb2YgYGRlc2NlbmRhbnRJRGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzY2VuZGFudElEKSB7XG4gIHJldHVybiBkZXNjZW5kYW50SUQuaW5kZXhPZihhbmNlc3RvcklEKSA9PT0gMCAmJiBpc0JvdW5kYXJ5KGRlc2NlbmRhbnRJRCwgYW5jZXN0b3JJRC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBJRCBvZiB0aGUgc3VwcGxpZWQgUmVhY3QgRE9NIElELCBgaWRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIGNvbXBvbmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIHBhcmVudCwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SUQoaWQpIHtcbiAgcmV0dXJuIGlkID8gaWQuc3Vic3RyKDAsIGlkLmxhc3RJbmRleE9mKFNFUEFSQVRPUikpIDogJyc7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmV4dCBET00gSUQgb24gdGhlIHRyZWUgcGF0aCBmcm9tIHRoZSBzdXBwbGllZCBgYW5jZXN0b3JJRGAgdG8gdGhlXG4gKiBzdXBwbGllZCBgZGVzdGluYXRpb25JRGAuIElmIHRoZXkgYXJlIGVxdWFsLCB0aGUgSUQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFuY2VzdG9ySUQgSUQgb2YgYW4gYW5jZXN0b3Igbm9kZSBvZiBgZGVzdGluYXRpb25JRGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25JRCBJRCBvZiB0aGUgZGVzdGluYXRpb24gbm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gTmV4dCBJRCBvbiB0aGUgcGF0aCBmcm9tIGBhbmNlc3RvcklEYCB0byBgZGVzdGluYXRpb25JRGAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXROZXh0RGVzY2VuZGFudElEKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIHtcbiAgIShpc1ZhbGlkSUQoYW5jZXN0b3JJRCkgJiYgaXNWYWxpZElEKGRlc3RpbmF0aW9uSUQpKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROZXh0RGVzY2VuZGFudElEKCVzLCAlcyk6IFJlY2VpdmVkIGFuIGludmFsaWQgUmVhY3QgRE9NIElELicsIGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgIWlzQW5jZXN0b3JJRE9mKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2dldE5leHREZXNjZW5kYW50SUQoLi4uKTogUmVhY3QgaGFzIG1hZGUgYW4gaW52YWxpZCBhc3N1bXB0aW9uIGFib3V0ICcgKyAndGhlIERPTSBoaWVyYXJjaHkuIEV4cGVjdGVkIGAlc2AgdG8gYmUgYW4gYW5jZXN0b3Igb2YgYCVzYC4nLCBhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChhbmNlc3RvcklEID09PSBkZXN0aW5hdGlvbklEKSB7XG4gICAgcmV0dXJuIGFuY2VzdG9ySUQ7XG4gIH1cbiAgLy8gU2tpcCBvdmVyIHRoZSBhbmNlc3RvciBhbmQgdGhlIGltbWVkaWF0ZSBzZXBhcmF0b3IuIFRyYXZlcnNlIHVudGlsIHdlIGhpdFxuICAvLyBhbm90aGVyIHNlcGFyYXRvciBvciB3ZSByZWFjaCB0aGUgZW5kIG9mIGBkZXN0aW5hdGlvbklEYC5cbiAgdmFyIHN0YXJ0ID0gYW5jZXN0b3JJRC5sZW5ndGggKyBTRVBBUkFUT1JfTEVOR1RIO1xuICB2YXIgaTtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBkZXN0aW5hdGlvbklELmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkoZGVzdGluYXRpb25JRCwgaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb25JRC5zdWJzdHIoMCwgaSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQgb2YgdHdvIElEcy5cbiAqXG4gKiBVc2luZyB0aGlzIElEIHNjaGVtZSwgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIGlzIHRoZSBsb25nZXN0IGNvbW1vblxuICogcHJlZml4IG9mIHRoZSB0d28gSURzIHRoYXQgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYSBcIm1hcmtlclwiIGluIGJvdGggc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb25lSURcbiAqIEBwYXJhbSB7c3RyaW5nfSB0d29JRFxuICogQHJldHVybiB7c3RyaW5nfSBOZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCwgb3IgdGhlIGVtcHR5IHN0cmluZyBpZiBub25lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKG9uZUlELCB0d29JRCkge1xuICB2YXIgbWluTGVuZ3RoID0gTWF0aC5taW4ob25lSUQubGVuZ3RoLCB0d29JRC5sZW5ndGgpO1xuICBpZiAobWluTGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBsYXN0Q29tbW9uTWFya2VySW5kZXggPSAwO1xuICAvLyBVc2UgYDw9YCB0byB0cmF2ZXJzZSB1bnRpbCB0aGUgXCJFT0xcIiBvZiB0aGUgc2hvcnRlciBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkob25lSUQsIGkpICYmIGlzQm91bmRhcnkodHdvSUQsIGkpKSB7XG4gICAgICBsYXN0Q29tbW9uTWFya2VySW5kZXggPSBpO1xuICAgIH0gZWxzZSBpZiAob25lSUQuY2hhckF0KGkpICE9PSB0d29JRC5jaGFyQXQoaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgbG9uZ2VzdENvbW1vbklEID0gb25lSUQuc3Vic3RyKDAsIGxhc3RDb21tb25NYXJrZXJJbmRleCk7XG4gICFpc1ZhbGlkSUQobG9uZ2VzdENvbW1vbklEKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQoJXMsICVzKTogRXhwZWN0ZWQgYSB2YWxpZCBSZWFjdCBET00gSUQ6ICVzJywgb25lSUQsIHR3b0lELCBsb25nZXN0Q29tbW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGxvbmdlc3RDb21tb25JRDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIHBhcmVudCBwYXRoIGJldHdlZW4gdHdvIElEcyAoZWl0aGVyIHVwIG9yIGRvd24pLiBUaGUgSURzIG11c3RcbiAqIG5vdCBiZSB0aGUgc2FtZSwgYW5kIHRoZXJlIG11c3QgZXhpc3QgYSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHRoZW0uIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLCB0cmF2ZXJzYWwgaXMgc3RvcHBlZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0YXJ0IElEIGF0IHdoaWNoIHRvIHN0YXJ0IHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RvcCBJRCBhdCB3aGljaCB0byBlbmQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIGVhY2ggSUQgd2l0aC5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBGaXJzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBmaXJzdCBub2RlLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcExhc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgbGFzdCBub2RlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnRQYXRoKHN0YXJ0LCBzdG9wLCBjYiwgYXJnLCBza2lwRmlyc3QsIHNraXBMYXN0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgJyc7XG4gIHN0b3AgPSBzdG9wIHx8ICcnO1xuICAhKHN0YXJ0ICE9PSBzdG9wKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gYW5kIHRvIHRoZSBzYW1lIElELCBgJXNgLicsIHN0YXJ0KSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciB0cmF2ZXJzZVVwID0gaXNBbmNlc3RvcklET2Yoc3RvcCwgc3RhcnQpO1xuICAhKHRyYXZlcnNlVXAgfHwgaXNBbmNlc3RvcklET2Yoc3RhcnQsIHN0b3ApKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSB0d28gSURzIHRoYXQgZG8gJyArICdub3QgaGF2ZSBhIHBhcmVudCBwYXRoLicsIHN0YXJ0LCBzdG9wKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIC8vIFRyYXZlcnNlIGZyb20gYHN0YXJ0YCB0byBgc3RvcGAgb25lIGRlcHRoIGF0IGEgdGltZS5cbiAgdmFyIGRlcHRoID0gMDtcbiAgdmFyIHRyYXZlcnNlID0gdHJhdmVyc2VVcCA/IGdldFBhcmVudElEIDogZ2V0TmV4dERlc2NlbmRhbnRJRDtcbiAgZm9yICh2YXIgaWQgPSBzdGFydDs7IGlkID0gdHJhdmVyc2UoaWQsIHN0b3ApKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoKCFza2lwRmlyc3QgfHwgaWQgIT09IHN0YXJ0KSAmJiAoIXNraXBMYXN0IHx8IGlkICE9PSBzdG9wKSkge1xuICAgICAgcmV0ID0gY2IoaWQsIHRyYXZlcnNlVXAsIGFyZyk7XG4gICAgfVxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IGlkID09PSBzdG9wKSB7XG4gICAgICAvLyBPbmx5IGJyZWFrIC8vYWZ0ZXIvLyB2aXNpdGluZyBgc3RvcGAuXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgIShkZXB0aCsrIDwgTUFYX1RSRUVfREVQVEgpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3RyYXZlcnNlUGFyZW50UGF0aCglcywgJXMsIC4uLik6IERldGVjdGVkIGFuIGluZmluaXRlIGxvb3Agd2hpbGUgJyArICd0cmF2ZXJzaW5nIHRoZSBSZWFjdCBET00gSUQgdHJlZS4gVGhpcyBtYXkgYmUgZHVlIHRvIG1hbGZvcm1lZCBJRHM6ICVzJywgc3RhcnQsIHN0b3ApIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIElEcyBhc3NpZ25lZCB0byBET00gcmVwcmVzZW50YXRpb25zIG9mIFJlYWN0IGNvbXBvbmVudHMuIFRoaXNcbiAqIHVzZXMgYSBzcGVjaWZpYyBzY2hlbWUgaW4gb3JkZXIgdG8gdHJhdmVyc2UgdGhlIERPTSBlZmZpY2llbnRseSAoZS5nLiBpblxuICogb3JkZXIgdG8gc2ltdWxhdGUgZXZlbnRzKS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3Qgcm9vdCBJRFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVhY3Qgcm9vdCBJRC5cbiAgICovXG4gIGNyZWF0ZVJlYWN0Um9vdElEOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlYWN0Um9vdElEU3RyaW5nKFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4KCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3QgSUQgYnkgam9pbmluZyBhIHJvb3QgSUQgd2l0aCBhIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgUm9vdCBJRCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgY29tcG9uZW50J3MgbmFtZSAoYXMgZmxhdHRlbmVkIGNoaWxkcmVuKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IElELlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZVJlYWN0SUQ6IGZ1bmN0aW9uIChyb290SUQsIG5hbWUpIHtcbiAgICByZXR1cm4gcm9vdElEICsgbmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoZSBSZWFjdCBjb21wb25lbnQgd2l0aCB0aGUgc3VwcGxpZWQgRE9NIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgRE9NIElEIG9mIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFJlYWN0Um9vdElERnJvbU5vZGVJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKGlkICYmIGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoU0VQQVJBVE9SLCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaWQuc3Vic3RyKDAsIGluZGV4KSA6IGlkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gICAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAgICpcbiAgICogTk9URTogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZVxuICAgKiBub3RoaW5nIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYXZlSUQgSUQgYmVpbmcgbGVmdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudGVySUQgSUQgYmVpbmcgZW50ZXJlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVhY2ggZW50ZXJlZC9sZWZ0IElELlxuICAgKiBAcGFyYW0geyp9IHVwQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBsZWZ0IElEcy5cbiAgICogQHBhcmFtIHsqfSBkb3duQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBlbnRlcmVkIElEcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUVudGVyTGVhdmU6IGZ1bmN0aW9uIChsZWF2ZUlELCBlbnRlcklELCBjYiwgdXBBcmcsIGRvd25BcmcpIHtcbiAgICB2YXIgYW5jZXN0b3JJRCA9IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChsZWF2ZUlELCBlbnRlcklEKTtcbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gbGVhdmVJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGxlYXZlSUQsIGFuY2VzdG9ySUQsIGNiLCB1cEFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gZW50ZXJJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGFuY2VzdG9ySUQsIGVudGVySUQsIGNiLCBkb3duQXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGB0cmF2ZXJzZVR3b1BoYXNlYCBidXQgc2tpcHMgdGhlIGB0YXJnZXRJRGAuXG4gICAqL1xuICB0cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldDogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2UgYSBub2RlIElELCBjYWxsaW5nIHRoZSBzdXBwbGllZCBgY2JgIGZvciBlYWNoIGFuY2VzdG9yIElELiBGb3JcbiAgICogZXhhbXBsZSwgcGFzc2luZyBgLjAuJHJvdy0wLjFgIHdvdWxkIHJlc3VsdCBpbiBgY2JgIGdldHRpbmcgY2FsbGVkXG4gICAqIHdpdGggYC4wYCwgYC4wLiRyb3ctMGAsIGFuZCBgLjAuJHJvdy0wLjFgLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gIH0sXG5cbiAgZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEOiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXh0RGVzY2VuZGFudElEOiBnZXROZXh0RGVzY2VuZGFudElELFxuXG4gIGlzQW5jZXN0b3JJRE9mOiBpc0FuY2VzdG9ySURPZixcblxuICBTRVBBUkFUT1I6IFNFUEFSQVRPUlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzO1xuLyogdW50aWwgYnJlYWsgKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZU1hcFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqL1xuXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBFUzY6IHZhciBSZWFjdEluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gICAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gICAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHZhbHVlO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZU1hcDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJc29tb3JwaGljXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL1JlYWN0Q2hpbGRyZW5cIik7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3JcIik7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgb25seUNoaWxkID0gcmVxdWlyZShcIi4vb25seUNoaWxkXCIpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcbiAgaXNWYWxpZEVsZW1lbnQ6IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCxcblxuICAvLyBDbGFzc2ljXG5cbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3MsXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnksXG4gIGNyZWF0ZU1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAvLyBDdXJyZW50bHkgYSBub29wLiBXaWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgYW5kIHRyYWNlIG1peGlucy5cbiAgICByZXR1cm4gbWl4aW47XG4gIH0sXG5cbiAgLy8gVGhpcyBsb29rcyBET00gc3BlY2lmaWMgYnV0IHRoZXNlIGFyZSBhY3R1YWxseSBpc29tb3JwaGljIGhlbHBlcnNcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxuICBET006IFJlYWN0RE9NLFxuXG4gIC8vIEhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZyBlbHNlLlxuICBfX3NwcmVhZDogYXNzaWduXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RMaWZlQ3ljbGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhpcyBtb2R1bGUgbWFuYWdlcyB0aGUgYm9va2tlZXBpbmcgd2hlbiBhIGNvbXBvbmVudCBpcyBpbiB0aGUgcHJvY2Vzc1xuICogb2YgYmVpbmcgbW91bnRlZCBvciBiZWluZyB1bm1vdW50ZWQuIFRoaXMgaXMgdXNlZCBhcyBhIHdheSB0byBlbmZvcmNlXG4gKiBpbnZhcmlhbnRzIChvciB3YXJuaW5ncykgd2hlbiBpdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gY2FsbFxuICogc2V0U3RhdGUvZm9yY2VVcGRhdGUuXG4gKlxuICogY3VycmVudGx5TW91bnRpbmdJbnN0YW5jZTogRHVyaW5nIHRoZSBjb25zdHJ1Y3Rpb24gcGhhc2UsIGl0IGlzIG5vdCBwb3NzaWJsZVxuICogdG8gdHJpZ2dlciBhbiB1cGRhdGUgc2luY2UgdGhlIGluc3RhbmNlIGlzIG5vdCBmdWxseSBtb3VudGVkIHlldC4gSG93ZXZlciwgd2VcbiAqIGN1cnJlbnRseSBhbGxvdyB0aGlzIGFzIGEgY29udmVuaWVuY2UgZm9yIG11dGF0aW5nIHRoZSBpbml0aWFsIHN0YXRlLlxuICpcbiAqIGN1cnJlbnRseVVubW91bnRpbmdJbnN0YW5jZTogRHVyaW5nIHRoZSB1bm1vdW50aW5nIHBoYXNlLCB0aGUgaW5zdGFuY2UgaXNcbiAqIHN0aWxsIG1vdW50ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc2NoZWR1bGUgYW4gdXBkYXRlLiBIb3dldmVyLCB0aGlzIGlzIG5vdFxuICogcmVjb21tZW5kZWQgYW5kIHByb2JhYmx5IGFuIGVycm9yIHNpbmNlIGl0J3MgYWJvdXQgdG8gYmUgdW5tb3VudGVkLlxuICogVGhlcmVmb3JlIHdlIHN0aWxsIHdhbnQgdG8gdHJpZ2dlciBpbiBhbiBlcnJvciBmb3IgdGhhdCBjYXNlLlxuICovXG5cbnZhciBSZWFjdExpZmVDeWNsZSA9IHtcbiAgY3VycmVudGx5TW91bnRpbmdJbnN0YW5jZTogbnVsbCxcbiAgY3VycmVudGx5VW5tb3VudGluZ0luc3RhbmNlOiBudWxsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TGlmZUN5Y2xlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdExpbmtcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlYWN0TGluayBlbmNhcHN1bGF0ZXMgYSBjb21tb24gcGF0dGVybiBpbiB3aGljaCBhIGNvbXBvbmVudCB3YW50cyB0byBtb2RpZnlcbiAqIGEgcHJvcCByZWNlaXZlZCBmcm9tIGl0cyBwYXJlbnQuIFJlYWN0TGluayBhbGxvd3MgdGhlIHBhcmVudCB0byBwYXNzIGRvd24gYVxuICogdmFsdWUgY291cGxlZCB3aXRoIGEgY2FsbGJhY2sgdGhhdCwgd2hlbiBpbnZva2VkLCBleHByZXNzZXMgYW4gaW50ZW50IHRvXG4gKiBtb2RpZnkgdGhhdCB2YWx1ZS4gRm9yIGV4YW1wbGU6XG4gKlxuICogUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICogICAgIHJldHVybiB7dmFsdWU6ICcnfTtcbiAqICAgfSxcbiAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICB2YXIgdmFsdWVMaW5rID0gbmV3IFJlYWN0TGluayh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLl9oYW5kbGVWYWx1ZUNoYW5nZSk7XG4gKiAgICAgcmV0dXJuIDxpbnB1dCB2YWx1ZUxpbms9e3ZhbHVlTGlua30gLz47XG4gKiAgIH0sXG4gKiAgIHRoaXMuX2hhbmRsZVZhbHVlQ2hhbmdlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICogICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiBuZXdWYWx1ZX0pO1xuICogICB9XG4gKiB9KTtcbiAqXG4gKiBXZSBoYXZlIHByb3ZpZGVkIHNvbWUgc3VnYXJ5IG1peGlucyB0byBtYWtlIHRoZSBjcmVhdGlvbiBhbmRcbiAqIGNvbnN1bXB0aW9uIG9mIFJlYWN0TGluayBlYXNpZXI7IHNlZSBMaW5rZWRWYWx1ZVV0aWxzIGFuZCBMaW5rZWRTdGF0ZU1peGluLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgY3VycmVudCB2YWx1ZSBvZiB0aGUgbGlua1xuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVxdWVzdENoYW5nZSBjYWxsYmFjayB0byByZXF1ZXN0IGEgY2hhbmdlXG4gKi9cbmZ1bmN0aW9uIFJlYWN0TGluayh2YWx1ZSwgcmVxdWVzdENoYW5nZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMucmVxdWVzdENoYW5nZSA9IHJlcXVlc3RDaGFuZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3BUeXBlIHRoYXQgZW5mb3JjZXMgdGhlIFJlYWN0TGluayBBUEkgYW5kIG9wdGlvbmFsbHkgY2hlY2tzIHRoZVxuICogdHlwZSBvZiB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGluc2lkZSB0aGUgbGluay4gRXhhbXBsZTpcbiAqXG4gKiBNeUNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gKiAgIHRhYkluZGV4TGluazogUmVhY3RMaW5rLlByb3BUeXBlcy5saW5rKFJlYWN0LlByb3BUeXBlcy5udW1iZXIpXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtUeXBlQ2hlY2tlcihsaW5rVHlwZSkge1xuICB2YXIgc2hhcGVzID0ge1xuICAgIHZhbHVlOiB0eXBlb2YgbGlua1R5cGUgPT09ICd1bmRlZmluZWQnID8gUmVhY3QuUHJvcFR5cGVzLmFueS5pc1JlcXVpcmVkIDogbGlua1R5cGUuaXNSZXF1aXJlZCxcbiAgICByZXF1ZXN0Q2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH07XG4gIHJldHVybiBSZWFjdC5Qcm9wVHlwZXMuc2hhcGUoc2hhcGVzKTtcbn1cblxuUmVhY3RMaW5rLlByb3BUeXBlcyA9IHtcbiAgbGluazogY3JlYXRlTGlua1R5cGVDaGVja2VyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TGluazsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNYXJrdXBDaGVja3N1bVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKFwiLi9hZGxlcjMyXCIpO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cC5yZXBsYWNlKCc+JywgJyAnICsgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUgKyAnPVwiJyArIGNoZWNrc3VtICsgJ1wiPicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TW91bnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3JcIik7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RW1wdHlDb21wb25lbnRcIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZU1hcFwiKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZShcIi4vUmVhY3RNYXJrdXBDaGVja3N1bVwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZShcIi4vUmVhY3RSZWNvbmNpbGVyXCIpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZVF1ZXVlXCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZShcIi4vZW1wdHlPYmplY3RcIik7XG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZShcIi4vY29udGFpbnNOb2RlXCIpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKFwiLi9zZXRJbm5lckhUTUxcIik7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKFwiLi92YWxpZGF0ZURPTU5lc3RpbmdcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBTRVBBUkFUT1IgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5TRVBBUkFUT1I7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBub2RlQ2FjaGUgPSB7fTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuICovXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG4vKiogTWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIGBjb250YWluZXJgIG5vZGVzLiAqL1xudmFyIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEID0ge307XG5cbmlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIC8qKiBfX0RFVl9fLW9ubHkgbWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIHJvb3QgZWxlbWVudHMuICovXG4gIHZhciByb290RWxlbWVudHNCeVJlYWN0Um9vdElEID0ge307XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYnJlYWR0aC1maXJzdCBzZWFyY2ggc3RhdGUgaW4gZmluZENvbXBvbmVudFJvb3QuXG52YXIgZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5ID0gW107XG5cbi8qKlxuICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgd2hlcmUgdGhlIHN0cmluZ3MgZGl2ZXJnZVxuICovXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XG4gIHZhciBtaW5MZW4gPSBNYXRoLm1pbihzdHJpbmcxLmxlbmd0aCwgc3RyaW5nMi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcxLmxlbmd0aCA9PT0gc3RyaW5nMi5sZW5ndGggPyAtMSA6IG1pbkxlbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW4gYSBSZWFjdCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBBIFwicmVhY3RSb290XCIgSUQsIGlmIGEgUmVhY3QgY29tcG9uZW50IGlzIHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290RWxlbWVudCAmJiBSZWFjdE1vdW50LmdldElEKHJvb3RFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBBY2Nlc3Npbmcgbm9kZVtBVFRSX05BTUVdIG9yIGNhbGxpbmcgZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgb24gYSBmb3JtXG4gKiBlbGVtZW50IGNhbiByZXR1cm4gaXRzIGNvbnRyb2wgd2hvc2UgbmFtZSBvciBJRCBlcXVhbHMgQVRUUl9OQU1FLiBBbGxcbiAqIERPTSBub2RlcyBzdXBwb3J0IGBnZXRBdHRyaWJ1dGVOb2RlYCBidXQgdGhpcyBjYW4gYWxzbyBnZXQgY2FsbGVkIG9uXG4gKiBvdGhlciBvYmplY3RzIHNvIGp1c3QgcmV0dXJuICcnIGlmIHdlJ3JlIGdpdmVuIHNvbWV0aGluZyBvdGhlciB0aGFuIGFcbiAqIERPTSBub2RlIChzdWNoIGFzIHdpbmRvdykuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudHxET01XaW5kb3d8RE9NRG9jdW1lbnR8RE9NVGV4dE5vZGV9IG5vZGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBzdXBwbGllZCBgZG9tTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGdldElEKG5vZGUpIHtcbiAgdmFyIGlkID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKGlkKSB7XG4gICAgaWYgKG5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHZhciBjYWNoZWQgPSBub2RlQ2FjaGVbaWRdO1xuICAgICAgaWYgKGNhY2hlZCAhPT0gbm9kZSkge1xuICAgICAgICAhIWlzVmFsaWQoY2FjaGVkLCBpZCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RNb3VudDogVHdvIHZhbGlkIGJ1dCB1bmVxdWFsIG5vZGVzIHdpdGggdGhlIHNhbWUgYCVzYDogJXMnLCBBVFRSX05BTUUsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIFJlYWN0LXNwZWNpZmljIElEIG9mIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBUaGUgRE9NIG5vZGUgd2hvc2UgSUQgd2lsbCBiZSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHZhbHVlIG9mIHRoZSBJRCBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIHNldElEKG5vZGUsIGlkKSB7XG4gIHZhciBvbGRJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChvbGRJRCAhPT0gaWQpIHtcbiAgICBkZWxldGUgbm9kZUNhY2hlW29sZElEXTtcbiAgfVxuICBub2RlLnNldEF0dHJpYnV0ZShBVFRSX05BTUUsIGlkKTtcbiAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGUoaWQpIHtcbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBwdWJsaWMgUmVhY3QgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHsqfSBpbnN0YW5jZSBBIHB1YmxpYyBSZWFjdCBpbnN0YW5jZS5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGVkIGBpZGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0YW5jZSkuX3Jvb3ROb2RlSUQ7XG4gIGlmIChSZWFjdEVtcHR5Q29tcG9uZW50LmlzTnVsbENvbXBvbmVudElEKGlkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghbm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSB8fCAhaXNWYWxpZChub2RlQ2FjaGVbaWRdLCBpZCkpIHtcbiAgICBub2RlQ2FjaGVbaWRdID0gUmVhY3RNb3VudC5maW5kUmVhY3ROb2RlQnlJRChpZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVDYWNoZVtpZF07XG59XG5cbi8qKlxuICogQSBub2RlIGlzIFwidmFsaWRcIiBpZiBpdCBpcyBjb250YWluZWQgYnkgYSBjdXJyZW50bHkgbW91bnRlZCBjb250YWluZXIuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IHRoZSBub2RlIGRvZXMgbm90IGhhdmUgdG8gYmUgY29udGFpbmVkIGJ5IGEgZG9jdW1lbnQgaW5cbiAqIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBleHBlY3RlZCBJRCBvZiB0aGUgbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5vZGUgaXMgY29udGFpbmVkIGJ5IGEgbW91bnRlZCBjb250YWluZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWQobm9kZSwgaWQpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICAhKGludGVybmFsR2V0SUQobm9kZSkgPT09IGlkKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdE1vdW50OiBVbmV4cGVjdGVkIG1vZGlmaWNhdGlvbiBvZiBgJXNgJywgQVRUUl9OQU1FKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluc05vZGUoY29udGFpbmVyLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENhdXNlcyB0aGUgY2FjaGUgdG8gZm9yZ2V0IGFib3V0IG9uZSBSZWFjdC1zcGVjaWZpYyBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIHRvIGZvcmdldC5cbiAqL1xuZnVuY3Rpb24gcHVyZ2VJRChpZCkge1xuICBkZWxldGUgbm9kZUNhY2hlW2lkXTtcbn1cblxudmFyIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuZnVuY3Rpb24gZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwoYW5jZXN0b3JJRCkge1xuICB2YXIgYW5jZXN0b3IgPSBub2RlQ2FjaGVbYW5jZXN0b3JJRF07XG4gIGlmIChhbmNlc3RvciAmJiBpc1ZhbGlkKGFuY2VzdG9yLCBhbmNlc3RvcklEKSkge1xuICAgIGRlZXBlc3ROb2RlU29GYXIgPSBhbmNlc3RvcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIG5vZGUgaXNuJ3QgcG9wdWxhdGVkIGluIHRoZSBjYWNoZSwgc28gcHJlc3VtYWJseSBub25lIG9mIGl0c1xuICAgIC8vIGRlc2NlbmRhbnRzIGFyZS4gQnJlYWsgb3V0IG9mIHRoZSBsb29wLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZGVlcGVzdCBjYWNoZWQgbm9kZSB3aG9zZSBJRCBpcyBhIHByZWZpeCBvZiBgdGFyZ2V0SURgLlxuICovXG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yKHRhcmdldElEKSB7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICBSZWFjdEluc3RhbmNlSGFuZGxlcy50cmF2ZXJzZUFuY2VzdG9ycyh0YXJnZXRJRCwgZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwpO1xuXG4gIHZhciBmb3VuZE5vZGUgPSBkZWVwZXN0Tm9kZVNvRmFyO1xuICBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbiAgcmV0dXJuIGZvdW5kTm9kZTtcbn1cblxuLyoqXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKGNvbnRleHQgPT09IGVtcHR5T2JqZWN0KSB7XG4gICAgICBjb250ZXh0ID0ge307XG4gICAgfVxuICAgIHZhciB0YWcgPSBjb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHRhZywgbnVsbCk7XG4gIH1cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gIGNvbXBvbmVudEluc3RhbmNlLl9pc1RvcExldmVsID0gdHJ1ZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCk7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgdHJhbnNhY3Rpb24ucGVyZm9ybShtb3VudENvbXBvbmVudEludG9Ob2RlLCBudWxsLCBjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lcikge1xuICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChpbnN0YW5jZSk7XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuICAvKiogRXhwb3NlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzICoqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgcmVuZGVyQ2FsbGJhY2spIHtcbiAgICByZW5kZXJDYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwcmV2Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSBhbHJlYWR5IGluIHRoZSBET01cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFByb3BzKG5leHRFbGVtZW50KTtcbiAgICB9XG5cbiAgICBSZWFjdE1vdW50LnNjcm9sbE1vbml0b3IoY29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcm9vdCBlbGVtZW50IGluIGNhc2UgaXQgbGF0ZXIgZ2V0cyB0cmFuc3BsYW50ZWQuXG4gICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW2dldFJlYWN0Um9vdElEKGNvbnRhaW5lcildID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY29tcG9uZW50IGludG8gdGhlIGluc3RhbmNlIG1hcCBhbmQgc3RhcnRzIHNjcm9sbCB2YWx1ZVxuICAgKiBtb25pdG9yaW5nXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHJldHVybiB7c3RyaW5nfSByZWFjdFJvb3QgSUQgcHJlZml4XG4gICAqL1xuICBfcmVnaXN0ZXJDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0Q29tcG9uZW50LCBjb250YWluZXIpIHtcbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XG5cbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdE1vdW50LnJlZ2lzdGVyQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBuZXh0Q29tcG9uZW50O1xuICAgIHJldHVybiByZWFjdFJvb3RJRDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBlbGVtZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudFxuICAgKi9cbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgKyAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBudWxsKTtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdE1vdW50Ll9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyKTtcblxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXG4gICAgLy8gcmVuZGVyaW5nLCBpbiBjb21wb25lbnRXaWxsTW91bnQgb3IgY29tcG9uZW50RGlkTW91bnQsIHdpbGwgYmUgYmF0Y2hlZFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSwgY29tcG9uZW50SW5zdGFuY2UsIHJlYWN0Um9vdElELCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGFuIGVsZW1lbnQgc3RyaW5nLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY29tcG9uZW50IGNsYXNzLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGNvbnRhaW5lciAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKS5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmIFJlYWN0TW91bnQuaXNSZW5kZXJlZEJ5UmVhY3QocmVhY3RSb290RWxlbWVudCk7XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKFJlYWN0TW91bnQuaXNSZW5kZXJlZEJ5UmVhY3Qocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb290RWxlbWVudFNpYmxpbmcgPSByb290RWxlbWVudFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgcGFyZW50Q29tcG9uZW50ICE9IG51bGwgPyBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZS5fcHJvY2Vzc0NoaWxkQ29udGV4dChwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkgOiBlbXB0eU9iamVjdCkuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgY29tcG9uZW50IGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAgd2l0aCBgaW5pdGlhbFByb3BzYCBhbmRcbiAgICogcmVuZGVycyBpdCBpbnRvIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3IgUmVhY3QgY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByb3BzIEluaXRpYWwgcHJvcHMgb2YgdGhlIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICBjb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnQ6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgcHJvcHMsIGNvbnRhaW5lcikge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQoY29uc3RydWN0b3IsIHByb3BzKTtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5yZW5kZXIoZWxlbWVudCwgY29udGFpbmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGNvbXBvbmVudCBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgIHdpdGggYGluaXRpYWxQcm9wc2AgYW5kXG4gICAqIHJlbmRlcnMgaXQgaW50byBhIGNvbnRhaW5lciBub2RlIGlkZW50aWZpZWQgYnkgc3VwcGxpZWQgYGlkYC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcG9uZW50Q29uc3RydWN0b3IgUmVhY3QgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHMgSW5pdGlhbCBwcm9wcyBvZiB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIHRoZSBjb250YWluZXIgbm9kZS5cbiAgICovXG4gIGNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudEJ5SUQ6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgcHJvcHMsIGlkKSB7XG4gICAgdmFyIGRvbU5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgIWRvbU5vZGUgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnVHJpZWQgdG8gZ2V0IGVsZW1lbnQgd2l0aCBpZCBvZiBcIiVzXCIgYnV0IGl0IGlzIG5vdCBwcmVzZW50IG9uIHRoZSBwYWdlLicsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50KGNvbnN0cnVjdG9yLCBwcm9wcywgZG9tTm9kZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNvbnRhaW5lciBub2RlIGludG8gd2hpY2ggUmVhY3QgY29tcG9uZW50cyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBUaGlzIGFsc28gY3JlYXRlcyB0aGUgXCJyZWFjdFJvb3RcIiBJRCB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGVsZW1lbnRcbiAgICogcmVuZGVyZWQgd2l0aGluLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZWdpc3RlciBhcyBhIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgXCJyZWFjdFJvb3RcIiBJRCBvZiBlbGVtZW50cyByZW5kZXJlZCB3aXRoaW4uXG4gICAqL1xuICByZWdpc3RlckNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgaWYgKHJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBJZiBvbmUgZXhpc3RzLCBtYWtlIHN1cmUgaXQgaXMgYSB2YWxpZCBcInJlYWN0Um9vdFwiIElELlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQocmVhY3RSb290SUQpO1xuICAgIH1cbiAgICBpZiAoIXJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBObyB2YWxpZCBcInJlYWN0Um9vdFwiIElEIGZvdW5kLCBjcmVhdGUgb25lLlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIH1cbiAgICBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXI7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBgY29udGFpbmVyYFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcbiAgICAvLyByZW5kZXIgYnV0IHdlIHN0aWxsIGRvbid0IGV4cGVjdCB0byBiZSBpbiBhIHJlbmRlciBjYWxsIGhlcmUuKVxuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgJyArICdpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuXG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIGNvbXBvbmVudCwgY29udGFpbmVyKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgZGVsZXRlIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgZGVsZXRlIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIFJlYWN0IGNvbXBvbmVudCB0byB3aGljaCB0aGVcbiAgICogc3VwcGxpZWQgRE9NIGBpZGAgYmVsb25ncy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgYGlkYC5cbiAgICovXG4gIGZpbmRSZWFjdENvbnRhaW5lckZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoaWQpO1xuICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgICBpZiAocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgICAvLyBDYWxsIGludGVybmFsR2V0SUQgaGVyZSBiZWNhdXNlIGdldElEIGNhbGxzIGlzVmFsaWQgd2hpY2ggY2FsbHNcbiAgICAgICAgLy8gZmluZFJlYWN0Q29udGFpbmVyRm9ySUQgKHRoaXMgZnVuY3Rpb24pLlxuICAgICAgICBpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50KSA9PT0gcmVhY3RSb290SUQsICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgSUQgZGlmZmVyZWQgZnJvbSByZWFjdFJvb3RJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGNvbnRhaW5lckNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjb250YWluZXJDaGlsZCAmJiByZWFjdFJvb3RJRCA9PT0gaW50ZXJuYWxHZXRJRChjb250YWluZXJDaGlsZCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY29udGFpbmVyIGhhcyBhIG5ldyBjaGlsZCB3aXRoIHRoZSBzYW1lIElEIGFzIHRoZSBvbGRcbiAgICAgICAgICAvLyByb290IGVsZW1lbnQsIHRoZW4gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gaXNcbiAgICAgICAgICAvLyBqdXN0IHN0YWxlIGFuZCBuZWVkcyB0byBiZSB1cGRhdGVkLiBUaGUgY2FzZSB0aGF0IGRlc2VydmVzIGFcbiAgICAgICAgICAvLyB3YXJuaW5nIGlzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBlbXB0eS5cbiAgICAgICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lckNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgJyArICdjb250YWluZXIuIE5ldyBjb250YWluZXI6Jywgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IFJlYWN0IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBET00gbm9kZSBpbiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSBSb290IERPTSBub2RlIG9mIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqL1xuICBmaW5kUmVhY3ROb2RlQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdCA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIHJldHVybiBSZWFjdE1vdW50LmZpbmRDb21wb25lbnRSb290KHJlYWN0Um9vdCwgaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBgbm9kZWAgaXMgcmVuZGVyZWQgYnkgUmVhY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbm9kZSBET00gRWxlbWVudCB0byBjaGVjay5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIEVsZW1lbnQgYXBwZWFycyB0byBiZSByZW5kZXJlZCBieSBSZWFjdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBpc1JlbmRlcmVkQnlSZWFjdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgLy8gTm90IGEgRE9NRWxlbWVudCwgdGhlcmVmb3JlIG5vdCBhIFJlYWN0IGNvbXBvbmVudFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaWQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICAgIHJldHVybiBpZCA/IGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB1cCB0aGUgYW5jZXN0b3JzIG9mIHRoZSBzdXBwbGllZCBub2RlIHRvIGZpbmQgYSBub2RlIHRoYXQgaXMgYVxuICAgKiBET00gcmVwcmVzZW50YXRpb24gb2YgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbm9kZVxuICAgKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0Rmlyc3RSZWFjdERPTTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnROb2RlICE9PSBjdXJyZW50KSB7XG4gICAgICBpZiAoUmVhY3RNb3VudC5pc1JlbmRlcmVkQnlSZWFjdChjdXJyZW50KSkge1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgYHRhcmdldElEYCBpbnNpZGUgb2YgdGhlIHN1cHBsaWVkXG4gICAqIGBhbmNlc3Rvck5vZGVgLiAgRXhwbG9pdHMgdGhlIElEIG5hbWluZyBzY2hlbWUgdG8gcGVyZm9ybSB0aGUgc2VhcmNoXG4gICAqIHF1aWNrbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IGFuY2VzdG9yTm9kZSBTZWFyY2ggZnJvbSB0aGlzIHJvb3QuXG4gICAqIEBwYXJhcm0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgYHRhcmdldElEYC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBmaW5kQ29tcG9uZW50Um9vdDogZnVuY3Rpb24gKGFuY2VzdG9yTm9kZSwgdGFyZ2V0SUQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZHJlbiA9IGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheTtcbiAgICB2YXIgY2hpbGRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGVlcGVzdEFuY2VzdG9yID0gZmluZERlZXBlc3RDYWNoZWRBbmNlc3Rvcih0YXJnZXRJRCkgfHwgYW5jZXN0b3JOb2RlO1xuXG4gICAgZmlyc3RDaGlsZHJlblswXSA9IGRlZXBlc3RBbmNlc3Rvci5maXJzdENoaWxkO1xuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMTtcblxuICAgIHdoaWxlIChjaGlsZEluZGV4IDwgZmlyc3RDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpcnN0Q2hpbGRyZW5bY2hpbGRJbmRleCsrXTtcbiAgICAgIHZhciB0YXJnZXRDaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZElEID0gUmVhY3RNb3VudC5nZXRJRChjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZElEKSB7XG4gICAgICAgICAgLy8gRXZlbiBpZiB3ZSBmaW5kIHRoZSBub2RlIHdlJ3JlIGxvb2tpbmcgZm9yLCB3ZSBmaW5pc2ggbG9vcGluZ1xuICAgICAgICAgIC8vIHRocm91Z2ggaXRzIHNpYmxpbmdzIHRvIGVuc3VyZSB0aGV5J3JlIGNhY2hlZCBzbyB0aGF0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyB0byByZXZpc2l0IHRoaXMgbm9kZSBhZ2Fpbi4gT3RoZXJ3aXNlLCB3ZSBtYWtlIG5eMiBjYWxscyB0byBnZXRJRFxuICAgICAgICAgIC8vIHdoZW4gdmlzaXRpbmcgdGhlIG1hbnkgY2hpbGRyZW4gb2YgYSBzaW5nbGUgbm9kZSBpbiBvcmRlci5cblxuICAgICAgICAgIGlmICh0YXJnZXRJRCA9PT0gY2hpbGRJRCkge1xuICAgICAgICAgICAgdGFyZ2V0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJlYWN0SW5zdGFuY2VIYW5kbGVzLmlzQW5jZXN0b3JJRE9mKGNoaWxkSUQsIHRhcmdldElEKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBhIGNoaWxkIHdob3NlIElEIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBJRCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIGJlIHN1cmUgdGhhdCB3ZSBvbmx5IHdhbnQgdG8gc2VhcmNoIHRoZSBzdWJ0cmVlXG4gICAgICAgICAgICAvLyByb290ZWQgYXQgdGhpcyBjaGlsZCwgc28gd2UgY2FuIHRocm93IG91dCB0aGUgcmVzdCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHNlYXJjaCBzdGF0ZS5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRJbmRleCA9IDA7XG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoaXMgY2hpbGQgaGFkIG5vIElELCB0aGVuIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBpdCB3YXNcbiAgICAgICAgICAvLyBpbmplY3RlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBicm93c2VyLCBhcyB3aGVuIGEgYDx0YWJsZT5gXG4gICAgICAgICAgLy8gZWxlbWVudCBzcHJvdXRzIGFuIGV4dHJhIGA8dGJvZHk+YCBjaGlsZCBhcyBhIHNpZGUgZWZmZWN0IG9mXG4gICAgICAgICAgLy8gYC5pbm5lckhUTUxgIHBhcnNpbmcuIE9wdGltaXN0aWNhbGx5IGNvbnRpbnVlIGRvd24gdGhpc1xuICAgICAgICAgIC8vIGJyYW5jaCwgYnV0IG5vdCBiZWZvcmUgZXhhbWluaW5nIHRoZSBvdGhlciBzaWJsaW5ncy5cbiAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0Q2hpbGQpIHtcbiAgICAgICAgLy8gRW1wdHlpbmcgZmlyc3RDaGlsZHJlbi9maW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkgaXNcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSBmb3IgY29ycmVjdG5lc3MsIGJ1dCBpdCBoZWxwcyB0aGUgR0MgcmVjbGFpbVxuICAgICAgICAvLyBhbnkgbm9kZXMgdGhhdCB3ZXJlIGxlZnQgYXQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoLlxuICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENoaWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICFmYWxzZSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kQ29tcG9uZW50Um9vdCguLi4sICVzKTogVW5hYmxlIHRvIGZpbmQgZWxlbWVudC4gVGhpcyBwcm9iYWJseSAnICsgJ21lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgYnJvd3NlciksICcgKyAndXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsIG5lc3RpbmcgdGFncyAnICsgJ2xpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyBpbiBhbiA8c3ZnPiAnICsgJ3BhcmVudC4gJyArICdUcnkgaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgd2l0aCBSZWFjdCBJRCBgJXNgLicsIHRhcmdldElELCBSZWFjdE1vdW50LmdldElEKGFuY2VzdG9yTm9kZSkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnbW91bnRDb21wb25lbnRJbnRvTm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCB2YWxpZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAobWFya3VwLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcblxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FLCBjaGVja3N1bSk7XG5cbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG1hcmt1cCwgcm9vdE1hcmt1cCk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gJyAoY2xpZW50KSAnICsgbWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgJyArICdzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSAnICsgJ21lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiAnICsgJ3RoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgJyArICdtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byAnICsgJ2Nyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91ICcgKyAnc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyAnICsgJ2FuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlOlxcbiVzJywgZGlmZmVyZW5jZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdCBhdHRlbXB0ZWQgdG8gcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgKyAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgKyAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgKyAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICsgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICsgJ29yIHNlcnZlcjpcXG4lcycsIGRpZmZlcmVuY2UpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCAnICsgJ3lvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzICcgKyAnd2l0aG91dCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcy4gJyArICdTZWUgUmVhY3QucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFjdCBJRCB1dGlsaXRpZXMuXG4gICAqL1xuXG4gIGdldFJlYWN0Um9vdElEOiBnZXRSZWFjdFJvb3RJRCxcblxuICBnZXRJRDogZ2V0SUQsXG5cbiAgc2V0SUQ6IHNldElELFxuXG4gIGdldE5vZGU6IGdldE5vZGUsXG5cbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcblxuICBwdXJnZUlEOiBwdXJnZUlEXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RNb3VudCwgJ1JlYWN0TW91bnQnLCB7XG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnLFxuICBfbW91bnRJbWFnZUludG9Ob2RlOiAnX21vdW50SW1hZ2VJbnRvTm9kZSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudFwiKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoXCIuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXCIpO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZShcIi4vUmVhY3RSZWNvbmNpbGVyXCIpO1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZShcIi4vUmVhY3RDaGlsZFJlY29uY2lsZXJcIik7XG5cbi8qKlxuICogVXBkYXRpbmcgY2hpbGRyZW4gb2YgYSBjb21wb25lbnQgbWF5IHRyaWdnZXIgcmVjdXJzaXZlIHVwZGF0ZXMuIFRoZSBkZXB0aCBpc1xuICogdXNlZCB0byBiYXRjaCByZWN1cnNpdmUgdXBkYXRlcyB0byByZW5kZXIgbWFya3VwIG1vcmUgZWZmaWNpZW50bHkuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVEZXB0aCA9IDA7XG5cbi8qKlxuICogUXVldWUgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAqXG4gKiBFYWNoIG9iamVjdCBoYXMgYSBgdHlwZWAgcHJvcGVydHkgdGhhdCBpcyBpbiBgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNgLlxuICpcbiAqIEB0eXBlIHthcnJheTxvYmplY3Q+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZVF1ZXVlID0gW107XG5cbi8qKlxuICogUXVldWUgb2YgbWFya3VwIHRvIGJlIHJlbmRlcmVkLlxuICpcbiAqIEB0eXBlIHthcnJheTxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hcmt1cFF1ZXVlID0gW107XG5cbi8qKlxuICogRW5xdWV1ZXMgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVNYXJrdXAocGFyZW50SUQsIG1hcmt1cCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgbWFya3VwSW5kZXg6IG1hcmt1cFF1ZXVlLnB1c2gobWFya3VwKSAtIDEsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFNvdXJjZSBpbmRleCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZU1vdmUocGFyZW50SUQsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVJlbW92ZShwYXJlbnRJRCwgZnJvbUluZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVGV4dENvbnRlbnQocGFyZW50SUQsIHRleHRDb250ZW50KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICBpZiAodXBkYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzKHVwZGF0ZVF1ZXVlLCBtYXJrdXBRdWV1ZSk7XG4gICAgY2xlYXJRdWV1ZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ2xlYXJzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gIHVwZGF0ZVF1ZXVlLmxlbmd0aCA9IDA7XG4gIG1hcmt1cFF1ZXVlLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogUmVhY3RNdWx0aUNoaWxkIGFyZSBjYXBhYmxlIG9mIHJlY29uY2lsaW5nIG11bHRpcGxlIGNoaWxkcmVuLlxuICpcbiAqIEBjbGFzcyBSZWFjdE11bHRpQ2hpbGRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkID0ge1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBmb3IgY29tcG9uZW50cyB0aGF0IG11c3QgcmVjb25jaWxlIG11bHRpcGxlXG4gICAqIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgYnkgYFJlYWN0RE9NQ29tcG9uZW50YCB0byBtb3VudCwgdXBkYXRlLCBhbmRcbiAgICogdW5tb3VudCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAbGVuZHMge1JlYWN0TXVsdGlDaGlsZC5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIG1vdW50ZWQgcmVwcmVzZW50YXRpb25zLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobW91bnRJbWFnZSk7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbik7XG4gICAgICAgIC8vIFRPRE86IFRoZSBzZXRUZXh0Q29udGVudCBvcGVyYXRpb24gc2hvdWxkIGJlIGVub3VnaFxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZEJ5TmFtZShwcmV2Q2hpbGRyZW5bbmFtZV0sIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgICAgdGhpcy5zZXRUZXh0Q29udGVudChuZXh0Q29udGVudCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXByb3ZlIHBlcmZvcm1hbmNlIGJ5IGlzb2xhdGluZyB0aGlzIGhvdCBjb2RlIHBhdGggZnJvbSB0aGUgdHJ5L2NhdGNoXG4gICAgICogYmxvY2sgaW4gYHVwZGF0ZUNoaWxkcmVuYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBuZXh0SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkQnlOYW1lKHByZXZDaGlsZCwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHRoaXMuX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4KG5leHRDaGlsZCwgbmFtZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZEJ5TmFtZShwcmV2Q2hpbGRyZW5bbmFtZV0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocmVuZGVyZWRDaGlsZHJlbik7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgZW5xdWV1ZU1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBtb3VudEltYWdlKSB7XG4gICAgICBlbnF1ZXVlTWFya3VwKHRoaXMuX3Jvb3ROb2RlSUQsIG1vdW50SW1hZ2UsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgZW5xdWV1ZVJlbW92ZSh0aGlzLl9yb290Tm9kZUlELCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodGV4dENvbnRlbnQpIHtcbiAgICAgIGVucXVldWVUZXh0Q29udGVudCh0aGlzLl9yb290Tm9kZUlELCB0ZXh0Q29udGVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG5hbWUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICB2YXIgcm9vdElEID0gdGhpcy5fcm9vdE5vZGVJRCArIG5hbWU7XG4gICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkIGluIGB0aGlzLl9yZW5kZXJlZENoaWxkcmVuYC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uIChjaGlsZCwgbmFtZSkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgfVxuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROYXRpdmVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyA9IG51bGw7XG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2Ygd3JhcHBlciBjbGFzc2VzIGFyb3VuZCBuYXRpdmUgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICAvLyBUaGlzIGFjY2VwdHMgYSBjbGFzcyB0aGF0IHJlY2VpdmVzIHRoZSB0YWcgc3RyaW5nLiBUaGlzIGlzIGEgY2F0Y2ggYWxsXG4gIC8vIHRoYXQgY2FuIHJlbmRlciBhbnkga2luZCBvZiB0YWcuXG4gIGluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIHRleHQgY29tcG9uZW50IGNsYXNzIHRoYXQgdGFrZXMgdGhlIHRleHQgc3RyaW5nIHRvIGJlXG4gIC8vIHJlbmRlcmVkIGFzIHByb3BzLlxuICBpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIHRleHRDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSBrZXllZCBvYmplY3Qgd2l0aCBjbGFzc2VzIGFzIHZhbHVlcy4gRWFjaCBrZXkgcmVwcmVzZW50cyBhXG4gIC8vIHRhZy4gVGhhdCBwYXJ0aWN1bGFyIHRhZyB3aWxsIHVzZSB0aGlzIGNsYXNzIGluc3RlYWQgb2YgdGhlIGdlbmVyaWMgb25lLlxuICBpbmplY3RDb21wb25lbnRDbGFzc2VzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3Nlcykge1xuICAgIGFzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfSxcbiAgLy8gVGVtcG9yYXJ5IGhhY2sgc2luY2Ugd2UgZXhwZWN0IERPTSByZWZzIHRvIGJlaGF2ZSBsaWtlIGNvbXBvc2l0ZXMsXG4gIC8vIGZvciB0aGlzIHJlbGVhc2UuXG4gIGluamVjdEF1dG9XcmFwcGVyOiBmdW5jdGlvbiAod3JhcHBlckZhY3RvcnkpIHtcbiAgICBhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3MgPSB3cmFwcGVyRmFjdG9yeTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBjb21wb3NpdGUgY29tcG9uZW50IHdyYXBwZXIgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSB0YWcgZm9yIHdoaWNoIHRvIGdldCB0aGUgY2xhc3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIFJlYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH1cbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gdGFnVG9Db21wb25lbnRDbGFzc1t0YWddO1xuICBpZiAoY29tcG9uZW50Q2xhc3MgPT0gbnVsbCkge1xuICAgIHRhZ1RvQ29tcG9uZW50Q2xhc3NbdGFnXSA9IGNvbXBvbmVudENsYXNzID0gYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzKHRhZyk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudENsYXNzO1xufVxuXG4vKipcbiAqIEdldCBhIG5hdGl2ZSBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHtcbiAgZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50OiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQsXG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TmF0aXZlQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gVGhpcyAnICsgJ3VzdWFsbHkgbWVhbnMgdGhhdCB5b3VcXCdyZSB0cnlpbmcgdG8gYWRkIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgJyArICdkb2VzblxcJ3QgaGF2ZSBhbiBvd25lciAodGhhdCBpcywgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBvZiBhbm90aGVyICcgKyAnY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QpLiBUcnkgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IGluc2lkZSBvZiAnICsgJ2EgbmV3IHRvcC1sZXZlbCBjb21wb25lbnQgd2hpY2ggd2lsbCBob2xkIHRoZSByZWYuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFRoaXMgJyArICd1c3VhbGx5IG1lYW5zIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIHJlbW92ZSBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0ICcgKyAnZG9lc25cXCd0IGhhdmUgYW4gb3duZXIgKHRoYXQgaXMsIHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgb2YgYW5vdGhlciAnICsgJ2NvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kKS4gVHJ5IHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBpbnNpZGUgb2YgJyArICdhIG5ldyB0b3AtbGV2ZWwgY29tcG9uZW50IHdoaWNoIHdpbGwgaG9sZCB0aGUgcmVmLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBDaGVjayB0aGF0IGBjb21wb25lbnRgIGlzIHN0aWxsIHRoZSBjdXJyZW50IHJlZiBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvXG4gICAgLy8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXG4gICAgaWYgKG93bmVyLmdldFB1YmxpY0luc3RhbmNlKCkucmVmc1tyZWZdID09PSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSkge1xuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RPd25lcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZWFjdFBlcmYgaXMgYSBnZW5lcmFsIEFPUCBzeXN0ZW0gZGVzaWduZWQgdG8gbWVhc3VyZSBwZXJmb3JtYW5jZS4gVGhpc1xuICogbW9kdWxlIG9ubHkgaGFzIHRoZSBob29rczogc2VlIFJlYWN0RGVmYXVsdFBlcmYgZm9yIHRoZSBhbmFseXNpcyB0b29sLlxuICovXG52YXIgUmVhY3RQZXJmID0ge1xuICAvKipcbiAgICogQm9vbGVhbiB0byBlbmFibGUvZGlzYWJsZSBtZWFzdXJlbWVudC4gU2V0IHRvIGZhbHNlIGJ5IGRlZmF1bHQgdG8gcHJldmVudFxuICAgKiBhY2NpZGVudGFsIGxvZ2dpbmcgYW5kIHBlcmYgbG9zcy5cbiAgICovXG4gIGVuYWJsZU1lYXN1cmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBIb2xkcyBvbnRvIHRoZSBtZWFzdXJlIGZ1bmN0aW9uIGluIHVzZS4gQnkgZGVmYXVsdCwgZG9uJ3QgbWVhc3VyZVxuICAgKiBhbnl0aGluZywgYnV0IHdlJ2xsIG92ZXJyaWRlIHRoaXMgaWYgd2UgaW5qZWN0IGEgbWVhc3VyZSBmdW5jdGlvbi5cbiAgICovXG4gIHN0b3JlZE1lYXN1cmU6IF9ub01lYXN1cmUsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iamVjdE5hbWVcbiAgICogQHBhcmFtIHtvYmplY3Q8c3RyaW5nPn0gbWV0aG9kTmFtZXNcbiAgICovXG4gIG1lYXN1cmVNZXRob2RzOiBmdW5jdGlvbiAob2JqZWN0LCBvYmplY3ROYW1lLCBtZXRob2ROYW1lcykge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgaWYgKCFtZXRob2ROYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSBSZWFjdFBlcmYubWVhc3VyZShvYmplY3ROYW1lLCBtZXRob2ROYW1lc1trZXldLCBvYmplY3Rba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyB0byB3cmFwIG1ldGhvZHMgeW91IHdhbnQgdG8gbWVhc3VyZS4gWmVybyBvdmVyaGVhZCBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAqL1xuICBtZWFzdXJlOiBmdW5jdGlvbiAob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhciBtZWFzdXJlZEZ1bmMgPSBudWxsO1xuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSkge1xuICAgICAgICAgIGlmICghbWVhc3VyZWRGdW5jKSB7XG4gICAgICAgICAgICBtZWFzdXJlZEZ1bmMgPSBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVhc3VyZWRGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICB3cmFwcGVyLmRpc3BsYXlOYW1lID0gb2JqTmFtZSArICdfJyArIGZuTmFtZTtcbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYztcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZWFzdXJlXG4gICAgICovXG4gICAgaW5qZWN0TWVhc3VyZTogZnVuY3Rpb24gKG1lYXN1cmUpIHtcbiAgICAgIFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlID0gbWVhc3VyZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2ltcGx5IHBhc3NlcyB0aHJvdWdoIHRoZSBtZWFzdXJlZCBmdW5jdGlvbiwgd2l0aG91dCBtZWFzdXJpbmcgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBfbm9NZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICByZXR1cm4gZnVuYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFBlcmY7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFRyYW5zZmVyZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIGpvaW5DbGFzc2VzID0gcmVxdWlyZShcIi4vam9pbkNsYXNzZXNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZmVyIHN0cmF0ZWd5IHRoYXQgd2lsbCBtZXJnZSBwcm9wIHZhbHVlcyB1c2luZyB0aGUgc3VwcGxpZWRcbiAqIGBtZXJnZVN0cmF0ZWd5YC4gSWYgYSBwcm9wIHdhcyBwcmV2aW91c2x5IHVuc2V0LCB0aGlzIGp1c3Qgc2V0cyBpdC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXJnZVN0cmF0ZWd5XG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNmZXJTdHJhdGVneShtZXJnZVN0cmF0ZWd5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocHJvcHMsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHNba2V5XSA9IG1lcmdlU3RyYXRlZ3kocHJvcHNba2V5XSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHRyYW5zZmVyU3RyYXRlZ3lNZXJnZSA9IGNyZWF0ZVRyYW5zZmVyU3RyYXRlZ3koZnVuY3Rpb24gKGEsIGIpIHtcbiAgLy8gYG1lcmdlYCBvdmVycmlkZXMgdGhlIGZpcnN0IG9iamVjdCdzIChgcHJvcHNba2V5XWAgYWJvdmUpIGtleXMgdXNpbmcgdGhlXG4gIC8vIHNlY29uZCBvYmplY3QncyAoYHZhbHVlYCkga2V5cy4gQW4gb2JqZWN0J3Mgc3R5bGUncyBleGlzdGluZyBgcHJvcEFgIHdvdWxkXG4gIC8vIGdldCBvdmVycmlkZGVuLiBGbGlwIHRoZSBvcmRlciBoZXJlLlxuICByZXR1cm4gYXNzaWduKHt9LCBiLCBhKTtcbn0pO1xuXG4vKipcbiAqIFRyYW5zZmVyIHN0cmF0ZWdpZXMgZGljdGF0ZSBob3cgcHJvcHMgYXJlIHRyYW5zZmVycmVkIGJ5IGB0cmFuc2ZlclByb3BzVG9gLlxuICogTk9URTogaWYgeW91IGFkZCBhbnkgbW9yZSBleGNlcHRpb25zIHRvIHRoaXMgbGlzdCB5b3Ugc2hvdWxkIGJlIHN1cmUgdG9cbiAqIHVwZGF0ZSBgY2xvbmVXaXRoUHJvcHMoKWAgYWNjb3JkaW5nbHkuXG4gKi9cbnZhciBUcmFuc2ZlclN0cmF0ZWdpZXMgPSB7XG4gIC8qKlxuICAgKiBOZXZlciB0cmFuc2ZlciBgY2hpbGRyZW5gLlxuICAgKi9cbiAgY2hpbGRyZW46IGVtcHR5RnVuY3Rpb24sXG4gIC8qKlxuICAgKiBUcmFuc2ZlciB0aGUgYGNsYXNzTmFtZWAgcHJvcCBieSBtZXJnaW5nIHRoZW0uXG4gICAqL1xuICBjbGFzc05hbWU6IGNyZWF0ZVRyYW5zZmVyU3RyYXRlZ3koam9pbkNsYXNzZXMpLFxuICAvKipcbiAgICogVHJhbnNmZXIgdGhlIGBzdHlsZWAgcHJvcCAod2hpY2ggaXMgYW4gb2JqZWN0KSBieSBtZXJnaW5nIHRoZW0uXG4gICAqL1xuICBzdHlsZTogdHJhbnNmZXJTdHJhdGVneU1lcmdlXG59O1xuXG4vKipcbiAqIE11dGF0ZXMgdGhlIGZpcnN0IGFyZ3VtZW50IGJ5IHRyYW5zZmVycmluZyB0aGUgcHJvcGVydGllcyBmcm9tIHRoZSBzZWNvbmRcbiAqIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZmVySW50byhwcm9wcywgbmV3UHJvcHMpIHtcbiAgZm9yICh2YXIgdGhpc0tleSBpbiBuZXdQcm9wcykge1xuICAgIGlmICghbmV3UHJvcHMuaGFzT3duUHJvcGVydHkodGhpc0tleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2ZlclN0cmF0ZWd5ID0gVHJhbnNmZXJTdHJhdGVnaWVzW3RoaXNLZXldO1xuXG4gICAgaWYgKHRyYW5zZmVyU3RyYXRlZ3kgJiYgVHJhbnNmZXJTdHJhdGVnaWVzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICB0cmFuc2ZlclN0cmF0ZWd5KHByb3BzLCB0aGlzS2V5LCBuZXdQcm9wc1t0aGlzS2V5XSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkodGhpc0tleSkpIHtcbiAgICAgIHByb3BzW3RoaXNLZXldID0gbmV3UHJvcHNbdGhpc0tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuLyoqXG4gKiBSZWFjdFByb3BUcmFuc2ZlcmVyIGFyZSBjYXBhYmxlIG9mIHRyYW5zZmVycmluZyBwcm9wcyB0byBhbm90aGVyIGNvbXBvbmVudFxuICogdXNpbmcgYSBgdHJhbnNmZXJQcm9wc1RvYCBtZXRob2QuXG4gKlxuICogQGNsYXNzIFJlYWN0UHJvcFRyYW5zZmVyZXJcbiAqL1xudmFyIFJlYWN0UHJvcFRyYW5zZmVyZXIgPSB7XG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBwcm9wcyBvYmplY3RzIHVzaW5nIFRyYW5zZmVyU3RyYXRlZ2llcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIG9yaWdpbmFsIHByb3BzICh0aGV5IHRha2UgcHJlY2VkZW5jZSlcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIG5ldyBwcm9wcyB0byBtZXJnZSBpblxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGEgbmV3IG9iamVjdCBjb250YWluaW5nIGJvdGggc2V0cyBvZiBwcm9wcyBtZXJnZWQuXG4gICAqL1xuICBtZXJnZVByb3BzOiBmdW5jdGlvbiAob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIHRyYW5zZmVySW50byhhc3NpZ24oe30sIG9sZFByb3BzKSwgbmV3UHJvcHMpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHJhbnNmZXJlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0ga2V5TWlycm9yKHtcbiAgcHJvcDogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgY2hpbGRDb250ZXh0OiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEZyYWdtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RGcmFnbWVudFwiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXCIpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHByb3BUeXBlczoge1xuICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAqXG4gKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gKlxuICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICogICB9KTtcbiAqXG4gKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gKlxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAqXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAqICAgICAgICAgICk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9LFxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gKiAgfSk7XG4gKlxuICogQGludGVybmFsXG4gKi9cblxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1JlcXVpcmVkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agd2FzIG5vdCBzcGVjaWZpZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCAnJyArIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGluc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBleHBlY3RlZFZhbHVlc1tpXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgJycgKyBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sICcnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwcm9wVmFsdWUgPSBSZWFjdEZyYWdtZW50LmV4dHJhY3RJZkZyYWdtZW50KHByb3BWYWx1ZSk7XG4gICAgICBmb3IgKHZhciBrIGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoIWlzTm9kZShwcm9wVmFsdWVba10pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKFwiLi9DYWxsYmFja1F1ZXVlXCIpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdElucHV0U2VsZWN0aW9uXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdgKSwgYnV0IHNlcnZlci1zaWRlIHVzZXNcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcbiAgLy8gYFJlYWN0VGV4dENvbXBvbmVudGAgY2hlY2tzIGl0IGluIGBtb3VudENvbXBvbmVudGAuYFxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJlc3VzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbmFzc2lnbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVmID0gcmVxdWlyZShcIi4vUmVhY3RSZWZcIik7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50VmFsaWRhdG9yXCIpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNoZWNrQW5kV2FybkZvck11dGF0ZWRQcm9wcyhpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGEgY29tcG9uZW50IHVzaW5nIGEgbmV3IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgPT09IHByZXZFbGVtZW50ICYmIG5leHRFbGVtZW50Ll9vd25lciAhPSBudWxsKSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIFJlYWN0RWxlbWVudFZhbGlkYXRvci5jaGVja0FuZFdhcm5Gb3JNdXRhdGVkUHJvcHMobmV4dEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGbHVzaCBhbnkgZGlydHkgY2hhbmdlcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24pIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVmXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0T3duZXJcIik7XG5cbnZhciBSZWFjdFJlZiA9IHt9O1xuXG5mdW5jdGlvbiBhdHRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihudWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5SZWFjdFJlZi5hdHRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgcmV0dXJuIG5leHRFbGVtZW50Ll9vd25lciAhPT0gcHJldkVsZW1lbnQuX293bmVyIHx8IG5leHRFbGVtZW50LnJlZiAhPT0gcHJldkVsZW1lbnQucmVmO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGRldGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWY7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4XG4gICAqL1xuICBpbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKF9jcmVhdGVSZWFjdFJvb3RJbmRleCkge1xuICAgIFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4ID0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4O1xuICB9XG59O1xuXG52YXIgUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBudWxsLFxuICBpbmplY3Rpb246IFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Um9vdEluZGV4OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZUhhbmRsZXNcIik7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoXCIuL1JlYWN0TWFya3VwQ2hlY2tzdW1cIik7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cIik7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoXCIuL2VtcHR5T2JqZWN0XCIpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgSFRNTCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoZWxlbWVudCkge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclRvU3RyaW5nKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdEVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgdHJ5IHtcbiAgICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHRyYW5zYWN0aW9uID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5nZXRQb29sZWQoZmFsc2UpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChlbGVtZW50LCBudWxsKTtcbiAgICAgIHZhciBtYXJrdXAgPSBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudChpZCwgdHJhbnNhY3Rpb24sIGVtcHR5T2JqZWN0KTtcbiAgICAgIHJldHVybiBSZWFjdE1hcmt1cENoZWNrc3VtLmFkZENoZWNrc3VtVG9NYXJrdXAobWFya3VwKTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwLCB3aXRob3V0IHRoZSBleHRyYSBSZWFjdCBJRCBhbmQgY2hlY2tzdW1cbiAqIChmb3IgZ2VuZXJhdGluZyBzdGF0aWMgcGFnZXMpXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTWFya3VwKGVsZW1lbnQpIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJUb1N0YXRpY01hcmt1cCgpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RFbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgdHJhbnNhY3Rpb247XG4gIHRyeSB7XG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChlbGVtZW50LCBudWxsKTtcbiAgICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudChpZCwgdHJhbnNhY3Rpb24sIGVtcHR5T2JqZWN0KTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW5kZXJUb1N0cmluZzogcmVuZGVyVG9TdHJpbmcsXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiByZW5kZXJUb1N0YXRpY01hcmt1cFxufTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKFwiLi9DYWxsYmFja1F1ZXVlXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgYENhbGxiYWNrUXVldWVgIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBvbkRPTVJlYWR5YCBjYWxsYmFja3NcbiAqIGR1cmluZyB0aGUgcGVyZm9ybWluZyBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgY2xvc2U6IGVtcHR5RnVuY3Rpb25cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWVkdXJlcy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXN1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFN0YXRlU2V0dGVyc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0U3RhdGVTZXR0ZXJzID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCBhbmQgdXNlcyB0aGUgcmVzdWx0XG4gICAqIG9mIHRoYXQgdG8gc2V0IHRoZSBjb21wb25lbnQncyBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNSZXR1cm5pbmdTdGF0ZSBSZXR1cm5lZCBjYWxsYmFjayB1c2VzIHRoaXMgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVybWluZSBob3cgdG8gdXBkYXRlIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gY2FsbGJhY2sgdGhhdCB3aGVuIGludm9rZWQgdXNlcyBmdW5jUmV0dXJuaW5nU3RhdGUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgIGRldGVybWluZWQgdGhlIG9iamVjdCBsaXRlcmFsIHRvIHNldFN0YXRlLlxuICAgKi9cbiAgY3JlYXRlU3RhdGVTZXR0ZXI6IGZ1bmN0aW9uIChjb21wb25lbnQsIGZ1bmNSZXR1cm5pbmdTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGZ1bmNSZXR1cm5pbmdTdGF0ZS5jYWxsKGNvbXBvbmVudCwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBpZiAocGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGNvbXBvbmVudC5zZXRTdGF0ZShwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaW5nbGUtYXJndW1lbnQgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgYSBzaW5nbGVcbiAgICoga2V5IGluIHRoZSBjb21wb25lbnQncyBzdGF0ZS5cbiAgICpcbiAgICogTm90ZTogdGhpcyBpcyBtZW1vaXplZCBmdW5jdGlvbiwgd2hpY2ggbWFrZXMgaXQgaW5leHBlbnNpdmUgdG8gY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBpbiB0aGUgc3RhdGUgdGhhdCB5b3Ugc2hvdWxkIHVwZGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIG9mIDEgYXJndW1lbnQgd2hpY2ggY2FsbHMgc2V0U3RhdGUoKSB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICB0aGUgcHJvdmlkZWQga2V5TmFtZSBhbmQgY2FsbGJhY2sgYXJndW1lbnQuXG4gICAqL1xuICBjcmVhdGVTdGF0ZUtleVNldHRlcjogZnVuY3Rpb24gKGNvbXBvbmVudCwga2V5KSB7XG4gICAgLy8gTWVtb2l6ZSB0aGUgc2V0dGVycy5cbiAgICB2YXIgY2FjaGUgPSBjb21wb25lbnQuX19rZXlTZXR0ZXJzIHx8IChjb21wb25lbnQuX19rZXlTZXR0ZXJzID0ge30pO1xuICAgIHJldHVybiBjYWNoZVtrZXldIHx8IChjYWNoZVtrZXldID0gY3JlYXRlU3RhdGVLZXlTZXR0ZXIoY29tcG9uZW50LCBrZXkpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlU3RhdGVLZXlTZXR0ZXIoY29tcG9uZW50LCBrZXkpIHtcbiAgLy8gUGFydGlhbCBzdGF0ZSBpcyBhbGxvY2F0ZWQgb3V0c2lkZSBvZiB0aGUgZnVuY3Rpb24gY2xvc3VyZSBzbyBpdCBjYW4gYmVcbiAgLy8gcmV1c2VkIHdpdGggZXZlcnkgY2FsbCwgYXZvaWRpbmcgbWVtb3J5IGFsbG9jYXRpb24gd2hlbiB0aGlzIGZ1bmN0aW9uXG4gIC8vIGlzIGNhbGxlZC5cbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gc3RhdGVLZXlTZXR0ZXIodmFsdWUpIHtcbiAgICBwYXJ0aWFsU3RhdGVba2V5XSA9IHZhbHVlO1xuICAgIGNvbXBvbmVudC5zZXRTdGF0ZShwYXJ0aWFsU3RhdGUpO1xuICB9O1xufVxuXG5SZWFjdFN0YXRlU2V0dGVycy5NaXhpbiA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiwgYW5kIHVzZXMgdGhlIHJlc3VsdFxuICAgKiBvZiB0aGF0IHRvIHNldCB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCB0aGVzZSBzdGF0ZW1lbnRzIGFyZSBlcXVpdmFsZW50OlxuICAgKlxuICAgKiAgIHRoaXMuc2V0U3RhdGUoe3g6IDF9KTtcbiAgICogICB0aGlzLmNyZWF0ZVN0YXRlU2V0dGVyKGZ1bmN0aW9uKHhWYWx1ZSkge1xuICAgKiAgICAgcmV0dXJuIHt4OiB4VmFsdWV9O1xuICAgKiAgIH0pKDEpO1xuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmV0dXJuaW5nU3RhdGUgUmV0dXJuZWQgY2FsbGJhY2sgdXNlcyB0aGlzIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmUgaG93IHRvIHVwZGF0ZSBzdGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIHRoYXQgd2hlbiBpbnZva2VkIHVzZXMgZnVuY1JldHVybmluZ1N0YXRlIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVkIHRoZSBvYmplY3QgbGl0ZXJhbCB0byBzZXRTdGF0ZS5cbiAgICovXG4gIGNyZWF0ZVN0YXRlU2V0dGVyOiBmdW5jdGlvbiAoZnVuY1JldHVybmluZ1N0YXRlKSB7XG4gICAgcmV0dXJuIFJlYWN0U3RhdGVTZXR0ZXJzLmNyZWF0ZVN0YXRlU2V0dGVyKHRoaXMsIGZ1bmNSZXR1cm5pbmdTdGF0ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaW5nbGUtYXJndW1lbnQgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgYSBzaW5nbGVcbiAgICoga2V5IGluIHRoZSBjb21wb25lbnQncyBzdGF0ZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHRoZXNlIHN0YXRlbWVudHMgYXJlIGVxdWl2YWxlbnQ6XG4gICAqXG4gICAqICAgdGhpcy5zZXRTdGF0ZSh7eDogMX0pO1xuICAgKiAgIHRoaXMuY3JlYXRlU3RhdGVLZXlTZXR0ZXIoJ3gnKSgxKTtcbiAgICpcbiAgICogTm90ZTogdGhpcyBpcyBtZW1vaXplZCBmdW5jdGlvbiwgd2hpY2ggbWFrZXMgaXQgaW5leHBlbnNpdmUgdG8gY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGluIHRoZSBzdGF0ZSB0aGF0IHlvdSBzaG91bGQgdXBkYXRlLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gY2FsbGJhY2sgb2YgMSBhcmd1bWVudCB3aGljaCBjYWxscyBzZXRTdGF0ZSgpIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgIHRoZSBwcm92aWRlZCBrZXlOYW1lIGFuZCBjYWxsYmFjayBhcmd1bWVudC5cbiAgICovXG4gIGNyZWF0ZVN0YXRlS2V5U2V0dGVyOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIFJlYWN0U3RhdGVTZXR0ZXJzLmNyZWF0ZVN0YXRlS2V5U2V0dGVyKHRoaXMsIGtleSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTdGF0ZVNldHRlcnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VGVzdFV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIFJlYWN0ID0gcmVxdWlyZShcIi4vUmVhY3RcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVtcHR5Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZUhhbmRsZXNcIik7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VNYXBcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZShcIi4vZW1wdHlPYmplY3RcIik7XG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKFwiLi9maW5kRE9NTm9kZVwiKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG5mdW5jdGlvbiBFdmVudChzdWZmaXgpIHt9XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0VGVzdFV0aWxzXG4gKi9cblxuLyoqXG4gKiBUb2RvOiBTdXBwb3J0IHRoZSBlbnRpcmUgRE9NLnNjcnkgcXVlcnkgc3ludGF4LiBGb3Igbm93LCB0aGVzZSBzaW1wbGVcbiAqIHV0aWxpdGllcyB3aWxsIHN1ZmZpY2UgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKiBAbGVuZHMgUmVhY3RUZXN0VXRpbHNcbiAqL1xudmFyIFJlYWN0VGVzdFV0aWxzID0ge1xuICByZW5kZXJJbnRvRG9jdW1lbnQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvLyBOb25lIG9mIG91ciB0ZXN0cyBhY3R1YWxseSByZXF1aXJlIGF0dGFjaGluZyB0aGUgY29udGFpbmVyIHRvIHRoZVxuICAgIC8vIERPTSwgYW5kIGRvaW5nIHNvIGNyZWF0ZXMgYSBtZXNzIHRoYXQgd2UgcmVseSBvbiB0ZXN0IGlzb2xhdGlvbiB0b1xuICAgIC8vIGNsZWFuIHVwLCBzbyB3ZSdyZSBnb2luZyB0byBzdG9wIGhvbm9yaW5nIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kXG4gICAgLy8gKGFuZCBwcm9iYWJseSByZW5hbWUgaXQgZXZlbnR1YWxseSkgaWYgbm8gcHJvYmxlbXMgYXJpc2UuXG4gICAgLy8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgcmV0dXJuIFJlYWN0LnJlbmRlcihpbnN0YW5jZSwgZGl2KTtcbiAgfSxcblxuICBpc0VsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KTtcbiAgfSxcblxuICBpc0VsZW1lbnRPZlR5cGU6IGZ1bmN0aW9uIChpbnN0LCBjb252ZW5pZW5jZUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChpbnN0KSAmJiBpbnN0LnR5cGUgPT09IGNvbnZlbmllbmNlQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaXNET01Db21wb25lbnQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgaGV1cmlzdGljLiBJdCdzIGp1c3QgaGVyZSBiZWNhdXNlIGNvbXBvc2l0ZXMgY2FuIGN1cnJlbnRseVxuICAgIC8vIHByZXRlbmQgdG8gYmUgRE9NIGNvbXBvbmVudHMuXG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC50YWdOYW1lICYmIGluc3QuZ2V0RE9NTm9kZSk7XG4gIH0sXG5cbiAgaXNET01Db21wb25lbnRFbGVtZW50OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHJldHVybiAhIShpbnN0ICYmIFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChpbnN0KSAmJiAhIWluc3QudGFnTmFtZSk7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnN0LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdC5zZXRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSxcblxuICBpc0NvbXBvc2l0ZUNvbXBvbmVudFdpdGhUeXBlOiBmdW5jdGlvbiAoaW5zdCwgdHlwZSkge1xuICAgIHJldHVybiAhIShSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSAmJiBpbnN0LmNvbnN0cnVjdG9yID09PSB0eXBlKTtcbiAgfSxcblxuICBpc0NvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2UgY2hlY2sgdGhlIHByb3RvdHlwZSBvZiB0aGUgdHlwZSB0aGF0IHdpbGwgZ2V0IG1vdW50ZWQsIG5vdCB0aGVcbiAgICAvLyBpbnN0YW5jZSBpdHNlbGYuIFRoaXMgaXMgYSBmdXR1cmUgcHJvb2Ygd2F5IG9mIGR1Y2sgdHlwaW5nLlxuICAgIHZhciBwcm90b3R5cGUgPSBpbnN0LnR5cGUucHJvdG90eXBlO1xuICAgIHJldHVybiB0eXBlb2YgcHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcHJvdG90eXBlLnNldFN0YXRlID09PSAnZnVuY3Rpb24nO1xuICB9LFxuXG4gIGlzQ29tcG9zaXRlQ29tcG9uZW50RWxlbWVudFdpdGhUeXBlOiBmdW5jdGlvbiAoaW5zdCwgdHlwZSkge1xuICAgIHJldHVybiAhIShSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnQoaW5zdCkgJiYgaW5zdC5jb25zdHJ1Y3RvciA9PT0gdHlwZSk7XG4gIH0sXG5cbiAgZ2V0UmVuZGVyZWRDaGlsZE9mQ29tcG9zaXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnQoaW5zdCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpO1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICB9LFxuXG4gIGZpbmRBbGxJblJlbmRlcmVkVHJlZTogZnVuY3Rpb24gKGluc3QsIHRlc3QpIHtcbiAgICBpZiAoIWluc3QpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRlc3QoaW5zdCkgPyBbaW5zdF0gOiBbXTtcbiAgICBpZiAoUmVhY3RUZXN0VXRpbHMuaXNET01Db21wb25lbnQoaW5zdCkpIHtcbiAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCk7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlbmRlcmVkQ2hpbGRyZW5ba2V5XS5nZXRQdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoUmVhY3RUZXN0VXRpbHMuZmluZEFsbEluUmVuZGVyZWRUcmVlKHJlbmRlcmVkQ2hpbGRyZW5ba2V5XS5nZXRQdWJsaWNJbnN0YW5jZSgpLCB0ZXN0KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSkge1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUoUmVhY3RUZXN0VXRpbHMuZ2V0UmVuZGVyZWRDaGlsZE9mQ29tcG9zaXRlQ29tcG9uZW50KGluc3QpLCB0ZXN0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBpbnN0YW5jZSBvZiBjb21wb25lbnRzIGluIHRoZSByZW5kZXJlZCB0cmVlIHRoYXQgYXJlIERPTVxuICAgKiBjb21wb25lbnRzIHdpdGggdGhlIGNsYXNzIG5hbWUgbWF0Y2hpbmcgYGNsYXNzTmFtZWAuXG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzLlxuICAgKi9cbiAgc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzczogZnVuY3Rpb24gKHJvb3QsIGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgIHZhciBpbnN0Q2xhc3NOYW1lID0gaW5zdC5wcm9wcy5jbGFzc05hbWU7XG4gICAgICByZXR1cm4gUmVhY3RUZXN0VXRpbHMuaXNET01Db21wb25lbnQoaW5zdCkgJiYgKGluc3RDbGFzc05hbWUgJiYgKCcgJyArIGluc3RDbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSAhPT0gLTEpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaWtlIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3MgYnV0IGV4cGVjdHMgdGhlcmUgdG8gYmUgb25lIHJlc3VsdCxcbiAgICogYW5kIHJldHVybnMgdGhhdCBvbmUgcmVzdWx0LCBvciB0aHJvd3MgZXhjZXB0aW9uIGlmIHRoZXJlIGlzIGFueSBvdGhlclxuICAgKiBudW1iZXIgb2YgbWF0Y2hlcyBiZXNpZGVzIG9uZS5cbiAgICogQHJldHVybiB7IVJlYWN0RE9NQ29tcG9uZW50fSBUaGUgb25lIG1hdGNoLlxuICAgKi9cbiAgZmluZFJlbmRlcmVkRE9NQ29tcG9uZW50V2l0aENsYXNzOiBmdW5jdGlvbiAocm9vdCwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIGFsbCA9IFJlYWN0VGVzdFV0aWxzLnNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3Mocm9vdCwgY2xhc3NOYW1lKTtcbiAgICBpZiAoYWxsLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGZpbmQgZXhhY3RseSBvbmUgbWF0Y2ggJyArICcoZm91bmQ6ICcgKyBhbGwubGVuZ3RoICsgJykgZm9yIGNsYXNzOicgKyBjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYWxsWzBdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgaW5zdGFuY2Ugb2YgY29tcG9uZW50cyBpbiB0aGUgcmVuZGVyZWQgdHJlZSB0aGF0IGFyZSBET01cbiAgICogY29tcG9uZW50cyB3aXRoIHRoZSB0YWcgbmFtZSBtYXRjaGluZyBgdGFnTmFtZWAuXG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzLlxuICAgKi9cbiAgc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhUYWc6IGZ1bmN0aW9uIChyb290LCB0YWdOYW1lKSB7XG4gICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmZpbmRBbGxJblJlbmRlcmVkVHJlZShyb290LCBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmlzRE9NQ29tcG9uZW50KGluc3QpICYmIGluc3QudGFnTmFtZSA9PT0gdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaWtlIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHQsXG4gICAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAgICogbnVtYmVyIG9mIG1hdGNoZXMgYmVzaWRlcyBvbmUuXG4gICAqIEByZXR1cm4geyFSZWFjdERPTUNvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAgICovXG4gIGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWc6IGZ1bmN0aW9uIChyb290LCB0YWdOYW1lKSB7XG4gICAgdmFyIGFsbCA9IFJlYWN0VGVzdFV0aWxzLnNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnKHJvb3QsIHRhZ05hbWUpO1xuICAgIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCBmb3IgdGFnOicgKyB0YWdOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbFswXTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYWxsIGluc3RhbmNlcyBvZiBjb21wb25lbnRzIHdpdGggdHlwZSBlcXVhbCB0byBgY29tcG9uZW50VHlwZWAuXG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzLlxuICAgKi9cbiAgc2NyeVJlbmRlcmVkQ29tcG9uZW50c1dpdGhUeXBlOiBmdW5jdGlvbiAocm9vdCwgY29tcG9uZW50VHlwZSkge1xuICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudFdpdGhUeXBlKGluc3QsIGNvbXBvbmVudFR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGVgIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHRcbiAgICogYW5kIHJldHVybnMgdGhhdCBvbmUgcmVzdWx0LCBvciB0aHJvd3MgZXhjZXB0aW9uIGlmIHRoZXJlIGlzIGFueSBvdGhlclxuICAgKiBudW1iZXIgb2YgbWF0Y2hlcyBiZXNpZGVzIG9uZS5cbiAgICogQHJldHVybiB7IVJlYWN0Q29tcG9uZW50fSBUaGUgb25lIG1hdGNoLlxuICAgKi9cbiAgZmluZFJlbmRlcmVkQ29tcG9uZW50V2l0aFR5cGU6IGZ1bmN0aW9uIChyb290LCBjb21wb25lbnRUeXBlKSB7XG4gICAgdmFyIGFsbCA9IFJlYWN0VGVzdFV0aWxzLnNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZShyb290LCBjb21wb25lbnRUeXBlKTtcbiAgICBpZiAoYWxsLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGZpbmQgZXhhY3RseSBvbmUgbWF0Y2ggZm9yIGNvbXBvbmVudFR5cGU6JyArIGNvbXBvbmVudFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gYWxsWzBdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgbW9ja2VkIGNvbXBvbmVudCBtb2R1bGUgdG8gdGhpcyBtZXRob2QgdG8gYXVnbWVudCBpdCB3aXRoXG4gICAqIHVzZWZ1bCBtZXRob2RzIHRoYXQgYWxsb3cgaXQgdG8gYmUgdXNlZCBhcyBhIGR1bW15IFJlYWN0IGNvbXBvbmVudC5cbiAgICogSW5zdGVhZCBvZiByZW5kZXJpbmcgYXMgdXN1YWwsIHRoZSBjb21wb25lbnQgd2lsbCBiZWNvbWUgYSBzaW1wbGVcbiAgICogPGRpdj4gY29udGFpbmluZyBhbnkgcHJvdmlkZWQgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtb2R1bGUgdGhlIG1vY2sgZnVuY3Rpb24gb2JqZWN0IGV4cG9ydGVkIGZyb20gYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSB0aGF0IGRlZmluZXMgdGhlIGNvbXBvbmVudCB0byBiZSBtb2NrZWRcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBtb2NrVGFnTmFtZSBvcHRpb25hbCBkdW1teSByb290IHRhZyBuYW1lIHRvIHJldHVyblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gcmVuZGVyIG1ldGhvZCAob3ZlcnJpZGVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLm1vY2tUYWdOYW1lIGlmIHByb3ZpZGVkKVxuICAgKiBAcmV0dXJuIHtvYmplY3R9IHRoZSBSZWFjdFRlc3RVdGlscyBvYmplY3QgKGZvciBjaGFpbmluZylcbiAgICovXG4gIG1vY2tDb21wb25lbnQ6IGZ1bmN0aW9uIChtb2R1bGUsIG1vY2tUYWdOYW1lKSB7XG4gICAgbW9ja1RhZ05hbWUgPSBtb2NrVGFnTmFtZSB8fCBtb2R1bGUubW9ja1RhZ05hbWUgfHwgJ2Rpdic7XG5cbiAgICBtb2R1bGUucHJvdG90eXBlLnJlbmRlci5tb2NrSW1wbGVtZW50YXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQobW9ja1RhZ05hbWUsIG51bGwsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyBhIHRvcCBsZXZlbCBldmVudCBiZWluZyBkaXNwYXRjaGVkIGZyb20gYSByYXcgZXZlbnQgdGhhdCBvY2N1cmVkXG4gICAqIG9uIGFuIGBFbGVtZW50YCBub2RlLlxuICAgKiBAcGFyYW0gdG9wTGV2ZWxUeXBlIHtPYmplY3R9IEEgdHlwZSBmcm9tIGBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzYFxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBub2RlIFRoZSBkb20gdG8gc2ltdWxhdGUgYW4gZXZlbnQgb2NjdXJyaW5nIG9uLlxuICAgKiBAcGFyYW0gez9FdmVudH0gZmFrZU5hdGl2ZUV2ZW50IEZha2UgbmF0aXZlIGV2ZW50IHRvIHVzZSBpbiBTeW50aGV0aWNFdmVudC5cbiAgICovXG4gIHNpbXVsYXRlTmF0aXZlRXZlbnRPbk5vZGU6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5vZGUsIGZha2VOYXRpdmVFdmVudCkge1xuICAgIGZha2VOYXRpdmVFdmVudC50YXJnZXQgPSBub2RlO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudCh0b3BMZXZlbFR5cGUsIGZha2VOYXRpdmVFdmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyBhIHRvcCBsZXZlbCBldmVudCBiZWluZyBkaXNwYXRjaGVkIGZyb20gYSByYXcgZXZlbnQgdGhhdCBvY2N1cmVkXG4gICAqIG9uIHRoZSBgUmVhY3RET01Db21wb25lbnRgIGBjb21wYC5cbiAgICogQHBhcmFtIHRvcExldmVsVHlwZSB7T2JqZWN0fSBBIHR5cGUgZnJvbSBgRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc2AuXG4gICAqIEBwYXJhbSBjb21wIHshUmVhY3RET01Db21wb25lbnR9XG4gICAqIEBwYXJhbSB7P0V2ZW50fSBmYWtlTmF0aXZlRXZlbnQgRmFrZSBuYXRpdmUgZXZlbnQgdG8gdXNlIGluIFN5bnRoZXRpY0V2ZW50LlxuICAgKi9cbiAgc2ltdWxhdGVOYXRpdmVFdmVudE9uRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBjb21wLCBmYWtlTmF0aXZlRXZlbnQpIHtcbiAgICBSZWFjdFRlc3RVdGlscy5zaW11bGF0ZU5hdGl2ZUV2ZW50T25Ob2RlKHRvcExldmVsVHlwZSwgZmluZERPTU5vZGUoY29tcCksIGZha2VOYXRpdmVFdmVudCk7XG4gIH0sXG5cbiAgbmF0aXZlVG91Y2hEYXRhOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3VjaGVzOiBbeyBwYWdlWDogeCwgcGFnZVk6IHkgfV1cbiAgICB9O1xuICB9LFxuXG4gIGNyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFjdFNoYWxsb3dSZW5kZXJlcigpO1xuICB9LFxuXG4gIFNpbXVsYXRlOiBudWxsLFxuICBTaW11bGF0ZU5hdGl2ZToge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2hhbGxvd1JlbmRlcmVyXG4gKi9cbnZhciBSZWFjdFNoYWxsb3dSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xufTtcblxuUmVhY3RTaGFsbG93UmVuZGVyZXIucHJvdG90eXBlLmdldFJlbmRlck91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudCAmJiB0aGlzLl9pbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3JlbmRlcmVkT3V0cHV0IHx8IG51bGw7XG59O1xuXG52YXIgTm9vcEludGVybmFsQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5fcmVuZGVyZWRPdXRwdXQgPSBlbGVtZW50O1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgPyBSZWFjdEVtcHR5Q29tcG9uZW50LmVtcHR5RWxlbWVudCA6IGVsZW1lbnQ7XG59O1xuXG5Ob29wSW50ZXJuYWxDb21wb25lbnQucHJvdG90eXBlID0ge1xuXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX3JlbmRlcmVkT3V0cHV0ID0gZWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgPyBSZWFjdEVtcHR5Q29tcG9uZW50LmVtcHR5RWxlbWVudCA6IGVsZW1lbnQ7XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge31cblxufTtcblxudmFyIFNoYWxsb3dDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKCkge307XG5hc3NpZ24oU2hhbGxvd0NvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IE5vb3BJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KTtcbiAgfSxcbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uICgpIHt9LFxuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbi5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0XG59KTtcblxuUmVhY3RTaGFsbG93UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgfVxuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgdGhpcy5fcmVuZGVyKGVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59O1xuXG5SZWFjdFNoYWxsb3dSZW5kZXJlci5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgdGhpcy5faW5zdGFuY2UudW5tb3VudENvbXBvbmVudCgpO1xuICB9XG59O1xuXG5SZWFjdFNoYWxsb3dSZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgdmFyIHJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IFNoYWxsb3dDb21wb25lbnRXcmFwcGVyKGVsZW1lbnQudHlwZSk7XG4gICAgaW5zdGFuY2UuY29uc3RydWN0KGVsZW1lbnQpO1xuXG4gICAgaW5zdGFuY2UubW91bnRDb21wb25lbnQocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2luc3RhbmNlLnJlY2VpdmVDb21wb25lbnQoZWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4cG9ydHM6XG4gKlxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUuY2xpY2soRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZS5tb3VzZU1vdmUoRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZS5jaGFuZ2UoRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIC4uLiAoQWxsIGtleXMgZnJvbSBldmVudCBwbHVnaW4gYGV2ZW50VHlwZXNgIG9iamVjdHMpXG4gKi9cbmZ1bmN0aW9uIG1ha2VTaW11bGF0b3IoZXZlbnRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9tQ29tcG9uZW50T3JOb2RlLCBldmVudERhdGEpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAoUmVhY3RUZXN0VXRpbHMuaXNET01Db21wb25lbnQoZG9tQ29tcG9uZW50T3JOb2RlKSkge1xuICAgICAgbm9kZSA9IGZpbmRET01Ob2RlKGRvbUNvbXBvbmVudE9yTm9kZSk7XG4gICAgfSBlbHNlIGlmIChkb21Db21wb25lbnRPck5vZGUudGFnTmFtZSkge1xuICAgICAgbm9kZSA9IGRvbUNvbXBvbmVudE9yTm9kZTtcbiAgICB9XG5cbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50VHlwZV07XG5cbiAgICB2YXIgZmFrZU5hdGl2ZUV2ZW50ID0gbmV3IEV2ZW50KCk7XG4gICAgZmFrZU5hdGl2ZUV2ZW50LnRhcmdldCA9IG5vZGU7XG4gICAgLy8gV2UgZG9uJ3QgdXNlIFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZCBpbiBvcmRlciB0byBub3QgaGF2ZSB0byB3b3JyeSBhYm91dFxuICAgIC8vIHByb3Blcmx5IGRlc3Ryb3lpbmcgYW55IHByb3BlcnRpZXMgYXNzaWduZWQgZnJvbSBgZXZlbnREYXRhYCB1cG9uIHJlbGVhc2VcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIFJlYWN0TW91bnQuZ2V0SUQobm9kZSksIGZha2VOYXRpdmVFdmVudCk7XG4gICAgYXNzaWduKGV2ZW50LCBldmVudERhdGEpO1xuXG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50KTtcbiAgICB9XG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gICAgICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZSgpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFNpbXVsYXRvcnMoKSB7XG4gIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlID0ge307XG5cbiAgdmFyIGV2ZW50VHlwZTtcbiAgZm9yIChldmVudFR5cGUgaW4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUVsZW1lbnQgfHwgUmVhY3RET01Db21wb25lbnR9IGRvbUNvbXBvbmVudE9yTm9kZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnREYXRhIEZha2UgZXZlbnQgZGF0YSB0byB1c2UgaW4gU3ludGhldGljRXZlbnQuXG4gICAgICovXG4gICAgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVbZXZlbnRUeXBlXSA9IG1ha2VTaW11bGF0b3IoZXZlbnRUeXBlKTtcbiAgfVxufVxuXG4vLyBSZWJ1aWxkIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHdoZW5ldmVyIGV2ZW50IHBsdWdpbnMgYXJlIGluamVjdGVkXG52YXIgb2xkSW5qZWN0RXZlbnRQbHVnaW5PcmRlciA9IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyO1xuRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIG9sZEluamVjdEV2ZW50UGx1Z2luT3JkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgYnVpbGRTaW11bGF0b3JzKCk7XG59O1xudmFyIG9sZEluamVjdEV2ZW50UGx1Z2lucyA9IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWU7XG5FdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lID0gZnVuY3Rpb24gKCkge1xuICBvbGRJbmplY3RFdmVudFBsdWdpbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgYnVpbGRTaW11bGF0b3JzKCk7XG59O1xuXG5idWlsZFNpbXVsYXRvcnMoKTtcblxuLyoqXG4gKiBFeHBvcnRzOlxuICpcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlLmNsaWNrKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVOYXRpdmUubW91c2VNb3ZlKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVOYXRpdmUubW91c2VJbi9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZU5hdGl2ZS5tb3VzZU91dChFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gLi4uIChBbGwga2V5cyBmcm9tIGBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzYClcbiAqXG4gKiBOb3RlOiBUb3AgbGV2ZWwgZXZlbnQgdHlwZXMgYXJlIGEgc3Vic2V0IG9mIHRoZSBlbnRpcmUgc2V0IG9mIGhhbmRsZXIgdHlwZXNcbiAqICh3aGljaCBpbmNsdWRlIGEgYnJvYWRlciBzZXQgb2YgXCJzeW50aGV0aWNcIiBldmVudHMpLiBGb3IgZXhhbXBsZSwgb25EcmFnRG9uZVxuICogaXMgYSBzeW50aGV0aWMgZXZlbnQuIEV4Y2VwdCB3aGVuIHRlc3RpbmcgYW4gZXZlbnQgcGx1Z2luIG9yIFJlYWN0J3MgZXZlbnRcbiAqIGhhbmRsaW5nIGNvZGUgc3BlY2lmaWNhbGx5LCB5b3UgcHJvYmFibHkgd2FudCB0byB1c2UgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVcbiAqIHRvIGRpc3BhdGNoIHN5bnRoZXRpYyBldmVudHMuXG4gKi9cblxuZnVuY3Rpb24gbWFrZU5hdGl2ZVNpbXVsYXRvcihldmVudFR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkb21Db21wb25lbnRPck5vZGUsIG5hdGl2ZUV2ZW50RGF0YSkge1xuICAgIHZhciBmYWtlTmF0aXZlRXZlbnQgPSBuZXcgRXZlbnQoZXZlbnRUeXBlKTtcbiAgICBhc3NpZ24oZmFrZU5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudERhdGEpO1xuICAgIGlmIChSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChkb21Db21wb25lbnRPck5vZGUpKSB7XG4gICAgICBSZWFjdFRlc3RVdGlscy5zaW11bGF0ZU5hdGl2ZUV2ZW50T25ET01Db21wb25lbnQoZXZlbnRUeXBlLCBkb21Db21wb25lbnRPck5vZGUsIGZha2VOYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIGlmICghIWRvbUNvbXBvbmVudE9yTm9kZS50YWdOYW1lKSB7XG4gICAgICAvLyBXaWxsIGFsbG93IG9uIGFjdHVhbCBkb20gbm9kZXMuXG4gICAgICBSZWFjdFRlc3RVdGlscy5zaW11bGF0ZU5hdGl2ZUV2ZW50T25Ob2RlKGV2ZW50VHlwZSwgZG9tQ29tcG9uZW50T3JOb2RlLCBmYWtlTmF0aXZlRXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGV2ZW50VHlwZTtcbmZvciAoZXZlbnRUeXBlIGluIHRvcExldmVsVHlwZXMpIHtcbiAgLy8gRXZlbnQgdHlwZSBpcyBzdG9yZWQgYXMgJ3RvcENsaWNrJyAtIHdlIHRyYW5zZm9ybSB0aGF0IHRvICdjbGljaydcbiAgdmFyIGNvbnZlbmllbmNlTmFtZSA9IGV2ZW50VHlwZS5pbmRleE9mKCd0b3AnKSA9PT0gMCA/IGV2ZW50VHlwZS5jaGFyQXQoMykudG9Mb3dlckNhc2UoKSArIGV2ZW50VHlwZS5zdWJzdHIoNCkgOiBldmVudFR5cGU7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50IHx8IFJlYWN0RE9NQ29tcG9uZW50fSBkb21Db21wb25lbnRPck5vZGVcbiAgICogQHBhcmFtIHs/RXZlbnR9IG5hdGl2ZUV2ZW50RGF0YSBGYWtlIG5hdGl2ZSBldmVudCB0byB1c2UgaW4gU3ludGhldGljRXZlbnQuXG4gICAqL1xuICBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZU5hdGl2ZVtjb252ZW5pZW5jZU5hbWVdID0gbWFrZU5hdGl2ZVNpbXVsYXRvcihldmVudFR5cGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VGVzdFV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL1JlYWN0Q2hpbGRyZW5cIik7XG52YXIgUmVhY3RGcmFnbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RnJhZ21lbnRcIik7XG5cbnZhciBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcgPSB7XG4gIC8qKlxuICAgKiBHaXZlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmAsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBrZXkgdG8gY2hpbGQuIEp1c3RcbiAgICogc2ltcGxlIHN5bnRhY3RpYyBzdWdhciBhcm91bmQgUmVhY3RDaGlsZHJlbi5tYXAoKS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBjaGlsZHJlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmBcbiAgICogQHJldHVybiB7b2JqZWN0fSBNYXBwaW5nIG9mIGtleSB0byBjaGlsZFxuICAgKi9cbiAgZ2V0Q2hpbGRNYXBwaW5nOiBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiBSZWFjdEZyYWdtZW50LmV4dHJhY3QoUmVhY3RDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0pKTtcbiAgfSxcblxuICAvKipcbiAgICogV2hlbiB5b3UncmUgYWRkaW5nIG9yIHJlbW92aW5nIGNoaWxkcmVuIHNvbWUgbWF5IGJlIGFkZGVkIG9yIHJlbW92ZWQgaW4gdGhlXG4gICAqIHNhbWUgcmVuZGVyIHBhc3MuIFdlIHdhbnQgdG8gc2hvdyAqYm90aCogc2luY2Ugd2Ugd2FudCB0byBzaW11bHRhbmVvdXNseVxuICAgKiBhbmltYXRlIGVsZW1lbnRzIGluIGFuZCBvdXQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBwcmV2aW91cyBzZXQgb2Yga2V5c1xuICAgKiBhbmQgYSBuZXcgc2V0IG9mIGtleXMgYW5kIG1lcmdlcyB0aGVtIHdpdGggaXRzIGJlc3QgZ3Vlc3Mgb2YgdGhlIGNvcnJlY3RcbiAgICogb3JkZXJpbmcuIEluIHRoZSBmdXR1cmUgd2UgbWF5IGV4cG9zZSBzb21lIG9mIHRoZSB1dGlsaXRpZXMgaW5cbiAgICogUmVhY3RNdWx0aUNoaWxkIHRvIG1ha2UgdGhpcyBlYXN5LCBidXQgZm9yIG5vdyBSZWFjdCBpdHNlbGYgZG9lcyBub3RcbiAgICogZGlyZWN0bHkgaGF2ZSB0aGlzIGNvbmNlcHQgb2YgdGhlIHVuaW9uIG9mIHByZXZDaGlsZHJlbiBhbmQgbmV4dENoaWxkcmVuXG4gICAqIHNvIHdlIGltcGxlbWVudCBpdCBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldiBwcmV2IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAgICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0IG5leHQgY2hpbGRyZW4gYXMgcmV0dXJuZWQgZnJvbVxuICAgKiBgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZygpYC5cbiAgICogQHJldHVybiB7b2JqZWN0fSBhIGtleSBzZXQgdGhhdCBjb250YWlucyBhbGwga2V5cyBpbiBgcHJldmAgYW5kIGFsbCBrZXlzXG4gICAqIGluIGBuZXh0YCBpbiBhIHJlYXNvbmFibGUgb3JkZXIuXG4gICAqL1xuICBtZXJnZUNoaWxkTWFwcGluZ3M6IGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgcHJldiA9IHByZXYgfHwge307XG4gICAgbmV4dCA9IG5leHQgfHwge307XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZUZvcktleShrZXkpIHtcbiAgICAgIGlmIChuZXh0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmV2W2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIGVhY2gga2V5IG9mIGBuZXh0YCwgdGhlIGxpc3Qgb2Yga2V5cyB0byBpbnNlcnQgYmVmb3JlIHRoYXQga2V5IGluXG4gICAgLy8gdGhlIGNvbWJpbmVkIGxpc3RcbiAgICB2YXIgbmV4dEtleXNQZW5kaW5nID0ge307XG5cbiAgICB2YXIgcGVuZGluZ0tleXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcmV2S2V5IGluIHByZXYpIHtcbiAgICAgIGlmIChuZXh0Lmhhc093blByb3BlcnR5KHByZXZLZXkpKSB7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0S2V5c1BlbmRpbmdbcHJldktleV0gPSBwZW5kaW5nS2V5cztcbiAgICAgICAgICBwZW5kaW5nS2V5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nS2V5cy5wdXNoKHByZXZLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBjaGlsZE1hcHBpbmcgPSB7fTtcbiAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChuZXh0S2V5c1BlbmRpbmcuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwZW5kaW5nTmV4dEtleSA9IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXTtcbiAgICAgICAgICBjaGlsZE1hcHBpbmdbbmV4dEtleXNQZW5kaW5nW25leHRLZXldW2ldXSA9IGdldFZhbHVlRm9yS2V5KHBlbmRpbmdOZXh0S2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXldID0gZ2V0VmFsdWVGb3JLZXkobmV4dEtleSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgYWRkIHRoZSBrZXlzIHdoaWNoIGRpZG4ndCBhcHBlYXIgYmVmb3JlIGFueSBrZXkgaW4gYG5leHRgXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE1hcHBpbmdbcGVuZGluZ0tleXNbaV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ0tleXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZE1hcHBpbmc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRyYW5zaXRpb25FdmVudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG4vKipcbiAqIEVWRU5UX05BTUVfTUFQIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGV2ZW50IGZpcmVkIHdoZW4gYVxuICogdHJhbnNpdGlvbi9hbmltYXRpb24gZW5kcywgYmFzZWQgb24gdGhlIHN0eWxlIHByb3BlcnR5IHVzZWQgdG9cbiAqIGRlZmluZSB0aGF0IGV2ZW50LlxuICovXG52YXIgRVZFTlRfTkFNRV9NQVAgPSB7XG4gIHRyYW5zaXRpb25lbmQ6IHtcbiAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnTW96VHJhbnNpdGlvbic6ICdtb3pUcmFuc2l0aW9uRW5kJyxcbiAgICAnT1RyYW5zaXRpb24nOiAnb1RyYW5zaXRpb25FbmQnLFxuICAgICdtc1RyYW5zaXRpb24nOiAnTVNUcmFuc2l0aW9uRW5kJ1xuICB9LFxuXG4gIGFuaW1hdGlvbmVuZDoge1xuICAgICdhbmltYXRpb24nOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAnV2Via2l0QW5pbWF0aW9uJzogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgJ01vekFuaW1hdGlvbic6ICdtb3pBbmltYXRpb25FbmQnLFxuICAgICdPQW5pbWF0aW9uJzogJ29BbmltYXRpb25FbmQnLFxuICAgICdtc0FuaW1hdGlvbic6ICdNU0FuaW1hdGlvbkVuZCdcbiAgfVxufTtcblxudmFyIGVuZEV2ZW50cyA9IFtdO1xuXG5mdW5jdGlvbiBkZXRlY3RFdmVudHMoKSB7XG4gIHZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHN0eWxlID0gdGVzdEVsLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNlYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbVxuICAvLyBmcm9tIHRoZSBtYXBcbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gIH1cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxuXG4gIGZvciAodmFyIGJhc2VFdmVudE5hbWUgaW4gRVZFTlRfTkFNRV9NQVApIHtcbiAgICB2YXIgYmFzZUV2ZW50cyA9IEVWRU5UX05BTUVfTUFQW2Jhc2VFdmVudE5hbWVdO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBiYXNlRXZlbnRzKSB7XG4gICAgICBpZiAoc3R5bGVOYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGVuZEV2ZW50cy5wdXNoKGJhc2VFdmVudHNbc3R5bGVOYW1lXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGRldGVjdEV2ZW50cygpO1xufVxuXG4vLyBXZSB1c2UgdGhlIHJhdyB7YWRkfHJlbW92ZX1FdmVudExpc3RlbmVyKCkgY2FsbCBiZWNhdXNlIEV2ZW50TGlzdGVuZXJcbi8vIGRvZXMgbm90IGtub3cgaG93IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIHdlIHJlYWxseSBzaG91bGRcbi8vIGNsZWFuIHVwLiBBbHNvLCB0aGVzZSBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQgaW4gb2xkZXIgYnJvd3NlcnNcbi8vIHNvIHdlIHNob3VsZCBiZSBBLU9LIGhlcmUuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG52YXIgUmVhY3RUcmFuc2l0aW9uRXZlbnRzID0ge1xuICBhZGRFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAobm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBJZiBDU1MgdHJhbnNpdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQsIHRyaWdnZXIgYW4gXCJlbmQgYW5pbWF0aW9uXCJcbiAgICAgIC8vIGV2ZW50IGltbWVkaWF0ZWx5LlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZXZlbnRMaXN0ZW5lciwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbmRFdmVudCkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKG5vZGUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW5kRXZlbnQpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VHJhbnNpdGlvbkV2ZW50czsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUcmFuc2l0aW9uR3JvdXBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZyA9IHJlcXVpcmUoXCIuL1JlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZ1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgY2xvbmVXaXRoUHJvcHMgPSByZXF1aXJlKFwiLi9jbG9uZVdpdGhQcm9wc1wiKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0VHJhbnNpdGlvbkdyb3VwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjb21wb25lbnQ6IFJlYWN0LlByb3BUeXBlcy5hbnksXG4gICAgY2hpbGRGYWN0b3J5OiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wb25lbnQ6ICdzcGFuJyxcbiAgICAgIGNoaWxkRmFjdG9yeTogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50XG4gICAgfTtcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcodGhpcy5wcm9wcy5jaGlsZHJlbilcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXMgPSB7fTtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluaXRpYWxDaGlsZE1hcHBpbmcgPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuICAgIGZvciAodmFyIGtleSBpbiBpbml0aWFsQ2hpbGRNYXBwaW5nKSB7XG4gICAgICBpZiAoaW5pdGlhbENoaWxkTWFwcGluZ1trZXldKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUFwcGVhcihrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgdmFyIG5leHRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcy5jaGlsZHJlbik7XG4gICAgdmFyIHByZXZDaGlsZE1hcHBpbmcgPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjaGlsZHJlbjogUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLm1lcmdlQ2hpbGRNYXBwaW5ncyhwcmV2Q2hpbGRNYXBwaW5nLCBuZXh0Q2hpbGRNYXBwaW5nKVxuICAgIH0pO1xuXG4gICAgdmFyIGtleTtcblxuICAgIGZvciAoa2V5IGluIG5leHRDaGlsZE1hcHBpbmcpIHtcbiAgICAgIHZhciBoYXNQcmV2ID0gcHJldkNoaWxkTWFwcGluZyAmJiBwcmV2Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAobmV4dENoaWxkTWFwcGluZ1trZXldICYmICFoYXNQcmV2ICYmICF0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0pIHtcbiAgICAgICAgdGhpcy5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gcHJldkNoaWxkTWFwcGluZykge1xuICAgICAgdmFyIGhhc05leHQgPSBuZXh0Q2hpbGRNYXBwaW5nICYmIG5leHRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChwcmV2Q2hpbGRNYXBwaW5nW2tleV0gJiYgIWhhc05leHQgJiYgIXRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSkge1xuICAgICAgICB0aGlzLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSB3YW50IHRvIHNvbWVkYXkgY2hlY2sgZm9yIHJlb3JkZXJpbmcsIHdlIGNvdWxkIGRvIGl0IGhlcmUuXG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleXNUb0VudGVyID0gdGhpcy5rZXlzVG9FbnRlcjtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAga2V5c1RvRW50ZXIuZm9yRWFjaCh0aGlzLnBlcmZvcm1FbnRlcik7XG5cbiAgICB2YXIga2V5c1RvTGVhdmUgPSB0aGlzLmtleXNUb0xlYXZlO1xuICAgIHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcbiAgICBrZXlzVG9MZWF2ZS5mb3JFYWNoKHRoaXMucGVyZm9ybUxlYXZlKTtcbiAgfSxcblxuICBwZXJmb3JtQXBwZWFyOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldID0gdHJ1ZTtcblxuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcblxuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbEFwcGVhcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxBcHBlYXIodGhpcy5faGFuZGxlRG9uZUFwcGVhcmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYW5kbGVEb25lQXBwZWFyaW5nKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVEb25lQXBwZWFyaW5nOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkQXBwZWFyKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkQXBwZWFyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XTtcblxuICAgIHZhciBjdXJyZW50Q2hpbGRNYXBwaW5nID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmICghY3VycmVudENoaWxkTWFwcGluZyB8fCAhY3VycmVudENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBUaGlzIHdhcyByZW1vdmVkIGJlZm9yZSBpdCBoYWQgZnVsbHkgYXBwZWFyZWQuIFJlbW92ZSBpdC5cbiAgICAgIHRoaXMucGVyZm9ybUxlYXZlKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIHBlcmZvcm1FbnRlcjogZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSA9IHRydWU7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG5cbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcih0aGlzLl9oYW5kbGVEb25lRW50ZXJpbmcuYmluZCh0aGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlRG9uZUVudGVyaW5nKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVEb25lRW50ZXJpbmc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRFbnRlcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudERpZEVudGVyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XTtcblxuICAgIHZhciBjdXJyZW50Q2hpbGRNYXBwaW5nID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmICghY3VycmVudENoaWxkTWFwcGluZyB8fCAhY3VycmVudENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBUaGlzIHdhcyByZW1vdmVkIGJlZm9yZSBpdCBoYWQgZnVsbHkgZW50ZXJlZC4gUmVtb3ZlIGl0LlxuICAgICAgdGhpcy5wZXJmb3JtTGVhdmUoa2V5KTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUxlYXZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldID0gdHJ1ZTtcblxuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxMZWF2ZSkge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxMZWF2ZSh0aGlzLl9oYW5kbGVEb25lTGVhdmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBzb21ld2hhdCBkYW5nZXJvdXMgYi9jIGl0IGNhbGxzIHNldFN0YXRlKClcbiAgICAgIC8vIGFnYWluLCBlZmZlY3RpdmVseSBtdXRhdGluZyB0aGUgY29tcG9uZW50IGJlZm9yZSBhbGwgdGhlIHdvcmtcbiAgICAgIC8vIGlzIGRvbmUuXG4gICAgICB0aGlzLl9oYW5kbGVEb25lTGVhdmluZyhrZXkpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlRG9uZUxlYXZpbmc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG5cbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZExlYXZlKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkTGVhdmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldO1xuXG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGN1cnJlbnRDaGlsZE1hcHBpbmcgJiYgY3VycmVudENoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAvLyBUaGlzIGVudGVyZWQgYWdhaW4gYmVmb3JlIGl0IGZ1bGx5IGxlZnQuIEFkZCBpdCBhZ2Fpbi5cbiAgICAgIHRoaXMucGVyZm9ybUVudGVyKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGFzc2lnbih7fSwgc3RhdGUuY2hpbGRyZW4pO1xuICAgICAgICBkZWxldGUgbmV3Q2hpbGRyZW5ba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgY2hpbGRyZW46IG5ld0NoaWxkcmVuIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETzogd2UgY291bGQgZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3IgdGhlIHdyYXBwZXIgbm9kZVxuICAgIC8vIGJ5IGNsb25pbmcgYSBzaW5nbGUgY2hpbGRcbiAgICB2YXIgY2hpbGRyZW5Ub1JlbmRlciA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnN0YXRlLmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLnN0YXRlLmNoaWxkcmVuW2tleV07XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgLy8gWW91IG1heSBuZWVkIHRvIGFwcGx5IHJlYWN0aXZlIHVwZGF0ZXMgdG8gYSBjaGlsZCBhcyBpdCBpcyBsZWF2aW5nLlxuICAgICAgICAvLyBUaGUgbm9ybWFsIFJlYWN0IHdheSB0byBkbyBpdCB3b24ndCB3b3JrIHNpbmNlIHRoZSBjaGlsZCB3aWxsIGhhdmVcbiAgICAgICAgLy8gYWxyZWFkeSBiZWVuIHJlbW92ZWQuIEluIGNhc2UgeW91IG5lZWQgdGhpcyBiZWhhdmlvciB5b3UgY2FuIHByb3ZpZGVcbiAgICAgICAgLy8gYSBjaGlsZEZhY3RvcnkgZnVuY3Rpb24gdG8gd3JhcCBldmVyeSBjaGlsZCwgZXZlbiB0aGUgb25lcyB0aGF0IGFyZVxuICAgICAgICAvLyBsZWF2aW5nLlxuICAgICAgICBjaGlsZHJlblRvUmVuZGVyLnB1c2goY2xvbmVXaXRoUHJvcHModGhpcy5wcm9wcy5jaGlsZEZhY3RvcnkoY2hpbGQpLCB7IHJlZjoga2V5LCBrZXk6IGtleSB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuY29tcG9uZW50LCB0aGlzLnByb3BzLCBjaGlsZHJlblRvUmVuZGVyKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uR3JvdXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RMaWZlQ3ljbGUgPSByZXF1aXJlKFwiLi9SZWFjdExpZmVDeWNsZVwiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZU1hcFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlICE9PSBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlNb3VudGluZ0luc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gYSBjb21wb25lbnRXaWxsTW91bnQgaGFuZGxlciwgZG9uJ3QgZW5xdWV1ZSBhIHJlcmVuZGVyXG4gICAgLy8gYmVjYXVzZSBSZWFjdFVwZGF0ZXMgYXNzdW1lcyB3ZSdyZSBpbiBhIGJyb3dzZXIgY29udGV4dCAod2hpY2ggaXNcbiAgICAvLyB3cm9uZyBmb3Igc2VydmVyIHJlbmRlcmluZykgYW5kIHdlJ3JlIGFib3V0IHRvIGRvIGEgcmVuZGVyIGFueXdheS5cbiAgICAvLyBTZWUgYnVnIGluICMxNzQwLlxuICAgIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICAhKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAnICsgJyhzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGUuJywgY2FsbGVyTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCAnICsgJ2NvbXBvbmVudC4gVGhpcyBpcyBhIG5vLW9wLicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlVbm1vdW50aW5nSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZW5xdWV1ZUNhbGxiYWNrKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCwgYHJlcGxhY2VQcm9wc2AsICcgKyAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArICdpc25cXCd0IGNhbGxhYmxlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG5cbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXG4gICAgLy8gaW5zdGFuY2UuIFNpbmNlIHdlIHdhbnQgdG8gbWFrZSBpdCBhIG5vLW9wIGluc3RlYWQsIHdlIG1pcnJvciB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxuICAgIC8vIGVucXVldWVVcGRhdGVzLlxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSB8fCBpbnRlcm5hbEluc3RhbmNlID09PSBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlNb3VudGluZ0luc3RhbmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIC8vIFRPRE86IFRoZSBjYWxsYmFjayBoZXJlIGlzIGlnbm9yZWQgd2hlbiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbVxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXG4gICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gZGlzYWxsb3dcbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZHVyaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVDYWxsYmFja0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZW5xdWV1ZUNhbGxiYWNrKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCwgYHJlcGxhY2VQcm9wc2AsICcgKyAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArICdpc25cXCd0IGNhbGxhYmxlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRVcGRhdGVDb21wb25lbnRgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxQcm9wcykge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0UHJvcHMnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICFpbnRlcm5hbEluc3RhbmNlLl9pc1RvcExldmVsID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3NldFByb3BzKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCBvbiBhICcgKyAnY29tcG9uZW50IHdpdGggYSBwYXJlbnQuIFRoaXMgaXMgYW4gYW50aS1wYXR0ZXJuIHNpbmNlIHByb3BzIHdpbGwgJyArICdnZXQgcmVhY3RpdmVseSB1cGRhdGVkIHdoZW4gcmVuZGVyZWQuIEluc3RlYWQsIGNoYW5nZSB0aGUgb3duZXJcXCdzICcgKyAnYHJlbmRlcmAgbWV0aG9kIHRvIHBhc3MgdGhlIGNvcnJlY3QgdmFsdWUgYXMgcHJvcHMgdG8gdGhlIGNvbXBvbmVudCAnICsgJ3doZXJlIGl0IGlzIGNyZWF0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gTWVyZ2Ugd2l0aCB0aGUgcGVuZGluZyBlbGVtZW50IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHdpdGggZXhpc3RpbmdcbiAgICAvLyBlbGVtZW50IHByb3BzLlxuICAgIHZhciBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0VsZW1lbnQgfHwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzLCBwYXJ0aWFsUHJvcHMpO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIHByb3BzKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VQcm9wcycpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgIWludGVybmFsSW5zdGFuY2UuX2lzVG9wTGV2ZWwgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAncmVwbGFjZVByb3BzKC4uLik6IFlvdSBjYWxsZWQgYHJlcGxhY2VQcm9wc2Agb24gYSAnICsgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgKyAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArICd3aGVyZSBpdCBpcyBjcmVhdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgLy8gZWxlbWVudCBwcm9wcy5cbiAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50IHx8IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIHByb3BzKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5ld0VsZW1lbnQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5ld0VsZW1lbnQ7XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKFwiLi9DYWxsYmFja1F1ZXVlXCIpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZShcIi4vUmVhY3RSZWNvbmNpbGVyXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIGRpcnR5Q29tcG9uZW50cyA9IFtdO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyAnICsgJ3N0cmF0ZWd5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG59XG5cbmFzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gJyArICdtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxuICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XG4gICAgICB2YXIgcXVldWUgPSBhc2FwQ2FsbGJhY2tRdWV1ZTtcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xuICAgICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbn07XG5mbHVzaEJhdGNoZWRVcGRhdGVzID0gUmVhY3RQZXJmLm1lYXN1cmUoJ1JlYWN0VXBkYXRlcycsICdmbHVzaEJhdGNoZWRVcGRhdGVzJywgZmx1c2hCYXRjaGVkVXBkYXRlcyk7XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcblxuICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxuICAvLyBmdW5jdGlvbiwgbGlrZSBzZXRQcm9wcywgc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcbiAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnZW5xdWV1ZVVwZGF0ZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzICcgKyAnYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgJyArICdhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuJykgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhlbnF1ZXVlVXBkYXRlLCBjb21wb25lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpcnR5Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcbiAqIGlmIG5vIHVwZGF0ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwZXJmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzLmFzYXA6IENhblxcJ3QgZW5xdWV1ZSBhbiBhc2FwIGNhbGxiYWNrIGluIGEgY29udGV4dCB3aGVyZScgKyAndXBkYXRlcyBhcmUgbm90IGJlaW5nIGJhdGNoZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBhc2FwQ2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgYXNhcEVucXVldWVkID0gdHJ1ZTtcbn1cblxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcbiAgaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChSZWNvbmNpbGVUcmFuc2FjdGlvbikge1xuICAgICFSZWNvbmNpbGVUcmFuc2FjdGlvbiA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIGluamVjdEJhdGNoaW5nU3RyYXRlZ3k6IGZ1bmN0aW9uIChfYmF0Y2hpbmdTdHJhdGVneSkge1xuICAgICFfYmF0Y2hpbmdTdHJhdGVneSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoZWRVcGRhdGVzKCkgZnVuY3Rpb24nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgYmF0Y2hpbmdTdHJhdGVneSA9IF9iYXRjaGluZ1N0cmF0ZWd5O1xuICB9XG59O1xuXG52YXIgUmVhY3RVcGRhdGVzID0ge1xuICAvKipcbiAgICogUmVhY3QgcmVmZXJlbmNlcyBgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbmAgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiBvcmRlclxuICAgKiB0byBhbGxvdyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBudWxsLFxuXG4gIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgZW5xdWV1ZVVwZGF0ZTogZW5xdWV1ZVVwZGF0ZSxcbiAgZmx1c2hCYXRjaGVkVXBkYXRlczogZmx1c2hCYXRjaGVkVXBkYXRlcyxcbiAgaW5qZWN0aW9uOiBSZWFjdFVwZGF0ZXNJbmplY3Rpb24sXG4gIGFzYXA6IGFzYXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFdpdGhBZGRvbnNcbiAqL1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGV4aXN0cyBwdXJlbHkgaW4gdGhlIG9wZW4gc291cmNlIHByb2plY3QsIGFuZCBpcyBtZWFudCBhcyBhIHdheVxuICogdG8gY3JlYXRlIGEgc2VwYXJhdGUgc3RhbmRhbG9uZSBidWlsZCBvZiBSZWFjdC4gVGhpcyBidWlsZCBoYXMgXCJhZGRvbnNcIiwgb3JcbiAqIGZ1bmN0aW9uYWxpdHkgd2UndmUgYnVpbHQgYW5kIHRoaW5rIG1pZ2h0IGJlIHVzZWZ1bCBidXQgZG9lc24ndCBoYXZlIGEgZ29vZFxuICogcGxhY2UgdG8gbGl2ZSBpbnNpZGUgUmVhY3QgY29yZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaW5rZWRTdGF0ZU1peGluID0gcmVxdWlyZShcIi4vTGlua2VkU3RhdGVNaXhpblwiKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xudmFyIFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpblwiKTtcbnZhciBSZWFjdENTU1RyYW5zaXRpb25Hcm91cCA9IHJlcXVpcmUoXCIuL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwXCIpO1xudmFyIFJlYWN0RnJhZ21lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEZyYWdtZW50XCIpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gcmVxdWlyZShcIi4vUmVhY3RUcmFuc2l0aW9uR3JvdXBcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xuXG52YXIgY2xvbmVXaXRoUHJvcHMgPSByZXF1aXJlKFwiLi9jbG9uZVdpdGhQcm9wc1wiKTtcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoXCIuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXCIpO1xudmFyIHNoYWxsb3dDb21wYXJlID0gcmVxdWlyZShcIi4vc2hhbGxvd0NvbXBhcmVcIik7XG52YXIgdXBkYXRlID0gcmVxdWlyZShcIi4vdXBkYXRlXCIpO1xuXG5SZWFjdC5hZGRvbnMgPSB7XG4gIENTU1RyYW5zaXRpb25Hcm91cDogUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAsXG4gIExpbmtlZFN0YXRlTWl4aW46IExpbmtlZFN0YXRlTWl4aW4sXG4gIFB1cmVSZW5kZXJNaXhpbjogUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluLFxuICBUcmFuc2l0aW9uR3JvdXA6IFJlYWN0VHJhbnNpdGlvbkdyb3VwLFxuXG4gIGJhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIGNsb25lV2l0aFByb3BzOiBjbG9uZVdpdGhQcm9wcyxcbiAgY3JlYXRlRnJhZ21lbnQ6IFJlYWN0RnJhZ21lbnQuY3JlYXRlLFxuICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsXG4gIHNoYWxsb3dDb21wYXJlOiBzaGFsbG93Q29tcGFyZSxcbiAgdXBkYXRlOiB1cGRhdGVcbn07XG5cbmlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIFJlYWN0LmFkZG9ucy5QZXJmID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0UGVyZlwiKTtcbiAgUmVhY3QuYWRkb25zLlRlc3RVdGlscyA9IHJlcXVpcmUoXCIuL1JlYWN0VGVzdFV0aWxzXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG5cbnZhciBNVVNUX1VTRV9BVFRSSUJVVEUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFO1xuXG52YXIgTlMgPSB7XG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGNsaXBQYXRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3g6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZmlsbDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGxPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9udEZhbWlseTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRTaXplOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZng6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZ3JhZGllbnRVbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlckVuZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlck1pZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlclN0YXJ0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgb2Zmc2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgb3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBhdHRlcm5Db250ZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuVW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwb2ludHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzcHJlYWRNZXRob2Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdG9wQ29sb3I6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdG9wT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZURhc2hhcnJheTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZUxpbmVjYXA6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlV2lkdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB0ZXh0QW5jaG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdHJhbnNmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdmVyc2lvbjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZpZXdCb3g6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHgyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rQWN0dWF0ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rQXJjcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rSHJlZjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rUm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rU2hvdzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rVGl0bGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1R5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxCYXNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sTGFuZzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbFNwYWNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHk6IE1VU1RfVVNFX0FUVFJJQlVURVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgY2xpcFBhdGg6ICdjbGlwLXBhdGgnLFxuICAgIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICAgIGZvbnRTaXplOiAnZm9udC1zaXplJyxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gICAgbWFya2VyRW5kOiAnbWFya2VyLWVuZCcsXG4gICAgbWFya2VyTWlkOiAnbWFya2VyLW1pZCcsXG4gICAgbWFya2VyU3RhcnQ6ICdtYXJrZXItc3RhcnQnLFxuICAgIHBhdHRlcm5Db250ZW50VW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgICBzcHJlYWRNZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICAgIHN0b3BDb2xvcjogJ3N0b3AtY29sb3InLFxuICAgIHN0b3BPcGFjaXR5OiAnc3RvcC1vcGFjaXR5JyxcbiAgICBzdHJva2VEYXNoYXJyYXk6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICAgIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gICAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICAgIHRleHRBbmNob3I6ICd0ZXh0LWFuY2hvcicsXG4gICAgdmlld0JveDogJ3ZpZXdCb3gnLFxuICAgIHhsaW5rQWN0dWF0ZTogJ3hsaW5rOmFjdHVhdGUnLFxuICAgIHhsaW5rQXJjcm9sZTogJ3hsaW5rOmFyY3JvbGUnLFxuICAgIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxuICAgIHhsaW5rUm9sZTogJ3hsaW5rOnJvbGUnLFxuICAgIHhsaW5rU2hvdzogJ3hsaW5rOnNob3cnLFxuICAgIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXG4gICAgeGxpbmtUeXBlOiAneGxpbms6dHlwZScsXG4gICAgeG1sQmFzZTogJ3htbDpiYXNlJyxcbiAgICB4bWxMYW5nOiAneG1sOmxhbmcnLFxuICAgIHhtbFNwYWNlOiAneG1sOnNwYWNlJ1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0RPTVByb3BlcnR5Q29uZmlnOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWxlY3RFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoXCIuL0V2ZW50UHJvcGFnYXRvcnNcIik7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0SW5wdXRTZWxlY3Rpb25cIik7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKFwiLi9nZXRBY3RpdmVFbGVtZW50XCIpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoXCIuL2lzVGV4dElucHV0RWxlbWVudFwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuL3NoYWxsb3dFcXVhbFwiKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlbGVjdENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudSwgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLlxudmFyIGhhc0xpc3RlbmVyID0gZmFsc2U7XG52YXIgT05fU0VMRUNUX0tFWSA9IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSk7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50ID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SUQsIG5hdGl2ZUV2ZW50KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuXG4gICAgaWYgKCFoYXNMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRvcExldmVsVGFyZ2V0KSB8fCB0b3BMZXZlbFRhcmdldC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fU0VMRUNUX0tFWSkge1xuICAgICAgaGFzTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VydmVyUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpemUgb2YgdGhlIHJlYWN0Um9vdCBJRCBzcGFjZS4gV2UgZ2VuZXJhdGUgcmFuZG9tIG51bWJlcnMgZm9yIFJlYWN0IHJvb3RcbiAqIElEcyBhbmQgaWYgdGhlcmUncyBhIGNvbGxpc2lvbiB0aGUgZXZlbnRzIGFuZCBET00gdXBkYXRlIHN5c3RlbSB3aWxsXG4gKiBnZXQgY29uZnVzZWQuIEluIHRoZSBmdXR1cmUgd2UgbmVlZCBhIHdheSB0byBnZW5lcmF0ZSBHVUlEcyBidXQgZm9yXG4gKiBub3cgdGhpcyB3aWxsIHdvcmsgb24gYSBzbWFsbGVyIHNjYWxlLlxuICovXG52YXIgR0xPQkFMX01PVU5UX1BPSU5UX01BWCA9IE1hdGgucG93KDIsIDUzKTtcblxudmFyIFNlcnZlclJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZlclJlYWN0Um9vdEluZGV4OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL0V2ZW50TGlzdGVuZXJcIik7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luVXRpbHNcIik7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoXCIuL0V2ZW50UHJvcGFnYXRvcnNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudFwiKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNGb2N1c0V2ZW50XCIpO1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50XCIpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNNb3VzZUV2ZW50XCIpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0RyYWdFdmVudFwiKTtcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljVG91Y2hFdmVudFwiKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljVUlFdmVudFwiKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljV2hlZWxFdmVudFwiKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudENoYXJDb2RlXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBibHVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25CbHVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CbHVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db3B5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db3B5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkN1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Eb3VibGVDbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VudGVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0V4aXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0xlYXZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnTGVhdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ092ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJvcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJvcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJvcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGZvY3VzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Gb2N1czogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRm9jdXNDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW5wdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbklucHV0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5RG93bjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5RG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5RG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVByZXNzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlQcmVzczogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5UHJlc3NDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5VXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVVwQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVycm9yOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FcnJvcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRXJyb3JDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlRG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU91dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXN0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGFzdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmVzZXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJlc2V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TY3JvbGw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNjcm9sbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VibWl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdWJtaXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaENhbmNlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaEVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2hlZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbldoZWVsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XaGVlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gIHRvcEJsdXI6IGV2ZW50VHlwZXMuYmx1cixcbiAgdG9wQ2xpY2s6IGV2ZW50VHlwZXMuY2xpY2ssXG4gIHRvcENvbnRleHRNZW51OiBldmVudFR5cGVzLmNvbnRleHRNZW51LFxuICB0b3BDb3B5OiBldmVudFR5cGVzLmNvcHksXG4gIHRvcEN1dDogZXZlbnRUeXBlcy5jdXQsXG4gIHRvcERvdWJsZUNsaWNrOiBldmVudFR5cGVzLmRvdWJsZUNsaWNrLFxuICB0b3BEcmFnOiBldmVudFR5cGVzLmRyYWcsXG4gIHRvcERyYWdFbmQ6IGV2ZW50VHlwZXMuZHJhZ0VuZCxcbiAgdG9wRHJhZ0VudGVyOiBldmVudFR5cGVzLmRyYWdFbnRlcixcbiAgdG9wRHJhZ0V4aXQ6IGV2ZW50VHlwZXMuZHJhZ0V4aXQsXG4gIHRvcERyYWdMZWF2ZTogZXZlbnRUeXBlcy5kcmFnTGVhdmUsXG4gIHRvcERyYWdPdmVyOiBldmVudFR5cGVzLmRyYWdPdmVyLFxuICB0b3BEcmFnU3RhcnQ6IGV2ZW50VHlwZXMuZHJhZ1N0YXJ0LFxuICB0b3BEcm9wOiBldmVudFR5cGVzLmRyb3AsXG4gIHRvcEVycm9yOiBldmVudFR5cGVzLmVycm9yLFxuICB0b3BGb2N1czogZXZlbnRUeXBlcy5mb2N1cyxcbiAgdG9wSW5wdXQ6IGV2ZW50VHlwZXMuaW5wdXQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BSZXNldDogZXZlbnRUeXBlcy5yZXNldCxcbiAgdG9wU2Nyb2xsOiBldmVudFR5cGVzLnNjcm9sbCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wVG91Y2hDYW5jZWw6IGV2ZW50VHlwZXMudG91Y2hDYW5jZWwsXG4gIHRvcFRvdWNoRW5kOiBldmVudFR5cGVzLnRvdWNoRW5kLFxuICB0b3BUb3VjaE1vdmU6IGV2ZW50VHlwZXMudG91Y2hNb3ZlLFxuICB0b3BUb3VjaFN0YXJ0OiBldmVudFR5cGVzLnRvdWNoU3RhcnQsXG4gIHRvcFdoZWVsOiBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0eXBlIGluIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZykge1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdHlwZV0uZGVwZW5kZW5jaWVzID0gW3R5cGVdO1xufVxuXG52YXIgT05fQ0xJQ0tfS0VZID0ga2V5T2YoeyBvbkNsaWNrOiBudWxsIH0pO1xudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIGV4Y2VwdCBjYW5jZWxzIHRoZSBldmVudCB3aGVuIHJldHVyblxuICAgKiB2YWx1ZSBpcyBmYWxzZS4gVGhpcyBiZWhhdmlvciB3aWxsIGJlIGRpc2FibGVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBFdmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRvbUlEIERPTSBJRCB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIGV4ZWN1dGVEaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lciwgZG9tSUQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaChldmVudCwgbGlzdGVuZXIsIGRvbUlEKTtcblxuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHR5cGVvZiByZXR1cm5WYWx1ZSAhPT0gJ2Jvb2xlYW4nLCAnUmV0dXJuaW5nIGBmYWxzZWAgZnJvbSBhbiBldmVudCBoYW5kbGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgJyArICdpZ25vcmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIEluc3RlYWQsIG1hbnVhbGx5IGNhbGwgJyArICdlLnN0b3BQcm9wYWdhdGlvbigpIG9yIGUucHJldmVudERlZmF1bHQoKSwgYXMgYXBwcm9wcmlhdGUuJykgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcElucHV0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmVzZXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VibWl0OlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgLy8gRmlyZUZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEb3VibGVDbGljazpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbnRlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRXhpdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnTGVhdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ092ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ1N0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyb3A6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0OlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Nyb2xsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2hlZWw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb3B5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEN1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLicsIHRvcExldmVsVHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2lkXTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljTW91c2VFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoXCIuL2dldEV2ZW50VGFyZ2V0XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogZ2V0RXZlbnRUYXJnZXQsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IGRpc3BhdGNoTWFya2VyO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG59XG5cbmFzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBudWxsO1xuICAgIHRoaXMuZGlzcGF0Y2hNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICBhc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IGFzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy50aHJlZUFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MudGhyZWVBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0ZvY3VzRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0lucHV0RXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0tleWJvYXJkRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRDaGFyQ29kZVwiKTtcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50S2V5XCIpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZVwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNNb3VzZUV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNVSUV2ZW50XCIpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoXCIuL1ZpZXdwb3J0TWV0cmljc1wiKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZVwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVG91Y2hFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljVUlFdmVudFwiKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZVwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVG91Y2hFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVUlFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKFwiLi9nZXRFdmVudFRhcmdldFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC53aW5kb3cgPT09IHRhcmdldCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgIGlmIChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gIH0sXG4gIGRldGFpbDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNNb3VzZUV2ZW50XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwZGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgdGhpcyBpbnN0YW5jZSBzbyB0aGF0IGl0IGlzIHByZXBhcmVkIGZvciBjb2xsZWN0aW5nIG1ldHJpY3MuIERvZXNcbiAgICogc28gc3VjaCB0aGF0IHRoaXMgc2V0dXAgbWV0aG9kIG1heSBiZSB1c2VkIG9uIGFuIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeVxuICAgKiBpbml0aWFsaXplZCwgaW4gYSB3YXkgdGhhdCBkb2VzIG5vdCBjb25zdW1lIGFkZGl0aW9uYWwgbWVtb3J5IHVwb24gcmV1c2UuXG4gICAqIFRoYXQgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgZGVjaWRlIHRvIG1ha2UgeW91ciBzdWJjbGFzcyBvZiB0aGlzIG1peGluIGFcbiAgICogXCJQb29sZWRDbGFzc1wiLlxuICAgKi9cbiAgcmVpbml0aWFsaXplVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLmdldFRyYW5zYWN0aW9uV3JhcHBlcnMoKTtcbiAgICBpZiAoIXRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGFyZ3MuLi4gQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZCAob3B0aW9uYWwpLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIEhlbHBzIHByZXZlbnQgbmVlZCB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gYG1ldGhvZGAuXG4gICAqL1xuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICEhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSAnICsgJ2lzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBlcnJvclRocm93bjtcbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgIC8vIG9uZSBvZiB0aGVzZSBjYWxscyB0aHJldy5cbiAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbCgwKTtcbiAgICAgIHJldCA9IG1ldGhvZC5jYWxsKHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIElmIGBtZXRob2RgIHRocm93cywgcHJlZmVyIHRvIHNob3cgdGhhdCBzdGFjayB0cmFjZSBvdmVyIGFueSB0aHJvd25cbiAgICAgICAgICAvLyBieSBpbnZva2luZyBgY2xvc2VBbGxgLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5jZSBgbWV0aG9kYCBkaWRuJ3QgdGhyb3csIHdlIGRvbid0IHdhbnQgdG8gc2lsZW5jZSB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBpbml0aWFsaXplQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgPyB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGFbaV0gPT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SKSB7XG4gICAgICAgICAgLy8gVGhlIGluaXRpYWxpemVyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgLy8gcmVtYWluaW5nIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IHRoZSBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgZWFjaCBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmNsb3NlW2ldYCBmdW5jdGlvbnMsIHBhc3NpbmcgaW50b1xuICAgKiB0aGVtIHRoZSByZXNwZWN0aXZlIHJldHVybiB2YWx1ZXMgb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5pbml0W2ldYFxuICAgKiAoYGNsb3NlYHJzIHRoYXQgY29ycmVzcG9uZCB0byBpbml0aWFsaXplcnMgdGhhdCBmYWlsZWQgd2lsbCBub3QgYmVcbiAgICogaW52b2tlZCkuXG4gICAqL1xuICBjbG9zZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbnZhciBUcmFuc2FjdGlvbiA9IHtcblxuICBNaXhpbjogTWl4aW4sXG5cbiAgLyoqXG4gICAqIFRva2VuIHRvIGxvb2sgZm9yIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBvY2N1cmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICB2YXIgY3VycmVudElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGN1cnJlbnQpO1xuICB2YXIgbmV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5leHQpO1xuXG4gIGlmIChjdXJyZW50SXNBcnJheSAmJiBuZXh0SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChjdXJyZW50SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChuZXh0SXNBcnJheSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFkbGVyMzJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gVGhpcyBpcyBhIGNsZWFuLXJvb20gaW1wbGVtZW50YXRpb24gb2YgYWRsZXIzMiBkZXNpZ25lZCBmb3IgZGV0ZWN0aW5nXG4vLyBpZiBtYXJrdXAgaXMgbm90IHdoYXQgd2UgZXhwZWN0IGl0IHRvIGJlLiBJdCBkb2VzIG5vdCBuZWVkIHRvIGJlXG4vLyBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcsIG9ubHkgcmVhc29uYWJseSBnb29kIGF0IGRldGVjdGluZyBpZiBtYXJrdXBcbi8vIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIGlzIGRpZmZlcmVudCB0aGFuIHRoYXQgb24gdGhlIGNsaWVudC5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgYSA9IChhICsgZGF0YS5jaGFyQ29kZUF0KGkpKSAlIE1PRDtcbiAgICBiID0gKGIgKyBhKSAlIE1PRDtcbiAgfVxuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW1lbGl6ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoXCIuL2NhbWVsaXplXCIpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICogQHByb3ZpZGVzTW9kdWxlIGNsb25lV2l0aFByb3BzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0UHJvcFRyYW5zZmVyZXIgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUcmFuc2ZlcmVyXCIpO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIENISUxEUkVOX1BST1AgPSBrZXlPZih7IGNoaWxkcmVuOiBudWxsIH0pO1xuXG4vKipcbiAqIFNvbWV0aW1lcyB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIHByb3BzIG9mIGEgY2hpbGQgcGFzc2VkIHRvIHlvdS4gVXN1YWxseVxuICogdGhpcyBpcyB0byBhZGQgYSBDU1MgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGNoaWxkIGNoaWxkIGVsZW1lbnQgeW91J2QgbGlrZSB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIHByb3BzIHlvdSdkIGxpa2UgdG8gbW9kaWZ5LiBjbGFzc05hbWUgYW5kIHN0eWxlIHdpbGwgYmVcbiAqIG1lcmdlZCBhdXRvbWF0aWNhbGx5LlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBhIGNsb25lIG9mIGNoaWxkIHdpdGggcHJvcHMgbWVyZ2VkIGluLlxuICovXG5mdW5jdGlvbiBjbG9uZVdpdGhQcm9wcyhjaGlsZCwgcHJvcHMpIHtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyghY2hpbGQucmVmLCAnWW91IGFyZSBjYWxsaW5nIGNsb25lV2l0aFByb3BzKCkgb24gYSBjaGlsZCB3aXRoIGEgcmVmLiBUaGlzIGlzICcgKyAnZGFuZ2Vyb3VzIGJlY2F1c2UgeW91XFwncmUgY3JlYXRpbmcgYSBuZXcgY2hpbGQgd2hpY2ggd2lsbCBub3QgYmUgJyArICdhZGRlZCBhcyBhIHJlZiB0byBpdHMgcGFyZW50LicpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gUmVhY3RQcm9wVHJhbnNmZXJlci5tZXJnZVByb3BzKHByb3BzLCBjaGlsZC5wcm9wcyk7XG5cbiAgLy8gVXNlIGBjaGlsZC5wcm9wcy5jaGlsZHJlbmAgaWYgaXQgaXMgcHJvdmlkZWQuXG4gIGlmICghbmV3UHJvcHMuaGFzT3duUHJvcGVydHkoQ0hJTERSRU5fUFJPUCkgJiYgY2hpbGQucHJvcHMuaGFzT3duUHJvcGVydHkoQ0hJTERSRU5fUFJPUCkpIHtcbiAgICBuZXdQcm9wcy5jaGlsZHJlbiA9IGNoaWxkLnByb3BzLmNoaWxkcmVuO1xuICB9XG5cbiAgLy8gVGhlIGN1cnJlbnQgQVBJIGRvZXNuJ3QgcmV0YWluIF9vd25lciBhbmQgX2NvbnRleHQsIHdoaWNoIGlzIHdoeSB0aGlzXG4gIC8vIGRvZXNuJ3QgdXNlIFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcy5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50KGNoaWxkLnR5cGUsIG5ld1Byb3BzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVdpdGhQcm9wczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY29udGFpbnNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKFwiLi9pc1RleHROb2RlXCIpO1xuXG4vKmpzbGludCBiaXR3aXNlOnRydWUgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICpcbiAqIEBwYXJhbSB7P0RPTU5vZGV9IG91dGVyTm9kZSBPdXRlciBET00gbm9kZS5cbiAqIEBwYXJhbSB7P0RPTU5vZGV9IGlubmVyTm9kZSBJbm5lciBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG91dGVyTm9kZWAgY29udGFpbnMgb3IgaXMgYGlubmVyTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShfeCwgX3gyKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIHZhciBvdXRlck5vZGUgPSBfeCxcbiAgICAgICAgaW5uZXJOb2RlID0gX3gyO1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICAgIF94ID0gb3V0ZXJOb2RlO1xuICAgICAgX3gyID0gaW5uZXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbnRhaW5zKSB7XG4gICAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlQXJyYXlGcm9tTWl4ZWRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9BcnJheSA9IHJlcXVpcmUoXCIuL3RvQXJyYXlcIik7XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4gKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJiAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgKEFycmF5LmlzQXJyYXkob2JqKSB8fCAnY2FsbGVlJyBpbiBvYmogfHwgJ2l0ZW0nIGluIG9iaikpXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NaXhlZChvYmopIHtcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9BcnJheShvYmopO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7XG5cbi8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG5cbi8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG5cbi8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2Vcbi8vIGEgJ3NlbGVjdCcgZWxlbWVudCBoYXMgJ2xlbmd0aCcgYW5kICdpdGVtJyBwcm9wZXJ0aWVzIG9uIElFOFxuXG4vLyBhcmd1bWVudHNcblxuLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3QiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlRnVsbFBhZ2VDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBEZWZlYXQgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSByZXF1aXJpbmcgdGhpcyBkaXJlY3RseS5cbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQ3JlYXRlIGEgY29tcG9uZW50IHRoYXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiB1bm1vdW50ZWQuXG4gKlxuICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gKiBlYXNpbHkgaW4gYSBjcm9zcy1icm93c2VyIHdheSwgaG93ZXZlciBpdCdzIHZhbHVhYmxlIHRvIGJlIGFibGUgdG9cbiAqIHRha2UgYWR2YW50YWdlIG9mIFJlYWN0J3MgcmVjb25jaWxpYXRpb24gZm9yIHN0eWxpbmcgYW5kIDx0aXRsZT5cbiAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSB0YWcgdG8gd3JhcFxuICogQHJldHVybiB7ZnVuY3Rpb259IGNvbnZlbmllbmNlIGNvbnN0cnVjdG9yIG9mIG5ldyBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQodGFnKSB7XG4gIHZhciBlbGVtZW50RmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KHRhZyk7XG5cbiAgdmFyIEZ1bGxQYWdlQ29tcG9uZW50ID0gUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyh7XG4gICAgdGFnTmFtZTogdGFnLnRvVXBwZXJDYXNlKCksXG4gICAgZGlzcGxheU5hbWU6ICdSZWFjdEZ1bGxQYWdlQ29tcG9uZW50JyArIHRhZyxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAhZmFsc2UgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnJXMgdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyAnICsgJ2ltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sIDxoZWFkPiwgJyArICdhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlICcgKyAndG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSBlbGVtZW50cy4nLCB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRGYWN0b3J5KHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEZ1bGxQYWdlQ29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXBcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSwgc3ViOiB0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoXCIuL2NyZWF0ZUFycmF5RnJvbU1peGVkXCIpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKFwiLi9nZXRNYXJrdXBXcmFwXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRhbmdlcm91c1N0eWxlVmFsdWVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKFwiLi9DU1NQcm9wZXJ0eVwiKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5RnVuY3Rpb25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5T2JqZWN0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc+JzogJyZndDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gICdcXCcnOiAnJiN4Mjc7J1xufTtcblxudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVyKG1hdGNoKSB7XG4gIHJldHVybiBFU0NBUEVfTE9PS1VQW21hdGNoXTtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIGVzY2FwZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmluZERPTU5vZGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZU1hcFwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBpc05vZGUgPSByZXF1aXJlKFwiLi9pc05vZGVcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBnZXRET01Ob2RlIG9yIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNOb2RlKGNvbXBvbmVudE9yRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG4gIGlmIChSZWFjdEluc3RhbmNlTWFwLmhhcyhjb21wb25lbnRPckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZ2V0Tm9kZUZyb21JbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9XG4gICEoY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PSBudWxsIHx8IHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyICE9PSAnZnVuY3Rpb24nKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdDb21wb25lbnQgKHdpdGgga2V5czogJXMpIGNvbnRhaW5zIGByZW5kZXJgIG1ldGhvZCAnICsgJ2J1dCBpcyBub3QgbW91bnRlZCBpbiB0aGUgRE9NJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhZmFsc2UgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL3RyYXZlcnNlQWxsQ2hpbGRyZW5cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGtleVVuaXF1ZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIG5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb2N1c05vZGVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgLy8gSUU4IGNhbiB0aHJvdyBcIkNhbid0IG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRyb2wgYmVjYXVzZSBpdCBpcyBpbnZpc2libGUsXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcbiAgLy8gcmVhc29ucyB0aGF0IGFyZSB0b28gZXhwZW5zaXZlIGFuZCBmcmFnaWxlIHRvIHRlc3QuXG4gIHRyeSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSBmdW5jdGlvbiAoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgYm9keSBpcyBub3QgeWV0IGRlZmluZWQuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRDaGFyQ29kZVwiKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICdBbHQnOiAnYWx0S2V5JyxcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXG4gICdNZXRhJzogJ21ldGFLZXknLFxuICAnU2hpZnQnOiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50TW9kaWZpZXJTdGF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEl0ZXJhdG9yRm5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRNYXJrdXBXcmFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cbnZhciBzaG91bGRXcmFwID0ge1xuICAvLyBGb3JjZSB3cmFwcGluZyBmb3IgU1ZHIGVsZW1lbnRzIGJlY2F1c2UgaWYgdGhleSBnZXQgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PixcbiAgLy8gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbiAgJ2NpcmNsZSc6IHRydWUsXG4gICdjbGlwUGF0aCc6IHRydWUsXG4gICdkZWZzJzogdHJ1ZSxcbiAgJ2VsbGlwc2UnOiB0cnVlLFxuICAnZyc6IHRydWUsXG4gICdsaW5lJzogdHJ1ZSxcbiAgJ2xpbmVhckdyYWRpZW50JzogdHJ1ZSxcbiAgJ3BhdGgnOiB0cnVlLFxuICAncG9seWdvbic6IHRydWUsXG4gICdwb2x5bGluZSc6IHRydWUsXG4gICdyYWRpYWxHcmFkaWVudCc6IHRydWUsXG4gICdyZWN0JzogdHJ1ZSxcbiAgJ3N0b3AnOiB0cnVlLFxuICAndGV4dCc6IHRydWVcbn07XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmc+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwLFxuXG4gICdjaXJjbGUnOiBzdmdXcmFwLFxuICAnY2xpcFBhdGgnOiBzdmdXcmFwLFxuICAnZGVmcyc6IHN2Z1dyYXAsXG4gICdlbGxpcHNlJzogc3ZnV3JhcCxcbiAgJ2cnOiBzdmdXcmFwLFxuICAnbGluZSc6IHN2Z1dyYXAsXG4gICdsaW5lYXJHcmFkaWVudCc6IHN2Z1dyYXAsXG4gICdwYXRoJzogc3ZnV3JhcCxcbiAgJ3BvbHlnb24nOiBzdmdXcmFwLFxuICAncG9seWxpbmUnOiBzdmdXcmFwLFxuICAncmFkaWFsR3JhZGllbnQnOiBzdmdXcmFwLFxuICAncmVjdCc6IHN2Z1dyYXAsXG4gICdzdG9wJzogc3ZnV3JhcCxcbiAgJ3RleHQnOiBzdmdXcmFwXG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgISEhZHVtbXlOb2RlID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIG5vZGVOYW1lID0gJyonO1xuICB9XG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcqJykge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8bGluayAvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPCcgKyBub2RlTmFtZSArICc+PC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgfVxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBzaG91bGRXcmFwW25vZGVOYW1lXSA/IG1hcmt1cFdyYXBbbm9kZU5hbWVdIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFRleHRDb250ZW50QWNjZXNzb3JcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZShcIi4vaHlwaGVuYXRlXCIpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVtcHR5Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3ROYXRpdmVDb21wb25lbnRcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50Lk1peGluLCB7XG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHsqfSBwYXJlbnRDb21wb3NpdGVUeXBlIFRoZSBjb21wb3NpdGUgdHlwZSB0aGF0IHJlc29sdmVkIHRoaXMuXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSwgcGFyZW50Q29tcG9zaXRlVHlwZSkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gZmFsc2UpIHtcbiAgICBub2RlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5lbXB0eUVsZW1lbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhlbGVtZW50ICYmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSwgJ09ubHkgZnVuY3Rpb25zIG9yIHN0cmluZ3MgY2FuIGJlIG1vdW50ZWQgYXMgUmVhY3QgY29tcG9uZW50cy4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmIChwYXJlbnRDb21wb3NpdGVUeXBlID09PSBlbGVtZW50LnR5cGUgJiYgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEF2b2lkIHJlY3Vyc2lvbiBpZiB0aGUgd3JhcHBlciByZW5kZXJzIGl0c2VsZi5cbiAgICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAvLyBBbGwgbmF0aXZlIGNvbXBvbmVudHMgYXJlIGN1cnJlbnRseSB3cmFwcGVkIGluIGEgY29tcG9zaXRlIHNvIHdlJ3JlXG4gICAgICAvLyBzYWZlIHRvIGFzc3VtZSB0aGF0IHRoaXMgaXMgd2hhdCB3ZSBzaG91bGQgaW5zdGFudGlhdGUuXG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW5hdGlvbnMuIEkuZS4gQVJULiBPbmNlIHRob3NlIGFyZSB1cGRhdGVkIHRvIHVzZSB0aGUgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbiwgd2UgY2FuIGRyb3AgdGhpcyBjb2RlIHBhdGguXG4gICAgICBpbnN0YW5jZSA9IG5ldyBlbGVtZW50LnR5cGUoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcigpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudC5jcmVhdGVJbnN0YW5jZUZvclRleHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0VuY291bnRlcmVkIGludmFsaWQgUmVhY3Qgbm9kZSBvZiB0eXBlICVzJywgdHlwZW9mIG5vZGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcodHlwZW9mIGluc3RhbmNlLmNvbnN0cnVjdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicsICdPbmx5IFJlYWN0IENvbXBvbmVudHMgY2FuIGJlIG1vdW50ZWQuJykgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBTZXRzIHVwIHRoZSBpbnN0YW5jZS4gVGhpcyBjYW4gcHJvYmFibHkganVzdCBtb3ZlIGludG8gdGhlIGNvbnN0cnVjdG9yIG5vdy5cbiAgaW5zdGFuY2UuY29uc3RydWN0KG5vZGUpO1xuXG4gIC8vIFRoZXNlIHR3byBmaWVsZHMgYXJlIHVzZWQgYnkgdGhlIERPTSBhbmQgQVJUIGRpZmZpbmcgYWxnb3JpdGhtc1xuICAvLyByZXNwZWN0aXZlbHkuIEluc3RlYWQgb2YgdXNpbmcgZXhwYW5kb3Mgb24gY29tcG9uZW50cywgd2Ugc2hvdWxkIGJlXG4gIC8vIHN0b3JpbmcgdGhlIHN0YXRlIG5lZWRlZCBieSB0aGUgZGlmZmluZyBhbGdvcml0aG1zIGVsc2V3aGVyZS5cbiAgaW5zdGFuY2UuX21vdW50SW5kZXggPSAwO1xuICBpbnN0YW5jZS5fbW91bnRJbWFnZSA9IG51bGw7XG5cbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpbnN0YW5jZS5faXNPd25lck5lY2Vzc2FyeSA9IGZhbHNlO1xuICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaW5zdGFuY2VzIHNob3VsZCBmdWxseSBjb25zdHJ1Y3RlZCBhdCB0aGlzIHBvaW50LCBzbyB0aGV5IHNob3VsZFxuICAvLyBub3QgZ2V0IGFueSBuZXcgZmllbGRzIGFkZGVkIHRvIHRoZW0gYXQgdGhpcyBwb2ludC5cbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNFdmVudFN1cHBvcnRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gKGV2ZW50TmFtZSBpbiBkb2N1bWVudCk7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHRJbnB1dEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICByZXR1cm4gZWxlbSAmJiAoZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJiBzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV0gfHwgZWxlbS5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHROb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoXCIuL2lzTm9kZVwiKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBqb2luQ2xhc3Nlc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgY2xhc3NOYW1lIHN0cmluZ3MgaW50byBvbmUuXG4gKiBodHRwOi8vanNwZXJmLmNvbS9qb2luY2xhc3Nlcy1hcmdzLXZzLWFycmF5XG4gKlxuICogQHBhcmFtIHsuLi4/c3RyaW5nfSBjbGFzc2VzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGpvaW5DbGFzc2VzKGNsYXNzTmFtZSAvKiwgLi4uICovKSB7XG4gIGlmICghY2xhc3NOYW1lKSB7XG4gICAgY2xhc3NOYW1lID0gJyc7XG4gIH1cbiAgdmFyIG5leHRDbGFzcztcbiAgdmFyIGFyZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChhcmdMZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaWkgPSAxOyBpaSA8IGFyZ0xlbmd0aDsgaWkrKykge1xuICAgICAgbmV4dENsYXNzID0gYXJndW1lbnRzW2lpXTtcbiAgICAgIGlmIChuZXh0Q2xhc3MpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5leHRDbGFzcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqb2luQ2xhc3NlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5TWlycm9yXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgIShvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5T2ZcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleU9mID0gZnVuY3Rpb24gKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1hcE9iamVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgYGNhbGxiYWNrYCBvbmNlIGZvciBlYWNoIGVudW1lcmFibGUgb3duIHByb3BlcnR5IGluIHRoZVxuICogb2JqZWN0IGFuZCBjb25zdHJ1Y3RzIGEgbmV3IG9iamVjdCBmcm9tIHRoZSByZXN1bHRzLiBUaGUgYGNhbGxiYWNrYCBpc1xuICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqXG4gKiAgLSB0aGUgcHJvcGVydHkgdmFsdWVcbiAqICAtIHRoZSBwcm9wZXJ0eSBuYW1lXG4gKiAgLSB0aGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICpcbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgYWRkZWQgYWZ0ZXIgdGhlIGNhbGwgdG8gYG1hcE9iamVjdGAgd2lsbCBub3QgYmUgdmlzaXRlZFxuICogYnkgYGNhbGxiYWNrYC4gSWYgdGhlIHZhbHVlcyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzIGFyZSBjaGFuZ2VkLCB0aGUgdmFsdWVcbiAqIHBhc3NlZCB0byBgY2FsbGJhY2tgIHdpbGwgYmUgdGhlIHZhbHVlIGF0IHRoZSB0aW1lIGBtYXBPYmplY3RgIHZpc2l0cyB0aGVtLlxuICogUHJvcGVydGllcyB0aGF0IGFyZSBkZWxldGVkIGJlZm9yZSBiZWluZyB2aXNpdGVkIGFyZSBub3QgdmlzaXRlZC5cbiAqXG4gKiBAZ3JlcCBmdW5jdGlvbiBvYmplY3RNYXAoKVxuICogQGdyZXAgZnVuY3Rpb24gb2JqTWFwKClcbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBuYW1lKSkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2FsbGJhY2suY2FsbChjb250ZXh0LCBvYmplY3RbbmFtZV0sIG5hbWUsIG9iamVjdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwT2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtZW1vaXplU3RyaW5nT25seVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgb25seUNoaWxkXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzXG4gKiBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0cyBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGVcbiAqIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG8gYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmVcbiAqIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdENvbXBvbmVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnb25seUNoaWxkIG11c3QgYmUgcGFzc2VkIGEgY2hpbGRyZW4gd2l0aCBleGFjdGx5IG9uZSBjaGlsZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcGVyZm9ybWFuY2VOb3dcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGVyZm9ybWFuY2UgPSByZXF1aXJlKFwiLi9wZXJmb3JtYW5jZVwiKTtcblxuLyoqXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xuICogYERhdGUubm93KClgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG5lZWQgdG8gc3VwcG9ydCBGaXJlZm94IDwgMTUgZm9yIG5vd1xuICogYmVjYXVzZSBvZiBGYWNlYm9vaydzIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUuXG4gKi9cbmlmICghcGVyZm9ybWFuY2UgfHwgIXBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZSA9IERhdGU7XG59XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHBlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKFwiLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcIik7XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQucmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldElubmVySFRNTFxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIFdISVRFU1BBQ0VfVEVTVCA9IC9eWyBcXHJcXG5cXHRcXGZdLztcbnZhciBOT05WSVNJQkxFX1RFU1QgPSAvPCghLS18bGlua3xub3NjcmlwdHxtZXRhfHNjcmlwdHxzdHlsZSlbIFxcclxcblxcdFxcZlxcLz5dLztcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xufTtcblxuLy8gV2luOCBhcHBzOiBBbGxvdyBhbGwgaHRtbCB0byBiZSBpbnNlcnRlZFxuaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSk7XG4gIH07XG59XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjUyNzkpICsgaHRtbDtcblxuICAgICAgICAvLyBkZWxldGVEYXRhIGxlYXZlcyBhbiBlbXB0eSBgVGV4dE5vZGVgIHdoaWNoIG9mZnNldHMgdGhlIGluZGV4IG9mIGFsbFxuICAgICAgICAvLyBjaGlsZHJlbi4gRGVmaW5pdGVseSB3YW50IHRvIGF2b2lkIHRoaXMuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlLmRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUuZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldFRleHRDb250ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKFwiLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcIik7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZShcIi4vc2V0SW5uZXJIVE1MXCIpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIHNldElubmVySFRNTChub2RlLCBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUZXh0Q29udGVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4qIEBwcm92aWRlc01vZHVsZSBzaGFsbG93Q29tcGFyZVxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4vc2hhbGxvd0VxdWFsXCIpO1xuXG4vKipcbiAqIERvZXMgYSBzaGFsbG93IGNvbXBhcmlzb24gZm9yIHByb3BzIGFuZCBzdGF0ZS5cbiAqIFNlZSBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmUoaW5zdGFuY2UsIG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIHJldHVybiAhc2hhbGxvd0VxdWFsKGluc3RhbmNlLnByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdGFuY2Uuc3RhdGUsIG5leHRTdGF0ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0NvbXBhcmU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNoYWxsb3dFcXVhbFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nXG4gKiBmYWxzZSB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW5cbiAqIG9iakEgYW5kIG9iakIuIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgdmFyIGJIYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuYmluZChvYmpCKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleXNBW2ldKSB8fCBvYmpBW2tleXNBW2ldXSAhPT0gb2JqQltrZXlzQVtpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RWxlbWVudGAgYW5kIGBuZXh0RWxlbWVudGAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICBpZiAocHJldkVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudCAhPSBudWxsKSB7XG4gICAgdmFyIHByZXZUeXBlID0gdHlwZW9mIHByZXZFbGVtZW50O1xuICAgIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG5leHRUeXBlID09PSAnc3RyaW5nJyB8fCBuZXh0VHlwZSA9PT0gJ251bWJlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB0b0FycmF5XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tTWl4ZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0IGluXG4gIC8vIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAhKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgIShsZW5ndGggPT09IDAgfHwgbGVuZ3RoIC0gMSBpbiBvYmopID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXk7XG5cbi8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdHJhdmVyc2VBbGxDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEZyYWdtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RGcmFnbWVudFwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoXCIuL2dldEl0ZXJhdG9yRm5cIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgU0VQQVJBVE9SID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuU0VQQVJBVE9SO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXAgPSB7XG4gICc9JzogJz0wJyxcbiAgJy4nOiAnPTEnLFxuICAnOic6ICc9Midcbn07XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9bPS46XS9nO1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyKG1hdGNoKSB7XG4gIHJldHVybiB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyTG9va3VwW21hdGNoXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiB3cmFwVXNlclByb3ZpZGVkS2V5KGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogRXNjYXBlIGEgY29tcG9uZW50IGtleSBzbyB0aGF0IGl0IGlzIHNhZmUgdG8gdXNlIGluIGEgcmVhY3RpZC5cbiAqXG4gKiBAcGFyYW0geyp9IGtleSBDb21wb25lbnQga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgdXNlclByb3ZpZGVkS2V5RXNjYXBlcik7XG59XG5cbi8qKlxuICogV3JhcCBhIGBrZXlgIHZhbHVlIGV4cGxpY2l0bHkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuICogaW1wbGljaXRseS1nZW5lcmF0ZWQga2V5cyBnZW5lcmF0ZWQgYnkgYSBjb21wb25lbnQncyBpbmRleCBpbiBpdHMgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVmFsdWUgb2YgYSB1c2VyLXByb3ZpZGVkIGBrZXlgIGF0dHJpYnV0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB3cmFwVXNlclByb3ZpZGVkS2V5KGtleSkge1xuICByZXR1cm4gJyQnICsgZXNjYXBlVXNlclByb3ZpZGVkS2V5KGtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IChuYW1lU29GYXIgIT09ICcnID8gbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SIDogU0VQQVJBVE9SKSArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IChuYW1lU29GYXIgIT09ICcnID8gbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SIDogU0VQQVJBVE9SKSArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSAobmFtZVNvRmFyICE9PSAnJyA/IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUiA6IFNFUEFSQVRPUikgKyB3cmFwVXNlclByb3ZpZGVkS2V5KGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAhKGNoaWxkcmVuLm5vZGVUeXBlICE9PSAxKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZUFsbENoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIGFuIGludmFsaWQgY2hpbGQ7IERPTSAnICsgJ2VsZW1lbnRzIGFyZSBub3QgdmFsaWQgY2hpbGRyZW4gb2YgUmVhY3QgY29tcG9uZW50cy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgZnJhZ21lbnQgPSBSZWFjdEZyYWdtZW50LmV4dHJhY3QoY2hpbGRyZW4pO1xuICAgICAgZm9yICh2YXIga2V5IGluIGZyYWdtZW50KSB7XG4gICAgICAgIGlmIChmcmFnbWVudC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY2hpbGQgPSBmcmFnbWVudFtrZXldO1xuICAgICAgICAgIG5leHROYW1lID0gKG5hbWVTb0ZhciAhPT0gJycgPyBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1IgOiBTRVBBUkFUT1IpICsgd3JhcFVzZXJQcm92aWRlZEtleShrZXkpICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdXBkYXRlXG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9ICh7fSkuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KHgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4geC5jb25jYXQoKTtcbiAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhc3NpZ24obmV3IHguY29uc3RydWN0b3IoKSwgeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbn1cblxudmFyIENPTU1BTkRfUFVTSCA9IGtleU9mKHsgJHB1c2g6IG51bGwgfSk7XG52YXIgQ09NTUFORF9VTlNISUZUID0ga2V5T2YoeyAkdW5zaGlmdDogbnVsbCB9KTtcbnZhciBDT01NQU5EX1NQTElDRSA9IGtleU9mKHsgJHNwbGljZTogbnVsbCB9KTtcbnZhciBDT01NQU5EX1NFVCA9IGtleU9mKHsgJHNldDogbnVsbCB9KTtcbnZhciBDT01NQU5EX01FUkdFID0ga2V5T2YoeyAkbWVyZ2U6IG51bGwgfSk7XG52YXIgQ09NTUFORF9BUFBMWSA9IGtleU9mKHsgJGFwcGx5OiBudWxsIH0pO1xuXG52YXIgQUxMX0NPTU1BTkRTX0xJU1QgPSBbQ09NTUFORF9QVVNILCBDT01NQU5EX1VOU0hJRlQsIENPTU1BTkRfU1BMSUNFLCBDT01NQU5EX1NFVCwgQ09NTUFORF9NRVJHRSwgQ09NTUFORF9BUFBMWV07XG5cbnZhciBBTExfQ09NTUFORFNfU0VUID0ge307XG5cbkFMTF9DT01NQU5EU19MSVNULmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgQUxMX0NPTU1BTkRTX1NFVFtjb21tYW5kXSA9IHRydWU7XG59KTtcblxuZnVuY3Rpb24gaW52YXJpYW50QXJyYXlDYXNlKHZhbHVlLCBzcGVjLCBjb21tYW5kKSB7XG4gICFBcnJheS5pc0FycmF5KHZhbHVlKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGUoKTogZXhwZWN0ZWQgdGFyZ2V0IG9mICVzIHRvIGJlIGFuIGFycmF5OyBnb3QgJXMuJywgY29tbWFuZCwgdmFsdWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHNwZWNWYWx1ZSA9IHNwZWNbY29tbWFuZF07XG4gICFBcnJheS5pc0FycmF5KHNwZWNWYWx1ZSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXk7IGdvdCAlcy4gJyArICdEaWQgeW91IGZvcmdldCB0byB3cmFwIHlvdXIgcGFyYW1ldGVyIGluIGFuIGFycmF5PycsIGNvbW1hbmQsIHNwZWNWYWx1ZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUodmFsdWUsIHNwZWMpIHtcbiAgISh0eXBlb2Ygc3BlYyA9PT0gJ29iamVjdCcpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiBZb3UgcHJvdmlkZWQgYSBrZXkgcGF0aCB0byB1cGRhdGUoKSB0aGF0IGRpZCBub3QgY29udGFpbiBvbmUgJyArICdvZiAlcy4gRGlkIHlvdSBmb3JnZXQgdG8gaW5jbHVkZSB7JXM6IC4uLn0/JywgQUxMX0NPTU1BTkRTX0xJU1Quam9pbignLCAnKSwgQ09NTUFORF9TRVQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX1NFVCkpIHtcbiAgICAhKE9iamVjdC5rZXlzKHNwZWMpLmxlbmd0aCA9PT0gMSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGhhdmUgbW9yZSB0aGFuIG9uZSBrZXkgaW4gYW4gb2JqZWN0IHdpdGggJXMnLCBDT01NQU5EX1NFVCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHNwZWNbQ09NTUFORF9TRVRdO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IHNoYWxsb3dDb3B5KHZhbHVlKTtcblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX01FUkdFKSkge1xuICAgIHZhciBtZXJnZU9iaiA9IHNwZWNbQ09NTUFORF9NRVJHRV07XG4gICAgIShtZXJnZU9iaiAmJiB0eXBlb2YgbWVyZ2VPYmogPT09ICdvYmplY3QnKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGUoKTogJXMgZXhwZWN0cyBhIHNwZWMgb2YgdHlwZSBcXCdvYmplY3RcXCc7IGdvdCAlcycsIENPTU1BTkRfTUVSR0UsIG1lcmdlT2JqKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIShuZXh0VmFsdWUgJiYgdHlwZW9mIG5leHRWYWx1ZSA9PT0gJ29iamVjdCcpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiAlcyBleHBlY3RzIGEgdGFyZ2V0IG9mIHR5cGUgXFwnb2JqZWN0XFwnOyBnb3QgJXMnLCBDT01NQU5EX01FUkdFLCBuZXh0VmFsdWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBhc3NpZ24obmV4dFZhbHVlLCBzcGVjW0NPTU1BTkRfTUVSR0VdKTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNwZWMsIENPTU1BTkRfUFVTSCkpIHtcbiAgICBpbnZhcmlhbnRBcnJheUNhc2UodmFsdWUsIHNwZWMsIENPTU1BTkRfUFVTSCk7XG4gICAgc3BlY1tDT01NQU5EX1BVU0hdLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIG5leHRWYWx1ZS5wdXNoKGl0ZW0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3BlYywgQ09NTUFORF9VTlNISUZUKSkge1xuICAgIGludmFyaWFudEFycmF5Q2FzZSh2YWx1ZSwgc3BlYywgQ09NTUFORF9VTlNISUZUKTtcbiAgICBzcGVjW0NPTU1BTkRfVU5TSElGVF0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgbmV4dFZhbHVlLnVuc2hpZnQoaXRlbSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX1NQTElDRSkpIHtcbiAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgdGFyZ2V0IHRvIGJlIGFuIGFycmF5OyBnb3QgJXMnLCBDT01NQU5EX1NQTElDRSwgdmFsdWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhQXJyYXkuaXNBcnJheShzcGVjW0NPTU1BTkRfU1BMSUNFXSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXkgb2YgYXJyYXlzOyBnb3QgJXMuICcgKyAnRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlcnMgaW4gYW4gYXJyYXk/JywgQ09NTUFORF9TUExJQ0UsIHNwZWNbQ09NTUFORF9TUExJQ0VdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgc3BlY1tDT01NQU5EX1NQTElDRV0uZm9yRWFjaChmdW5jdGlvbiAoYXJncykge1xuICAgICAgIUFycmF5LmlzQXJyYXkoYXJncykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXkgb2YgYXJyYXlzOyBnb3QgJXMuICcgKyAnRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlcnMgaW4gYW4gYXJyYXk/JywgQ09NTUFORF9TUExJQ0UsIHNwZWNbQ09NTUFORF9TUExJQ0VdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBuZXh0VmFsdWUuc3BsaWNlLmFwcGx5KG5leHRWYWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX0FQUExZKSkge1xuICAgICEodHlwZW9mIHNwZWNbQ09NTUFORF9BUFBMWV0gPT09ICdmdW5jdGlvbicpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiBleHBlY3RlZCBzcGVjIG9mICVzIHRvIGJlIGEgZnVuY3Rpb247IGdvdCAlcy4nLCBDT01NQU5EX0FQUExZLCBzcGVjW0NPTU1BTkRfQVBQTFldKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgbmV4dFZhbHVlID0gc3BlY1tDT01NQU5EX0FQUExZXShuZXh0VmFsdWUpO1xuICB9XG5cbiAgZm9yICh2YXIgayBpbiBzcGVjKSB7XG4gICAgaWYgKCEoQUxMX0NPTU1BTkRTX1NFVC5oYXNPd25Qcm9wZXJ0eShrKSAmJiBBTExfQ09NTUFORFNfU0VUW2tdKSkge1xuICAgICAgbmV4dFZhbHVlW2tdID0gdXBkYXRlKHZhbHVlW2tdLCBzcGVjW2tdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZGF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHZhbGlkYXRlRE9NTmVzdGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIHBhcmVudFRhZzogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IGFzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLnBhcmVudFRhZyA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcblxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuXG4gICAgICBjYXNlICd0YWJsZSc6XG5cbiAgICAgIGNhc2UgJ2hyJzpcblxuICAgICAgY2FzZSAneG1wJzpcblxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW5zdGFuY2UsIHJldHVybiBhIGxpc3Qgb2YgaXRzIHJlY3Vyc2l2ZVxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgdmFyIGZpbmRPd25lclN0YWNrID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIC8qZXNsaW50LWRpc2FibGUgc3BhY2UtYWZ0ZXIta2V5d29yZHMgKi9cbiAgICBkbyB7XG4gICAgICAvKmVzbGludC1lbmFibGUgc3BhY2UtYWZ0ZXIta2V5d29yZHMgKi9cbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLnBhcmVudFRhZztcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBwcm9ibGVtYXRpYyA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKHByb2JsZW1hdGljKSB7XG4gICAgICB2YXIgYW5jZXN0b3JUYWcgPSBwcm9ibGVtYXRpYy50YWc7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0YW5jZSA9IHByb2JsZW1hdGljLmluc3RhbmNlO1xuXG4gICAgICB2YXIgY2hpbGRPd25lciA9IGNoaWxkSW5zdGFuY2UgJiYgY2hpbGRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgdmFyIGNoaWxkT3duZXJzID0gZmluZE93bmVyU3RhY2soY2hpbGRPd25lcik7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lcnMgPSBmaW5kT3duZXJTdGFjayhhbmNlc3Rvck93bmVyKTtcblxuICAgICAgdmFyIG1pblN0YWNrTGVuID0gTWF0aC5taW4oY2hpbGRPd25lcnMubGVuZ3RoLCBhbmNlc3Rvck93bmVycy5sZW5ndGgpO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHZhciBkZWVwZXN0Q29tbW9uID0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRPd25lcnNbaV0gPT09IGFuY2VzdG9yT3duZXJzW2ldKSB7XG4gICAgICAgICAgZGVlcGVzdENvbW1vbiA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFVOS05PV04gPSAnKHVua25vd24pJztcbiAgICAgIHZhciBjaGlsZE93bmVyTmFtZXMgPSBjaGlsZE93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIG93bmVySW5mbyA9IFtdLmNvbmNhdChcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGluc3RhbmNlcyBoYXZlIGEgY29tbW9uIG93bmVyIGFuY2VzdG9yLCBzdGFydFxuICAgICAgLy8gd2l0aCB0aGF0IC0tIG90aGVyd2lzZSB3ZSBqdXN0IHN0YXJ0IHdpdGggdGhlIHBhcmVudCdzIG93bmVycy5cbiAgICAgIGRlZXBlc3RDb21tb24gIT09IC0xID8gY2hpbGRPd25lcnNbZGVlcGVzdENvbW1vbl0uZ2V0TmFtZSgpIHx8IFVOS05PV04gOiBbXSwgYW5jZXN0b3JPd25lck5hbWVzLCBhbmNlc3RvclRhZyxcbiAgICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xuICAgICAgaW52YWxpZEFuY2VzdG9yID8gWycuLi4nXSA6IFtdLCBjaGlsZE93bmVyTmFtZXMsIGNoaWxkVGFnKS5qb2luKCcgPiAnKTtcblxuICAgICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgb3duZXJJbmZvO1xuICAgICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgICAgfVxuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiA8JXM+IGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiAnICsgJ1NlZSAlcy4lcycsIGNoaWxkVGFnLCBhbmNlc3RvclRhZywgb3duZXJJbmZvLCBpbmZvKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6IDwlcz4gY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgY2hpbGRUYWcsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleSA9ICdfX3ZhbGlkYXRlRE9NTmVzdGluZ19hbmNlc3RvckluZm8kJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbztcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5wYXJlbnRUYWc7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB3YXJuaW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgL15bc1xcV10qJC8udGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgKyAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcbiIsInZhciBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9BcHBEaXNwYXRjaGVyJyk7XHJcblxyXG52YXIgSW5wdXRBY3Rpb25zID0ge1xyXG5cclxuICAgIHVwc2VydDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICBBcHBEaXNwYXRjaGVyLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogaW5wdXQuYWN0aW9uVHlwZSxcclxuICAgICAgICAgICAgbW9kZWxLZXk6IGlucHV0Lm1vZGVsS2V5LFxyXG4gICAgICAgICAgICBtb2RlbFZhbHVlOiBpbnB1dC5tb2RlbFZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dEFjdGlvbnM7IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIE1haW5Db21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvTWFpbkNvbXBvbmVudCcpO1xyXG5cclxuUmVhY3QucmVuZGVyKDxNYWluQ29tcG9uZW50IC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpOyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBJbnB1dEFjdGlvbnMgPSByZXF1aXJlKCcuLi8uLi9hY3Rpb25zL0lucHV0QWN0aW9ucycpO1xyXG5cclxudmFyIElucHV0Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgX29uSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gUmVhY3QuZmluZERPTU5vZGUodGhpcy5yZWZzLmlucHV0KS52YWx1ZS50cmltKCk7XHJcbiAgICAgICAgaWYoaW5wdXQgPT09ICcnKXtcclxuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7IC8vZGVsZXRlZCB0aGVpciBpbnB1dDsgcmVzb3J0IHRvIHVuZGVmaW5lZHx8ZGVmYXVsdHNcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5pc1ZhbGlkKGlucHV0KSl7XHJcbiAgICAgICAgICAgIGlmKGlucHV0ICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSB0aGlzLnByb3BzLmNvbnZlcnQoaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIElucHV0QWN0aW9ucy51cHNlcnQoe1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uVHlwZTogdGhpcy5wcm9wcy5hY3Rpb25UeXBlLFxyXG4gICAgICAgICAgICAgICAgbW9kZWxLZXk6IHRoaXMucHJvcHMuaWQsXHJcbiAgICAgICAgICAgICAgICBtb2RlbFZhbHVlOiBpbnB1dFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYmVmb3JlLCBhZnRlcjtcclxuICAgICAgICBpZih0aGlzLnByb3BzLmFkZE9uQmVmb3JlSW5wdXQgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnByb3BzLmFkZE9uQmVmb3JlSW5wdXQpe1xyXG4gICAgICAgICAgICBiZWZvcmUgPSA8c3BhbiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cC1hZGRvblwiPnt0aGlzLnByb3BzLmFkZE9ufTwvc3Bhbj47XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGFmdGVyID0gPHNwYW4gY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj57dGhpcy5wcm9wcy5hZGRPbn08L3NwYW4+O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVxdWlyZWQgPSB0aGlzLnByb3BzLnJlcXVpcmVkID8gJyByZXF1aXJlZCcgOiAnJztcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT17XCJsYWJlbCBsYWJlbC1kZWZhdWx0XCIgKyByZXF1aXJlZH0gaHRtbEZvcj17dGhpcy5wcm9wcy5pZH0+e3RoaXMucHJvcHMubGFiZWx9PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICB7YmVmb3JlfVxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD17dGhpcy5wcm9wcy5pZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT17dGhpcy5wcm9wcy50eXBlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXt0aGlzLnByb3BzLmlkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17dGhpcy5wcm9wcy5kZWZhdWx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5fb25JbnB1dENoYW5nZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPVwiaW5wdXRcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAge2FmdGVyfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dENvbXBvbmVudDsiLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIgSW5wdXRDb21wb25lbnQgPSByZXF1aXJlKCcuL0lucHV0Q29tcG9uZW50Jyk7XHJcbnZhciBNb250aGx5Q29zdElucHV0RGVmaW5pdGlvbnMgPSByZXF1aXJlKCcuLi8uLi9kZWZpbmVzL01vbnRobHlDb3N0SW5wdXREZWZpbml0aW9ucycpO1xyXG52YXIgU2NlbmFyaW9JbnB1dERlZmluaXRpb25zID0gcmVxdWlyZSgnLi4vLi4vZGVmaW5lcy9TY2VuYXJpb0lucHV0RGVmaW5pdGlvbnMnKTtcclxuXHJcbnZhciBNYWluQ29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaW5wdXRzID0gU2NlbmFyaW9JbnB1dERlZmluaXRpb25zLmdldCgpO1xyXG4gICAgICAgIGlucHV0cyA9IGlucHV0cy5jb25jYXQoTW9udGhseUNvc3RJbnB1dERlZmluaXRpb25zLmdldCgpKTtcclxuICAgICAgICB2YXIgaW5wdXRDb21wb25lbnRzO1xyXG4gICAgICAgIGlmKGlucHV0cyAhPT0gdW5kZWZpbmVkICYmIGlucHV0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlucHV0Q29tcG9uZW50cyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPElucHV0Q29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17ZS5pZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e2UuaWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblR5cGU9e2UuYWN0aW9uVHlwZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT17ZS50eXBlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17ZS5sYWJlbH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdD17ZS5kZWZhdWx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZD17ZS5yZXF1aXJlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT25CZWZvcmVJbnB1dD17ZS5hZGRPbkJlZm9yZUlucHV0fHx0cnVlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPbj17ZS5hZGRPbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZD17ZS5pc1ZhbGlkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0PXtlLmNvbnZlcnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dExpc3RcIj5cclxuICAgICAgICAgICAgICAgIHtpbnB1dENvbXBvbmVudHN9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYWluQ29tcG9uZW50OyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBUaXRsZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vVGl0bGVDb21wb25lbnQvVGl0bGVDb21wb25lbnQnKTtcclxudmFyIElucHV0TGlzdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vSW5wdXRMaXN0Q29tcG9uZW50L0lucHV0TGlzdENvbXBvbmVudCcpO1xyXG52YXIgUmVzdWx0TGlzdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVzdWx0TGlzdENvbXBvbmVudC9SZXN1bHRMaXN0Q29tcG9uZW50Jyk7XHJcblxyXG52YXIgTWFpbkNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYWluQ29tcG9uZW50XCI+XHJcbiAgICAgICAgICAgICAgICA8VGl0bGVDb21wb25lbnQgLz5cclxuICAgICAgICAgICAgICAgIDxJbnB1dExpc3RDb21wb25lbnQgLz5cclxuICAgICAgICAgICAgICAgIDxSZXN1bHRMaXN0Q29tcG9uZW50IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYWluQ29tcG9uZW50O1xyXG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIgSGlnaGNoYXJ0cyA9IHJlcXVpcmUoJ3JlYWN0LWhpZ2hjaGFydHMnKTtcclxuXHJcbnZhciBJbmNvbWVCcmVha2Rvd25Db21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbmNvbWVCcmVha0Rvd25DaGFydDtcclxuXHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5tb250aGx5SW5jb21lID4gMCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJyZWFrZG93bnMgPSBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdUYWtlIGhvbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5wcm9wcy5uZXRJbmNvbWUgLyB0aGlzLnByb3BzLm1vbnRobHlJbmNvbWUpICogMTAwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnRXhwZW5zZXMnLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5wcm9wcy5tb250aGx5RXhwZW5zZXMgLyB0aGlzLnByb3BzLm1vbnRobHlJbmNvbWUpICogMTAwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnTW9udGhseSBDYXIgQ29zdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICh0aGlzLnByb3BzLm1vbnRobHlDYXJDb3N0IC8gdGhpcy5wcm9wcy5tb250aGx5SW5jb21lKSAqIDEwMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcclxuICAgICAgICAgICAgYnJlYWtkb3ducy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS52YWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2UubGFiZWwsIGUudmFsdWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29uZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBwbG90QmFja2dyb3VuZENvbG9yOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsb3RCb3JkZXJXaWR0aDogMCxcclxuICAgICAgICAgICAgICAgICAgICBwbG90U2hhZG93OiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0luY29tZTxicj5CcmVha2Rvd24nLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcclxuICAgICAgICAgICAgICAgICAgICB5OiA0MFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludEZvcm1hdDogJ3tzZXJpZXMubmFtZX06IDxiPntwb2ludC5wZXJjZW50YWdlOi4xZn0lPC9iPidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwbG90T3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHBpZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGFiZWxzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IC01MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTaGFkb3c6ICcwcHggMXB4IDJweCBibGFjaydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogLTkwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogOTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlcjogWyc1MCUnLCAnNzUlJ11cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwaWUnLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdJbmNvbWUgQnJlYWtkb3duJyxcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclNpemU6ICc1MCUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGluY29tZUJyZWFrRG93bkNoYXJ0ID0gPEhpZ2hjaGFydHMgY29uZmlnID0ge2NvbmZpZ30+PC9IaWdoY2hhcnRzPjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIHtpbmNvbWVCcmVha0Rvd25DaGFydH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluY29tZUJyZWFrZG93bkNvbXBvbmVudDtcclxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBOZXRJbmNvbWVUZXh0Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cIndlbGwgY2VudGVyVGV4dFwiPlRha2UgSG9tZSBQZXIgTW9udGggQWZ0ZXIgRXhwZW5zZXMgQW5kIENhciBQYXltZW50ICR7dGhpcy5wcm9wcy5uZXRJbmNvbWUudG9GaXhlZCgyKX08L2gyPjtcclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5ldEluY29tZVRleHRDb21wb25lbnQ7IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIElucHV0QWN0aW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uc3RhbnRzL0lucHV0QWN0aW9uQ29uc3RhbnRzJyk7XHJcbnZhciBJbnB1dFN0b3JlID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vc3RvcmVzL0lucHV0U3RvcmUnKTtcclxuXHJcbnZhciBTYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIF9vbklucHV0Q2hhbmdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgaW5wdXRzOiBJbnB1dFN0b3JlLmdldEFsbCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIElucHV0U3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIoSW5wdXRBY3Rpb25Db25zdGFudHMuU0FGRVRZX05FVF9DSEFOR0UsIHRoaXMuX29uSW5wdXRDaGFuZ2UpO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBJbnB1dFN0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKElucHV0QWN0aW9uQ29uc3RhbnRzLlNBRkVUWV9ORVRfQ0hBTkdFLCB0aGlzLl9vbklucHV0Q2hhbmdlKTtcclxuICAgIH0sXHJcbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlucHV0czogSW5wdXRTdG9yZS5nZXRBbGwoKVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2FmZXR5TmV0RWZmZWN0VGV4dDtcclxuXHJcbiAgICAgICAgaWYodGhpcy5zdGF0ZS5pbnB1dHMuc2FmZXR5TmV0ID4gMCl7XHJcbiAgICAgICAgICAgIHZhciBtb250aHNPZlNhZmV0eU5ldEVmZmVjdCA9IDEyO1xyXG4gICAgICAgICAgICB2YXIgb3ZlclRpbWUgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTE7IGk8PW1vbnRoc09mU2FmZXR5TmV0RWZmZWN0OyBpKyspe1xyXG4gICAgICAgICAgICAgICAgb3ZlclRpbWVbaV0gPSAodGhpcy5zdGF0ZS5pbnB1dHMuc2FmZXR5TmV0ICsgKHRoaXMucHJvcHMubmV0SW5jb21lICogaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNhZmV0eU5ldEVmZmVjdFRleHQgPSA8aDIgY2xhc3NOYW1lPVwid2VsbCBjZW50ZXJUZXh0XCI+QWZ0ZXIgNiBNb250aHMgWW91ciBTYWZldHkgTmV0IFdvdWxkIEJlIEF0ICR7b3ZlclRpbWVbNl0udG9GaXhlZCgyKX08L2gyPjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICB7c2FmZXR5TmV0RWZmZWN0VGV4dH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNhZmV0eU5ldE92ZXJUaW1lQ29tcG9uZW50OyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG52YXIgSW5wdXRBY3Rpb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25zdGFudHMvSW5wdXRBY3Rpb25Db25zdGFudHMnKTtcclxudmFyIElucHV0U3RvcmUgPSByZXF1aXJlKCcuLi8uLi8uLi9zdG9yZXMvSW5wdXRTdG9yZScpO1xyXG52YXIgVmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvVmFsaWRhdG9ycycpO1xyXG52YXIgU2NlbmFyaW9JbnB1dERlZmluaXRpb25zID0gcmVxdWlyZSgnLi4vLi4vLi4vZGVmaW5lcy9TY2VuYXJpb0lucHV0RGVmaW5pdGlvbnMnKTtcclxuXHJcbnZhciBJbmNvbWVCcmVha2Rvd25Db21wb25lbnQgPSByZXF1aXJlKCcuL05ldEluY29tZUJhc2VkQ29tcG9uZW50cy9JbmNvbWVCcmVha2Rvd25Db21wb25lbnQnKTtcclxudmFyIE5ldEluY29tZVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL05ldEluY29tZUJhc2VkQ29tcG9uZW50cy9OZXRJbmNvbWVUZXh0Q29tcG9uZW50Jyk7XHJcbnZhciBTYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vTmV0SW5jb21lQmFzZWRDb21wb25lbnRzL1NhZmV0eU5ldE92ZXJUaW1lQ29tcG9uZW50Jyk7XHJcblxyXG52YXIgbGlzdGVuVG9BY3Rpb25zID0gW1xyXG4gICAgSW5wdXRBY3Rpb25Db25zdGFudHMuTU9OVEhMWV9JTkNPTUVfQ0hBTkdFLFxyXG4gICAgSW5wdXRBY3Rpb25Db25zdGFudHMuTU9OVEhMWV9FWFBFTlNFU19DSEFOR0VcclxuXTtcclxuXHJcbnZhciBSZXN1bHRMaXN0Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgX29uSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBpbnB1dHM6IElucHV0U3RvcmUuZ2V0QWxsKClcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGxpc3RlblRvQWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvblR5cGVDb25zdGFudCl7XHJcbiAgICAgICAgICAgIElucHV0U3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIoYWN0aW9uVHlwZUNvbnN0YW50LCBzZWxmLl9vbklucHV0Q2hhbmdlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGxpc3RlblRvQWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGlvblR5cGVDb25zdGFudCl7XHJcbiAgICAgICAgICAgIElucHV0U3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIoYWN0aW9uVHlwZUNvbnN0YW50LCBzZWxmLl9vbklucHV0Q2hhbmdlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlucHV0czogSW5wdXRTdG9yZS5nZXRBbGwoKVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaW5jb21lQnJlYWtkb3duQ29tcG9uZW50O1xyXG4gICAgICAgIHZhciBuZXRJbmNvbWVUZXh0Q29tcG9uZW50O1xyXG4gICAgICAgIHZhciBzYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudDtcclxuXHJcbiAgICAgICAgaWYoVmFsaWRhdG9ycy52YWxpZGF0ZVJlcXVpcmVkSW5wdXRzRXhpc3QoU2NlbmFyaW9JbnB1dERlZmluaXRpb25zLmdldCgpLCB0aGlzLnN0YXRlLmlucHV0cykpe1xyXG4gICAgICAgICAgICB2YXIgbmV0SW5jb21lID0gdGhpcy5zdGF0ZS5pbnB1dHMubW9udGhseUluY29tZSAtIHRoaXMuc3RhdGUuaW5wdXRzLm1vbnRobHlFeHBlbnNlcyAtIHRoaXMucHJvcHMubW9udGhseUNhckNvc3Q7XHJcbiAgICAgICAgICAgIGluY29tZUJyZWFrZG93bkNvbXBvbmVudCA9IDxJbmNvbWVCcmVha2Rvd25Db21wb25lbnRcclxuICAgICAgICAgICAgICAgIG5ldEluY29tZT17bmV0SW5jb21lfVxyXG4gICAgICAgICAgICAgICAgbW9udGhseUluY29tZT17dGhpcy5zdGF0ZS5pbnB1dHMubW9udGhseUluY29tZX1cclxuICAgICAgICAgICAgICAgIG1vbnRobHlDYXJDb3N0PXt0aGlzLnByb3BzLm1vbnRobHlDYXJDb3N0fVxyXG4gICAgICAgICAgICAgICAgbW9udGhseUV4cGVuc2VzPXt0aGlzLnN0YXRlLmlucHV0cy5tb250aGx5RXhwZW5zZXN9XHJcbiAgICAgICAgICAgIC8+O1xyXG4gICAgICAgICAgICBuZXRJbmNvbWVUZXh0Q29tcG9uZW50ID0gPE5ldEluY29tZVRleHRDb21wb25lbnQgbmV0SW5jb21lPXtuZXRJbmNvbWV9IC8+O1xyXG4gICAgICAgICAgICBzYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudCA9IDxTYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudCBuZXRJbmNvbWU9e25ldEluY29tZX0gLz47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICB7aW5jb21lQnJlYWtkb3duQ29tcG9uZW50fVxyXG4gICAgICAgICAgICAgICAge25ldEluY29tZVRleHRDb21wb25lbnR9XHJcbiAgICAgICAgICAgICAgICB7c2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnR9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bHRMaXN0Q29tcG9uZW50O1xyXG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIgSW5wdXRBY3Rpb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMvSW5wdXRBY3Rpb25Db25zdGFudHMnKTtcclxudmFyIElucHV0U3RvcmUgPSByZXF1aXJlKCcuLi8uLi9zdG9yZXMvSW5wdXRTdG9yZScpO1xyXG52YXIgVmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvVmFsaWRhdG9ycycpO1xyXG52YXIgTW9udGhseUNvc3RJbnB1dERlZmluaXRpb25zID0gcmVxdWlyZSgnLi4vLi4vZGVmaW5lcy9Nb250aGx5Q29zdElucHV0RGVmaW5pdGlvbnMnKTtcclxudmFyIENhbGN1bGF0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQ2FsY3VsYXRpb25zJyk7XHJcbnZhciBOZXRJbmNvbWVCYXNlZExpc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1Jlc3VsdENvbXBvbmVudHMvTmV0SW5jb21lQmFzZWRMaXN0Q29tcG9uZW50Jyk7XHJcblxyXG52YXIgUmVzdWx0TGlzdENvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIF9vbklucHV0Q2hhbmdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgaW5wdXRzOiBJbnB1dFN0b3JlLmdldEFsbCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIElucHV0U3RvcmUuYWRkQ2hhbmdlTGlzdGVuZXIoSW5wdXRBY3Rpb25Db25zdGFudHMuTU9OVEhMWV9DT1NUX0lOUFVUX0NIQU5HRSwgdGhpcy5fb25JbnB1dENoYW5nZSk7XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIElucHV0U3RvcmUucmVtb3ZlQ2hhbmdlTGlzdGVuZXIoSW5wdXRBY3Rpb25Db25zdGFudHMuTU9OVEhMWV9DT1NUX0lOUFVUX0NIQU5HRSwgdGhpcy5fb25JbnB1dENoYW5nZSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbnB1dHM6IElucHV0U3RvcmUuZ2V0QWxsKClcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYoVmFsaWRhdG9ycy52YWxpZGF0ZVJlcXVpcmVkSW5wdXRzRXhpc3QoTW9udGhseUNvc3RJbnB1dERlZmluaXRpb25zLmdldCgpLCB0aGlzLnN0YXRlLmlucHV0cykpe1xyXG4gICAgICAgICAgICB2YXIgbW9udGhseUNhckNvc3QgPSBDYWxjdWxhdGlvbnMubW9udGhseUNvc3QoXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy52ZWhpY2xlUHJpY2UsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5kb3duUGF5bWVudCxcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLnRyYWRlSW4sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5pbnRlcmVzdFJhdGUsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy5zYWxlc1RheCxcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5wdXRzLnRlcm1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cIm1vbnRobHlDb3N0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ3ZWxsIGNlbnRlclRleHRcIj5DYXIgUGF5bWVudCAke21vbnRobHlDYXJDb3N0fS9tb250aDwvaDI+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPE5ldEluY29tZUJhc2VkTGlzdENvbXBvbmVudCBtb250aGx5Q2FyQ29zdD17bW9udGhseUNhckNvc3R9IC8+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj48L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzdWx0TGlzdENvbXBvbmVudDtcclxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwID0gcmVxdWlyZSgncmVhY3QvYWRkb25zL0NTU1RyYW5zaXRpb25Hcm91cCcpO1xyXG52YXIgVGl0bGVEZWZpbml0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RlZmluZXMvVGl0bGVEZWZpbml0aW9ucycpO1xyXG52YXIgdGl0bGVJbnRlcnZhbFRpbWUgPSAxMDAwMDtcclxudmFyIHRpdGxlVXBkYXRlSW50ZXJ2YWw7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjZcclxudmFyIElucHV0Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciB0aXRsZXMgPSBUaXRsZURlZmluaXRpb25zLmdldCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZXNbTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSAqICh0aXRsZXMubGVuZ3RoKSkpXVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRpdGxlVXBkYXRlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgdGl0bGVzID0gVGl0bGVEZWZpbml0aW9ucy5nZXQoKTtcclxuICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVzW01hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAodGl0bGVzLmxlbmd0aCkpKV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgdGl0bGVJbnRlcnZhbFRpbWUpO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGl0bGVVcGRhdGVJbnRlcnZhbCk7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgICA8UmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAgdHJhbnNpdGlvbk5hbWU9XCJmYWRlSW5cIiB0cmFuc2l0aW9uQXBwZWFyPXt0cnVlfSB0cmFuc2l0aW9uTGVhdmU9e2ZhbHNlfT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17dGhpcy5zdGF0ZS50aXRsZX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNSBrZXk9XCJ0aXRsZVwiIGNsYXNzTmFtZT1cImNlbnRlclRleHRcIj57dGhpcy5zdGF0ZS50aXRsZX08L2g1PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9SZWFjdENTU1RyYW5zaXRpb25Hcm91cD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0Q29tcG9uZW50O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIE1PTlRITFlfSU5DT01FX0RFRkFVTFQ6IDAsXHJcbiAgICBNT05USExZX0VYUEVOU0VTX0RFRkFVTFQ6IDAsXHJcbiAgICBTQUZFVFlfTkVUX0RFRkFVTFQ6IDAsXHJcbiAgICBWRUhJQ0xFX1BSSUNFX0RFRkFVTFQ6IHVuZGVmaW5lZCwgLy9vbmx5IHJlcXVpcmVkIGZpZWxkIGZvciBhcHAgdG8gZG8gYmFzaWMgZnVuY1xyXG4gICAgRE9XTl9QQVlNRU5UX0RFRkFVTFQ6IDAsXHJcbiAgICBUUkFERV9JTl9ERUZBVUxUOiAwLFxyXG4gICAgU0FMRVNfVEFYX0RFRkFVTFQ6IDUuMSxcclxuICAgIElOVEVSRVNUX1JBVEVfREVGQVVMVDogMi45LFxyXG4gICAgVEVSTV9ERUZBVUxUOiA3MlxyXG59OyIsInZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdrZXltaXJyb3InKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yKHtcclxuICAgIE1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0U6IG51bGwsXHJcbiAgICBNT05USExZX0lOQ09NRV9DSEFOR0U6IG51bGwsXHJcbiAgICBNT05USExZX0VYUEVOU0VTX0NIQU5HRTogbnVsbCxcclxuICAgIFNBRkVUWV9ORVRfQ0hBTkdFOiBudWxsXHJcbn0pOyIsIm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgRGVmYXVsdElucHV0Q29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL0RlZmF1bHRJbnB1dFZhbHVlQ29uc3RhbnRzJyk7XHJcbiAgICB2YXIgSW5wdXRBY3Rpb25zID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL0lucHV0QWN0aW9uQ29uc3RhbnRzJyk7XHJcbiAgICB2YXIgVmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4uL3V0aWwvVmFsaWRhdG9ycycpO1xyXG4gICAgdmFyIGlucHV0cyA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndmVoaWNsZVByaWNlJyxcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogSW5wdXRBY3Rpb25zLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1ZlaGljbGUgUHJpY2UnLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBEZWZhdWx0SW5wdXRDb25zdGFudHMuVkVISUNMRV9QUklDRV9ERUZBVUxULFxyXG4gICAgICAgICAgICByZXF1aXJlZDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlZFSElDTEVfUFJJQ0VfREVGQVVMVCA9PT0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBhZGRPbjogJyQnLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBWYWxpZGF0b3JzLnZhbGlkYXRlTnVtYmVySW5wdXQsXHJcbiAgICAgICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uKGUpeyByZXR1cm4gcGFyc2VJbnQoZSk7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdkb3duUGF5bWVudCcsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9ucy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdEb3duIFBheW1lbnQnLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBEZWZhdWx0SW5wdXRDb25zdGFudHMuRE9XTl9QQVlNRU5UX0RFRkFVTFQsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBEZWZhdWx0SW5wdXRDb25zdGFudHMuRE9XTl9QQVlNRU5UX0RFRkFVTFQgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWRkT246ICckJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZU51bWJlcklucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlSW50KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndHJhZGVJbicsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9ucy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdUcmFkZSBJbicsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5UUkFERV9JTl9ERUZBVUxULFxyXG4gICAgICAgICAgICByZXF1aXJlZDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlRSQURFX0lOX0RFRkFVTFQgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWRkT246ICckJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZU51bWJlcklucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlSW50KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnc2FsZXNUYXgnLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbnMuTU9OVEhMWV9DT1NUX0lOUFVUX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnU2FsZXMgVGF4JyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlNBTEVTX1RBWF9ERUZBVUxULFxyXG4gICAgICAgICAgICByZXF1aXJlZDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlNBTEVTX1RBWF9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uQmVmb3JlSW5wdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBhZGRPbjogJyUnLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBWYWxpZGF0b3JzLnZhbGlkYXRlUGVyY2VudElucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlRmxvYXQoZSk7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdpbnRlcmVzdFJhdGUnLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbnMuTU9OVEhMWV9DT1NUX0lOUFVUX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnSW50ZXJlc3QgUmF0ZSAoQVBSKScsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5JTlRFUkVTVF9SQVRFX0RFRkFVTFQsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBEZWZhdWx0SW5wdXRDb25zdGFudHMuSU5URVJFU1RfUkFURV9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uQmVmb3JlSW5wdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBhZGRPbjogJyUnLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBWYWxpZGF0b3JzLnZhbGlkYXRlUGVyY2VudElucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlRmxvYXQoZSk7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICd0ZXJtJyxcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogSW5wdXRBY3Rpb25zLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1Rlcm0gKE1vbnRocyknLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBEZWZhdWx0SW5wdXRDb25zdGFudHMuVEVSTV9ERUZBVUxULFxyXG4gICAgICAgICAgICByZXF1aXJlZDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlRFUk1fREVGQVVMVCA9PT0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBhZGRPbkJlZm9yZUlucHV0OiBmYWxzZSxcclxuICAgICAgICAgICAgYWRkT246ICdtb250aHMnLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBWYWxpZGF0b3JzLnZhbGlkYXRlTnVtYmVySW5wdXQsXHJcbiAgICAgICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uKGUpeyByZXR1cm4gcGFyc2VJbnQoZSk7IH1cclxuICAgICAgICB9XHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGlucHV0cztcclxufTsiLCJtb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIERlZmF1bHRJbnB1dENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9EZWZhdWx0SW5wdXRWYWx1ZUNvbnN0YW50cycpO1xyXG4gICAgdmFyIElucHV0QWN0aW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL0lucHV0QWN0aW9uQ29uc3RhbnRzJyk7XHJcbiAgICB2YXIgVmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4uL3V0aWwvVmFsaWRhdG9ycycpO1xyXG4gICAgdmFyIGlucHV0cyA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnbW9udGhseUluY29tZScsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfSU5DT01FX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnTW9udGhseSBJbmNvbWUnLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBEZWZhdWx0SW5wdXRDb25zdGFudHMuTU9OVEhMWV9JTkNPTUVfREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5NT05USExZX0lOQ09NRV9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ21vbnRobHlFeHBlbnNlcycsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfRVhQRU5TRVNfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdNb250aGx5IEV4cGVuc2VzJyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLk1PTlRITFlfRVhQRU5TRVNfREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5NT05USExZX0VYUEVOU0VTX0RFRkFVTFQgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWRkT246ICckJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZU51bWJlcklucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlSW50KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnc2FmZXR5TmV0JyxcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogSW5wdXRBY3Rpb25Db25zdGFudHMuU0FGRVRZX05FVF9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1NhdmluZ3MgLyBTYWZldHkgTmV0JyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlNBRkVUWV9ORVRfREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5TQUZFVFlfTkVUX0RFRkFVTFQgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWRkT246ICckJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZU51bWJlcklucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlSW50KGUpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgXTtcclxuICAgIHJldHVybiBpbnB1dHM7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgXCJJdCdzIFdvcnRoIEl0LiBTaWduLiBUcnVzdCBNZS5cIixcclxuICAgICAgICBcIkl0J3MgT25seSA1SyBMZXNzIFRoYW4gQSBNb3J0Z2FnZS5cIixcclxuICAgICAgICBcIkNhbiBZb3UgUmVhbGx5IFB1dCBBIFByaWNlIE9uIEZ1bj9cIixcclxuICAgICAgICBcIlJldGlyZW1lbnQgSXMgU3RpbGwgNDAgWWVhcnMgT3V0LlwiLFxyXG4gICAgICAgIFwiV2hlbiBJbiBEb3VidCBHZXQgQSBWOC5cIixcclxuICAgICAgICBcIkFkcmVuYWxpbmUgSXMgUHJpY2VsZXNzLlwiLFxyXG4gICAgICAgIFwiTGlmZSBJcyBUb28gU2hvcnQgVG8gRHJpdmUgQSBCb3JpbmcgQ2FyLlwiLFxyXG4gICAgICAgIFwiSnVzdCBDdXQgQmFjayBPbiBFYXRpbmcgT3V0LlwiXHJcbiAgICBdXHJcbn07XHJcbiIsInZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnZmx1eCcpLkRpc3BhdGNoZXI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBEaXNwYXRjaGVyKCk7IiwidmFyIEFwcERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyL0FwcERpc3BhdGNoZXInKTtcclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcclxudmFyIElucHV0QWN0aW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL0lucHV0QWN0aW9uQ29uc3RhbnRzJyk7XHJcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgX2lucHV0cyA9IHt9O1xyXG5cclxudmFyIElucHV0U3RvcmUgPSBhc3NpZ24oe30sIEV2ZW50RW1pdHRlci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgICAgcmV0dXJuIF9pbnB1dHNba2V5XTtcclxuICAgIH0sXHJcbiAgICBnZXRBbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfaW5wdXRzO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbWl0TW9udGhseUNvc3RJbnB1dENoYW5nZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbWl0U2NlbmFyaW9DaGFuZ2U6IGZ1bmN0aW9uKHNjZW5hcmlvQWN0aW9uVHlwZUNvbnN0YW50KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KHNjZW5hcmlvQWN0aW9uVHlwZUNvbnN0YW50KTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkQ2hhbmdlTGlzdGVuZXI6IGZ1bmN0aW9uKFR5cGVPZkNoYW5nZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm9uKFR5cGVPZkNoYW5nZSwgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZUNoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbihUeXBlT2ZDaGFuZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihUeXBlT2ZDaGFuZ2UsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuQXBwRGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihhY3Rpb24pIHtcclxuXHJcbiAgICBzd2l0Y2goYWN0aW9uLmFjdGlvblR5cGUpIHtcclxuICAgICAgICBjYXNlIElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0U6XHJcbiAgICAgICAgICAgIF9pbnB1dHNbYWN0aW9uLm1vZGVsS2V5XSA9IGFjdGlvbi5tb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICBJbnB1dFN0b3JlLmVtaXRNb250aGx5Q29zdElucHV0Q2hhbmdlKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgSW5wdXRBY3Rpb25Db25zdGFudHMuTU9OVEhMWV9JTkNPTUVfQ0hBTkdFOlxyXG4gICAgICAgICAgICBfaW5wdXRzW2FjdGlvbi5tb2RlbEtleV0gPSBhY3Rpb24ubW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgSW5wdXRTdG9yZS5lbWl0U2NlbmFyaW9DaGFuZ2UoYWN0aW9uLmFjdGlvblR5cGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfRVhQRU5TRVNfQ0hBTkdFOlxyXG4gICAgICAgICAgICBfaW5wdXRzW2FjdGlvbi5tb2RlbEtleV0gPSBhY3Rpb24ubW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgSW5wdXRTdG9yZS5lbWl0U2NlbmFyaW9DaGFuZ2UoYWN0aW9uLmFjdGlvblR5cGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIElucHV0QWN0aW9uQ29uc3RhbnRzLlNBRkVUWV9ORVRfQ0hBTkdFOlxyXG4gICAgICAgICAgICBfaW5wdXRzW2FjdGlvbi5tb2RlbEtleV0gPSBhY3Rpb24ubW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgSW5wdXRTdG9yZS5lbWl0U2NlbmFyaW9DaGFuZ2UoYWN0aW9uLmFjdGlvblR5cGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vIG5vIG9wXHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5wdXRTdG9yZTsiLCJtb2R1bGUuZXhwb3J0cy5tb250aGx5Q29zdCA9IGZ1bmN0aW9uKHZlaGljbGVQcmljZSwgZG93blBheW1lbnQsIHRyYWRlSW4sIGludGVyZXN0UmF0ZSwgc2FsZXNUYXgsIHRlcm0pe1xyXG4gICAgdmFyIGFkanVzdGVkSW50ZXJlc3RSYXRlUGVyY2VudCA9IGludGVyZXN0UmF0ZSAqIC4wMTtcclxuICAgIHZhciBhZGp1c3RlZFNhbGVzVGF4UGVyY2VudCA9IHNhbGVzVGF4ICogLjAxOyAvLyAyLjkgPT4gLjAyOVxyXG4gICAgdmFyIHNhbGVzVGF4QW1vdW50ID0gdmVoaWNsZVByaWNlICogYWRqdXN0ZWRTYWxlc1RheFBlcmNlbnQ7XHJcbiAgICB2YXIgbmV0Q29zdCA9IHZlaGljbGVQcmljZSArIHNhbGVzVGF4QW1vdW50IC0gZG93blBheW1lbnQgLSB0cmFkZUluO1xyXG4gICAgdmFyIHJhdGUgPSBhZGp1c3RlZEludGVyZXN0UmF0ZVBlcmNlbnQgLyAxMjtcclxuICAgIHZhciByYXRlQ2FsYyA9IChyYXRlICogTWF0aC5wb3coKDEgKyByYXRlKSwgdGVybSkpLyhNYXRoLnBvdygoMSArIHJhdGUpLCB0ZXJtKSAtIDEpO1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoKG5ldENvc3QgKiByYXRlQ2FsYykudG9GaXhlZCgyKSk7XHJcbn07IiwiLypcclxuICB1bmRlZmluZWQncyBhcmUgb2ssIGRlZmF1bHRzIGFyZSBzZXQgZm9yIGlucHV0cyAoYW5kIGlmIG5vIGRlZmF1bHQsIGNhbGMgc2ltcGx5IGlzbid0IG1hZGUpXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZU51bWJlcklucHV0ID0gZnVuY3Rpb24oaW5wdXQpe1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGlmKGlucHV0ID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcGFyc2VJbnQoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzLnZhbGlkYXRlUGVyY2VudElucHV0ID0gZnVuY3Rpb24ocGVyY2VudCl7XHJcbiAgICB0cnl7XHJcbiAgICAgICAgaWYocGVyY2VudCA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChwZXJjZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfWNhdGNoKGUpe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMudmFsaWRhdGVSZXF1aXJlZElucHV0c0V4aXN0ID0gZnVuY3Rpb24oaW5wdXREZWZpbml0aW9ucywgaW5wdXRNb2RlbHMpe1xyXG4gICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xyXG4gICAgaW5wdXREZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIGlmKGlucHV0TW9kZWxzW2UuaWRdID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBpZihlLmRlZmF1bHQgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBpbnB1dE1vZGVsc1tlLmlkXSA9IGUuZGVmYXVsdDtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpc1ZhbGlkO1xyXG59OyJdfQ==
