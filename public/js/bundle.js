(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher')

},{"./lib/Dispatcher":4}],4:[function(require,module,exports){
/*
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * @typechecks
 */

"use strict";

var invariant = require('./invariant');

var _lastID = 1;
var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *    CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *
 *         case 'city-update':
 *           FlightPriceStore.price =
 *             FlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

  function Dispatcher() {
    this.$Dispatcher_callbacks = {};
    this.$Dispatcher_isPending = {};
    this.$Dispatcher_isHandled = {};
    this.$Dispatcher_isDispatching = false;
    this.$Dispatcher_pendingPayload = null;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   *
   * @param {function} callback
   * @return {string}
   */
  Dispatcher.prototype.register=function(callback) {
    var id = _prefix + _lastID++;
    this.$Dispatcher_callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   *
   * @param {string} id
   */
  Dispatcher.prototype.unregister=function(id) {
    invariant(
      this.$Dispatcher_callbacks[id],
      'Dispatcher.unregister(...): `%s` does not map to a registered callback.',
      id
    );
    delete this.$Dispatcher_callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   *
   * @param {array<string>} ids
   */
  Dispatcher.prototype.waitFor=function(ids) {
    invariant(
      this.$Dispatcher_isDispatching,
      'Dispatcher.waitFor(...): Must be invoked while dispatching.'
    );
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this.$Dispatcher_isPending[id]) {
        invariant(
          this.$Dispatcher_isHandled[id],
          'Dispatcher.waitFor(...): Circular dependency detected while ' +
          'waiting for `%s`.',
          id
        );
        continue;
      }
      invariant(
        this.$Dispatcher_callbacks[id],
        'Dispatcher.waitFor(...): `%s` does not map to a registered callback.',
        id
      );
      this.$Dispatcher_invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   *
   * @param {object} payload
   */
  Dispatcher.prototype.dispatch=function(payload) {
    invariant(
      !this.$Dispatcher_isDispatching,
      'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'
    );
    this.$Dispatcher_startDispatching(payload);
    try {
      for (var id in this.$Dispatcher_callbacks) {
        if (this.$Dispatcher_isPending[id]) {
          continue;
        }
        this.$Dispatcher_invokeCallback(id);
      }
    } finally {
      this.$Dispatcher_stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   *
   * @return {boolean}
   */
  Dispatcher.prototype.isDispatching=function() {
    return this.$Dispatcher_isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @param {string} id
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_invokeCallback=function(id) {
    this.$Dispatcher_isPending[id] = true;
    this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);
    this.$Dispatcher_isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @param {object} payload
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_startDispatching=function(payload) {
    for (var id in this.$Dispatcher_callbacks) {
      this.$Dispatcher_isPending[id] = false;
      this.$Dispatcher_isHandled[id] = false;
    }
    this.$Dispatcher_pendingPayload = payload;
    this.$Dispatcher_isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */
  Dispatcher.prototype.$Dispatcher_stopDispatching=function() {
    this.$Dispatcher_pendingPayload = null;
    this.$Dispatcher_isDispatching = false;
  };


module.exports = Dispatcher;

},{"./invariant":5}],5:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

},{}],6:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

"use strict";

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  if (!(obj instanceof Object && !Array.isArray(obj))) {
    throw new Error('keyMirror(...): Argument must be an object.');
  }
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

},{}],7:[function(require,module,exports){
'use strict';
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function ownEnumerableKeys(obj) {
	var keys = Object.getOwnPropertyNames(obj);

	if (Object.getOwnPropertySymbols) {
		keys = keys.concat(Object.getOwnPropertySymbols(obj));
	}

	return keys.filter(function (key) {
		return propIsEnumerable.call(obj, key);
	});
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = ownEnumerableKeys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],8:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react/addons"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react/addons"], factory);
	else if(typeof exports === 'object')
		exports["Highcharts"] = factory(require("react"), require("react/addons"));
	else
		root["Highcharts"] = factory(root["react"], root["react/addons"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {global.HighchartsAdapter = __webpack_require__(5);
	var Highcharts = __webpack_require__(6);
	var React = __webpack_require__(2);
	var update = __webpack_require__(3).addons.update;
	module.exports = React.createClass({
	  displayName: 'Highcharts',

	  renderChart: function () {
	    if (!this.props.config) {
	      throw new Error('Config has to be specified, for the Highchart component');
	    }

	    var config = this.props.config;
	    var node = this.refs.chart.getDOMNode();

	    if (!config.chart) {
	      config = update(config, {chart: {$set: {}}})
	    }

	    config = update(config, {chart: {renderTo: {$set: node}}});

	    new Highcharts.Chart(config);
	  },

	  componentDidMount: function () {
	    this.renderChart();
	  },
	  componentDidUpdate: function () {
	    this.renderChart();
	  },
	  render: function () {
	    return React.createElement("div", {className: "chart", ref: "chart"})
	  }
	});

	module.exports.Highcharts = Highcharts;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */,
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license @product.name@ JS v@product.version@ (@product.date@)
	 *
	 * Standalone Highcharts Framework
	 *
	 * License: MIT License
	 */


	/*global Highcharts */
	var HighchartsAdapter = (function () {

	var UNDEFINED,
		doc = document,
		emptyArray = [],
		timers = [],
		timerId,
		animSetters = {},
		Fx;

	Math.easeInOutSine = function (t, b, c, d) {
		return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	};



	/**
	 * Extend given object with custom events
	 */
	function augment(obj) {
		function removeOneEvent(el, type, fn) {
			el.removeEventListener(type, fn, false);
		}

		function IERemoveOneEvent(el, type, fn) {
			fn = el.HCProxiedMethods[fn.toString()];
			el.detachEvent('on' + type, fn);
		}

		function removeAllEvents(el, type) {
			var events = el.HCEvents,
				remove,
				types,
				len,
				n;

			if (el.removeEventListener) {
				remove = removeOneEvent;
			} else if (el.attachEvent) {
				remove = IERemoveOneEvent;
			} else {
				return; // break on non-DOM events
			}


			if (type) {
				types = {};
				types[type] = true;
			} else {
				types = events;
			}

			for (n in types) {
				if (events[n]) {
					len = events[n].length;
					while (len--) {
						remove(el, n, events[n][len]);
					}
				}
			}
		}

		if (!obj.HCExtended) {
			Highcharts.extend(obj, {
				HCExtended: true,

				HCEvents: {},

				bind: function (name, fn) {
					var el = this,
						events = this.HCEvents,
						wrappedFn;

					// handle DOM events in modern browsers
					if (el.addEventListener) {
						el.addEventListener(name, fn, false);

					// handle old IE implementation
					} else if (el.attachEvent) {
						
						wrappedFn = function (e) {
							e.target = e.srcElement || window; // #2820
							fn.call(el, e);
						};

						if (!el.HCProxiedMethods) {
							el.HCProxiedMethods = {};
						}

						// link wrapped fn with original fn, so we can get this in removeEvent
						el.HCProxiedMethods[fn.toString()] = wrappedFn;

						el.attachEvent('on' + name, wrappedFn);
					}


					if (events[name] === UNDEFINED) {
						events[name] = [];
					}

					events[name].push(fn);
				},

				unbind: function (name, fn) {
					var events,
						index;

					if (name) {
						events = this.HCEvents[name] || [];
						if (fn) {
							index = HighchartsAdapter.inArray(fn, events);
							if (index > -1) {
								events.splice(index, 1);
								this.HCEvents[name] = events;
							}
							if (this.removeEventListener) {
								removeOneEvent(this, name, fn);
							} else if (this.attachEvent) {
								IERemoveOneEvent(this, name, fn);
							}
						} else {
							removeAllEvents(this, name);
							this.HCEvents[name] = [];
						}
					} else {
						removeAllEvents(this);
						this.HCEvents = {};
					}
				},

				trigger: function (name, args) {
					var events = this.HCEvents[name] || [],
						target = this,
						len = events.length,
						i,
						preventDefault,
						fn;

					// Attach a simple preventDefault function to skip default handler if called
					preventDefault = function () {
						args.defaultPrevented = true;
					};
					
					for (i = 0; i < len; i++) {
						fn = events[i];

						// args is never null here
						if (args.stopped) {
							return;
						}

						args.preventDefault = preventDefault;
						args.target = target;

						// If the type is not set, we're running a custom event (#2297). If it is set,
						// we're running a browser event, and setting it will cause en error in
						// IE8 (#2465).
						if (!args.type) {
							args.type = name;
						}
						

						
						// If the event handler return false, prevent the default handler from executing
						if (fn.call(this, args) === false) {
							args.preventDefault();
						}
					}
				}
			});
		}

		return obj;
	}


	return {

		/**
		 * Initialize the adapter. This is run once as Highcharts is first run.
		 */
		init: function (pathAnim) {

			/**
			 * Compatibility section to add support for legacy IE. This can be removed if old IE 
			 * support is not needed.
			 */
			if (!doc.defaultView) {
				this._getStyle = function (el, prop) {
					var val;
					if (el.style[prop]) {
						return el.style[prop];
					} else {
						if (prop === 'opacity') {
							prop = 'filter';
						}
						/*jslint unparam: true*/
						val = el.currentStyle[prop.replace(/\-(\w)/g, function (a, b) { return b.toUpperCase(); })];
						if (prop === 'filter') {
							val = val.replace(
								/alpha\(opacity=([0-9]+)\)/, 
								function (a, b) { 
									return b / 100; 
								}
							);
						}
						/*jslint unparam: false*/
						return val === '' ? 1 : val;
					} 
				};
				this.adapterRun = function (elem, method) {
					var alias = { width: 'clientWidth', height: 'clientHeight' }[method];

					if (alias) {
						elem.style.zoom = 1;
						return elem[alias] - 2 * parseInt(HighchartsAdapter._getStyle(elem, 'padding'), 10);
					}
				};
			}

			if (!Array.prototype.forEach) {
				this.each = function (arr, fn) { // legacy
					var i = 0, 
						len = arr.length;
					for (; i < len; i++) {
						if (fn.call(arr[i], arr[i], i, arr) === false) {
							return i;
						}
					}
				};
			}

			if (!Array.prototype.indexOf) {
				this.inArray = function (item, arr) {
					var len, 
						i = 0;

					if (arr) {
						len = arr.length;
						
						for (; i < len; i++) {
							if (arr[i] === item) {
								return i;
							}
						}
					}

					return -1;
				};
			}

			if (!Array.prototype.filter) {
				this.grep = function (elements, callback) {
					var ret = [],
						i = 0,
						length = elements.length;

					for (; i < length; i++) {
						if (!!callback(elements[i], i)) {
							ret.push(elements[i]);
						}
					}

					return ret;
				};
			}

			//--- End compatibility section ---


			/**
			 * Start of animation specific code
			 */
			Fx = function (elem, options, prop) {
				this.options = options;
				this.elem = elem;
				this.prop = prop;
			};
			Fx.prototype = {
				
				update: function () {
					var styles,
						paths = this.paths,
						elem = this.elem,
						elemelem = elem.element; // if destroyed, it is null

					// Animation setter defined from outside
					if (animSetters[this.prop]) {
						animSetters[this.prop](this);

					// Animating a path definition on SVGElement
					} else if (paths && elemelem) {
						elem.attr('d', pathAnim.step(paths[0], paths[1], this.now, this.toD));

					// Other animations on SVGElement
					} else if (elem.attr) {
						if (elemelem) {
							elem.attr(this.prop, this.now);
						}

					// HTML styles
					} else {
						styles = {};
						styles[this.prop] = this.now + this.unit;
						Highcharts.css(elem, styles);
					}
					
					if (this.options.step) {
						this.options.step.call(this.elem, this.now, this);
					}

				},
				custom: function (from, to, unit) {
					var self = this,
						t = function (gotoEnd) {
							return self.step(gotoEnd);
						},
						i;

					this.startTime = +new Date();
					this.start = from;
					this.end = to;
					this.unit = unit;
					this.now = this.start;
					this.pos = this.state = 0;

					t.elem = this.elem;

					if (t() && timers.push(t) === 1) {
						timerId = setInterval(function () {
							
							for (i = 0; i < timers.length; i++) {
								if (!timers[i]()) {
									timers.splice(i--, 1);
								}
							}

							if (!timers.length) {
								clearInterval(timerId);
							}
						}, 13);
					}
				},
				
				step: function (gotoEnd) {
					var t = +new Date(),
						ret,
						done,
						options = this.options,
						elem = this.elem,
						i;
					
					if (elem.stopAnimation || (elem.attr && !elem.element)) { // #2616, element including flag is destroyed
						ret = false;

					} else if (gotoEnd || t >= options.duration + this.startTime) {
						this.now = this.end;
						this.pos = this.state = 1;
						this.update();

						this.options.curAnim[this.prop] = true;

						done = true;
						for (i in options.curAnim) {
							if (options.curAnim[i] !== true) {
								done = false;
							}
						}

						if (done) {
							if (options.complete) {
								options.complete.call(elem);
							}
						}
						ret = false;

					} else {
						var n = t - this.startTime;
						this.state = n / options.duration;
						this.pos = options.easing(n, 0, 1, options.duration);
						this.now = this.start + ((this.end - this.start) * this.pos);
						this.update();
						ret = true;
					}
					return ret;
				}
			};

			/**
			 * The adapter animate method
			 */
			this.animate = function (el, prop, opt) {
				var start,
					unit = '',
					end,
					fx,
					args,
					name;

				el.stopAnimation = false; // ready for new

				if (typeof opt !== 'object' || opt === null) {
					args = arguments;
					opt = {
						duration: args[2],
						easing: args[3],
						complete: args[4]
					};
				}
				if (typeof opt.duration !== 'number') {
					opt.duration = 400;
				}
				opt.easing = Math[opt.easing] || Math.easeInOutSine;
				opt.curAnim = Highcharts.extend({}, prop);
				
				for (name in prop) {
					fx = new Fx(el, opt, name);
					end = null;
					
					if (name === 'd') {
						fx.paths = pathAnim.init(
							el,
							el.d,
							prop.d
						);
						fx.toD = prop.d;
						start = 0;
						end = 1;
					} else if (el.attr) {
						start = el.attr(name);
					} else {
						start = parseFloat(HighchartsAdapter._getStyle(el, name)) || 0;
						if (name !== 'opacity') {
							unit = 'px';
						}
					}
		
					if (!end) {
						end = prop[name];
					}
					fx.custom(start, end, unit);
				}	
			};
		},

		/**
		 * Internal method to return CSS value for given element and property
		 */
		_getStyle: function (el, prop) {
			return window.getComputedStyle(el, undefined).getPropertyValue(prop);
		},

		/**
		 * Add an animation setter for a specific property
		 */
		addAnimSetter: function (prop, fn) {
			animSetters[prop] = fn;
		},

		/**
		 * Downloads a script and executes a callback when done.
		 * @param {String} scriptLocation
		 * @param {Function} callback
		 */
		getScript: function (scriptLocation, callback) {
			// We cannot assume that Assets class from mootools-more is available so instead insert a script tag to download script.
			var head = doc.getElementsByTagName('head')[0],
				script = doc.createElement('script');

			script.type = 'text/javascript';
			script.src = scriptLocation;
			script.onload = callback;

			head.appendChild(script);
		},

		/**
		 * Return the index of an item in an array, or -1 if not found
		 */
		inArray: function (item, arr) {
			return arr.indexOf ? arr.indexOf(item) : emptyArray.indexOf.call(arr, item);
		},


		/**
		 * A direct link to adapter methods
		 */
		adapterRun: function (elem, method) {
			return parseInt(HighchartsAdapter._getStyle(elem, method), 10);
		},

		/**
		 * Filter an array
		 */
		grep: function (elements, callback) {
			return emptyArray.filter.call(elements, callback);
		},

		/**
		 * Map an array
		 */
		map: function (arr, fn) {
			var results = [], i = 0, len = arr.length;

			for (; i < len; i++) {
				results[i] = fn.call(arr[i], arr[i], i, arr);
			}

			return results;
		},

		/**
		 * Get the element's offset position, corrected by overflow:auto. Loosely based on jQuery's offset method.
		 */
		offset: function (el) {
			var docElem = document.documentElement,
				box = el.getBoundingClientRect();

			return {
				top: box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),
				left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
			};
		},

		/**
		 * Add an event listener
		 */
		addEvent: function (el, type, fn) {
			augment(el).bind(type, fn);
		},

		/**
		 * Remove event added with addEvent
		 */
		removeEvent: function (el, type, fn) {
			augment(el).unbind(type, fn);
		},

		/**
		 * Fire an event on a custom object
		 */
		fireEvent: function (el, type, eventArguments, defaultFunction) {
			var e;

			if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
				e = doc.createEvent('Events');
				e.initEvent(type, true, true);
				e.target = el;

				Highcharts.extend(e, eventArguments);

				if (el.dispatchEvent) {
					el.dispatchEvent(e);
				} else {
					el.fireEvent(type, e);
				}

			} else if (el.HCExtended === true) {
				eventArguments = eventArguments || {};
				el.trigger(type, eventArguments);
			}

			if (eventArguments && eventArguments.defaultPrevented) {
				defaultFunction = null;
			}

			if (defaultFunction) {
				defaultFunction(eventArguments);
			}
		},

		washMouseEvent: function (e) {
			return e;
		},


		/**
		 * Stop running animation
		 */
		stop: function (el) {
			el.stopAnimation = true;
		},

		/**
		 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
		 * @param {Array} arr
		 * @param {Function} fn
		 */
		each: function (arr, fn) { // modern browsers
			return Array.prototype.forEach.call(arr, fn);
		}
	};
	}());


	/*** EXPORTS FROM exports-loader ***/
	module.exports = HighchartsAdapter

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// ==ClosureCompiler==
	// @compilation_level SIMPLE_OPTIMIZATIONS

	/**
	 * @license Highcharts JS v4.1.4-modified ()
	 *
	 * (c) 2009-2014 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	// JSLint options:
	/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */
	/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */
	(function () {
	// encapsulated variables
	var UNDEFINED,
		doc = document,
		win = window,
		math = Math,
		mathRound = math.round,
		mathFloor = math.floor,
		mathCeil = math.ceil,
		mathMax = math.max,
		mathMin = math.min,
		mathAbs = math.abs,
		mathCos = math.cos,
		mathSin = math.sin,
		mathPI = math.PI,
		deg2rad = mathPI * 2 / 360,


		// some variables
		userAgent = navigator.userAgent,
		isOpera = win.opera,
		isIE = /(msie|trident)/i.test(userAgent) && !isOpera,
		docMode8 = doc.documentMode === 8,
		isWebKit = /AppleWebKit/.test(userAgent),
		isFirefox = /Firefox/.test(userAgent),
		isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
		SVG_NS = 'http://www.w3.org/2000/svg',
		hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
		hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
		useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
		Renderer,
		hasTouch,
		symbolSizes = {},
		idCounter = 0,
		garbageBin,
		defaultOptions,
		dateFormat, // function
		globalAnimation,
		pathAnim,
		timeUnits,
		noop = function () { return UNDEFINED; },
		charts = [],
		chartCount = 0,
		PRODUCT = 'Highcharts',
		VERSION = '4.1.4-modified',

		// some constants for frequently used strings
		DIV = 'div',
		ABSOLUTE = 'absolute',
		RELATIVE = 'relative',
		HIDDEN = 'hidden',
		PREFIX = 'highcharts-',
		VISIBLE = 'visible',
		PX = 'px',
		NONE = 'none',
		M = 'M',
		L = 'L',
		numRegex = /^[0-9]+$/,
		NORMAL_STATE = '',
		HOVER_STATE = 'hover',
		SELECT_STATE = 'select',
		marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
		
		// Object for extending Axis
		AxisPlotLineOrBandExtension,

		// constants for attributes
		STROKE_WIDTH = 'stroke-width',

		// time methods, changed based on whether or not UTC is used
		Date,  // Allow using a different Date class
		makeTime,
		timezoneOffset,
		getTimezoneOffset,
		getMinutes,
		getHours,
		getDay,
		getDate,
		getMonth,
		getFullYear,
		setMinutes,
		setHours,
		setDate,
		setMonth,
		setFullYear,


		// lookup over the types and the associated classes
		seriesTypes = {},
		Highcharts;

	// The Highcharts namespace
	Highcharts = win.Highcharts = win.Highcharts ? error(16, true) : {};

	Highcharts.seriesTypes = seriesTypes;

	/**
	 * Extend an object with the members of another
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to add to the first one
	 */
	var extend = Highcharts.extend = function (a, b) {
		var n;
		if (!a) {
			a = {};
		}
		for (n in b) {
			a[n] = b[n];
		}
		return a;
	};
		
	/**
	 * Deep merge two or more objects and return a third object. If the first argument is
	 * true, the contents of the second object is copied into the first object.
	 * Previously this function redirected to jQuery.extend(true), but this had two limitations.
	 * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
	 * it copied properties from extended prototypes. 
	 */
	function merge() {
		var i,
			args = arguments,
			len,
			ret = {},
			doCopy = function (copy, original) {
				var value, key;

				// An object is replacing a primitive
				if (typeof copy !== 'object') {
					copy = {};
				}

				for (key in original) {
					if (original.hasOwnProperty(key)) {
						value = original[key];

						// Copy the contents of objects, but not arrays or DOM nodes
						if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&
								key !== 'renderTo' && typeof value.nodeType !== 'number') {
							copy[key] = doCopy(copy[key] || {}, value);
					
						// Primitives and arrays are copied over directly
						} else {
							copy[key] = original[key];
						}
					}
				}
				return copy;
			};

		// If first argument is true, copy into the existing object. Used in setOptions.
		if (args[0] === true) {
			ret = args[1];
			args = Array.prototype.slice.call(args, 2);
		}

		// For each argument, extend the return
		len = args.length;
		for (i = 0; i < len; i++) {
			ret = doCopy(ret, args[i]);
		}

		return ret;
	}

	/**
	 * Shortcut for parseInt
	 * @param {Object} s
	 * @param {Number} mag Magnitude
	 */
	function pInt(s, mag) {
		return parseInt(s, mag || 10);
	}

	/**
	 * Check for string
	 * @param {Object} s
	 */
	function isString(s) {
		return typeof s === 'string';
	}

	/**
	 * Check for object
	 * @param {Object} obj
	 */
	function isObject(obj) {
		return obj && typeof obj === 'object';
	}

	/**
	 * Check for array
	 * @param {Object} obj
	 */
	function isArray(obj) {
		return Object.prototype.toString.call(obj) === '[object Array]';
	}

	/**
	 * Check for number
	 * @param {Object} n
	 */
	function isNumber(n) {
		return typeof n === 'number';
	}

	function log2lin(num) {
		return math.log(num) / math.LN10;
	}
	function lin2log(num) {
		return math.pow(10, num);
	}

	/**
	 * Remove last occurence of an item from an array
	 * @param {Array} arr
	 * @param {Mixed} item
	 */
	function erase(arr, item) {
		var i = arr.length;
		while (i--) {
			if (arr[i] === item) {
				arr.splice(i, 1);
				break;
			}
		}
		//return arr;
	}

	/**
	 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
	 * @param {Object} obj
	 */
	function defined(obj) {
		return obj !== UNDEFINED && obj !== null;
	}

	/**
	 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
	 * it attempts to set expando properties on the SVG element, which is not allowed.
	 *
	 * @param {Object} elem The DOM element to receive the attribute(s)
	 * @param {String|Object} prop The property or an abject of key-value pairs
	 * @param {String} value The value if a single property is set
	 */
	function attr(elem, prop, value) {
		var key,
			ret;

		// if the prop is a string
		if (isString(prop)) {
			// set the value
			if (defined(value)) {
				elem.setAttribute(prop, value);

			// get the value
			} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
				ret = elem.getAttribute(prop);
			}

		// else if prop is defined, it is a hash of key/value pairs
		} else if (defined(prop) && isObject(prop)) {
			for (key in prop) {
				elem.setAttribute(key, prop[key]);
			}
		}
		return ret;
	}
	/**
	 * Check if an element is an array, and if not, make it into an array. Like
	 * MooTools' $.splat.
	 */
	function splat(obj) {
		return isArray(obj) ? obj : [obj];
	}


	/**
	 * Return the first value that is defined. Like MooTools' $.pick.
	 */
	var pick = Highcharts.pick = function () {
		var args = arguments,
			i,
			arg,
			length = args.length;
		for (i = 0; i < length; i++) {
			arg = args[i];
			if (arg !== UNDEFINED && arg !== null) {
				return arg;
			}
		}
	};

	/**
	 * Set CSS on a given element
	 * @param {Object} el
	 * @param {Object} styles Style object with camel case property names
	 */
	function css(el, styles) {
		if (isIE && !hasSVG) { // #2686
			if (styles && styles.opacity !== UNDEFINED) {
				styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
			}
		}
		extend(el.style, styles);
	}

	/**
	 * Utility function to create element with attributes and styles
	 * @param {Object} tag
	 * @param {Object} attribs
	 * @param {Object} styles
	 * @param {Object} parent
	 * @param {Object} nopad
	 */
	function createElement(tag, attribs, styles, parent, nopad) {
		var el = doc.createElement(tag);
		if (attribs) {
			extend(el, attribs);
		}
		if (nopad) {
			css(el, {padding: 0, border: NONE, margin: 0});
		}
		if (styles) {
			css(el, styles);
		}
		if (parent) {
			parent.appendChild(el);
		}
		return el;
	}

	/**
	 * Extend a prototyped class by new members
	 * @param {Object} parent
	 * @param {Object} members
	 */
	function extendClass(parent, members) {
		var object = function () { return UNDEFINED; };
		object.prototype = new parent();
		extend(object.prototype, members);
		return object;
	}

	/**
	 * Pad a string to a given length by adding 0 to the beginning
	 * @param {Number} number
	 * @param {Number} length
	 */
	function pad(number, length) {
		// Create an array of the remaining length +1 and join it with 0's
		return new Array((length || 2) + 1 - String(number).length).join(0) + number;
	}

	/**
	 * Wrap a method with extended functionality, preserving the original function
	 * @param {Object} obj The context object that the method belongs to 
	 * @param {String} method The name of the method to extend
	 * @param {Function} func A wrapper function callback. This function is called with the same arguments
	 * as the original function, except that the original function is unshifted and passed as the first 
	 * argument. 
	 */
	var wrap = Highcharts.wrap = function (obj, method, func) {
		var proceed = obj[method];
		obj[method] = function () {
			var args = Array.prototype.slice.call(arguments);
			args.unshift(proceed);
			return func.apply(this, args);
		};
	};


	function getTZOffset(timestamp) {
		return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
	}

	/**
	 * Based on http://www.php.net/manual/en/function.strftime.php
	 * @param {String} format
	 * @param {Number} timestamp
	 * @param {Boolean} capitalize
	 */
	dateFormat = function (format, timestamp, capitalize) {
		if (!defined(timestamp) || isNaN(timestamp)) {
			return 'Invalid date';
		}
		format = pick(format, '%Y-%m-%d %H:%M:%S');

		var date = new Date(timestamp - getTZOffset(timestamp)),
			key, // used in for constuct below
			// get the basic time values
			hours = date[getHours](),
			day = date[getDay](),
			dayOfMonth = date[getDate](),
			month = date[getMonth](),
			fullYear = date[getFullYear](),
			lang = defaultOptions.lang,
			langWeekdays = lang.weekdays,

			// List all format keys. Custom formats can be added from the outside. 
			replacements = extend({

				// Day
				'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
				'A': langWeekdays[day], // Long weekday, like 'Monday'
				'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
				'e': dayOfMonth, // Day of the month, 1 through 31
				'w': day,

				// Week (none implemented)
				//'W': weekNumber(),

				// Month
				'b': lang.shortMonths[month], // Short month, like 'Jan'
				'B': lang.months[month], // Long month, like 'January'
				'm': pad(month + 1), // Two digit month number, 01 through 12

				// Year
				'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
				'Y': fullYear, // Four digits year, like 2009

				// Time
				'H': pad(hours), // Two digits hours in 24h format, 00 through 23
				'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
				'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
				'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
				'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
				'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
				'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
				'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
			}, Highcharts.dateFormats);


		// do the replaces
		for (key in replacements) {
			while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
				format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
			}
		}

		// Optionally capitalize the string and return
		return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
	};

	/** 
	 * Format a single variable. Similar to sprintf, without the % prefix.
	 */
	function formatSingle(format, val) {
		var floatRegex = /f$/,
			decRegex = /\.([0-9])/,
			lang = defaultOptions.lang,
			decimals;

		if (floatRegex.test(format)) { // float
			decimals = format.match(decRegex);
			decimals = decimals ? decimals[1] : -1;
			if (val !== null) {
				val = Highcharts.numberFormat(
					val,
					decimals,
					lang.decimalPoint,
					format.indexOf(',') > -1 ? lang.thousandsSep : ''
				);
			}
		} else {
			val = dateFormat(format, val);
		}
		return val;
	}

	/**
	 * Format a string according to a subset of the rules of Python's String.format method.
	 */
	function format(str, ctx) {
		var splitter = '{',
			isInside = false,
			segment,
			valueAndFormat,
			path,
			i,
			len,
			ret = [],
			val,
			index;
		
		while ((index = str.indexOf(splitter)) !== -1) {
			
			segment = str.slice(0, index);
			if (isInside) { // we're on the closing bracket looking back
				
				valueAndFormat = segment.split(':');
				path = valueAndFormat.shift().split('.'); // get first and leave format
				len = path.length;
				val = ctx;

				// Assign deeper paths
				for (i = 0; i < len; i++) {
					val = val[path[i]];
				}

				// Format the replacement
				if (valueAndFormat.length) {
					val = formatSingle(valueAndFormat.join(':'), val);
				}

				// Push the result and advance the cursor
				ret.push(val);
				
			} else {
				ret.push(segment);
				
			}
			str = str.slice(index + 1); // the rest
			isInside = !isInside; // toggle
			splitter = isInside ? '}' : '{'; // now look for next matching bracket
		}
		ret.push(str);
		return ret.join('');
	}

	/**
	 * Get the magnitude of a number
	 */
	function getMagnitude(num) {
		return math.pow(10, mathFloor(math.log(num) / math.LN10));
	}

	/**
	 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
	 * @param {Number} interval
	 * @param {Array} multiples
	 * @param {Number} magnitude
	 * @param {Object} options
	 */
	function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
		var normalized, 
			i,
			retInterval = interval;

		// round to a tenfold of 1, 2, 2.5 or 5
		magnitude = pick(magnitude, 1);
		normalized = interval / magnitude;

		// multiples for a linear scale
		if (!multiples) {
			multiples = [1, 2, 2.5, 5, 10];

			// the allowDecimals option
			if (allowDecimals === false) {
				if (magnitude === 1) {
					multiples = [1, 2, 5, 10];
				} else if (magnitude <= 0.1) {
					multiples = [1 / magnitude];
				}
			}
		}

		// normalize the interval to the nearest multiple
		for (i = 0; i < multiples.length; i++) {
			retInterval = multiples[i];
			if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
				(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
				break;
			}
		}

		// multiply back to the correct magnitude
		retInterval *= magnitude;
		
		return retInterval;
	}


	/**
	 * Utility method that sorts an object array and keeping the order of equal items.
	 * ECMA script standard does not specify the behaviour when items are equal.
	 */
	function stableSort(arr, sortFunction) {
		var length = arr.length,
			sortValue,
			i;

		// Add index to each item
		for (i = 0; i < length; i++) {
			arr[i].ss_i = i; // stable sort index
		}

		arr.sort(function (a, b) {
			sortValue = sortFunction(a, b);
			return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
		});

		// Remove index from items
		for (i = 0; i < length; i++) {
			delete arr[i].ss_i; // stable sort index
		}
	}

	/**
	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	 * method is slightly slower, but safe.
	 */
	function arrayMin(data) {
		var i = data.length,
			min = data[0];

		while (i--) {
			if (data[i] < min) {
				min = data[i];
			}
		}
		return min;
	}

	/**
	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
	 * method is slightly slower, but safe.
	 */
	function arrayMax(data) {
		var i = data.length,
			max = data[0];

		while (i--) {
			if (data[i] > max) {
				max = data[i];
			}
		}
		return max;
	}

	/**
	 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
	 * It loops all properties and invokes destroy if there is a destroy method. The property is
	 * then delete'ed.
	 * @param {Object} The object to destroy properties on
	 * @param {Object} Exception, do not destroy this property, only delete it.
	 */
	function destroyObjectProperties(obj, except) {
		var n;
		for (n in obj) {
			// If the object is non-null and destroy is defined
			if (obj[n] && obj[n] !== except && obj[n].destroy) {
				// Invoke the destroy
				obj[n].destroy();
			}

			// Delete the property from the object.
			delete obj[n];
		}
	}


	/**
	 * Discard an element by moving it to the bin and delete
	 * @param {Object} The HTML node to discard
	 */
	function discardElement(element) {
		// create a garbage bin element, not part of the DOM
		if (!garbageBin) {
			garbageBin = createElement(DIV);
		}

		// move the node and empty bin
		if (element) {
			garbageBin.appendChild(element);
		}
		garbageBin.innerHTML = '';
	}

	/**
	 * Provide error messages for debugging, with links to online explanation 
	 */
	function error (code, stop) {
		var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
		if (stop) {
			throw msg;
		}
		// else ...
		if (win.console) {
			console.log(msg);
		}
	}

	/**
	 * Fix JS round off float errors
	 * @param {Number} num
	 */
	function correctFloat(num) {
		return parseFloat(
			num.toPrecision(14)
		);
	}

	/**
	 * Set the global animation to either a given value, or fall back to the
	 * given chart's animation option
	 * @param {Object} animation
	 * @param {Object} chart
	 */
	function setAnimation(animation, chart) {
		globalAnimation = pick(animation, chart.animation);
	}

	/**
	 * The time unit lookup
	 */
	timeUnits = {
		millisecond: 1,
		second: 1000,
		minute: 60000,
		hour: 3600000,
		day: 24 * 3600000,
		week: 7 * 24 * 3600000,
		month: 28 * 24 * 3600000,
		year: 364 * 24 * 3600000
	};


	/**
	 * Format a number and return a string based on input settings
	 * @param {Number} number The input number to format
	 * @param {Number} decimals The amount of decimals
	 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
	 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
	 */
	Highcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {
		var lang = defaultOptions.lang,
			// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
			n = +number || 0,
			c = decimals === -1 ?
				mathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).
				(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
			d = decPoint === undefined ? lang.decimalPoint : decPoint,
			t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
			s = n < 0 ? "-" : "",
			i = String(pInt(n = mathAbs(n).toFixed(c))),
			j = i.length > 3 ? i.length % 3 : 0;

		return (s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
				(c ? d + mathAbs(n - i).toFixed(c).slice(2) : ""));
	};
	/**
	 * Path interpolation algorithm used across adapters
	 */
	pathAnim = {
		/**
		 * Prepare start and end values so that the path can be animated one to one
		 */
		init: function (elem, fromD, toD) {
			fromD = fromD || '';
			var shift = elem.shift,
				bezier = fromD.indexOf('C') > -1,
				numParams = bezier ? 7 : 3,
				endLength,
				slice,
				i,
				start = fromD.split(' '),
				end = [].concat(toD), // copy
				startBaseLine,
				endBaseLine,
				sixify = function (arr) { // in splines make move points have six parameters like bezier curves
					i = arr.length;
					while (i--) {
						if (arr[i] === M) {
							arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
						}
					}
				};

			if (bezier) {
				sixify(start);
				sixify(end);
			}

			// pull out the base lines before padding
			if (elem.isArea) {
				startBaseLine = start.splice(start.length - 6, 6);
				endBaseLine = end.splice(end.length - 6, 6);
			}

			// if shifting points, prepend a dummy point to the end path
			if (shift <= end.length / numParams && start.length === end.length) {
				while (shift--) {
					end = [].concat(end).splice(0, numParams).concat(end);
				}
			}
			elem.shift = 0; // reset for following animations

			// copy and append last point until the length matches the end length
			if (start.length) {
				endLength = end.length;
				while (start.length < endLength) {

					//bezier && sixify(start);
					slice = [].concat(start).splice(start.length - numParams, numParams);
					if (bezier) { // disable first control point
						slice[numParams - 6] = slice[numParams - 2];
						slice[numParams - 5] = slice[numParams - 1];
					}
					start = start.concat(slice);
				}
			}

			if (startBaseLine) { // append the base lines for areas
				start = start.concat(startBaseLine);
				end = end.concat(endBaseLine);
			}
			return [start, end];
		},

		/**
		 * Interpolate each value of the path and return the array
		 */
		step: function (start, end, pos, complete) {
			var ret = [],
				i = start.length,
				startVal;

			if (pos === 1) { // land on the final path without adjustment points appended in the ends
				ret = complete;

			} else if (i === end.length && pos < 1) {
				while (i--) {
					startVal = parseFloat(start[i]);
					ret[i] =
						isNaN(startVal) ? // a letter instruction like M or L
							start[i] :
							pos * (parseFloat(end[i] - startVal)) + startVal;

				}
			} else { // if animation is finished or length not matching, land on right value
				ret = end;
			}
			return ret;
		}
	};

	(function ($) {
		/**
		 * The default HighchartsAdapter for jQuery
		 */
		win.HighchartsAdapter = win.HighchartsAdapter || ($ && {
			
			/**
			 * Initialize the adapter by applying some extensions to jQuery
			 */
			init: function (pathAnim) {
				
				// extend the animate function to allow SVG animations
				var Fx = $.fx;
				
				/*jslint unparam: true*//* allow unused param x in this function */
				$.extend($.easing, {
					easeOutQuad: function (x, t, b, c, d) {
						return -c * (t /= d) * (t - 2) + b;
					}
				});
				/*jslint unparam: false*/
			
				// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
				$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {
					var obj = Fx.step,
						base;
						
					// Handle different parent objects
					if (fn === 'cur') {
						obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype
					
					} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model
						obj = $.Tween.propHooks[fn];
						fn = 'set';
					}
			
					// Overwrite the method
					base = obj[fn];
					if (base) { // step.width and step.height don't exist in jQuery < 1.7
			
						// create the extended function replacement
						obj[fn] = function (fx) {

							var elem;
							
							// Fx.prototype.cur does not use fx argument
							fx = i ? fx : this;

							// Don't run animations on textual properties like align (#1821)
							if (fx.prop === 'align') {
								return;
							}
			
							// shortcut
							elem = fx.elem;
			
							// Fx.prototype.cur returns the current value. The other ones are setters
							// and returning a value has no effect.
							return elem.attr ? // is SVG element wrapper
								elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method
								base.apply(this, arguments); // use jQuery's built-in method
						};
					}
				});

				// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
				wrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {
					return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
				});
				
				// Define the setter function for d (path definitions)
				this.addAnimSetter('d', function (fx) {
					var elem = fx.elem,
						ends;
			
					// Normally start and end should be set in state == 0, but sometimes,
					// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
					// in these cases
					if (!fx.started) {
						ends = pathAnim.init(elem, elem.d, elem.toD);
						fx.start = ends[0];
						fx.end = ends[1];
						fx.started = true;
					}
			
					// Interpolate each value of the path
					elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
				});
				
				/**
				 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
				 * @param {Array} arr
				 * @param {Function} fn
				 */
				this.each = Array.prototype.forEach ?
					function (arr, fn) { // modern browsers
						return Array.prototype.forEach.call(arr, fn);
						
					} : 
					function (arr, fn) { // legacy
						var i, 
							len = arr.length;
						for (i = 0; i < len; i++) {
							if (fn.call(arr[i], arr[i], i, arr) === false) {
								return i;
							}
						}
					};
				
				/**
				 * Register Highcharts as a plugin in the respective framework
				 */
				$.fn.highcharts = function () {
					var constr = 'Chart', // default constructor
						args = arguments,
						options,
						ret,
						chart;

					if (this[0]) {

						if (isString(args[0])) {
							constr = args[0];
							args = Array.prototype.slice.call(args, 1); 
						}
						options = args[0];

						// Create the chart
						if (options !== UNDEFINED) {
							/*jslint unused:false*/
							options.chart = options.chart || {};
							options.chart.renderTo = this[0];
							chart = new Highcharts[constr](options, args[1]);
							ret = this;
							/*jslint unused:true*/
						}

						// When called without parameters or with the return argument, get a predefined chart
						if (options === UNDEFINED) {
							ret = charts[attr(this[0], 'data-highcharts-chart')];
						}
					}
					
					return ret;
				};

			},

			/**
			 * Add an animation setter for a specific property
			 */
			addAnimSetter: function (prop, setter) {
				// jQuery 1.8 style
				if ($.Tween) {
					$.Tween.propHooks[prop] = {
						set: setter
					};
				// pre 1.8
				} else {
					$.fx.step[prop] = setter;
				}
			},
			
			/**
			 * Downloads a script and executes a callback when done.
			 * @param {String} scriptLocation
			 * @param {Function} callback
			 */
			getScript: $.getScript,
			
			/**
			 * Return the index of an item in an array, or -1 if not found
			 */
			inArray: $.inArray,
			
			/**
			 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
			 * @param {Object} elem The HTML element
			 * @param {String} method Which method to run on the wrapped element
			 */
			adapterRun: function (elem, method) {
				return $(elem)[method]();
			},
		
			/**
			 * Filter an array
			 */
			grep: $.grep,
		
			/**
			 * Map an array
			 * @param {Array} arr
			 * @param {Function} fn
			 */
			map: function (arr, fn) {
				//return jQuery.map(arr, fn);
				var results = [],
					i = 0,
					len = arr.length;
				for (; i < len; i++) {
					results[i] = fn.call(arr[i], arr[i], i, arr);
				}
				return results;
		
			},
		
			/**
			 * Get the position of an element relative to the top left of the page
			 */
			offset: function (el) {
				return $(el).offset();
			},
		
			/**
			 * Add an event listener
			 * @param {Object} el A HTML element or custom object
			 * @param {String} event The event type
			 * @param {Function} fn The event handler
			 */
			addEvent: function (el, event, fn) {
				$(el).bind(event, fn);
			},
		
			/**
			 * Remove event added with addEvent
			 * @param {Object} el The object
			 * @param {String} eventType The event type. Leave blank to remove all events.
			 * @param {Function} handler The function to remove
			 */
			removeEvent: function (el, eventType, handler) {
				// workaround for jQuery issue with unbinding custom events:
				// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
				var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
				if (doc[func] && el && !el[func]) {
					el[func] = function () {};
				}
		
				$(el).unbind(eventType, handler);
			},
		
			/**
			 * Fire an event on a custom object
			 * @param {Object} el
			 * @param {String} type
			 * @param {Object} eventArguments
			 * @param {Function} defaultFunction
			 */
			fireEvent: function (el, type, eventArguments, defaultFunction) {
				var event = $.Event(type),
					detachedType = 'detached' + type,
					defaultPrevented;
		
				// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts
				// never uses these properties, Chrome includes them in the default click event and
				// raises the warning when they are copied over in the extend statement below.
				//
				// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
				// testing if they are there (warning in chrome) the only option is to test if running IE.
				if (!isIE && eventArguments) {
					delete eventArguments.layerX;
					delete eventArguments.layerY;
					delete eventArguments.returnValue;
				}
		
				extend(event, eventArguments);
		
				// Prevent jQuery from triggering the object method that is named the
				// same as the event. For example, if the event is 'select', jQuery
				// attempts calling el.select and it goes into a loop.
				if (el[type]) {
					el[detachedType] = el[type];
					el[type] = null;
				}
		
				// Wrap preventDefault and stopPropagation in try/catch blocks in
				// order to prevent JS errors when cancelling events on non-DOM
				// objects. #615.
				/*jslint unparam: true*/
				$.each(['preventDefault', 'stopPropagation'], function (i, fn) {
					var base = event[fn];
					event[fn] = function () {
						try {
							base.call(event);
						} catch (e) {
							if (fn === 'preventDefault') {
								defaultPrevented = true;
							}
						}
					};
				});
				/*jslint unparam: false*/
		
				// trigger it
				$(el).trigger(event);
		
				// attach the method
				if (el[detachedType]) {
					el[type] = el[detachedType];
					el[detachedType] = null;
				}
		
				if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
					defaultFunction(event);
				}
			},
			
			/**
			 * Extension method needed for MooTools
			 */
			washMouseEvent: function (e) {
				var ret = e.originalEvent || e;
				
				// computed by jQuery, needed by IE8
				if (ret.pageX === UNDEFINED) { // #1236
					ret.pageX = e.pageX;
					ret.pageY = e.pageY;
				}
				
				return ret;
			},
		
			/**
			 * Animate a HTML element or SVG element wrapper
			 * @param {Object} el
			 * @param {Object} params
			 * @param {Object} options jQuery-like animation options: duration, easing, callback
			 */
			animate: function (el, params, options) {
				var $el = $(el);
				if (!el.style) {
					el.style = {}; // #1881
				}
				if (params.d) {
					el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
					params.d = 1; // because in jQuery, animating to an array has a different meaning
				}
		
				$el.stop();
				if (params.opacity !== UNDEFINED && el.attr) {
					params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)
				}
				el.hasAnim = 1; // #3342
				$el.animate(params, options);
		
			},
			/**
			 * Stop running animation
			 */
			stop: function (el) {
				if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy
					$(el).stop();
				}
			}
		});
	}(win.jQuery));


	// check for a custom HighchartsAdapter defined prior to this file
	var globalAdapter = win.HighchartsAdapter,
		adapter = globalAdapter || {};
		
	// Initialize the adapter
	if (globalAdapter) {
		globalAdapter.init.call(globalAdapter, pathAnim);
	}


	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
	// and all the utility functions will be null. In that case they are populated by the
	// default adapters below.
	var adapterRun = adapter.adapterRun,
		getScript = adapter.getScript,
		inArray = adapter.inArray,
		each = Highcharts.each = adapter.each,
		grep = adapter.grep,
		offset = adapter.offset,
		map = adapter.map,
		addEvent = adapter.addEvent,
		removeEvent = adapter.removeEvent,
		fireEvent = adapter.fireEvent,
		washMouseEvent = adapter.washMouseEvent,
		animate = adapter.animate,
		stop = adapter.stop;



	/* ****************************************************************************
	 * Handle the options                                                         *
	 *****************************************************************************/
	defaultOptions = {
		colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', 
			    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
		symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
		lang: {
			loading: 'Loading...',
			months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
					'August', 'September', 'October', 'November', 'December'],
			shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
			weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
			decimalPoint: '.',
			numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
			resetZoom: 'Reset zoom',
			resetZoomTitle: 'Reset zoom level 1:1',
			thousandsSep: ' '
		},
		global: {
			useUTC: true,
			//timezoneOffset: 0,
			canvasToolsURL: 'http://code.highcharts.com/4.1.4-modified/modules/canvas-tools.js',
			VMLRadialGradientURL: 'http://code.highcharts.com/4.1.4-modified/gfx/vml-radial-gradient.png'
		},
		chart: {
			//animation: true,
			//alignTicks: false,
			//reflow: true,
			//className: null,
			//events: { load, selection },
			//margin: [null],
			//marginTop: null,
			//marginRight: null,
			//marginBottom: null,
			//marginLeft: null,
			borderColor: '#4572A7',
			//borderWidth: 0,
			borderRadius: 0,
			defaultSeriesType: 'line',
			ignoreHiddenSeries: true,
			//inverted: false,
			//shadow: false,
			spacing: [10, 10, 15, 10],
			//spacingTop: 10,
			//spacingRight: 10,
			//spacingBottom: 15,
			//spacingLeft: 10,
			//style: {
			//	fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
			//	fontSize: '12px'
			//},
			backgroundColor: '#FFFFFF',
			//plotBackgroundColor: null,
			plotBorderColor: '#C0C0C0',
			//plotBorderWidth: 0,
			//plotShadow: false,
			//zoomType: ''
			resetZoomButton: {
				theme: {
					zIndex: 20
				},
				position: {
					align: 'right',
					x: -10,
					//verticalAlign: 'top',
					y: 10
				}
				// relativeTo: 'plot'
			}
		},
		title: {
			text: 'Chart title',
			align: 'center',
			// floating: false,
			margin: 15,
			// x: 0,
			// verticalAlign: 'top',
			// y: null,
			style: {
				color: '#333333',
				fontSize: '18px'
			}

		},
		subtitle: {
			text: '',
			align: 'center',
			// floating: false
			// x: 0,
			// verticalAlign: 'top',
			// y: null,
			style: {
				color: '#555555'
			}
		},

		plotOptions: {
			line: { // base series options
				allowPointSelect: false,
				showCheckbox: false,
				animation: {
					duration: 1000
				},
				//connectNulls: false,
				//cursor: 'default',
				//clip: true,
				//dashStyle: null,
				//enableMouseTracking: true,
				events: {},
				//legendIndex: 0,
				//linecap: 'round',
				lineWidth: 2,
				//shadow: false,
				// stacking: null,
				marker: {
					//enabled: true,
					//symbol: null,
					lineWidth: 0,
					radius: 4,
					lineColor: '#FFFFFF',
					//fillColor: null,
					states: { // states for a single point
						hover: {
							enabled: true,
							lineWidthPlus: 1,
							radiusPlus: 2
						},
						select: {
							fillColor: '#FFFFFF',
							lineColor: '#000000',
							lineWidth: 2
						}
					}
				},
				point: {
					events: {}
				},
				dataLabels: {
					align: 'center',
					// defer: true,
					// enabled: false,
					formatter: function () {
						return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
					},
					style: {
						color: 'contrast',
						fontSize: '11px',
						fontWeight: 'bold',
						textShadow: '0 0 6px contrast, 0 0 3px contrast'
					},
					verticalAlign: 'bottom', // above singular point
					x: 0,
					y: 0,
					// backgroundColor: undefined,
					// borderColor: undefined,
					// borderRadius: undefined,
					// borderWidth: undefined,
					padding: 5
					// shadow: false
				},
				cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
				pointRange: 0,
				//pointStart: 0,
				//pointInterval: 1,
				//showInLegend: null, // auto: true for standalone series, false for linked series
				states: { // states for the entire series
					hover: {
						//enabled: false,
						lineWidthPlus: 1,
						marker: {
							// lineWidth: base + 1,
							// radius: base + 1
						},
						halo: {
							size: 10,
							opacity: 0.25
						}
					},
					select: {
						marker: {}
					}
				},
				stickyTracking: true,
				//tooltip: {
					//pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
					//valueDecimals: null,
					//xDateFormat: '%A, %b %e, %Y',
					//valuePrefix: '',
					//ySuffix: ''				
				//}
				turboThreshold: 1000
				// zIndex: null
			}
		},
		labels: {
			//items: [],
			style: {
				//font: defaultFont,
				position: ABSOLUTE,
				color: '#3E576F'
			}
		},
		legend: {
			enabled: true,
			align: 'center',
			//floating: false,
			layout: 'horizontal',
			labelFormatter: function () {
				return this.name;
			},
			//borderWidth: 0,
			borderColor: '#909090',
			borderRadius: 0,
			navigation: {
				// animation: true,
				activeColor: '#274b6d',
				// arrowSize: 12
				inactiveColor: '#CCC'
				// style: {} // text styles
			},
			// margin: 20,
			// reversed: false,
			shadow: false,
			// backgroundColor: null,
			/*style: {
				padding: '5px'
			},*/
			itemStyle: {			
				color: '#333333',
				fontSize: '12px',
				fontWeight: 'bold'
			},
			itemHoverStyle: {
				//cursor: 'pointer', removed as of #601
				color: '#000'
			},
			itemHiddenStyle: {
				color: '#CCC'
			},
			itemCheckboxStyle: {
				position: ABSOLUTE,
				width: '13px', // for IE precision
				height: '13px'
			},
			// itemWidth: undefined,
			// symbolRadius: 0,
			// symbolWidth: 16,
			symbolPadding: 5,
			verticalAlign: 'bottom',
			// width: undefined,
			x: 0,
			y: 0,
			title: {
				//text: null,
				style: {
					fontWeight: 'bold'
				}
			}			
		},

		loading: {
			// hideDuration: 100,
			labelStyle: {
				fontWeight: 'bold',
				position: RELATIVE,
				top: '45%'
			},
			// showDuration: 0,
			style: {
				position: ABSOLUTE,
				backgroundColor: 'white',
				opacity: 0.5,
				textAlign: 'center'
			}
		},

		tooltip: {
			enabled: true,
			animation: hasSVG,
			//crosshairs: null,
			backgroundColor: 'rgba(249, 249, 249, .85)',
			borderWidth: 1,
			borderRadius: 3,
			dateTimeLabelFormats: { 
				millisecond: '%A, %b %e, %H:%M:%S.%L',
				second: '%A, %b %e, %H:%M:%S',
				minute: '%A, %b %e, %H:%M',
				hour: '%A, %b %e, %H:%M',
				day: '%A, %b %e, %Y',
				week: 'Week from %A, %b %e, %Y',
				month: '%B %Y',
				year: '%Y'
			},
			footerFormat: '',
			//formatter: defaultFormatter,
			headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
			pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
			shadow: true,
			//shape: 'callout',
			//shared: false,
			snap: isTouchDevice ? 25 : 10,
			style: {
				color: '#333333',
				cursor: 'default',
				fontSize: '12px',
				padding: '8px',
				whiteSpace: 'nowrap'
			}
			//xDateFormat: '%A, %b %e, %Y',
			//valueDecimals: null,
			//valuePrefix: '',
			//valueSuffix: ''
		},

		credits: {
			enabled: true,
			text: 'Highcharts.com',
			href: 'http://www.highcharts.com',
			position: {
				align: 'right',
				x: -10,
				verticalAlign: 'bottom',
				y: -5
			},
			style: {
				cursor: 'pointer',
				color: '#909090',
				fontSize: '9px'
			}
		}
	};




	// Series defaults
	var defaultPlotOptions = defaultOptions.plotOptions,
		defaultSeriesOptions = defaultPlotOptions.line;

	// set the default time methods
	setTimeMethods();



	/**
	 * Set the time methods globally based on the useUTC option. Time method can be either
	 * local time or UTC (default).
	 */
	function setTimeMethods() {
		var globalOptions = defaultOptions.global,
			useUTC = globalOptions.useUTC,
			GET = useUTC ? 'getUTC' : 'get',
			SET = useUTC ? 'setUTC' : 'set';


		Date = globalOptions.Date || window.Date;
		timezoneOffset = useUTC && globalOptions.timezoneOffset;
		getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
		makeTime = function (year, month, date, hours, minutes, seconds) {
			var d;
			if (useUTC) {
				d = Date.UTC.apply(0, arguments);
				d += getTZOffset(d);
			} else {
				d = new Date(
					year,
					month,
					pick(date, 1),
					pick(hours, 0),
					pick(minutes, 0),
					pick(seconds, 0)
				).getTime();
			}
			return d;
		};
		getMinutes =  GET + 'Minutes';
		getHours =    GET + 'Hours';
		getDay =      GET + 'Day';
		getDate =     GET + 'Date';
		getMonth =    GET + 'Month';
		getFullYear = GET + 'FullYear';
		setMinutes =  SET + 'Minutes';
		setHours =    SET + 'Hours';
		setDate =     SET + 'Date';
		setMonth =    SET + 'Month';
		setFullYear = SET + 'FullYear';

	}

	/**
	 * Merge the default options with custom options and return the new options structure
	 * @param {Object} options The new custom options
	 */
	function setOptions(options) {
		
		// Copy in the default options
		defaultOptions = merge(true, defaultOptions, options);
		
		// Apply UTC
		setTimeMethods();

		return defaultOptions;
	}

	/**
	 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
	 * wasn't enough because the setOptions method created a new object.
	 */
	function getOptions() {
		return defaultOptions;
	}


	/**
	 * Handle color operations. The object methods are chainable.
	 * @param {String} input The input color in either rbga or hex format
	 */
	var rgbaRegEx = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
		hexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
		rgbRegEx = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;

	var Color = function (input) {
		// declare variables
		var rgba = [], result, stops;

		/**
		 * Parse the input color to rgba array
		 * @param {String} input
		 */
		function init(input) {

			// Gradients
			if (input && input.stops) {
				stops = map(input.stops, function (stop) {
					return Color(stop[1]);
				});

			// Solid colors
			} else {
				// rgba
				result = rgbaRegEx.exec(input);
				if (result) {
					rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
				} else { 
					// hex
					result = hexRegEx.exec(input);
					if (result) {
						rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
					} else {
						// rgb
						result = rgbRegEx.exec(input);
						if (result) {
							rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
						}
					}
				}
			}		

		}
		/**
		 * Return the color a specified format
		 * @param {String} format
		 */
		function get(format) {
			var ret;

			if (stops) {
				ret = merge(input);
				ret.stops = [].concat(ret.stops);
				each(stops, function (stop, i) {
					ret.stops[i] = [ret.stops[i][0], stop.get(format)];
				});

			// it's NaN if gradient colors on a column chart
			} else if (rgba && !isNaN(rgba[0])) {
				if (format === 'rgb') {
					ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
				} else if (format === 'a') {
					ret = rgba[3];
				} else {
					ret = 'rgba(' + rgba.join(',') + ')';
				}
			} else {
				ret = input;
			}
			return ret;
		}

		/**
		 * Brighten the color
		 * @param {Number} alpha
		 */
		function brighten(alpha) {
			if (stops) {
				each(stops, function (stop) {
					stop.brighten(alpha);
				});
			
			} else if (isNumber(alpha) && alpha !== 0) {
				var i;
				for (i = 0; i < 3; i++) {
					rgba[i] += pInt(alpha * 255);

					if (rgba[i] < 0) {
						rgba[i] = 0;
					}
					if (rgba[i] > 255) {
						rgba[i] = 255;
					}
				}
			}
			return this;
		}
		/**
		 * Set the color's opacity to a given alpha value
		 * @param {Number} alpha
		 */
		function setOpacity(alpha) {
			rgba[3] = alpha;
			return this;
		}

		// initialize: parse the input
		init(input);

		// public methods
		return {
			get: get,
			brighten: brighten,
			rgba: rgba,
			setOpacity: setOpacity,
			raw: input
		};
	};


	/**
	 * A wrapper object for SVG elements
	 */
	function SVGElement() {}

	SVGElement.prototype = {
		
		// Default base for animation
		opacity: 1,
		// For labels, these CSS properties are applied to the <text> node directly
		textProps: ['fontSize', 'fontWeight', 'fontFamily', 'color', 
			'lineHeight', 'width', 'textDecoration', 'textShadow'],
		
		/**
		 * Initialize the SVG renderer
		 * @param {Object} renderer
		 * @param {String} nodeName
		 */
		init: function (renderer, nodeName) {
			var wrapper = this;
			wrapper.element = nodeName === 'span' ?
				createElement(nodeName) :
				doc.createElementNS(SVG_NS, nodeName);
			wrapper.renderer = renderer;
		},
		
		/**
		 * Animate a given attribute
		 * @param {Object} params
		 * @param {Number} options The same options as in jQuery animation
		 * @param {Function} complete Function to perform at the end of animation
		 */
		animate: function (params, options, complete) {
			var animOptions = pick(options, globalAnimation, true);
			stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
			if (animOptions) {
				animOptions = merge(animOptions, {}); //#2625
				if (complete) { // allows using a callback with the global animation without overwriting it
					animOptions.complete = complete;
				}
				animate(this, params, animOptions);
			} else {
				this.attr(params);
				if (complete) {
					complete();
				}
			}
			return this;
		},

		/**
		 * Build an SVG gradient out of a common JavaScript configuration object
		 */
		colorGradient: function (color, prop, elem) {
			var renderer = this.renderer,
				colorObject,
				gradName,
				gradAttr,
				gradients,
				gradientObject,
				stops,
				stopColor,
				stopOpacity,
				radialReference,
				n,
				id,
				key = [];

			// Apply linear or radial gradients
			if (color.linearGradient) {
				gradName = 'linearGradient';
			} else if (color.radialGradient) {
				gradName = 'radialGradient';
			}

			if (gradName) {
				gradAttr = color[gradName];
				gradients = renderer.gradients;
				stops = color.stops;
				radialReference = elem.radialReference;

				// Keep < 2.2 kompatibility
				if (isArray(gradAttr)) {
					color[gradName] = gradAttr = {
						x1: gradAttr[0],
						y1: gradAttr[1],
						x2: gradAttr[2],
						y2: gradAttr[3],
						gradientUnits: 'userSpaceOnUse'
					};
				}

				// Correct the radial gradient for the radial reference system
				if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
					gradAttr = merge(gradAttr, {
						cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
						cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
						r: gradAttr.r * radialReference[2],
						gradientUnits: 'userSpaceOnUse'
					});
				}

				// Build the unique key to detect whether we need to create a new element (#1282)
				for (n in gradAttr) {
					if (n !== 'id') {
						key.push(n, gradAttr[n]);
					}
				}
				for (n in stops) {
					key.push(stops[n]);
				}
				key = key.join(',');

				// Check if a gradient object with the same config object is created within this renderer
				if (gradients[key]) {
					id = gradients[key].attr('id');

				} else {

					// Set the id and create the element
					gradAttr.id = id = PREFIX + idCounter++;
					gradients[key] = gradientObject = renderer.createElement(gradName)
						.attr(gradAttr)
						.add(renderer.defs);


					// The gradient needs to keep a list of stops to be able to destroy them
					gradientObject.stops = [];
					each(stops, function (stop) {
						var stopObject;
						if (stop[1].indexOf('rgba') === 0) {
							colorObject = Color(stop[1]);
							stopColor = colorObject.get('rgb');
							stopOpacity = colorObject.get('a');
						} else {
							stopColor = stop[1];
							stopOpacity = 1;
						}
						stopObject = renderer.createElement('stop').attr({
							offset: stop[0],
							'stop-color': stopColor,
							'stop-opacity': stopOpacity
						}).add(gradientObject);

						// Add the stop element to the gradient
						gradientObject.stops.push(stopObject);
					});
				}

				// Set the reference to the gradient object
				elem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');
			} 
		},

		/**
		 * Apply a polyfill to the text-stroke CSS property, by copying the text element
		 * and apply strokes to the copy.
		 *
		 * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color
		 * TODO: 
		 * - update defaults
		 */
		applyTextShadow: function (textShadow) {
			var elem = this.element,
				tspans,
				hasContrast = textShadow.indexOf('contrast') !== -1,
				// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
				// this again with new IE release. In exports, the rendering is passed to PhantomJS. 
				supports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);

			// When the text shadow is set to contrast, use dark stroke for light text and vice versa
			if (hasContrast) {
				textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
			}

			/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
			if (elem.textContent.indexOf('2.') === 0) {
				elem.style['text-shadow'] = 'none';
				supports = false;
			}
			// */

			// No reason to polyfill, we've got native support
			if (supports) {
				if (hasContrast) { // Apply the altered style
					css(elem, {
						textShadow: textShadow
					});
				}
			} else {

				this.fakeTS = true; // Fake text shadow

				// In order to get the right y position of the clones, 
				// copy over the y setter
				this.ySetter = this.xSetter;

				tspans = [].slice.call(elem.getElementsByTagName('tspan'));
				each(textShadow.split(/\s?,\s?/g), function (textShadow) {
					var firstChild = elem.firstChild,
						color,
						strokeWidth;
					
					textShadow = textShadow.split(' ');
					color = textShadow[textShadow.length - 1];

					// Approximately tune the settings to the text-shadow behaviour
					strokeWidth = textShadow[textShadow.length - 2];

					if (strokeWidth) {
						each(tspans, function (tspan, y) {
							var clone;

							// Let the first line start at the correct X position
							if (y === 0) {
								tspan.setAttribute('x', elem.getAttribute('x'));
								y = elem.getAttribute('y');
								tspan.setAttribute('y', y || 0);
								if (y === null) {
									elem.setAttribute('y', 0);
								}
							}

							// Create the clone and apply shadow properties
							clone = tspan.cloneNode(1);
							attr(clone, {
								'class': PREFIX + 'text-shadow',
								'fill': color,
								'stroke': color,
								'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
								'stroke-width': strokeWidth,
								'stroke-linejoin': 'round'
							});
							elem.insertBefore(clone, firstChild);
						});
					}
				});
			}
		},

		/**
		 * Set or get a given attribute
		 * @param {Object|String} hash
		 * @param {Mixed|Undefined} val
		 */
		attr: function (hash, val) {
			var key,
				value,
				element = this.element,
				hasSetSymbolSize,
				ret = this,
				skipAttr;

			// single key-value pair
			if (typeof hash === 'string' && val !== UNDEFINED) {
				key = hash;
				hash = {};
				hash[key] = val;
			}

			// used as a getter: first argument is a string, second is undefined
			if (typeof hash === 'string') {
				ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);
			
			// setter
			} else {

				for (key in hash) {
					value = hash[key];
					skipAttr = false;



					if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
						if (!hasSetSymbolSize) {
							this.symbolAttr(hash);
							hasSetSymbolSize = true;
						}
						skipAttr = true;
					}

					if (this.rotation && (key === 'x' || key === 'y')) {
						this.doTransform = true;
					}
					
					if (!skipAttr) {
						(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);
					}

					// Let the shadow follow the main element
					if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
						this.updateShadows(key, value);
					}
				}

				// Update transform. Do this outside the loop to prevent redundant updating for batch setting
				// of attributes.
				if (this.doTransform) {
					this.updateTransform();
					this.doTransform = false;
				}

			}

			return ret;
		},

		updateShadows: function (key, value) {
			var shadows = this.shadows,
				i = shadows.length;
			while (i--) {
				shadows[i].setAttribute(
					key,
					key === 'height' ?
						mathMax(value - (shadows[i].cutHeight || 0), 0) :
						key === 'd' ? this.d : value
				);
			}
		},

		/**
		 * Add a class name to an element
		 */
		addClass: function (className) {
			var element = this.element,
				currentClassName = attr(element, 'class') || '';

			if (currentClassName.indexOf(className) === -1) {
				attr(element, 'class', currentClassName + ' ' + className);
			}
			return this;
		},
		/* hasClass and removeClass are not (yet) needed
		hasClass: function (className) {
			return attr(this.element, 'class').indexOf(className) !== -1;
		},
		removeClass: function (className) {
			attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
			return this;
		},
		*/

		/**
		 * If one of the symbol size affecting parameters are changed,
		 * check all the others only once for each call to an element's
		 * .attr() method
		 * @param {Object} hash
		 */
		symbolAttr: function (hash) {
			var wrapper = this;

			each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
				wrapper[key] = pick(hash[key], wrapper[key]);
			});

			wrapper.attr({
				d: wrapper.renderer.symbols[wrapper.symbolName](
					wrapper.x,
					wrapper.y,
					wrapper.width,
					wrapper.height,
					wrapper
				)
			});
		},

		/**
		 * Apply a clipping path to this object
		 * @param {String} id
		 */
		clip: function (clipRect) {
			return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
		},

		/**
		 * Calculate the coordinates needed for drawing a rectangle crisply and return the
		 * calculated attributes
		 * @param {Number} strokeWidth
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		crisp: function (rect) {

			var wrapper = this,
				key,
				attribs = {},
				normalizer,
				strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;

			normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

			// normalize for crisp edges
			rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
			rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
			rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
			rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
			rect.strokeWidth = strokeWidth;

			for (key in rect) {
				if (wrapper[key] !== rect[key]) { // only set attribute if changed
					wrapper[key] = attribs[key] = rect[key];
				}
			}

			return attribs;
		},

		/**
		 * Set styles for the element
		 * @param {Object} styles
		 */
		css: function (styles) {
			var elemWrapper = this,
				oldStyles = elemWrapper.styles,
				newStyles = {},
				elem = elemWrapper.element,
				textWidth,
				n,
				serializedCss = '',
				hyphenate,
				hasNew = !oldStyles;

			// convert legacy
			if (styles && styles.color) {
				styles.fill = styles.color;
			}

			// Filter out existing styles to increase performance (#2640)
			if (oldStyles) {
				for (n in styles) {
					if (styles[n] !== oldStyles[n]) {
						newStyles[n] = styles[n];
						hasNew = true;
					}
				}
			}
			if (hasNew) {
				textWidth = elemWrapper.textWidth = 
					(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || 
					elemWrapper.textWidth; // #3501

				// Merge the new styles with the old ones
				if (oldStyles) {
					styles = extend(
						oldStyles,
						newStyles
					);
				}		

				// store object
				elemWrapper.styles = styles;

				if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
					delete styles.width;
				}

				// serialize and set style attribute
				if (isIE && !hasSVG) {
					css(elemWrapper.element, styles);
				} else {
					/*jslint unparam: true*/
					hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
					/*jslint unparam: false*/
					for (n in styles) {
						serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
					}
					attr(elem, 'style', serializedCss); // #1881
				}


				// re-build text
				if (textWidth && elemWrapper.added) {
					elemWrapper.renderer.buildText(elemWrapper);
				}
			}

			return elemWrapper;
		},

		/**
		 * Add an event listener
		 * @param {String} eventType
		 * @param {Function} handler
		 */
		on: function (eventType, handler) {
			var svgElement = this,
				element = svgElement.element;
			
			// touch
			if (hasTouch && eventType === 'click') {
				element.ontouchstart = function (e) {			
					svgElement.touchEventFired = Date.now();				
					e.preventDefault();
					handler.call(element, e);
				};
				element.onclick = function (e) {												
					if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
						handler.call(element, e);
					}
				};			
			} else {
				// simplest possible event model for internal use
				element['on' + eventType] = handler;
			}
			return this;
		},

		/**
		 * Set the coordinates needed to draw a consistent radial gradient across
		 * pie slices regardless of positioning inside the chart. The format is
		 * [centerX, centerY, diameter] in pixels.
		 */
		setRadialReference: function (coordinates) {
			this.element.radialReference = coordinates;
			return this;
		},

		/**
		 * Move an object and its children by x and y values
		 * @param {Number} x
		 * @param {Number} y
		 */
		translate: function (x, y) {
			return this.attr({
				translateX: x,
				translateY: y
			});
		},

		/**
		 * Invert a group, rotate and flip
		 */
		invert: function () {
			var wrapper = this;
			wrapper.inverted = true;
			wrapper.updateTransform();
			return wrapper;
		},

		/**
		 * Private method to update the transform attribute based on internal
		 * properties
		 */
		updateTransform: function () {
			var wrapper = this,
				translateX = wrapper.translateX || 0,
				translateY = wrapper.translateY || 0,
				scaleX = wrapper.scaleX,
				scaleY = wrapper.scaleY,
				inverted = wrapper.inverted,
				rotation = wrapper.rotation,
				element = wrapper.element,
				transform;

			// flipping affects translate as adjustment for flipping around the group's axis
			if (inverted) {
				translateX += wrapper.attr('width');
				translateY += wrapper.attr('height');
			}

			// Apply translate. Nearly all transformed elements have translation, so instead
			// of checking for translate = 0, do it always (#1767, #1846).
			transform = ['translate(' + translateX + ',' + translateY + ')'];

			// apply rotation
			if (inverted) {
				transform.push('rotate(90) scale(-1,1)');
			} else if (rotation) { // text rotation
				transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');
				
				// Delete bBox memo when the rotation changes
				//delete wrapper.bBox;
			}

			// apply scale
			if (defined(scaleX) || defined(scaleY)) {
				transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
			}

			if (transform.length) {
				element.setAttribute('transform', transform.join(' '));
			}
		},
		/**
		 * Bring the element to the front
		 */
		toFront: function () {
			var element = this.element;
			element.parentNode.appendChild(element);
			return this;
		},


		/**
		 * Break down alignment options like align, verticalAlign, x and y
		 * to x and y relative to the chart.
		 *
		 * @param {Object} alignOptions
		 * @param {Boolean} alignByTranslate
		 * @param {String[Object} box The box to align to, needs a width and height. When the
		 *		box is a string, it refers to an object in the Renderer. For example, when
		 *		box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
		 *		x and y properties.
		 *
		 */
		align: function (alignOptions, alignByTranslate, box) {
			var align,
				vAlign,
				x,
				y,
				attribs = {},
				alignTo,
				renderer = this.renderer,
				alignedObjects = renderer.alignedObjects;

			// First call on instanciate
			if (alignOptions) {
				this.alignOptions = alignOptions;
				this.alignByTranslate = alignByTranslate;
				if (!box || isString(box)) { // boxes other than renderer handle this internally
					this.alignTo = alignTo = box || 'renderer';
					erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
					alignedObjects.push(this);
					box = null; // reassign it below
				}

			// When called on resize, no arguments are supplied
			} else {
				alignOptions = this.alignOptions;
				alignByTranslate = this.alignByTranslate;
				alignTo = this.alignTo;
			}

			box = pick(box, renderer[alignTo], renderer);

			// Assign variables
			align = alignOptions.align;
			vAlign = alignOptions.verticalAlign;
			x = (box.x || 0) + (alignOptions.x || 0); // default: left align
			y = (box.y || 0) + (alignOptions.y || 0); // default: top align

			// Align
			if (align === 'right' || align === 'center') {
				x += (box.width - (alignOptions.width || 0)) /
						{ right: 1, center: 2 }[align];
			}
			attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


			// Vertical align
			if (vAlign === 'bottom' || vAlign === 'middle') {
				y += (box.height - (alignOptions.height || 0)) /
						({ bottom: 1, middle: 2 }[vAlign] || 1);

			}
			attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

			// Animate only if already placed
			this[this.placed ? 'animate' : 'attr'](attribs);
			this.placed = true;
			this.alignAttr = attribs;

			return this;
		},

		/**
		 * Get the bounding box (width, height, x and y) for the element
		 */
		getBBox: function (reload) {
			var wrapper = this,
				bBox,// = wrapper.bBox,
				renderer = wrapper.renderer,
				width,
				height,
				rotation = wrapper.rotation,
				element = wrapper.element,
				styles = wrapper.styles,
				rad = rotation * deg2rad,
				textStr = wrapper.textStr,
				textShadow,
				elemStyle = element.style,
				toggleTextShadowShim,
				cacheKey;

			if (textStr !== UNDEFINED) {

				// Properties that affect bounding box
				cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

				// Since numbers are monospaced, and numerical labels appear a lot in a chart,
				// we assume that a label of n characters has the same bounding box as others 
				// of the same length.
				if (textStr === '' || numRegex.test(textStr)) {
					cacheKey = 'num:' + textStr.toString().length + cacheKey;

				// Caching all strings reduces rendering time by 4-5%.
				} else {
					cacheKey = textStr + cacheKey;
				}
			}

			if (cacheKey && !reload) {
				bBox = renderer.cache[cacheKey];
			}

			// No cache found
			if (!bBox) {

				// SVG elements
				if (element.namespaceURI === SVG_NS || renderer.forExport) {
					try { // Fails in Firefox if the container has display: none.

						// When the text shadow shim is used, we need to hide the fake shadows
						// to get the correct bounding box (#3872)
						toggleTextShadowShim = this.fakeTS && function (display) {
							each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
								tspan.style.display = display;
							});
						};

						// Workaround for #3842, Firefox reporting wrong bounding box for shadows
						if (isFirefox && elemStyle.textShadow) {
							textShadow = elemStyle.textShadow;
							elemStyle.textShadow = '';
						} else if (toggleTextShadowShim) {
							toggleTextShadowShim(NONE);
						}

						bBox = element.getBBox ?
							// SVG: use extend because IE9 is not allowed to change width and height in case
							// of rotation (below)
							extend({}, element.getBBox()) :
							// Canvas renderer and legacy IE in export mode
							{
								width: element.offsetWidth,
								height: element.offsetHeight
							};

						// #3842
						if (textShadow) {
							elemStyle.textShadow = textShadow;
						} else if (toggleTextShadowShim) {
							toggleTextShadowShim('');
						}
					} catch (e) {}

					// If the bBox is not set, the try-catch block above failed. The other condition
					// is for Opera that returns a width of -Infinity on hidden elements.
					if (!bBox || bBox.width < 0) {
						bBox = { width: 0, height: 0 };
					}


				// VML Renderer or useHTML within SVG
				} else {

					bBox = wrapper.htmlGetBBox();

				}

				// True SVG elements as well as HTML elements in modern browsers using the .useHTML option
				// need to compensated for rotation
				if (renderer.isSVG) {
					width = bBox.width;
					height = bBox.height;

					// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
					if (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
						bBox.height = height = 14;
					}

					// Adjust for rotated text
					if (rotation) {
						bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
						bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
					}
				}

				// Cache it
				renderer.cache[cacheKey] = bBox;
			}
			return bBox;
		},

		/**
		 * Show the element
		 */
		show: function (inherit) {
			// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881)
			if (inherit && this.element.namespaceURI === SVG_NS) {
				this.element.removeAttribute('visibility');
			} else {
				this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
			}
			return this;
		},

		/**
		 * Hide the element
		 */
		hide: function () {
			return this.attr({ visibility: HIDDEN });
		},

		fadeOut: function (duration) {
			var elemWrapper = this;
			elemWrapper.animate({
				opacity: 0
			}, {
				duration: duration || 150,
				complete: function () {
					elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
				}
			});
		},

		/**
		 * Add the element
		 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
		 *	to append the element to the renderer.box.
		 */
		add: function (parent) {

			var renderer = this.renderer,
				element = this.element,
				inserted;

			if (parent) {
				this.parentGroup = parent;
			}

			// mark as inverted
			this.parentInverted = parent && parent.inverted;

			// build formatted text
			if (this.textStr !== undefined) {
				renderer.buildText(this);
			}

			// Mark as added
			this.added = true;

			// If we're adding to renderer root, or other elements in the group 
			// have a z index, we need to handle it
			if (!parent || parent.handleZ || this.zIndex) {
				inserted = this.zIndexSetter();
			}

			// If zIndex is not handled, append at the end
			if (!inserted) {
				(parent ? parent.element : renderer.box).appendChild(element);
			}

			// fire an event for internal hooks
			if (this.onAdd) {
				this.onAdd();
			}

			return this;
		},

		/**
		 * Removes a child either by removeChild or move to garbageBin.
		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
		 */
		safeRemoveChild: function (element) {
			var parentNode = element.parentNode;
			if (parentNode) {
				parentNode.removeChild(element);
			}
		},

		/**
		 * Destroy the element and element wrapper
		 */
		destroy: function () {
			var wrapper = this,
				element = wrapper.element || {},
				shadows = wrapper.shadows,
				parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
				grandParent,
				key,
				i;

			// remove events
			element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
			stop(wrapper); // stop running animations

			if (wrapper.clipPath) {
				wrapper.clipPath = wrapper.clipPath.destroy();
			}

			// Destroy stops in case this is a gradient object
			if (wrapper.stops) {
				for (i = 0; i < wrapper.stops.length; i++) {
					wrapper.stops[i] = wrapper.stops[i].destroy();
				}
				wrapper.stops = null;
			}

			// remove element
			wrapper.safeRemoveChild(element);

			// destroy shadows
			if (shadows) {
				each(shadows, function (shadow) {
					wrapper.safeRemoveChild(shadow);
				});
			}

			// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
			while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
				grandParent = parentToClean.parentGroup;
				wrapper.safeRemoveChild(parentToClean.div);
				delete parentToClean.div;
				parentToClean = grandParent;
			}

			// remove from alignObjects
			if (wrapper.alignTo) {
				erase(wrapper.renderer.alignedObjects, wrapper);
			}

			for (key in wrapper) {
				delete wrapper[key];
			}

			return null;
		},

		/**
		 * Add a shadow to the element. Must be done after the element is added to the DOM
		 * @param {Boolean|Object} shadowOptions
		 */
		shadow: function (shadowOptions, group, cutOff) {
			var shadows = [],
				i,
				shadow,
				element = this.element,
				strokeWidth,
				shadowWidth,
				shadowElementOpacity,

				// compensate for inverted plot area
				transform;


			if (shadowOptions) {
				shadowWidth = pick(shadowOptions.width, 3);
				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
				transform = this.parentInverted ?
					'(-1,-1)' :
					'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
				for (i = 1; i <= shadowWidth; i++) {
					shadow = element.cloneNode(0);
					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
					attr(shadow, {
						'isShadow': 'true',
						'stroke': shadowOptions.color || 'black',
						'stroke-opacity': shadowElementOpacity * i,
						'stroke-width': strokeWidth,
						'transform': 'translate' + transform,
						'fill': NONE
					});
					if (cutOff) {
						attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
						shadow.cutHeight = strokeWidth;
					}

					if (group) {
						group.element.appendChild(shadow);
					} else {
						element.parentNode.insertBefore(shadow, element);
					}

					shadows.push(shadow);
				}

				this.shadows = shadows;
			}
			return this;

		},

		xGetter: function (key) {
			if (this.element.nodeName === 'circle') {
				key = { x: 'cx', y: 'cy' }[key] || key;
			}
			return this._defaultGetter(key);
		},

		/** 
		 * Get the current value of an attribute or pseudo attribute, used mainly
		 * for animation.
		 */
		_defaultGetter: function (key) {
			var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

			if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
				ret = parseFloat(ret);
			}
			return ret;
		},


		dSetter: function (value, key, element) {
			if (value && value.join) { // join path
				value = value.join(' ');
			}
			if (/(NaN| {2}|^$)/.test(value)) {
				value = 'M 0 0';
			}
			element.setAttribute(key, value);

			this[key] = value;
		},
		dashstyleSetter: function (value) {
			var i;
			value = value && value.toLowerCase();
			if (value) {
				value = value
					.replace('shortdashdotdot', '3,1,1,1,1,1,')
					.replace('shortdashdot', '3,1,1,1')
					.replace('shortdot', '1,1,')
					.replace('shortdash', '3,1,')
					.replace('longdash', '8,3,')
					.replace(/dot/g, '1,3,')
					.replace('dash', '4,3,')
					.replace(/,$/, '')
					.split(','); // ending comma

				i = value.length;
				while (i--) {
					value[i] = pInt(value[i]) * this['stroke-width'];
				}
				value = value.join(',')
					.replace('NaN', 'none'); // #3226
				this.element.setAttribute('stroke-dasharray', value);
			}
		},
		alignSetter: function (value) {
			this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
		},
		opacitySetter: function (value, key, element) {
			this[key] = value;
			element.setAttribute(key, value);
		},
		titleSetter: function (value) {
			var titleNode = this.element.getElementsByTagName('title')[0];
			if (!titleNode) {
				titleNode = doc.createElementNS(SVG_NS, 'title');
				this.element.appendChild(titleNode);
			}
			titleNode.textContent = (String(pick(value), '')).replace(/<[^>]*>/g, ''); // #3276 #3895
		},
		textSetter: function (value) {
			if (value !== this.textStr) {
				// Delete bBox memo when the text changes
				delete this.bBox;
			
				this.textStr = value;
				if (this.added) {
					this.renderer.buildText(this);
				}
			}
		},
		fillSetter: function (value, key, element) {
			if (typeof value === 'string') {
				element.setAttribute(key, value);
			} else if (value) {
				this.colorGradient(value, key, element);
			}
		},
		zIndexSetter: function (value, key) {
			var renderer = this.renderer,
				parentGroup = this.parentGroup,
				parentWrapper = parentGroup || renderer,
				parentNode = parentWrapper.element || renderer.box,
				childNodes,
				otherElement,
				otherZIndex,
				element = this.element,
				inserted,
				run = this.added,
				i;
			
			if (defined(value)) {
				element.setAttribute(key, value); // So we can read it for other elements in the group
				value = +value;
				if (this[key] === value) { // Only update when needed (#3865)
					run = false;
				}
				this[key] = value;
			}

			// Insert according to this and other elements' zIndex. Before .add() is called,
			// nothing is done. Then on add, or by later calls to zIndexSetter, the node
			// is placed on the right place in the DOM.
			if (run) {
				value = this.zIndex;

				if (value && parentGroup) {
					parentGroup.handleZ = true;
				}
			
				childNodes = parentNode.childNodes;
				for (i = 0; i < childNodes.length && !inserted; i++) {
					otherElement = childNodes[i];
					otherZIndex = attr(otherElement, 'zIndex');
					if (otherElement !== element && (
							// Insert before the first element with a higher zIndex
							pInt(otherZIndex) > value ||
							// If no zIndex given, insert before the first element with a zIndex
							(!defined(value) && defined(otherZIndex))

							)) {
						parentNode.insertBefore(element, otherElement);
						inserted = true;
					}
				}
				if (!inserted) {
					parentNode.appendChild(element);
				}
			}
			return inserted;
		},
		_defaultSetter: function (value, key, element) {
			element.setAttribute(key, value);
		}
	};

	// Some shared setters and getters
	SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
	SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = 
			SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = 
			SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
		this[key] = value;
		this.doTransform = true;
	};

	// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
	// stroke attribute altogether. #1270, #1369, #3065, #3072.
	SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
		this[key] = value;
		// Only apply the stroke attribute if the stroke width is defined and larger than 0
		if (this.stroke && this['stroke-width']) {
			this.strokeWidth = this['stroke-width'];
			SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
			element.setAttribute('stroke-width', this['stroke-width']);
			this.hasStroke = true;
		} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
			element.removeAttribute('stroke');
			this.hasStroke = false;
		}
	};


	/**
	 * The default SVG renderer
	 */
	var SVGRenderer = function () {
		this.init.apply(this, arguments);
	};
	SVGRenderer.prototype = {
		Element: SVGElement,

		/**
		 * Initialize the SVGRenderer
		 * @param {Object} container
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Boolean} forExport
		 */
		init: function (container, width, height, style, forExport) {
			var renderer = this,
				loc = location,
				boxWrapper,
				element,
				desc;

			boxWrapper = renderer.createElement('svg')
				.attr({
					version: '1.1'
				})
				.css(this.getStyle(style));
			element = boxWrapper.element;
			container.appendChild(element);

			// For browsers other than IE, add the namespace attribute (#1978)
			if (container.innerHTML.indexOf('xmlns') === -1) {
				attr(element, 'xmlns', SVG_NS);
			}

			// object properties
			renderer.isSVG = true;
			renderer.box = element;
			renderer.boxWrapper = boxWrapper;
			renderer.alignedObjects = [];

			// Page url used for internal references. #24, #672, #1070
			renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
				loc.href
					.replace(/#.*?$/, '') // remove the hash
					.replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
					.replace(/ /g, '%20') : // replace spaces (needed for Safari only)
				'';

			// Add description
			desc = this.createElement('desc').add();
			desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


			renderer.defs = this.createElement('defs').add();
			renderer.forExport = forExport;
			renderer.gradients = {}; // Object where gradient SvgElements are stored
			renderer.cache = {}; // Cache for numerical bounding boxes

			renderer.setSize(width, height, false);



			// Issue 110 workaround:
			// In Firefox, if a div is positioned by percentage, its pixel position may land
			// between pixels. The container itself doesn't display this, but an SVG element
			// inside this container will be drawn at subpixel precision. In order to draw
			// sharp lines, this must be compensated for. This doesn't seem to work inside
			// iframes though (like in jsFiddle).
			var subPixelFix, rect;
			if (isFirefox && container.getBoundingClientRect) {
				renderer.subPixelFix = subPixelFix = function () {
					css(container, { left: 0, top: 0 });
					rect = container.getBoundingClientRect();
					css(container, {
						left: (mathCeil(rect.left) - rect.left) + PX,
						top: (mathCeil(rect.top) - rect.top) + PX
					});
				};

				// run the fix now
				subPixelFix();

				// run it on resize
				addEvent(win, 'resize', subPixelFix);
			}
		},

		getStyle: function (style) {
			return (this.style = extend({
				fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
				fontSize: '12px'
			}, style));
		},

		/**
		 * Detect whether the renderer is hidden. This happens when one of the parent elements
		 * has display: none. #608.
		 */
		isHidden: function () {
			return !this.boxWrapper.getBBox().width;
		},

		/**
		 * Destroys the renderer and its allocated members.
		 */
		destroy: function () {
			var renderer = this,
				rendererDefs = renderer.defs;
			renderer.box = null;
			renderer.boxWrapper = renderer.boxWrapper.destroy();

			// Call destroy on all gradient elements
			destroyObjectProperties(renderer.gradients || {});
			renderer.gradients = null;

			// Defs are null in VMLRenderer
			// Otherwise, destroy them here.
			if (rendererDefs) {
				renderer.defs = rendererDefs.destroy();
			}

			// Remove sub pixel fix handler
			// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
			// See issue #982
			if (renderer.subPixelFix) {
				removeEvent(win, 'resize', renderer.subPixelFix);
			}

			renderer.alignedObjects = null;

			return null;
		},

		/**
		 * Create a wrapper for an SVG element
		 * @param {Object} nodeName
		 */
		createElement: function (nodeName) {
			var wrapper = new this.Element();
			wrapper.init(this, nodeName);
			return wrapper;
		},

		/**
		 * Dummy function for use in canvas renderer
		 */
		draw: function () {},

		/**
		 * Parse a simple HTML string into SVG tspans
		 *
		 * @param {Object} textNode The parent text SVG node
		 */
		buildText: function (wrapper) {
			var textNode = wrapper.element,
				renderer = this,
				forExport = renderer.forExport,
				textStr = pick(wrapper.textStr, '').toString(),
				hasMarkup = textStr.indexOf('<') !== -1,
				lines,
				childNodes = textNode.childNodes,
				styleRegex,
				hrefRegex,
				parentX = attr(textNode, 'x'),
				textStyles = wrapper.styles,
				width = wrapper.textWidth,
				textLineHeight = textStyles && textStyles.lineHeight,
				textShadow = textStyles && textStyles.textShadow,
				ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
				i = childNodes.length,
				tempParent = width && !wrapper.added && this.box,
				getLineHeight = function (tspan) {
					return textLineHeight ? 
						pInt(textLineHeight) :
						renderer.fontMetrics(
							/(px|em)$/.test(tspan && tspan.style.fontSize) ?
								tspan.style.fontSize :
								((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
							tspan
						).h;
				},
				unescapeAngleBrackets = function (inputStr) {
					return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
				};

			/// remove old text
			while (i--) {
				textNode.removeChild(childNodes[i]);
			}

			// Skip tspans, add text directly to text node. The forceTSpan is a hook 
			// used in text outline hack.
			if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {
				textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
				return;

			// Complex strings, add more logic
			} else {

				styleRegex = /<.*style="([^"]+)".*>/;
				hrefRegex = /<.*href="(http[^"]+)".*>/;

				if (tempParent) {
					tempParent.appendChild(textNode); // attach it to the DOM to read offset width
				}

				if (hasMarkup) {
					lines = textStr
						.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
						.replace(/<(i|em)>/g, '<span style="font-style:italic">')
						.replace(/<a/g, '<span')
						.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
						.split(/<br.*?>/g);

				} else {
					lines = [textStr];
				}


				// remove empty line at end
				if (lines[lines.length - 1] === '') {
					lines.pop();
				}

				
				// build the lines
				each(lines, function (line, lineNo) {
					var spans, spanNo = 0;

					line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
					spans = line.split('|||');

					each(spans, function (span) {
						if (span !== '' || spans.length === 1) {
							var attributes = {},
								tspan = doc.createElementNS(SVG_NS, 'tspan'),
								spanStyle; // #390
							if (styleRegex.test(span)) {
								spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
								attr(tspan, 'style', spanStyle);
							}
							if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
								attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
								css(tspan, { cursor: 'pointer' });
							}

							span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

							// Nested tags aren't supported, and cause crash in Safari (#1596)
							if (span !== ' ') {

								// add the text node
								tspan.appendChild(doc.createTextNode(span));

								if (!spanNo) { // first span in a line, align it to the left
									if (lineNo && parentX !== null) {
										attributes.x = parentX;
									}
								} else {
									attributes.dx = 0; // #16
								}

								// add attributes
								attr(tspan, attributes);

								// Append it
								textNode.appendChild(tspan);

								// first span on subsequent line, add the line height
								if (!spanNo && lineNo) {

									// allow getting the right offset height in exporting in IE
									if (!hasSVG && forExport) {
										css(tspan, { display: 'block' });
									}

									// Set the line height based on the font size of either
									// the text element or the tspan element
									attr(
										tspan,
										'dy',
										getLineHeight(tspan)
									);
								}

								/*if (width) {
									renderer.breakText(wrapper, width);
								}*/

								// Check width and apply soft breaks or ellipsis
								if (width) {
									var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
										hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
										tooLong,
										wasTooLong,
										actualWidth,
										rest = [],
										dy = getLineHeight(tspan),
										softLineNo = 1,
										rotation = wrapper.rotation,
										wordStr = span, // for ellipsis
										cursor = wordStr.length, // binary search cursor
										bBox;

									while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
										wrapper.rotation = 0; // discard rotation when computing box
										bBox = wrapper.getBBox(true);
										actualWidth = bBox.width;

										// Old IE cannot measure the actualWidth for SVG elements (#2314)
										if (!hasSVG && renderer.forExport) {
											actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
										}

										tooLong = actualWidth > width;

										// For ellipsis, do a binary search for the correct string length
										if (wasTooLong === undefined) {
											wasTooLong = tooLong; // First time
										}
										if (ellipsis && wasTooLong) {
											cursor /= 2;

											if (wordStr === '' || (!tooLong && cursor < 0.5)) {
												words = []; // All ok, break out
											} else {
												if (tooLong) {
													wasTooLong = true;
												}
												wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
												words = [wordStr + '\u2026'];
												tspan.removeChild(tspan.firstChild);
											}

										// Looping down, this is the first word sequence that is not too long,
										// so we can move on to build the next line.
										} else if (!tooLong || words.length === 1) {
											words = rest;
											rest = [];
													
											if (words.length) {
												softLineNo++;
												
												tspan = doc.createElementNS(SVG_NS, 'tspan');
												attr(tspan, {
													dy: dy,
													x: parentX
												});
												if (spanStyle) { // #390
													attr(tspan, 'style', spanStyle);
												}
												textNode.appendChild(tspan);
											}
											if (actualWidth > width) { // a single word is pressing it out
												width = actualWidth;
											}
										} else { // append to existing line tspan
											tspan.removeChild(tspan.firstChild);
											rest.unshift(words.pop());
										}
										if (words.length) {
											tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
										}
									}
									if (wasTooLong) {
										wrapper.attr('title', wrapper.textStr);
									}
									wrapper.rotation = rotation;
								}

								spanNo++;
							}
						}
					});
				});
				if (tempParent) {
					tempParent.removeChild(textNode); // attach it to the DOM to read offset width
				}

				// Apply the text shadow
				if (textShadow && wrapper.applyTextShadow) {
					wrapper.applyTextShadow(textShadow);
				}
			}
		},

		

		/*
		breakText: function (wrapper, width) {
			var bBox = wrapper.getBBox(),
				node = wrapper.element,
				textLength = node.textContent.length,
				pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
				increment = 0,
				finalPos;

			if (bBox.width > width) {
				while (finalPos === undefined) {
					textLength = node.getSubStringLength(0, pos);

					if (textLength <= width) {
						if (increment === -1) {
							finalPos = pos;
						} else {
							increment = 1;
						}
					} else {
						if (increment === 1) {
							finalPos = pos - 1;
						} else {
							increment = -1;
						}
					}
					pos += increment;
				}
			}
			console.log(finalPos, node.getSubStringLength(0, finalPos))
		},
		*/

		/** 
		 * Returns white for dark colors and black for bright colors
		 */
		getContrast: function (color) {
			color = Color(color).rgba;
			return color[0] + color[1] + color[2] > 384 ? '#000' : '#FFF';
		},

		/**
		 * Create a button with preset states
		 * @param {String} text
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Function} callback
		 * @param {Object} normalState
		 * @param {Object} hoverState
		 * @param {Object} pressedState
		 */
		button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
			var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
				curState = 0,
				stateOptions,
				stateStyle,
				normalStyle,
				hoverStyle,
				pressedStyle,
				disabledStyle,
				verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

			// Normal state - prepare the attributes
			normalState = merge({
				'stroke-width': 1,
				stroke: '#CCCCCC',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#FEFEFE'],
						[1, '#F6F6F6']
					]
				},
				r: 2,
				padding: 5,
				style: {
					color: 'black'
				}
			}, normalState);
			normalStyle = normalState.style;
			delete normalState.style;

			// Hover state
			hoverState = merge(normalState, {
				stroke: '#68A',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#FFF'],
						[1, '#ACF']
					]
				}
			}, hoverState);
			hoverStyle = hoverState.style;
			delete hoverState.style;

			// Pressed state
			pressedState = merge(normalState, {
				stroke: '#68A',
				fill: {
					linearGradient: verticalGradient,
					stops: [
						[0, '#9BD'],
						[1, '#CDF']
					]
				}
			}, pressedState);
			pressedStyle = pressedState.style;
			delete pressedState.style;

			// Disabled state
			disabledState = merge(normalState, {
				style: {
					color: '#CCC'
				}
			}, disabledState);
			disabledStyle = disabledState.style;
			delete disabledState.style;

			// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
			addEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {
				if (curState !== 3) {
					label.attr(hoverState)
						.css(hoverStyle);
				}
			});
			addEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {
				if (curState !== 3) {
					stateOptions = [normalState, hoverState, pressedState][curState];
					stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
					label.attr(stateOptions)
						.css(stateStyle);
				}
			});

			label.setState = function (state) {
				label.state = curState = state;
				if (!state) {
					label.attr(normalState)
						.css(normalStyle);
				} else if (state === 2) {
					label.attr(pressedState)
						.css(pressedStyle);
				} else if (state === 3) {
					label.attr(disabledState)
						.css(disabledStyle);
				}
			};

			return label
				.on('click', function () {
					if (curState !== 3) {
						callback.call(label);
					}
				})
				.attr(normalState)
				.css(extend({ cursor: 'default' }, normalStyle));
		},

		/**
		 * Make a straight line crisper by not spilling out to neighbour pixels
		 * @param {Array} points
		 * @param {Number} width
		 */
		crispLine: function (points, width) {
			// points format: [M, 0, 0, L, 100, 0]
			// normalize to a crisp line
			if (points[1] === points[4]) {
				// Substract due to #1129. Now bottom and left axis gridlines behave the same.
				points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
			}
			if (points[2] === points[5]) {
				points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
			}
			return points;
		},


		/**
		 * Draw a path
		 * @param {Array} path An SVG path in array form
		 */
		path: function (path) {
			var attr = {
				fill: NONE
			};
			if (isArray(path)) {
				attr.d = path;
			} else if (isObject(path)) { // attributes
				extend(attr, path);
			}
			return this.createElement('path').attr(attr);
		},

		/**
		 * Draw and return an SVG circle
		 * @param {Number} x The x position
		 * @param {Number} y The y position
		 * @param {Number} r The radius
		 */
		circle: function (x, y, r) {
			var attr = isObject(x) ?
				x :
				{
					x: x,
					y: y,
					r: r
				},
				wrapper = this.createElement('circle');

			wrapper.xSetter = function (value) {
				this.element.setAttribute('cx', value);
			};
			wrapper.ySetter = function (value) {
				this.element.setAttribute('cy', value);
			};
			return wrapper.attr(attr);
		},

		/**
		 * Draw and return an arc
		 * @param {Number} x X position
		 * @param {Number} y Y position
		 * @param {Number} r Radius
		 * @param {Number} innerR Inner radius like used in donut charts
		 * @param {Number} start Starting angle
		 * @param {Number} end Ending angle
		 */
		arc: function (x, y, r, innerR, start, end) {
			var arc;

			if (isObject(x)) {
				y = x.y;
				r = x.r;
				innerR = x.innerR;
				start = x.start;
				end = x.end;
				x = x.x;
			}

			// Arcs are defined as symbols for the ability to set
			// attributes in attr and animate
			arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
				innerR: innerR || 0,
				start: start || 0,
				end: end || 0
			});
			arc.r = r; // #959
			return arc;
		},

		/**
		 * Draw and return a rectangle
		 * @param {Number} x Left position
		 * @param {Number} y Top position
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Number} r Border corner radius
		 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
		 */
		rect: function (x, y, width, height, r, strokeWidth) {

			r = isObject(x) ? x.r : r;

			var wrapper = this.createElement('rect'),
				attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
					x: x,
					y: y,
					width: mathMax(width, 0),
					height: mathMax(height, 0)
				};

			if (strokeWidth !== UNDEFINED) {
				attribs.strokeWidth = strokeWidth;
				attribs = wrapper.crisp(attribs);
			}

			if (r) {
				attribs.r = r;
			}

			wrapper.rSetter = function (value) {
				attr(this.element, {
					rx: value,
					ry: value
				});
			};
			
			return wrapper.attr(attribs);
		},

		/**
		 * Resize the box and re-align all aligned elements
		 * @param {Object} width
		 * @param {Object} height
		 * @param {Boolean} animate
		 *
		 */
		setSize: function (width, height, animate) {
			var renderer = this,
				alignedObjects = renderer.alignedObjects,
				i = alignedObjects.length;

			renderer.width = width;
			renderer.height = height;

			renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
				width: width,
				height: height
			});

			while (i--) {
				alignedObjects[i].align();
			}
		},

		/**
		 * Create a group
		 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
		 *	 This can be used for styling and scripting.
		 */
		g: function (name) {
			var elem = this.createElement('g');
			return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
		},

		/**
		 * Display an image
		 * @param {String} src
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		image: function (src, x, y, width, height) {
			var attribs = {
					preserveAspectRatio: NONE
				},
				elemWrapper;

			// optional properties
			if (arguments.length > 1) {
				extend(attribs, {
					x: x,
					y: y,
					width: width,
					height: height
				});
			}

			elemWrapper = this.createElement('image').attr(attribs);

			// set the href in the xlink namespace
			if (elemWrapper.element.setAttributeNS) {
				elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
					'href', src);
			} else {
				// could be exporting in IE
				// using href throws "not supported" in ie7 and under, requries regex shim to fix later
				elemWrapper.element.setAttribute('hc-svg-href', src);
			}
			return elemWrapper;
		},

		/**
		 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
		 *
		 * @param {Object} symbol
		 * @param {Object} x
		 * @param {Object} y
		 * @param {Object} radius
		 * @param {Object} options
		 */
		symbol: function (symbol, x, y, width, height, options) {

			var obj,

				// get the symbol definition function
				symbolFn = this.symbols[symbol],

				// check if there's a path defined for this symbol
				path = symbolFn && symbolFn(
					mathRound(x),
					mathRound(y),
					width,
					height,
					options
				),

				imageElement,
				imageRegex = /^url\((.*?)\)$/,
				imageSrc,
				imageSize,
				centerImage;

			if (path) {

				obj = this.path(path);
				// expando properties for use in animate and attr
				extend(obj, {
					symbolName: symbol,
					x: x,
					y: y,
					width: width,
					height: height
				});
				if (options) {
					extend(obj, options);
				}


			// image symbols
			} else if (imageRegex.test(symbol)) {

				// On image load, set the size and position
				centerImage = function (img, size) {
					if (img.element) { // it may be destroyed in the meantime (#1390)
						img.attr({
							width: size[0],
							height: size[1]
						});

						if (!img.alignByTranslate) { // #185
							img.translate(
								mathRound((width - size[0]) / 2), // #1378
								mathRound((height - size[1]) / 2)
							);
						}
					}
				};

				imageSrc = symbol.match(imageRegex)[1];
				imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

				// Ireate the image synchronously, add attribs async
				obj = this.image(imageSrc)
					.attr({
						x: x,
						y: y
					});
				obj.isImg = true;

				if (imageSize) {
					centerImage(obj, imageSize);
				} else {
					// Initialize image to be 0 size so export will still function if there's no cached sizes.
					obj.attr({ width: 0, height: 0 });

					// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
					// the created element must be assigned to a variable in order to load (#292).
					imageElement = createElement('img', {
						onload: function () {
							centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);
						},
						src: imageSrc
					});
				}
			}

			return obj;
		},

		/**
		 * An extendable collection of functions for defining symbol paths.
		 */
		symbols: {
			'circle': function (x, y, w, h) {
				var cpw = 0.166 * w;
				return [
					M, x + w / 2, y,
					'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
					'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
					'Z'
				];
			},

			'square': function (x, y, w, h) {
				return [
					M, x, y,
					L, x + w, y,
					x + w, y + h,
					x, y + h,
					'Z'
				];
			},

			'triangle': function (x, y, w, h) {
				return [
					M, x + w / 2, y,
					L, x + w, y + h,
					x, y + h,
					'Z'
				];
			},

			'triangle-down': function (x, y, w, h) {
				return [
					M, x, y,
					L, x + w, y,
					x + w / 2, y + h,
					'Z'
				];
			},
			'diamond': function (x, y, w, h) {
				return [
					M, x + w / 2, y,
					L, x + w, y + h / 2,
					x + w / 2, y + h,
					x, y + h / 2,
					'Z'
				];
			},
			'arc': function (x, y, w, h, options) {
				var start = options.start,
					radius = options.r || w || h,
					end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
					innerRadius = options.innerR,
					open = options.open,
					cosStart = mathCos(start),
					sinStart = mathSin(start),
					cosEnd = mathCos(end),
					sinEnd = mathSin(end),
					longArc = options.end - start < mathPI ? 0 : 1;

				return [
					M,
					x + radius * cosStart,
					y + radius * sinStart,
					'A', // arcTo
					radius, // x radius
					radius, // y radius
					0, // slanting
					longArc, // long or short arc
					1, // clockwise
					x + radius * cosEnd,
					y + radius * sinEnd,
					open ? M : L,
					x + innerRadius * cosEnd,
					y + innerRadius * sinEnd,
					'A', // arcTo
					innerRadius, // x radius
					innerRadius, // y radius
					0, // slanting
					longArc, // long or short arc
					0, // clockwise
					x + innerRadius * cosStart,
					y + innerRadius * sinStart,

					open ? '' : 'Z' // close
				];
			},

			/**
			 * Callout shape used for default tooltips, also used for rounded rectangles in VML
			 */
			callout: function (x, y, w, h, options) {
				var arrowLength = 6,
					halfDistance = 6,
					r = mathMin((options && options.r) || 0, w, h),
					safeDistance = r + halfDistance,
					anchorX = options && options.anchorX,
					anchorY = options && options.anchorY,
					path,
					normalizer = mathRound(options.strokeWidth || 0) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors;

				x += normalizer;
				y += normalizer;
				path = [
					'M', x + r, y, 
					'L', x + w - r, y, // top side
					'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
					'L', x + w, y + h - r, // right side
					'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
					'L', x + r, y + h, // bottom side
					'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
					'L', x, y + r, // left side
					'C', x, y, x, y, x + r, y // top-right corner
				];
				
				if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
					path.splice(13, 3,
						'L', x + w, anchorY - halfDistance, 
						x + w + arrowLength, anchorY,
						x + w, anchorY + halfDistance,
						x + w, y + h - r
					);
				} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
					path.splice(33, 3, 
						'L', x, anchorY + halfDistance, 
						x - arrowLength, anchorY,
						x, anchorY - halfDistance,
						x, y + r
					);
				} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
					path.splice(23, 3,
						'L', anchorX + halfDistance, y + h,
						anchorX, y + h + arrowLength,
						anchorX - halfDistance, y + h,
						x + r, y + h
					);
				} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
					path.splice(3, 3,
						'L', anchorX - halfDistance, y,
						anchorX, y - arrowLength,
						anchorX + halfDistance, y,
						w - r, y
					);
				}
				return path;
			}
		},

		/**
		 * Define a clipping rectangle
		 * @param {String} id
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		clipRect: function (x, y, width, height) {
			var wrapper,
				id = PREFIX + idCounter++,

				clipPath = this.createElement('clipPath').attr({
					id: id
				}).add(this.defs);

			wrapper = this.rect(x, y, width, height, 0).add(clipPath);
			wrapper.id = id;
			wrapper.clipPath = clipPath;
			wrapper.count = 0;

			return wrapper;
		},


		


		/**
		 * Add text to the SVG object
		 * @param {String} str
		 * @param {Number} x Left position
		 * @param {Number} y Top position
		 * @param {Boolean} useHTML Use HTML to render the text
		 */
		text: function (str, x, y, useHTML) {

			// declare variables
			var renderer = this,
				fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
				wrapper,
				attr = {};

			if (useHTML && !renderer.forExport) {
				return renderer.html(str, x, y);
			}

			attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
			if (y) {
				attr.y = Math.round(y);
			}
			if (str || str === 0) {
				attr.text = str;
			}

			wrapper = renderer.createElement('text')
				.attr(attr);

			// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
			if (fakeSVG) {
				wrapper.css({
					position: ABSOLUTE
				});
			}

			if (!useHTML) {
				wrapper.xSetter = function (value, key, element) {
					var tspans = element.getElementsByTagName('tspan'),
						tspan,
						parentVal = element.getAttribute(key),
						i;
					for (i = 0; i < tspans.length; i++) {
						tspan = tspans[i];
						// If the x values are equal, the tspan represents a linebreak
						if (tspan.getAttribute(key) === parentVal) {
							tspan.setAttribute(key, value);
						}
					}
					element.setAttribute(key, value);
				};
			}
			
			return wrapper;
		},

		/**
		 * Utility to return the baseline offset and total line height from the font size
		 */
		fontMetrics: function (fontSize, elem) {
			fontSize = fontSize || this.style.fontSize;
			if (elem && win.getComputedStyle) {
				elem = elem.element || elem; // SVGElement
				fontSize = win.getComputedStyle(elem, "").fontSize;
			}
			fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

			// Empirical values found by comparing font size and bounding box height.
			// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
			var lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2),
				baseline = mathRound(lineHeight * 0.8);

			return {
				h: lineHeight,
				b: baseline,
				f: fontSize
			};
		},

		/**
		 * Correct X and Y positioning of a label for rotation (#1764)
		 */
		rotCorr: function (baseline, rotation, alterY) {
			var y = baseline;
			if (rotation && alterY) {
				y = mathMax(y * mathCos(rotation * deg2rad), 4);
			}
			return {
				x: (-baseline / 3) * mathSin(rotation * deg2rad),
				y: y
			};
		},

		/**
		 * Add a label, a text item that can hold a colored or gradient background
		 * as well as a border and shadow.
		 * @param {string} str
		 * @param {Number} x
		 * @param {Number} y
		 * @param {String} shape
		 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
		 *	coordinates it should be pinned to
		 * @param {Number} anchorY
		 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
		 *	like renderer.text, or to the upper border of the rectangle.
		 * @param {String} className Class name for the group
		 */
		label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

			var renderer = this,
				wrapper = renderer.g(className),
				text = renderer.text('', 0, 0, useHTML)
					.attr({
						zIndex: 1
					}),
					//.add(wrapper),
				box,
				bBox,
				alignFactor = 0,
				padding = 3,
				paddingLeft = 0,
				width,
				height,
				wrapperX,
				wrapperY,
				crispAdjust = 0,
				deferredAttr = {},
				baselineOffset,
				needsBox;

			/**
			 * This function runs after the label is added to the DOM (when the bounding box is
			 * available), and after the text of the label is updated to detect the new bounding
			 * box and reflect it in the border box.
			 */
			function updateBoxSize() {
				var boxX,
					boxY,
					style = text.element.style;

				bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && 
					text.getBBox(); //#3295 && 3514 box failure when string equals 0
				wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
				wrapper.height = (height || bBox.height || 0) + 2 * padding;

				// update the label-scoped y offset
				baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;

				
				if (needsBox) {

					// create the border box if it is not already present
					if (!box) {
						boxX = mathRound(-alignFactor * padding);
						boxY = baseline ? -baselineOffset : 0;

						wrapper.box = box = shape ?
							renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
							renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
						box.attr('fill', NONE).add(wrapper);
					}

					// apply the box attributes
					if (!box.isImg) { // #1630
						box.attr(extend({
							width: mathRound(wrapper.width),
							height: mathRound(wrapper.height)
						}, deferredAttr));
					}
					deferredAttr = null;
				}
			}

			/**
			 * This function runs after setting text or padding, but only if padding is changed
			 */
			function updateTextPadding() {
				var styles = wrapper.styles,
					textAlign = styles && styles.textAlign,
					x = paddingLeft + padding * (1 - alignFactor),
					y;

				// determin y based on the baseline
				y = baseline ? 0 : baselineOffset;

				// compensate for alignment
				if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
					x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
				}

				// update if anything changed
				if (x !== text.x || y !== text.y) {
					text.attr('x', x);
					if (y !== UNDEFINED) {
						// As a workaround for #3649, use translation instead of y attribute. #3649
						// is a rendering bug in WebKit for Retina (Mac, iOS, PhantomJS) that 
						// results in duplicated text when an y attribute is used in combination 
						// with a CSS text-style.
						text.attr(text.element.nodeName === 'SPAN' ? 'y' : 'translateY', y);
					}
				}

				// record current values
				text.x = x;
				text.y = y;
			}

			/**
			 * Set a box attribute, or defer it if the box is not yet created
			 * @param {Object} key
			 * @param {Object} value
			 */
			function boxAttr(key, value) {
				if (box) {
					box.attr(key, value);
				} else {
					deferredAttr[key] = value;
				}
			}

			/**
			 * After the text element is added, get the desired size of the border box
			 * and add it before the text in the DOM.
			 */
			wrapper.onAdd = function () {
				text.add(wrapper);
				wrapper.attr({
					text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
					x: x,
					y: y
				});

				if (box && defined(anchorX)) {
					wrapper.attr({
						anchorX: anchorX,
						anchorY: anchorY
					});
				}
			};

			/*
			 * Add specific attribute setters.
			 */

			// only change local variables
			wrapper.widthSetter = function (value) {
				width = value;
			};
			wrapper.heightSetter = function (value) {
				height = value;
			};
			wrapper.paddingSetter =  function (value) {
				if (defined(value) && value !== padding) {
					padding = wrapper.padding = value;
					updateTextPadding();
				}
			};
			wrapper.paddingLeftSetter =  function (value) {
				if (defined(value) && value !== paddingLeft) {
					paddingLeft = value;
					updateTextPadding();
				}
			};


			// change local variable and prevent setting attribute on the group
			wrapper.alignSetter = function (value) {
				alignFactor = { left: 0, center: 0.5, right: 1 }[value];
			};

			// apply these to the box and the text alike
			wrapper.textSetter = function (value) {
				if (value !== UNDEFINED) {
					text.textSetter(value);
				}
				updateBoxSize();
				updateTextPadding();
			};

			// apply these to the box but not to the text
			wrapper['stroke-widthSetter'] = function (value, key) {
				if (value) {
					needsBox = true;
				}
				crispAdjust = value % 2 / 2;
				boxAttr(key, value);
			};
			wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
				if (key === 'fill' && value) {
					needsBox = true;
				}
				boxAttr(key, value);
			};
			wrapper.anchorXSetter = function (value, key) {
				anchorX = value;
				boxAttr(key, value + crispAdjust - wrapperX);
			};
			wrapper.anchorYSetter = function (value, key) {
				anchorY = value;
				boxAttr(key, value - wrapperY);
			};

			// rename attributes
			wrapper.xSetter = function (value) {
				wrapper.x = value; // for animation getter
				if (alignFactor) {
					value -= alignFactor * ((width || bBox.width) + padding);
				}
				wrapperX = mathRound(value);
				wrapper.attr('translateX', wrapperX);
			};
			wrapper.ySetter = function (value) {
				wrapperY = wrapper.y = mathRound(value);
				wrapper.attr('translateY', wrapperY);
			};

			// Redirect certain methods to either the box or the text
			var baseCss = wrapper.css;
			return extend(wrapper, {
				/**
				 * Pick up some properties and apply them to the text instead of the wrapper
				 */
				css: function (styles) {
					if (styles) {
						var textStyles = {};
						styles = merge(styles); // create a copy to avoid altering the original object (#537)
						each(wrapper.textProps, function (prop) {
							if (styles[prop] !== UNDEFINED) {
								textStyles[prop] = styles[prop];
								delete styles[prop];
							}
						});
						text.css(textStyles);
					}
					return baseCss.call(wrapper, styles);
				},
				/**
				 * Return the bounding box of the box, not the group
				 */
				getBBox: function () {
					return {
						width: bBox.width + 2 * padding,
						height: bBox.height + 2 * padding,
						x: bBox.x - padding,
						y: bBox.y - padding
					};
				},
				/**
				 * Apply the shadow to the box
				 */
				shadow: function (b) {
					if (box) {
						box.shadow(b);
					}
					return wrapper;
				},
				/**
				 * Destroy and release memory.
				 */
				destroy: function () {

					// Added by button implementation
					removeEvent(wrapper.element, 'mouseenter');
					removeEvent(wrapper.element, 'mouseleave');

					if (text) {
						text = text.destroy();
					}
					if (box) {
						box = box.destroy();
					}
					// Call base implementation to destroy the rest
					SVGElement.prototype.destroy.call(wrapper);

					// Release local pointers (#1298)
					wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
				}
			});
		}
	}; // end SVGRenderer


	// general renderer
	Renderer = SVGRenderer;
	// extend SvgElement for useHTML option
	extend(SVGElement.prototype, {
		/**
		 * Apply CSS to HTML elements. This is used in text within SVG rendering and
		 * by the VML renderer
		 */
		htmlCss: function (styles) {
			var wrapper = this,
				element = wrapper.element,
				textWidth = styles && element.tagName === 'SPAN' && styles.width;

			if (textWidth) {
				delete styles.width;
				wrapper.textWidth = textWidth;
				wrapper.updateTransform();
			}
			if (styles && styles.textOverflow === 'ellipsis') {
				styles.whiteSpace = 'nowrap';
				styles.overflow = 'hidden';
			}
			wrapper.styles = extend(wrapper.styles, styles);
			css(wrapper.element, styles);

			return wrapper;
		},

		/**
		 * VML and useHTML method for calculating the bounding box based on offsets
		 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
		 * use the cached value
		 *
		 * @return {Object} A hash containing values for x, y, width and height
		 */

		htmlGetBBox: function () {
			var wrapper = this,
				element = wrapper.element;

			// faking getBBox in exported SVG in legacy IE
			// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
			if (element.nodeName === 'text') {
				element.style.position = ABSOLUTE;
			}

			return {
				x: element.offsetLeft,
				y: element.offsetTop,
				width: element.offsetWidth,
				height: element.offsetHeight
			};
		},

		/**
		 * VML override private method to update elements based on internal
		 * properties based on SVG transform
		 */
		htmlUpdateTransform: function () {
			// aligning non added elements is expensive
			if (!this.added) {
				this.alignOnAdd = true;
				return;
			}

			var wrapper = this,
				renderer = wrapper.renderer,
				elem = wrapper.element,
				translateX = wrapper.translateX || 0,
				translateY = wrapper.translateY || 0,
				x = wrapper.x || 0,
				y = wrapper.y || 0,
				align = wrapper.textAlign || 'left',
				alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
				shadows = wrapper.shadows,
				styles = wrapper.styles;

			// apply translate
			css(elem, {
				marginLeft: translateX,
				marginTop: translateY
			});
			if (shadows) { // used in labels/tooltip
				each(shadows, function (shadow) {
					css(shadow, {
						marginLeft: translateX + 1,
						marginTop: translateY + 1
					});
				});
			}

			// apply inversion
			if (wrapper.inverted) { // wrapper is a group
				each(elem.childNodes, function (child) {
					renderer.invertChild(child, elem);
				});
			}

			if (elem.tagName === 'SPAN') {

				var width,
					rotation = wrapper.rotation,
					baseline,
					textWidth = pInt(wrapper.textWidth),
					currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

				if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


					baseline = renderer.fontMetrics(elem.style.fontSize).b;

					// Renderer specific handling of span rotation
					if (defined(rotation)) {
						wrapper.setSpanRotation(rotation, alignCorrection, baseline);
					}

					width = pick(wrapper.elemWidth, elem.offsetWidth);

					// Update textWidth
					if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
						css(elem, {
							width: textWidth + PX,
							display: 'block',
							whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331
						});
						width = textWidth;
					}

					wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);
				}

				// apply position with correction
				css(elem, {
					left: (x + (wrapper.xCorr || 0)) + PX,
					top: (y + (wrapper.yCorr || 0)) + PX
				});

				// force reflow in webkit to apply the left and top on useHTML element (#1249)
				if (isWebKit) {
					baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose
				}

				// record current text transform
				wrapper.cTT = currentTextTransform;
			}
		},

		/**
		 * Set the rotation of an individual HTML span
		 */
		setSpanRotation: function (rotation, alignCorrection, baseline) {
			var rotationStyle = {},
				cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

			rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
			rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
			css(this.element, rotationStyle);
		},

		/**
		 * Get the correction in X and Y positioning as the element is rotated.
		 */
		getSpanCorrection: function (width, baseline, alignCorrection) {
			this.xCorr = -width * alignCorrection;
			this.yCorr = -baseline;
		}
	});

	// Extend SvgRenderer for useHTML option.
	extend(SVGRenderer.prototype, {
		/**
		 * Create HTML text node. This is used by the VML renderer as well as the SVG
		 * renderer through the useHTML option.
		 *
		 * @param {String} str
		 * @param {Number} x
		 * @param {Number} y
		 */
		html: function (str, x, y) {
			var wrapper = this.createElement('span'),
				element = wrapper.element,
				renderer = wrapper.renderer;

			// Text setter
			wrapper.textSetter = function (value) {
				if (value !== element.innerHTML) {
					delete this.bBox;
				}
				element.innerHTML = this.textStr = value;
			};

			// Various setters which rely on update transform
			wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
				if (key === 'align') {
					key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
				}
				wrapper[key] = value;
				wrapper.htmlUpdateTransform();
			};

			// Set the default attributes
			wrapper.attr({
					text: str,
					x: mathRound(x),
					y: mathRound(y)
				})
				.css({
					position: ABSOLUTE,
					fontFamily: this.style.fontFamily,
					fontSize: this.style.fontSize
				});

			// Keep the whiteSpace style outside the wrapper.styles collection
			element.style.whiteSpace = 'nowrap';

			// Use the HTML specific .css method
			wrapper.css = wrapper.htmlCss;

			// This is specific for HTML within SVG
			if (renderer.isSVG) {
				wrapper.add = function (svgGroupWrapper) {

					var htmlGroup,
						container = renderer.box.parentNode,
						parentGroup,
						parents = [];

					this.parentGroup = svgGroupWrapper;

					// Create a mock group to hold the HTML elements
					if (svgGroupWrapper) {
						htmlGroup = svgGroupWrapper.div;
						if (!htmlGroup) {

							// Read the parent chain into an array and read from top down
							parentGroup = svgGroupWrapper;
							while (parentGroup) {

								parents.push(parentGroup);

								// Move up to the next parent group
								parentGroup = parentGroup.parentGroup;
							}

							// Ensure dynamically updating position when any parent is translated
							each(parents.reverse(), function (parentGroup) {
								var htmlGroupStyle;

								// Create a HTML div and append it to the parent div to emulate
								// the SVG group structure
								htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {
									className: attr(parentGroup.element, 'class')
								}, {
									position: ABSOLUTE,
									left: (parentGroup.translateX || 0) + PX,
									top: (parentGroup.translateY || 0) + PX
								}, htmlGroup || container); // the top group is appended to container

								// Shortcut
								htmlGroupStyle = htmlGroup.style;

								// Set listeners to update the HTML div's position whenever the SVG group
								// position is changed
								extend(parentGroup, {
									translateXSetter: function (value, key) {
										htmlGroupStyle.left = value + PX;
										parentGroup[key] = value;
										parentGroup.doTransform = true;
									},
									translateYSetter: function (value, key) {
										htmlGroupStyle.top = value + PX;
										parentGroup[key] = value;
										parentGroup.doTransform = true;
									},
									visibilitySetter: function (value, key) {
										htmlGroupStyle[key] = value;
									}
								});
							});

						}
					} else {
						htmlGroup = container;
					}

					htmlGroup.appendChild(element);

					// Shared with VML:
					wrapper.added = true;
					if (wrapper.alignOnAdd) {
						wrapper.htmlUpdateTransform();
					}

					return wrapper;
				};
			}
			return wrapper;
		}
	});

	/* ****************************************************************************
	 *                                                                            *
	 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
	 *                                                                            *
	 * For applications and websites that don't need IE support, like platform    *
	 * targeted mobile apps and web apps, this code can be removed.               *
	 *                                                                            *
	 *****************************************************************************/

	/**
	 * @constructor
	 */
	var VMLRenderer, VMLElement;
	if (!hasSVG && !useCanVG) {

	/**
	 * The VML element wrapper.
	 */
	VMLElement = {

		/**
		 * Initialize a new VML element wrapper. It builds the markup as a string
		 * to minimize DOM traffic.
		 * @param {Object} renderer
		 * @param {Object} nodeName
		 */
		init: function (renderer, nodeName) {
			var wrapper = this,
				markup =  ['<', nodeName, ' filled="f" stroked="f"'],
				style = ['position: ', ABSOLUTE, ';'],
				isDiv = nodeName === DIV;

			// divs and shapes need size
			if (nodeName === 'shape' || isDiv) {
				style.push('left:0;top:0;width:1px;height:1px;');
			}
			style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

			markup.push(' style="', style.join(''), '"/>');

			// create element with default attributes and style
			if (nodeName) {
				markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
					markup.join('')
					: renderer.prepVML(markup);
				wrapper.element = createElement(markup);
			}

			wrapper.renderer = renderer;
		},

		/**
		 * Add the node to the given parent
		 * @param {Object} parent
		 */
		add: function (parent) {
			var wrapper = this,
				renderer = wrapper.renderer,
				element = wrapper.element,
				box = renderer.box,
				inverted = parent && parent.inverted,

				// get the parent node
				parentNode = parent ?
					parent.element || parent :
					box;


			// if the parent group is inverted, apply inversion on all children
			if (inverted) { // only on groups
				renderer.invertChild(element, parentNode);
			}

			// append it
			parentNode.appendChild(element);

			// align text after adding to be able to read offset
			wrapper.added = true;
			if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
				wrapper.updateTransform();
			}

			// fire an event for internal hooks
			if (wrapper.onAdd) {
				wrapper.onAdd();
			}

			return wrapper;
		},

		/**
		 * VML always uses htmlUpdateTransform
		 */
		updateTransform: SVGElement.prototype.htmlUpdateTransform,

		/**
		 * Set the rotation of a span with oldIE's filter
		 */
		setSpanRotation: function () {
			// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
			// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
			// has support for CSS3 transform. The getBBox method also needs to be updated
			// to compensate for the rotation, like it currently does for SVG.
			// Test case: http://jsfiddle.net/highcharts/Ybt44/

			var rotation = this.rotation,
				costheta = mathCos(rotation * deg2rad),
				sintheta = mathSin(rotation * deg2rad);
						
			css(this.element, {
				filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
					', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
					', sizingMethod=\'auto expand\')'].join('') : NONE
			});
		},

		/**
		 * Get the positioning correction for the span after rotating. 
		 */
		getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

			var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
				sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
				height = pick(this.elemHeight, this.element.offsetHeight),
				quad,
				nonLeft = align && align !== 'left';

			// correct x and y
			this.xCorr = costheta < 0 && -width;
			this.yCorr = sintheta < 0 && -height;

			// correct for baseline and corners spilling out after rotation
			quad = costheta * sintheta < 0;
			this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
			this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
			// correct for the length/height of the text
			if (nonLeft) {
				this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
				if (rotation) {
					this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
				}
				css(this.element, {
					textAlign: align
				});
			}
		},

		/**
		 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
		 * as the parameter and returns a string.
		 */
		pathToVML: function (value) {
			// convert paths
			var i = value.length,
				path = [];

			while (i--) {

				// Multiply by 10 to allow subpixel precision.
				// Substracting half a pixel seems to make the coordinates
				// align with SVG, but this hasn't been tested thoroughly
				if (isNumber(value[i])) {
					path[i] = mathRound(value[i] * 10) - 5;
				} else if (value[i] === 'Z') { // close the path
					path[i] = 'x';
				} else {
					path[i] = value[i];

					// When the start X and end X coordinates of an arc are too close,
					// they are rounded to the same value above. In this case, substract or 
					// add 1 from the end X and Y positions. #186, #760, #1371, #1410.
					if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
						// Start and end X
						if (path[i + 5] === path[i + 7]) {
							path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
						}
						// Start and end Y
						if (path[i + 6] === path[i + 8]) {
							path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
						}
					}
				}
			}

			
			// Loop up again to handle path shortcuts (#2132)
			/*while (i++ < path.length) {
				if (path[i] === 'H') { // horizontal line to
					path[i] = 'L';
					path.splice(i + 2, 0, path[i - 1]);
				} else if (path[i] === 'V') { // vertical line to
					path[i] = 'L';
					path.splice(i + 1, 0, path[i - 2]);
				}
			}*/
			return path.join(' ') || 'x';
		},

		/**
		 * Set the element's clipping to a predefined rectangle
		 *
		 * @param {String} id The id of the clip rectangle
		 */
		clip: function (clipRect) {
			var wrapper = this,
				clipMembers,
				cssRet;

			if (clipRect) {
				clipMembers = clipRect.members;
				erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
				clipMembers.push(wrapper);
				wrapper.destroyClip = function () {
					erase(clipMembers, wrapper);
				};
				cssRet = clipRect.getCSS(wrapper);

			} else {
				if (wrapper.destroyClip) {
					wrapper.destroyClip();
				}
				cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
			}

			return wrapper.css(cssRet);

		},

		/**
		 * Set styles for the element
		 * @param {Object} styles
		 */
		css: SVGElement.prototype.htmlCss,

		/**
		 * Removes a child either by removeChild or move to garbageBin.
		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
		 */
		safeRemoveChild: function (element) {
			// discardElement will detach the node from its parent before attaching it
			// to the garbage bin. Therefore it is important that the node is attached and have parent.
			if (element.parentNode) {
				discardElement(element);
			}
		},

		/**
		 * Extend element.destroy by removing it from the clip members array
		 */
		destroy: function () {
			if (this.destroyClip) {
				this.destroyClip();
			}

			return SVGElement.prototype.destroy.apply(this);
		},

		/**
		 * Add an event listener. VML override for normalizing event parameters.
		 * @param {String} eventType
		 * @param {Function} handler
		 */
		on: function (eventType, handler) {
			// simplest possible event model for internal use
			this.element['on' + eventType] = function () {
				var evt = win.event;
				evt.target = evt.srcElement;
				handler(evt);
			};
			return this;
		},

		/**
		 * In stacked columns, cut off the shadows so that they don't overlap
		 */
		cutOffPath: function (path, length) {

			var len;

			path = path.split(/[ ,]/);
			len = path.length;

			if (len === 9 || len === 11) {
				path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
			}
			return path.join(' ');
		},

		/**
		 * Apply a drop shadow by copying elements and giving them different strokes
		 * @param {Boolean|Object} shadowOptions
		 */
		shadow: function (shadowOptions, group, cutOff) {
			var shadows = [],
				i,
				element = this.element,
				renderer = this.renderer,
				shadow,
				elemStyle = element.style,
				markup,
				path = element.path,
				strokeWidth,
				modifiedPath,
				shadowWidth,
				shadowElementOpacity;

			// some times empty paths are not strings
			if (path && typeof path.value !== 'string') {
				path = 'x';
			}
			modifiedPath = path;

			if (shadowOptions) {
				shadowWidth = pick(shadowOptions.width, 3);
				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
				for (i = 1; i <= 3; i++) {

					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

					// Cut off shadows for stacked column items
					if (cutOff) {
						modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
					}

					markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
						'" filled="false" path="', modifiedPath,
						'" coordsize="10 10" style="', element.style.cssText, '" />'];

					shadow = createElement(renderer.prepVML(markup),
						null, {
							left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
							top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
						}
					);
					if (cutOff) {
						shadow.cutOff = strokeWidth + 1;
					}

					// apply the opacity
					markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
					createElement(renderer.prepVML(markup), null, null, shadow);


					// insert it
					if (group) {
						group.element.appendChild(shadow);
					} else {
						element.parentNode.insertBefore(shadow, element);
					}

					// record it
					shadows.push(shadow);

				}

				this.shadows = shadows;
			}
			return this;
		},
		updateShadows: noop, // Used in SVG only

		setAttr: function (key, value) {
			if (docMode8) { // IE8 setAttribute bug
				this.element[key] = value;
			} else {
				this.element.setAttribute(key, value);
			}
		},
		classSetter: function (value) {
			// IE8 Standards mode has problems retrieving the className unless set like this
			this.element.className = value;
		},
		dashstyleSetter: function (value, key, element) {
			var strokeElem = element.getElementsByTagName('stroke')[0] ||
				createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
			strokeElem[key] = value || 'solid';
			this[key] = value; /* because changing stroke-width will change the dash length
				and cause an epileptic effect */
		},
		dSetter: function (value, key, element) {
			var i,
				shadows = this.shadows;
			value = value || [];
			this.d = value.join && value.join(' '); // used in getter for animation

			element.path = value = this.pathToVML(value);

			// update shadows
			if (shadows) {
				i = shadows.length;
				while (i--) {
					shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
				}
			}
			this.setAttr(key, value);
		},
		fillSetter: function (value, key, element) {
			var nodeName = element.nodeName;
			if (nodeName === 'SPAN') { // text color
				element.style.color = value;
			} else if (nodeName !== 'IMG') { // #1336
				element.filled = value !== NONE;
				this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
			}
		},
		opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
		rotationSetter: function (value, key, element) {
			var style = element.style;
			this[key] = style[key] = value; // style is for #1873

			// Correction for the 1x1 size of the shape container. Used in gauge needles.
			style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
			style.top = mathRound(mathCos(value * deg2rad)) + PX;
		},
		strokeSetter: function (value, key, element) {
			this.setAttr('strokecolor', this.renderer.color(value, element, key));
		},
		'stroke-widthSetter': function (value, key, element) {
			element.stroked = !!value; // VML "stroked" attribute
			this[key] = value; // used in getter, issue #113
			if (isNumber(value)) {
				value += PX;
			}
			this.setAttr('strokeweight', value);
		},
		titleSetter: function (value, key) {
			this.setAttr(key, value);
		},
		visibilitySetter: function (value, key, element) {

			// Handle inherited visibility
			if (value === 'inherit') {
				value = VISIBLE;
			}
			
			// Let the shadow follow the main element
			if (this.shadows) {
				each(this.shadows, function (shadow) {
					shadow.style[key] = value;
				});
			}

			// Instead of toggling the visibility CSS property, move the div out of the viewport.
			// This works around #61 and #586
			if (element.nodeName === 'DIV') {
				value = value === HIDDEN ? '-999em' : 0;

				// In order to redraw, IE7 needs the div to be visible when tucked away
				// outside the viewport. So the visibility is actually opposite of
				// the expected value. This applies to the tooltip only.
				if (!docMode8) {
					element.style[key] = value ? VISIBLE : HIDDEN;
				}
				key = 'top';
			}
			element.style[key] = value;
		},
		xSetter: function (value, key, element) {
			this[key] = value; // used in getter

			if (key === 'x') {
				key = 'left';
			} else if (key === 'y') {
				key = 'top';
			}/* else {
				value = mathMax(0, value); // don't set width or height below zero (#311)
			}*/

			// clipping rectangle special
			if (this.updateClipping) {
				this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
				this.updateClipping();
			} else {
				// normal
				element.style[key] = value;
			}
		},
		zIndexSetter: function (value, key, element) {
			element.style[key] = value;
		}
	};
	Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

	// Some shared setters
	VMLElement.prototype.ySetter =
		VMLElement.prototype.widthSetter = 
		VMLElement.prototype.heightSetter = 
		VMLElement.prototype.xSetter;


	/**
	 * The VML renderer
	 */
	var VMLRendererExtension = { // inherit SVGRenderer

		Element: VMLElement,
		isIE8: userAgent.indexOf('MSIE 8.0') > -1,


		/**
		 * Initialize the VMLRenderer
		 * @param {Object} container
		 * @param {Number} width
		 * @param {Number} height
		 */
		init: function (container, width, height, style) {
			var renderer = this,
				boxWrapper,
				box,
				css;

			renderer.alignedObjects = [];

			boxWrapper = renderer.createElement(DIV)
				.css(extend(this.getStyle(style), { position: RELATIVE}));
			box = boxWrapper.element;
			container.appendChild(boxWrapper.element);


			// generate the containing box
			renderer.isVML = true;
			renderer.box = box;
			renderer.boxWrapper = boxWrapper;
			renderer.cache = {};


			renderer.setSize(width, height, false);

			// The only way to make IE6 and IE7 print is to use a global namespace. However,
			// with IE8 the only way to make the dynamic shapes visible in screen and print mode
			// seems to be to add the xmlns attribute and the behaviour style inline.
			if (!doc.namespaces.hcv) {

				doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

				// Setup default CSS (#2153, #2368, #2384)
				css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
					'{ behavior:url(#default#VML); display: inline-block; } ';
				try {
					doc.createStyleSheet().cssText = css;
				} catch (e) {
					doc.styleSheets[0].cssText += css;
				}

			}
		},


		/**
		 * Detect whether the renderer is hidden. This happens when one of the parent elements
		 * has display: none
		 */
		isHidden: function () {
			return !this.box.offsetWidth;
		},

		/**
		 * Define a clipping rectangle. In VML it is accomplished by storing the values
		 * for setting the CSS style to all associated members.
		 *
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		clipRect: function (x, y, width, height) {

			// create a dummy element
			var clipRect = this.createElement(),
				isObj = isObject(x);

			// mimic a rectangle with its style object for automatic updating in attr
			return extend(clipRect, {
				members: [],
				count: 0,
				left: (isObj ? x.x : x) + 1,
				top: (isObj ? x.y : y) + 1,
				width: (isObj ? x.width : width) - 1,
				height: (isObj ? x.height : height) - 1,
				getCSS: function (wrapper) {
					var element = wrapper.element,
						nodeName = element.nodeName,
						isShape = nodeName === 'shape',
						inverted = wrapper.inverted,
						rect = this,
						top = rect.top - (isShape ? element.offsetTop : 0),
						left = rect.left,
						right = left + rect.width,
						bottom = top + rect.height,
						ret = {
							clip: 'rect(' +
								mathRound(inverted ? left : top) + 'px,' +
								mathRound(inverted ? bottom : right) + 'px,' +
								mathRound(inverted ? right : bottom) + 'px,' +
								mathRound(inverted ? top : left) + 'px)'
						};

					// issue 74 workaround
					if (!inverted && docMode8 && nodeName === 'DIV') {
						extend(ret, {
							width: right + PX,
							height: bottom + PX
						});
					}
					return ret;
				},

				// used in attr and animation to update the clipping of all members
				updateClipping: function () {
					each(clipRect.members, function (member) {
						if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
							member.css(clipRect.getCSS(member));
						}
					});
				}
			});

		},


		/**
		 * Take a color and return it if it's a string, make it a gradient if it's a
		 * gradient configuration object, and apply opacity.
		 *
		 * @param {Object} color The color or config object
		 */
		color: function (color, elem, prop, wrapper) {
			var renderer = this,
				colorObject,
				regexRgba = /^rgba/,
				markup,
				fillType,
				ret = NONE;

			// Check for linear or radial gradient
			if (color && color.linearGradient) {
				fillType = 'gradient';
			} else if (color && color.radialGradient) {
				fillType = 'pattern';
			}


			if (fillType) {

				var stopColor,
					stopOpacity,
					gradient = color.linearGradient || color.radialGradient,
					x1,
					y1,
					x2,
					y2,
					opacity1,
					opacity2,
					color1,
					color2,
					fillAttr = '',
					stops = color.stops,
					firstStop,
					lastStop,
					colors = [],
					addFillNode = function () {
						// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
						// are reversed.
						markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
							'" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
						createElement(renderer.prepVML(markup), null, null, elem);
					};

				// Extend from 0 to 1
				firstStop = stops[0];
				lastStop = stops[stops.length - 1];
				if (firstStop[0] > 0) {
					stops.unshift([
						0,
						firstStop[1]
					]);
				}
				if (lastStop[0] < 1) {
					stops.push([
						1,
						lastStop[1]
					]);
				}

				// Compute the stops
				each(stops, function (stop, i) {
					if (regexRgba.test(stop[1])) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}

					// Build the color attribute
					colors.push((stop[0] * 100) + '% ' + stopColor);

					// Only start and end opacities are allowed, so we use the first and the last
					if (!i) {
						opacity1 = stopOpacity;
						color2 = stopColor;
					} else {
						opacity2 = stopOpacity;
						color1 = stopColor;
					}
				});

				// Apply the gradient to fills only.
				if (prop === 'fill') {

					// Handle linear gradient angle
					if (fillType === 'gradient') {
						x1 = gradient.x1 || gradient[0] || 0;
						y1 = gradient.y1 || gradient[1] || 0;
						x2 = gradient.x2 || gradient[2] || 0;
						y2 = gradient.y2 || gradient[3] || 0;
						fillAttr = 'angle="' + (90  - math.atan(
							(y2 - y1) / // y vector
							(x2 - x1) // x vector
							) * 180 / mathPI) + '"';

						addFillNode();

					// Radial (circular) gradient
					} else {

						var r = gradient.r,
							sizex = r * 2,
							sizey = r * 2,
							cx = gradient.cx,
							cy = gradient.cy,
							radialReference = elem.radialReference,
							bBox,
							applyRadialGradient = function () {
								if (radialReference) {
									bBox = wrapper.getBBox();
									cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
									cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
									sizex *= radialReference[2] / bBox.width;
									sizey *= radialReference[2] / bBox.height;
								}
								fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
									'size="' + sizex + ',' + sizey + '" ' +
									'origin="0.5,0.5" ' +
									'position="' + cx + ',' + cy + '" ' +
									'color2="' + color2 + '" ';

								addFillNode();
							};

						// Apply radial gradient
						if (wrapper.added) {
							applyRadialGradient();
						} else {
							// We need to know the bounding box to get the size and position right
							wrapper.onAdd = applyRadialGradient;
						}

						// The fill element's color attribute is broken in IE8 standards mode, so we
						// need to set the parent shape's fillcolor attribute instead.
						ret = color1;
					}

				// Gradients are not supported for VML stroke, return the first color. #722.
				} else {
					ret = stopColor;
				}

			// if the color is an rgba color, split it and add a fill node
			// to hold the opacity component
			} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

				colorObject = Color(color);

				markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
				createElement(this.prepVML(markup), null, null, elem);

				ret = colorObject.get('rgb');


			} else {
				var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
				if (propNodes.length) {
					propNodes[0].opacity = 1;
					propNodes[0].type = 'solid';
				}
				ret = color;
			}

			return ret;
		},

		/**
		 * Take a VML string and prepare it for either IE8 or IE6/IE7.
		 * @param {Array} markup A string array of the VML markup to prepare
		 */
		prepVML: function (markup) {
			var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
				isIE8 = this.isIE8;

			markup = markup.join('');

			if (isIE8) { // add xmlns and style inline
				markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
				if (markup.indexOf('style="') === -1) {
					markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
				} else {
					markup = markup.replace('style="', 'style="' + vmlStyle);
				}

			} else { // add namespace
				markup = markup.replace('<', '<hcv:');
			}

			return markup;
		},

		/**
		 * Create rotated and aligned text
		 * @param {String} str
		 * @param {Number} x
		 * @param {Number} y
		 */
		text: SVGRenderer.prototype.html,

		/**
		 * Create and return a path element
		 * @param {Array} path
		 */
		path: function (path) {
			var attr = {
				// subpixel precision down to 0.1 (width and height = 1px)
				coordsize: '10 10'
			};
			if (isArray(path)) {
				attr.d = path;
			} else if (isObject(path)) { // attributes
				extend(attr, path);
			}
			// create the shape
			return this.createElement('shape').attr(attr);
		},

		/**
		 * Create and return a circle element. In VML circles are implemented as
		 * shapes, which is faster than v:oval
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} r
		 */
		circle: function (x, y, r) {
			var circle = this.symbol('circle');
			if (isObject(x)) {
				r = x.r;
				y = x.y;
				x = x.x;
			}
			circle.isCircle = true; // Causes x and y to mean center (#1682)
			circle.r = r;
			return circle.attr({ x: x, y: y });
		},

		/**
		 * Create a group using an outer div and an inner v:group to allow rotating
		 * and flipping. A simple v:group would have problems with positioning
		 * child HTML elements and CSS clip.
		 *
		 * @param {String} name The name of the group
		 */
		g: function (name) {
			var wrapper,
				attribs;

			// set the class name
			if (name) {
				attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
			}

			// the div to hold HTML and clipping
			wrapper = this.createElement(DIV).attr(attribs);

			return wrapper;
		},

		/**
		 * VML override to create a regular HTML image
		 * @param {String} src
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} width
		 * @param {Number} height
		 */
		image: function (src, x, y, width, height) {
			var obj = this.createElement('img')
				.attr({ src: src });

			if (arguments.length > 1) {
				obj.attr({
					x: x,
					y: y,
					width: width,
					height: height
				});
			}
			return obj;
		},

		/**
		 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
		 */
		createElement: function (nodeName) {
			return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);	
		},

		/**
		 * In the VML renderer, each child of an inverted div (group) is inverted
		 * @param {Object} element
		 * @param {Object} parentNode
		 */
		invertChild: function (element, parentNode) {
			var ren = this,
				parentStyle = parentNode.style,
				imgStyle = element.tagName === 'IMG' && element.style; // #1111

			css(element, {
				flip: 'x',
				left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
				top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
				rotation: -90
			});

			// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
			each(element.childNodes, function (child) {
				ren.invertChild(child, element);
			});
		},

		/**
		 * Symbol definitions that override the parent SVG renderer's symbols
		 *
		 */
		symbols: {
			// VML specific arc function
			arc: function (x, y, w, h, options) {
				var start = options.start,
					end = options.end,
					radius = options.r || w || h,
					innerRadius = options.innerR,
					cosStart = mathCos(start),
					sinStart = mathSin(start),
					cosEnd = mathCos(end),
					sinEnd = mathSin(end),
					ret;

				if (end - start === 0) { // no angle, don't show it.
					return ['x'];
				}

				ret = [
					'wa', // clockwise arc to
					x - radius, // left
					y - radius, // top
					x + radius, // right
					y + radius, // bottom
					x + radius * cosStart, // start x
					y + radius * sinStart, // start y
					x + radius * cosEnd, // end x
					y + radius * sinEnd  // end y
				];

				if (options.open && !innerRadius) {
					ret.push(
						'e',
						M,
						x,// - innerRadius,
						y// - innerRadius
					);
				}

				ret.push(
					'at', // anti clockwise arc to
					x - innerRadius, // left
					y - innerRadius, // top
					x + innerRadius, // right
					y + innerRadius, // bottom
					x + innerRadius * cosEnd, // start x
					y + innerRadius * sinEnd, // start y
					x + innerRadius * cosStart, // end x
					y + innerRadius * sinStart, // end y
					'x', // finish path
					'e' // close
				);

				ret.isArc = true;
				return ret;

			},
			// Add circle symbol path. This performs significantly faster than v:oval.
			circle: function (x, y, w, h, wrapper) {

				if (wrapper) {
					w = h = 2 * wrapper.r;
				}

				// Center correction, #1682
				if (wrapper && wrapper.isCircle) {
					x -= w / 2;
					y -= h / 2;
				}

				// Return the path
				return [
					'wa', // clockwisearcto
					x, // left
					y, // top
					x + w, // right
					y + h, // bottom
					x + w, // start x
					y + h / 2,     // start y
					x + w, // end x
					y + h / 2,     // end y
					//'x', // finish path
					'e' // close
				];
			},
			/**
			 * Add rectangle symbol path which eases rotation and omits arcsize problems
			 * compared to the built-in VML roundrect shape. When borders are not rounded,
			 * use the simpler square path, else use the callout path without the arrow.
			 */
			rect: function (x, y, w, h, options) {
				return SVGRenderer.prototype.symbols[
					!defined(options) || !options.r ? 'square' : 'callout'
				].call(0, x, y, w, h, options);
			}
		}
	};
	Highcharts.VMLRenderer = VMLRenderer = function () {
		this.init.apply(this, arguments);
	};
	VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

		// general renderer
		Renderer = VMLRenderer;
	}

	// This method is used with exporting in old IE, when emulating SVG (see #2314)
	SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
		var measuringSpan = doc.createElement('span'),
			offsetWidth,
		textNode = doc.createTextNode(text);

		measuringSpan.appendChild(textNode);
		css(measuringSpan, styles);
		this.box.appendChild(measuringSpan);
		offsetWidth = measuringSpan.offsetWidth;
		discardElement(measuringSpan); // #2463
		return offsetWidth;
	};


	/* ****************************************************************************
	 *                                                                            *
	 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
	 *                                                                            *
	 *****************************************************************************/
	/* ****************************************************************************
	 *                                                                            *
	 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
	 * TARGETING THAT SYSTEM.                                                     *
	 *                                                                            *
	 *****************************************************************************/
	var CanVGRenderer,
		CanVGController;

	if (useCanVG) {
		/**
		 * The CanVGRenderer is empty from start to keep the source footprint small.
		 * When requested, the CanVGController downloads the rest of the source packaged
		 * together with the canvg library.
		 */
		Highcharts.CanVGRenderer = CanVGRenderer = function () {
			// Override the global SVG namespace to fake SVG/HTML that accepts CSS
			SVG_NS = 'http://www.w3.org/1999/xhtml';
		};

		/**
		 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
		 * the implementation from SvgRenderer will not be merged in until first render.
		 */
		CanVGRenderer.prototype.symbols = {};

		/**
		 * Handles on demand download of canvg rendering support.
		 */
		CanVGController = (function () {
			// List of renderering calls
			var deferredRenderCalls = [];

			/**
			 * When downloaded, we are ready to draw deferred charts.
			 */
			function drawDeferred() {
				var callLength = deferredRenderCalls.length,
					callIndex;

				// Draw all pending render calls
				for (callIndex = 0; callIndex < callLength; callIndex++) {
					deferredRenderCalls[callIndex]();
				}
				// Clear the list
				deferredRenderCalls = [];
			}

			return {
				push: function (func, scriptLocation) {
					// Only get the script once
					if (deferredRenderCalls.length === 0) {
						getScript(scriptLocation, drawDeferred);
					}
					// Register render call
					deferredRenderCalls.push(func);
				}
			};
		}());

		Renderer = CanVGRenderer;
	} // end CanVGRenderer

	/* ****************************************************************************
	 *                                                                            *
	 * END OF ANDROID < 3 SPECIFIC CODE                                           *
	 *                                                                            *
	 *****************************************************************************/

	/**
	 * The Tick class
	 */
	function Tick(axis, pos, type, noLabel) {
		this.axis = axis;
		this.pos = pos;
		this.type = type || '';
		this.isNew = true;

		if (!type && !noLabel) {
			this.addLabel();
		}
	}

	Tick.prototype = {
		/**
		 * Write the tick label
		 */
		addLabel: function () {
			var tick = this,
				axis = tick.axis,
				options = axis.options,
				chart = axis.chart,
				categories = axis.categories,
				names = axis.names,
				pos = tick.pos,
				labelOptions = options.labels,
				str,
				tickPositions = axis.tickPositions,
				isFirst = pos === tickPositions[0],
				isLast = pos === tickPositions[tickPositions.length - 1],
				value = categories ?
					pick(categories[pos], names[pos], pos) :
					pos,
				label = tick.label,
				tickPositionInfo = tickPositions.info,
				dateTimeLabelFormat;

			// Set the datetime label format. If a higher rank is set for this position, use that. If not,
			// use the general format.
			if (axis.isDatetimeAxis && tickPositionInfo) {
				dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
			}
			// set properties for access in render method
			tick.isFirst = isFirst;
			tick.isLast = isLast;

			// get the string
			str = axis.labelFormatter.call({
				axis: axis,
				chart: chart,
				isFirst: isFirst,
				isLast: isLast,
				dateTimeLabelFormat: dateTimeLabelFormat,
				value: axis.isLog ? correctFloat(lin2log(value)) : value
			});

			// prepare CSS
			//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
			
			// first call
			if (!defined(label)) {

				tick.label = label =
					defined(str) && labelOptions.enabled ?
						chart.renderer.text(
								str,
								0,
								0,
								labelOptions.useHTML
							)
							//.attr(attr)
							// without position absolute, IE export sometimes is wrong
							.css(merge(labelOptions.style))
							.add(axis.labelGroup) :
						null;
				tick.labelLength = label && label.getBBox().width; // Un-rotated length
				tick.rotation = 0; // Base value to detect change for new calls to getBBox

			// update
			} else if (label) {
				label.attr({ text: str });
			}
		},

		/**
		 * Get the offset height or width of the label
		 */
		getLabelSize: function () {
			return this.label ?
				this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
				0;
		},

		/**
		 * Handle the label overflow by adjusting the labels to the left and right edge, or
		 * hide them if they collide into the neighbour label.
		 */
		handleOverflow: function (xy) {
			var axis = this.axis,
				pxPos = xy.x,
				chartWidth = axis.chart.chartWidth,
				spacing = axis.chart.spacing,
				leftBound = pick(axis.labelLeft, spacing[3]),
				rightBound = pick(axis.labelRight, chartWidth - spacing[1]),
				label = this.label,
				rotation = this.rotation,
				factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
				labelWidth = label.getBBox().width,
				slotWidth = axis.slotWidth,
				leftPos,
				rightPos,
				textWidth;

			// Check if the label overshoots the chart spacing box. If it does, move it.
			// If it now overshoots the slotWidth, add ellipsis.
			if (!rotation) {
				leftPos = pxPos - factor * labelWidth;
				rightPos = pxPos + factor * labelWidth;

				if (leftPos < leftBound) {
					slotWidth -= leftBound - leftPos;
					xy.x = leftBound;
					label.attr({ align: 'left' });				
				} else if (rightPos > rightBound) {
					slotWidth -= rightPos - rightBound;
					xy.x = rightBound;
					label.attr({ align: 'right' });
				}

				if (labelWidth > slotWidth) {
					textWidth = slotWidth;
				}
			

			// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
			} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
				textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
			} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
				textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
			}

			if (textWidth) {
				label.css({
					width: textWidth,
					textOverflow: 'ellipsis'
				});
			}
		},

		/**
		 * Get the x and y position for ticks and labels
		 */
		getPosition: function (horiz, pos, tickmarkOffset, old) {
			var axis = this.axis,
				chart = axis.chart,
				cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

			return {
				x: horiz ?
					axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
					axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

				y: horiz ?
					cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
					cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
			};

		},

		/**
		 * Get the x, y position of the tick label
		 */
		getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
			var axis = this.axis,
				transA = axis.transA,
				reversed = axis.reversed,
				staggerLines = axis.staggerLines,
				rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
				yOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),
				line;

			x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
				tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
			y = y + yOffset - (tickmarkOffset && !horiz ?
				tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

			// Correct for staggered labels
			if (staggerLines) {
				line = (index / (step || 1) % staggerLines);
				y += line * (axis.labelOffset / staggerLines);
			}

			return {
				x: x,
				y: mathRound(y)
			};
		},

		/**
		 * Extendible method to return the path of the marker
		 */
		getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
			return renderer.crispLine([
					M,
					x,
					y,
					L,
					x + (horiz ? 0 : -tickLength),
					y + (horiz ? tickLength : 0)
				], tickWidth);
		},

		/**
		 * Put everything in place
		 *
		 * @param index {Number}
		 * @param old {Boolean} Use old coordinates to prepare an animation into new position
		 */
		render: function (index, old, opacity) {
			var tick = this,
				axis = tick.axis,
				options = axis.options,
				chart = axis.chart,
				renderer = chart.renderer,
				horiz = axis.horiz,
				type = tick.type,
				label = tick.label,
				pos = tick.pos,
				labelOptions = options.labels,
				gridLine = tick.gridLine,
				gridPrefix = type ? type + 'Grid' : 'grid',
				tickPrefix = type ? type + 'Tick' : 'tick',
				gridLineWidth = options[gridPrefix + 'LineWidth'],
				gridLineColor = options[gridPrefix + 'LineColor'],
				dashStyle = options[gridPrefix + 'LineDashStyle'],
				tickLength = options[tickPrefix + 'Length'],
				tickWidth = options[tickPrefix + 'Width'] || 0,
				tickColor = options[tickPrefix + 'Color'],
				tickPosition = options[tickPrefix + 'Position'],
				gridLinePath,
				mark = tick.mark,
				markPath,
				step = /*axis.labelStep || */labelOptions.step,
				attribs,
				show = true,
				tickmarkOffset = axis.tickmarkOffset,
				xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
				x = xy.x,
				y = xy.y,
				reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

			opacity = pick(opacity, 1);
			this.isActive = true;

			// create the grid line
			if (gridLineWidth) {
				gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

				if (gridLine === UNDEFINED) {
					attribs = {
						stroke: gridLineColor,
						'stroke-width': gridLineWidth
					};
					if (dashStyle) {
						attribs.dashstyle = dashStyle;
					}
					if (!type) {
						attribs.zIndex = 1;
					}
					if (old) {
						attribs.opacity = 0;
					}
					tick.gridLine = gridLine =
						gridLineWidth ?
							renderer.path(gridLinePath)
								.attr(attribs).add(axis.gridGroup) :
							null;
				}

				// If the parameter 'old' is set, the current call will be followed
				// by another call, therefore do not do any animations this time
				if (!old && gridLine && gridLinePath) {
					gridLine[tick.isNew ? 'attr' : 'animate']({
						d: gridLinePath,
						opacity: opacity
					});
				}
			}

			// create the tick mark
			if (tickWidth && tickLength) {

				// negate the length
				if (tickPosition === 'inside') {
					tickLength = -tickLength;
				}
				if (axis.opposite) {
					tickLength = -tickLength;
				}

				markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
				if (mark) { // updating
					mark.animate({
						d: markPath,
						opacity: opacity
					});
				} else { // first time
					tick.mark = renderer.path(
						markPath
					).attr({
						stroke: tickColor,
						'stroke-width': tickWidth,
						opacity: opacity
					}).add(axis.axisGroup);
				}
			}

			// the label is created on init - now move it into place
			if (label && !isNaN(x)) {
				label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

				// Apply show first and show last. If the tick is both first and last, it is
				// a single centered tick, in which case we show the label anyway (#2100).
				if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
						(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
					show = false;

				// Handle label overflow and show or hide accordingly
				} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
					tick.handleOverflow(xy);
				}

				// apply step
				if (step && index % step) {
					// show those indices dividable by step
					show = false;
				}

				// Set the new position, and show or hide
				if (show && !isNaN(xy.y)) {
					xy.opacity = opacity;
					label[tick.isNew ? 'attr' : 'animate'](xy);
					tick.isNew = false;
				} else {
					label.attr('y', -9999); // #1338
				}
			}
		},

		/**
		 * Destructor for the tick prototype
		 */
		destroy: function () {
			destroyObjectProperties(this, this.axis);
		}
	};

	/**
	 * The object wrapper for plot lines and plot bands
	 * @param {Object} options
	 */
	Highcharts.PlotLineOrBand = function (axis, options) {
		this.axis = axis;

		if (options) {
			this.options = options;
			this.id = options.id;
		}
	};

	Highcharts.PlotLineOrBand.prototype = {
		
		/**
		 * Render the plot line or plot band. If it is already existing,
		 * move it.
		 */
		render: function () {
			var plotLine = this,
				axis = plotLine.axis,
				horiz = axis.horiz,
				options = plotLine.options,
				optionsLabel = options.label,
				label = plotLine.label,
				width = options.width,
				to = options.to,
				from = options.from,
				isBand = defined(from) && defined(to),
				value = options.value,
				dashStyle = options.dashStyle,
				svgElem = plotLine.svgElem,
				path = [],
				addEvent,
				eventType,
				xs,
				ys,
				x,
				y,
				color = options.color,
				zIndex = options.zIndex,
				events = options.events,
				attribs = {},
				renderer = axis.chart.renderer;

			// logarithmic conversion
			if (axis.isLog) {
				from = log2lin(from);
				to = log2lin(to);
				value = log2lin(value);
			}

			// plot line
			if (width) {
				path = axis.getPlotLinePath(value, width);
				attribs = {
					stroke: color,
					'stroke-width': width
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
			} else if (isBand) { // plot band

				path = axis.getPlotBandPath(from, to, options);
				if (color) {
					attribs.fill = color;
				}
				if (options.borderWidth) {
					attribs.stroke = options.borderColor;
					attribs['stroke-width'] = options.borderWidth;
				}
			} else {
				return;
			}
			// zIndex
			if (defined(zIndex)) {
				attribs.zIndex = zIndex;
			}

			// common for lines and bands
			if (svgElem) {
				if (path) {
					svgElem.animate({
						d: path
					}, null, svgElem.onGetPath);
				} else {
					svgElem.hide();
					svgElem.onGetPath = function () {
						svgElem.show();
					};
					if (label) {
						plotLine.label = label = label.destroy();
					}
				}
			} else if (path && path.length) {
				plotLine.svgElem = svgElem = renderer.path(path)
					.attr(attribs).add();

				// events
				if (events) {
					addEvent = function (eventType) {
						svgElem.on(eventType, function (e) {
							events[eventType].apply(plotLine, [e]);
						});
					};
					for (eventType in events) {
						addEvent(eventType);
					}
				}
			}

			// the plot band/line label
			if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
				// apply defaults
				optionsLabel = merge({
					align: horiz && isBand && 'center',
					x: horiz ? !isBand && 4 : 10,
					verticalAlign : !horiz && isBand && 'middle',
					y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
					rotation: horiz && !isBand && 90
				}, optionsLabel);

				// add the SVG element
				if (!label) {
					attribs = {
						align: optionsLabel.textAlign || optionsLabel.align,
						rotation: optionsLabel.rotation
					};
					if (defined(zIndex)) {
						attribs.zIndex = zIndex;
					}
					plotLine.label = label = renderer.text(
							optionsLabel.text,
							0,
							0,
							optionsLabel.useHTML
						)
						.attr(attribs)
						.css(optionsLabel.style)
						.add();
				}

				// get the bounding box and align the label
				// #3000 changed to better handle choice between plotband or plotline
				xs = [path[1], path[4], (isBand ? path[6] : path[1])];
				ys = [path[2], path[5], (isBand ? path[7] : path[2])];
				x = arrayMin(xs);
				y = arrayMin(ys);

				label.align(optionsLabel, false, {
					x: x,
					y: y,
					width: arrayMax(xs) - x,
					height: arrayMax(ys) - y
				});
				label.show();

			} else if (label) { // move out of sight
				label.hide();
			}

			// chainable
			return plotLine;
		},

		/**
		 * Remove the plot line or band
		 */
		destroy: function () {
			// remove it from the lookup
			erase(this.axis.plotLinesAndBands, this);
			
			delete this.axis;
			destroyObjectProperties(this);
		}
	};

	/**
	 * Object with members for extending the Axis prototype
	 */

	AxisPlotLineOrBandExtension = {

		/**
		 * Create the path for a plot band
		 */ 
		getPlotBandPath: function (from, to) {
			var toPath = this.getPlotLinePath(to, null, null, true),
				path = this.getPlotLinePath(from, null, null, true);

			if (path && toPath && path.toString() !== toPath.toString()) { // #3836
				path.push(
					toPath[4],
					toPath[5],
					toPath[1],
					toPath[2]
				);
			} else { // outside the axis area
				path = null;
			}
			
			return path;
		},

		addPlotBand: function (options) {
			return this.addPlotBandOrLine(options, 'plotBands');
		},
		
		addPlotLine: function (options) {
			return this.addPlotBandOrLine(options, 'plotLines');
		},

		/**
		 * Add a plot band or plot line after render time
		 *
		 * @param options {Object} The plotBand or plotLine configuration object
		 */
		addPlotBandOrLine: function (options, coll) {
			var obj = new Highcharts.PlotLineOrBand(this, options).render(),
				userOptions = this.userOptions;

			if (obj) { // #2189
				// Add it to the user options for exporting and Axis.update
				if (coll) {
					userOptions[coll] = userOptions[coll] || [];
					userOptions[coll].push(options); 
				}
				this.plotLinesAndBands.push(obj); 
			}
			
			return obj;
		},

		/**
		 * Remove a plot band or plot line from the chart by id
		 * @param {Object} id
		 */
		removePlotBandOrLine: function (id) {
			var plotLinesAndBands = this.plotLinesAndBands,
				options = this.options,
				userOptions = this.userOptions,
				i = plotLinesAndBands.length;
			while (i--) {
				if (plotLinesAndBands[i].id === id) {
					plotLinesAndBands[i].destroy();
				}
			}
			each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
				i = arr.length;
				while (i--) {
					if (arr[i].id === id) {
						erase(arr, arr[i]);
					}
				}
			});
		}
	};

	/**
	 * Create a new axis object
	 * @param {Object} chart
	 * @param {Object} options
	 */
	var Axis = Highcharts.Axis = function () {
		this.init.apply(this, arguments);
	};

	Axis.prototype = {

		/**
		 * Default options for the X axis - the Y axis has extended defaults
		 */
		defaultOptions: {
			// allowDecimals: null,
			// alternateGridColor: null,
			// categories: [],
			dateTimeLabelFormats: {
				millisecond: '%H:%M:%S.%L',
				second: '%H:%M:%S',
				minute: '%H:%M',
				hour: '%H:%M',
				day: '%e. %b',
				week: '%e. %b',
				month: '%b \'%y',
				year: '%Y'
			},
			endOnTick: false,
			gridLineColor: '#D8D8D8',
			// gridLineDashStyle: 'solid',
			// gridLineWidth: 0,
			// reversed: false,

			labels: {
				enabled: true,
				// rotation: 0,
				// align: 'center',
				// step: null,
				style: {
					color: '#606060',
					cursor: 'default',
					fontSize: '11px'
				},
				x: 0,
				y: 15
				/*formatter: function () {
					return this.value;
				},*/
			},
			lineColor: '#C0D0E0',
			lineWidth: 1,
			//linkedTo: null,
			//max: undefined,
			//min: undefined,
			minPadding: 0.01,
			maxPadding: 0.01,
			//minRange: null,
			minorGridLineColor: '#E0E0E0',
			// minorGridLineDashStyle: null,
			minorGridLineWidth: 1,
			minorTickColor: '#A0A0A0',
			//minorTickInterval: null,
			minorTickLength: 2,
			minorTickPosition: 'outside', // inside or outside
			//minorTickWidth: 0,
			//opposite: false,
			//offset: 0,
			//plotBands: [{
			//	events: {},
			//	zIndex: 1,
			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
			//}],
			//plotLines: [{
			//	events: {}
			//  dashStyle: {}
			//	zIndex:
			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
			//}],
			//reversed: false,
			// showFirstLabel: true,
			// showLastLabel: true,
			startOfWeek: 1,
			startOnTick: false,
			tickColor: '#C0D0E0',
			//tickInterval: null,
			tickLength: 10,
			tickmarkPlacement: 'between', // on or between
			tickPixelInterval: 100,
			tickPosition: 'outside',
			tickWidth: 1,
			title: {
				//text: null,
				align: 'middle', // low, middle or high
				//margin: 0 for horizontal, 10 for vertical axes,
				//rotation: 0,
				//side: 'outside',
				style: {
					color: '#707070'
				}
				//x: 0,
				//y: 0
			},
			type: 'linear' // linear, logarithmic or datetime
		},

		/**
		 * This options set extends the defaultOptions for Y axes
		 */
		defaultYAxisOptions: {
			endOnTick: true,
			gridLineWidth: 1,
			tickPixelInterval: 72,
			showLastLabel: true,
			labels: {
				x: -8,
				y: 3
			},
			lineWidth: 0,
			maxPadding: 0.05,
			minPadding: 0.05,
			startOnTick: true,
			tickWidth: 0,
			title: {
				rotation: 270,
				text: 'Values'
			},
			stackLabels: {
				enabled: false,
				//align: dynamic,
				//y: dynamic,
				//x: dynamic,
				//verticalAlign: dynamic,
				//textAlign: dynamic,
				//rotation: 0,
				formatter: function () {
					return Highcharts.numberFormat(this.total, -1);
				},
				style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
			}
		},

		/**
		 * These options extend the defaultOptions for left axes
		 */
		defaultLeftAxisOptions: {
			labels: {
				x: -15,
				y: null
			},
			title: {
				rotation: 270
			}
		},

		/**
		 * These options extend the defaultOptions for right axes
		 */
		defaultRightAxisOptions: {
			labels: {
				x: 15,
				y: null
			},
			title: {
				rotation: 90
			}
		},

		/**
		 * These options extend the defaultOptions for bottom axes
		 */
		defaultBottomAxisOptions: {
			labels: {
				autoRotation: [-45],
				x: 0,
				y: null // based on font size
				// overflow: undefined,
				// staggerLines: null
			},
			title: {
				rotation: 0
			}
		},
		/**
		 * These options extend the defaultOptions for top axes
		 */
		defaultTopAxisOptions: {
			labels: {
				autoRotation: [-45],
				x: 0,
				y: -15
				// overflow: undefined
				// staggerLines: null
			},
			title: {
				rotation: 0
			}
		},

		/**
		 * Initialize the axis
		 */
		init: function (chart, userOptions) {


			var isXAxis = userOptions.isX,
				axis = this;

			// Flag, is the axis horizontal
			axis.horiz = chart.inverted ? !isXAxis : isXAxis;

			// Flag, isXAxis
			axis.isXAxis = isXAxis;
			axis.coll = isXAxis ? 'xAxis' : 'yAxis';

			axis.opposite = userOptions.opposite; // needed in setOptions
			axis.side = userOptions.side || (axis.horiz ?
					(axis.opposite ? 0 : 2) : // top : bottom
					(axis.opposite ? 1 : 3));  // right : left

			axis.setOptions(userOptions);


			var options = this.options,
				type = options.type,
				isDatetimeAxis = type === 'datetime';

			axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


			// Flag, stagger lines or not
			axis.userOptions = userOptions;

			//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
			axis.minPixelPadding = 0;
			//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series
			//axis.ignoreMaxPadding = UNDEFINED;

			axis.chart = chart;
			axis.reversed = options.reversed;
			axis.zoomEnabled = options.zoomEnabled !== false;

			// Initial categories
			axis.categories = options.categories || type === 'category';
			axis.names = axis.names || []; // Preserve on update (#3830)

			// Elements
			//axis.axisGroup = UNDEFINED;
			//axis.gridGroup = UNDEFINED;
			//axis.axisTitle = UNDEFINED;
			//axis.axisLine = UNDEFINED;

			// Shorthand types
			axis.isLog = type === 'logarithmic';
			axis.isDatetimeAxis = isDatetimeAxis;

			// Flag, if axis is linked to another axis
			axis.isLinked = defined(options.linkedTo);
			// Linked axis.
			//axis.linkedParent = UNDEFINED;

			// Tick positions
			//axis.tickPositions = UNDEFINED; // array containing predefined positions
			// Tick intervals
			//axis.tickInterval = UNDEFINED;
			//axis.minorTickInterval = UNDEFINED;

			
			// Major ticks
			axis.ticks = {};
			axis.labelEdge = [];
			// Minor ticks
			axis.minorTicks = {};

			// List of plotLines/Bands
			axis.plotLinesAndBands = [];

			// Alternate bands
			axis.alternateBands = {};

			// Axis metrics
			//axis.left = UNDEFINED;
			//axis.top = UNDEFINED;
			//axis.width = UNDEFINED;
			//axis.height = UNDEFINED;
			//axis.bottom = UNDEFINED;
			//axis.right = UNDEFINED;
			//axis.transA = UNDEFINED;
			//axis.transB = UNDEFINED;
			//axis.oldTransA = UNDEFINED;
			axis.len = 0;
			//axis.oldMin = UNDEFINED;
			//axis.oldMax = UNDEFINED;
			//axis.oldUserMin = UNDEFINED;
			//axis.oldUserMax = UNDEFINED;
			//axis.oldAxisLength = UNDEFINED;
			axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
			axis.range = options.range;
			axis.offset = options.offset || 0;


			// Dictionary for stacks
			axis.stacks = {};
			axis.oldStacks = {};
			
			// Min and max in the data
			//axis.dataMin = UNDEFINED,
			//axis.dataMax = UNDEFINED,

			// The axis range
			axis.max = null;
			axis.min = null;

			// User set min and max
			//axis.userMin = UNDEFINED,
			//axis.userMax = UNDEFINED,

			// Crosshair options
			axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
			// Run Axis

			var eventType,
				events = axis.options.events;

			// Register
			if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
				if (isXAxis && !this.isColorAxis) { // #2713
					chart.axes.splice(chart.xAxis.length, 0, axis);
				} else {
					chart.axes.push(axis);
				}

				chart[axis.coll].push(axis);
			}

			axis.series = axis.series || []; // populated by Series

			// inverted charts have reversed xAxes as default
			if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
				axis.reversed = true;
			}

			axis.removePlotBand = axis.removePlotBandOrLine;
			axis.removePlotLine = axis.removePlotBandOrLine;


			// register event listeners
			for (eventType in events) {
				addEvent(axis, eventType, events[eventType]);
			}

			// extend logarithmic axis
			if (axis.isLog) {
				axis.val2lin = log2lin;
				axis.lin2val = lin2log;
			}
		},

		/**
		 * Merge and set options
		 */
		setOptions: function (userOptions) {
			this.options = merge(
				this.defaultOptions,
				this.isXAxis ? {} : this.defaultYAxisOptions,
				[this.defaultTopAxisOptions, this.defaultRightAxisOptions,
					this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
				merge(
					defaultOptions[this.coll], // if set in setOptions (#1053)
					userOptions
				)
			);
		},

		/**
		 * The default label formatter. The context is a special config object for the label.
		 */
		defaultLabelFormatter: function () {
			var axis = this.axis,
				value = this.value,
				categories = axis.categories,
				dateTimeLabelFormat = this.dateTimeLabelFormat,
				numericSymbols = defaultOptions.lang.numericSymbols,
				i = numericSymbols && numericSymbols.length,
				multi,
				ret,
				formatOption = axis.options.labels.format,

				// make sure the same symbol is added for all labels on a linear axis
				numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

			if (formatOption) {
				ret = format(formatOption, this);

			} else if (categories) {
				ret = value;

			} else if (dateTimeLabelFormat) { // datetime axis
				ret = dateFormat(dateTimeLabelFormat, value);

			} else if (i && numericSymbolDetector >= 1000) {
				// Decide whether we should add a numeric symbol like k (thousands) or M (millions).
				// If we are to enable this in tooltip or other places as well, we can move this
				// logic to the numberFormatter and enable it by a parameter.
				while (i-- && ret === UNDEFINED) {
					multi = Math.pow(1000, i + 1);
					if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {
						ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
					}
				}
			}

			if (ret === UNDEFINED) {
				if (mathAbs(value) >= 10000) { // add thousands separators
					ret = Highcharts.numberFormat(value, 0);

				} else { // small numbers
					ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
				}
			}

			return ret;
		},

		/**
		 * Get the minimum and maximum for the series of each axis
		 */
		getSeriesExtremes: function () {
			var axis = this,
				chart = axis.chart;

			axis.hasVisibleSeries = false;

			// Reset properties in case we're redrawing (#3353)
			axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;
			
			if (axis.buildStacks) {
				axis.buildStacks();
			}

			// loop through this axis' series
			each(axis.series, function (series) {

				if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

					var seriesOptions = series.options,
						xData,
						threshold = seriesOptions.threshold,
						seriesDataMin,
						seriesDataMax;

					axis.hasVisibleSeries = true;

					// Validate threshold in logarithmic axes
					if (axis.isLog && threshold <= 0) {
						threshold = null;
					}

					// Get dataMin and dataMax for X axes
					if (axis.isXAxis) {
						xData = series.xData;
						if (xData.length) {
							axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
							axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
						}

					// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
					} else {

						// Get this particular series extremes
						series.getExtremes();
						seriesDataMax = series.dataMax;
						seriesDataMin = series.dataMin;

						// Get the dataMin and dataMax so far. If percentage is used, the min and max are
						// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
						// doesn't have active y data, we continue with nulls
						if (defined(seriesDataMin) && defined(seriesDataMax)) {
							axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
							axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
						}

						// Adjust to threshold
						if (defined(threshold)) {
							if (axis.dataMin >= threshold) {
								axis.dataMin = threshold;
								axis.ignoreMinPadding = true;
							} else if (axis.dataMax < threshold) {
								axis.dataMax = threshold;
								axis.ignoreMaxPadding = true;
							}
						}
					}
				}
			});
		},

		/**
		 * Translate from axis value to pixel position on the chart, or back
		 *
		 */
		translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
			var axis = this,
				sign = 1,
				cvsOffset = 0,
				localA = old ? axis.oldTransA : axis.transA,
				localMin = old ? axis.oldMin : axis.min,
				returnValue,
				minPixelPadding = axis.minPixelPadding,
				doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;

			if (!localA) {
				localA = axis.transA;
			}

			// In vertical axes, the canvas coordinates start from 0 at the top like in
			// SVG.
			if (cvsCoord) {
				sign *= -1; // canvas coordinates inverts the value
				cvsOffset = axis.len;
			}

			// Handle reversed axis
			if (axis.reversed) {
				sign *= -1;
				cvsOffset -= sign * (axis.sector || axis.len);
			}

			// From pixels to value
			if (backwards) { // reverse translation

				val = val * sign + cvsOffset;
				val -= minPixelPadding;
				returnValue = val / localA + localMin; // from chart pixel to value
				if (doPostTranslate) { // log and ordinal axes
					returnValue = axis.lin2val(returnValue);
				}

			// From value to pixels
			} else {
				if (doPostTranslate) { // log and ordinal axes
					val = axis.val2lin(val);
				}
				if (pointPlacement === 'between') {
					pointPlacement = 0.5;
				}
				returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
					(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
			}

			return returnValue;
		},

		/**
		 * Utility method to translate an axis value to pixel position.
		 * @param {Number} value A value in terms of axis units
		 * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
		 *        or just the axis/pane itself.
		 */
		toPixels: function (value, paneCoordinates) {
			return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
		},

		/*
		 * Utility method to translate a pixel position in to an axis value
		 * @param {Number} pixel The pixel value coordinate
		 * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
		 *        axis/pane itself.
		 */
		toValue: function (pixel, paneCoordinates) {
			return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
		},

		/**
		 * Create the path for a plot line that goes from the given value on
		 * this axis, across the plot to the opposite side
		 * @param {Number} value
		 * @param {Number} lineWidth Used for calculation crisp line
		 * @param {Number] old Use old coordinates (for resizing and rescaling)
		 */
		getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
			var axis = this,
				chart = axis.chart,
				axisLeft = axis.left,
				axisTop = axis.top,
				x1,
				y1,
				x2,
				y2,
				cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
				cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
				skip,
				transB = axis.transB,
				/**
				 * Check if x is between a and b. If not, either move to a/b or skip, 
				 * depending on the force parameter.
				 */
				between = function (x, a, b) {
					if (x < a || x > b) {
						if (force) {
							x = mathMin(mathMax(a, x), b);
						} else {
							skip = true;
						}
					}
					return x;
				};

			translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
			x1 = x2 = mathRound(translatedValue + transB);
			y1 = y2 = mathRound(cHeight - translatedValue - transB);

			if (isNaN(translatedValue)) { // no min or max
				skip = true;

			} else if (axis.horiz) {
				y1 = axisTop;
				y2 = cHeight - axis.bottom;
				x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
			} else {
				x1 = axisLeft;
				x2 = cWidth - axis.right;
				y1 = y2 = between(y1, axisTop, axisTop + axis.height);
			}
			return skip && !force ?
				null :
				chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
		},

		/**
		 * Set the tick positions of a linear axis to round values like whole tens or every five.
		 */
		getLinearTickPositions: function (tickInterval, min, max) {
			var pos,
				lastPos,
				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
				tickPositions = [];

			// For single points, add a tick regardless of the relative position (#2662)
			if (min === max && isNumber(min)) {
				return [min];
			}

			// Populate the intermediate values
			pos = roundedMin;
			while (pos <= roundedMax) {

				// Place the tick on the rounded value
				tickPositions.push(pos);

				// Always add the raw tickInterval, not the corrected one.
				pos = correctFloat(pos + tickInterval);

				// If the interval is not big enough in the current min - max range to actually increase
				// the loop variable, we need to break out to prevent endless loop. Issue #619
				if (pos === lastPos) {
					break;
				}

				// Record the last value
				lastPos = pos;
			}
			return tickPositions;
		},

		/**
		 * Return the minor tick positions. For logarithmic axes, reuse the same logic
		 * as for major ticks.
		 */
		getMinorTickPositions: function () {
			var axis = this,
				options = axis.options,
				tickPositions = axis.tickPositions,
				minorTickInterval = axis.minorTickInterval,
				minorTickPositions = [],
				pos,
				i,
				min = axis.min,
				max = axis.max,
				range = max - min,
				len;

			// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
			if (range && range / minorTickInterval < axis.len / 3) { // #3875

				if (axis.isLog) {
					len = tickPositions.length;
					for (i = 1; i < len; i++) {
						minorTickPositions = minorTickPositions.concat(
							axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
						);
					}
				} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
					minorTickPositions = minorTickPositions.concat(
						axis.getTimeTicks(
							axis.normalizeTimeTickInterval(minorTickInterval),
							min,
							max,
							options.startOfWeek
						)
					);
				} else {
					for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
						minorTickPositions.push(pos);
					}
				}
			}

			axis.trimTicks(minorTickPositions); // #3652 #3743
			return minorTickPositions;
		},

		/**
		 * Adjust the min and max for the minimum range. Keep in mind that the series data is
		 * not yet processed, so we don't have information on data cropping and grouping, or
		 * updated axis.pointRange or series.pointRange. The data can't be processed until
		 * we have finally established min and max.
		 */
		adjustForMinRange: function () {
			var axis = this,
				options = axis.options,
				min = axis.min,
				max = axis.max,
				zoomOffset,
				spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
				closestDataRange,
				i,
				distance,
				xData,
				loopLength,
				minArgs,
				maxArgs;

			// Set the automatic minimum range based on the closest point distance
			if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

				if (defined(options.min) || defined(options.max)) {
					axis.minRange = null; // don't do this again

				} else {

					// Find the closest distance between raw data points, as opposed to
					// closestPointRange that applies to processed points (cropped and grouped)
					each(axis.series, function (series) {
						xData = series.xData;
						loopLength = series.xIncrement ? 1 : xData.length - 1;
						for (i = loopLength; i > 0; i--) {
							distance = xData[i] - xData[i - 1];
							if (closestDataRange === UNDEFINED || distance < closestDataRange) {
								closestDataRange = distance;
							}
						}
					});
					axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
				}
			}

			// if minRange is exceeded, adjust
			if (max - min < axis.minRange) {
				var minRange = axis.minRange;
				zoomOffset = (minRange - max + min) / 2;

				// if min and max options have been set, don't go beyond it
				minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
				if (spaceAvailable) { // if space is available, stay within the data range
					minArgs[2] = axis.dataMin;
				}
				min = arrayMax(minArgs);

				maxArgs = [min + minRange, pick(options.max, min + minRange)];
				if (spaceAvailable) { // if space is availabe, stay within the data range
					maxArgs[2] = axis.dataMax;
				}

				max = arrayMin(maxArgs);

				// now if the max is adjusted, adjust the min back
				if (max - min < minRange) {
					minArgs[0] = max - minRange;
					minArgs[1] = pick(options.min, max - minRange);
					min = arrayMax(minArgs);
				}
			}

			// Record modified extremes
			axis.min = min;
			axis.max = max;
		},

		/**
		 * Update translation information
		 */
		setAxisTranslation: function (saveOld) {
			var axis = this,
				range = axis.max - axis.min,
				pointRange = axis.axisPointRange || 0,
				closestPointRange,
				minPointOffset = 0,
				pointRangePadding = 0,
				linkedParent = axis.linkedParent,
				ordinalCorrection,
				hasCategories = !!axis.categories,
				transA = axis.transA,
				isXAxis = axis.isXAxis;

			// Adjust translation for padding. Y axis with categories need to go through the same (#1784).
			if (isXAxis || hasCategories || pointRange) {
				if (linkedParent) {
					minPointOffset = linkedParent.minPointOffset;
					pointRangePadding = linkedParent.pointRangePadding;

				} else {
					each(axis.series, function (series) {
						var seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806
							pointPlacement = series.options.pointPlacement,
							seriesClosestPointRange = series.closestPointRange;

						if (seriesPointRange > range) { // #1446
							seriesPointRange = 0;
						}
						pointRange = mathMax(pointRange, seriesPointRange);

						if (!axis.single) {
							// minPointOffset is the value padding to the left of the axis in order to make
							// room for points with a pointRange, typically columns. When the pointPlacement option
							// is 'between' or 'on', this padding does not apply.
							minPointOffset = mathMax(
								minPointOffset,
								isString(pointPlacement) ? 0 : seriesPointRange / 2
							);

							// Determine the total padding needed to the length of the axis to make room for the
							// pointRange. If the series' pointPlacement is 'on', no padding is added.
							pointRangePadding = mathMax(
								pointRangePadding,
								pointPlacement === 'on' ? 0 : seriesPointRange
							);
						}

						// Set the closestPointRange
						if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
							closestPointRange = defined(closestPointRange) ?
								mathMin(closestPointRange, seriesClosestPointRange) :
								seriesClosestPointRange;
						}
					});
				}

				// Record minPointOffset and pointRangePadding
				ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
				axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
				axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

				// pointRange means the width reserved for each point, like in a column chart
				axis.pointRange = mathMin(pointRange, range);

				// closestPointRange means the closest distance between points. In columns
				// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
				// is some other value
				if (isXAxis) {
					axis.closestPointRange = closestPointRange;
				}
			}

			// Secondary values
			if (saveOld) {
				axis.oldTransA = transA;
			}
			axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
			axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
			axis.minPixelPadding = transA * minPointOffset;
		},

		/**
		 * Set the tick positions to round values and optionally extend the extremes
		 * to the nearest tick
		 */
		setTickInterval: function (secondPass) {
			var axis = this,
				chart = axis.chart,
				options = axis.options,
				isLog = axis.isLog,
				isDatetimeAxis = axis.isDatetimeAxis,
				isXAxis = axis.isXAxis,
				isLinked = axis.isLinked,
				maxPadding = options.maxPadding,
				minPadding = options.minPadding,
				length,
				linkedParentExtremes,
				tickIntervalOption = options.tickInterval,
				minTickInterval,
				tickPixelIntervalOption = options.tickPixelInterval,
				categories = axis.categories;

			if (!isDatetimeAxis && !categories && !isLinked) {
				this.getTickAmount();
			}

			// linked axis gets the extremes from the parent axis
			if (isLinked) {
				axis.linkedParent = chart[axis.coll][options.linkedTo];
				linkedParentExtremes = axis.linkedParent.getExtremes();
				axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
				axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
				if (options.type !== axis.linkedParent.options.type) {
					error(11, 1); // Can't link axes of different type
				}
			} else { // initial min and max from the extreme data values
				axis.min = pick(axis.userMin, options.min, axis.dataMin);
				axis.max = pick(axis.userMax, options.max, axis.dataMax);
			}

			if (isLog) {
				if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
					error(10, 1); // Can't plot negative values on log axis
				}
				axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934
				axis.max = correctFloat(log2lin(axis.max));
			}

			// handle zoomed range
			if (axis.range && defined(axis.max)) {
				axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618
				axis.userMax = axis.max;

				axis.range = null;  // don't use it when running setExtremes
			}

			// Hook for adjusting this.min and this.max. Used by bubble series.
			if (axis.beforePadding) {
				axis.beforePadding();
			}

			// adjust min and max for the minimum range
			axis.adjustForMinRange();

			// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
			// into account, we do this after computing tick interval (#1337).
			if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
				length = axis.max - axis.min;
				if (length) {
					if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
						axis.min -= length * minPadding;
					}
					if (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
						axis.max += length * maxPadding;
					}
				}
			}

			// Stay within floor and ceiling
			if (isNumber(options.floor)) {
				axis.min = mathMax(axis.min, options.floor);
			}
			if (isNumber(options.ceiling)) {
				axis.max = mathMin(axis.max, options.ceiling);
			}

			// get tickInterval
			if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
				axis.tickInterval = 1;
			} else if (isLinked && !tickIntervalOption &&
					tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
				axis.tickInterval = axis.linkedParent.tickInterval;
			} else {
				axis.tickInterval = pick(
					tickIntervalOption,
					this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
					categories ? // for categoried axis, 1 is default, for linear axis use tickPix
						1 :
						// don't let it be more than the data range
						(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
				);
			}

			// Now we're finished detecting min and max, crop and group series data. This
			// is in turn needed in order to find tick positions in ordinal axes.
			if (isXAxis && !secondPass) {
				each(axis.series, function (series) {
					series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
				});
			}

			// set the translation factor used in translate function
			axis.setAxisTranslation(true);

			// hook for ordinal axes and radial axes
			if (axis.beforeSetTickPositions) {
				axis.beforeSetTickPositions();
			}

			// hook for extensions, used in Highstock ordinal axes
			if (axis.postProcessTickInterval) {
				axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
			}

			// In column-like charts, don't cramp in more ticks than there are points (#1943)
			if (axis.pointRange) {
				axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
			}

			// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
			minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
			if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
				axis.tickInterval = minTickInterval;
			}

			// for linear axes, get magnitude and normalize the interval
			if (!isDatetimeAxis && !isLog) { // linear
				if (!tickIntervalOption) {
					axis.tickInterval = normalizeTickInterval(
						axis.tickInterval, 
						null, 
						getMagnitude(axis.tickInterval), 
						// If the tick interval is between 0.5 and 5 and the axis max is in the order of
						// thousands, chances are we are dealing with years. Don't allow decimals. #3363.
						pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
						!!this.tickAmount
					);
				}
			}

			// Prevent ticks from getting so close that we can't draw the labels
			if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
				axis.tickInterval = axis.unsquish();
			}

			this.setTickPositions();
		},

		/**
		 * Now we have computed the normalized tickInterval, get the tick positions
		 */
		setTickPositions: function () {

			var options = this.options,
				tickPositions,
				tickPositionsOption = options.tickPositions,
				tickPositioner = options.tickPositioner,
				startOnTick = options.startOnTick,
				endOnTick = options.endOnTick,
				single;

			// Set the tickmarkOffset
			this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && 
				this.tickInterval === 1) ? 0.5 : 0; // #3202


			// get minorTickInterval
			this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
				this.tickInterval / 5 : options.minorTickInterval;

			// Find the tick positions
			this.tickPositions = tickPositions = options.tickPositions && options.tickPositions.slice(); // Work on a copy (#1565)
			if (!tickPositions) {

				if (this.isDatetimeAxis) {
					tickPositions = this.getTimeTicks(
						this.normalizeTimeTickInterval(this.tickInterval, options.units),
						this.min,
						this.max,
						options.startOfWeek,
						this.ordinalPositions,
						this.closestPointRange,
						true
					);
				} else if (this.isLog) {
					tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
				} else {
					tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
				}

				this.tickPositions = tickPositions;

				// Run the tick positioner callback, that allows modifying auto tick positions.
				if (tickPositioner) {
					tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
					if (tickPositioner) {
						this.tickPositions = tickPositions = tickPositioner;
					}
				}

			}

			if (!this.isLinked) {

				// reset min/max or remove extremes based on start/end on tick
				this.trimTicks(tickPositions, startOnTick, endOnTick);

				// When there is only one point, or all points have the same value on this axis, then min
				// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
				// in order to center the point, but leave it with one tick. #1337.
				if (this.min === this.max && defined(this.min) && !this.tickAmount) {
					// Substract half a unit (#2619, #2846, #2515, #3390)
					single = true;
					this.min -= 0.5;
					this.max += 0.5;
				}
				this.single = single;

				if (!tickPositionsOption && !tickPositioner) {
					this.adjustTickAmount();
				}
			}
		},

		/**
		 * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
		 */
		trimTicks: function (tickPositions, startOnTick, endOnTick) {
			var roundedMin = tickPositions[0],
				roundedMax = tickPositions[tickPositions.length - 1],
				minPointOffset = this.minPointOffset || 0;
				
			if (startOnTick) {
				this.min = roundedMin;
			} else if (this.min - minPointOffset > roundedMin) {
				tickPositions.shift();
			}

			if (endOnTick) {
				this.max = roundedMax;
			} else if (this.max + minPointOffset < roundedMax) {
				tickPositions.pop();
			}

			// If no tick are left, set one tick in the middle (#3195) 
			if (tickPositions.length === 0 && defined(roundedMin)) {
				tickPositions.push((roundedMax + roundedMin) / 2);
			}		
		},

		/**
		 * Set the max ticks of either the x and y axis collection
		 */
		getTickAmount: function () {
			var others = {}, // Whether there is another axis to pair with this one
				hasOther,
				options = this.options,
				tickAmount = options.tickAmount,
				tickPixelInterval = options.tickPixelInterval;

			if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
					!this.isLog && options.startOnTick && options.endOnTick) {
				tickAmount = 2;
			}

			if (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
				// Check if there are multiple axes in the same pane
				each(this.chart[this.coll], function (axis) {
					var options = axis.options,
						horiz = axis.horiz,
						key = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');
					
					if (others[key]) {
						hasOther = true;
					} else {
						others[key] = 1;
					}
				});

				if (hasOther) {
					// Add 1 because 4 tick intervals require 5 ticks (including first and last)
					tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
				}
			}

			// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
			// prevents the axis from adding ticks that are too far away from the data extremes.
			if (tickAmount < 4) {
				this.finalTickAmt = tickAmount;
				tickAmount = 5;
			}
			
			this.tickAmount = tickAmount;
		},

		/**
		 * When using multiple axes, adjust the number of ticks to match the highest
		 * number of ticks in that group
		 */
		adjustTickAmount: function () {
			var tickInterval = this.tickInterval,
				tickPositions = this.tickPositions,
				tickAmount = this.tickAmount,
				finalTickAmt = this.finalTickAmt,
				currentTickAmount = tickPositions && tickPositions.length,
				i,
				len;

			if (currentTickAmount < tickAmount) { // TODO: Check #3411
				while (tickPositions.length < tickAmount) {
					tickPositions.push(correctFloat(
						tickPositions[tickPositions.length - 1] + tickInterval
					));
				}
				this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
				this.max = tickPositions[tickPositions.length - 1];

			// We have too many ticks, run second pass to try to reduce ticks
			} else if (currentTickAmount > tickAmount) {
				this.tickInterval *= 2;
				this.setTickPositions();
			}

			// The finalTickAmt property is set in getTickAmount
			if (defined(finalTickAmt)) {
				i = len = tickPositions.length;
				while (i--) {
					if (
						(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
						(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
					) {
						tickPositions.splice(i, 1);
					}	
				}
				this.finalTickAmt = UNDEFINED;
			}
		},

		/**
		 * Set the scale based on data min and max, user set min and max or options
		 *
		 */
		setScale: function () {
			var axis = this,
				stacks = axis.stacks,
				type,
				i,
				isDirtyData,
				isDirtyAxisLength;

			axis.oldMin = axis.min;
			axis.oldMax = axis.max;
			axis.oldAxisLength = axis.len;

			// set the new axisLength
			axis.setAxisSize();
			//axisLength = horiz ? axisWidth : axisHeight;
			isDirtyAxisLength = axis.len !== axis.oldAxisLength;

			// is there new data?
			each(axis.series, function (series) {
				if (series.isDirtyData || series.isDirty ||
						series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
					isDirtyData = true;
				}
			});

			// do we really need to go through all this?
			if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
				axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {

				// reset stacks
				if (!axis.isXAxis) {
					for (type in stacks) {
						for (i in stacks[type]) {
							stacks[type][i].total = null;
							stacks[type][i].cum = 0;
						}
					}
				}

				axis.forceRedraw = false;

				// get data extremes if needed
				axis.getSeriesExtremes();

				// get fixed positions based on tickInterval
				axis.setTickInterval();

				// record old values to decide whether a rescale is necessary later on (#540)
				axis.oldUserMin = axis.userMin;
				axis.oldUserMax = axis.userMax;

				// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
				if (!axis.isDirty) {
					axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
				}
			} else if (!axis.isXAxis) {
				if (axis.oldStacks) {
					stacks = axis.stacks = axis.oldStacks;
				}

				// reset stacks
				for (type in stacks) {
					for (i in stacks[type]) {
						stacks[type][i].cum = stacks[type][i].total;
					}
				}
			}
		},

		/**
		 * Set the extremes and optionally redraw
		 * @param {Number} newMin
		 * @param {Number} newMax
		 * @param {Boolean} redraw
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 * @param {Object} eventArguments
		 *
		 */
		setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
			var axis = this,
				chart = axis.chart;

			redraw = pick(redraw, true); // defaults to true

			each(axis.series, function (serie) {
				delete serie.kdTree;
			});

			// Extend the arguments with min and max
			eventArguments = extend(eventArguments, {
				min: newMin,
				max: newMax
			});

			// Fire the event
			fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

				axis.userMin = newMin;
				axis.userMax = newMax;
				axis.eventArgs = eventArguments;

				// Mark for running afterSetExtremes
				axis.isDirtyExtremes = true;

				// redraw
				if (redraw) {
					chart.redraw(animation);
				}
			});
		},

		/**
		 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
		 * in stock charts.
		 */
		zoom: function (newMin, newMax) {
			var dataMin = this.dataMin,
				dataMax = this.dataMax,
				options = this.options;

			// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
			if (!this.allowZoomOutside) {
				if (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {
					newMin = UNDEFINED;
				}
				if (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {
					newMax = UNDEFINED;
				}
			}

			// In full view, displaying the reset zoom button is not required
			this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

			// Do it
			this.setExtremes(
				newMin,
				newMax,
				false,
				UNDEFINED,
				{ trigger: 'zoom' }
			);
			return true;
		},

		/**
		 * Update the axis metrics
		 */
		setAxisSize: function () {
			var chart = this.chart,
				options = this.options,
				offsetLeft = options.offsetLeft || 0,
				offsetRight = options.offsetRight || 0,
				horiz = this.horiz,
				width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
				height = pick(options.height, chart.plotHeight),
				top = pick(options.top, chart.plotTop),
				left = pick(options.left, chart.plotLeft + offsetLeft),
				percentRegex = /%$/;

			// Check for percentage based input values
			if (percentRegex.test(height)) {
				height = parseFloat(height) / 100 * chart.plotHeight;
			}
			if (percentRegex.test(top)) {
				top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;
			}

			// Expose basic values to use in Series object and navigator
			this.left = left;
			this.top = top;
			this.width = width;
			this.height = height;
			this.bottom = chart.chartHeight - height - top;
			this.right = chart.chartWidth - width - left;

			// Direction agnostic properties
			this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
			this.pos = horiz ? left : top; // distance from SVG origin
		},

		/**
		 * Get the actual axis extremes
		 */
		getExtremes: function () {
			var axis = this,
				isLog = axis.isLog;

			return {
				min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
				max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
				dataMin: axis.dataMin,
				dataMax: axis.dataMax,
				userMin: axis.userMin,
				userMax: axis.userMax
			};
		},

		/**
		 * Get the zero plane either based on zero or on the min or max value.
		 * Used in bar and area plots
		 */
		getThreshold: function (threshold) {
			var axis = this,
				isLog = axis.isLog;

			var realMin = isLog ? lin2log(axis.min) : axis.min,
				realMax = isLog ? lin2log(axis.max) : axis.max;

			if (realMin > threshold || threshold === null) {
				threshold = realMin;
			} else if (realMax < threshold) {
				threshold = realMax;
			}

			return axis.translate(threshold, 0, 1, 0, 1);
		},

		/**
		 * Compute auto alignment for the axis label based on which side the axis is on
		 * and the given rotation for the label
		 */
		autoLabelAlign: function (rotation) {
			var ret,
				angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

			if (angle > 15 && angle < 165) {
				ret = 'right';
			} else if (angle > 195 && angle < 345) {
				ret = 'left';
			} else {
				ret = 'center';
			}
			return ret;
		},

		/**
		 * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
		 * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. 
		 * On a vertical axis remove ticks and add ellipsis.
		 */
		unsquish: function () {
			var chart = this.chart,
				ticks = this.ticks,
				labelOptions = this.options.labels,
				horiz = this.horiz,
				tickInterval = this.tickInterval,
				newTickInterval = tickInterval,
				slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
				rotation,
				rotationOption = labelOptions.rotation,
				labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
				step,
				bestScore = Number.MAX_VALUE,
				autoRotation,
				// Return the multiple of tickInterval that is needed to avoid collision
				getStep = function (spaceNeeded) {
					var step = spaceNeeded / (slotSize || 1);
					step = step > 1 ? mathCeil(step) : 1;
					return step * tickInterval;
				};
			
			if (horiz) {
				autoRotation = defined(rotationOption) ? 
					[rotationOption] :
					slotSize < 80 && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;

				if (autoRotation) {

					// Loop over the given autoRotation options, and determine which gives the best score. The 
					// best score is that with the lowest number of steps and a rotation closest to horizontal.
					each(autoRotation, function (rot) {
						var score;

						if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891
						
							step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

							score = step + mathAbs(rot / 360);

							if (score < bestScore) {
								bestScore = score;
								rotation = rot;
								newTickInterval = step;
							}
						}
					});
				}

			} else {
				newTickInterval = getStep(labelMetrics.h);
			}

			this.autoRotation = autoRotation;
			this.labelRotation = rotation;

			return newTickInterval;
		},

		renderUnsquish: function () {
			var chart = this.chart,
				renderer = chart.renderer,
				tickPositions = this.tickPositions,
				ticks = this.ticks,
				labelOptions = this.options.labels,
				horiz = this.horiz,
				margin = chart.margin,
				slotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&
					((this.staggerLines || 1) * chart.plotWidth) / tickPositions.length) ||
					(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,
				innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
				attr = {},
				labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
				css,
				labelLength = 0,
				label,
				i,
				pos;

			// Set rotation option unless it is "auto", like in gauges
			if (!isString(labelOptions.rotation)) {
				attr.rotation = labelOptions.rotation;
			}
			
			// Handle auto rotation on horizontal axis
			if (this.autoRotation) {

				// Get the longest label length
				each(tickPositions, function (tick) {
					tick = ticks[tick];
					if (tick && tick.labelLength > labelLength) {
						labelLength = tick.labelLength;
					}
				});
				
				// Apply rotation only if the label is too wide for the slot, and
				// the label is wider than its height.
				if (labelLength > innerWidth && labelLength > labelMetrics.h) {
					attr.rotation = this.labelRotation;
				} else {
					this.labelRotation = 0;
				}

			// Handle word-wrap or ellipsis on vertical axis
			} else if (slotWidth) {
				// For word-wrap or ellipsis
				css = { width: innerWidth + PX, textOverflow: 'clip' };

				// On vertical axis, only allow word wrap if there is room for more lines.
				i = tickPositions.length;
				while (!horiz && i--) {
					pos = tickPositions[i];
					label = ticks[pos].label;
					if (label) {
						if (this.len / tickPositions.length - 4 < label.getBBox().height) {
							label.specCss = { textOverflow: 'ellipsis' };
						}
					}
				}
			}


			// Add ellipsis if the label length is significantly longer than ideal
			if (attr.rotation) {
				css = { 
					width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX,
					textOverflow: 'ellipsis'
				};
			}

			// Set the explicit or automatic label alignment
			this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);

			// Apply general and specific CSS
			each(tickPositions, function (pos) {
				var tick = ticks[pos],
					label = tick && tick.label;
				if (label) {
					if (css) {
						label.css(merge(css, label.specCss));
					}
					delete label.specCss;
					label.attr(attr);
					tick.rotation = attr.rotation;
				}
			});

			// TODO: Why not part of getLabelPosition?
			this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);
		},

		/**
		 * Render the tick labels to a preliminary position to get their sizes
		 */
		getOffset: function () {
			var axis = this,
				chart = axis.chart,
				renderer = chart.renderer,
				options = axis.options,
				tickPositions = axis.tickPositions,
				ticks = axis.ticks,
				horiz = axis.horiz,
				side = axis.side,
				invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
				hasData,
				showAxis,
				titleOffset = 0,
				titleOffsetOption,
				titleMargin = 0,
				axisTitleOptions = options.title,
				labelOptions = options.labels,
				labelOffset = 0, // reset
				labelOffsetPadded,
				axisOffset = chart.axisOffset,
				clipOffset = chart.clipOffset,
				directionFactor = [-1, 1, 1, -1][side],
				n,
				lineHeightCorrection;

			// For reuse in Axis.render
			axis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) && defined(axis.max) && !!tickPositions));
			axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

			// Set/reset staggerLines
			axis.staggerLines = axis.horiz && labelOptions.staggerLines;

			// Create the axisGroup and gridGroup elements on first iteration
			if (!axis.axisGroup) {
				axis.gridGroup = renderer.g('grid')
					.attr({ zIndex: options.gridZIndex || 1 })
					.add();
				axis.axisGroup = renderer.g('axis')
					.attr({ zIndex: options.zIndex || 2 })
					.add();
				axis.labelGroup = renderer.g('axis-labels')
					.attr({ zIndex: labelOptions.zIndex || 7 })
					.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
					.add();
			}

			if (hasData || axis.isLinked) {
				
				// Generate ticks
				each(tickPositions, function (pos) {
					if (!ticks[pos]) {
						ticks[pos] = new Tick(axis, pos);
					} else {
						ticks[pos].addLabel(); // update labels depending on tick interval
					}
				});

				axis.renderUnsquish();

				each(tickPositions, function (pos) {
					// left side must be align: right and right side must have align: left for labels
					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {

						// get the highest offset
						labelOffset = mathMax(
							ticks[pos].getLabelSize(),
							labelOffset
						);
					}
				});

				if (axis.staggerLines) {
					labelOffset *= axis.staggerLines;
					axis.labelOffset = labelOffset;
				}


			} else { // doesn't have data
				for (n in ticks) {
					ticks[n].destroy();
					delete ticks[n];
				}
			}

			if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
				if (!axis.axisTitle) {
					axis.axisTitle = renderer.text(
						axisTitleOptions.text,
						0,
						0,
						axisTitleOptions.useHTML
					)
					.attr({
						zIndex: 7,
						rotation: axisTitleOptions.rotation || 0,
						align:
							axisTitleOptions.textAlign ||
							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
					})
					.addClass(PREFIX + this.coll.toLowerCase() + '-title')
					.css(axisTitleOptions.style)
					.add(axis.axisGroup);
					axis.axisTitle.isNew = true;
				}

				if (showAxis) {
					titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
					titleOffsetOption = axisTitleOptions.offset;
					titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
				}

				// hide or show the title depending on whether showEmpty is set
				axis.axisTitle[showAxis ? 'show' : 'hide']();
			}

			// handle automatic or user set offset
			axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

			axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
			lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;
			labelOffsetPadded = labelOffset + titleMargin +
				(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));
			axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

			axisOffset[side] = mathMax(
				axisOffset[side],
				axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
				labelOffsetPadded // #3027
			);
			clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);
		},

		/**
		 * Get the path for the axis line
		 */
		getLinePath: function (lineWidth) {
			var chart = this.chart,
				opposite = this.opposite,
				offset = this.offset,
				horiz = this.horiz,
				lineLeft = this.left + (opposite ? this.width : 0) + offset,
				lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

			if (opposite) {
				lineWidth *= -1; // crispify the other way - #1480, #1687
			}

			return chart.renderer.crispLine([
					M,
					horiz ?
						this.left :
						lineLeft,
					horiz ?
						lineTop :
						this.top,
					L,
					horiz ?
						chart.chartWidth - this.right :
						lineLeft,
					horiz ?
						lineTop :
						chart.chartHeight - this.bottom
				], lineWidth);
		},

		/**
		 * Position the title
		 */
		getTitlePosition: function () {
			// compute anchor points for each of the title align options
			var horiz = this.horiz,
				axisLeft = this.left,
				axisTop = this.top,
				axisLength = this.len,
				axisTitleOptions = this.options.title,
				margin = horiz ? axisLeft : axisTop,
				opposite = this.opposite,
				offset = this.offset,
				fontSize = pInt(axisTitleOptions.style.fontSize || 12),

				// the position in the length direction of the axis
				alongAxis = {
					low: margin + (horiz ? 0 : axisLength),
					middle: margin + axisLength / 2,
					high: margin + (horiz ? axisLength : 0)
				}[axisTitleOptions.align],

				// the position in the perpendicular direction of the axis
				offAxis = (horiz ? axisTop + this.height : axisLeft) +
					(horiz ? 1 : -1) * // horizontal axis reverses the margin
					(opposite ? -1 : 1) * // so does opposite axes
					this.axisTitleMargin +
					(this.side === 2 ? fontSize : 0);

			return {
				x: horiz ?
					alongAxis :
					offAxis + (opposite ? this.width : 0) + offset +
						(axisTitleOptions.x || 0), // x
				y: horiz ?
					offAxis - (opposite ? this.height : 0) + offset :
					alongAxis + (axisTitleOptions.y || 0) // y
			};
		},

		/**
		 * Render the axis
		 */
		render: function () {
			var axis = this,
				chart = axis.chart,
				renderer = chart.renderer,
				options = axis.options,
				isLog = axis.isLog,
				isLinked = axis.isLinked,
				tickPositions = axis.tickPositions,
				axisTitle = axis.axisTitle,			
				ticks = axis.ticks,
				minorTicks = axis.minorTicks,
				alternateBands = axis.alternateBands,
				stackLabelOptions = options.stackLabels,
				alternateGridColor = options.alternateGridColor,
				tickmarkOffset = axis.tickmarkOffset,
				lineWidth = options.lineWidth,
				linePath,
				hasRendered = chart.hasRendered,
				slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
				hasData = axis.hasData,
				showAxis = axis.showAxis,
				from,
				to;

			// Reset
			axis.labelEdge.length = 0;
			//axis.justifyToPlot = overflow === 'justify';
			axis.overlap = false;

			// Mark all elements inActive before we go over and mark the active ones
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos;
				for (pos in coll) {
					coll[pos].isActive = false;
				}
			});

			// If the series has data draw the ticks. Else only the line and title
			if (hasData || isLinked) {

				// minor ticks
				if (axis.minorTickInterval && !axis.categories) {
					each(axis.getMinorTickPositions(), function (pos) {
						if (!minorTicks[pos]) {
							minorTicks[pos] = new Tick(axis, pos, 'minor');
						}

						// render new ticks in old position
						if (slideInTicks && minorTicks[pos].isNew) {
							minorTicks[pos].render(null, true);
						}

						minorTicks[pos].render(null, false, 1);
					});
				}

				// Major ticks. Pull out the first item and render it last so that
				// we can get the position of the neighbour label. #808.
				if (tickPositions.length) { // #1300
					each(tickPositions, function (pos, i) {

						// linked axes need an extra check to find out if
						if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

							if (!ticks[pos]) {
								ticks[pos] = new Tick(axis, pos);
							}

							// render new ticks in old position
							if (slideInTicks && ticks[pos].isNew) {
								ticks[pos].render(i, true, 0.1);
							}

							ticks[pos].render(i);
						}

					});
					// In a categorized axis, the tick marks are displayed between labels. So
					// we need to add a tick mark and grid line at the left edge of the X axis.
					if (tickmarkOffset && (axis.min === 0 || axis.single)) {
						if (!ticks[-1]) {
							ticks[-1] = new Tick(axis, -1, null, true);
						}
						ticks[-1].render(-1);
					}

				}

				// alternate grid color
				if (alternateGridColor) {
					each(tickPositions, function (pos, i) {
						if (i % 2 === 0 && pos < axis.max) {
							if (!alternateBands[pos]) {
								alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
							}
							from = pos + tickmarkOffset; // #949
							to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
							alternateBands[pos].options = {
								from: isLog ? lin2log(from) : from,
								to: isLog ? lin2log(to) : to,
								color: alternateGridColor
							};
							alternateBands[pos].render();
							alternateBands[pos].isActive = true;
						}
					});
				}

				// custom plot lines and bands
				if (!axis._addedPlotLB) { // only first time
					each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
						axis.addPlotBandOrLine(plotLineOptions);
					});
					axis._addedPlotLB = true;
				}

			} // end if hasData

			// Remove inactive ticks
			each([ticks, minorTicks, alternateBands], function (coll) {
				var pos,
					i,
					forDestruction = [],
					delay = globalAnimation ? globalAnimation.duration || 500 : 0,
					destroyInactiveItems = function () {
						i = forDestruction.length;
						while (i--) {
							// When resizing rapidly, the same items may be destroyed in different timeouts,
							// or the may be reactivated
							if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
								coll[forDestruction[i]].destroy();
								delete coll[forDestruction[i]];
							}
						}

					};

				for (pos in coll) {

					if (!coll[pos].isActive) {
						// Render to zero opacity
						coll[pos].render(pos, false, 0);
						coll[pos].isActive = false;
						forDestruction.push(pos);
					}
				}

				// When the objects are finished fading out, destroy them
				if (coll === alternateBands || !chart.hasRendered || !delay) {
					destroyInactiveItems();
				} else if (delay) {
					setTimeout(destroyInactiveItems, delay);
				}
			});

			// Static items. As the axis group is cleared on subsequent calls
			// to render, these items are added outside the group.
			// axis line
			if (lineWidth) {
				linePath = axis.getLinePath(lineWidth);
				if (!axis.axisLine) {
					axis.axisLine = renderer.path(linePath)
						.attr({
							stroke: options.lineColor,
							'stroke-width': lineWidth,
							zIndex: 7
						})
						.add(axis.axisGroup);
				} else {
					axis.axisLine.animate({ d: linePath });
				}

				// show or hide the line depending on options.showEmpty
				axis.axisLine[showAxis ? 'show' : 'hide']();
			}

			if (axisTitle && showAxis) {

				axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
					axis.getTitlePosition()
				);
				axisTitle.isNew = false;
			}

			// Stacked totals:
			if (stackLabelOptions && stackLabelOptions.enabled) {
				axis.renderStackTotals();
			}
			// End stacked totals

			axis.isDirty = false;
		},

		/**
		 * Redraw the axis to reflect changes in the data or axis extremes
		 */
		redraw: function () {
			
			// render the axis
			this.render();

			// move plot lines and bands
			each(this.plotLinesAndBands, function (plotLine) {
				plotLine.render();
			});

			// mark associated series as dirty and ready for redraw
			each(this.series, function (series) {
				series.isDirty = true;
			});

		},

		/**
		 * Destroys an Axis instance.
		 */
		destroy: function (keepEvents) {
			var axis = this,
				stacks = axis.stacks,
				stackKey,
				plotLinesAndBands = axis.plotLinesAndBands,
				i;

			// Remove the events
			if (!keepEvents) {
				removeEvent(axis);
			}

			// Destroy each stack total
			for (stackKey in stacks) {
				destroyObjectProperties(stacks[stackKey]);

				stacks[stackKey] = null;
			}

			// Destroy collections
			each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
				destroyObjectProperties(coll);
			});
			i = plotLinesAndBands.length;
			while (i--) { // #1975
				plotLinesAndBands[i].destroy();
			}

			// Destroy local variables
			each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {
				if (axis[prop]) {
					axis[prop] = axis[prop].destroy();
				}
			});

			// Destroy crosshair
			if (this.cross) {
				this.cross.destroy();
			}
		},

		/**
		 * Draw the crosshair
		 */
		drawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.

			var path,
				options = this.crosshair,
				animation = options.animation,
				pos,
				attribs,
				categorized;
			
			if (
				// Disabled in options
				!this.crosshair || 
				// Snap
				((defined(point) || !pick(this.crosshair.snap, true)) === false)
			) {
				this.hideCrosshair();
			
			} else {			

				// Get the path
				if (!pick(options.snap, true)) {
					pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
				} else if (defined(point)) {
					/*jslint eqeq: true*/
					pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
					/*jslint eqeq: false*/
				}

				if (this.isRadial) {
					path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
				} else {
					path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
				}

				if (path === null) {
					this.hideCrosshair();
					return;
				}

				// Draw the cross
				if (this.cross) {
					this.cross
						.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);
				} else {
					categorized = this.categories && !this.isRadial;
					attribs = {
						'stroke-width': options.width || (categorized ? this.transA : 1),
						stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
						zIndex: options.zIndex || 2
					};
					if (options.dashStyle) {
						attribs.dashstyle = options.dashStyle;
					}
					this.cross = this.chart.renderer.path(path).attr(attribs).add();
				}

			}

		},

		/**
		 *	Hide the crosshair.
		 */
		hideCrosshair: function () {
			if (this.cross) {
				this.cross.hide();
			}
		}
	}; // end Axis

	extend(Axis.prototype, AxisPlotLineOrBandExtension);

	/**
	 * Set the tick positions to a time unit that makes sense, for example
	 * on the first of each month or on every Monday. Return an array
	 * with the time positions. Used in datetime axes as well as for grouping
	 * data on a datetime axis.
	 *
	 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
	 * @param {Number} min The minimum in axis values
	 * @param {Number} max The maximum in axis values
	 * @param {Number} startOfWeek
	 */
	Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
		var tickPositions = [],
			i,
			higherRanks = {},
			useUTC = defaultOptions.global.useUTC,
			minYear, // used in months and years as a basis for Date.UTC()
			minDate = new Date(min - getTZOffset(min)),
			interval = normalizedInterval.unitRange,
			count = normalizedInterval.count;

		if (defined(min)) { // #1300
			minDate.setMilliseconds(interval >= timeUnits.second ? 0 :
				count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

			if (interval >= timeUnits.second) { // second
				minDate.setSeconds(interval >= timeUnits.minute ? 0 :
					count * mathFloor(minDate.getSeconds() / count));
			}
		
			if (interval >= timeUnits.minute) { // minute
				minDate[setMinutes](interval >= timeUnits.hour ? 0 :
					count * mathFloor(minDate[getMinutes]() / count));
			}
		
			if (interval >= timeUnits.hour) { // hour
				minDate[setHours](interval >= timeUnits.day ? 0 :
					count * mathFloor(minDate[getHours]() / count));
			}
		
			if (interval >= timeUnits.day) { // day
				minDate[setDate](interval >= timeUnits.month ? 1 :
					count * mathFloor(minDate[getDate]() / count));
			}
		
			if (interval >= timeUnits.month) { // month
				minDate[setMonth](interval >= timeUnits.year ? 0 :
					count * mathFloor(minDate[getMonth]() / count));
				minYear = minDate[getFullYear]();
			}
		
			if (interval >= timeUnits.year) { // year
				minYear -= minYear % count;
				minDate[setFullYear](minYear);
			}
		
			// week is a special case that runs outside the hierarchy
			if (interval === timeUnits.week) {
				// get start of current week, independent of count
				minDate[setDate](minDate[getDate]() - minDate[getDay]() +
					pick(startOfWeek, 1));
			}
		
		
			// get tick positions
			i = 1;
			if (timezoneOffset || getTimezoneOffset) {
				minDate = minDate.getTime();
				minDate = new Date(minDate + getTZOffset(minDate));
			}
			minYear = minDate[getFullYear]();
			var time = minDate.getTime(),
				minMonth = minDate[getMonth](),
				minDateDate = minDate[getDate](),
				localTimezoneOffset = (timeUnits.day + 
						(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
					) % timeUnits.day; // #950, #3359
		
			// iterate and add tick positions at appropriate values
			while (time < max) {
				tickPositions.push(time);
		
				// if the interval is years, use Date.UTC to increase years
				if (interval === timeUnits.year) {
					time = makeTime(minYear + i * count, 0);
		
				// if the interval is months, use Date.UTC to increase months
				} else if (interval === timeUnits.month) {
					time = makeTime(minYear, minMonth + i * count);
		
				// if we're using global time, the interval is not fixed as it jumps
				// one hour at the DST crossover
				} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {
					time = makeTime(minYear, minMonth, minDateDate +
						i * count * (interval === timeUnits.day ? 1 : 7));
		
				// else, the interval is fixed and we use simple addition
				} else {
					time += interval * count;
				}
		
				i++;
			}
		
			// push the last time
			tickPositions.push(time);


			// mark new days if the time is dividible by day (#1649, #1760)
			each(grep(tickPositions, function (time) {
				return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
			}), function (time) {
				higherRanks[time] = 'day';
			});
		}


		// record information on the chosen unit - for dynamic label formatter
		tickPositions.info = extend(normalizedInterval, {
			higherRanks: higherRanks,
			totalRange: interval * count
		});

		return tickPositions;
	};

	/**
	 * Get a normalized tick interval for dates. Returns a configuration object with
	 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
	 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
	 * of segments in stock charts, the normalizing logic was extracted in order to 
	 * prevent it for running over again for each segment having the same interval. 
	 * #662, #697.
	 */
	Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
		var units = unitsOption || [[
					'millisecond', // unit name
					[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
				], [
					'second',
					[1, 2, 5, 10, 15, 30]
				], [
					'minute',
					[1, 2, 5, 10, 15, 30]
				], [
					'hour',
					[1, 2, 3, 4, 6, 8, 12]
				], [
					'day',
					[1, 2]
				], [
					'week',
					[1, 2]
				], [
					'month',
					[1, 2, 3, 4, 6]
				], [
					'year',
					null
				]],
			unit = units[units.length - 1], // default unit is years
			interval = timeUnits[unit[0]],
			multiples = unit[1],
			count,
			i;
			
		// loop through the units to find the one that best fits the tickInterval
		for (i = 0; i < units.length; i++) {
			unit = units[i];
			interval = timeUnits[unit[0]];
			multiples = unit[1];


			if (units[i + 1]) {
				// lessThan is in the middle between the highest multiple and the next unit.
				var lessThan = (interval * multiples[multiples.length - 1] +
							timeUnits[units[i + 1][0]]) / 2;

				// break and keep the current unit
				if (tickInterval <= lessThan) {
					break;
				}
			}
		}

		// prevent 2.5 years intervals, though 25, 250 etc. are allowed
		if (interval === timeUnits.year && tickInterval < 5 * interval) {
			multiples = [1, 2, 5];
		}

		// get the count
		count = normalizeTickInterval(
			tickInterval / interval, 
			multiples,
			unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
		);
		
		return {
			unitRange: interval,
			count: count,
			unitName: unit[0]
		};
	};/**
	 * Methods defined on the Axis prototype
	 */

	/**
	 * Set the tick positions of a logarithmic axis
	 */
	Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
		var axis = this,
			options = axis.options,
			axisLength = axis.len,
			// Since we use this method for both major and minor ticks,
			// use a local variable and return the result
			positions = []; 
		
		// Reset
		if (!minor) {
			axis._minorAutoInterval = null;
		}
		
		// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
		if (interval >= 0.5) {
			interval = mathRound(interval);
			positions = axis.getLinearTickPositions(interval, min, max);
			
		// Second case: We need intermediary ticks. For example 
		// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
		} else if (interval >= 0.08) {
			var roundedMin = mathFloor(min),
				intermediate,
				i,
				j,
				len,
				pos,
				lastPos,
				break2;
				
			if (interval > 0.3) {
				intermediate = [1, 2, 4];
			} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 4, 6, 8];
			} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
				intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
			}
			
			for (i = roundedMin; i < max + 1 && !break2; i++) {
				len = intermediate.length;
				for (j = 0; j < len && !break2; j++) {
					pos = log2lin(lin2log(i) * intermediate[j]);
					if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
						positions.push(lastPos);
					}
					
					if (lastPos > max) {
						break2 = true;
					}
					lastPos = pos;
				}
			}
			
		// Third case: We are so deep in between whole logarithmic values that
		// we might as well handle the tick positions like a linear axis. For
		// example 1.01, 1.02, 1.03, 1.04.
		} else {
			var realMin = lin2log(min),
				realMax = lin2log(max),
				tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
				filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
				tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
				totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
			
			interval = pick(
				filteredTickIntervalOption,
				axis._minorAutoInterval,
				(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
			);
			
			interval = normalizeTickInterval(
				interval, 
				null, 
				getMagnitude(interval)
			);
			
			positions = map(axis.getLinearTickPositions(
				interval, 
				realMin,
				realMax	
			), log2lin);
			
			if (!minor) {
				axis._minorAutoInterval = interval / 5;
			}
		}
		
		// Set the axis-level tickInterval variable 
		if (!minor) {
			axis.tickInterval = interval;
		}
		return positions;
	};/**
	 * The tooltip object
	 * @param {Object} chart The chart instance
	 * @param {Object} options Tooltip options
	 */
	var Tooltip = Highcharts.Tooltip = function () {
		this.init.apply(this, arguments);
	};

	Tooltip.prototype = {

		init: function (chart, options) {

			var borderWidth = options.borderWidth,
				style = options.style,
				padding = pInt(style.padding);

			// Save the chart and options
			this.chart = chart;
			this.options = options;

			// Keep track of the current series
			//this.currentSeries = UNDEFINED;

			// List of crosshairs
			this.crosshairs = [];

			// Current values of x and y when animating
			this.now = { x: 0, y: 0 };

			// The tooltip is initially hidden
			this.isHidden = true;


			// create the label		
			this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
				.attr({
					padding: padding,
					fill: options.backgroundColor,
					'stroke-width': borderWidth,
					r: options.borderRadius,
					zIndex: 8
				})
				.css(style)
				.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
				.add()
				.attr({ y: -9999 }); // #2301, #2657

			// When using canVG the shadow shows up as a gray circle
			// even if the tooltip is hidden.
			if (!useCanVG) {
				this.label.shadow(options.shadow);
			}

			// Public property for getting the shared state.
			this.shared = options.shared;
		},

		/**
		 * Destroy the tooltip and its elements.
		 */
		destroy: function () {
			// Destroy and clear local variables
			if (this.label) {
				this.label = this.label.destroy();
			}
			clearTimeout(this.hideTimer);
			clearTimeout(this.tooltipTimeout);
		},

		/**
		 * Provide a soft movement for the tooltip
		 *
		 * @param {Number} x
		 * @param {Number} y
		 * @private
		 */
		move: function (x, y, anchorX, anchorY) {
			var tooltip = this,
				now = tooltip.now,
				animate = tooltip.options.animation !== false && !tooltip.isHidden && 
					// When we get close to the target position, abort animation and land on the right place (#3056)
					(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
				skipAnchor = tooltip.followPointer || tooltip.len > 1;

			// Get intermediate values for animation
			extend(now, {
				x: animate ? (2 * now.x + x) / 3 : x,
				y: animate ? (now.y + y) / 2 : y,
				anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
				anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
			});

			// Move to the intermediate value
			tooltip.label.attr(now);

			
			// Run on next tick of the mouse tracker
			if (animate) {
			
				// Never allow two timeouts
				clearTimeout(this.tooltipTimeout);
				
				// Set the fixed interval ticking for the smooth tooltip
				this.tooltipTimeout = setTimeout(function () {
					// The interval function may still be running during destroy, so check that the chart is really there before calling.
					if (tooltip) {
						tooltip.move(x, y, anchorX, anchorY);
					}
				}, 32);
				
			}
		},

		/**
		 * Hide the tooltip
		 */
		hide: function (delay) {
			var tooltip = this,
				hoverPoints;
			
			clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
			if (!this.isHidden) {
				hoverPoints = this.chart.hoverPoints;

				this.hideTimer = setTimeout(function () {
					tooltip.label.fadeOut();
					tooltip.isHidden = true;
				}, pick(delay, this.options.hideDelay, 500));

				// hide previous hoverPoints and set new
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}

				this.chart.hoverPoints = null;
				this.chart.hoverSeries = null;
			}
		},
		
		/** 
		 * Extendable method to get the anchor position of the tooltip
		 * from a point or set of points
		 */
		getAnchor: function (points, mouseEvent) {
			var ret,
				chart = this.chart,
				inverted = chart.inverted,
				plotTop = chart.plotTop,
				plotLeft = chart.plotLeft,
				plotX = 0,
				plotY = 0,
				yAxis,
				xAxis;
			
			points = splat(points);
			
			// Pie uses a special tooltipPos
			ret = points[0].tooltipPos;
			
			// When tooltip follows mouse, relate the position to the mouse
			if (this.followPointer && mouseEvent) {
				if (mouseEvent.chartX === UNDEFINED) {
					mouseEvent = chart.pointer.normalize(mouseEvent);
				}
				ret = [
					mouseEvent.chartX - chart.plotLeft,
					mouseEvent.chartY - plotTop
				];
			}
			// When shared, use the average position
			if (!ret) {
				each(points, function (point) {
					yAxis = point.series.yAxis;
					xAxis = point.series.xAxis;
					plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); 
					plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
						(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
				});
				
				plotX /= points.length;
				plotY /= points.length;
				
				ret = [
					inverted ? chart.plotWidth - plotY : plotX,
					this.shared && !inverted && points.length > 1 && mouseEvent ? 
						mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
						inverted ? chart.plotHeight - plotX : plotY
				];
			}

			return map(ret, mathRound);
		},
		
		/**
		 * Place the tooltip in a chart without spilling over
		 * and not covering the point it self.
		 */
		getPosition: function (boxWidth, boxHeight, point) {
			
			var chart = this.chart,
				distance = this.distance,
				ret = {},
				h = point.h,
				swapped,
				first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],
				second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],
				// The far side is right or bottom
				preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),
				/**
				 * Handle the preferred dimension. When the preferred dimension is tooltip
				 * on top or bottom of the point, it will look for space there.
				 */
				firstDimension = function (dim, outerSize, innerSize, point) {
					var roomLeft = innerSize < point - distance,
						roomRight = point + distance + innerSize < outerSize,
						alignedLeft = point - distance - innerSize,
						alignedRight = point + distance;

					if (preferFarSide && roomRight) {
						ret[dim] = alignedRight;
					} else if (!preferFarSide && roomLeft) {
						ret[dim] = alignedLeft;
					} else if (roomLeft) {
						ret[dim] = alignedLeft - h < 0 ? alignedLeft : alignedLeft - h;
					} else if (roomRight) {
						ret[dim] = alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h;
					} else {
						return false;
					}
				},
				/**
				 * Handle the secondary dimension. If the preferred dimension is tooltip
				 * on top or bottom of the point, the second dimension is to align the tooltip
				 * above the point, trying to align center but allowing left or right
				 * align within the chart box.
				 */
				secondDimension = function (dim, outerSize, innerSize, point) {
					// Too close to the edge, return false and swap dimensions
					if (point < distance || point > outerSize - distance) {
						return false;
					
					// Align left/top
					} else if (point < innerSize / 2) {
						ret[dim] = 1;
					// Align right/bottom
					} else if (point > outerSize - innerSize / 2) {
						ret[dim] = outerSize - innerSize - 2;
					// Align center
					} else {
						ret[dim] = point - innerSize / 2;
					}
				},
				/**
				 * Swap the dimensions 
				 */
				swap = function (count) {
					var temp = first;
					first = second;
					second = temp;
					swapped = count;
				},
				run = function () {
					if (firstDimension.apply(0, first) !== false) {
						if (secondDimension.apply(0, second) === false && !swapped) {
							swap(true);
							run();
						}
					} else if (!swapped) {
						swap(true);
						run();
					} else {
						ret.x = ret.y = 0;
					}
				};

			// Under these conditions, prefer the tooltip on the side of the point
			if (chart.inverted || this.len > 1) {
				swap();
			}
			run();

			return ret;
		
		},

		/**
		 * In case no user defined formatter is given, this will be used. Note that the context
		 * here is an object holding point, series, x, y etc.
		 */
		defaultFormatter: function (tooltip) {
			var items = this.points || splat(this),
				s;

			// build the header
			s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

			// build the values
			s = s.concat(tooltip.bodyFormatter(items));

			// footer
			s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

			return s.join('');
		},

		/**
		 * Refresh the tooltip's text and position.
		 * @param {Object} point
		 */
		refresh: function (point, mouseEvent) {
			var tooltip = this,
				chart = tooltip.chart,
				label = tooltip.label,
				options = tooltip.options,
				x,
				y,
				anchor,
				textConfig = {},
				text,
				pointConfig = [],
				formatter = options.formatter || tooltip.defaultFormatter,
				hoverPoints = chart.hoverPoints,
				borderColor,
				shared = tooltip.shared,
				currentSeries;
				
			clearTimeout(this.hideTimer);
			
			// get the reference point coordinates (pie charts use tooltipPos)
			tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
			anchor = tooltip.getAnchor(point, mouseEvent);
			x = anchor[0];
			y = anchor[1];

			// shared tooltip, array is sent over
			if (shared && !(point.series && point.series.noSharedTooltip)) {
				
				// hide previous hoverPoints and set new
				
				chart.hoverPoints = point;
				if (hoverPoints) {
					each(hoverPoints, function (point) {
						point.setState();
					});
				}

				each(point, function (item) {
					item.setState(HOVER_STATE);

					pointConfig.push(item.getLabelConfig());
				});

				textConfig = {
					x: point[0].category,
					y: point[0].y
				};
				textConfig.points = pointConfig;
				this.len = pointConfig.length;
				point = point[0];

			// single point tooltip
			} else {
				textConfig = point.getLabelConfig();
			}
			text = formatter.call(textConfig, tooltip);

			// register the current series
			currentSeries = point.series;
			this.distance = pick(currentSeries.tooltipOptions.distance, 16);

			// update the inner HTML
			if (text === false) {
				this.hide();
			} else {

				// show it
				if (tooltip.isHidden) {
					stop(label);
					label.attr('opacity', 1).show();
				}

				// update text
				label.attr({
					text: text
				});

				// set the stroke color of the box
				borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
				label.attr({
					stroke: borderColor
				});
				tooltip.updatePosition({ 
					plotX: x, 
					plotY: y, 
					negative: point.negative, 
					ttBelow: point.ttBelow, 
					h: (point.shapeArgs && point.shapeArgs.height) || 0
				});
			
				this.isHidden = false;
			}
			fireEvent(chart, 'tooltipRefresh', {
					text: text,
					x: x + chart.plotLeft,
					y: y + chart.plotTop,
					borderColor: borderColor
				});
		},
		
		/**
		 * Find the new position and perform the move
		 */
		updatePosition: function (point) {
			var chart = this.chart,
				label = this.label, 
				pos = (this.options.positioner || this.getPosition).call(
					this,
					label.width,
					label.height,
					point
				);

			// do the move
			this.move(
				mathRound(pos.x), 
				mathRound(pos.y), 
				point.plotX + chart.plotLeft, 
				point.plotY + chart.plotTop
			);
		},

		/** 
		 * Get the best X date format based on the closest point range on the axis.
		 */
		getXDateFormat: function (point, options, xAxis) {
			var xDateFormat,
				dateTimeLabelFormats = options.dateTimeLabelFormats,
				closestPointRange = xAxis && xAxis.closestPointRange,
				n,
				blank = '01-01 00:00:00.000',
				strpos = {
					millisecond: 15,
					second: 12,
					minute: 9,
					hour: 6,
					day: 3
				},
				date,
				lastN;

			if (closestPointRange) {
				date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
				for (n in timeUnits) {

					// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
					if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && 
							date.substr(6) === blank.substr(6)) {
						n = 'week';
						break;

					// The first format that is too great for the range
					} else if (timeUnits[n] > closestPointRange) {
						n = lastN;
						break;
					
					// If the point is placed every day at 23:59, we need to show
					// the minutes as well. #2637.
					} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
						break;
					}

					// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
					if (n !== 'week') {
						lastN = n;
					}
				}
				
				if (n) {
					xDateFormat = dateTimeLabelFormats[n];
				}
			} else {
				xDateFormat = dateTimeLabelFormats.day;
			}

			return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
		},

		/**
		 * Format the footer/header of the tooltip
		 * #3397: abstraction to enable formatting of footer and header
		 */
		tooltipFooterHeaderFormatter: function (point, isFooter) {
			var footOrHead = isFooter ? 'footer' : 'header',
				series = point.series,
				tooltipOptions = series.tooltipOptions,
				xDateFormat = tooltipOptions.xDateFormat,
				xAxis = series.xAxis,
				isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),
				formatString = tooltipOptions[footOrHead+'Format'];

			// Guess the best date format based on the closest point distance (#568, #3418)
			if (isDateTime && !xDateFormat) {
				xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);
			}

			// Insert the footer date format if any
			if (isDateTime && xDateFormat) {
				formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
			}

			return format(formatString, {
				point: point,
				series: series
			});
		},

		/**
	     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
	     * abstracting this functionality allows to easily overwrite and extend it. 
		 */
		bodyFormatter: function (items) {
	        return map(items, function (item) {
	            var tooltipOptions = item.series.tooltipOptions;
	            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
	        });
	    }
	    
	};

	var hoverChartIndex;

	// Global flag for touch support
	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED;

	/**
	 * The mouse tracker object. All methods starting with "on" are primary DOM event handlers. 
	 * Subsequent methods should be named differently from what they are doing.
	 * @param {Object} chart The Chart instance
	 * @param {Object} options The root options object
	 */
	var Pointer = Highcharts.Pointer = function (chart, options) {
		this.init(chart, options);
	};

	Pointer.prototype = {
		/**
		 * Initialize Pointer
		 */
		init: function (chart, options) {
			
			var chartOptions = options.chart,
				chartEvents = chartOptions.events,
				zoomType = useCanVG ? '' : chartOptions.zoomType,
				inverted = chart.inverted,
				zoomX,
				zoomY;

			// Store references
			this.options = options;
			this.chart = chart;
			
			// Zoom status
			this.zoomX = zoomX = /x/.test(zoomType);
			this.zoomY = zoomY = /y/.test(zoomType);
			this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
			this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
			this.hasZoom = zoomX || zoomY;

			// Do we need to handle click on a touch device?
			this.runChartClick = chartEvents && !!chartEvents.click;

			this.pinchDown = [];
			this.lastValidTouch = {};

			if (Highcharts.Tooltip && options.tooltip.enabled) {
				chart.tooltip = new Tooltip(chart, options.tooltip);
				this.followTouchMove = pick(options.tooltip.followTouchMove, true);
			}

			this.setDOMEvents();
		}, 

		/**
		 * Add crossbrowser support for chartX and chartY
		 * @param {Object} e The event object in standard browsers
		 */
		normalize: function (e, chartPosition) {
			var chartX,
				chartY,
				ePos;

			// common IE normalizing
			e = e || window.event;

			// Framework specific normalizing (#1165)
			e = washMouseEvent(e);

			// More IE normalizing, needs to go after washMouseEvent
			if (!e.target) {
				e.target = e.srcElement;
			}
			
			// iOS (#2757)
			ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

			// Get mouse position
			if (!chartPosition) {
				this.chartPosition = chartPosition = offset(this.chart.container);
			}

			// chartX and chartY
			if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
				chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
					// for IE10 quirks mode within framesets
				chartY = e.y;
			} else {
				chartX = ePos.pageX - chartPosition.left;
				chartY = ePos.pageY - chartPosition.top;
			}

			return extend(e, {
				chartX: mathRound(chartX),
				chartY: mathRound(chartY)
			});
		},

		/**
		 * Get the click position in terms of axis values.
		 *
		 * @param {Object} e A pointer event
		 */
		getCoordinates: function (e) {
			var coordinates = {
					xAxis: [],
					yAxis: []
				};

			each(this.chart.axes, function (axis) {
				coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
					axis: axis,
					value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
				});
			});
			return coordinates;
		},
		
		/**
		 * With line type charts with a single tracker, get the point closest to the mouse.
		 * Run Point.onMouseOver and display tooltip for the point or points.
		 */
		runPointActions: function (e) {

			var pointer = this,
				chart = pointer.chart,
				series = chart.series,
				tooltip = chart.tooltip,
				shared = tooltip ? tooltip.shared : false,
				followPointer,
				//point,
				//points,
				hoverPoint = chart.hoverPoint,
				hoverSeries = chart.hoverSeries,
				i,
				//j,
				distance = chart.chartWidth,
				rdistance = chart.chartWidth,
				anchor,
				noSharedTooltip,
				kdpoints = [],
				kdpoint,
				kdpointT;

			// For hovering over the empty parts of the plot area (hoverSeries is undefined). 
			// If there is one series with point tracking (combo chart), don't go to nearest neighbour.
			if (!shared && !hoverSeries) {
				for (i = 0; i < series.length; i++) {
					if (series[i].directTouch || !series[i].options.stickyTracking) {
						series = [];
					}
				}
			}

			// Handle shared tooltip or cases where a series is not yet hovered
			if (!(hoverSeries && hoverSeries.noSharedTooltip) && (shared || !hoverSeries)) { // #3821 
				// Find nearest points on all series
				each(series, function (s) {
					// Skip hidden series
					noSharedTooltip = s.noSharedTooltip && shared;
					if (s.visible && !noSharedTooltip && pick(s.options.enableMouseTracking, true)) { // #3821
						kdpointT = s.searchPoint(e); // #3828
						if (kdpointT) {
							kdpoints.push(kdpointT);
						}
					}
				});
				// Find absolute nearest point
				each(kdpoints, function (p) {
					if (p && defined(p.plotX) && defined(p.plotY)) {
						if ((p.dist.distX < distance) || ((p.dist.distX === distance || p.series.kdDimensions > 1) && p.dist.distR < rdistance)) {
							distance = p.dist.distX;
							rdistance = p.dist.distR;
							kdpoint = p;
						}
					}
				});	

			// Handle non-shared tooltips
			} else {
				// If it has a hoverPoint and that series requires direct touch (like columns), use the hoverPoint (#3899).
				// Otherwise, search the k-d tree (like scatter).
				kdpoint = (hoverSeries.directTouch && hoverPoint) || (hoverSeries && hoverSeries.searchPoint(e));
			}

			// Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926
			if (kdpoint && (kdpoint !== hoverPoint || (tooltip && tooltip.isHidden))) {
				// Draw tooltip if necessary
				if (shared && !kdpoint.series.noSharedTooltip) {
					i = kdpoints.length;
					while (i--) {
						if (kdpoints[i].clientX !== kdpoint.clientX || (kdpoints[i].series.noSharedTooltip || false)) {
							kdpoints.splice(i, 1);
						}
					}
					if (kdpoints.length && tooltip) {
						tooltip.refresh(kdpoints, e);
					}

					// do mouseover on all points except the closest
					each(kdpoints, function (point) {
						if (point !== kdpoint) { 
							point.onMouseOver(e);
						}
					});				
					kdpoint.onMouseOver(e); // #3919 do mouseover on the closest point last to ensure it is the hoverpoint
				} else {
					if (tooltip) { 
						tooltip.refresh(kdpoint, e);
					}
					kdpoint.onMouseOver(e); 
				}
			
			// Update positions (regardless of kdpoint or hoverPoint)
			} else {
				followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
				if (tooltip && followPointer && !tooltip.isHidden) {
					anchor = tooltip.getAnchor([{}], e);
					tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });			
				}
			}

			// Start the event listener to pick up the tooltip 
			if (tooltip && !pointer._onDocumentMouseMove) {
				pointer._onDocumentMouseMove = function (e) {
					if (charts[hoverChartIndex]) {
						charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
					}
				};
				addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
			}
			
			// Crosshair
			each(chart.axes, function (axis) {
				axis.drawCrosshair(e, pick(kdpoint, hoverPoint));
			});	
					
		},



		/**
		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
		 * 
		 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
		 */
		reset: function (allowMove, delay) {
			var pointer = this,
				chart = pointer.chart,
				hoverSeries = chart.hoverSeries,
				hoverPoint = chart.hoverPoint,
				tooltip = chart.tooltip,
				tooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;
				
			// Narrow in allowMove
			allowMove = allowMove && tooltip && tooltipPoints;
				
			// Check if the points have moved outside the plot area, #1003		
			if (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {
				allowMove = false;
			}	
			// Just move the tooltip, #349
			if (allowMove) {
				tooltip.refresh(tooltipPoints);
				if (hoverPoint) { // #2500
					hoverPoint.setState(hoverPoint.state, true);
					each(chart.axes, function (axis) {
						if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {
							axis.drawCrosshair(null, allowMove);
						}  else {
							axis.hideCrosshair();
						}
					});
					
				}

			// Full reset
			} else {

				if (hoverPoint) {
					hoverPoint.onMouseOut();
				}

				if (hoverSeries) {
					hoverSeries.onMouseOut();
				}

				if (tooltip) {
					tooltip.hide(delay);
				}

				if (pointer._onDocumentMouseMove) {
					removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
					pointer._onDocumentMouseMove = null;
				}

				// Remove crosshairs
				each(chart.axes, function (axis) {
					axis.hideCrosshair();
				});
				
				pointer.hoverX = null;

			}
		},

		/**
		 * Scale series groups to a certain scale and translation
		 */
		scaleGroups: function (attribs, clip) {

			var chart = this.chart,
				seriesAttribs;

			// Scale each series
			each(chart.series, function (series) {
				seriesAttribs = attribs || series.getPlotBox(); // #1701
				if (series.xAxis && series.xAxis.zoomEnabled) {
					series.group.attr(seriesAttribs);
					if (series.markerGroup) {
						series.markerGroup.attr(seriesAttribs);
						series.markerGroup.clip(clip ? chart.clipRect : null);
					}
					if (series.dataLabelsGroup) {
						series.dataLabelsGroup.attr(seriesAttribs);
					}
				}
			});
			
			// Clip
			chart.clipRect.attr(clip || chart.clipBox);
		},

		/**
		 * Start a drag operation
		 */
		dragStart: function (e) {
			var chart = this.chart;

			// Record the start position
			chart.mouseIsDown = e.type;
			chart.cancelClick = false;
			chart.mouseDownX = this.mouseDownX = e.chartX;
			chart.mouseDownY = this.mouseDownY = e.chartY;
		},

		/**
		 * Perform a drag operation in response to a mousemove event while the mouse is down
		 */
		drag: function (e) {

			var chart = this.chart,
				chartOptions = chart.options.chart,
				chartX = e.chartX,
				chartY = e.chartY,
				zoomHor = this.zoomHor,
				zoomVert = this.zoomVert,
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop,
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				clickedInside,
				size,
				mouseDownX = this.mouseDownX,
				mouseDownY = this.mouseDownY,
				panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

			// If the mouse is outside the plot area, adjust to cooordinates
			// inside to prevent the selection marker from going outside
			if (chartX < plotLeft) {
				chartX = plotLeft;
			} else if (chartX > plotLeft + plotWidth) {
				chartX = plotLeft + plotWidth;
			}

			if (chartY < plotTop) {
				chartY = plotTop;
			} else if (chartY > plotTop + plotHeight) {
				chartY = plotTop + plotHeight;
			}
			
			// determine if the mouse has moved more than 10px
			this.hasDragged = Math.sqrt(
				Math.pow(mouseDownX - chartX, 2) +
				Math.pow(mouseDownY - chartY, 2)
			);
			
			if (this.hasDragged > 10) {
				clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

				// make a selection
				if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
					if (!this.selectionMarker) {
						this.selectionMarker = chart.renderer.rect(
							plotLeft,
							plotTop,
							zoomHor ? 1 : plotWidth,
							zoomVert ? 1 : plotHeight,
							0
						)
						.attr({
							fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
							zIndex: 7
						})
						.add();
					}
				}

				// adjust the width of the selection marker
				if (this.selectionMarker && zoomHor) {
					size = chartX - mouseDownX;
					this.selectionMarker.attr({
						width: mathAbs(size),
						x: (size > 0 ? 0 : size) + mouseDownX
					});
				}
				// adjust the height of the selection marker
				if (this.selectionMarker && zoomVert) {
					size = chartY - mouseDownY;
					this.selectionMarker.attr({
						height: mathAbs(size),
						y: (size > 0 ? 0 : size) + mouseDownY
					});
				}

				// panning
				if (clickedInside && !this.selectionMarker && chartOptions.panning) {
					chart.pan(e, chartOptions.panning);
				}
			}
		},

		/**
		 * On mouse up or touch end across the entire document, drop the selection.
		 */
		drop: function (e) {
			var pointer = this,
				chart = this.chart,
				hasPinched = this.hasPinched;

			if (this.selectionMarker) {
				var selectionData = {
						xAxis: [],
						yAxis: [],
						originalEvent: e.originalEvent || e
					},
					selectionBox = this.selectionMarker,
					selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
					selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
					selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
					selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
					runZoom;

				// a selection has been made
				if (this.hasDragged || hasPinched) {

					// record each axis' min and max
					each(chart.axes, function (axis) {
						if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
							var horiz = axis.horiz,
								minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075
								selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
								selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

							selectionData[axis.coll].push({
								axis: axis,
								min: mathMin(selectionMin, selectionMax), // for reversed axes
								max: mathMax(selectionMin, selectionMax)
							});
							runZoom = true;
						}
					});
					if (runZoom) {
						fireEvent(chart, 'selection', selectionData, function (args) { 
							chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
						});
					}

				}
				this.selectionMarker = this.selectionMarker.destroy();

				// Reset scaling preview
				if (hasPinched) {
					this.scaleGroups();
				}
			}

			// Reset all
			if (chart) { // it may be destroyed on mouse up - #877
				css(chart.container, { cursor: chart._cursor });
				chart.cancelClick = this.hasDragged > 10; // #370
				chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
				this.pinchDown = [];
			}
		},

		onContainerMouseDown: function (e) {

			e = this.normalize(e);

			// issue #295, dragging not always working in Firefox
			if (e.preventDefault) {
				e.preventDefault();
			}
			
			this.dragStart(e);
		},

		

		onDocumentMouseUp: function (e) {
			if (charts[hoverChartIndex]) {
				charts[hoverChartIndex].pointer.drop(e);
			}
		},

		/**
		 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
		 * Issue #149 workaround. The mouseleave event does not always fire. 
		 */
		onDocumentMouseMove: function (e) {
			var chart = this.chart,
				chartPosition = this.chartPosition;

			e = this.normalize(e, chartPosition);

			// If we're outside, hide the tooltip
			if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
					!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
				this.reset();
			}
		},

		/**
		 * When mouse leaves the container, hide the tooltip.
		 */
		onContainerMouseLeave: function () {
			var chart = charts[hoverChartIndex];
			if (chart) {
				chart.pointer.reset();
				chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
			}
		},

		// The mousemove, touchmove and touchstart event handler
		onContainerMouseMove: function (e) {

			var chart = this.chart;

			hoverChartIndex = chart.index;

			e = this.normalize(e);		
			e.returnValue = false; // #2251, #3224
			
			if (chart.mouseIsDown === 'mousedown') {
				this.drag(e);
			} 
			
			// Show the tooltip and run mouse over events (#977)
			if ((this.inClass(e.target, 'highcharts-tracker') || 
					chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
				this.runPointActions(e);
			}
		},

		/**
		 * Utility to detect whether an element has, or has a parent with, a specific
		 * class name. Used on detection of tracker objects and on deciding whether
		 * hovering the tooltip should cause the active series to mouse out.
		 */
		inClass: function (element, className) {
			var elemClassName;
			while (element) {
				elemClassName = attr(element, 'class');
				if (elemClassName) {
					if (elemClassName.indexOf(className) !== -1) {
						return true;
					} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
						return false;
					}
				}
				element = element.parentNode;
			}		
		},

		onTrackerMouseOut: function (e) {
			var series = this.chart.hoverSeries,
				relatedTarget = e.relatedTarget || e.toElement,
				relatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499
			
			if (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&
					relatedSeries !== series) {
				series.onMouseOut();
			}
		},

		onContainerClick: function (e) {
			var chart = this.chart,
				hoverPoint = chart.hoverPoint, 
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop;
			
			e = this.normalize(e);
			e.originalEvent = e; // #3913
			e.cancelBubble = true; // IE specific

			if (!chart.cancelClick) {
				
				// On tracker click, fire the series and point events. #783, #1583
				if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

					// the series click event
					fireEvent(hoverPoint.series, 'click', extend(e, {
						point: hoverPoint
					}));

					// the point click event
					if (chart.hoverPoint) { // it may be destroyed (#1844)
						hoverPoint.firePointEvent('click', e);
					}

				// When clicking outside a tracker, fire a chart event
				} else {
					extend(e, this.getCoordinates(e));

					// fire a click event in the chart
					if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
						fireEvent(chart, 'click', e);
					}
				}


			}
		},

		/**
		 * Set the JS DOM events on the container and document. This method should contain
		 * a one-to-one assignment between methods and their handlers. Any advanced logic should
		 * be moved to the handler reflecting the event's name.
		 */
		setDOMEvents: function () {

			var pointer = this,
				container = pointer.chart.container;

			container.onmousedown = function (e) {
				pointer.onContainerMouseDown(e);
			};
			container.onmousemove = function (e) {
				pointer.onContainerMouseMove(e);
			};
			container.onclick = function (e) {
				pointer.onContainerClick(e);
			};
			addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
			if (chartCount === 1) {
				addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
			}
			if (hasTouch) {
				container.ontouchstart = function (e) {
					pointer.onContainerTouchStart(e);
				};
				container.ontouchmove = function (e) {
					pointer.onContainerTouchMove(e);
				};
				if (chartCount === 1) {
					addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
				}
			}
			
		},

		/**
		 * Destroys the Pointer object and disconnects DOM events.
		 */
		destroy: function () {
			var prop;

			removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
			if (!chartCount) {
				removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
				removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
			}

			// memory and CPU leak
			clearInterval(this.tooltipTimeout);

			for (prop in this) {
				this[prop] = null;
			}
		}
	};


	/* Support for touch devices */
	extend(Highcharts.Pointer.prototype, {

		/**
		 * Run translation operations
		 */
		pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
			if (this.zoomHor || this.pinchHor) {
				this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
			if (this.zoomVert || this.pinchVert) {
				this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
			}
		},

		/**
		 * Run translation operations for each direction (horizontal and vertical) independently
		 */
		pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
			var chart = this.chart,
				xy = horiz ? 'x' : 'y',
				XY = horiz ? 'X' : 'Y',
				sChartXY = 'chart' + XY,
				wh = horiz ? 'width' : 'height',
				plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
				selectionWH,
				selectionXY,
				clipXY,
				scale = forcedScale || 1,
				inverted = chart.inverted,
				bounds = chart.bounds[horiz ? 'h' : 'v'],
				singleTouch = pinchDown.length === 1,
				touch0Start = pinchDown[0][sChartXY],
				touch0Now = touches[0][sChartXY],
				touch1Start = !singleTouch && pinchDown[1][sChartXY],
				touch1Now = !singleTouch && touches[1][sChartXY],
				outOfBounds,
				transformScale,
				scaleKey,
				setScale = function () {
					if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
						scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); 
					}
					
					clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
					selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
				};

			// Set the scale, first pass
			setScale();

			selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

			// Out of bounds
			if (selectionXY < bounds.min) {
				selectionXY = bounds.min;
				outOfBounds = true;
			} else if (selectionXY + selectionWH > bounds.max) {
				selectionXY = bounds.max - selectionWH;
				outOfBounds = true;
			}
			
			// Is the chart dragged off its bounds, determined by dataMin and dataMax?
			if (outOfBounds) {

				// Modify the touchNow position in order to create an elastic drag movement. This indicates
				// to the user that the chart is responsive but can't be dragged further.
				touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
				if (!singleTouch) {
					touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
				}

				// Set the scale, second pass to adapt to the modified touchNow positions
				setScale();

			} else {
				lastValidTouch[xy] = [touch0Now, touch1Now];
			}

			// Set geometry for clipping, selection and transformation
			if (!inverted) { // TODO: implement clipping for inverted charts
				clip[xy] = clipXY - plotLeftTop;
				clip[wh] = selectionWH;
			}
			scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
			transformScale = inverted ? 1 / scale : scale;

			selectionMarker[wh] = selectionWH;
			selectionMarker[xy] = selectionXY;
			transform[scaleKey] = scale;
			transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
		},
		
		/**
		 * Handle touch events with two touches
		 */
		pinch: function (e) {

			var self = this,
				chart = self.chart,
				pinchDown = self.pinchDown,
				touches = e.touches,
				touchesLength = touches.length,
				lastValidTouch = self.lastValidTouch,
				hasZoom = self.hasZoom,
				selectionMarker = self.selectionMarker,
				transform = {},
				fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && 
					chart.runTrackerClick) || self.runChartClick),
				clip = {};

			// On touch devices, only proceed to trigger click if a handler is defined
			if (hasZoom && !fireClickEvent) {
				e.preventDefault();
			}
			
			// Normalize each touch
			map(touches, function (e) {
				return self.normalize(e);
			});
			
			// Register the touch start position
			if (e.type === 'touchstart') {
				each(touches, function (e, i) {
					pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
				});
				lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
				lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

				// Identify the data bounds in pixels
				each(chart.axes, function (axis) {
					if (axis.zoomEnabled) {
						var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
							minPixelPadding = axis.minPixelPadding,
							min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
							max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
							absMin = mathMin(min, max),
							absMax = mathMax(min, max);

						// Store the bounds for use in the touchmove handler
						bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
						bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
					}
				});
				self.res = true; // reset on next move
			
			// Event type is touchmove, handle panning and pinching
			} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first
				

				// Set the marker
				if (!selectionMarker) {
					self.selectionMarker = selectionMarker = extend({
						destroy: noop
					}, chart.plotBox);
				}
				
				self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

				self.hasPinched = hasZoom;

				// Scale and translate the groups to provide visual feedback during pinching
				self.scaleGroups(transform, clip);
				
				// Optionally move the tooltip on touchmove
				if (!hasZoom && self.followTouchMove && touchesLength === 1) {
					this.runPointActions(self.normalize(e));
				} else if (self.res) {
					self.res = false;
					this.reset(false, 0);
				}
			}
		},

		onContainerTouchStart: function (e) {
			var chart = this.chart;

			hoverChartIndex = chart.index;

			if (e.touches.length === 1) {

				e = this.normalize(e);

				if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

					// Run mouse events and display tooltip etc
					this.runPointActions(e);

					this.pinch(e);

				} else {
					// Hide the tooltip on touching outside the plot area (#1203)
					this.reset();
				}

			} else if (e.touches.length === 2) {
				this.pinch(e);
			}   
		},

		onContainerTouchMove: function (e) {
			if (e.touches.length === 1 || e.touches.length === 2) {
				this.pinch(e);
			}
		},

		onDocumentTouchEnd: function (e) {
			if (charts[hoverChartIndex]) {
				charts[hoverChartIndex].pointer.drop(e);
			}
		}

	});
	if (win.PointerEvent || win.MSPointerEvent) {
		
		// The touches object keeps track of the points being touched at all times
		var touches = {},
			hasPointerEvent = !!win.PointerEvent,
			getWebkitTouches = function () {
				var key, fake = [];
				fake.item = function (i) { return this[i]; };
				for (key in touches) {
					if (touches.hasOwnProperty(key)) {
						fake.push({
							pageX: touches[key].pageX,
							pageY: touches[key].pageY,
							target: touches[key].target
						});
					}
				}
				return fake;
			},
			translateMSPointer = function (e, method, wktype, callback) {
				var p;
				e = e.originalEvent || e;
				if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
					callback(e);
					p = charts[hoverChartIndex].pointer;
					p[method]({
						type: wktype,
						target: e.currentTarget,
						preventDefault: noop,
						touches: getWebkitTouches()
					});				
				}
			};

		/**
		 * Extend the Pointer prototype with methods for each event handler and more
		 */
		extend(Pointer.prototype, {
			onContainerPointerDown: function (e) {
				translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
				});
			},
			onContainerPointerMove: function (e) {
				translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
					if (!touches[e.pointerId].target) {
						touches[e.pointerId].target = e.currentTarget;
					}
				});
			},
			onDocumentPointerUp: function (e) {
				translateMSPointer(e, 'onContainerTouchEnd', 'touchend', function (e) {
					delete touches[e.pointerId];
				});
			},

			/**
			 * Add or remove the MS Pointer specific events
			 */
			batchMSEvents: function (fn) {
				fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
				fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
				fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
			}
		});

		// Disable default IE actions for pinch and such on chart element
		wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
			proceed.call(this, chart, options);
			if (this.hasZoom || this.followTouchMove) {
				css(chart.container, {
					'-ms-touch-action': NONE,
					'touch-action': NONE
				});
			}
		});

		// Add IE specific touch events to chart
		wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
			proceed.apply(this);
			if (this.hasZoom || this.followTouchMove) {
				this.batchMSEvents(addEvent);
			}
		});
		// Destroy MS events also
		wrap(Pointer.prototype, 'destroy', function (proceed) {
			this.batchMSEvents(removeEvent);
			proceed.call(this);
		});
	}
	/**
	 * The overview of the chart's series
	 */
	var Legend = Highcharts.Legend = function (chart, options) {
		this.init(chart, options);
	};

	Legend.prototype = {
		
		/**
		 * Initialize the legend
		 */
		init: function (chart, options) {
			
			var legend = this,
				itemStyle = options.itemStyle,
				padding,
				itemMarginTop = options.itemMarginTop || 0;
		
			this.options = options;

			if (!options.enabled) {
				return;
			}
		
			legend.itemStyle = itemStyle;
			legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
			legend.itemMarginTop = itemMarginTop;
			legend.padding = padding = pick(options.padding, 8);
			legend.initialItemX = padding;
			legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
			legend.maxItemWidth = 0;
			legend.chart = chart;
			legend.itemHeight = 0;
			legend.symbolWidth = pick(options.symbolWidth, 16);
			legend.pages = [];


			// Render it
			legend.render();

			// move checkboxes
			addEvent(legend.chart, 'endResize', function () { 
				legend.positionCheckboxes();
			});

		},

		/**
		 * Set the colors for the legend item
		 * @param {Object} item A Series or Point instance
		 * @param {Object} visible Dimmed or colored
		 */
		colorizeItem: function (item, visible) {
			var legend = this,
				options = legend.options,
				legendItem = item.legendItem,
				legendLine = item.legendLine,
				legendSymbol = item.legendSymbol,
				hiddenColor = legend.itemHiddenStyle.color,
				textColor = visible ? options.itemStyle.color : hiddenColor,
				symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
				markerOptions = item.options && item.options.marker,
				symbolAttr = { fill: symbolColor },
				key,
				val;
			
			if (legendItem) {
				legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
			}
			if (legendLine) {
				legendLine.attr({ stroke: symbolColor });
			}
			
			if (legendSymbol) {
				
				// Apply marker options
				if (markerOptions && legendSymbol.isMarker) { // #585
					symbolAttr.stroke = symbolColor;
					markerOptions = item.convertAttribs(markerOptions);
					for (key in markerOptions) {
						val = markerOptions[key];
						if (val !== UNDEFINED) {
							symbolAttr[key] = val;
						}
					}
				}

				legendSymbol.attr(symbolAttr);
			}
		},

		/**
		 * Position the legend item
		 * @param {Object} item A Series or Point instance
		 */
		positionItem: function (item) {
			var legend = this,
				options = legend.options,
				symbolPadding = options.symbolPadding,
				ltr = !options.rtl,
				legendItemPos = item._legendItemPos,
				itemX = legendItemPos[0],
				itemY = legendItemPos[1],
				checkbox = item.checkbox;

			if (item.legendGroup) {
				item.legendGroup.translate(
					ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
					itemY
				);
			}

			if (checkbox) {
				checkbox.x = itemX;
				checkbox.y = itemY;
			}
		},

		/**
		 * Destroy a single legend item
		 * @param {Object} item The series or point
		 */
		destroyItem: function (item) {
			var checkbox = item.checkbox;

			// destroy SVG elements
			each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
				if (item[key]) {
					item[key] = item[key].destroy();
				}
			});

			if (checkbox) {
				discardElement(item.checkbox);
			}
		},

		/**
		 * Destroy all items.
		 */
		clearItems: function () {
			var legend = this;
			each(legend.getAllItems(), function (item) {
				legend.destroyItem(item); 
			});		
		},

		/**
		 * Destroys the legend.
		 */
		destroy: function () {
			var legend = this,
				legendGroup = legend.group,
				box = legend.box;

			if (box) {
				legend.box = box.destroy();
			}

			if (legendGroup) {
				legend.group = legendGroup.destroy();
			}
		},

		/**
		 * Position the checkboxes after the width is determined
		 */
		positionCheckboxes: function (scrollOffset) {
			var alignAttr = this.group.alignAttr,
				translateY,
				clipHeight = this.clipHeight || this.legendHeight;

			if (alignAttr) {
				translateY = alignAttr.translateY;
				each(this.allItems, function (item) {
					var checkbox = item.checkbox,
						top;
					
					if (checkbox) {
						top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
						css(checkbox, {
							left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
							top: top + PX,
							display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
						});
					}
				});
			}
		},
		
		/**
		 * Render the legend title on top of the legend
		 */
		renderTitle: function () {
			var options = this.options,
				padding = this.padding,
				titleOptions = options.title,
				titleHeight = 0,
				bBox;
			
			if (titleOptions.text) {
				if (!this.title) {
					this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
						.attr({ zIndex: 1 })
						.css(titleOptions.style)
						.add(this.group);
				}
				bBox = this.title.getBBox();
				titleHeight = bBox.height;
				this.offsetWidth = bBox.width; // #1717
				this.contentGroup.attr({ translateY: titleHeight });
			}
			this.titleHeight = titleHeight;
		},

		/**
		 * Render a single specific legend item
		 * @param {Object} item A series or point
		 */
		renderItem: function (item) {
			var legend = this,
				chart = legend.chart,
				renderer = chart.renderer,
				options = legend.options,
				horizontal = options.layout === 'horizontal',
				symbolWidth = legend.symbolWidth,
				symbolPadding = options.symbolPadding,
				itemStyle = legend.itemStyle,
				itemHiddenStyle = legend.itemHiddenStyle,
				padding = legend.padding,
				itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
				ltr = !options.rtl,
				itemHeight,
				widthOption = options.width,
				itemMarginBottom = options.itemMarginBottom || 0,
				itemMarginTop = legend.itemMarginTop,
				initialItemX = legend.initialItemX,
				bBox,
				itemWidth,
				li = item.legendItem,
				series = item.series && item.series.drawLegendSymbol ? item.series : item,
				seriesOptions = series.options,
				showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
				useHTML = options.useHTML;

			if (!li) { // generate it once, later move it

				// Generate the group box
				// A group to hold the symbol and text. Text is to be appended in Legend class.
				item.legendGroup = renderer.g('legend-item')
					.attr({ zIndex: 1 })
					.add(legend.scrollGroup);

				// Generate the list item text and add it to the group
				item.legendItem = li = renderer.text(
						options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item),
						ltr ? symbolWidth + symbolPadding : -symbolPadding,
						legend.baseline || 0,
						useHTML
					)
					.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
					.attr({
						align: ltr ? 'left' : 'right',
						zIndex: 2
					})
					.add(item.legendGroup);

				// Get the baseline for the first item - the font size is equal for all
				if (!legend.baseline) {
					legend.baseline = renderer.fontMetrics(itemStyle.fontSize, li).f + 3 + itemMarginTop;
					li.attr('y', legend.baseline);
				}

				// Draw the legend symbol inside the group box
				series.drawLegendSymbol(legend, item);

				if (legend.setItemEvents) {
					legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
				}			

				// Colorize the items
				legend.colorizeItem(item, item.visible);

				// add the HTML checkbox on top
				if (showCheckbox) {
					legend.createCheckboxForItem(item);				
				}
			}

			// calculate the positions for the next line
			bBox = li.getBBox();

			itemWidth = item.checkboxOffset = 
				options.itemWidth || 
				item.legendItemWidth || 
				symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
			legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

			// if the item exceeds the width, start a new line
			if (horizontal && legend.itemX - initialItemX + itemWidth >
					(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
				legend.itemX = initialItemX;
				legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
			}

			// If the item exceeds the height, start a new column
			/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
				legend.itemY = legend.initialItemY;
				legend.itemX += legend.maxItemWidth;
				legend.maxItemWidth = 0;
			}*/

			// Set the edge positions
			legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
			legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
			legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

			// cache the position of the newly generated or reordered items
			item._legendItemPos = [legend.itemX, legend.itemY];

			// advance
			if (horizontal) {
				legend.itemX += itemWidth;

			} else {
				legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
				legend.lastLineHeight = itemHeight;
			}

			// the width of the widest item
			legend.offsetWidth = widthOption || mathMax(
				(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
				legend.offsetWidth
			);
		},

		/**
		 * Get all items, which is one item per series for normal series and one item per point
		 * for pie series.
		 */
		getAllItems: function () {
			var allItems = [];
			each(this.chart.series, function (series) {
				var seriesOptions = series.options;

				// Handle showInLegend. If the series is linked to another series, defaults to false.
				if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
					return;
				}

				// use points or series for the legend item depending on legendType
				allItems = allItems.concat(
						series.legendItems ||
						(seriesOptions.legendType === 'point' ?
								series.data :
								series)
				);
			});
			return allItems;
		},

		/**
		 * Adjust the chart margins by reserving space for the legend on only one side
		 * of the chart. If the position is set to a corner, top or bottom is reserved
		 * for horizontal legends and left or right for vertical ones.
		 */
		adjustMargins: function (margin, spacing) {
			var chart = this.chart, 
				options = this.options,
				// Use the first letter of each alignment option in order to detect the side 
				alignment = options.align[0] + options.verticalAlign[0] + options.layout[0];
				
			if (this.display && !options.floating) {

				each([
					/(lth|ct|rth)/,
					/(rtv|rm|rbv)/,
					/(rbh|cb|lbh)/,
					/(lbv|lm|ltv)/
				], function (alignments, side) {
					if (alignments.test(alignment) && !defined(margin[side])) {
						// Now we have detected on which side of the chart we should reserve space for the legend
						chart[marginNames[side]] = mathMax(
							chart[marginNames[side]],
							chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + 
								[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + 
								pick(options.margin, 12) +
								spacing[side]
						);
					}
				});
			}
		},

		/**
		 * Render the legend. This method can be called both before and after
		 * chart.render. If called after, it will only rearrange items instead
		 * of creating new ones.
		 */
		render: function () {
			var legend = this,
				chart = legend.chart,
				renderer = chart.renderer,
				legendGroup = legend.group,
				allItems,
				display,
				legendWidth,
				legendHeight,
				box = legend.box,
				options = legend.options,
				padding = legend.padding,
				legendBorderWidth = options.borderWidth,
				legendBackgroundColor = options.backgroundColor;

			legend.itemX = legend.initialItemX;
			legend.itemY = legend.initialItemY;
			legend.offsetWidth = 0;
			legend.lastItemY = 0;

			if (!legendGroup) {
				legend.group = legendGroup = renderer.g('legend')
					.attr({ zIndex: 7 }) 
					.add();
				legend.contentGroup = renderer.g()
					.attr({ zIndex: 1 }) // above background
					.add(legendGroup);
				legend.scrollGroup = renderer.g()
					.add(legend.contentGroup);
			}
			
			legend.renderTitle();

			// add each series or point
			allItems = legend.getAllItems();

			// sort by legendIndex
			stableSort(allItems, function (a, b) {
				return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
			});

			// reversed legend
			if (options.reversed) {
				allItems.reverse();
			}

			legend.allItems = allItems;
			legend.display = display = !!allItems.length;

			// render the items
			legend.lastLineHeight = 0;
			each(allItems, function (item) {
				legend.renderItem(item); 
			});

			// Get the box
			legendWidth = (options.width || legend.offsetWidth) + padding;
			legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
			legendHeight = legend.handleOverflow(legendHeight);
			legendHeight += padding;

			// Draw the border and/or background
			if (legendBorderWidth || legendBackgroundColor) {

				if (!box) {
					legend.box = box = renderer.rect(
						0,
						0,
						legendWidth,
						legendHeight,
						options.borderRadius,
						legendBorderWidth || 0
					).attr({
						stroke: options.borderColor,
						'stroke-width': legendBorderWidth || 0,
						fill: legendBackgroundColor || NONE
					})
					.add(legendGroup)
					.shadow(options.shadow);
					box.isNew = true;

				} else if (legendWidth > 0 && legendHeight > 0) {
					box[box.isNew ? 'attr' : 'animate'](
						box.crisp({ width: legendWidth, height: legendHeight })
					);
					box.isNew = false;
				}

				// hide the border if no items
				box[display ? 'show' : 'hide']();
			}
			
			legend.legendWidth = legendWidth;
			legend.legendHeight = legendHeight;

			// Now that the legend width and height are established, put the items in the 
			// final position
			each(allItems, function (item) {
				legend.positionItem(item);
			});

			// 1.x compatibility: positioning based on style
			/*var props = ['left', 'right', 'top', 'bottom'],
				prop,
				i = 4;
			while (i--) {
				prop = props[i];
				if (options.style[prop] && options.style[prop] !== 'auto') {
					options[i < 2 ? 'align' : 'verticalAlign'] = prop;
					options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
				}
			}*/

			if (display) {
				legendGroup.align(extend({
					width: legendWidth,
					height: legendHeight
				}, options), true, 'spacingBox');
			}

			if (!chart.isResizing) {
				this.positionCheckboxes();
			}
		},
		
		/**
		 * Set up the overflow handling by adding navigation with up and down arrows below the
		 * legend.
		 */
		handleOverflow: function (legendHeight) {
			var legend = this,
				chart = this.chart,
				renderer = chart.renderer,
				options = this.options,
				optionsY = options.y,
				alignTop = options.verticalAlign === 'top',
				spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
				maxHeight = options.maxHeight,
				clipHeight,
				clipRect = this.clipRect,
				navOptions = options.navigation,
				animation = pick(navOptions.animation, true),
				arrowSize = navOptions.arrowSize || 12,
				nav = this.nav,
				pages = this.pages,
				lastY,
				allItems = this.allItems;
				
			// Adjust the height
			if (options.layout === 'horizontal') {
				spaceHeight /= 2;
			}
			if (maxHeight) {
				spaceHeight = mathMin(spaceHeight, maxHeight);
			}
			
			// Reset the legend height and adjust the clipping rectangle
			pages.length = 0;
			if (legendHeight > spaceHeight && !options.useHTML) {

				this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - this.padding, 0);
				this.currentPage = pick(this.currentPage, 1);
				this.fullHeight = legendHeight;
				
				// Fill pages with Y positions so that the top of each a legend item defines
				// the scroll top for each page (#2098)
				each(allItems, function (item, i) {
					var y = item._legendItemPos[1],
						h = mathRound(item.legendItem.getBBox().height),
						len = pages.length;
					
					if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
						pages.push(lastY || y);
						len++;
					}
					
					if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
						pages.push(y);
					}
					if (y !== lastY) {
						lastY = y;
					}
				});

				// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
				if (!clipRect) {
					clipRect = legend.clipRect = renderer.clipRect(0, this.padding, 9999, 0);
					legend.contentGroup.clip(clipRect);
				}
				clipRect.attr({
					height: clipHeight
				});
				
				// Add navigation elements
				if (!nav) {
					this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
					this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
						.on('click', function () {
							legend.scroll(-1, animation);
						})
						.add(nav);
					this.pager = renderer.text('', 15, 10)
						.css(navOptions.style)
						.add(nav);
					this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
						.on('click', function () {
							legend.scroll(1, animation);
						})
						.add(nav);
				}
				
				// Set initial position
				legend.scroll(0);
				
				legendHeight = spaceHeight;
				
			} else if (nav) {
				clipRect.attr({
					height: chart.chartHeight
				});
				nav.hide();
				this.scrollGroup.attr({
					translateY: 1
				});
				this.clipHeight = 0; // #1379
			}
			
			return legendHeight;
		},
		
		/**
		 * Scroll the legend by a number of pages
		 * @param {Object} scrollBy
		 * @param {Object} animation
		 */
		scroll: function (scrollBy, animation) {
			var pages = this.pages,
				pageCount = pages.length,
				currentPage = this.currentPage + scrollBy,
				clipHeight = this.clipHeight,
				navOptions = this.options.navigation,
				activeColor = navOptions.activeColor,
				inactiveColor = navOptions.inactiveColor,
				pager = this.pager,
				padding = this.padding,
				scrollOffset;
			
			// When resizing while looking at the last page
			if (currentPage > pageCount) {
				currentPage = pageCount;
			}
			
			if (currentPage > 0) {
				
				if (animation !== UNDEFINED) {
					setAnimation(animation, this.chart);
				}
				
				this.nav.attr({
					translateX: padding,
					translateY: clipHeight + this.padding + 7 + this.titleHeight,
					visibility: VISIBLE
				});
				this.up.attr({
						fill: currentPage === 1 ? inactiveColor : activeColor
					})
					.css({
						cursor: currentPage === 1 ? 'default' : 'pointer'
					});
				pager.attr({
					text: currentPage + '/' + pageCount
				});
				this.down.attr({
						x: 18 + this.pager.getBBox().width, // adjust to text width
						fill: currentPage === pageCount ? inactiveColor : activeColor
					})
					.css({
						cursor: currentPage === pageCount ? 'default' : 'pointer'
					});
				
				scrollOffset = -pages[currentPage - 1] + this.initialItemY;

				this.scrollGroup.animate({
					translateY: scrollOffset
				});			
				
				this.currentPage = currentPage;
				this.positionCheckboxes(scrollOffset);
			}
				
		}
		
	};

	/*
	 * LegendSymbolMixin
	 */ 

	var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

		/**
		 * Get the series' symbol in the legend
		 * 
		 * @param {Object} legend The legend object
		 * @param {Object} item The series (this) or point
		 */
		drawRectangle: function (legend, item) {
			var symbolHeight = legend.options.symbolHeight || 12;
			
			item.legendSymbol = this.chart.renderer.rect(
				0,
				legend.baseline - 5 - (symbolHeight / 2),
				legend.symbolWidth,
				symbolHeight,
				legend.options.symbolRadius || 0
			).attr({
				zIndex: 3
			}).add(item.legendGroup);		
			
		},

		/**
		 * Get the series' symbol in the legend. This method should be overridable to create custom 
		 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
		 * 
		 * @param {Object} legend The legend object
		 */
		drawLineMarker: function (legend) {

			var options = this.options,
				markerOptions = options.marker,
				radius,
				legendOptions = legend.options,
				legendSymbol,
				symbolWidth = legend.symbolWidth,
				renderer = this.chart.renderer,
				legendItemGroup = this.legendGroup,
				verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize, this.legendItem).b * 0.3),
				attr;

			// Draw the line
			if (options.lineWidth) {
				attr = {
					'stroke-width': options.lineWidth
				};
				if (options.dashStyle) {
					attr.dashstyle = options.dashStyle;
				}
				this.legendLine = renderer.path([
					M,
					0,
					verticalCenter,
					L,
					symbolWidth,
					verticalCenter
				])
				.attr(attr)
				.add(legendItemGroup);
			}
			
			// Draw the marker
			if (markerOptions && markerOptions.enabled !== false) {
				radius = markerOptions.radius;
				this.legendSymbol = legendSymbol = renderer.symbol(
					this.symbol,
					(symbolWidth / 2) - radius,
					verticalCenter - radius,
					2 * radius,
					2 * radius
				)
				.add(legendItemGroup);
				legendSymbol.isMarker = true;
			}
		}
	};

	// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
	// and for #2580, a similar drawing flaw in Firefox 26.
	// TODO: Explore if there's a general cause for this. The problem may be related 
	// to nested group elements, as the legend item texts are within 4 group elements.
	if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
		wrap(Legend.prototype, 'positionItem', function (proceed, item) {
			var legend = this,
				runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
					if (item._legendItemPos) {
						proceed.call(legend, item);
					}
				};

			// Do it now, for export and to get checkbox placement
			runPositionItem();
			
			// Do it after to work around the core issue
			setTimeout(runPositionItem);
		});
	}
	/**
	 * The chart class
	 * @param {Object} options
	 * @param {Function} callback Function to run when the chart has loaded
	 */
	var Chart = Highcharts.Chart = function () {
		this.init.apply(this, arguments);
	};

	Chart.prototype = {

		/**
		 * Hook for modules
		 */
		callbacks: [],

		/**
		 * Initialize the chart
		 */
		init: function (userOptions, callback) {

			// Handle regular options
			var options,
				seriesOptions = userOptions.series; // skip merging data points to increase performance

			userOptions.series = null;
			options = merge(defaultOptions, userOptions); // do the merge
			options.series = userOptions.series = seriesOptions; // set back the series data
			this.userOptions = userOptions;

			var optionsChart = options.chart;
			
			// Create margin & spacing array
			this.margin = this.splashArray('margin', optionsChart);
			this.spacing = this.splashArray('spacing', optionsChart);

			var chartEvents = optionsChart.events;

			//this.runChartClick = chartEvents && !!chartEvents.click;
			this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

			this.callback = callback;
			this.isResizing = 0;
			this.options = options;
			//chartTitleOptions = UNDEFINED;
			//chartSubtitleOptions = UNDEFINED;

			this.axes = [];
			this.series = [];
			this.hasCartesianSeries = optionsChart.showAxes;
			//this.axisOffset = UNDEFINED;
			//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
			//this.inverted = UNDEFINED;
			//this.loadingShown = UNDEFINED;
			//this.container = UNDEFINED;
			//this.chartWidth = UNDEFINED;
			//this.chartHeight = UNDEFINED;
			//this.marginRight = UNDEFINED;
			//this.marginBottom = UNDEFINED;
			//this.containerWidth = UNDEFINED;
			//this.containerHeight = UNDEFINED;
			//this.oldChartWidth = UNDEFINED;
			//this.oldChartHeight = UNDEFINED;

			//this.renderTo = UNDEFINED;
			//this.renderToClone = UNDEFINED;

			//this.spacingBox = UNDEFINED

			//this.legend = UNDEFINED;

			// Elements
			//this.chartBackground = UNDEFINED;
			//this.plotBackground = UNDEFINED;
			//this.plotBGImage = UNDEFINED;
			//this.plotBorder = UNDEFINED;
			//this.loadingDiv = UNDEFINED;
			//this.loadingSpan = UNDEFINED;

			var chart = this,
				eventType;

			// Add the chart to the global lookup
			chart.index = charts.length;
			charts.push(chart);
			chartCount++;

			// Set up auto resize
			if (optionsChart.reflow !== false) {
				addEvent(chart, 'load', function () {
					chart.initReflow();
				});
			}

			// Chart event handlers
			if (chartEvents) {
				for (eventType in chartEvents) {
					addEvent(chart, eventType, chartEvents[eventType]);
				}
			}

			chart.xAxis = [];
			chart.yAxis = [];

			// Expose methods and variables
			chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
			chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

			chart.firstRender();
		},

		/**
		 * Initialize an individual series, called internally before render time
		 */
		initSeries: function (options) {
			var chart = this,
				optionsChart = chart.options.chart,
				type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
				series,
				constr = seriesTypes[type];

			// No such series type
			if (!constr) {
				error(17, true);
			}

			series = new constr();
			series.init(this, options);
			return series;
		},

		/**
		 * Check whether a given point is within the plot area
		 *
		 * @param {Number} plotX Pixel x relative to the plot area
		 * @param {Number} plotY Pixel y relative to the plot area
		 * @param {Boolean} inverted Whether the chart is inverted
		 */
		isInsidePlot: function (plotX, plotY, inverted) {
			var x = inverted ? plotY : plotX,
				y = inverted ? plotX : plotY;
				
			return x >= 0 &&
				x <= this.plotWidth &&
				y >= 0 &&
				y <= this.plotHeight;
		},

		/**
		 * Redraw legend, axes or series based on updated data
		 *
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		redraw: function (animation) {
			var chart = this,
				axes = chart.axes,
				series = chart.series,
				pointer = chart.pointer,
				legend = chart.legend,
				redrawLegend = chart.isDirtyLegend,
				hasStackedSeries,
				hasDirtyStacks,
				hasCartesianSeries = chart.hasCartesianSeries,
				isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
				seriesLength = series.length,
				i = seriesLength,
				serie,
				renderer = chart.renderer,
				isHiddenChart = renderer.isHidden(),
				afterRedraw = [];
				
			setAnimation(animation, chart);
			
			if (isHiddenChart) {
				chart.cloneRenderTo();
			}

			// Adjust title layout (reflow multiline text)
			chart.layOutTitles();

			// link stacked series
			while (i--) {
				serie = series[i];

				if (serie.options.stacking) {
					hasStackedSeries = true;
					
					if (serie.isDirty) {
						hasDirtyStacks = true;
						break;
					}
				}
			}
			if (hasDirtyStacks) { // mark others as dirty
				i = seriesLength;
				while (i--) {
					serie = series[i];
					if (serie.options.stacking) {
						serie.isDirty = true;
					}
				}
			}

			// handle updated data in the series
			each(series, function (serie) {
				if (serie.isDirty) { // prepare the data so axis can read it
					if (serie.options.legendType === 'point') {
						redrawLegend = true;
					}
				}
			});

			// handle added or removed series
			if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
				// draw legend graphics
				legend.render();

				chart.isDirtyLegend = false;
			}

			// reset stacks
			if (hasStackedSeries) {
				chart.getStacks();
			}


			if (hasCartesianSeries) {
				if (!chart.isResizing) {

					// reset maxTicks
					chart.maxTicks = null;

					// set axes scales
					each(axes, function (axis) {
						axis.setScale();
					});
				}
			}

			chart.getMargins(); // #3098

			if (hasCartesianSeries) {
				// If one axis is dirty, all axes must be redrawn (#792, #2169)
				each(axes, function (axis) {
					if (axis.isDirty) {
						isDirtyBox = true;
					}
				});

				// redraw axes
				each(axes, function (axis) {
					
					// Fire 'afterSetExtremes' only if extremes are set
					if (axis.isDirtyExtremes) { // #821
						axis.isDirtyExtremes = false;
						afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
							fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
							delete axis.eventArgs;
						});
					}
					
					if (isDirtyBox || hasStackedSeries) {
						axis.redraw();
					}
				});
			}
			
			// the plot areas size has changed
			if (isDirtyBox) {
				chart.drawChartBox();
			}


			// redraw affected series
			each(series, function (serie) {
				if (serie.isDirty && serie.visible &&
						(!serie.isCartesian || serie.xAxis)) { // issue #153
					serie.redraw();
				}
			});

			// move tooltip or reset
			if (pointer) {
				pointer.reset(true);
			}

			// redraw if canvas
			renderer.draw();

			// fire the event
			fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
			
			if (isHiddenChart) {
				chart.cloneRenderTo(true);
			}
			
			// Fire callbacks that are put on hold until after the redraw
			each(afterRedraw, function (callback) {
				callback.call();
			});
		},

		/**
		 * Get an axis, series or point object by id.
		 * @param id {String} The id as given in the configuration options
		 */
		get: function (id) {
			var chart = this,
				axes = chart.axes,
				series = chart.series;

			var i,
				j,
				points;

			// search axes
			for (i = 0; i < axes.length; i++) {
				if (axes[i].options.id === id) {
					return axes[i];
				}
			}

			// search series
			for (i = 0; i < series.length; i++) {
				if (series[i].options.id === id) {
					return series[i];
				}
			}

			// search points
			for (i = 0; i < series.length; i++) {
				points = series[i].points || [];
				for (j = 0; j < points.length; j++) {
					if (points[j].id === id) {
						return points[j];
					}
				}
			}
			return null;
		},

		/**
		 * Create the Axis instances based on the config options
		 */
		getAxes: function () {
			var chart = this,
				options = this.options,
				xAxisOptions = options.xAxis = splat(options.xAxis || {}),
				yAxisOptions = options.yAxis = splat(options.yAxis || {}),
				optionsArray,
				axis;

			// make sure the options are arrays and add some members
			each(xAxisOptions, function (axis, i) {
				axis.index = i;
				axis.isX = true;
			});

			each(yAxisOptions, function (axis, i) {
				axis.index = i;
			});

			// concatenate all axis options into one array
			optionsArray = xAxisOptions.concat(yAxisOptions);

			each(optionsArray, function (axisOptions) {
				axis = new Axis(chart, axisOptions);
			});
		},


		/**
		 * Get the currently selected points from all series
		 */
		getSelectedPoints: function () {
			var points = [];
			each(this.series, function (serie) {
				points = points.concat(grep(serie.points || [], function (point) {
					return point.selected;
				}));
			});
			return points;
		},

		/**
		 * Get the currently selected series
		 */
		getSelectedSeries: function () {
			return grep(this.series, function (serie) {
				return serie.selected;
			});
		},

		/**
		 * Generate stacks for each series and calculate stacks total values
		 */
		getStacks: function () {
			var chart = this;

			// reset stacks for each yAxis
			each(chart.yAxis, function (axis) {
				if (axis.stacks && axis.hasVisibleSeries) {
					axis.oldStacks = axis.stacks;
				}
			});

			each(chart.series, function (series) {
				if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
					series.stackKey = series.type + pick(series.options.stack, '');
				}
			});
		},	

		/**
		 * Show the title and subtitle of the chart
		 *
		 * @param titleOptions {Object} New title options
		 * @param subtitleOptions {Object} New subtitle options
		 *
		 */
		setTitle: function (titleOptions, subtitleOptions, redraw) {
			var chart = this,
				options = chart.options,
				chartTitleOptions,
				chartSubtitleOptions;

			chartTitleOptions = options.title = merge(options.title, titleOptions);
			chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

			// add title and subtitle
			each([
				['title', titleOptions, chartTitleOptions],
				['subtitle', subtitleOptions, chartSubtitleOptions]
			], function (arr) {
				var name = arr[0],
					title = chart[name],
					titleOptions = arr[1],
					chartTitleOptions = arr[2];

				if (title && titleOptions) {
					chart[name] = title = title.destroy(); // remove old
				}
				
				if (chartTitleOptions && chartTitleOptions.text && !title) {
					chart[name] = chart.renderer.text(
						chartTitleOptions.text,
						0,
						0,
						chartTitleOptions.useHTML
					)
					.attr({
						align: chartTitleOptions.align,
						'class': PREFIX + name,
						zIndex: chartTitleOptions.zIndex || 4
					})
					.css(chartTitleOptions.style)
					.add();
				}	
			});
			chart.layOutTitles(redraw);
		},

		/**
		 * Lay out the chart titles and cache the full offset height for use in getMargins
		 */
		layOutTitles: function (redraw) {
			var titleOffset = 0,
				title = this.title,
				subtitle = this.subtitle,
				options = this.options,
				titleOptions = options.title,
				subtitleOptions = options.subtitle,
				requiresDirtyBox,
				renderer = this.renderer,
				autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

			if (title) {
				title
					.css({ width: (titleOptions.width || autoWidth) + PX })
					.align(extend({ 
						y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
					}, titleOptions), false, 'spacingBox');
				
				if (!titleOptions.floating && !titleOptions.verticalAlign) {
					titleOffset = title.getBBox().height;
				}
			}
			if (subtitle) {
				subtitle
					.css({ width: (subtitleOptions.width || autoWidth) + PX })
					.align(extend({ 
						y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b 
					}, subtitleOptions), false, 'spacingBox');
				
				if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
					titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
				}
			}

			requiresDirtyBox = this.titleOffset !== titleOffset;				
			this.titleOffset = titleOffset; // used in getMargins

			if (!this.isDirtyBox && requiresDirtyBox) {
				this.isDirtyBox = requiresDirtyBox;
				// Redraw if necessary (#2719, #2744)		
				if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
					this.redraw();
				}
			}
		},

		/**
		 * Get chart width and height according to options and container size
		 */
		getChartSize: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				widthOption = optionsChart.width,
				heightOption = optionsChart.height,
				renderTo = chart.renderToClone || chart.renderTo;

			// get inner width and height from jQuery (#824)
			if (!defined(widthOption)) {
				chart.containerWidth = adapterRun(renderTo, 'width');
			}
			if (!defined(heightOption)) {
				chart.containerHeight = adapterRun(renderTo, 'height');
			}
			
			chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
			chart.chartHeight = mathMax(0, pick(heightOption,
				// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
				chart.containerHeight > 19 ? chart.containerHeight : 400));
		},

		/**
		 * Create a clone of the chart's renderTo div and place it outside the viewport to allow
		 * size computation on chart.render and chart.redraw
		 */
		cloneRenderTo: function (revert) {
			var clone = this.renderToClone,
				container = this.container;
			
			// Destroy the clone and bring the container back to the real renderTo div
			if (revert) {
				if (clone) {
					this.renderTo.appendChild(container);
					discardElement(clone);
					delete this.renderToClone;
				}
			
			// Set up the clone
			} else {
				if (container && container.parentNode === this.renderTo) {
					this.renderTo.removeChild(container); // do not clone this
				}
				this.renderToClone = clone = this.renderTo.cloneNode(0);
				css(clone, {
					position: ABSOLUTE,
					top: '-9999px',
					display: 'block' // #833
				});
				if (clone.style.setProperty) { // #2631
					clone.style.setProperty('display', 'block', 'important');
				}
				doc.body.appendChild(clone);
				if (container) {
					clone.appendChild(container);
				}
			}
		},

		/**
		 * Get the containing element, determine the size and create the inner container
		 * div to hold the chart
		 */
		getContainer: function () {
			var chart = this,
				container,
				optionsChart = chart.options.chart,
				chartWidth,
				chartHeight,
				renderTo,
				indexAttrName = 'data-highcharts-chart',
				oldChartIndex,
				containerId;

			chart.renderTo = renderTo = optionsChart.renderTo;
			containerId = PREFIX + idCounter++;

			if (isString(renderTo)) {
				chart.renderTo = renderTo = doc.getElementById(renderTo);
			}
			
			// Display an error if the renderTo is wrong
			if (!renderTo) {
				error(13, true);
			}
			
			// If the container already holds a chart, destroy it. The check for hasRendered is there
			// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
			// attribute and the SVG contents, but not an interactive chart. So in this case,
			// charts[oldChartIndex] will point to the wrong chart if any (#2609).
			oldChartIndex = pInt(attr(renderTo, indexAttrName));
			if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
				charts[oldChartIndex].destroy();
			}		
			
			// Make a reference to the chart from the div
			attr(renderTo, indexAttrName, chart.index);

			// remove previous chart
			renderTo.innerHTML = '';

			// If the container doesn't have an offsetWidth, it has or is a child of a node
			// that has display:none. We need to temporarily move it out to a visible
			// state to determine the size, else the legend and tooltips won't render
			// properly. The allowClone option is used in sparklines as a micro optimization,
			// saving about 1-2 ms each chart.
			if (!optionsChart.skipClone && !renderTo.offsetWidth) {
				chart.cloneRenderTo();
			}

			// get the width and height
			chart.getChartSize();
			chartWidth = chart.chartWidth;
			chartHeight = chart.chartHeight;

			// create the inner container
			chart.container = container = createElement(DIV, {
					className: PREFIX + 'container' +
						(optionsChart.className ? ' ' + optionsChart.className : ''),
					id: containerId
				}, extend({
					position: RELATIVE,
					overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
						// content overflow in IE
					width: chartWidth + PX,
					height: chartHeight + PX,
					textAlign: 'left',
					lineHeight: 'normal', // #427
					zIndex: 0, // #1072
					'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
				}, optionsChart.style),
				chart.renderToClone || renderTo
			);

			// cache the cursor (#1650)
			chart._cursor = container.style.cursor;

			// Initialize the renderer
			chart.renderer =
				optionsChart.forExport ? // force SVG, used for SVG export
					new SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :
					new Renderer(container, chartWidth, chartHeight, optionsChart.style);

			if (useCanVG) {
				// If we need canvg library, extend and configure the renderer
				// to get the tracker for translating mouse events
				chart.renderer.create(chart, container, chartWidth, chartHeight);
			}
			// Add a reference to the charts index
			chart.renderer.chartIndex = chart.index;
		},

		/**
		 * Calculate margins by rendering axis labels in a preliminary position. Title,
		 * subtitle and legend have already been rendered at this stage, but will be
		 * moved into their final positions
		 */
		getMargins: function (skipAxes) {
			var chart = this,
				spacing = chart.spacing,
				margin = chart.margin,
				titleOffset = chart.titleOffset;

			chart.resetMargins();

			// Adjust for title and subtitle
			if (titleOffset && !defined(margin[0])) {
				chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
			}
			
			// Adjust for legend
			chart.legend.adjustMargins(margin, spacing);

			// adjust for scroller
			if (chart.extraBottomMargin) {
				chart.marginBottom += chart.extraBottomMargin;
			}
			if (chart.extraTopMargin) {
				chart.plotTop += chart.extraTopMargin;
			}
			if (!skipAxes) {
				this.getAxisMargins();
			}
		},

		getAxisMargins: function () {

			var chart = this,
				axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
				margin = chart.margin;
			
			// pre-render axes to get labels offset width
			if (chart.hasCartesianSeries) {
				each(chart.axes, function (axis) {
					axis.getOffset();
				});
			}

			// Add the axis offsets
			each(marginNames, function (m, side) {
				if (!defined(margin[side])) {
					chart[m] += axisOffset[side];
				}		
			});

			chart.setChartSize();

		},

		/**
		 * Resize the chart to its container if size is not explicitly set
		 */
		reflow: function (e) {
			var chart = this,
				optionsChart = chart.options.chart,
				renderTo = chart.renderTo,
				width = optionsChart.width || adapterRun(renderTo, 'width'),
				height = optionsChart.height || adapterRun(renderTo, 'height'),
				target = e ? e.target : win, // #805 - MooTools doesn't supply e
				doReflow = function () {
					if (chart.container) { // It may have been destroyed in the meantime (#1257)
						chart.setSize(width, height, false);
						chart.hasUserSize = null;
					}
				};
				
			// Width and height checks for display:none. Target is doc in IE8 and Opera,
			// win in Firefox, Chrome and IE9.
			if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093
				if (width !== chart.containerWidth || height !== chart.containerHeight) {
					clearTimeout(chart.reflowTimeout);
					if (e) { // Called from window.resize
						chart.reflowTimeout = setTimeout(doReflow, 100);
					} else { // Called directly (#2224)
						doReflow();
					}
				}
				chart.containerWidth = width;
				chart.containerHeight = height;
			}
		},

		/**
		 * Add the event handlers necessary for auto resizing
		 */
		initReflow: function () {
			var chart = this,
				reflow = function (e) {
					chart.reflow(e);
				};
				
			
			addEvent(win, 'resize', reflow);
			addEvent(chart, 'destroy', function () {
				removeEvent(win, 'resize', reflow);
			});
		},

		/**
		 * Resize the chart to a given width and height
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Object|Boolean} animation
		 */
		setSize: function (width, height, animation) {
			var chart = this,
				chartWidth,
				chartHeight,
				fireEndResize;

			// Handle the isResizing counter
			chart.isResizing += 1;
			fireEndResize = function () {
				if (chart) {
					fireEvent(chart, 'endResize', null, function () {
						chart.isResizing -= 1;
					});
				}
			};

			// set the animation for the current process
			setAnimation(animation, chart);

			chart.oldChartHeight = chart.chartHeight;
			chart.oldChartWidth = chart.chartWidth;
			if (defined(width)) {
				chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
				chart.hasUserSize = !!chartWidth;
			}
			if (defined(height)) {
				chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
			}

			// Resize the container with the global animation applied if enabled (#2503)
			(globalAnimation ? animate : css)(chart.container, {
				width: chartWidth + PX,
				height: chartHeight + PX
			}, globalAnimation);

			chart.setChartSize(true);
			chart.renderer.setSize(chartWidth, chartHeight, animation);

			// handle axes
			chart.maxTicks = null;
			each(chart.axes, function (axis) {
				axis.isDirty = true;
				axis.setScale();
			});

			// make sure non-cartesian series are also handled
			each(chart.series, function (serie) {
				serie.isDirty = true;
			});

			chart.isDirtyLegend = true; // force legend redraw
			chart.isDirtyBox = true; // force redraw of plot and chart border

			chart.layOutTitles(); // #2857
			chart.getMargins();

			chart.redraw(animation);


			chart.oldChartHeight = null;
			fireEvent(chart, 'resize');

			// fire endResize and set isResizing back
			// If animation is disabled, fire without delay
			if (globalAnimation === false) {
				fireEndResize();
			} else { // else set a timeout with the animation duration
				setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
			}
		},

		/**
		 * Set the public chart properties. This is done before and after the pre-render
		 * to determine margin sizes
		 */
		setChartSize: function (skipAxes) {
			var chart = this,
				inverted = chart.inverted,
				renderer = chart.renderer,
				chartWidth = chart.chartWidth,
				chartHeight = chart.chartHeight,
				optionsChart = chart.options.chart,
				spacing = chart.spacing,
				clipOffset = chart.clipOffset,
				clipX,
				clipY,
				plotLeft,
				plotTop,
				plotWidth,
				plotHeight,
				plotBorderWidth;

			chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
			chart.plotTop = plotTop = mathRound(chart.plotTop);
			chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
			chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

			chart.plotSizeX = inverted ? plotHeight : plotWidth;
			chart.plotSizeY = inverted ? plotWidth : plotHeight;
			
			chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

			// Set boxes used for alignment
			chart.spacingBox = renderer.spacingBox = {
				x: spacing[3],
				y: spacing[0],
				width: chartWidth - spacing[3] - spacing[1],
				height: chartHeight - spacing[0] - spacing[2]
			};
			chart.plotBox = renderer.plotBox = {
				x: plotLeft,
				y: plotTop,
				width: plotWidth,
				height: plotHeight
			};

			plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
			clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
			clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
			chart.clipBox = {
				x: clipX, 
				y: clipY, 
				width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), 
				height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
			};

			if (!skipAxes) {
				each(chart.axes, function (axis) {
					axis.setAxisSize();
					axis.setAxisTranslation();
				});
			}
		},

		/**
		 * Initial margins before auto size margins are applied
		 */
		resetMargins: function () {
			var chart = this;

			each(marginNames, function (m, side) {
				chart[m] = pick(chart.margin[side], chart.spacing[side]);
			});
			chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
			chart.clipOffset = [0, 0, 0, 0];
		},

		/**
		 * Draw the borders and backgrounds for chart and plot area
		 */
		drawChartBox: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				renderer = chart.renderer,
				chartWidth = chart.chartWidth,
				chartHeight = chart.chartHeight,
				chartBackground = chart.chartBackground,
				plotBackground = chart.plotBackground,
				plotBorder = chart.plotBorder,
				plotBGImage = chart.plotBGImage,
				chartBorderWidth = optionsChart.borderWidth || 0,
				chartBackgroundColor = optionsChart.backgroundColor,
				plotBackgroundColor = optionsChart.plotBackgroundColor,
				plotBackgroundImage = optionsChart.plotBackgroundImage,
				plotBorderWidth = optionsChart.plotBorderWidth || 0,
				mgn,
				bgAttr,
				plotLeft = chart.plotLeft,
				plotTop = chart.plotTop,
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				plotBox = chart.plotBox,
				clipRect = chart.clipRect,
				clipBox = chart.clipBox;

			// Chart area
			mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

			if (chartBorderWidth || chartBackgroundColor) {
				if (!chartBackground) {
					
					bgAttr = {
						fill: chartBackgroundColor || NONE
					};
					if (chartBorderWidth) { // #980
						bgAttr.stroke = optionsChart.borderColor;
						bgAttr['stroke-width'] = chartBorderWidth;
					}
					chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
							optionsChart.borderRadius, chartBorderWidth)
						.attr(bgAttr)
						.addClass(PREFIX + 'background')
						.add()
						.shadow(optionsChart.shadow);

				} else { // resize
					chartBackground.animate(
						chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
					);
				}
			}


			// Plot background
			if (plotBackgroundColor) {
				if (!plotBackground) {
					chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
						.attr({
							fill: plotBackgroundColor
						})
						.add()
						.shadow(optionsChart.plotShadow);
				} else {
					plotBackground.animate(plotBox);
				}
			}
			if (plotBackgroundImage) {
				if (!plotBGImage) {
					chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
						.add();
				} else {
					plotBGImage.animate(plotBox);
				}
			}
			
			// Plot clip
			if (!clipRect) {
				chart.clipRect = renderer.clipRect(clipBox);
			} else {
				clipRect.animate({
					width: clipBox.width,
					height: clipBox.height
				});
			}

			// Plot area border
			if (plotBorderWidth) {
				if (!plotBorder) {
					chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
						.attr({
							stroke: optionsChart.plotBorderColor,
							'stroke-width': plotBorderWidth,
							fill: NONE,
							zIndex: 1
						})
						.add();
				} else {
					plotBorder.animate(
						plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative
					);
				}
			}

			// reset
			chart.isDirtyBox = false;
		},

		/**
		 * Detect whether a certain chart property is needed based on inspecting its options
		 * and series. This mainly applies to the chart.invert property, and in extensions to 
		 * the chart.angular and chart.polar properties.
		 */
		propFromSeries: function () {
			var chart = this,
				optionsChart = chart.options.chart,
				klass,
				seriesOptions = chart.options.series,
				i,
				value;
				
				
			each(['inverted', 'angular', 'polar'], function (key) {
				
				// The default series type's class
				klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
				
				// Get the value from available chart-wide properties
				value = (
					chart[key] || // 1. it is set before
					optionsChart[key] || // 2. it is set in the options
					(klass && klass.prototype[key]) // 3. it's default series class requires it
				);
		
				// 4. Check if any the chart's series require it
				i = seriesOptions && seriesOptions.length;
				while (!value && i--) {
					klass = seriesTypes[seriesOptions[i].type];
					if (klass && klass.prototype[key]) {
						value = true;
					}
				}
		
				// Set the chart property
				chart[key] = value;	
			});
			
		},

		/**
		 * Link two or more series together. This is done initially from Chart.render,
		 * and after Chart.addSeries and Series.remove.
		 */
		linkSeries: function () {
			var chart = this,
				chartSeries = chart.series;

			// Reset links
			each(chartSeries, function (series) {
				series.linkedSeries.length = 0;
			});

			// Apply new links
			each(chartSeries, function (series) {
				var linkedTo = series.options.linkedTo;
				if (isString(linkedTo)) {
					if (linkedTo === ':previous') {
						linkedTo = chart.series[series.index - 1];
					} else {
						linkedTo = chart.get(linkedTo);
					}
					if (linkedTo) {
						linkedTo.linkedSeries.push(series);
						series.linkedParent = linkedTo;
					}
				}
			});
		},

		/**
		 * Render series for the chart
		 */
		renderSeries: function () {
			each(this.series, function (serie) {
				serie.translate();
				serie.render();
			});
		},
			
		/**
		 * Render labels for the chart
		 */
		renderLabels: function () {
			var chart = this,
				labels = chart.options.labels;
			if (labels.items) {
				each(labels.items, function (label) {
					var style = extend(labels.style, label.style),
						x = pInt(style.left) + chart.plotLeft,
						y = pInt(style.top) + chart.plotTop + 12;

					// delete to prevent rewriting in IE
					delete style.left;
					delete style.top;

					chart.renderer.text(
						label.html,
						x,
						y
					)
					.attr({ zIndex: 2 })
					.css(style)
					.add();

				});
			}
		},

		/**
		 * Render all graphics for the chart
		 */
		render: function () {
			var chart = this,
				axes = chart.axes,
				renderer = chart.renderer,
				options = chart.options,
				tempWidth,
				tempHeight,
				redoHorizontal,
				redoVertical;

			// Title
			chart.setTitle();


			// Legend
			chart.legend = new Legend(chart, options.legend);

			chart.getStacks(); // render stacks

			// Get chart margins
			chart.getMargins(true);
			chart.setChartSize();

			// Record preliminary dimensions for later comparison
			tempWidth = chart.plotWidth;
			tempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels

			// Get margins by pre-rendering axes
			each(axes, function (axis) {
				axis.setScale();
			});
			chart.getAxisMargins();

			// If the plot area size has changed significantly, calculate tick positions again
			redoHorizontal = tempWidth / chart.plotWidth > 1.2;
			redoVertical = tempHeight / chart.plotHeight > 1.1;

			if (redoHorizontal || redoVertical) {

				chart.maxTicks = null; // reset for second pass
				each(axes, function (axis) {
					if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
						axis.setTickInterval(true); // update to reflect the new margins
					}
				});
				chart.getMargins(); // second pass to check for new labels
			}

			// Draw the borders and backgrounds
			chart.drawChartBox();		


			// Axes
			if (chart.hasCartesianSeries) {
				each(axes, function (axis) {
					axis.render();
				});
			}

			// The series
			if (!chart.seriesGroup) {
				chart.seriesGroup = renderer.g('series-group')
					.attr({ zIndex: 3 })
					.add();
			}
			chart.renderSeries();

			// Labels
			chart.renderLabels();

			// Credits
			chart.showCredits(options.credits);

			// Set flag
			chart.hasRendered = true;

		},

		/**
		 * Show chart credits based on config options
		 */
		showCredits: function (credits) {
			if (credits.enabled && !this.credits) {
				this.credits = this.renderer.text(
					credits.text,
					0,
					0
				)
				.on('click', function () {
					if (credits.href) {
						location.href = credits.href;
					}
				})
				.attr({
					align: credits.position.align,
					zIndex: 8
				})
				.css(credits.style)
				.add()
				.align(credits.position);
			}
		},

		/**
		 * Clean up memory usage
		 */
		destroy: function () {
			var chart = this,
				axes = chart.axes,
				series = chart.series,
				container = chart.container,
				i,
				parentNode = container && container.parentNode;
				
			// fire the chart.destoy event
			fireEvent(chart, 'destroy');
			
			// Delete the chart from charts lookup array
			charts[chart.index] = UNDEFINED;
			chartCount--;
			chart.renderTo.removeAttribute('data-highcharts-chart');

			// remove events
			removeEvent(chart);

			// ==== Destroy collections:
			// Destroy axes
			i = axes.length;
			while (i--) {
				axes[i] = axes[i].destroy();
			}

			// Destroy each series
			i = series.length;
			while (i--) {
				series[i] = series[i].destroy();
			}

			// ==== Destroy chart properties:
			each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 
					'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', 
					'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
				var prop = chart[name];

				if (prop && prop.destroy) {
					chart[name] = prop.destroy();
				}
			});

			// remove container and all SVG
			if (container) { // can break in IE when destroyed before finished loading
				container.innerHTML = '';
				removeEvent(container);
				if (parentNode) {
					discardElement(container);
				}

			}

			// clean it all up
			for (i in chart) {
				delete chart[i];
			}

		},


		/**
		 * VML namespaces can't be added until after complete. Listening
		 * for Perini's doScroll hack is not enough.
		 */
		isReadyToRender: function () {
			var chart = this;

			// Note: in spite of JSLint's complaints, win == win.top is required
			/*jslint eqeq: true*/
			if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {
			/*jslint eqeq: false*/
				if (useCanVG) {
					// Delay rendering until canvg library is downloaded and ready
					CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
				} else {
					doc.attachEvent('onreadystatechange', function () {
						doc.detachEvent('onreadystatechange', chart.firstRender);
						if (doc.readyState === 'complete') {
							chart.firstRender();
						}
					});
				}
				return false;
			}
			return true;
		},

		/**
		 * Prepare for first rendering after all data are loaded
		 */
		firstRender: function () {
			var chart = this,
				options = chart.options,
				callback = chart.callback;

			// Check whether the chart is ready to render
			if (!chart.isReadyToRender()) {
				return;
			}

			// Create the container
			chart.getContainer();

			// Run an early event after the container and renderer are established
			fireEvent(chart, 'init');

			
			chart.resetMargins();
			chart.setChartSize();

			// Set the common chart properties (mainly invert) from the given series
			chart.propFromSeries();

			// get axes
			chart.getAxes();

			// Initialize the series
			each(options.series || [], function (serieOptions) {
				chart.initSeries(serieOptions);
			});

			chart.linkSeries();

			// Run an event after axes and series are initialized, but before render. At this stage,
			// the series data is indexed and cached in the xData and yData arrays, so we can access
			// those before rendering. Used in Highstock. 
			fireEvent(chart, 'beforeRender'); 

			// depends on inverted and on margins being set
			if (Highcharts.Pointer) {
				chart.pointer = new Pointer(chart, options);
			}

			chart.render();

			// add canvas
			chart.renderer.draw();
			// run callbacks
			if (callback) {
				callback.apply(chart, [chart]);
			}
			each(chart.callbacks, function (fn) {
				if (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)
					fn.apply(chart, [chart]);
				}
			});
			
			// Fire the load event
			fireEvent(chart, 'load');		
			
			// If the chart was rendered outside the top container, put it back in (#3679)
			chart.cloneRenderTo(true);

		},

		/**
		* Creates arrays for spacing and margin from given options.
		*/
		splashArray: function (target, options) {
			var oVar = options[target],
				tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

			return [pick(options[target + 'Top'], tArray[0]),
					pick(options[target + 'Right'], tArray[1]),
					pick(options[target + 'Bottom'], tArray[2]),
					pick(options[target + 'Left'], tArray[3])];
		}
	}; // end Chart

	var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
		/**
		 * Get the center of the pie based on the size and center options relative to the  
		 * plot area. Borrowed by the polar and gauge series types.
		 */
		getCenter: function () {
			
			var options = this.options,
				chart = this.chart,
				slicingRoom = 2 * (options.slicedOffset || 0),
				handleSlicingRoom,
				plotWidth = chart.plotWidth - 2 * slicingRoom,
				plotHeight = chart.plotHeight - 2 * slicingRoom,
				centerOption = options.center,
				positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
				smallestSize = mathMin(plotWidth, plotHeight),
				isPercent,
				i,
				value;

			for (i = 0; i < 4; ++i) {
				value = positions[i];
				isPercent = /%$/.test(value);
				handleSlicingRoom = i < 2 || (i === 2 && isPercent);
				positions[i] = (isPercent ?
					// i == 0: centerX, relative to width
					// i == 1: centerY, relative to height
					// i == 2: size, relative to smallestSize
					// i == 3: innerSize, relative to size
					[plotWidth, plotHeight, smallestSize, positions[2]][i] *
						pInt(value) / 100 :
					pInt(value)) + (handleSlicingRoom ? slicingRoom : 0);
			}
			return positions;
		}
	};

	/**
	 * The Point object and prototype. Inheritable and used as base for PiePoint
	 */
	var Point = function () {};
	Point.prototype = {

		/**
		 * Initialize the point
		 * @param {Object} series The series object containing this point
		 * @param {Object} options The data in either number, array or object format
		 */
		init: function (series, options, x) {

			var point = this,
				colors;
			point.series = series;
			point.color = series.color; // #3445
			point.applyOptions(options, x);
			point.pointAttr = {};

			if (series.options.colorByPoint) {
				colors = series.options.colors || series.chart.options.colors;
				point.color = point.color || colors[series.colorCounter++];
				// loop back to zero
				if (series.colorCounter === colors.length) {
					series.colorCounter = 0;
				}
			}

			series.chart.pointCount++;
			return point;
		},
		/**
		 * Apply the options containing the x and y data and possible some extra properties.
		 * This is called on point init or from point.update.
		 *
		 * @param {Object} options
		 */
		applyOptions: function (options, x) {
			var point = this,
				series = point.series,
				pointValKey = series.options.pointValKey || series.pointValKey;

			options = Point.prototype.optionsToObject.call(this, options);

			// copy options directly to point
			extend(point, options);
			point.options = point.options ? extend(point.options, options) : options;

			// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
			if (pointValKey) {
				point.y = point[pointValKey];
			}

			// If no x is set by now, get auto incremented value. All points must have an
			// x value, however the y value can be null to create a gap in the series
			if (point.x === UNDEFINED && series) {
				point.x = x === UNDEFINED ? series.autoIncrement() : x;
			}

			return point;
		},

		/**
		 * Transform number or array configs into objects
		 */
		optionsToObject: function (options) {
			var ret = {},
				series = this.series,
				pointArrayMap = series.pointArrayMap || ['y'],
				valueCount = pointArrayMap.length,
				firstItemType,
				i = 0,
				j = 0;

			if (typeof options === 'number' || options === null) {
				ret[pointArrayMap[0]] = options;

			} else if (isArray(options)) {
				// with leading x value
				if (options.length > valueCount) {
					firstItemType = typeof options[0];
					if (firstItemType === 'string') {
						ret.name = options[0];
					} else if (firstItemType === 'number') {
						ret.x = options[0];
					}
					i++;
				}
				while (j < valueCount) {
					ret[pointArrayMap[j++]] = options[i++];
				}
			} else if (typeof options === 'object') {
				ret = options;

				// This is the fastest way to detect if there are individual point dataLabels that need
				// to be considered in drawDataLabels. These can only occur in object configs.
				if (options.dataLabels) {
					series._hasPointLabels = true;
				}

				// Same approach as above for markers
				if (options.marker) {
					series._hasPointMarkers = true;
				}
			}
			return ret;
		},

		/**
		 * Destroy a point to clear memory. Its reference still stays in series.data.
		 */
		destroy: function () {
			var point = this,
				series = point.series,
				chart = series.chart,
				hoverPoints = chart.hoverPoints,
				prop;

			chart.pointCount--;

			if (hoverPoints) {
				point.setState();
				erase(hoverPoints, point);
				if (!hoverPoints.length) {
					chart.hoverPoints = null;
				}

			}
			if (point === chart.hoverPoint) {
				point.onMouseOut();
			}

			// remove all events
			if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
				removeEvent(point);
				point.destroyElements();
			}

			if (point.legendItem) { // pies have legend items
				chart.legend.destroyItem(point);
			}

			for (prop in point) {
				point[prop] = null;
			}


		},

		/**
		 * Destroy SVG elements associated with the point
		 */
		destroyElements: function () {
			var point = this,
				props = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],
				prop,
				i = 6;
			while (i--) {
				prop = props[i];
				if (point[prop]) {
					point[prop] = point[prop].destroy();
				}
			}
		},

		/**
		 * Return the configuration hash needed for the data label and tooltip formatters
		 */
		getLabelConfig: function () {
			var point = this;
			return {
				x: point.category,
				y: point.y,
				key: point.name || point.category,
				series: point.series,
				point: point,
				percentage: point.percentage,
				total: point.total || point.stackTotal
			};
		},	

		/**
		 * Extendable method for formatting each point's tooltip line
		 *
		 * @return {String} A string to be concatenated in to the common tooltip text
		 */
		tooltipFormatter: function (pointFormat) {

			// Insert options for valueDecimals, valuePrefix, and valueSuffix
			var series = this.series,
				seriesTooltipOptions = series.tooltipOptions,
				valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
				valuePrefix = seriesTooltipOptions.valuePrefix || '',
				valueSuffix = seriesTooltipOptions.valueSuffix || '';

			// Loop over the point array map and replace unformatted values with sprintf formatting markup
			each(series.pointArrayMap || ['y'], function (key) {
				key = '{point.' + key; // without the closing bracket
				if (valuePrefix || valueSuffix) {
					pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
				}
				pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
			});

			return format(pointFormat, {
				point: this,
				series: this.series
			});
		},

		/**
		 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
		 * causes a name clash in MooTools
		 * @param {String} eventType
		 * @param {Object} eventArgs Additional event arguments
		 * @param {Function} defaultFunction Default event handler
		 */
		firePointEvent: function (eventType, eventArgs, defaultFunction) {
			var point = this,
				series = this.series,
				seriesOptions = series.options;

			// load event handlers on demand to save time on mouseover/out
			if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
				this.importEvents();
			}

			// add default handler if in selection mode
			if (eventType === 'click' && seriesOptions.allowPointSelect) {
				defaultFunction = function (event) {
					// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
					point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
				};
			}

			fireEvent(this, eventType, eventArgs, defaultFunction);
		}
	};/**
	 * @classDescription The base function which all other series types inherit from. The data in the series is stored
	 * in various arrays.
	 *
	 * - First, series.options.data contains all the original config options for
	 * each point whether added by options or methods like series.addPoint.
	 * - Next, series.data contains those values converted to points, but in case the series data length
	 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
	 * only contains the points that have been created on demand.
	 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
	 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
	 * compared to series.data and series.options.data. If however the series data is grouped, these can't
	 * be correlated one to one.
	 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
	 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
	 *
	 * @param {Object} chart
	 * @param {Object} options
	 */
	var Series = Highcharts.Series = function () {};

	Series.prototype = {

		isCartesian: true,
		type: 'line',
		pointClass: Point,
		sorted: true, // requires the data to be sorted
		requireSorting: true,
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'lineColor',
			'stroke-width': 'lineWidth',
			fill: 'fillColor',
			r: 'radius'
		},
		axisTypes: ['xAxis', 'yAxis'],
		colorCounter: 0,
		parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
		init: function (chart, options) {
			var series = this,
				eventType,
				events,
				chartSeries = chart.series,
				sortByIndex = function (a, b) {
					return pick(a.options.index, a._i) - pick(b.options.index, b._i);
				};

			series.chart = chart;
			series.options = options = series.setOptions(options); // merge with plotOptions
			series.linkedSeries = [];

			// bind the axes
			series.bindAxes();

			// set some variables
			extend(series, {
				name: options.name,
				state: NORMAL_STATE,
				pointAttr: {},
				visible: options.visible !== false, // true by default
				selected: options.selected === true // false by default
			});

			// special
			if (useCanVG) {
				options.animation = false;
			}

			// register event listeners
			events = options.events;
			for (eventType in events) {
				addEvent(series, eventType, events[eventType]);
			}
			if (
				(events && events.click) ||
				(options.point && options.point.events && options.point.events.click) ||
				options.allowPointSelect
			) {
				chart.runTrackerClick = true;
			}

			series.getColor();
			series.getSymbol();

			// Set the data
			each(series.parallelArrays, function (key) {
				series[key + 'Data'] = [];
			});
			series.setData(options.data, false);

			// Mark cartesian
			if (series.isCartesian) {
				chart.hasCartesianSeries = true;
			}

			// Register it in the chart
			chartSeries.push(series);
			series._i = chartSeries.length - 1;

			// Sort series according to index option (#248, #1123, #2456)
			stableSort(chartSeries, sortByIndex);
			if (this.yAxis) {
				stableSort(this.yAxis.series, sortByIndex);
			}

			each(chartSeries, function (series, i) {
				series.index = i;
				series.name = series.name || 'Series ' + (i + 1);
			});

		},

		/**
		 * Set the xAxis and yAxis properties of cartesian series, and register the series
		 * in the axis.series array
		 */
		bindAxes: function () {
			var series = this,
				seriesOptions = series.options,
				chart = series.chart,
				axisOptions;

			each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

				each(chart[AXIS], function (axis) { // loop through the chart's axis objects
					axisOptions = axis.options;

					// apply if the series xAxis or yAxis option mathches the number of the
					// axis, or if undefined, use the first axis
					if ((seriesOptions[AXIS] === axisOptions.index) ||
							(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

						// register this series in the axis.series lookup
						axis.series.push(series);

						// set this series.xAxis or series.yAxis reference
						series[AXIS] = axis;

						// mark dirty for redraw
						axis.isDirty = true;
					}
				});

				// The series needs an X and an Y axis
				if (!series[AXIS] && series.optionalAxis !== AXIS) {
					error(18, true);
				}

			});
		},

		/**
		 * For simple series types like line and column, the data values are held in arrays like
		 * xData and yData for quick lookup to find extremes and more. For multidimensional series
		 * like bubble and map, this can be extended with arrays like zData and valueData by
		 * adding to the series.parallelArrays array.
		 */
		updateParallelArrays: function (point, i) {
			var series = point.series,
				args = arguments,
				fn = typeof i === 'number' ?
					 // Insert the value in the given position
					function (key) {
						var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
						series[key + 'Data'][i] = val;
					} :
					// Apply the method specified in i with the following arguments as arguments
					function (key) {
						Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
					};

			each(series.parallelArrays, fn);
		},

		/**
		 * Return an auto incremented x value based on the pointStart and pointInterval options.
		 * This is only used if an x value is not given for the point that calls autoIncrement.
		 */
		autoIncrement: function () {

			var options = this.options,
				xIncrement = this.xIncrement,
				date,
				pointInterval,
				pointIntervalUnit = options.pointIntervalUnit;
			
			xIncrement = pick(xIncrement, options.pointStart, 0);
			
			this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
			
			// Added code for pointInterval strings
			if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {
				date = new Date(xIncrement);
				date = (pointIntervalUnit === 'month') ?
					+date[setMonth](date[getMonth]() + pointInterval) :
					+date[setFullYear](date[getFullYear]() + pointInterval);
				pointInterval = date - xIncrement;
			}
			
			this.xIncrement = xIncrement + pointInterval;
			return xIncrement;
		},

		/**
		 * Divide the series data into segments divided by null values.
		 */
		getSegments: function () {
			var series = this,
				lastNull = -1,
				segments = [],
				i,
				points = series.points,
				pointsLength = points.length;

			if (pointsLength) { // no action required for []

				// if connect nulls, just remove null points
				if (series.options.connectNulls) {
					i = pointsLength;
					while (i--) {
						if (points[i].y === null) {
							points.splice(i, 1);
						}
					}
					if (points.length) {
						segments = [points];
					}

				// else, split on null points
				} else {
					each(points, function (point, i) {
						if (point.y === null) {
							if (i > lastNull + 1) {
								segments.push(points.slice(lastNull + 1, i));
							}
							lastNull = i;
						} else if (i === pointsLength - 1) { // last value
							segments.push(points.slice(lastNull + 1, i + 1));
						}
					});
				}
			}

			// register it
			series.segments = segments;
		},

		/**
		 * Set the series options by merging from the options tree
		 * @param {Object} itemOptions
		 */
		setOptions: function (itemOptions) {
			var chart = this.chart,
				chartOptions = chart.options,
				plotOptions = chartOptions.plotOptions,
				userOptions = chart.userOptions || {},
				userPlotOptions = userOptions.plotOptions || {},
				typeOptions = plotOptions[this.type],
				options,
				zones;

			this.userOptions = itemOptions;

			// General series options take precedence over type options because otherwise, default
			// type options like column.animation would be overwritten by the general option.
			// But issues have been raised here (#3881), and the solution may be to distinguish 
			// between default option and userOptions like in the tooltip below.
			options = merge(
				typeOptions,
				plotOptions.series,
				itemOptions
			);

			// The tooltip options are merged between global and series specific options
			this.tooltipOptions = merge(
				defaultOptions.tooltip,
				defaultOptions.plotOptions[this.type].tooltip,
				userOptions.tooltip,
				userPlotOptions.series && userPlotOptions.series.tooltip,
				userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
				itemOptions.tooltip
			);

			// Delete marker object if not allowed (#1125)
			if (typeOptions.marker === null) {
				delete options.marker;
			}

			// Handle color zones
			this.zoneAxis = options.zoneAxis;
			zones = this.zones = (options.zones || []).slice();
			if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
				zones.push({
					value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
					color: options.negativeColor,
					fillColor: options.negativeFillColor
				});
			}
			if (zones.length) { // Push one extra zone for the rest
				if (defined(zones[zones.length - 1].value)) {
					zones.push({
						color: this.color,
						fillColor: this.fillColor
					});
				}
			}
			return options;
		},

		getCyclic: function (prop, value, defaults) {
			var i,
				userOptions = this.userOptions,
				indexName = '_' + prop + 'Index',
				counterName = prop + 'Counter';

			if (!value) {
				if (defined(userOptions[indexName])) { // after Series.update()
					i = userOptions[indexName];
				} else {
					userOptions[indexName] = i = this.chart[counterName] % defaults.length;
					this.chart[counterName] += 1;
				}
				value = defaults[i];
			}
			this[prop] = value;
		},

		/**
		 * Get the series' color
		 */
		getColor: function () {
			if (!this.options.colorByPoint) {
				this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
			}
		},
		/**
		 * Get the series' symbol
		 */
		getSymbol: function () {
			var seriesMarkerOption = this.options.marker;

			this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

			// don't substract radius in image symbols (#604)
			if (/^url/.test(this.symbol)) {
				seriesMarkerOption.radius = 0;
			}
		},

		drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

		/**
		 * Replace the series data with a new set of data
		 * @param {Object} data
		 * @param {Object} redraw
		 */
		setData: function (data, redraw, animation, updatePoints) {
			var series = this,
				oldData = series.points,
				oldDataLength = (oldData && oldData.length) || 0,
				dataLength,
				options = series.options,
				chart = series.chart,
				firstPoint = null,
				xAxis = series.xAxis,
				hasCategories = xAxis && !!xAxis.categories,
				i,
				turboThreshold = options.turboThreshold,
				pt,
				xData = this.xData,
				yData = this.yData,
				pointArrayMap = series.pointArrayMap,
				valueCount = pointArrayMap && pointArrayMap.length;

			data = data || [];
			dataLength = data.length;
			redraw = pick(redraw, true);

			// If the point count is the same as is was, just run Point.update which is
			// cheaper, allows animation, and keeps references to points.
			if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
				each(data, function (point, i) {
					oldData[i].update(point, false, null, false);
				});

			} else {

				// Reset properties
				series.xIncrement = null;
				series.pointRange = hasCategories ? 1 : options.pointRange;

				series.colorCounter = 0; // for series with colorByPoint (#1547)
				
				// Update parallel arrays
				each(this.parallelArrays, function (key) {
					series[key + 'Data'].length = 0;
				});

				// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
				// first value is tested, and we assume that all the rest are defined the same
				// way. Although the 'for' loops are similar, they are repeated inside each
				// if-else conditional for max performance.
				if (turboThreshold && dataLength > turboThreshold) {

					// find the first non-null point
					i = 0;
					while (firstPoint === null && i < dataLength) {
						firstPoint = data[i];
						i++;
					}


					if (isNumber(firstPoint)) { // assume all points are numbers
						var x = pick(options.pointStart, 0),
							pointInterval = pick(options.pointInterval, 1);

						for (i = 0; i < dataLength; i++) {
							xData[i] = x;
							yData[i] = data[i];
							x += pointInterval;
						}
						series.xIncrement = x;
					} else if (isArray(firstPoint)) { // assume all points are arrays
						if (valueCount) { // [x, low, high] or [x, o, h, l, c]
							for (i = 0; i < dataLength; i++) {
								pt = data[i];
								xData[i] = pt[0];
								yData[i] = pt.slice(1, valueCount + 1);
							}
						} else { // [x, y]
							for (i = 0; i < dataLength; i++) {
								pt = data[i];
								xData[i] = pt[0];
								yData[i] = pt[1];
							}
						}
					} else {
						error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
					}
				} else {
					for (i = 0; i < dataLength; i++) {
						if (data[i] !== UNDEFINED) { // stray commas in oldIE
							pt = { series: series };
							series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
							series.updateParallelArrays(pt, i);
							if (hasCategories && pt.name) {
								xAxis.names[pt.x] = pt.name; // #2046
							}
						}
					}
				}

				// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
				if (isString(yData[0])) {
					error(14, true);
				}

				series.data = [];
				series.options.data = data;
				//series.zData = zData;

				// destroy old points
				i = oldDataLength;
				while (i--) {
					if (oldData[i] && oldData[i].destroy) {
						oldData[i].destroy();
					}
				}

				// reset minRange (#878)
				if (xAxis) {
					xAxis.minRange = xAxis.userMinRange;
				}

				// redraw
				series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
				animation = false;
			}

			if (redraw) {
				chart.redraw(animation);
			}
		},

		/**
		 * Process the data by cropping away unused data points if the series is longer
		 * than the crop threshold. This saves computing time for lage series.
		 */
		processData: function (force) {
			var series = this,
				processedXData = series.xData, // copied during slice operation below
				processedYData = series.yData,
				dataLength = processedXData.length,
				croppedData,
				cropStart = 0,
				cropped,
				distance,
				closestPointRange,
				xAxis = series.xAxis,
				i, // loop variable
				options = series.options,
				cropThreshold = options.cropThreshold,
				isCartesian = series.isCartesian,
				xExtremes,
				min,
				max;

			// If the series data or axes haven't changed, don't go through this. Return false to pass
			// the message on to override methods like in data grouping.
			if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
				return false;
			}

			if (xAxis) {
				xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
				min = xExtremes.min;
				max = xExtremes.max;
			}

			// optionally filter out points outside the plot area
			if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
				
				// it's outside current extremes
				if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
					processedXData = [];
					processedYData = [];

				// only crop if it's actually spilling out
				} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
					croppedData = this.cropData(series.xData, series.yData, min, max);
					processedXData = croppedData.xData;
					processedYData = croppedData.yData;
					cropStart = croppedData.start;
					cropped = true;
				}
			}


			// Find the closest distance between processed points
			for (i = processedXData.length - 1; i >= 0; i--) {
				distance = processedXData[i] - processedXData[i - 1];
				
				if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
					closestPointRange = distance;

				// Unsorted data is not supported by the line tooltip, as well as data grouping and
				// navigation in Stock charts (#725) and width calculation of columns (#1900)
				} else if (distance < 0 && series.requireSorting) {
					error(15);
				}
			}

			// Record the properties
			series.cropped = cropped; // undefined or true
			series.cropStart = cropStart;
			series.processedXData = processedXData;
			series.processedYData = processedYData;

			if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
				series.pointRange = closestPointRange || 1;
			}
			series.closestPointRange = closestPointRange;

		},

		/**
		 * Iterate over xData and crop values between min and max. Returns object containing crop start/end
		 * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
		 */
		cropData: function (xData, yData, min, max) {
			var dataLength = xData.length,
				cropStart = 0,
				cropEnd = dataLength,
				cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
				i;

			// iterate up to find slice start
			for (i = 0; i < dataLength; i++) {
				if (xData[i] >= min) {
					cropStart = mathMax(0, i - cropShoulder);
					break;
				}
			}

			// proceed to find slice end
			for (; i < dataLength; i++) {
				if (xData[i] > max) {
					cropEnd = i + cropShoulder;
					break;
				}
			}

			return {
				xData: xData.slice(cropStart, cropEnd),
				yData: yData.slice(cropStart, cropEnd),
				start: cropStart,
				end: cropEnd
			};
		},


		/**
		 * Generate the data point after the data has been processed by cropping away
		 * unused points and optionally grouped in Highcharts Stock.
		 */
		generatePoints: function () {
			var series = this,
				options = series.options,
				dataOptions = options.data,
				data = series.data,
				dataLength,
				processedXData = series.processedXData,
				processedYData = series.processedYData,
				pointClass = series.pointClass,
				processedDataLength = processedXData.length,
				cropStart = series.cropStart || 0,
				cursor,
				hasGroupedData = series.hasGroupedData,
				point,
				points = [],
				i;

			if (!data && !hasGroupedData) {
				var arr = [];
				arr.length = dataOptions.length;
				data = series.data = arr;
			}

			for (i = 0; i < processedDataLength; i++) {
				cursor = cropStart + i;
				if (!hasGroupedData) {
					if (data[cursor]) {
						point = data[cursor];
					} else if (dataOptions[cursor] !== UNDEFINED) { // #970
						data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
					}
					points[i] = point;
				} else {
					// splat the y data in case of ohlc data array
					points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
				}
				points[i].index = cursor; // For faster access in Point.update
			}

			// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
			// swithching view from non-grouped data to grouped data (#637)
			if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
				for (i = 0; i < dataLength; i++) {
					if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
						i += processedDataLength;
					}
					if (data[i]) {
						data[i].destroyElements();
						data[i].plotX = UNDEFINED; // #1003
					}
				}
			}

			series.data = data;
			series.points = points;
		},

		/**
		 * Calculate Y extremes for visible data
		 */
		getExtremes: function (yData) {
			var xAxis = this.xAxis,
				yAxis = this.yAxis,
				xData = this.processedXData,
				yDataLength,
				activeYData = [],
				activeCounter = 0,
				xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
				xMin = xExtremes.min,
				xMax = xExtremes.max,
				validValue,
				withinRange,
				dataMin,
				dataMax,
				x,
				y,
				i,
				j;

			yData = yData || this.stackedYData || this.processedYData;
			yDataLength = yData.length;

			for (i = 0; i < yDataLength; i++) {

				x = xData[i];
				y = yData[i];

				// For points within the visible range, including the first point outside the
				// visible range, consider y extremes
				validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
				withinRange = this.getExtremesFromAll || this.cropped || ((xData[i + 1] || x) >= xMin &&
					(xData[i - 1] || x) <= xMax);

				if (validValue && withinRange) {

					j = y.length;
					if (j) { // array, like ohlc or range data
						while (j--) {
							if (y[j] !== null) {
								activeYData[activeCounter++] = y[j];
							}
						}
					} else {
						activeYData[activeCounter++] = y;
					}
				}
			}
			this.dataMin = pick(dataMin, arrayMin(activeYData));
			this.dataMax = pick(dataMax, arrayMax(activeYData));
		},

		/**
		 * Translate data points from raw data values to chart specific positioning data
		 * needed later in drawPoints, drawGraph and drawTracker.
		 */
		translate: function () {
			if (!this.processedXData) { // hidden series
				this.processData();
			}
			this.generatePoints();
			var series = this,
				options = series.options,
				stacking = options.stacking,
				xAxis = series.xAxis,
				categories = xAxis.categories,
				yAxis = series.yAxis,
				points = series.points,
				dataLength = points.length,
				hasModifyValue = !!series.modifyValue,
				i,
				pointPlacement = options.pointPlacement,
				dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
				threshold = options.threshold,
				plotX,
				plotY,
				lastPlotX,
				closestPointRangePx = Number.MAX_VALUE;

			// Translate each point
			for (i = 0; i < dataLength; i++) {
				var point = points[i],
					xValue = point.x,
					yValue = point.y,
					yBottom = point.low,
					stack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey],
					pointStack,
					stackValues;

				// Discard disallowed y values for log axes (#3434)
				if (yAxis.isLog && yValue !== null && yValue <= 0) {
					point.y = yValue = null;
					error(10);
				}

				// Get the plotX translation
				point.plotX = plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags'); // Math.round fixes #591


				// Calculate the bottom y value for stacked series
				if (stacking && series.visible && stack && stack[xValue]) {

					pointStack = stack[xValue];
					stackValues = pointStack.points[series.index + ',' + i];
					yBottom = stackValues[0];
					yValue = stackValues[1];

					if (yBottom === 0) {
						yBottom = pick(threshold, yAxis.min);
					}
					if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
						yBottom = null;
					}

					point.total = point.stackTotal = pointStack.total;
					point.percentage = pointStack.total && (point.y / pointStack.total * 100);
					point.stackY = yValue;

					// Place the stack label
					pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

				}

				// Set translated yBottom or remove it
				point.yBottom = defined(yBottom) ?
					yAxis.translate(yBottom, 0, 1, 0, 1) :
					null;

				// general hook, used for Highstock compare mode
				if (hasModifyValue) {
					yValue = series.modifyValue(yValue, point);
				}

				// Set the the plotY value, reset it for redraws
				point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
					mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
					UNDEFINED;
				point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
					plotX >= 0 && plotX <= xAxis.len;


				// Set client related positions for mouse tracking
				point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514

				point.negative = point.y < (threshold || 0);

				// some API data
				point.category = categories && categories[point.x] !== UNDEFINED ?
					categories[point.x] : point.x;

				// Determine auto enabling of markers (#3635)
				if (i) {
					closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
				}
				lastPlotX = plotX;

			}

			series.closestPointRangePx = closestPointRangePx;

			// now that we have the cropped data, build the segments
			series.getSegments();
		},

		/**
		 * Set the clipping for the series. For animated series it is called twice, first to initiate
		 * animating the clip then the second time without the animation to set the final clip.
		 */
		setClip: function (animation) {
			var chart = this.chart,
				renderer = chart.renderer,
				inverted = chart.inverted,
				seriesClipBox = this.clipBox,
				clipBox = seriesClipBox || chart.clipBox,
				sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),
				clipRect = chart[sharedClipKey],
				markerClipRect = chart[sharedClipKey + 'm'];

			// If a clipping rectangle with the same properties is currently present in the chart, use that.
			if (!clipRect) {

				// When animation is set, prepare the initial positions
				if (animation) { 
					clipBox.width = 0;

					chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
						-99, // include the width of the first marker
						inverted ? -chart.plotLeft : -chart.plotTop,
						99,
						inverted ? chart.chartWidth : chart.chartHeight
					);
				}
				chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
				
			}
			if (animation) {
				clipRect.count += 1;
			}

			if (this.options.clip !== false) {
				this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
				this.markerGroup.clip(markerClipRect);
				this.sharedClipKey = sharedClipKey;
			}

			// Remove the shared clipping rectancgle when all series are shown
			if (!animation) {
				clipRect.count -= 1;
				if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {
					if (!seriesClipBox) {
						chart[sharedClipKey] = chart[sharedClipKey].destroy();
					}
					if (chart[sharedClipKey + 'm']) {
						chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
					}
				}
			}
		},

		/**
		 * Animate in the series
		 */
		animate: function (init) {
			var series = this,
				chart = series.chart,
				clipRect,
				animation = series.options.animation,
				sharedClipKey;

			// Animation option is set to true
			if (animation && !isObject(animation)) {
				animation = defaultPlotOptions[series.type].animation;
			}

			// Initialize the animation. Set up the clipping rectangle.
			if (init) {

				series.setClip(animation);

			// Run the animation
			} else {
				sharedClipKey = this.sharedClipKey;
				clipRect = chart[sharedClipKey];
				if (clipRect) {
					clipRect.animate({
						width: chart.plotSizeX
					}, animation);
				}
				if (chart[sharedClipKey + 'm']) {
					chart[sharedClipKey + 'm'].animate({
						width: chart.plotSizeX + 99
					}, animation);
				}

				// Delete this function to allow it only once
				series.animate = null;
	 
			}
		},

		/**
		 * This runs after animation to land on the final plot clipping
		 */
		afterAnimate: function () {
			this.setClip();
			fireEvent(this, 'afterAnimate');
		},

		/**
		 * Draw the markers
		 */
		drawPoints: function () {
			var series = this,
				pointAttr,
				points = series.points,
				chart = series.chart,
				plotX,
				plotY,
				i,
				point,
				radius,
				symbol,
				isImage,
				graphic,
				options = series.options,
				seriesMarkerOptions = options.marker,
				seriesPointAttr = series.pointAttr[''],
				pointMarkerOptions,
				hasPointMarker,
				enabled,
				isInside,
				markerGroup = series.markerGroup,
				xAxis = series.xAxis,
				globallyEnabled = pick(
					seriesMarkerOptions.enabled, 
					xAxis.isRadial,
					series.closestPointRangePx > 2 * seriesMarkerOptions.radius
				);

			if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

				i = points.length;
				while (i--) {
					point = points[i];
					plotX = mathFloor(point.plotX); // #1843
					plotY = point.plotY;
					graphic = point.graphic;
					pointMarkerOptions = point.marker || {};
					hasPointMarker = !!point.marker;
					enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
					isInside = point.isInside;

					// only draw the point if y is defined
					if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

						// shortcuts
						pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
						radius = pointAttr.r;
						symbol = pick(pointMarkerOptions.symbol, series.symbol);
						isImage = symbol.indexOf('url') === 0;

						if (graphic) { // update
							graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
								.animate(extend({
									x: plotX - radius,
									y: plotY - radius
								}, graphic.symbolName ? { // don't apply to image symbols #507
									width: 2 * radius,
									height: 2 * radius
								} : {}));
						} else if (isInside && (radius > 0 || isImage)) {
							point.graphic = graphic = chart.renderer.symbol(
								symbol,
								plotX - radius,
								plotY - radius,
								2 * radius,
								2 * radius,
								hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
							)
							.attr(pointAttr)
							.add(markerGroup);
						}

					} else if (graphic) {
						point.graphic = graphic.destroy(); // #1269
					}
				}
			}

		},

		/**
		 * Convert state properties from API naming conventions to SVG attributes
		 *
		 * @param {Object} options API options object
		 * @param {Object} base1 SVG attribute object to inherit from
		 * @param {Object} base2 Second level SVG attribute object to inherit from
		 */
		convertAttribs: function (options, base1, base2, base3) {
			var conversion = this.pointAttrToOptions,
				attr,
				option,
				obj = {};

			options = options || {};
			base1 = base1 || {};
			base2 = base2 || {};
			base3 = base3 || {};

			for (attr in conversion) {
				option = conversion[attr];
				obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
			}
			return obj;
		},

		/**
		 * Get the state attributes. Each series type has its own set of attributes
		 * that are allowed to change on a point's state change. Series wide attributes are stored for
		 * all series, and additionally point specific attributes are stored for all
		 * points with individual marker options. If such options are not defined for the point,
		 * a reference to the series wide attributes is stored in point.pointAttr.
		 */
		getAttribs: function () {
			var series = this,
				seriesOptions = series.options,
				normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
				stateOptions = normalOptions.states,
				stateOptionsHover = stateOptions[HOVER_STATE],
				pointStateOptionsHover,
				seriesColor = series.color,
				seriesNegativeColor = series.options.negativeColor,
				normalDefaults = {
					stroke: seriesColor,
					fill: seriesColor
				},
				points = series.points || [], // #927
				i,
				point,
				seriesPointAttr = [],
				pointAttr,
				pointAttrToOptions = series.pointAttrToOptions,
				hasPointSpecificOptions = series.hasPointSpecificOptions,
				defaultLineColor = normalOptions.lineColor,
				defaultFillColor = normalOptions.fillColor,
				turboThreshold = seriesOptions.turboThreshold,
				zones = series.zones,
				zoneAxis = series.zoneAxis || 'y',
				attr,
				key;

			// series type specific modifications
			if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

				// if no hover radius is given, default to normal radius + 2
				stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
				stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

			} else { // column, bar, pie

				// if no hover color is given, brighten the normal color
				stateOptionsHover.color = stateOptionsHover.color ||
					Color(stateOptionsHover.color || seriesColor)
						.brighten(stateOptionsHover.brightness).get();

				// if no hover negativeColor is given, brighten the normal negativeColor
				stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
					Color(stateOptionsHover.negativeColor || seriesNegativeColor)
						.brighten(stateOptionsHover.brightness).get();
			}

			// general point attributes for the series normal state
			seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

			// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
			each([HOVER_STATE, SELECT_STATE], function (state) {
				seriesPointAttr[state] =
						series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
			});

			// set it
			series.pointAttr = seriesPointAttr;


			// Generate the point-specific attribute collections if specific point
			// options are given. If not, create a referance to the series wide point
			// attributes
			i = points.length;
			if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
				while (i--) {
					point = points[i];
					normalOptions = (point.options && point.options.marker) || point.options;
					if (normalOptions && normalOptions.enabled === false) {
						normalOptions.radius = 0;
					}

					if (zones.length) {
						var j = 0,
							threshold = zones[j];
						while (point[zoneAxis] >= threshold.value) {				
							threshold = zones[++j];
						}
						
						point.color = point.fillColor = threshold.color;
					}

					hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

					// check if the point has specific visual options
					if (point.options) {
						for (key in pointAttrToOptions) {
							if (defined(normalOptions[pointAttrToOptions[key]])) {
								hasPointSpecificOptions = true;
							}
						}
					}

					// a specific marker config object is defined for the individual point:
					// create it's own attribute collection
					if (hasPointSpecificOptions) {
						normalOptions = normalOptions || {};
						pointAttr = [];
						stateOptions = normalOptions.states || {}; // reassign for individual point
						pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

						// Handle colors for column and pies
						if (!seriesOptions.marker) { // column, bar, point
							// If no hover color is given, brighten the normal color. #1619, #2579
							pointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
								Color(point.color)
									.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
									.get();
						}

						// normal point state inherits series wide normal state
						attr = { color: point.color }; // #868
						if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
							attr.fillColor = point.color;
						}
						if (!defaultLineColor) {
							attr.lineColor = point.color; // Bubbles take point color, line markers use white
						}
						pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

						// inherit from point normal and series hover
						pointAttr[HOVER_STATE] = series.convertAttribs(
							stateOptions[HOVER_STATE],
							seriesPointAttr[HOVER_STATE],
							pointAttr[NORMAL_STATE]
						);

						// inherit from point normal and series hover
						pointAttr[SELECT_STATE] = series.convertAttribs(
							stateOptions[SELECT_STATE],
							seriesPointAttr[SELECT_STATE],
							pointAttr[NORMAL_STATE]
						);


					// no marker config object is created: copy a reference to the series-wide
					// attribute collection
					} else {
						pointAttr = seriesPointAttr;
					}

					point.pointAttr = pointAttr;
				}
			}
		},

		/**
		 * Clear DOM objects and free up memory
		 */
		destroy: function () {
			var series = this,
				chart = series.chart,
				issue134 = /AppleWebKit\/533/.test(userAgent),
				destroy,
				i,
				data = series.data || [],
				point,
				prop,
				axis;

			// add event hook
			fireEvent(series, 'destroy');

			// remove all events
			removeEvent(series);

			// erase from axes
			each(series.axisTypes || [], function (AXIS) {
				axis = series[AXIS];
				if (axis) {
					erase(axis.series, series);
					axis.isDirty = axis.forceRedraw = true;
				}
			});

			// remove legend items
			if (series.legendItem) {
				series.chart.legend.destroyItem(series);
			}

			// destroy all points with their elements
			i = data.length;
			while (i--) {
				point = data[i];
				if (point && point.destroy) {
					point.destroy();
				}
			}
			series.points = null;

			// Clear the animation timeout if we are destroying the series during initial animation
			clearTimeout(series.animationTimeout);

			// destroy all SVGElements associated to the series
			each(['area', 'graph', 'dataLabelsGroup', 'group', 'markerGroup', 'tracker',
					'graphNeg', 'areaNeg', 'posClip', 'negClip'], function (prop) {
				if (series[prop]) {

					// issue 134 workaround
					destroy = issue134 && prop === 'group' ?
						'hide' :
						'destroy';

					series[prop][destroy]();
				}
			});

			// remove from hoverSeries
			if (chart.hoverSeries === series) {
				chart.hoverSeries = null;
			}
			erase(chart.series, series);

			// clear all members
			for (prop in series) {
				delete series[prop];
			}
		},

		/**
		 * Return the graph path of a segment
		 */
		getSegmentPath: function (segment) {
			var series = this,
				segmentPath = [],
				step = series.options.step;

			// build the segment line
			each(segment, function (point, i) {

				var plotX = point.plotX,
					plotY = point.plotY,
					lastPoint;

				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

				} else {

					// moveTo or lineTo
					segmentPath.push(i ? L : M);

					// step line?
					if (step && i) {
						lastPoint = segment[i - 1];
						if (step === 'right') {
							segmentPath.push(
								lastPoint.plotX,
								plotY
							);

						} else if (step === 'center') {
							segmentPath.push(
								(lastPoint.plotX + plotX) / 2,
								lastPoint.plotY,
								(lastPoint.plotX + plotX) / 2,
								plotY
							);

						} else {
							segmentPath.push(
								plotX,
								lastPoint.plotY
							);
						}
					}

					// normal line to next point
					segmentPath.push(
						point.plotX,
						point.plotY
					);
				}
			});

			return segmentPath;
		},

		/**
		 * Get the graph path
		 */
		getGraphPath: function () {
			var series = this,
				graphPath = [],
				segmentPath,
				singlePoints = []; // used in drawTracker

			// Divide into segments and build graph and area paths
			each(series.segments, function (segment) {

				segmentPath = series.getSegmentPath(segment);

				// add the segment to the graph, or a single point for tracking
				if (segment.length > 1) {
					graphPath = graphPath.concat(segmentPath);
				} else {
					singlePoints.push(segment[0]);
				}
			});

			// Record it for use in drawGraph and drawTracker, and return graphPath
			series.singlePoints = singlePoints;
			series.graphPath = graphPath;

			return graphPath;

		},

		/**
		 * Draw the actual graph
		 */
		drawGraph: function () {
			var series = this,
				options = this.options,
				props = [['graph', options.lineColor || this.color, options.dashStyle]],
				lineWidth = options.lineWidth,
				roundCap = options.linecap !== 'square',
				graphPath = this.getGraphPath(),
				fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph
				zones = this.zones;

			each(zones, function (threshold, i) {
				props.push(['colorGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
			});
			
			// Draw the graph
			each(props, function (prop, i) {
				var graphKey = prop[0],
					graph = series[graphKey],
					attribs;

				if (graph) {
					stop(graph); // cancel running animations, #459
					graph.animate({ d: graphPath });

				} else if ((lineWidth || fillColor) && graphPath.length) { // #1487
					attribs = {
						stroke: prop[1],
						'stroke-width': lineWidth,
						fill: fillColor,
						zIndex: 1 // #1069
					};
					if (prop[2]) {
						attribs.dashstyle = prop[2];
					} else if (roundCap) {
						attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
					}

					series[graphKey] = series.chart.renderer.path(graphPath)
						.attr(attribs)
						.add(series.group)
						.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
				}
			});
		},

		/**
		 * Clip the graphs into the positive and negative coloured graphs
		 */
		applyZones: function () {
			var series = this,
				chart = this.chart,
				renderer = chart.renderer,
				zones = this.zones,
				translatedFrom,
				translatedTo,
				clips = this.clips || [],
				clipAttr,
				graph = this.graph,
				area = this.area,
				chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
				zoneAxis = this.zoneAxis || 'y',
				axis = this[zoneAxis + 'Axis'],
				reversed = axis.reversed,
				horiz = axis.horiz,
				ignoreZones = false;

			if (zones.length && (graph || area)) {
				// The use of the Color Threshold assumes there are no gaps
				// so it is safe to hide the original graph and area
				graph.hide();
				if (area) { area.hide(); }

				// Create the clips
				each(zones, function (threshold, i) {
					translatedFrom = pick(translatedTo, (reversed ? (horiz ? chart.plotWidth : 0) : (horiz ? 0 : axis.toPixels(axis.min))));
					translatedTo = mathRound(axis.toPixels(pick(threshold.value, axis.max), true));

					if (ignoreZones) {
						translatedFrom = translatedTo = axis.toPixels(axis.max);
					}

					if (axis.isXAxis) {
						clipAttr = {
							x: reversed ? translatedTo : translatedFrom,
							y: 0,
							width: Math.abs(translatedFrom - translatedTo), 
							height: chartSizeMax
						};
						if (!horiz) {
							clipAttr.x = chart.plotHeight - clipAttr.x;
						}
					} else {
						clipAttr = {
							x: 0,
							y: reversed ? translatedFrom : translatedTo,
							width: chartSizeMax, 
							height: Math.abs(translatedFrom - translatedTo)
						};
						if (horiz) {
							clipAttr.y = chart.plotWidth - clipAttr.y;
						}
					} 

					/// VML SUPPPORT
					if (chart.inverted && renderer.isVML) {
						if (axis.isXAxis) {			
							clipAttr = {
								x: 0,
								y: reversed ? translatedFrom : translatedTo,
								height: clipAttr.width,
								width: chart.chartWidth
							};		
						} else {				
							clipAttr = {
								x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
								y: 0,
								width: clipAttr.height,
								height: chart.chartHeight
							};	
						}				
					}
					/// END OF VML SUPPORT

					if (clips[i]) {
						clips[i].animate(clipAttr);
					} else {
						clips[i] = renderer.clipRect(clipAttr);

						series['colorGraph' + i].clip(clips[i]);

						if (area) {
							series['colorArea' + i].clip(clips[i]);
						}
					}
					// if this zone extends out of the axis, ignore the others
					ignoreZones = threshold.value > axis.max;
				});
				this.clips = clips;
			}
		},

		/**
		 * Initialize and perform group inversion on series.group and series.markerGroup
		 */
		invertGroups: function () {
			var series = this,
				chart = series.chart;

			// Pie, go away (#1736)
			if (!series.xAxis) {
				return;
			}

			// A fixed size is needed for inversion to work
			function setInvert() {
				var size = {
					width: series.yAxis.len,
					height: series.xAxis.len
				};

				each(['group', 'markerGroup'], function (groupName) {
					if (series[groupName]) {
						series[groupName].attr(size).invert();
					}
				});
			}

			addEvent(chart, 'resize', setInvert); // do it on resize
			addEvent(series, 'destroy', function () {
				removeEvent(chart, 'resize', setInvert);
			});

			// Do it now
			setInvert(); // do it now

			// On subsequent render and redraw, just do setInvert without setting up events again
			series.invertGroups = setInvert;
		},

		/**
		 * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
		 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
		 */
		plotGroup: function (prop, name, visibility, zIndex, parent) {
			var group = this[prop],
				isNew = !group;

			// Generate it on first call
			if (isNew) {
				this[prop] = group = this.chart.renderer.g(name)
					.attr({
						visibility: visibility,
						zIndex: zIndex || 0.1 // IE8 needs this
					})
					.add(parent);
			}
			// Place it on first and subsequent (redraw) calls
			group[isNew ? 'attr' : 'animate'](this.getPlotBox());
			return group;
		},

		/**
		 * Get the translation and scale for the plot area of this series
		 */
		getPlotBox: function () {
			var chart = this.chart,
				xAxis = this.xAxis,
				yAxis = this.yAxis;

			// Swap axes for inverted (#2339)
			if (chart.inverted) {
				xAxis = yAxis;
				yAxis = this.xAxis;
			}
			return {
				translateX: xAxis ? xAxis.left : chart.plotLeft,
				translateY: yAxis ? yAxis.top : chart.plotTop,
				scaleX: 1, // #1623
				scaleY: 1
			};
		},

		/**
		 * Render the graph and markers
		 */
		render: function () {
			var series = this,
				chart = series.chart,
				group,
				options = series.options,
				animation = options.animation,
				// Animation doesn't work in IE8 quirks when the group div is hidden,
				// and looks bad in other oldIE
				animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,
				visibility = series.visible ? VISIBLE : HIDDEN,
				zIndex = options.zIndex,
				hasRendered = series.hasRendered,
				chartSeriesGroup = chart.seriesGroup;

			// the group
			group = series.plotGroup(
				'group',
				'series',
				visibility,
				zIndex,
				chartSeriesGroup
			);

			series.markerGroup = series.plotGroup(
				'markerGroup',
				'markers',
				visibility,
				zIndex,
				chartSeriesGroup
			);

			// initiate the animation
			if (animDuration) {
				series.animate(true);
			}

			// cache attributes for shapes
			series.getAttribs();

			// SVGRenderer needs to know this before drawing elements (#1089, #1795)
			group.inverted = series.isCartesian ? chart.inverted : false;

			// draw the graph if any
			if (series.drawGraph) {
				series.drawGraph();
				series.applyZones();
			}

			each(series.points, function (point) {
				if (point.redraw) {
					point.redraw();
				}
			});

			// draw the data labels (inn pies they go before the points)
			if (series.drawDataLabels) {
				series.drawDataLabels();
			}

			// draw the points
			if (series.visible) {
				series.drawPoints();
			}


			// draw the mouse tracking area
			if (series.drawTracker && series.options.enableMouseTracking !== false) {
				series.drawTracker();
			}

			// Handle inverted series and tracker groups
			if (chart.inverted) {
				series.invertGroups();
			}

			// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
			if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
				group.clip(chart.clipRect);
			}

			// Run the animation
			if (animDuration) {
				series.animate();
			} 

			// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
			// which should be available to the user).
			if (!hasRendered) {
				if (animDuration) {
					series.animationTimeout = setTimeout(function () {
						series.afterAnimate();
					}, animDuration);
				} else {
					series.afterAnimate();
				}
			}

			series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
			// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
			series.hasRendered = true;
		},

		/**
		 * Redraw the series after an update in the axes.
		 */
		redraw: function () {
			var series = this,
				chart = series.chart,
				wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
				wasDirty = series.isDirty,
				group = series.group,
				xAxis = series.xAxis,
				yAxis = series.yAxis;

			// reposition on resize
			if (group) {
				if (chart.inverted) {
					group.attr({
						width: chart.plotWidth,
						height: chart.plotHeight
					});
				}

				group.animate({
					translateX: pick(xAxis && xAxis.left, chart.plotLeft),
					translateY: pick(yAxis && yAxis.top, chart.plotTop)
				});
			}

			series.translate();
			series.render();
			if (wasDirtyData) {
				fireEvent(series, 'updatedData');
			}
			if (wasDirty || wasDirtyData) {			// #3945 recalculate the kdtree when dirty
				delete this.kdTree; // #3868 recalculate the kdtree with dirty data
			}
		},

		/**
		 * KD Tree && PointSearching Implementation
		 */

		kdDimensions: 1,
		kdTree: null,
		kdAxisArray: ['clientX', 'plotY'],
		kdComparer: 'distX',

		searchPoint: function (e) {
			var series = this,
				xAxis = series.xAxis,
				yAxis = series.yAxis,
				inverted = series.chart.inverted;
			
			return this.searchKDTree({
				clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
				plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
			});
		},

		buildKDTree: function () {
			var series = this,
				dimensions = series.kdDimensions;

			// Internal function
			function _kdtree(points, depth, dimensions) {
				var axis, median, length = points && points.length;

				if (length) {

					// alternate between the axis
					axis = series.kdAxisArray[depth % dimensions];

					// sort point array
					points.sort(function(a, b) {
						return a[axis] - b[axis];
					});
				
					median = Math.floor(length / 2);
					
					// build and return node
					return {
						point: points[median],
						left: _kdtree(points.slice(0, median), depth + 1, dimensions),
						right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
					};
				
				}
			}

			// Start the recursive build process with a clone of the points array and null points filtered out (#3873)
			function startRecursive() {
				var points = grep(series.points, function (point) {
					return point.y !== null;
				});
				series.kdTree = _kdtree(points, dimensions, dimensions);		
			}

			delete series.kdTree;
			
			if (series.options.kdSync) {  // For testing tooltips, don't build async
				startRecursive();
			} else {
				setTimeout(startRecursive);
			}
		},

		searchKDTree: function (point) {
			var series = this,
				kdComparer = this.kdComparer,
				kdX = this.kdAxisArray[0],
				kdY = this.kdAxisArray[1];

			// Internal function
			function _distance(p1, p2) {
				var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
					y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
					r = (x || 0) + (y || 0);
					
				return {
					distX: defined(x) ? Math.sqrt(x) : Number.MAX_VALUE,
					distY: defined(y) ? Math.sqrt(y) : Number.MAX_VALUE,
					distR: defined(r) ? Math.sqrt(r) : Number.MAX_VALUE
				};
			}
			function _search(search, tree, depth, dimensions) {
				var point = tree.point,
					axis = series.kdAxisArray[depth % dimensions],
					tdist,
					sideA,
					sideB,
					ret = point,
					nPoint1,
					nPoint2;
				point.dist = _distance(search, point);

				// Pick side based on distance to splitting point
				tdist = search[axis] - point[axis];
				sideA = tdist < 0 ? 'left' : 'right';

				// End of tree
				if (tree[sideA]) {
					nPoint1 =_search(search, tree[sideA], depth + 1, dimensions);

					ret = (nPoint1.dist[kdComparer] < ret.dist[kdComparer] ? nPoint1 : point);

					sideB = tdist < 0 ? 'right' : 'left';
					if (tree[sideB]) {
						// compare distance to current best to splitting point to decide wether to check side B or not
						if (Math.sqrt(tdist*tdist) < ret.dist[kdComparer]) {
							nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
							ret = (nPoint2.dist[kdComparer] < ret.dist[kdComparer] ? nPoint2 : ret);
						}
					}
				}
				return ret;
			}

			if (!this.kdTree) {
				this.buildKDTree();
			}

			if (this.kdTree) {
				return _search(point, 
					this.kdTree, this.kdDimensions, this.kdDimensions);
			}
		}

	}; // end Series prototype

	/**
	 * The class for stack items
	 */
	function StackItem(axis, options, isNegative, x, stackOption) {
		
		var inverted = axis.chart.inverted;

		this.axis = axis;

		// Tells if the stack is negative
		this.isNegative = isNegative;

		// Save the options to be able to style the label
		this.options = options;

		// Save the x value to be able to position the label later
		this.x = x;

		// Initialize total value
		this.total = null;

		// This will keep each points' extremes stored by series.index and point index
		this.points = {};

		// Save the stack option on the series configuration object, and whether to treat it as percent
		this.stack = stackOption;

		// The align options and text align varies on whether the stack is negative and
		// if the chart is inverted or not.
		// First test the user supplied value, then use the dynamic.
		this.alignOptions = {
			align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
			verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
			y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
			x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
		};

		this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
	}

	StackItem.prototype = {
		destroy: function () {
			destroyObjectProperties(this, this.axis);
		},

		/**
		 * Renders the stack total label and adds it to the stack label group.
		 */
		render: function (group) {
			var options = this.options,
				formatOption = options.format,
				str = formatOption ?
					format(formatOption, this) : 
					options.formatter.call(this);  // format the text in the label

			// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
			if (this.label) {
				this.label.attr({text: str, visibility: HIDDEN});
			// Create new label
			} else {
				this.label =
					this.axis.chart.renderer.text(str, null, null, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries
						.css(options.style)				// apply style
						.attr({
							align: this.textAlign,				// fix the text-anchor
							rotation: options.rotation,	// rotation
							visibility: HIDDEN					// hidden until setOffset is called
						})				
						.add(group);							// add to the labels-group
			}
		},

		/**
		 * Sets the offset that the stack has from the x value and repositions the label.
		 */
		setOffset: function (xOffset, xWidth) {
			var stackItem = this,
				axis = stackItem.axis,
				chart = axis.chart,
				inverted = chart.inverted,
				neg = this.isNegative,							// special treatment is needed for negative stacks
				y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
				yZero = axis.translate(0),						// stack origin
				h = mathAbs(y - yZero),							// stack height
				x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position
				plotHeight = chart.plotHeight,
				stackBox = {	// this is the box for the complete stack
					x: inverted ? (neg ? y : y - h) : x,
					y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
					width: inverted ? h : xWidth,
					height: inverted ? xWidth : h
				},
				label = this.label,
				alignAttr;
			
			if (label) {
				label.align(this.alignOptions, null, stackBox);	// align the label to the box
					
				// Set visibility (#678)
				alignAttr = label.alignAttr;
				label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
			}
		}
	};


	// Stacking methods defined on the Axis prototype

	/**
	 * Build the stacks from top down
	 */
	Axis.prototype.buildStacks = function () {
		var series = this.series,
			reversedStacks = pick(this.options.reversedStacks, true),
			i = series.length;
		if (!this.isXAxis) {
			this.usePercentage = false;
			while (i--) {
				series[reversedStacks ? i : series.length - i - 1].setStackedPoints();
			}
			// Loop up again to compute percent stack
			if (this.usePercentage) {
				for (i = 0; i < series.length; i++) {
					series[i].setPercentStacks();
				}
			}
		}
	};

	Axis.prototype.renderStackTotals = function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			stacks = axis.stacks,
			stackKey, 
			oneStack, 
			stackCategory,
			stackTotalGroup = axis.stackTotalGroup;

		// Create a separate group for the stack total labels
		if (!stackTotalGroup) {
			axis.stackTotalGroup = stackTotalGroup =
				renderer.g('stack-labels')
					.attr({
						visibility: VISIBLE,
						zIndex: 6
					})
					.add();
		}

		// plotLeft/Top will change when y axis gets wider so we need to translate the
		// stackTotalGroup at every render call. See bug #506 and #516
		stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

		// Render each stack total
		for (stackKey in stacks) {
			oneStack = stacks[stackKey];
			for (stackCategory in oneStack) {
				oneStack[stackCategory].render(stackTotalGroup);
			}
		}
	};


	// Stacking methods defnied for Series prototype

	/**
	 * Adds series' points value to corresponding stack
	 */
	Series.prototype.setStackedPoints = function () {
		if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
			return;
		}

		var series = this,
			xData = series.processedXData,
			yData = series.processedYData,
			stackedYData = [],
			yDataLength = yData.length,
			seriesOptions = series.options,
			threshold = seriesOptions.threshold,
			stackOption = seriesOptions.stack,
			stacking = seriesOptions.stacking,
			stackKey = series.stackKey,
			negKey = '-' + stackKey,
			negStacks = series.negStacks,
			yAxis = series.yAxis,
			stacks = yAxis.stacks,
			oldStacks = yAxis.oldStacks,
			isNegative,
			stack,
			other,
			key,
			pointKey,
			i,
			x,
			y;

		// loop over the non-null y values and read them into a local array
		for (i = 0; i < yDataLength; i++) {
			x = xData[i];
			y = yData[i];
			pointKey = series.index + ',' + i;

			// Read stacked values into a stack based on the x value,
			// the sign of y and the stack key. Stacking is also handled for null values (#739)
			isNegative = negStacks && y < threshold;
			key = isNegative ? negKey : stackKey;

			// Create empty object for this stack if it doesn't exist yet
			if (!stacks[key]) {
				stacks[key] = {};
			}

			// Initialize StackItem for this x
			if (!stacks[key][x]) {
				if (oldStacks[key] && oldStacks[key][x]) {
					stacks[key][x] = oldStacks[key][x];
					stacks[key][x].total = null;
				} else {
					stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
				}
			}

			// If the StackItem doesn't exist, create it first
			stack = stacks[key][x];
			stack.points[pointKey] = [stack.cum || 0];

			// Add value to the stack total
			if (stacking === 'percent') {

				// Percent stacked column, totals are the same for the positive and negative stacks
				other = isNegative ? stackKey : negKey;
				if (negStacks && stacks[other] && stacks[other][x]) {
					other = stacks[other][x];
					stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

				// Percent stacked areas
				} else {
					stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
				}
			} else {
				stack.total = correctFloat(stack.total + (y || 0));
			}

			stack.cum = (stack.cum || 0) + (y || 0);

			stack.points[pointKey].push(stack.cum);
			stackedYData[i] = stack.cum;

		}

		if (stacking === 'percent') {
			yAxis.usePercentage = true;
		}

		this.stackedYData = stackedYData; // To be used in getExtremes

		// Reset old stacks
		yAxis.oldStacks = {};
	};

	/**
	 * Iterate over all stacks and compute the absolute values to percent
	 */
	Series.prototype.setPercentStacks = function () {
		var series = this,
			stackKey = series.stackKey,
			stacks = series.yAxis.stacks,
			processedXData = series.processedXData;

		each([stackKey, '-' + stackKey], function (key) {
			var i = processedXData.length,
				x,
				stack,
				pointExtremes,
				totalFactor;

			while (i--) {
				x = processedXData[i];
				stack = stacks[key] && stacks[key][x];
				pointExtremes = stack && stack.points[series.index + ',' + i];
				if (pointExtremes) {
					totalFactor = stack.total ? 100 / stack.total : 0;
					pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
					pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
					series.stackedYData[i] = pointExtremes[1];
				}
			}
		});
	};

	// Extend the Chart prototype for dynamic methods
	extend(Chart.prototype, {

		/**
		 * Add a series dynamically after  time
		 *
		 * @param {Object} options The config options
		 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 *
		 * @return {Object} series The newly created series object
		 */
		addSeries: function (options, redraw, animation) {
			var series,
				chart = this;

			if (options) {
				redraw = pick(redraw, true); // defaults to true

				fireEvent(chart, 'addSeries', { options: options }, function () {
					series = chart.initSeries(options);

					chart.isDirtyLegend = true; // the series array is out of sync with the display
					chart.linkSeries();
					if (redraw) {
						chart.redraw(animation);
					}
				});
			}

			return series;
		},

		/**
	     * Add an axis to the chart
	     * @param {Object} options The axis option
	     * @param {Boolean} isX Whether it is an X axis or a value axis
	     */
		addAxis: function (options, isX, redraw, animation) {
			var key = isX ? 'xAxis' : 'yAxis',
				chartOptions = this.options,
				axis;

			/*jslint unused: false*/
			axis = new Axis(this, merge(options, {
				index: this[key].length,
				isX: isX
			}));
			/*jslint unused: true*/

			// Push the new axis options to the chart options
			chartOptions[key] = splat(chartOptions[key] || {});
			chartOptions[key].push(options);

			if (pick(redraw, true)) {
				this.redraw(animation);
			}
		},

		/**
		 * Dim the chart and show a loading text or symbol
		 * @param {String} str An optional text to show in the loading label instead of the default one
		 */
		showLoading: function (str) {
			var chart = this,
				options = chart.options,
				loadingDiv = chart.loadingDiv,
				loadingOptions = options.loading,
				setLoadingSize = function () {
					if (loadingDiv) {
						css(loadingDiv, {
							left: chart.plotLeft + PX,
							top: chart.plotTop + PX,
							width: chart.plotWidth + PX,
							height: chart.plotHeight + PX
						});
					}
				};

			// create the layer at the first call
			if (!loadingDiv) {
				chart.loadingDiv = loadingDiv = createElement(DIV, {
					className: PREFIX + 'loading'
				}, extend(loadingOptions.style, {
					zIndex: 10,
					display: NONE
				}), chart.container);

				chart.loadingSpan = createElement(
					'span',
					null,
					loadingOptions.labelStyle,
					loadingDiv
				);
				addEvent(chart, 'redraw', setLoadingSize); // #1080
			}

			// update text
			chart.loadingSpan.innerHTML = str || options.lang.loading;

			// show it
			if (!chart.loadingShown) {
				css(loadingDiv, {
					opacity: 0,
					display: ''				
				});
				animate(loadingDiv, {
					opacity: loadingOptions.style.opacity
				}, {
					duration: loadingOptions.showDuration || 0
				});
				chart.loadingShown = true;
			}
			setLoadingSize();
		},

		/**
		 * Hide the loading layer
		 */
		hideLoading: function () {
			var options = this.options,
				loadingDiv = this.loadingDiv;

			if (loadingDiv) {
				animate(loadingDiv, {
					opacity: 0
				}, {
					duration: options.loading.hideDuration || 100,
					complete: function () {
						css(loadingDiv, { display: NONE });
					}
				});
			}
			this.loadingShown = false;
		}
	});

	// extend the Point prototype for dynamic methods
	extend(Point.prototype, {
		/**
		 * Update the point with new options (typically x/y data) and optionally redraw the series.
		 *
		 * @param {Object} options Point options as defined in the series.data array
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 *
		 */
		update: function (options, redraw, animation, runEvent) {
			var point = this,
				series = point.series,
				graphic = point.graphic,
				i,
				chart = series.chart,
				seriesOptions = series.options,
				names = series.xAxis && series.xAxis.names;

			redraw = pick(redraw, true);

			function update() {

				point.applyOptions(options);

				// Update visuals
				if (isObject(options) && !isArray(options)) {
					// Defer the actual redraw until getAttribs has been called (#3260)
					point.redraw = function () {
						if (graphic) {
							if (options && options.marker && options.marker.symbol) {
								point.graphic = graphic.destroy();
							} else {
								graphic.attr(point.pointAttr[point.state || '']);
							}
						}
						if (options && options.dataLabels && point.dataLabel) { // #2468
							point.dataLabel = point.dataLabel.destroy();
						}
						point.redraw = null;
					};
				}

				// record changes in the parallel arrays
				i = point.index;
				series.updateParallelArrays(point, i);
				if (names && point.name) {
					names[point.x] = point.name;
				}

				seriesOptions.data[i] = point.options;

				// redraw
				series.isDirty = series.isDirtyData = true;
				if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
					chart.isDirtyBox = true;
				}

				if (chart.legend.display && seriesOptions.legendType === 'point') { // #1831, #1885, #3934
					series.updateTotals();
					chart.legend.clearItems();
				}
				if (redraw) {
					chart.redraw(animation);
				}
			}

			// Fire the event with a default handler of doing the update
			if (runEvent === false) { // When called from setData
				update();
			} else {
				point.firePointEvent('update', { options: options }, update);
			}
		},

		/**
		 * Remove a point and optionally redraw the series and if necessary the axes
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		remove: function (redraw, animation) {
			this.series.removePoint(inArray(this, this.series.data), redraw, animation);
		}
	});

	// Extend the series prototype for dynamic methods
	extend(Series.prototype, {
		/**
		 * Add a point dynamically after chart load time
		 * @param {Object} options Point options as given in series.data
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean} shift If shift is true, a point is shifted off the start
		 *    of the series as one is appended to the end.
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */
		addPoint: function (options, redraw, shift, animation) {
			var series = this,
				seriesOptions = series.options,
				data = series.data,
				graph = series.graph,
				area = series.area,
				chart = series.chart,
				names = series.xAxis && series.xAxis.names,
				currentShift = (graph && graph.shift) || 0,
				dataOptions = seriesOptions.data,
				point,
				isInTheMiddle,
				xData = series.xData,
				x,
				i;

			setAnimation(animation, chart);

			// Make graph animate sideways
			if (shift) {
				each([graph, area, series.graphNeg, series.areaNeg], function (shape) {
					if (shape) {
						shape.shift = currentShift + 1;
					}
				});
			}
			if (area) {
				area.isArea = true; // needed in animation, both with and without shift
			}

			// Optional redraw, defaults to true
			redraw = pick(redraw, true);

			// Get options and push the point to xData, yData and series.options. In series.generatePoints
			// the Point instance will be created on demand and pushed to the series.data array.
			point = { series: series };
			series.pointClass.prototype.applyOptions.apply(point, [options]);
			x = point.x;

			// Get the insertion point
			i = xData.length;
			if (series.requireSorting && x < xData[i - 1]) {
				isInTheMiddle = true;
				while (i && xData[i - 1] > x) {
					i--;
				}
			}

			series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
			series.updateParallelArrays(point, i); // update it

			if (names && point.name) {
				names[x] = point.name;
			}
			dataOptions.splice(i, 0, options);

			if (isInTheMiddle) {
				series.data.splice(i, 0, null);
				series.processData();
			}

			// Generate points to be added to the legend (#1329)
			if (seriesOptions.legendType === 'point') {
				series.generatePoints();
			}

			// Shift the first point off the parallel arrays
			// todo: consider series.removePoint(i) method
			if (shift) {
				if (data[0] && data[0].remove) {
					data[0].remove(false);
				} else {
					data.shift();
					series.updateParallelArrays(point, 'shift');

					dataOptions.shift();
				}
			}

			// redraw
			series.isDirty = true;
			series.isDirtyData = true;
			if (redraw) {
				series.getAttribs(); // #1937
				chart.redraw();
			}
		},

		/**
		 * Remove a point (rendered or not), by index
		 */
		removePoint: function (i, redraw, animation) {

			var series = this,
				data = series.data,
				point = data[i],
				points = series.points,
				chart = series.chart,
				remove = function () {

					if (data.length === points.length) {
						points.splice(i, 1);
					}
					data.splice(i, 1);
					series.options.data.splice(i, 1);
					series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

					if (point) {
						point.destroy();
					}

					// redraw
					series.isDirty = true;
					series.isDirtyData = true;
					if (redraw) {
						chart.redraw();
					}
				};

			setAnimation(animation, chart);
			redraw = pick(redraw, true);

			// Fire the event with a default handler of removing the point
			if (point) {
				point.firePointEvent('remove', null, remove);
			} else {
				remove();
			}
		},

		/**
		 * Remove a series and optionally redraw the chart
		 *
		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
		 *    configuration
		 */

		remove: function (redraw, animation) {
			var series = this,
				chart = series.chart;
			redraw = pick(redraw, true);

			if (!series.isRemoving) {  /* prevent triggering native event in jQuery
					(calling the remove function from the remove event) */
				series.isRemoving = true;

				// fire the event with a default handler of removing the point
				fireEvent(series, 'remove', null, function () {


					// destroy elements
					series.destroy();


					// redraw
					chart.isDirtyLegend = chart.isDirtyBox = true;
					chart.linkSeries();

					if (redraw) {
						chart.redraw(animation);
					}
				});

			}
			series.isRemoving = false;
		},

		/**
		 * Update the series with a new set of options
		 */
		update: function (newOptions, redraw) {
			var series = this,
				chart = this.chart,
				// must use user options when changing type because this.options is merged
				// in with type specific plotOptions
				oldOptions = this.userOptions,
				oldType = this.type,
				proto = seriesTypes[oldType].prototype,
				preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
				n;

			// If we're changing type or zIndex, create new groups (#3380, #3404)
			if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
				preserve.length = 0;
			}

			// Make sure groups are not destroyed (#3094)
			each(preserve, function (prop) {
				preserve[prop] = series[prop];
				delete series[prop];
			});

			// Do the merge, with some forced options
			newOptions = merge(oldOptions, {
				animation: false,
				index: this.index,
				pointStart: this.xData[0] // when updating after addPoint
			}, { data: this.options.data }, newOptions);

			// Destroy the series and delete all properties. Reinsert all methods 
			// and properties from the new type prototype (#2270, #3719)
			this.remove(false);
			for (n in proto) {
				this[n] = UNDEFINED;
			}
			extend(this, seriesTypes[newOptions.type || oldType].prototype);

			// Re-register groups (#3094)
			each(preserve, function (prop) {
				series[prop] = preserve[prop];
			});

			this.init(chart, newOptions);
			chart.linkSeries(); // Links are lost in this.remove (#3028)
			if (pick(redraw, true)) {
				chart.redraw(false);
			}
		}
	});

	// Extend the Axis.prototype for dynamic methods
	extend(Axis.prototype, {

		/**
		 * Update the axis with a new options structure
		 */
		update: function (newOptions, redraw) {
			var chart = this.chart;

			newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

			this.destroy(true);
			this._addedPlotLB = UNDEFINED; // #1611, #2887

			this.init(chart, extend(newOptions, { events: UNDEFINED }));

			chart.isDirtyBox = true;
			if (pick(redraw, true)) {
				chart.redraw();
			}
		},

		/**
	     * Remove the axis from the chart
	     */
		remove: function (redraw) {
			var chart = this.chart,
				key = this.coll, // xAxis or yAxis
				axisSeries = this.series,
				i = axisSeries.length;

			// Remove associated series (#2687)
			while (i--) {
				if (axisSeries[i]) {
					axisSeries[i].remove(false);
				}
			}

			// Remove the axis
			erase(chart.axes, this);
			erase(chart[key], this);
			chart.options[key].splice(this.options.index, 1);
			each(chart[key], function (axis, i) { // Re-index, #1706
				axis.options.index = i;
			});
			this.destroy();
			chart.isDirtyBox = true;

			if (pick(redraw, true)) {
				chart.redraw();
			}
		},

		/**
		 * Update the axis title by options
		 */
		setTitle: function (newTitleOptions, redraw) {
			this.update({ title: newTitleOptions }, redraw);
		},

		/**
		 * Set new axis categories and optionally redraw
		 * @param {Array} categories
		 * @param {Boolean} redraw
		 */
		setCategories: function (categories, redraw) {
			this.update({ categories: categories }, redraw);
		}

	});


	/**
	 * LineSeries object
	 */
	var LineSeries = extendClass(Series);
	seriesTypes.line = LineSeries;

	/**
	 * Set the default options for area
	 */
	defaultPlotOptions.area = merge(defaultSeriesOptions, {
		threshold: 0
		// trackByArea: false,
		// lineColor: null, // overrides color, but lets fillColor be unaltered
		// fillOpacity: 0.75,
		// fillColor: null
	});

	/**
	 * AreaSeries object
	 */
	var AreaSeries = extendClass(Series, {
		type: 'area',
		/**
		 * For stacks, don't split segments on null values. Instead, draw null values with 
		 * no marker. Also insert dummy points for any X position that exists in other series
		 * in the stack.
		 */ 
		getSegments: function () {
			var series = this,
				segments = [],
				segment = [],
				keys = [],
				xAxis = this.xAxis,
				yAxis = this.yAxis,
				stack = yAxis.stacks[this.stackKey],
				pointMap = {},
				plotX,
				plotY,
				points = this.points,
				connectNulls = this.options.connectNulls,
				i,
				x;

			if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue
				// Create a map where we can quickly look up the points by their X value.
				for (i = 0; i < points.length; i++) {
					pointMap[points[i].x] = points[i];
				}

				// Sort the keys (#1651)
				for (x in stack) {
					if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
						keys.push(+x);
					}
				}
				keys.sort(function (a, b) {
					return a - b;
				});

				each(keys, function (x) {
					var y = 0,
						stackPoint;

					if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836
						return;

					// The point exists, push it to the segment
					} else if (pointMap[x]) {
						segment.push(pointMap[x]);

					// There is no point for this X value in this series, so we 
					// insert a dummy point in order for the areas to be drawn
					// correctly.
					} else {

						// Loop down the stack to find the series below this one that has
						// a value (#1991)
						for (i = series.index; i <= yAxis.series.length; i++) {
							stackPoint = stack[x].points[i + ',' + x];
							if (stackPoint) {
								y = stackPoint[1];
								break;
							}
						}

						plotX = xAxis.translate(x);
						plotY = yAxis.toPixels(y, true);
						segment.push({ 
							y: null, 
							plotX: plotX,
							clientX: plotX, 
							plotY: plotY, 
							yBottom: plotY,
							onMouseOver: noop
						});
					}
				});

				if (segment.length) {
					segments.push(segment);
				}

			} else {
				Series.prototype.getSegments.call(this);
				segments = this.segments;
			}

			this.segments = segments;
		},
		
		/**
		 * Extend the base Series getSegmentPath method by adding the path for the area.
		 * This path is pushed to the series.areaPath property.
		 */
		getSegmentPath: function (segment) {
			
			var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
				areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
				i,
				options = this.options,
				segLength = segmentPath.length,
				translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
				yBottom;
			
			if (segLength === 3) { // for animation from 1 to two points
				areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
			}
			if (options.stacking && !this.closedStacks) {
				
				// Follow stack back. Todo: implement areaspline. A general solution could be to 
				// reverse the entire graphPath of the previous series, though may be hard with
				// splines and with series with different extremes
				for (i = segment.length - 1; i >= 0; i--) {

					yBottom = pick(segment[i].yBottom, translatedThreshold);
				
					// step line?
					if (i < segment.length - 1 && options.step) {
						areaSegmentPath.push(segment[i + 1].plotX, yBottom);
					}
					
					areaSegmentPath.push(segment[i].plotX, yBottom);
				}

			} else { // follow zero line back
				this.closeSegment(areaSegmentPath, segment, translatedThreshold);
			}
			this.areaPath = this.areaPath.concat(areaSegmentPath);
			return segmentPath;
		},
		
		/**
		 * Extendable method to close the segment path of an area. This is overridden in polar 
		 * charts.
		 */
		closeSegment: function (path, segment, translatedThreshold) {
			path.push(
				L,
				segment[segment.length - 1].plotX,
				translatedThreshold,
				L,
				segment[0].plotX,
				translatedThreshold
			);
		},
		
		/**
		 * Draw the graph and the underlying area. This method calls the Series base
		 * function and adds the area. The areaPath is calculated in the getSegmentPath
		 * method called from Series.prototype.drawGraph.
		 */
		drawGraph: function () {
			
			// Define or reset areaPath
			this.areaPath = [];
			
			// Call the base method
			Series.prototype.drawGraph.apply(this);
			
			// Define local variables
			var series = this,
				areaPath = this.areaPath,
				options = this.options,
				zones = this.zones,
				props = [['area', this.color, options.fillColor]]; // area name, main color, fill color
			
			each(zones, function (threshold, i) {
				props.push(['colorArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
			});
			each(props, function (prop) {
				var areaKey = prop[0],
					area = series[areaKey];
					
				// Create or update the area
				if (area) { // update
					area.animate({ d: areaPath });
		
				} else { // create
					series[areaKey] = series.chart.renderer.path(areaPath)
						.attr({
							fill: pick(
								prop[2],
								Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
							),
							zIndex: 0 // #1069
						}).add(series.group);
				}
			});
		},

		drawLegendSymbol: LegendSymbolMixin.drawRectangle
	});

	seriesTypes.area = AreaSeries;
	/**
	 * Set the default options for spline
	 */
	defaultPlotOptions.spline = merge(defaultSeriesOptions);

	/**
	 * SplineSeries object
	 */
	var SplineSeries = extendClass(Series, {
		type: 'spline',

		/**
		 * Get the spline segment from a given point's previous neighbour to the given point
		 */
		getPointSpline: function (segment, point, i) {
			var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
				denom = smoothing + 1,
				plotX = point.plotX,
				plotY = point.plotY,
				lastPoint = segment[i - 1],
				nextPoint = segment[i + 1],
				leftContX,
				leftContY,
				rightContX,
				rightContY,
				ret;

			// find control points
			if (lastPoint && nextPoint) {
			
				var lastX = lastPoint.plotX,
					lastY = lastPoint.plotY,
					nextX = nextPoint.plotX,
					nextY = nextPoint.plotY,
					correction;

				leftContX = (smoothing * plotX + lastX) / denom;
				leftContY = (smoothing * plotY + lastY) / denom;
				rightContX = (smoothing * plotX + nextX) / denom;
				rightContY = (smoothing * plotY + nextY) / denom;

				// have the two control points make a straight line through main point
				correction = ((rightContY - leftContY) * (rightContX - plotX)) /
					(rightContX - leftContX) + plotY - rightContY;

				leftContY += correction;
				rightContY += correction;

				// to prevent false extremes, check that control points are between
				// neighbouring points' y values
				if (leftContY > lastY && leftContY > plotY) {
					leftContY = mathMax(lastY, plotY);
					rightContY = 2 * plotY - leftContY; // mirror of left control point
				} else if (leftContY < lastY && leftContY < plotY) {
					leftContY = mathMin(lastY, plotY);
					rightContY = 2 * plotY - leftContY;
				}
				if (rightContY > nextY && rightContY > plotY) {
					rightContY = mathMax(nextY, plotY);
					leftContY = 2 * plotY - rightContY;
				} else if (rightContY < nextY && rightContY < plotY) {
					rightContY = mathMin(nextY, plotY);
					leftContY = 2 * plotY - rightContY;
				}

				// record for drawing in next point
				point.rightContX = rightContX;
				point.rightContY = rightContY;

			}
			
			// Visualize control points for debugging
			/*
			if (leftContX) {
				this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
					.attr({
						stroke: 'red',
						'stroke-width': 1,
						fill: 'none'
					})
					.add();
				this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
					.attr({
						stroke: 'red',
						'stroke-width': 1
					})
					.add();
				this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
					.attr({
						stroke: 'green',
						'stroke-width': 1,
						fill: 'none'
					})
					.add();
				this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
					.attr({
						stroke: 'green',
						'stroke-width': 1
					})
					.add();
			}
			*/

			// moveTo or lineTo
			if (!i) {
				ret = [M, plotX, plotY];
			} else { // curve from last point to this
				ret = [
					'C',
					lastPoint.rightContX || lastPoint.plotX,
					lastPoint.rightContY || lastPoint.plotY,
					leftContX || plotX,
					leftContY || plotY,
					plotX,
					plotY
				];
				lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
			}
			return ret;
		}
	});
	seriesTypes.spline = SplineSeries;

	/**
	 * Set the default options for areaspline
	 */
	defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

	/**
	 * AreaSplineSeries object
	 */
	var areaProto = AreaSeries.prototype,
		AreaSplineSeries = extendClass(SplineSeries, {
			type: 'areaspline',
			closedStacks: true, // instead of following the previous graph back, follow the threshold back
			
			// Mix in methods from the area series
			getSegmentPath: areaProto.getSegmentPath,
			closeSegment: areaProto.closeSegment,
			drawGraph: areaProto.drawGraph,
			drawLegendSymbol: LegendSymbolMixin.drawRectangle
		});

	seriesTypes.areaspline = AreaSplineSeries;

	/**
	 * Set the default options for column
	 */
	defaultPlotOptions.column = merge(defaultSeriesOptions, {
		borderColor: '#FFFFFF',
		//borderWidth: 1,
		borderRadius: 0,
		//colorByPoint: undefined,
		groupPadding: 0.2,
		//grouping: true,
		marker: null, // point options are specified in the base options
		pointPadding: 0.1,
		//pointWidth: null,
		minPointLength: 0,
		cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
		pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
		states: {
			hover: {
				brightness: 0.1,
				shadow: false,
				halo: false
			},
			select: {
				color: '#C0C0C0',
				borderColor: '#000000',
				shadow: false
			}
		},
		dataLabels: {
			align: null, // auto
			verticalAlign: null, // auto
			y: null
		},
		stickyTracking: false,
		tooltip: {
			distance: 6
		},
		threshold: 0
	});

	/**
	 * ColumnSeries object
	 */
	var ColumnSeries = extendClass(Series, {
		type: 'column',
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'borderColor',
			fill: 'color',
			r: 'borderRadius'
		},
		cropShoulder: 0,
		directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
		trackerGroups: ['group', 'dataLabelsGroup'],
		negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
			// point is substracted from previous (#1910)
		
		/**
		 * Initialize the series
		 */
		init: function () {
			Series.prototype.init.apply(this, arguments);

			var series = this,
				chart = series.chart;

			// if the series is added dynamically, force redraw of other
			// series affected by a new column
			if (chart.hasRendered) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.type === series.type) {
						otherSeries.isDirty = true;
					}
				});
			}
		},

		/**
		 * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
		 * pointWidth etc. 
		 */
		getColumnMetrics: function () {

			var series = this,
				options = series.options,
				xAxis = series.xAxis,
				yAxis = series.yAxis,
				reversedXAxis = xAxis.reversed,
				stackKey,
				stackGroups = {},
				columnIndex,
				columnCount = 0;

			// Get the total number of column type series.
			// This is called on every series. Consider moving this logic to a
			// chart.orderStacks() function and call it on init, addSeries and removeSeries
			if (options.grouping === false) {
				columnCount = 1;
			} else {
				each(series.chart.series, function (otherSeries) {
					var otherOptions = otherSeries.options,
						otherYAxis = otherSeries.yAxis;
					if (otherSeries.type === series.type && otherSeries.visible &&
							yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
						if (otherOptions.stacking) {
							stackKey = otherSeries.stackKey;
							if (stackGroups[stackKey] === UNDEFINED) {
								stackGroups[stackKey] = columnCount++;
							}
							columnIndex = stackGroups[stackKey];
						} else if (otherOptions.grouping !== false) { // #1162
							columnIndex = columnCount++;
						}
						otherSeries.columnIndex = columnIndex;
					}
				});
			}

			var categoryWidth = mathMin(
					mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
					xAxis.len // #1535
				),
				groupPadding = categoryWidth * options.groupPadding,
				groupWidth = categoryWidth - 2 * groupPadding,
				pointOffsetWidth = groupWidth / columnCount,
				optionPointWidth = options.pointWidth,
				pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
					pointOffsetWidth * options.pointPadding,
				pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts
				colIndex = (reversedXAxis ? 
					columnCount - (series.columnIndex || 0) : // #1251
					series.columnIndex) || 0,
				pointXOffset = pointPadding + (groupPadding + colIndex *
					pointOffsetWidth - (categoryWidth / 2)) *
					(reversedXAxis ? -1 : 1);

			// Save it for reading in linked series (Error bars particularly)
			return (series.columnMetrics = { 
				width: pointWidth, 
				offset: pointXOffset 
			});
				
		},

		/**
		 * Translate each point to the plot area coordinate system and find shape positions
		 */
		translate: function () {
			var series = this,
				chart = series.chart,
				options = series.options,
				borderWidth = series.borderWidth = pick(
					options.borderWidth, 
					series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
				),
				yAxis = series.yAxis,
				threshold = options.threshold,
				translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
				minPointLength = pick(options.minPointLength, 5),
				metrics = series.getColumnMetrics(),
				pointWidth = metrics.width,
				seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
				pointXOffset = series.pointXOffset = metrics.offset,
				xCrisp = -(borderWidth % 2 ? 0.5 : 0),
				yCrisp = borderWidth % 2 ? 0.5 : 1;

			if (chart.renderer.isVML && chart.inverted) {
				yCrisp += 1;
			}

			// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
			// columns to have individual sizes. When pointPadding is greater, we strive for equal-width
			// columns (#2694).
			if (options.pointPadding) {
				seriesBarW = mathCeil(seriesBarW);
			}

			Series.prototype.translate.apply(series);

			// Record the new values
			each(series.points, function (point) {
				var yBottom = pick(point.yBottom, translatedThreshold),
					plotY = mathMin(mathMax(-999 - yBottom, point.plotY), yAxis.len + 999 + yBottom), // Don't draw too far outside plot area (#1303, #2241)
					barX = point.plotX + pointXOffset,
					barW = seriesBarW,
					barY = mathMin(plotY, yBottom),
					right,
					bottom,
					fromTop,
					barH = mathMax(plotY, yBottom) - barY;

				// Handle options.minPointLength
				if (mathAbs(barH) < minPointLength) {
					if (minPointLength) {
						barH = minPointLength;
						barY =
							mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
								yBottom - minPointLength : // keep position
								translatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0)); // use exact yAxis.translation (#1485)
					}
				}

				// Cache for access in polar
				point.barX = barX;
				point.pointWidth = pointWidth;

				// Fix the tooltip on center of grouped columns (#1216, #424, #3648)
				point.tooltipPos = chart.inverted ? 
					[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2] : 
					[barX + barW / 2, plotY + yAxis.pos - chart.plotTop];

				// Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)
				right = mathRound(barX + barW) + xCrisp;
				barX = mathRound(barX) + xCrisp;
				barW = right - barX;

				fromTop = mathAbs(barY) < 0.5;
				bottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575
				barY = mathRound(barY) + yCrisp;
				barH = bottom - barY;

				// Top edges are exceptions
				if (fromTop) {
					barY -= 1;
					barH += 1;
				}

				// Register shape type and arguments to be used in drawPoints
				point.shapeType = 'rect';
				point.shapeArgs = {
					x: barX,
					y: barY,
					width: barW,
					height: barH
				};

			});

		},

		getSymbol: noop,
		
		/**
		 * Use a solid rectangle like the area series types
		 */
		drawLegendSymbol: LegendSymbolMixin.drawRectangle,
		
		
		/**
		 * Columns have no graph
		 */
		drawGraph: noop,

		/**
		 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
		 * apply for columns and bars. This method is inherited by scatter series.
		 *
		 */
		drawPoints: function () {
			var series = this,
				chart = this.chart,
				options = series.options,
				renderer = chart.renderer,
				animationLimit = options.animationLimit || 250,
				shapeArgs,
				pointAttr;

			// draw the columns
			each(series.points, function (point) {
				var plotY = point.plotY,
					graphic = point.graphic,
					borderAttr;

				if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
					shapeArgs = point.shapeArgs;

					borderAttr = defined(series.borderWidth) ? {
						'stroke-width': series.borderWidth
					} : {};

					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];
					
					if (graphic) { // update
						stop(graphic);
						graphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));

					} else {
						point.graphic = graphic = renderer[point.shapeType](shapeArgs)
							.attr(borderAttr)
							.attr(pointAttr)
							.add(series.group)
							.shadow(options.shadow, null, options.stacking && !options.borderRadius);
					}

				} else if (graphic) {
					point.graphic = graphic.destroy(); // #1269
				}
			});
		},

		/**
		 * Animate the column heights one by one from zero
		 * @param {Boolean} init Whether to initialize the animation or run it
		 */
		animate: function (init) {
			var series = this,
				yAxis = this.yAxis,
				options = series.options,
				inverted = this.chart.inverted,
				attr = {},
				translatedThreshold;

			if (hasSVG) { // VML is too slow anyway
				if (init) {
					attr.scaleY = 0.001;
					translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
					if (inverted) {
						attr.translateX = translatedThreshold - yAxis.len;
					} else {
						attr.translateY = translatedThreshold;
					}
					series.group.attr(attr);

				} else { // run the animation
					
					attr.scaleY = 1;
					attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
					series.group.animate(attr, series.options.animation);

					// delete this function to allow it only once
					series.animate = null;
				}
			}
		},
		
		/**
		 * Remove this series from the chart
		 */
		remove: function () {
			var series = this,
				chart = series.chart;

			// column and bar series affects other series of the same type
			// as they are either stacked or grouped
			if (chart.hasRendered) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.type === series.type) {
						otherSeries.isDirty = true;
					}
				});
			}

			Series.prototype.remove.apply(series, arguments);
		}
	});
	seriesTypes.column = ColumnSeries;
	/**
	 * Set the default options for bar
	 */
	defaultPlotOptions.bar = merge(defaultPlotOptions.column);
	/**
	 * The Bar series class
	 */
	var BarSeries = extendClass(ColumnSeries, {
		type: 'bar',
		inverted: true
	});
	seriesTypes.bar = BarSeries;

	/**
	 * Set the default options for scatter
	 */
	defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
		lineWidth: 0,
		marker: {
			enabled: true // Overrides auto-enabling in line series (#3647)
		},
		tooltip: {
			headerFormat: '<span style="color:{series.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
			pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
		}
	});

	/**
	 * The scatter series class
	 */
	var ScatterSeries = extendClass(Series, {
		type: 'scatter',
		sorted: false,
		requireSorting: false,
		noSharedTooltip: true,
		trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
		takeOrdinalPosition: false, // #2342
		kdDimensions: 2,
		kdComparer: 'distR',
		drawGraph: function () {
			if (this.options.lineWidth) {
				Series.prototype.drawGraph.call(this);
			}
		}
	});

	seriesTypes.scatter = ScatterSeries;

	/**
	 * Set the default options for pie
	 */
	defaultPlotOptions.pie = merge(defaultSeriesOptions, {
		borderColor: '#FFFFFF',
		borderWidth: 1,
		center: [null, null],
		clip: false,
		colorByPoint: true, // always true for pies
		dataLabels: {
			// align: null,
			// connectorWidth: 1,
			// connectorColor: point.color,
			// connectorPadding: 5,
			distance: 30,
			enabled: true,
			formatter: function () { // #2945
				return this.point.name;
			},
			// softConnector: true,
			x: 0
			// y: 0
		},
		ignoreHiddenPoint: true,
		//innerSize: 0,
		legendType: 'point',
		marker: null, // point options are specified in the base options
		size: null,
		showInLegend: false,
		slicedOffset: 10,
		states: {
			hover: {
				brightness: 0.1,
				shadow: false
			}
		},
		stickyTracking: false,
		tooltip: {
			followPointer: true
		}
	});

	/**
	 * Extended point object for pies
	 */
	var PiePoint = extendClass(Point, {
		/**
		 * Initiate the pie slice
		 */
		init: function () {

			Point.prototype.init.apply(this, arguments);

			var point = this,
				toggleSlice;

			extend(point, {
				visible: point.visible !== false,
				name: pick(point.name, 'Slice')
			});

			// add event listener for select
			toggleSlice = function (e) {
				point.slice(e.type === 'select');
			};
			addEvent(point, 'select', toggleSlice);
			addEvent(point, 'unselect', toggleSlice);

			return point;
		},

		/**
		 * Toggle the visibility of the pie slice
		 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
		 *    visibility is toggled
		 */
		setVisible: function (vis) {
			var point = this,
				series = point.series,
				chart = series.chart,
				doRedraw = !series.isDirty && series.options.ignoreHiddenPoint;

			// if called without an argument, toggle visibility
			point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

			// Show and hide associated elements
			each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
				if (point[key]) {
					point[key][vis ? 'show' : 'hide'](true);
				}
			});

			if (point.legendItem) {
				if (chart.hasRendered) {
					series.updateTotals();
					chart.legend.clearItems();
					if (!doRedraw) {
						chart.legend.render();
					}
				}
				chart.legend.colorizeItem(point, vis);
			}

			// Handle ignore hidden slices
			if (doRedraw) {
				series.isDirty = true;
				chart.redraw();
			}
		},

		/**
		 * Set or toggle whether the slice is cut out from the pie
		 * @param {Boolean} sliced When undefined, the slice state is toggled
		 * @param {Boolean} redraw Whether to redraw the chart. True by default.
		 */
		slice: function (sliced, redraw, animation) {
			var point = this,
				series = point.series,
				chart = series.chart,
				translation;

			setAnimation(animation, chart);

			// redraw is true by default
			redraw = pick(redraw, true);

			// if called without an argument, toggle
			point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

			translation = sliced ? point.slicedTranslation : {
				translateX: 0,
				translateY: 0
			};

			point.graphic.animate(translation);
			
			if (point.shadowGroup) {
				point.shadowGroup.animate(translation);
			}

		},

		haloPath: function (size) {
			var shapeArgs = this.shapeArgs,
				chart = this.series.chart;

			return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
				innerR: this.shapeArgs.r,
				start: shapeArgs.start,
				end: shapeArgs.end
			});
		}
	});

	/**
	 * The Pie series class
	 */
	var PieSeries = {
		type: 'pie',
		isCartesian: false,
		pointClass: PiePoint,
		requireSorting: false,
		noSharedTooltip: true,
		trackerGroups: ['group', 'dataLabelsGroup'],
		axisTypes: [],
		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
			stroke: 'borderColor',
			'stroke-width': 'borderWidth',
			fill: 'color'
		},

		/**
		 * Pies have one color each point
		 */
		getColor: noop,

		/**
		 * Animate the pies in
		 */
		animate: function (init) {
			var series = this,
				points = series.points,
				startAngleRad = series.startAngleRad;

			if (!init) {
				each(points, function (point) {
					var graphic = point.graphic,
						args = point.shapeArgs;

					if (graphic) {
						// start values
						graphic.attr({
							r: series.center[3] / 2, // animate from inner radius (#779)
							start: startAngleRad,
							end: startAngleRad
						});

						// animate
						graphic.animate({
							r: args.r,
							start: args.start,
							end: args.end
						}, series.options.animation);
					}
				});

				// delete this function to allow it only once
				series.animate = null;
			}
		},

		/**
		 * Extend the basic setData method by running processData and generatePoints immediately,
		 * in order to access the points from the legend.
		 */
		setData: function (data, redraw, animation, updatePoints) {
			Series.prototype.setData.call(this, data, false, animation, updatePoints);
			this.processData();
			this.generatePoints();
			if (pick(redraw, true)) {
				this.chart.redraw(animation);
			} 
		},

		/**
		 * Recompute total chart sum and update percentages of points.
		 */
		updateTotals: function () {
			var i,
				total = 0,
				points,
				len,
				point,
				ignoreHiddenPoint = this.options.ignoreHiddenPoint;

			// Populate local vars
			points = this.points;
			len = points.length;
			
			// Get the total sum
			for (i = 0; i < len; i++) {
				point = points[i];

				// Disallow negative values (#1530, #3623)
				if (point.y < 0) {
					point.y = null;
				}
				
				total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
			}
			this.total = total;

			// Set each point's properties
			for (i = 0; i < len; i++) {
				point = points[i];
				//point.percentage = (total <= 0 || ignoreHiddenPoint && !point.visible) ? 0 : point.y / total * 100;
				point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
				point.total = total;
			}
		},

		/**
		 * Extend the generatePoints method by adding total and percentage properties to each point
		 */
		generatePoints: function () {
			Series.prototype.generatePoints.call(this);
			this.updateTotals();
		},
		
		/**
		 * Do translation for pie slices
		 */
		translate: function (positions) {
			this.generatePoints();
			
			var series = this,
				cumulative = 0,
				precision = 1000, // issue #172
				options = series.options,
				slicedOffset = options.slicedOffset,
				connectorOffset = slicedOffset + options.borderWidth,
				start,
				end,
				angle,
				startAngle = options.startAngle || 0,
				startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
				endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
				circ = endAngleRad - startAngleRad, //2 * mathPI,
				points = series.points,
				radiusX, // the x component of the radius vector for a given point
				radiusY,
				labelDistance = options.dataLabels.distance,
				ignoreHiddenPoint = options.ignoreHiddenPoint,
				i,
				len = points.length,
				point;

			// Get positions - either an integer or a percentage string must be given.
			// If positions are passed as a parameter, we're in a recursive loop for adjusting
			// space for data labels.
			if (!positions) {
				series.center = positions = series.getCenter();
			}

			// utility for getting the x value from a given y, used for anticollision logic in data labels
			series.getX = function (y, left) {

				angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

				return positions[0] +
					(left ? -1 : 1) *
					(mathCos(angle) * (positions[2] / 2 + labelDistance));
			};

			// Calculate the geometry for each point
			for (i = 0; i < len; i++) {
				
				point = points[i];
				
				// set start and end angle
				start = startAngleRad + (cumulative * circ);
				if (!ignoreHiddenPoint || point.visible) {
					cumulative += point.percentage / 100;
				}
				end = startAngleRad + (cumulative * circ);

				// set the shape
				point.shapeType = 'arc';
				point.shapeArgs = {
					x: positions[0],
					y: positions[1],
					r: positions[2] / 2,
					innerR: positions[3] / 2,
					start: mathRound(start * precision) / precision,
					end: mathRound(end * precision) / precision
				};

				// The angle must stay within -90 and 270 (#2645)
				angle = (end + start) / 2;
				if (angle > 1.5 * mathPI) {
					angle -= 2 * mathPI;
				} else if (angle < -mathPI / 2) {
					angle += 2 * mathPI;
				}

				// Center for the sliced out slice
				point.slicedTranslation = {
					translateX: mathRound(mathCos(angle) * slicedOffset),
					translateY: mathRound(mathSin(angle) * slicedOffset)
				};

				// set the anchor point for tooltips
				radiusX = mathCos(angle) * positions[2] / 2;
				radiusY = mathSin(angle) * positions[2] / 2;
				point.tooltipPos = [
					positions[0] + radiusX * 0.7,
					positions[1] + radiusY * 0.7
				];
				
				point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
				point.angle = angle;

				// set the anchor point for data labels
				connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
				point.labelPos = [
					positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
					positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
					positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
					positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
					positions[0] + radiusX, // landing point for connector
					positions[1] + radiusY, // a/a
					labelDistance < 0 ? // alignment
						'center' :
						point.half ? 'right' : 'left', // alignment
					angle // center angle
				];

			}
		},
		
		drawGraph: null,

		/**
		 * Draw the data points
		 */
		drawPoints: function () {
			var series = this,
				chart = series.chart,
				renderer = chart.renderer,
				groupTranslation,
				//center,
				graphic,
				//group,
				shadow = series.options.shadow,
				shadowGroup,
				shapeArgs;

			if (shadow && !series.shadowGroup) {
				series.shadowGroup = renderer.g('shadow')
					.add(series.group);
			}

			// draw the slices
			each(series.points, function (point) {
				graphic = point.graphic;
				shapeArgs = point.shapeArgs;
				shadowGroup = point.shadowGroup;

				// put the shadow behind all points
				if (shadow && !shadowGroup) {
					shadowGroup = point.shadowGroup = renderer.g('shadow')
						.add(series.shadowGroup);
				}

				// if the point is sliced, use special translation, else use plot area traslation
				groupTranslation = point.sliced ? point.slicedTranslation : {
					translateX: 0,
					translateY: 0
				};

				//group.translate(groupTranslation[0], groupTranslation[1]);
				if (shadowGroup) {
					shadowGroup.attr(groupTranslation);
				}

				// draw the slice
				if (graphic) {
					graphic.animate(extend(shapeArgs, groupTranslation));
				} else {
					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.setRadialReference(series.center)
						.attr(
							point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
						)
						.attr({ 
							'stroke-linejoin': 'round'
							//zIndex: 1 // #2722 (reversed)
						})
						.attr(groupTranslation)
						.add(series.group)
						.shadow(shadow, shadowGroup);	
				}

				// detect point specific visibility (#2430)
				if (point.visible !== undefined) {
					point.setVisible(point.visible);
				}

			});

		},


		searchPoint: noop,

		/**
		 * Utility for sorting data labels
		 */
		sortByAngle: function (points, sign) {
			points.sort(function (a, b) {
				return a.angle !== undefined && (b.angle - a.angle) * sign;
			});
		},		

		/**
		 * Use a simple symbol from LegendSymbolMixin
		 */
		drawLegendSymbol: LegendSymbolMixin.drawRectangle,

		/**
		 * Use the getCenter method from drawLegendSymbol
		 */
		getCenter: CenteredSeriesMixin.getCenter,

		/**
		 * Pies don't have point marker symbols
		 */
		getSymbol: noop

	};
	PieSeries = extendClass(Series, PieSeries);
	seriesTypes.pie = PieSeries;

	/**
	 * Draw the data labels
	 */
	Series.prototype.drawDataLabels = function () {

		var series = this,
			seriesOptions = series.options,
			cursor = seriesOptions.cursor,
			options = seriesOptions.dataLabels,
			points = series.points,
			pointOptions,
			generalOptions,
			hasRendered = series.hasRendered || 0,
			str,
			dataLabelsGroup,
			renderer = series.chart.renderer;

		if (options.enabled || series._hasPointLabels) {

			// Process default alignment of data labels for columns
			if (series.dlProcessOptions) {
				series.dlProcessOptions(options);
			}

			// Create a separate group for the data labels to avoid rotation
			dataLabelsGroup = series.plotGroup(
				'dataLabelsGroup',
				'data-labels',
				options.defer ? HIDDEN : VISIBLE,
				options.zIndex || 6
			);

			if (pick(options.defer, true)) {
				dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
				if (!hasRendered) {
					addEvent(series, 'afterAnimate', function () {
						if (series.visible) { // #3023, #3024
							dataLabelsGroup.show();
						}
						dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
					});
				}
			}

			// Make the labels for each point
			generalOptions = options;
			each(points, function (point) {

				var enabled,
					dataLabel = point.dataLabel,
					labelConfig,
					attr,
					name,
					rotation,
					connector = point.connector,
					isNew = true,
					style,
					moreStyle = {};

				// Determine if each data label is enabled
				pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
				enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282


				// If the point is outside the plot area, destroy it. #678, #820
				if (dataLabel && !enabled) {
					point.dataLabel = dataLabel.destroy();

				// Individual labels are disabled if the are explicitly disabled
				// in the point options, or if they fall outside the plot area.
				} else if (enabled) {

					// Create individual options structure that can be extended without
					// affecting others
					options = merge(generalOptions, pointOptions);
					style = options.style;

					rotation = options.rotation;

					// Get the string
					labelConfig = point.getLabelConfig();
					str = options.format ?
						format(options.format, labelConfig) :
						options.formatter.call(labelConfig, options);

					// Determine the color
					style.color = pick(options.color, style.color, series.color, 'black');


					// update existing label
					if (dataLabel) {

						if (defined(str)) {
							dataLabel
								.attr({
									text: str
								});
							isNew = false;

						} else { // #1437 - the label is shown conditionally
							point.dataLabel = dataLabel = dataLabel.destroy();
							if (connector) {
								point.connector = connector.destroy();
							}
						}

					// create new label
					} else if (defined(str)) {
						attr = {
							//align: align,
							fill: options.backgroundColor,
							stroke: options.borderColor,
							'stroke-width': options.borderWidth,
							r: options.borderRadius || 0,
							rotation: rotation,
							padding: options.padding,
							zIndex: 1
						};
						
						// Get automated contrast color
						if (style.color === 'contrast') {
							moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? 
								renderer.getContrast(point.color || series.color) : 
								'#000000';
						}
						if (cursor) {
							moreStyle.cursor = cursor;
						}
						

						// Remove unused attributes (#947)
						for (name in attr) {
							if (attr[name] === UNDEFINED) {
								delete attr[name];
							}
						}

						dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
							str,
							0,
							-999,
							options.shape,
							null,
							null,
							options.useHTML
						)
						.attr(attr)
						.css(extend(style, moreStyle))
						.add(dataLabelsGroup)
						.shadow(options.shadow);

					}

					if (dataLabel) {
						// Now the data label is created and placed at 0,0, so we need to align it
						series.alignDataLabel(point, dataLabel, options, null, isNew);
					}
				}
			});
		}
	};

	/**
	 * Align each individual data label
	 */
	Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
		var chart = this.chart,
			inverted = chart.inverted,
			plotX = pick(point.plotX, -999),
			plotY = pick(point.plotY, -999),
			bBox = dataLabel.getBBox(),
			baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
			rotCorr, // rotation correction
			// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
			visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
				(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
			alignAttr; // the final position;

		if (visible) {

			// The alignment box is a singular point
			alignTo = extend({
				x: inverted ? chart.plotWidth - plotY : plotX,
				y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
				width: 0,
				height: 0
			}, alignTo);

			// Add the text size for alignment calculation
			extend(options, {
				width: bBox.width,
				height: bBox.height
			});

			// Allow a hook for changing alignment in the last moment, then do the alignment
			if (options.rotation) { // Fancy box alignment isn't supported for rotated text
				rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723
				dataLabel[isNew ? 'attr' : 'animate']({
						x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
						y: alignTo.y + options.y + alignTo.height / 2
					})
					.attr({ // #3003
						align: options.align
					});
			} else {
				dataLabel.align(options, null, alignTo);
				alignAttr = dataLabel.alignAttr;

				// Handle justify or crop
				if (pick(options.overflow, 'justify') === 'justify') {
					this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);

				} else if (pick(options.crop, true)) {
					// Now check that the data label is within the plot area
					visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);

				}

				// When we're using a shape, make it possible with a connector or an arrow pointing to thie point
				if (options.shape) {
					dataLabel.attr({
						anchorX: point.plotX,
						anchorY: point.plotY
					});
				}

			}
		}

		// Show or hide based on the final aligned position
		if (!visible) {
			dataLabel.attr({ y: -999 });
			dataLabel.placed = false; // don't animate back in
		}

	};

	/**
	 * If data labels fall partly outside the plot area, align them back in, in a way that
	 * doesn't hide the point.
	 */
	Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
		var chart = this.chart,
			align = options.align,
			verticalAlign = options.verticalAlign,
			off,
			justified,
			padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

		// Off left
		off = alignAttr.x + padding;
		if (off < 0) {
			if (align === 'right') {
				options.align = 'left';
			} else {
				options.x = -off;
			}
			justified = true;
		}

		// Off right
		off = alignAttr.x + bBox.width - padding;
		if (off > chart.plotWidth) {
			if (align === 'left') {
				options.align = 'right';
			} else {
				options.x = chart.plotWidth - off;
			}
			justified = true;
		}

		// Off top
		off = alignAttr.y + padding;
		if (off < 0) {
			if (verticalAlign === 'bottom') {
				options.verticalAlign = 'top';
			} else {
				options.y = -off;
			}
			justified = true;
		}

		// Off bottom
		off = alignAttr.y + bBox.height - padding;
		if (off > chart.plotHeight) {
			if (verticalAlign === 'top') {
				options.verticalAlign = 'bottom';
			} else {
				options.y = chart.plotHeight - off;
			}
			justified = true;
		}

		if (justified) {
			dataLabel.placed = !isNew;
			dataLabel.align(options, null, alignTo);
		}
	};

	/**
	 * Override the base drawDataLabels method by pie specific functionality
	 */
	if (seriesTypes.pie) {
		seriesTypes.pie.prototype.drawDataLabels = function () {
			var series = this,
				data = series.data,
				point,
				chart = series.chart,
				options = series.options.dataLabels,
				connectorPadding = pick(options.connectorPadding, 10),
				connectorWidth = pick(options.connectorWidth, 1),
				plotWidth = chart.plotWidth,
				plotHeight = chart.plotHeight,
				connector,
				connectorPath,
				softConnector = pick(options.softConnector, true),
				distanceOption = options.distance,
				seriesCenter = series.center,
				radius = seriesCenter[2] / 2,
				centerY = seriesCenter[1],
				outside = distanceOption > 0,
				dataLabel,
				dataLabelWidth,
				labelPos,
				labelHeight,
				halves = [// divide the points into right and left halves for anti collision
					[], // right
					[]  // left
				],
				x,
				y,
				visibility,
				rankArr,
				i,
				j,
				overflow = [0, 0, 0, 0], // top, right, bottom, left
				sort = function (a, b) {
					return b.y - a.y;
				};

			// get out if not enabled
			if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
				return;
			}

			// run parent method
			Series.prototype.drawDataLabels.apply(series);

			// arrange points for detection collision
			each(data, function (point) {
				if (point.dataLabel && point.visible) { // #407, #2510
					halves[point.half].push(point);
				}
			});

			/* Loop over the points in each half, starting from the top and bottom
			 * of the pie to detect overlapping labels.
			 */
			i = 2;
			while (i--) {

				var slots = [],
					slotsLength,
					usedSlots = [],
					points = halves[i],
					pos,
					bottom,
					length = points.length,
					slotIndex;

				if (!length) {
					continue;
				}

				// Sort by angle
				series.sortByAngle(points, i - 0.5);

				// Assume equal label heights on either hemisphere (#2630)
				j = labelHeight = 0;
				while (!labelHeight && points[j]) { // #1569
					labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
					j++;
				}

				// Only do anti-collision when we are outside the pie and have connectors (#856)
				if (distanceOption > 0) {

					// Build the slots
					bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
					for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {
						slots.push(pos);
					}
					slotsLength = slots.length;


					/* Visualize the slots
					if (!series.slotElements) {
						series.slotElements = [];
					}
					if (i === 1) {
						series.slotElements.forEach(function (elem) {
							elem.destroy();
						});
						series.slotElements.length = 0;
					}
						
					slots.forEach(function (pos, no) {
						var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
							slotY = pos + chart.plotTop;
						
						if (!isNaN(slotX)) {
							series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
								.attr({
									'stroke-width': 1,
									stroke: 'silver',
									fill: 'rgba(0,0,255,0.1)'
								})
								.add());
							series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
								.attr({
									fill: 'silver'
								}).add());
						}
					});
					// */

					// if there are more values than available slots, remove lowest values
					if (length > slotsLength) {
						// create an array for sorting and ranking the points within each quarter
						rankArr = [].concat(points);
						rankArr.sort(sort);
						j = length;
						while (j--) {
							rankArr[j].rank = j;
						}
						j = length;
						while (j--) {
							if (points[j].rank >= slotsLength) {
								points.splice(j, 1);
							}
						}
						length = points.length;
					}

					// The label goes to the nearest open slot, but not closer to the edge than
					// the label's index.
					for (j = 0; j < length; j++) {

						point = points[j];
						labelPos = point.labelPos;

						var closest = 9999,
							distance,
							slotI;

						// find the closest slot index
						for (slotI = 0; slotI < slotsLength; slotI++) {
							distance = mathAbs(slots[slotI] - labelPos[1]);
							if (distance < closest) {
								closest = distance;
								slotIndex = slotI;
							}
						}

						// if that slot index is closer to the edges of the slots, move it
						// to the closest appropriate slot
						if (slotIndex < j && slots[j] !== null) { // cluster at the top
							slotIndex = j;
						} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
							slotIndex = slotsLength - length + j;
							while (slots[slotIndex] === null) { // make sure it is not taken
								slotIndex++;
							}
						} else {
							// Slot is taken, find next free slot below. In the next run, the next slice will find the
							// slot above these, because it is the closest one
							while (slots[slotIndex] === null) { // make sure it is not taken
								slotIndex++;
							}
						}

						usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
						slots[slotIndex] = null; // mark as taken
					}
					// sort them in order to fill in from the top
					usedSlots.sort(sort);
				}

				// now the used slots are sorted, fill them up sequentially
				for (j = 0; j < length; j++) {

					var slot, naturalY;

					point = points[j];
					labelPos = point.labelPos;
					dataLabel = point.dataLabel;
					visibility = point.visible === false ? HIDDEN : VISIBLE;
					naturalY = labelPos[1];

					if (distanceOption > 0) {
						slot = usedSlots.pop();
						slotIndex = slot.i;

						// if the slot next to currrent slot is free, the y value is allowed
						// to fall back to the natural position
						y = slot.y;
						if ((naturalY > y && slots[slotIndex + 1] !== null) ||
								(naturalY < y &&  slots[slotIndex - 1] !== null)) {
							y = mathMin(mathMax(0, naturalY), chart.plotHeight);
						}

					} else {
						y = naturalY;
					}

					// get the x - use the natural x position for first and last slot, to prevent the top
					// and botton slice connectors from touching each other on either side
					x = options.justify ?
						seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
						series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


					// Record the placement and visibility
					dataLabel._attr = {
						visibility: visibility,
						align: labelPos[6]
					};
					dataLabel._pos = {
						x: x + options.x +
							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
						y: y + options.y - 10 // 10 is for the baseline (label vs text)
					};
					dataLabel.connX = x;
					dataLabel.connY = y;


					// Detect overflowing data labels
					if (this.options.size === null) {
						dataLabelWidth = dataLabel.width;
						// Overflow left
						if (x - dataLabelWidth < connectorPadding) {
							overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

						// Overflow right
						} else if (x + dataLabelWidth > plotWidth - connectorPadding) {
							overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
						}

						// Overflow top
						if (y - labelHeight / 2 < 0) {
							overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

						// Overflow left
						} else if (y + labelHeight / 2 > plotHeight) {
							overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
						}
					}
				} // for each point
			} // for each half

			// Do not apply the final placement and draw the connectors until we have verified
			// that labels are not spilling over.
			if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

				// Place the labels in the final position
				this.placeDataLabels();

				// Draw the connectors
				if (outside && connectorWidth) {
					each(this.points, function (point) {
						connector = point.connector;
						labelPos = point.labelPos;
						dataLabel = point.dataLabel;

						if (dataLabel && dataLabel._pos) {
							visibility = dataLabel._attr.visibility;
							x = dataLabel.connX;
							y = dataLabel.connY;
							connectorPath = softConnector ? [
								M,
								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
								'C',
								x, y, // first break, next to the label
								2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
								labelPos[2], labelPos[3], // second break
								L,
								labelPos[4], labelPos[5] // base
							] : [
								M,
								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
								L,
								labelPos[2], labelPos[3], // second break
								L,
								labelPos[4], labelPos[5] // base
							];

							if (connector) {
								connector.animate({ d: connectorPath });
								connector.attr('visibility', visibility);

							} else {
								point.connector = connector = series.chart.renderer.path(connectorPath).attr({
									'stroke-width': connectorWidth,
									stroke: options.connectorColor || point.color || '#606060',
									visibility: visibility
									//zIndex: 0 // #2722 (reversed)
								})
								.add(series.dataLabelsGroup);
							}
						} else if (connector) {
							point.connector = connector.destroy();
						}
					});
				}
			}
		};
		/**
		 * Perform the final placement of the data labels after we have verified that they
		 * fall within the plot area.
		 */
		seriesTypes.pie.prototype.placeDataLabels = function () {
			each(this.points, function (point) {
				var dataLabel = point.dataLabel,
					_pos;

				if (dataLabel) {
					_pos = dataLabel._pos;
					if (_pos) {
						dataLabel.attr(dataLabel._attr);
						dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
						dataLabel.moved = true;
					} else if (dataLabel) {
						dataLabel.attr({ y: -999 });
					}
				}
			});
		};

		seriesTypes.pie.prototype.alignDataLabel =  noop;

		/**
		 * Verify whether the data labels are allowed to draw, or we should run more translation and data
		 * label positioning to keep them inside the plot area. Returns true when data labels are ready
		 * to draw.
		 */
		seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

			var center = this.center,
				options = this.options,
				centerOption = options.center,
				minSize = options.minSize || 80,
				newSize = minSize,
				ret;

			// Handle horizontal size and center
			if (centerOption[0] !== null) { // Fixed center
				newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

			} else { // Auto center
				newSize = mathMax(
					center[2] - overflow[1] - overflow[3], // horizontal overflow
					minSize
				);
				center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
			}

			// Handle vertical size and center
			if (centerOption[1] !== null) { // Fixed center
				newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

			} else { // Auto center
				newSize = mathMax(
					mathMin(
						newSize,
						center[2] - overflow[0] - overflow[2] // vertical overflow
					),
					minSize
				);
				center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
			}

			// If the size must be decreased, we need to run translate and drawDataLabels again
			if (newSize < center[2]) {
				center[2] = newSize;
				this.translate(center);
				each(this.points, function (point) {
					if (point.dataLabel) {
						point.dataLabel._pos = null; // reset
					}
				});

				if (this.drawDataLabels) {
					this.drawDataLabels();
				}
			// Else, return true to indicate that the pie and its labels is within the plot area
			} else {
				ret = true;
			}
			return ret;
		};
	}

	if (seriesTypes.column) {

		/**
		 * Override the basic data label alignment by adjusting for the position of the column
		 */
		seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
			var inverted = this.chart.inverted,
				series = point.series,
				dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
				below = point.below || (point.plotY > pick(this.translatedThreshold, series.yAxis.len)),
				inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?

			// Align to the column itself, or the top of it
			if (dlBox) { // Area range uses this method but not alignTo
				alignTo = merge(dlBox);

				if (inverted) {
					alignTo = {
						x: series.yAxis.len - alignTo.y - alignTo.height,
						y: series.xAxis.len - alignTo.x - alignTo.width,
						width: alignTo.height,
						height: alignTo.width
					};
				}

				// Compute the alignment box
				if (!inside) {
					if (inverted) {
						alignTo.x += below ? 0 : alignTo.width;
						alignTo.width = 0;
					} else {
						alignTo.y += below ? alignTo.height : 0;
						alignTo.height = 0;
					}
				}
			}


			// When alignment is undefined (typically columns and bars), display the individual
			// point below or above the point depending on the threshold
			options.align = pick(
				options.align,
				!inverted || inside ? 'center' : below ? 'right' : 'left'
			);
			options.verticalAlign = pick(
				options.verticalAlign,
				inverted || inside ? 'middle' : below ? 'top' : 'bottom'
			);

			// Call the parent method
			Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
		};
	}



	/**
	 * Highcharts JS v4.1.4-modified ()
	 * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.
	 *
	 * (c) 2010-2014 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */

	/*global Highcharts, HighchartsAdapter */
	(function (H) {
		var Chart = H.Chart,
			each = H.each,
			addEvent = HighchartsAdapter.addEvent;

		// Collect potensial overlapping data labels. Stack labels probably don't need to be 
		// considered because they are usually accompanied by data labels that lie inside the columns.
		Chart.prototype.callbacks.push(function (chart) {
			function collectAndHide() {
				var labels = [];

				each(chart.series, function (series) {
					var dlOptions = series.options.dataLabels;
					if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
						each(series.points, function (point) { 
							if (point.dataLabel) {
								point.dataLabel.labelrank = point.labelrank;
								labels.push(point.dataLabel);
							}
						});
					}
				});
				chart.hideOverlappingLabels(labels);
			}

			// Do it now ...
			collectAndHide();

			// ... and after each chart redraw
			addEvent(chart, 'redraw', collectAndHide);

		});

		/**
		 * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
		 * visual imression.
		 */		
		Chart.prototype.hideOverlappingLabels = function (labels) {

			var len = labels.length,
				label,
				i,
				j,
				label1,
				label2,
				intersectRect = function (pos1, pos2, size1, size2) {
					return !(
						pos2.x > pos1.x + size1.width ||
						pos2.x + size2.width < pos1.x ||
						pos2.y > pos1.y + size1.height ||
						pos2.y + size2.height < pos1.y
					);
				};
		
			// Mark with initial opacity
			for (i = 0; i < len; i++) {
				label = labels[i];
				if (label) {
					label.oldOpacity = label.opacity;
					label.newOpacity = 1;
				}
			}

			// Detect overlapping labels
			for (i = 0; i < len; i++) {
				label1 = labels[i];

				for (j = i + 1; j < len; ++j) {
					label2 = labels[j];
					if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0 && 
							intersectRect(label1.alignAttr, label2.alignAttr, label1, label2)) {
						(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
					}
				}
			}

			// Hide or show
			for (i = 0; i < len; i++) {
				label = labels[i];
				if (label) {
					if (label.oldOpacity !== label.newOpacity && label.placed) {
						label.alignAttr.opacity = label.newOpacity;
						label[label.isOld && label.newOpacity ? 'animate' : 'attr'](label.alignAttr);
					}
					label.isOld = true;
				}
			}
		};

	}(Highcharts));/**
	 * TrackerMixin for points and graphs
	 */

	var TrackerMixin = Highcharts.TrackerMixin = {

		drawTrackerPoint: function () {
			var series = this,
				chart = series.chart,
				pointer = chart.pointer,
				cursor = series.options.cursor,
				css = cursor && { cursor: cursor },
				onMouseOver = function (e) {
					var target = e.target,
					point;

					while (target && !point) {
						point = target.point;
						target = target.parentNode;
					}

					if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
						point.onMouseOver(e);
					}
				};

			// Add reference to the point
			each(series.points, function (point) {
				if (point.graphic) {
					point.graphic.element.point = point;
				}
				if (point.dataLabel) {
					point.dataLabel.element.point = point;
				}
			});

			// Add the event listeners, we need to do this only once
			if (!series._hasTracking) {
				each(series.trackerGroups, function (key) {
					if (series[key]) { // we don't always have dataLabelsGroup
						series[key]
							.addClass(PREFIX + 'tracker')
							.on('mouseover', onMouseOver)
							.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
							.css(css);
						if (hasTouch) {
							series[key].on('touchstart', onMouseOver);
						}
					}
				});
				series._hasTracking = true;
			}
		},

		/**
		 * Draw the tracker object that sits above all data labels and markers to
		 * track mouse events on the graph or points. For the line type charts
		 * the tracker uses the same graphPath, but with a greater stroke width
		 * for better control.
		 */
		drawTrackerGraph: function () {
			var series = this,
				options = series.options,
				trackByArea = options.trackByArea,
				trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
				trackerPathLength = trackerPath.length,
				chart = series.chart,
				pointer = chart.pointer,
				renderer = chart.renderer,
				snap = chart.options.tooltip.snap,
				tracker = series.tracker,
				cursor = options.cursor,
				css = cursor && { cursor: cursor },
				singlePoints = series.singlePoints,
				singlePoint,
				i,
				onMouseOver = function () {
					if (chart.hoverSeries !== series) {
						series.onMouseOver();
					}
				},
				/*
				 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
				 * IE6: 0.002
				 * IE7: 0.002
				 * IE8: 0.002
				 * IE9: 0.00000000001 (unlimited)
				 * IE10: 0.0001 (exporting only)
				 * FF: 0.00000000001 (unlimited)
				 * Chrome: 0.000001
				 * Safari: 0.000001
				 * Opera: 0.00000000001 (unlimited)
				 */
				TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

			// Extend end points. A better way would be to use round linecaps,
			// but those are not clickable in VML.
			if (trackerPathLength && !trackByArea) {
				i = trackerPathLength + 1;
				while (i--) {
					if (trackerPath[i] === M) { // extend left side
						trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
					}
					if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
						trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
					}
				}
			}

			// handle single points
			for (i = 0; i < singlePoints.length; i++) {
				singlePoint = singlePoints[i];
				trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
				L, singlePoint.plotX + snap, singlePoint.plotY);
			}

			// draw the tracker
			if (tracker) {
				tracker.attr({ d: trackerPath });
			} else { // create

				series.tracker = renderer.path(trackerPath)
				.attr({
					'stroke-linejoin': 'round', // #1225
					visibility: series.visible ? VISIBLE : HIDDEN,
					stroke: TRACKER_FILL,
					fill: trackByArea ? TRACKER_FILL : NONE,
					'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),
					zIndex: 2
				})
				.add(series.group);

				// The tracker is added to the series group, which is clipped, but is covered
				// by the marker group. So the marker group also needs to capture events.
				each([series.tracker, series.markerGroup], function (tracker) {
					tracker.addClass(PREFIX + 'tracker')
						.on('mouseover', onMouseOver)
						.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
						.css(css);

					if (hasTouch) {
						tracker.on('touchstart', onMouseOver);
					}
				});
			}
		}
	};
	/* End TrackerMixin */


	/**
	 * Add tracking event listener to the series group, so the point graphics
	 * themselves act as trackers
	 */ 

	if (seriesTypes.column) {
		ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;	
	}

	if (seriesTypes.pie) {
		seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	}

	if (seriesTypes.scatter) {
		ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	}

	/* 
	 * Extend Legend for item events 
	 */ 
	extend(Legend.prototype, {

		setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
		var legend = this;
		// Set the events on the item group, or in case of useHTML, the item itself (#1249)
		(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
				item.setState(HOVER_STATE);
				legendItem.css(legend.options.itemHoverStyle);
			})
			.on('mouseout', function () {
				legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
				item.setState();
			})
			.on('click', function (event) {
				var strLegendItemClick = 'legendItemClick',
					fnLegendItemClick = function () {
						item.setVisible();
					};
					
				// Pass over the click/touch event. #4.
				event = {
					browserEvent: event
				};

				// click the name or symbol
				if (item.firePointEvent) { // point
					item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
				} else {
					fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
				}
			});
		},

		createCheckboxForItem: function (item) {
			var legend = this;

			item.checkbox = createElement('input', {
				type: 'checkbox',
				checked: item.selected,
				defaultChecked: item.selected // required by IE7
			}, legend.options.itemCheckboxStyle, legend.chart.container);

			addEvent(item.checkbox, 'click', function (event) {
				var target = event.target;
				fireEvent(item.series || item, 'checkboxClick', { // #3712
						checked: target.checked,
						item: item
					},
					function () {
						item.select();
					}
				);
			});
		}	
	});

	/* 
	 * Add pointer cursor to legend itemstyle in defaultOptions
	 */
	defaultOptions.legend.itemStyle.cursor = 'pointer';


	/* 
	 * Extend the Chart object with interaction
	 */

	extend(Chart.prototype, {
		/**
		 * Display the zoom button
		 */
		showResetZoom: function () {
			var chart = this,
				lang = defaultOptions.lang,
				btnOptions = chart.options.chart.resetZoomButton,
				theme = btnOptions.theme,
				states = theme.states,
				alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';
				
			this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)
				.attr({
					align: btnOptions.position.align,
					title: lang.resetZoomTitle
				})
				.add()
				.align(btnOptions.position, false, alignTo);
				
		},

		/**
		 * Zoom out to 1:1
		 */
		zoomOut: function () {
			var chart = this;
			fireEvent(chart, 'selection', { resetSelection: true }, function () { 
				chart.zoom();
			});
		},

		/**
		 * Zoom into a given portion of the chart given by axis coordinates
		 * @param {Object} event
		 */
		zoom: function (event) {
			var chart = this,
				hasZoomed,
				pointer = chart.pointer,
				displayButton = false,
				resetZoomButton;

			// If zoom is called with no arguments, reset the axes
			if (!event || event.resetSelection) {
				each(chart.axes, function (axis) {
					hasZoomed = axis.zoom();
				});
			} else { // else, zoom in on all axes
				each(event.xAxis.concat(event.yAxis), function (axisData) {
					var axis = axisData.axis,
						isXAxis = axis.isXAxis;

					// don't zoom more than minRange
					if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
						hasZoomed = axis.zoom(axisData.min, axisData.max);
						if (axis.displayBtn) {
							displayButton = true;
						}
					}
				});
			}
			
			// Show or hide the Reset zoom button
			resetZoomButton = chart.resetZoomButton;
			if (displayButton && !resetZoomButton) {
				chart.showResetZoom();
			} else if (!displayButton && isObject(resetZoomButton)) {
				chart.resetZoomButton = resetZoomButton.destroy();
			}
			

			// Redraw
			if (hasZoomed) {
				chart.redraw(
					pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
				);
			}
		},

		/**
		 * Pan the chart by dragging the mouse across the pane. This function is called
		 * on mouse move, and the distance to pan is computed from chartX compared to
		 * the first chartX position in the dragging operation.
		 */
		pan: function (e, panning) {

			var chart = this,
				hoverPoints = chart.hoverPoints,
				doRedraw;

			// remove active points for shared tooltip
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
				var mousePos = e[isX ? 'chartX' : 'chartY'],
					axis = chart[isX ? 'xAxis' : 'yAxis'][0],
					startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],
					halfPointRange = (axis.pointRange || 0) / 2,
					extremes = axis.getExtremes(),
					newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
					newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,
					goingLeft = startPos > mousePos; // #3613

				if (axis.series.length && 
						(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && 
						(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
					axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
					doRedraw = true;
				}

				chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run
			});

			if (doRedraw) {
				chart.redraw(false);
			}
			css(chart.container, { cursor: 'move' });
		}
	});

	/*
	 * Extend the Point object with interaction
	 */
	extend(Point.prototype, {
		/**
		 * Toggle the selection status of a point
		 * @param {Boolean} selected Whether to select or unselect the point.
		 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
		 *		 this happens if the control key (Cmd on Mac) was pressed during clicking.
		 */
		select: function (selected, accumulate) {
			var point = this,
				series = point.series,
				chart = series.chart;

			selected = pick(selected, !point.selected);

			// fire the event with the defalut handler
			point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
				point.selected = point.options.selected = selected;
				series.options.data[inArray(point, series.data)] = point.options;

				point.setState(selected && SELECT_STATE);

				// unselect all other points unless Ctrl or Cmd + click
				if (!accumulate) {
					each(chart.getSelectedPoints(), function (loopPoint) {
						if (loopPoint.selected && loopPoint !== point) {
							loopPoint.selected = loopPoint.options.selected = false;
							series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
							loopPoint.setState(NORMAL_STATE);
								loopPoint.firePointEvent('unselect');
						}
					});
				}
			});
		},

		/**
		 * Runs on mouse over the point
		 */
		onMouseOver: function (e) {
			var point = this,
				series = point.series,
				chart = series.chart,
				tooltip = chart.tooltip,
				hoverPoint = chart.hoverPoint;

			if (chart.hoverSeries !== series) {
				series.onMouseOver();
			}		

			// set normal state to previous series
			if (hoverPoint && hoverPoint !== point) {
				hoverPoint.onMouseOut();
			}

			// trigger the event
			point.firePointEvent('mouseOver');

			// update the tooltip
			if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
				tooltip.refresh(point, e);
			}

			// hover this
			point.setState(HOVER_STATE);
			chart.hoverPoint = point;
		},

		/**
		 * Runs on mouse out from the point
		 */
		onMouseOut: function () {
			var chart = this.series.chart,
				hoverPoints = chart.hoverPoints;

			this.firePointEvent('mouseOut');

			if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
				this.setState();
				chart.hoverPoint = null;
			}
		},

		/**
		 * Import events from the series' and point's options. Only do it on
		 * demand, to save processing time on hovering.
		 */
		importEvents: function () {
			if (!this.hasImportedEvents) {
				var point = this,
					options = merge(point.series.options.point, point.options),
					events = options.events,
					eventType;

				point.events = events;

				for (eventType in events) {
					addEvent(point, eventType, events[eventType]);
				}
				this.hasImportedEvents = true;

			}
		},

		/**
		 * Set the point's state
		 * @param {String} state
		 */
		setState: function (state, move) {
			var point = this,
				plotX = point.plotX,
				plotY = point.plotY,
				series = point.series,
				stateOptions = series.options.states,
				markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
				normalDisabled = markerOptions && !markerOptions.enabled,
				markerStateOptions = markerOptions && markerOptions.states[state],
				stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
				stateMarkerGraphic = series.stateMarkerGraphic,
				pointMarker = point.marker || {},
				chart = series.chart,
				radius,
				halo = series.halo,
				haloOptions,
				newSymbol,
				pointAttr;

			state = state || NORMAL_STATE; // empty string
			pointAttr = point.pointAttr[state] || series.pointAttr[state];

			if (
					// already has this state
					(state === point.state && !move) ||
					// selected points don't respond to hover
					(point.selected && state !== SELECT_STATE) ||
					// series' state options is disabled
					(stateOptions[state] && stateOptions[state].enabled === false) ||
					// general point marker's state options is disabled
					(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
					// individual point marker's state options is disabled
					(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

				) {
				return;
			}

			// apply hover styles to the existing point
			if (point.graphic) {
				radius = markerOptions && point.graphic.symbolName && pointAttr.r;
				point.graphic.attr(merge(
					pointAttr,
					radius ? { // new symbol attributes (#507, #612)
						x: plotX - radius,
						y: plotY - radius,
						width: 2 * radius,
						height: 2 * radius
					} : {}
				));

				// Zooming in from a range with no markers to a range with markers
				if (stateMarkerGraphic) {
					stateMarkerGraphic.hide();
				}
			} else {
				// if a graphic is not applied to each point in the normal state, create a shared
				// graphic for the hover state
				if (state && markerStateOptions) {
					radius = markerStateOptions.radius;
					newSymbol = pointMarker.symbol || series.symbol;

					// If the point has another symbol than the previous one, throw away the
					// state marker graphic and force a new one (#1459)
					if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
						stateMarkerGraphic = stateMarkerGraphic.destroy();
					}

					// Add a new state marker graphic
					if (!stateMarkerGraphic) {
						if (newSymbol) {
							series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
								newSymbol,
								plotX - radius,
								plotY - radius,
								2 * radius,
								2 * radius
							)
							.attr(pointAttr)
							.add(series.markerGroup);
							stateMarkerGraphic.currentSymbol = newSymbol;
						}

					// Move the existing graphic
					} else {
						stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
							x: plotX - radius,
							y: plotY - radius
						});
					}
				}

				if (stateMarkerGraphic) {
					stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
				}
			}

			// Show me your halo
			haloOptions = stateOptions[state] && stateOptions[state].halo;
			if (haloOptions && haloOptions.size) {
				if (!halo) {
					series.halo = halo = chart.renderer.path()
						.add(chart.seriesGroup);
				}
				halo.attr(extend({
					fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()
				}, haloOptions.attributes))[move ? 'animate' : 'attr']({
					d: point.haloPath(haloOptions.size)
				});
			} else if (halo) {
				halo.attr({ d: [] });
			}

			point.state = state;
		},

		haloPath: function (size) {
			var series = this.series,
				chart = series.chart,
				plotBox = series.getPlotBox(),
				inverted = chart.inverted;

			return chart.renderer.symbols.circle(
				plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, 
				plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, 
				size * 2, 
				size * 2
			);
		}
	});

	/*
	 * Extend the Series object with interaction
	 */

	extend(Series.prototype, {
		/**
		 * Series mouse over handler
		 */
		onMouseOver: function () {
			var series = this,
				chart = series.chart,
				hoverSeries = chart.hoverSeries;

			// set normal state to previous series
			if (hoverSeries && hoverSeries !== series) {
				hoverSeries.onMouseOut();
			}

			// trigger the event, but to save processing time,
			// only if defined
			if (series.options.events.mouseOver) {
				fireEvent(series, 'mouseOver');
			}

			// hover this
			series.setState(HOVER_STATE);
			chart.hoverSeries = series;
		},

		/**
		 * Series mouse out handler
		 */
		onMouseOut: function () {
			// trigger the event only if listeners exist
			var series = this,
				options = series.options,
				chart = series.chart,
				tooltip = chart.tooltip,
				hoverPoint = chart.hoverPoint;

			// trigger mouse out on the point, which must be in this series
			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			// fire the mouse out event
			if (series && options.events.mouseOut) {
				fireEvent(series, 'mouseOut');
			}


			// hide the tooltip
			if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
				tooltip.hide();
			}

			// set normal state
			series.setState();
			chart.hoverSeries = null;
		},

		/**
		 * Set the state of the graph
		 */
		setState: function (state) {
			var series = this,
				options = series.options,
				graph = series.graph,
				graphNeg = series.graphNeg,
				stateOptions = options.states,
				lineWidth = options.lineWidth,
				attribs;

			state = state || NORMAL_STATE;

			if (series.state !== state) {
				series.state = state;

				if (stateOptions[state] && stateOptions[state].enabled === false) {
					return;
				}

				if (state) {
					lineWidth = (stateOptions[state].lineWidth || lineWidth) + (stateOptions[state].lineWidthPlus || 0);
				}

				if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
					attribs = {
						'stroke-width': lineWidth
					};
					// use attr because animate will cause any other animation on the graph to stop
					graph.attr(attribs);
					if (graphNeg) {
						graphNeg.attr(attribs);
					}
				}
			}
		},

		/**
		 * Set the visibility of the graph
		 *
		 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
		 *				the visibility is toggled.
		 */
		setVisible: function (vis, redraw) {
			var series = this,
				chart = series.chart,
				legendItem = series.legendItem,
				showOrHide,
				ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
				oldVisibility = series.visible;

			// if called without an argument, toggle visibility
			series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
			showOrHide = vis ? 'show' : 'hide';

			// show or hide elements
			each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
				if (series[key]) {
					series[key][showOrHide]();
				}
			});


			// hide tooltip (#1361)
			if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
				series.onMouseOut();
			}


			if (legendItem) {
				chart.legend.colorizeItem(series, vis);
			}


			// rescale or adapt to resized chart
			series.isDirty = true;
			// in a stack, all other series are affected
			if (series.options.stacking) {
				each(chart.series, function (otherSeries) {
					if (otherSeries.options.stacking && otherSeries.visible) {
						otherSeries.isDirty = true;
					}
				});
			}

			// show or hide linked series
			each(series.linkedSeries, function (otherSeries) {
				otherSeries.setVisible(vis, false);
			});

			if (ignoreHiddenSeries) {
				chart.isDirtyBox = true;
			}
			if (redraw !== false) {
				chart.redraw();
			}

			fireEvent(series, showOrHide);
		},

		/**
		 * Show the graph
		 */
		show: function () {
			this.setVisible(true);
		},

		/**
		 * Hide the graph
		 */
		hide: function () {
			this.setVisible(false);
		},


		/**
		 * Set the selected state of the graph
		 *
		 * @param selected {Boolean} True to select the series, false to unselect. If
		 *				UNDEFINED, the selection state is toggled.
		 */
		select: function (selected) {
			var series = this;
			// if called without an argument, toggle
			series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

			if (series.checkbox) {
				series.checkbox.checked = selected;
			}

			fireEvent(series, selected ? 'select' : 'unselect');
		},

		drawTracker: TrackerMixin.drawTrackerGraph
	});
	// global variables
	extend(Highcharts, {
		
		// Constructors
		Color: Color,
		Point: Point,
		Tick: Tick,	
		Renderer: Renderer,
		SVGElement: SVGElement,
		SVGRenderer: SVGRenderer,
		
		// Various
		arrayMin: arrayMin,
		arrayMax: arrayMax,
		charts: charts,
		dateFormat: dateFormat,
		error: error,
		format: format,
		pathAnim: pathAnim,
		getOptions: getOptions,
		hasBidiBug: hasBidiBug,
		isTouchDevice: isTouchDevice,
		setOptions: setOptions,
		addEvent: addEvent,
		removeEvent: removeEvent,
		createElement: createElement,
		discardElement: discardElement,
		css: css,
		each: each,
		map: map,
		merge: merge,
		splat: splat,
		extendClass: extendClass,
		pInt: pInt,
		svg: hasSVG,
		canvas: useCanVG,
		vml: !hasSVG && !useCanVG,
		product: PRODUCT,
		version: VERSION
	});

	}());


	/*** EXPORTS FROM exports-loader ***/
	module.exports = Highcharts

/***/ }
/******/ ])
});

},{"react":183,"react/addons":9}],9:[function(require,module,exports){
var warning = require('./lib/warning');
warning(
  false,
  'require("react/addons") is deprecated. ' +
  'Access using require("react/addons/{addon}") instead.'
);

module.exports = require('./lib/ReactWithAddons');

},{"./lib/ReactWithAddons":110,"./lib/warning":182}],10:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AutoFocusMixin
 * @typechecks static-only
 */

'use strict';

var findDOMNode = require("./findDOMNode");
var focusNode = require("./focusNode");

var AutoFocusMixin = {
  componentDidMount: function () {
    if (this.props.autoFocus) {
      focusNode(findDOMNode(this));
    }
  }
};

module.exports = AutoFocusMixin;
},{"./findDOMNode":141,"./focusNode":143}],11:[function(require,module,exports){
/**
 * Copyright 2013-2015 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var FallbackCompositionState = require("./FallbackCompositionState");
var SyntheticCompositionEvent = require("./SyntheticCompositionEvent");
var SyntheticInputEvent = require("./SyntheticInputEvent");

var keyOf = require("./keyOf");

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBeforeInput: null }),
      captured: keyOf({ onBeforeInputCapture: null })
    },
    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionEnd: null }),
      captured: keyOf({ onCompositionEndCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionStart: null }),
      captured: keyOf({ onCompositionStartCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionUpdate: null }),
      captured: keyOf({ onCompositionUpdateCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionEnd:
      return getDataFromCustomEvent(nativeEvent);
    case topLevelTypes.topKeyPress:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case topLevelTypes.topTextInput:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  if (currentComposition) {
    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case topLevelTypes.topPaste:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case topLevelTypes.topKeyPress:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case topLevelTypes.topCompositionEnd:
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventConstants":24,"./EventPropagators":29,"./ExecutionEnvironment":30,"./FallbackCompositionState":31,"./SyntheticCompositionEvent":116,"./SyntheticInputEvent":120,"./keyOf":165}],12:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSCore
 * @typechecks
 */

'use strict';

var invariant = require("./invariant");

/**
 * The CSSCore module specifies the API (and implements most of the methods)
 * that should be used when dealing with the display of elements (via their
 * CSS classes and visibility on screen. It is an API focused on mutating the
 * display and not reading it as no logical state should be encoded in the
 * display of elements.
 */

var CSSCore = {

  /**
   * Adds the class passed in to the element if it doesn't already have it.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  addClass: function (element, className) {
    !!/\s/.test(className) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'CSSCore.addClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;

    if (className) {
      if (element.classList) {
        element.classList.add(className);
      } else if (!CSSCore.hasClass(element, className)) {
        element.className = element.className + ' ' + className;
      }
    }
    return element;
  },

  /**
   * Removes the class passed in from the element
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  removeClass: function (element, className) {
    !!/\s/.test(className) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'CSSCore.removeClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;

    if (className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (CSSCore.hasClass(element, className)) {
        element.className = element.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ') // multiple spaces to one
        .replace(/^\s*|\s*$/g, ''); // trim the ends
      }
    }
    return element;
  },

  /**
   * Helper to add or remove a class from an element based on a condition.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @param {*} bool condition to whether to add or remove the class
   * @return {DOMElement} the element passed in
   */
  conditionClass: function (element, className, bool) {
    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
  },

  /**
   * Tests whether the element has the class specified.
   *
   * @param {DOMNode|DOMWindow} element the element to set the class on
   * @param {string} className the CSS className
   * @return {boolean} true if the element has the class, false if not
   */
  hasClass: function (element, className) {
    !!/\s/.test(className) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'CSS.hasClass takes only a single class name.') : invariant(false) : undefined;
    if (element.classList) {
      return !!className && element.classList.contains(className);
    }
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
  }

};

module.exports = CSSCore;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],13:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  boxFlex: true,
  boxFlexGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundImage: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundColor: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],14:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require("./CSSProperty");
var ExecutionEnvironment = require("./ExecutionEnvironment");

var camelizeStyleName = require("./camelizeStyleName");
var dangerousStyleValue = require("./dangerousStyleValue");
var hyphenateStyleName = require("./hyphenateStyleName");
var memoizeStringOnly = require("./memoizeStringOnly");
var warning = require("./warning");

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if ('production' !== process.env.NODE_ENV) {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    'production' !== process.env.NODE_ENV ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    'production' !== process.env.NODE_ENV ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    'production' !== process.env.NODE_ENV ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
  };

  /**
   * @param {string} name
   * @param {*} value
   */
  var warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function (styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if ('production' !== process.env.NODE_ENV) {
        warnValidStyle(styleName, styleValue);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function (node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if ('production' !== process.env.NODE_ENV) {
        warnValidStyle(styleName, styles[styleName]);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleName === 'float') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;
}).call(this,require('_process'))

},{"./CSSProperty":13,"./ExecutionEnvironment":30,"./camelizeStyleName":131,"./dangerousStyleValue":137,"./hyphenateStyleName":156,"./memoizeStringOnly":167,"./warning":182,"_process":2}],15:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CallbackQueue
 */

'use strict';

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var invariant = require("./invariant");

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

assign(CallbackQueue.prototype, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function (callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function () {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      !(callbacks.length === contexts.length) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function () {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function () {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;
}).call(this,require('_process'))

},{"./Object.assign":36,"./PooledClass":37,"./invariant":158,"_process":2}],16:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ChangeEventPlugin
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var isEventSupported = require("./isEventSupported");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onChange: null }),
      captured: keyOf({ onChangeCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  return elem.nodeName === 'SELECT' || elem.nodeName === 'INPUT' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue();
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName === 'INPUT' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
      if (targetID) {
        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"./EventConstants":24,"./EventPluginHub":26,"./EventPropagators":29,"./ExecutionEnvironment":30,"./ReactUpdates":109,"./SyntheticEvent":118,"./isEventSupported":159,"./isTextInputElement":161,"./keyOf":165}],17:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

'use strict';

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function () {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;
},{}],18:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

'use strict';

var Danger = require("./Danger");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var setTextContent = require("./setTextContent");
var invariant = require("./invariant");

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.

  // fix render order error in safari
  // IE8 will throw error when index out of list size.
  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

  parentNode.insertBefore(childNode, beforeChild);
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: setTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function (updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; i < updates.length; i++) {
      update = updates[i];
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        !updatedChild ? 'production' !== process.env.NODE_ENV ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; k < updates.length; k++) {
      update = updates[k];
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          setTextContent(update.parentNode, update.textContent);
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;
}).call(this,require('_process'))

},{"./Danger":21,"./ReactMultiChildUpdateTypes":89,"./invariant":158,"./setTextContent":174,"_process":2}],19:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

'use strict';

var invariant = require("./invariant");

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 1,
  MUST_USE_PROPERTY: 2,
  HAS_SIDE_EFFECTS: 4,
  HAS_BOOLEAN_VALUE: 8,
  HAS_NUMERIC_VALUE: 16,
  HAS_POSITIVE_NUMERIC_VALUE: 32 | 16,
  HAS_OVERLOADED_BOOLEAN_VALUE: 64,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.isStandardName.hasOwnProperty(propName) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

      DOMProperty.isStandardName[propName] = true;

      var lowerCased = propName.toLowerCase();
      DOMProperty.getPossibleStandardName[lowerCased] = propName;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        DOMProperty.getPossibleStandardName[attributeName] = propName;
        DOMProperty.getAttributeName[propName] = attributeName;
      } else {
        DOMProperty.getAttributeName[propName] = lowerCased;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        DOMProperty.getAttributeNamespace[propName] = DOMAttributeNamespaces[propName];
      } else {
        DOMProperty.getAttributeNamespace[propName] = null;
      }

      DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName;

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
      } else {
        DOMProperty.getMutationMethod[propName] = null;
      }

      var propConfig = Properties[propName];
      DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
      DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
      DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
      DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
      DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
      DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
      DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);

      !(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName]) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
      !(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName]) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
      !(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Checks whether a property name is a standard property.
   * @type {Object}
   */
  isStandardName: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties.
   * @type {Object}
   */
  getPossibleStandardName: {},

  /**
   * Mapping from normalized names to attribute names that differ. Attribute
   * names are used when rendering markup or with `*Attribute()`.
   * @type {Object}
   */
  getAttributeName: {},

  /**
   * Mapping from normalized names to namespaces.
   * @type {Object}
   */
  getAttributeNamespace: {},

  /**
   * Mapping from normalized names to properties on DOM node instances.
   * (This includes properties that mutate due to external factors.)
   * @type {Object}
   */
  getPropertyName: {},

  /**
   * Mapping from normalized names to mutation methods. This will only exist if
   * mutation cannot be set simply by the property or `setAttribute()`.
   * @type {Object}
   */
  getMutationMethod: {},

  /**
   * Whether the property must be accessed and mutated as an object property.
   * @type {Object}
   */
  mustUseAttribute: {},

  /**
   * Whether the property must be accessed and mutated using `*Attribute()`.
   * (This includes anything that fails `<propName> in <element>`.)
   * @type {Object}
   */
  mustUseProperty: {},

  /**
   * Whether or not setting a value causes side effects such as triggering
   * resources to be loaded or text selection changes. We must ensure that
   * the value is only set if it has changed.
   * @type {Object}
   */
  hasSideEffects: {},

  /**
   * Whether the property should be removed when set to a falsey value.
   * @type {Object}
   */
  hasBooleanValue: {},

  /**
   * Whether the property must be numeric or parse as a
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasNumericValue: {},

  /**
   * Whether the property must be positive numeric or parse as a positive
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasPositiveNumericValue: {},

  /**
   * Whether the property can be used as a flag as well as with a value. Removed
   * when strictly equal to false; present without a value when strictly equal
   * to true; present with a value otherwise.
   * @type {Object}
   */
  hasOverloadedBooleanValue: {},

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function (nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],20:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require("./DOMProperty");

var quoteAttributeValueForBrowser = require("./quoteAttributeValueForBrowser");
var warning = require("./warning");

function shouldIgnoreValue(name, value) {
  return value == null || DOMProperty.hasBooleanValue[name] && !value || DOMProperty.hasNumericValue[name] && isNaN(value) || DOMProperty.hasPositiveNumericValue[name] && value < 1 || DOMProperty.hasOverloadedBooleanValue[name] && value === false;
}

if ('production' !== process.env.NODE_ENV) {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function (name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    'production' !== process.env.NODE_ENV ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
      if (shouldIgnoreValue(name, value)) {
        return '';
      }
      var attributeName = DOMProperty.getAttributeName[name];
      if (DOMProperty.hasBooleanValue[name] || DOMProperty.hasOverloadedBooleanValue[name] && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    } else if ('production' !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(name, value)) {
        this.deleteValueForProperty(node, name);
      } else if (DOMProperty.mustUseAttribute[name]) {
        var attributeName = DOMProperty.getAttributeName[name];
        var namespace = DOMProperty.getAttributeNamespace[name];
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      } else {
        var propName = DOMProperty.getPropertyName[name];
        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
        // property type before comparing; only `value` does and is string.
        if (!DOMProperty.hasSideEffects[name] || '' + node[propName] !== '' + value) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        node.removeAttribute(name);
      } else {
        node.setAttribute(name, '' + value);
      }
    } else if ('production' !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (DOMProperty.mustUseAttribute[name]) {
        node.removeAttribute(DOMProperty.getAttributeName[name]);
      } else {
        var propName = DOMProperty.getPropertyName[name];
        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
        if (!DOMProperty.hasSideEffects[name] || '' + node[propName] !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if ('production' !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  }

};

module.exports = DOMPropertyOperations;
}).call(this,require('_process'))

},{"./DOMProperty":19,"./quoteAttributeValueForBrowser":171,"./warning":182,"_process":2}],21:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createNodesFromMarkup = require("./createNodesFromMarkup");
var emptyFunction = require("./emptyFunction");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function (markupList) {
    !ExecutionEnvironment.canUseDOM ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(false) : undefined;
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      !markupList[i] ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      var resultIndex;
      for (resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
          // This index will be parsed back out below.
          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
      );

      for (var j = 0; j < renderNodes.length; ++j) {
        var renderNode = renderNodes[j];
        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          !!resultList.hasOwnProperty(resultIndex) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;
        } else if ('production' !== process.env.NODE_ENV) {
          console.error('Danger: Discarding unexpected node:', renderNode);
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    !(resultListAssignmentCount === resultList.length) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

    !(resultList.length === markupList.length) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(false) : undefined;
    !markup ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
    !(oldChild.tagName.toLowerCase() !== 'html') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See React.renderToString().') : invariant(false) : undefined;

    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":30,"./createNodesFromMarkup":136,"./emptyFunction":138,"./getMarkupWrap":151,"./invariant":158,"_process":2}],22:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultEventPluginOrder
 */

'use strict';

var keyOf = require("./keyOf");

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null }), keyOf({ AnalyticsEventPlugin: null })];

module.exports = DefaultEventPluginOrder;
},{"./keyOf":165}],23:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");

var ReactMount = require("./ReactMount");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({ onMouseEnter: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  },
  mouseLeave: {
    registrationName: keyOf({ onMouseLeave: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from, to;
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
    } else {
      from = win;
      to = topLevelTarget;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromID = from ? ReactMount.getID(from) : '';
    var toID = to ? ReactMount.getID(to) : '';

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;
},{"./EventConstants":24,"./EventPropagators":29,"./ReactMount":87,"./SyntheticMouseEvent":122,"./keyOf":165}],24:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

'use strict';

var keyMirror = require("./keyMirror");

var PropagationPhases = keyMirror({ bubbled: null, captured: null });

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topBlur: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topReset: null,
  topScroll: null,
  topSelectionChange: null,
  topSubmit: null,
  topTextInput: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;
},{"./keyMirror":164}],25:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventListener
 * @typechecks
 */

'use strict';

var emptyFunction = require("./emptyFunction");

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function (target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function () {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function (target, eventType, callback) {
    if (!target.addEventListener) {
      if ('production' !== process.env.NODE_ENV) {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    } else {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, true);
        }
      };
    }
  },

  registerDefault: function () {}
};

module.exports = EventListener;
}).call(this,require('_process'))

},{"./emptyFunction":138,"_process":2}],26:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

'use strict';

var EventPluginRegistry = require("./EventPluginRegistry");
var EventPluginUtils = require("./EventPluginUtils");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");
var warning = require("./warning");

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */
var executeDispatchesAndRelease = function (event) {
  if (event) {
    var executeDispatch = EventPluginUtils.executeDispatch;
    // Plugins can provide custom behavior when dispatching events.
    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
    if (PluginModule && PluginModule.executeDispatch) {
      executeDispatch = PluginModule.executeDispatch;
    }
    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
  'production' !== process.env.NODE_ENV ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function (InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if ('production' !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function () {
      if ('production' !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function (id, registrationName, listener) {
    !(typeof listener === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;

    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(id, registrationName, listener);
    }
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (id, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(id, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function (id) {
    for (var registrationName in listenerBank) {
      if (!listenerBank[registrationName][id]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(id, registrationName);
      }

      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function () {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
    !!eventQueue ? 'production' !== process.env.NODE_ENV ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
}).call(this,require('_process'))

},{"./EventPluginRegistry":27,"./EventPluginUtils":28,"./accumulateInto":128,"./forEachAccumulated":144,"./invariant":158,"./warning":182,"_process":2}],27:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

'use strict';

var invariant = require("./invariant");

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !PluginModule.extractEvents ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (InjectedEventPluginOrder) {
    !!EventPluginOrder ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
        !!namesToPlugins[pluginName] ? 'production' !== process.env.NODE_ENV ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],28:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

'use strict';

var EventConstants = require("./EventConstants");

var invariant = require("./invariant");
var warning = require("./warning");

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function (InjectedMount) {
    injection.Mount = InjectedMount;
    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
}

var validateEventDispatches;
if ('production' !== process.env.NODE_ENV) {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    'production' !== process.env.NODE_ENV ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
  };
}

/**
 * Invokes `cb(event, listener, id)`. Avoids using call if no scope is
 * provided. The `(listener,id)` pair effectively forms the "dispatch" but are
 * kept separate to conserve memory.
 */
function forEachEventDispatch(event, cb) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ('production' !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      cb(event, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    cb(event, dispatchListeners, dispatchIDs);
  }
}

/**
 * Default implementation of PluginModule.executeDispatch().
 * @param {SyntheticEvent} SyntheticEvent to handle
 * @param {function} Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, listener, domID) {
  event.currentTarget = injection.Mount.getNode(domID);
  var returnValue = listener(event, domID);
  event.currentTarget = null;
  return returnValue;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, cb) {
  forEachEventDispatch(event, cb);
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return id of the first dispatch execution who's listener returns true, or
 * null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ('production' !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ('production' !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  !!Array.isArray(dispatchListener) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {bool} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatch: executeDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getNode: function (id) {
    return injection.Mount.getNode(id);
  },
  getID: function (node) {
    return injection.Mount.getID(node);
  },

  injection: injection
};

module.exports = EventPluginUtils;
}).call(this,require('_process'))

},{"./EventConstants":24,"./invariant":158,"./warning":182,"_process":2}],29:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");

var warning = require("./warning");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(domID, 'Dispatching id must not be null') : undefined;
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We can not perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
}).call(this,require('_process'))

},{"./EventConstants":24,"./EventPluginHub":26,"./accumulateInto":128,"./forEachAccumulated":144,"./warning":182,"_process":2}],30:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],31:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FallbackCompositionState
 * @typechecks static-only
 */

'use strict';

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var getTextContentAccessor = require("./getTextContentAccessor");

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

assign(FallbackCompositionState.prototype, {
  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./Object.assign":36,"./PooledClass":37,"./getTextContentAccessor":153}],32:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

'use strict';

var DOMProperty = require("./DOMProperty");
var ExecutionEnvironment = require("./ExecutionEnvironment");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
}

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    acceptCharset: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusMixin
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    classID: MUST_USE_ATTRIBUTE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formAction: MUST_USE_ATTRIBUTE,
    formEncType: MUST_USE_ATTRIBUTE,
    formMethod: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: MUST_USE_ATTRIBUTE,
    frameBorder: MUST_USE_ATTRIBUTE,
    headers: null,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    high: null,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    label: null,
    lang: null,
    list: MUST_USE_ATTRIBUTE,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    low: null,
    manifest: MUST_USE_ATTRIBUTE,
    marginHeight: null,
    marginWidth: null,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    media: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    minLength: MUST_USE_ATTRIBUTE,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: null,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: null,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    sizes: MUST_USE_ATTRIBUTE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcSet: MUST_USE_ATTRIBUTE,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: null,
    autoCorrect: null,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: MUST_USE_ATTRIBUTE,
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    itemType: MUST_USE_ATTRIBUTE,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: MUST_USE_ATTRIBUTE,
    itemRef: MUST_USE_ATTRIBUTE,
    // property is supported for OpenGraph in meta tags.
    property: null,
    // IE-only attribute that controls focus behavior
    unselectable: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoCapitalize: 'autocapitalize',
    autoComplete: 'autocomplete',
    autoCorrect: 'autocorrect',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
    encType: 'encoding',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":19,"./ExecutionEnvironment":30}],33:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedStateMixin
 * @typechecks static-only
 */

'use strict';

var ReactLink = require("./ReactLink");
var ReactStateSetters = require("./ReactStateSetters");

/**
 * A simple mixin around ReactLink.forState().
 */
var LinkedStateMixin = {
  /**
   * Create a ReactLink that's linked to part of this component's state. The
   * ReactLink will have the current value of this.state[key] and will call
   * setState() when a change is requested.
   *
   * @param {string} key state key to update. Note: you may want to use keyOf()
   * if you're using Google Closure Compiler advanced mode.
   * @return {ReactLink} ReactLink instance linking to the state.
   */
  linkState: function (key) {
    return new ReactLink(this.state[key], ReactStateSetters.createStateKeySetter(this, key));
  }
};

module.exports = LinkedStateMixin;
},{"./ReactLink":85,"./ReactStateSetters":103}],34:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

'use strict';

var ReactPropTypes = require("./ReactPropTypes");

var invariant = require("./invariant");

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
}

/**
 * @param {SyntheticEvent} e change event to handle
 */
function _handleLinkedValueChange(e) {
  /*jshint validthis:true */
  this.props.valueLink.requestChange(e.target.value);
}

/**
  * @param {SyntheticEvent} e change event to handle
  */
function _handleLinkedCheckChange(e) {
  /*jshint validthis:true */
  this.props.checkedLink.requestChange(e.target.checked);
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  Mixin: {
    propTypes: {
      value: function (props, propName, componentName) {
        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      checked: function (props, propName, componentName) {
        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      onChange: ReactPropTypes.func
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {function} change callback either from onChange prop or link.
   */
  getOnChange: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return _handleLinkedValueChange;
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return _handleLinkedCheckChange;
    }
    return inputProps.onChange;
  }
};

module.exports = LinkedValueUtils;
}).call(this,require('_process'))

},{"./ReactPropTypes":96,"./invariant":158,"_process":2}],35:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LocalEventTrapMixin
 */

'use strict';

var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");

var accumulateInto = require("./accumulateInto");
var findDOMNode = require("./findDOMNode");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");

function remove(event) {
  event.remove();
}

var LocalEventTrapMixin = {
  trapBubbledEvent: function (topLevelType, handlerBaseName) {
    !this.isMounted() ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
    // If a component renders to null or if another component fatals and causes
    // the state of the tree to be corrupted, `node` here can be null.
    var node = findDOMNode(this);
    !node ? 'production' !== process.env.NODE_ENV ? invariant(false, 'LocalEventTrapMixin.trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
    var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, node);
    this._localEventListeners = accumulateInto(this._localEventListeners, listener);
  },

  // trapCapturedEvent would look nearly identical. We don't implement that
  // method because it isn't currently needed.

  componentWillUnmount: function () {
    if (this._localEventListeners) {
      forEachAccumulated(this._localEventListeners, remove);
    }
  }
};

module.exports = LocalEventTrapMixin;
}).call(this,require('_process'))

},{"./ReactBrowserEventEmitter":40,"./accumulateInto":128,"./findDOMNode":141,"./forEachAccumulated":144,"./invariant":158,"_process":2}],36:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;
},{}],37:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

'use strict';

var invariant = require("./invariant");

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
  if (instance.destructor) {
    instance.destructor();
  }
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],38:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

var ReactDOMClient = require("./ReactDOMClient");
var ReactDOMServer = require("./ReactDOMServer");
var ReactIsomorphic = require("./ReactIsomorphic");

var assign = require("./Object.assign");

var React = {};

assign(React, ReactIsomorphic);
assign(React, ReactDOMClient);
assign(React, ReactDOMServer);

React.version = '0.14.0-alpha3';

module.exports = React;
},{"./Object.assign":36,"./ReactDOMClient":55,"./ReactDOMServer":65,"./ReactIsomorphic":83}],39:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserComponentMixin
 */

'use strict';

var ReactInstanceMap = require("./ReactInstanceMap");

var findDOMNode = require("./findDOMNode");
var warning = require("./warning");

var didWarnKey = '_getDOMNodeDidWarn';

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function () {
    'production' !== process.env.NODE_ENV ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'React.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
    this.constructor[didWarnKey] = true;
    return findDOMNode(this);
  }
};

module.exports = ReactBrowserComponentMixin;
}).call(this,require('_process'))

},{"./ReactInstanceMap":82,"./findDOMNode":141,"./warning":182,"_process":2}],40:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPluginRegistry = require("./EventPluginRegistry");
var ReactEventEmitterMixin = require("./ReactEventEmitterMixin");
var ViewportMetrics = require("./ViewportMetrics");

var assign = require("./Object.assign");
var isEventSupported = require("./isEventSupported");

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topBlur: 'blur',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topScroll: 'scroll',
  topSelectionChange: 'selectionchange',
  topTextInput: 'textInput',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

module.exports = ReactBrowserEventEmitter;
},{"./EventConstants":24,"./EventPluginHub":26,"./EventPluginRegistry":27,"./Object.assign":36,"./ReactEventEmitterMixin":76,"./ViewportMetrics":127,"./isEventSupported":159}],41:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroup
 */

'use strict';

var React = require("./React");

var assign = require("./Object.assign");

var ReactTransitionGroup = React.createFactory(require("./ReactTransitionGroup"));
var ReactCSSTransitionGroupChild = React.createFactory(require("./ReactCSSTransitionGroupChild"));

var ReactCSSTransitionGroup = React.createClass({
  displayName: 'ReactCSSTransitionGroup',

  propTypes: {
    transitionName: React.PropTypes.string.isRequired,
    transitionAppear: React.PropTypes.bool,
    transitionEnter: React.PropTypes.bool,
    transitionLeave: React.PropTypes.bool
  },

  getDefaultProps: function () {
    return {
      transitionAppear: false,
      transitionEnter: true,
      transitionLeave: true
    };
  },

  _wrapChild: function (child) {
    // We need to provide this childFactory so that
    // ReactCSSTransitionGroupChild can receive updates to name, enter, and
    // leave while it is leaving.
    return ReactCSSTransitionGroupChild({
      name: this.props.transitionName,
      appear: this.props.transitionAppear,
      enter: this.props.transitionEnter,
      leave: this.props.transitionLeave
    }, child);
  },

  render: function () {
    return ReactTransitionGroup(assign({}, this.props, { childFactory: this._wrapChild }));
  }
});

module.exports = ReactCSSTransitionGroup;
},{"./Object.assign":36,"./React":38,"./ReactCSSTransitionGroupChild":42,"./ReactTransitionGroup":107}],42:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroupChild
 */

'use strict';

var React = require("./React");

var CSSCore = require("./CSSCore");
var ReactTransitionEvents = require("./ReactTransitionEvents");

var onlyChild = require("./onlyChild");
var warning = require("./warning");

// We don't remove the element from the DOM until we receive an animationend or
// transitionend event. If the user screws up and forgets to add an animation
// their node will be stuck in the DOM forever, so we detect if an animation
// does not start and if it doesn't, we just call the end listener immediately.
var TICK = 17;
var NO_EVENT_TIMEOUT = 5000;

var noEventListener = null;

if ('production' !== process.env.NODE_ENV) {
  noEventListener = function () {
    'production' !== process.env.NODE_ENV ? warning(false, 'transition(): tried to perform an animation without ' + 'an animationend or transitionend event after timeout (' + '%sms). You should either disable this ' + 'transition in JS or add a CSS animation/transition.', NO_EVENT_TIMEOUT) : undefined;
  };
}

var ReactCSSTransitionGroupChild = React.createClass({
  displayName: 'ReactCSSTransitionGroupChild',

  transition: function (animationType, finishCallback) {
    var node = React.findDOMNode(this);
    var className = this.props.name + '-' + animationType;
    var activeClassName = className + '-active';
    var noEventTimeout = null;

    var endListener = function (e) {
      if (e && e.target !== node) {
        return;
      }
      if ('production' !== process.env.NODE_ENV) {
        clearTimeout(noEventTimeout);
      }

      CSSCore.removeClass(node, className);
      CSSCore.removeClass(node, activeClassName);

      ReactTransitionEvents.removeEndEventListener(node, endListener);

      // Usually this optional callback is used for informing an owner of
      // a leave animation and telling it to remove the child.
      if (finishCallback) {
        finishCallback();
      }
    };

    ReactTransitionEvents.addEndEventListener(node, endListener);

    CSSCore.addClass(node, className);

    // Need to do this to actually trigger a transition.
    this.queueClass(activeClassName);

    if ('production' !== process.env.NODE_ENV) {
      noEventTimeout = setTimeout(noEventListener, NO_EVENT_TIMEOUT);
    }
  },

  queueClass: function (className) {
    this.classNameQueue.push(className);

    if (!this.timeout) {
      this.timeout = setTimeout(this.flushClassNameQueue, TICK);
    }
  },

  flushClassNameQueue: function () {
    if (this.isMounted()) {
      this.classNameQueue.forEach(CSSCore.addClass.bind(CSSCore, React.findDOMNode(this)));
    }
    this.classNameQueue.length = 0;
    this.timeout = null;
  },

  componentWillMount: function () {
    this.classNameQueue = [];
  },

  componentWillUnmount: function () {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
  },

  componentWillAppear: function (done) {
    if (this.props.appear) {
      this.transition('appear', done);
    } else {
      done();
    }
  },

  componentWillEnter: function (done) {
    if (this.props.enter) {
      this.transition('enter', done);
    } else {
      done();
    }
  },

  componentWillLeave: function (done) {
    if (this.props.leave) {
      this.transition('leave', done);
    } else {
      done();
    }
  },

  render: function () {
    return onlyChild(this.props.children);
  }
});

module.exports = ReactCSSTransitionGroupChild;
}).call(this,require('_process'))

},{"./CSSCore":12,"./React":38,"./ReactTransitionEvents":106,"./onlyChild":168,"./warning":182,"_process":2}],43:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildReconciler
 * @typechecks static-only
 */

'use strict';

var ReactReconciler = require("./ReactReconciler");

var flattenChildren = require("./flattenChildren");
var instantiateReactComponent = require("./instantiateReactComponent");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {

  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context) {
    var children = flattenChildren(nestedChildNodes);
    for (var name in children) {
      if (children.hasOwnProperty(name)) {
        var child = children[name];
        // The rendered children must be turned into instances as they're
        // mounted.
        var childInstance = instantiateReactComponent(child, null);
        children[name] = childInstance;
      }
    }
    return children;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextNestedChildNodes Nested child maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextNestedChildNodes, transaction, context) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    var nextChildren = flattenChildren(nextNestedChildNodes);
    if (!nextChildren && !prevChildren) {
      return null;
    }
    var name;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      var prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          ReactReconciler.unmountComponent(prevChild, name);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, null);
        nextChildren[name] = nextChildInstance;
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        ReactReconciler.unmountComponent(prevChildren[name]);
      }
    }
    return nextChildren;
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild);
      }
    }
  }

};

module.exports = ReactChildReconciler;
},{"./ReactReconciler":98,"./flattenChildren":142,"./instantiateReactComponent":157,"./shouldUpdateReactComponent":177}],44:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

'use strict';

var PooledClass = require("./PooledClass");
var ReactFragment = require("./ReactFragment");

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var threeArgumentPooler = PooledClass.threeArgumentPooler;

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(traverseContext, child, name) {
  var bookKeeping = traverseContext;
  bookKeeping.func.call(bookKeeping.context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc.
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }

  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, mapFunction, mapContext) {
  this.result = mapResult;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);

function mapSingleChildIntoContext(traverseContext, child, name) {
  var bookKeeping = traverseContext;
  var mapResult = bookKeeping.result;

  var keyUnique = mapResult[name] === undefined;
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(keyUnique, 'ReactChildren.map(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }

  if (keyUnique) {
    var mappedChild = bookKeeping.func.call(bookKeeping.context, child, bookKeeping.count++);
    mapResult[name] = mappedChild;
  }
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * TODO: This may likely break any calls to `ReactChildren.map` that were
 * previously relying on the fact that we guarded against null children.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} mapFunction.
 * @param {*} mapContext Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var mapResult = {};
  var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
  return ReactFragment.create(mapResult);
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  count: countChildren
};

module.exports = ReactChildren;
}).call(this,require('_process'))

},{"./PooledClass":37,"./ReactFragment":78,"./traverseAllChildren":179,"./warning":182,"_process":2}],45:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */

'use strict';

var ReactComponent = require("./ReactComponent");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactErrorUtils = require("./ReactErrorUtils");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactLifeCycle = require("./ReactLifeCycle");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactUpdateQueue = require("./ReactUpdateQueue");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var keyMirror = require("./keyMirror");
var keyOf = require("./keyOf");
var warning = require("./warning");

var MIXINS_KEY = keyOf({ mixins: null });

/**
 * Policies that describe methods in `ReactClassInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});

var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if ('production' !== process.env.NODE_ENV) {
      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if ('production' !== process.env.NODE_ENV) {
      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if ('production' !== process.env.NODE_ENV) {
      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  }
};

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but not in __DEV__
      'production' !== process.env.NODE_ENV ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  !(typeof spec !== 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
  !!ReactElement.isValidElement(spec) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

  var proto = Constructor.prototype;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if ('production' !== process.env.NODE_ENV) {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = (name in RESERVED_SPEC_KEYS);
    !!isReserved ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

    var isInherited = (name in Constructor);
    !!isInherited ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if ('production' !== process.env.NODE_ENV) {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    /* eslint-disable block-scoped-var, no-undef */
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        'production' !== process.env.NODE_ENV ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
      } else if (!args.length) {
        'production' !== process.env.NODE_ENV ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
      /* eslint-enable */
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  for (var autoBindKey in component.__reactAutoBindMap) {
    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
      var method = component.__reactAutoBindMap[autoBindKey];
      component[autoBindKey] = bindAutoBindMethod(component, ReactErrorUtils.guard(method, component.constructor.displayName + '.' + autoBindKey));
    }
  }
}

var typeDeprecationDescriptor = {
  enumerable: false,
  get: function () {
    var displayName = this.displayName || this.name || 'Component';
    'production' !== process.env.NODE_ENV ? warning(false, '%s.type is deprecated. Use %s directly to access the class.', displayName, displayName) : undefined;
    Object.defineProperty(this, 'type', {
      value: this
    });
    return this;
  }
};

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    ReactUpdateQueue.enqueueReplaceState(this, newState);
    if (callback) {
      ReactUpdateQueue.enqueueCallback(this, callback);
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    if ('production' !== process.env.NODE_ENV) {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        'production' !== process.env.NODE_ENV ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(this);
    if (internalInstance) {
      return internalInstance !== ReactLifeCycle.currentlyMountingInstance;
    } else {
      return false;
    }
  },

  /**
   * Sets a subset of the props.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  setProps: function (partialProps, callback) {
    ReactUpdateQueue.enqueueSetProps(this, partialProps);
    if (callback) {
      ReactUpdateQueue.enqueueCallback(this, callback);
    }
  },

  /**
   * Replace all the props.
   *
   * @param {object} newProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  replaceProps: function (newProps, callback) {
    ReactUpdateQueue.enqueueReplaceProps(this, newProps);
    if (callback) {
      ReactUpdateQueue.enqueueCallback(this, callback);
    }
  }
};

var ReactClassComponent = function () {};
assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    var Constructor = function (props, context) {
      // This constructor is overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if ('production' !== process.env.NODE_ENV) {
        'production' !== process.env.NODE_ENV ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindMap) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if ('production' !== process.env.NODE_ENV) {
        // We allow auto-mocks to proceed as if they're returning null.
        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

      this.state = initialState;
    };
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if ('production' !== process.env.NODE_ENV) {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? 'production' !== process.env.NODE_ENV ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    // Legacy hook
    Constructor.type = Constructor;
    if ('production' !== process.env.NODE_ENV) {
      try {
        Object.defineProperty(Constructor, 'type', typeDeprecationDescriptor);
      } catch (x) {}
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;

// IE will fail on defineProperty (es5-shim/sham too)
}).call(this,require('_process'))

},{"./Object.assign":36,"./ReactComponent":46,"./ReactCurrentOwner":52,"./ReactElement":72,"./ReactErrorUtils":75,"./ReactInstanceMap":82,"./ReactLifeCycle":84,"./ReactPropTypeLocationNames":94,"./ReactPropTypeLocations":95,"./ReactUpdateQueue":108,"./invariant":158,"./keyMirror":164,"./keyOf":165,"./warning":182,"_process":2}],46:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

'use strict';

var ReactUpdateQueue = require("./ReactUpdateQueue");

var invariant = require("./invariant");
var warning = require("./warning");

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context) {
  this.props = props;
  this.context = context;
}

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
  }
  ReactUpdateQueue.enqueueSetState(this, partialState);
  if (callback) {
    ReactUpdateQueue.enqueueCallback(this, callback);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  ReactUpdateQueue.enqueueForceUpdate(this);
  if (callback) {
    ReactUpdateQueue.enqueueCallback(this, callback);
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if ('production' !== process.env.NODE_ENV) {
  var deprecatedAPIs = {
    getDOMNode: ['getDOMNode', 'Use React.findDOMNode(component) instead.'],
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceProps: ['replaceProps', 'Instead, call React.render again at the top level.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
    setProps: ['setProps', 'Instead, call React.render again at the top level.']
  };
  var defineDeprecationWarning = function (methodName, info) {
    try {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          'production' !== process.env.NODE_ENV ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
          return undefined;
        }
      });
    } catch (x) {}
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;

// IE will fail on defineProperty (es5-shim/sham too)
}).call(this,require('_process'))

},{"./ReactUpdateQueue":108,"./invariant":158,"./warning":182,"_process":2}],47:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

'use strict';

var ReactDOMIDOperations = require("./ReactDOMIDOperations");
var ReactMount = require("./ReactMount");

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function (rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  }

};

module.exports = ReactComponentBrowserEnvironment;
},{"./ReactDOMIDOperations":58,"./ReactMount":87}],48:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentEnvironment
 */

'use strict';

var invariant = require("./invariant");

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable environment dependent cleanup hook. (server vs.
   * browser etc). Example: A browser system caches DOM nodes based on component
   * ID and must remove that cache entry when this instance is unmounted.
   */
  unmountIDFromEnvironment: null,

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkupByID: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],49:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule ReactComponentWithPureRenderMixin
*/

'use strict';

var shallowCompare = require("./shallowCompare");

/**
 * If your React component's render function is "pure", e.g. it will render the
 * same result given the same props and state, provide this Mixin for a
 * considerable performance boost.
 *
 * Most React components have pure render functions.
 *
 * Example:
 *
 *   var ReactComponentWithPureRenderMixin =
 *     require('ReactComponentWithPureRenderMixin');
 *   React.createClass({
 *     mixins: [ReactComponentWithPureRenderMixin],
 *
 *     render: function() {
 *       return <div className={this.props.className}>foo</div>;
 *     }
 *   });
 *
 * Note: This only checks shallow equality for props and state. If these contain
 * complex data structures this mixin may have false-negatives for deeper
 * differences. Only mixin to components which have simple props and state, or
 * use `forceUpdate()` when you know deep data structures have changed.
 */
var ReactComponentWithPureRenderMixin = {
  shouldComponentUpdate: function (nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }
};

module.exports = ReactComponentWithPureRenderMixin;
},{"./shallowCompare":175}],50:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

'use strict';

var ReactComponentEnvironment = require("./ReactComponentEnvironment");
var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactLifeCycle = require("./ReactLifeCycle");
var ReactNativeComponent = require("./ReactNativeComponent");
var ReactPerf = require("./ReactPerf");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactReconciler = require("./ReactReconciler");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var emptyObject = require("./emptyObject");
var invariant = require("./invariant");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var warning = require("./warning");

function getDeclarationErrorAddendum(component) {
  var owner = component._currentElement._owner || null;
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = null;
    this._instance = null;

    // See ReactUpdateQueue
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedComponent = null;

    this._context = null;
    this._mountOrder = 0;
    this._isTopLevel = false;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    this._context = context;
    this._mountOrder = nextMountID++;
    this._rootNodeID = rootID;

    var publicProps = this._processProps(this._currentElement.props);
    var publicContext = this._processContext(context);

    var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);

    // Initialize the public class
    var inst = new Component(publicProps, publicContext);

    if ('production' !== process.env.NODE_ENV) {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      'production' !== process.env.NODE_ENV ? warning(inst.render != null, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render` in your ' + 'component or you may have accidentally tried to render an element ' + 'whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if ('production' !== process.env.NODE_ENV) {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      'production' !== process.env.NODE_ENV ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
      'production' !== process.env.NODE_ENV ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
      'production' !== process.env.NODE_ENV ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
      'production' !== process.env.NODE_ENV ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
      'production' !== process.env.NODE_ENV ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var renderedElement;

    var previouslyMounting = ReactLifeCycle.currentlyMountingInstance;
    ReactLifeCycle.currentlyMountingInstance = this;
    try {
      if (inst.componentWillMount) {
        inst.componentWillMount();
        // When mounting, calls to `setState` by `componentWillMount` will set
        // `this._pendingStateQueue` without triggering a re-render.
        if (this._pendingStateQueue) {
          inst.state = this._processPendingState(inst.props, inst.context);
        }
      }

      renderedElement = this._renderValidatedComponent();
    } finally {
      ReactLifeCycle.currentlyMountingInstance = previouslyMounting;
    }

    this._renderedComponent = this._instantiateReactComponent(renderedElement, this._currentElement.type // The wrapping type
    );

    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
    if (inst.componentDidMount) {
      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    }

    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function () {
    var inst = this._instance;

    if (inst.componentWillUnmount) {
      var previouslyUnmounting = ReactLifeCycle.currentlyUnmountingInstance;
      ReactLifeCycle.currentlyUnmountingInstance = this;
      try {
        inst.componentWillUnmount();
      } finally {
        ReactLifeCycle.currentlyUnmountingInstance = previouslyUnmounting;
      }
    }

    ReactReconciler.unmountComponent(this._renderedComponent);
    this._renderedComponent = null;

    // Reset pending fields
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Schedule a partial update to the props. Only used for internal testing.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @internal
   */
  _setPropsInternal: function (partialProps, callback) {
    // This is a deoptimized path. We optimize for always having an element.
    // This creates an extra internal element.
    var element = this._pendingElement || this._currentElement;
    this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps));
    ReactUpdates.enqueueUpdate(this, callback);
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var maskedContext = null;
    var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if ('production' !== process.env.NODE_ENV) {
      var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
      if (Component.contextTypes) {
        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var inst = this._instance;
    var childContext = inst.getChildContext && inst.getChildContext();
    if (childContext) {
      !(typeof inst.constructor.childContextTypes === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
      if ('production' !== process.env.NODE_ENV) {
        this._checkPropTypes(inst.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);
      }
      for (var name in childContext) {
        !(name in inst.constructor.childContextTypes) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
      }
      return assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function (newProps) {
    if ('production' !== process.env.NODE_ENV) {
      var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
      if (Component.propTypes) {
        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
      }
    }
    return newProps;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function (propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the element
    // validation.
    var componentName = this.getName();
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error;
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof propTypes[propName] === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
          error = propTypes[propName](props, propName, componentName, location);
        } catch (ex) {
          error = ex;
        }
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // React.render calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);

          if (location === ReactPropTypeLocations.prop) {
            // Preface gives us something to blacklist in warning module
            'production' !== process.env.NODE_ENV ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
          } else {
            'production' !== process.env.NODE_ENV ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
          }
        }
      }
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
    }

    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      if ('production' !== process.env.NODE_ENV) {
        ReactElementValidator.checkAndWarnForMutatedProps(this._currentElement);
      }

      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;

    var nextContext = inst.context;
    var nextProps = inst.props;

    // Distinguish between a props update versus a simple state update
    if (prevParentElement !== nextParentElement) {
      nextContext = this._processContext(nextUnmaskedContext);
      nextProps = this._processProps(nextParentElement.props);

      // An update here will schedule an update but immediately set
      // _pendingStateQueue which will ensure that any state updates gets
      // immediately reconciled instead of waiting for the next batch.

      if (inst.componentWillReceiveProps) {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);

    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
    }

    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var inst = this._instance;

    var prevProps = inst.props;
    var prevState = inst.state;
    var prevContext = inst.context;

    if (inst.componentWillUpdate) {
      inst.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (inst.componentDidUpdate) {
      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();
    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      // These two IDs are actually the same! But nothing should rely on that.
      var thisID = this._rootNodeID;
      var prevComponentID = prevComponentInstance._rootNodeID;
      ReactReconciler.unmountComponent(prevComponentInstance);

      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement, this._currentElement.type);
      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
    }
  },

  /**
   * @protected
   */
  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedComponent = inst.render();
    if ('production' !== process.env.NODE_ENV) {
      // We allow auto-mocks to proceed as if they're returning null.
      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedComponent = null;
      }
    }

    return renderedComponent;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedComponent;
    var previousContext = ReactContext.current;
    ReactContext.current = this._processChildContext(this._currentElement._context);
    ReactCurrentOwner.current = this;
    try {
      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactContext.current = previousContext;
      ReactCurrentOwner.current = null;
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    (renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent))) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
    return renderedComponent;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = component.getPublicInstance();
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by React.render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    return this._instance;
  },

  // Stub
  _instantiateReactComponent: null

};

ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent',
  _renderValidatedComponent: '_renderValidatedComponent'
});

var ReactCompositeComponent = {

  Mixin: ReactCompositeComponentMixin

};

module.exports = ReactCompositeComponent;
}).call(this,require('_process'))

},{"./Object.assign":36,"./ReactComponentEnvironment":48,"./ReactContext":51,"./ReactCurrentOwner":52,"./ReactElement":72,"./ReactElementValidator":73,"./ReactInstanceMap":82,"./ReactLifeCycle":84,"./ReactNativeComponent":90,"./ReactPerf":92,"./ReactPropTypeLocationNames":94,"./ReactPropTypeLocations":95,"./ReactReconciler":98,"./ReactUpdates":109,"./emptyObject":139,"./invariant":158,"./shouldUpdateReactComponent":177,"./warning":182,"_process":2}],51:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactContext
 */

'use strict';

var emptyObject = require("./emptyObject");

/**
 * Keeps track of the current context.
 *
 * The context is automatically passed down the component ownership hierarchy
 * and is accessible via `this.context` on ReactCompositeComponents.
 */
var ReactContext = {

  /**
   * @internal
   * @type {object}
   */
  current: emptyObject

};

module.exports = ReactContext;
},{"./emptyObject":139}],52:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],53:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 * @typechecks static-only
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");

var mapObject = require("./mapObject");

/**
 * Create a factory that creates HTML tag elements.
 *
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMFactory(tag) {
  if ('production' !== process.env.NODE_ENV) {
    return ReactElementValidator.createFactory(tag);
  }
  return ReactElement.createFactory(tag);
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOM = mapObject({
  a: 'a',
  abbr: 'abbr',
  address: 'address',
  area: 'area',
  article: 'article',
  aside: 'aside',
  audio: 'audio',
  b: 'b',
  base: 'base',
  bdi: 'bdi',
  bdo: 'bdo',
  big: 'big',
  blockquote: 'blockquote',
  body: 'body',
  br: 'br',
  button: 'button',
  canvas: 'canvas',
  caption: 'caption',
  cite: 'cite',
  code: 'code',
  col: 'col',
  colgroup: 'colgroup',
  data: 'data',
  datalist: 'datalist',
  dd: 'dd',
  del: 'del',
  details: 'details',
  dfn: 'dfn',
  dialog: 'dialog',
  div: 'div',
  dl: 'dl',
  dt: 'dt',
  em: 'em',
  embed: 'embed',
  fieldset: 'fieldset',
  figcaption: 'figcaption',
  figure: 'figure',
  footer: 'footer',
  form: 'form',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  head: 'head',
  header: 'header',
  hgroup: 'hgroup',
  hr: 'hr',
  html: 'html',
  i: 'i',
  iframe: 'iframe',
  img: 'img',
  input: 'input',
  ins: 'ins',
  kbd: 'kbd',
  keygen: 'keygen',
  label: 'label',
  legend: 'legend',
  li: 'li',
  link: 'link',
  main: 'main',
  map: 'map',
  mark: 'mark',
  menu: 'menu',
  menuitem: 'menuitem',
  meta: 'meta',
  meter: 'meter',
  nav: 'nav',
  noscript: 'noscript',
  object: 'object',
  ol: 'ol',
  optgroup: 'optgroup',
  option: 'option',
  output: 'output',
  p: 'p',
  param: 'param',
  picture: 'picture',
  pre: 'pre',
  progress: 'progress',
  q: 'q',
  rp: 'rp',
  rt: 'rt',
  ruby: 'ruby',
  s: 's',
  samp: 'samp',
  script: 'script',
  section: 'section',
  select: 'select',
  small: 'small',
  source: 'source',
  span: 'span',
  strong: 'strong',
  style: 'style',
  sub: 'sub',
  summary: 'summary',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  textarea: 'textarea',
  tfoot: 'tfoot',
  th: 'th',
  thead: 'thead',
  time: 'time',
  title: 'title',
  tr: 'tr',
  track: 'track',
  u: 'u',
  ul: 'ul',
  'var': 'var',
  video: 'video',
  wbr: 'wbr',

  // SVG
  circle: 'circle',
  clipPath: 'clipPath',
  defs: 'defs',
  ellipse: 'ellipse',
  g: 'g',
  line: 'line',
  linearGradient: 'linearGradient',
  mask: 'mask',
  path: 'path',
  pattern: 'pattern',
  polygon: 'polygon',
  polyline: 'polyline',
  radialGradient: 'radialGradient',
  rect: 'rect',
  stop: 'stop',
  svg: 'svg',
  text: 'text',
  tspan: 'tspan'

}, createDOMFactory);

module.exports = ReactDOM;
}).call(this,require('_process'))

},{"./ReactElement":72,"./ReactElementValidator":73,"./mapObject":166,"_process":2}],54:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMButton
 */

'use strict';

var AutoFocusMixin = require("./AutoFocusMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var keyMirror = require("./keyMirror");

var button = ReactElement.createFactory('button');

var mouseListenerNames = keyMirror({
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,
  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
});

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = ReactClass.createClass({
  displayName: 'ReactDOMButton',
  tagName: 'BUTTON',

  mixins: [AutoFocusMixin, ReactBrowserComponentMixin],

  render: function () {
    var props = {};

    // Copy the props; except the mouse listeners if we're disabled
    for (var key in this.props) {
      if (this.props.hasOwnProperty(key) && (!this.props.disabled || !mouseListenerNames[key])) {
        props[key] = this.props[key];
      }
    }

    return button(props, this.props.children);
  }

});

module.exports = ReactDOMButton;
},{"./AutoFocusMixin":10,"./ReactBrowserComponentMixin":39,"./ReactClass":45,"./ReactElement":72,"./keyMirror":164}],55:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMClient
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactDOMTextComponent = require("./ReactDOMTextComponent");
var ReactDefaultInjection = require("./ReactDefaultInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");
var ReactReconciler = require("./ReactReconciler");

var findDOMNode = require("./findDOMNode");
var warning = require("./warning");

ReactDefaultInjection.inject();

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  constructAndRenderComponent: ReactMount.constructAndRenderComponent,
  constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
  findDOMNode: findDOMNode,
  render: render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    CurrentOwner: ReactCurrentOwner,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    Reconciler: ReactReconciler,
    TextComponent: ReactDOMTextComponent
  });
}

if ('production' !== process.env.NODE_ENV) {
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // If we're in Chrome, look for the devtools marker and provide a download
    // link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    // If we're in IE8, check to see if we are in combatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    'production' !== process.env.NODE_ENV ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

    // shams
    Object.create, Object.freeze];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
        break;
      }
    }
  }
}

module.exports = React;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":30,"./ReactCurrentOwner":52,"./ReactDOMTextComponent":66,"./ReactDefaultInjection":69,"./ReactInstanceHandles":81,"./ReactMount":87,"./ReactPerf":92,"./ReactReconciler":98,"./findDOMNode":141,"./warning":182,"_process":2}],56:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

/* global hasOwnProperty:true */

'use strict';

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMProperty = require("./DOMProperty");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
var ReactMount = require("./ReactMount");
var ReactMultiChild = require("./ReactMultiChild");
var ReactPerf = require("./ReactPerf");

var assign = require("./Object.assign");
var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
var invariant = require("./invariant");
var isEventSupported = require("./isEventSupported");
var keyOf = require("./keyOf");
var shallowEqual = require("./shallowEqual");
var validateDOMNesting = require("./validateDOMNesting");
var warning = require("./warning");

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = keyOf({ style: null });

var ELEMENT_NODE_TYPE = 1;

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  'production' !== process.env.NODE_ENV ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', JSON.stringify(style1), JSON.stringify(style2)) : undefined;
}

/**
 * Optionally injectable operations for mutating the DOM
 */
var BackendIDOperations = null;

/**
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if ('production' !== process.env.NODE_ENV) {
    if (voidElementTags[component._tag]) {
      'production' !== process.env.NODE_ENV ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.', component._tag) : undefined;
    }
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
    !(typeof props.dangerouslySetInnerHTML === 'object' && '__html' in props.dangerouslySetInnerHTML) ? 'production' !== process.env.NODE_ENV ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
  }
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
    'production' !== process.env.NODE_ENV ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
  }
  !(props.style == null || typeof props.style === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.') : invariant(false) : undefined;
}

function enqueuePutListener(id, registrationName, listener, transaction) {
  if ('production' !== process.env.NODE_ENV) {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    'production' !== process.env.NODE_ENV ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
  }
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
    listenTo(registrationName, doc);
  }
  transaction.getReactMountReady().enqueue(putListener, {
    id: id,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special cased tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
  // NOTE: menuitem's close tag should be omitted, but that causes problems.
};

var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = ({}).hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
    validatedTagCache[tag] = true;
  }
}

function processChildContext(context, inst) {
  if ('production' !== process.env.NODE_ENV) {
    // Pass down our tag name to child components for validation purposes
    context = assign({}, context);
    var info = context[validateDOMNesting.ancestorInfoContextKey];
    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
  }
  return context;
}

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag) {
  validateDangerousTag(tag);
  this._tag = tag;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._rootNodeID = null;
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  construct: function (element) {
    this._currentElement = element;
  },

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (rootID, transaction, context) {
    this._rootNodeID = rootID;

    assertValidProps(this, this._currentElement.props);
    if ('production' !== process.env.NODE_ENV) {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction);
    var tagContent = this._createContentMarkup(transaction, context);
    if (!tagContent && omittedCloseTags[this._tag]) {
      return tagOpen + '/>';
    }
    return tagOpen + '>' + tagContent + '</' + this._tag + '>';
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction) {
    var props = this._currentElement.props;
    var ret = '<' + this._tag;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if ('production' !== process.env.NODE_ENV) {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, context) {
    var ret = '';
    var props = this._currentElement.props;

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, processChildContext(context, this));
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    assertValidProps(this, this._currentElement.props);
    this._updateDOMProperties(prevElement.props, transaction);
    this._updateDOMChildren(prevElement.props, transaction, processChildContext(context, this));
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMProperties: function (lastProps, transaction) {
    var nextProps = this._currentElement.props;
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if ('production' !== process.env.NODE_ENV) {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp);
      }
    }
    if (styleUpdates) {
      BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMChildren: function (lastProps, transaction, context) {
    var nextProps = this._currentElement.props;

    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml);
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction, context);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function () {
    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    this._rootNodeID = null;
  }

};

ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent'
});

assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

ReactDOMComponent.injection = {
  injectIDOperations: function (IDOperations) {
    ReactDOMComponent.BackendIDOperations = BackendIDOperations = IDOperations;
  }
};

module.exports = ReactDOMComponent;
}).call(this,require('_process'))

},{"./CSSPropertyOperations":14,"./DOMProperty":19,"./DOMPropertyOperations":20,"./Object.assign":36,"./ReactBrowserEventEmitter":40,"./ReactComponentBrowserEnvironment":47,"./ReactMount":87,"./ReactMultiChild":88,"./ReactPerf":92,"./escapeTextContentForBrowser":140,"./invariant":158,"./isEventSupported":159,"./keyOf":165,"./shallowEqual":176,"./validateDOMNesting":181,"./warning":182,"_process":2}],57:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMForm
 */

'use strict';

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var form = ReactElement.createFactory('form');

/**
 * Since onSubmit doesn't bubble OR capture on the top level in IE8, we need
 * to capture it on the <form> element itself. There are lots of hacks we could
 * do to accomplish this, but the most reliable is to make <form> a
 * composite component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMForm = ReactClass.createClass({
  displayName: 'ReactDOMForm',
  tagName: 'FORM',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function () {
    // TODO: Instead of using `ReactDOM` directly, we should use JSX. However,
    // `jshint` fails to parse JSX so in order for linting to work in the open
    // source repo, we need to just use `ReactDOM.form`.
    return form(this.props);
  },

  componentDidMount: function () {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
  }
});

module.exports = ReactDOMForm;
},{"./EventConstants":24,"./LocalEventTrapMixin":35,"./ReactBrowserComponentMixin":39,"./ReactClass":45,"./ReactElement":72}],58:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

'use strict';

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMChildrenOperations = require("./DOMChildrenOperations");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");

/**
 * Errors for properties that should not be updated with `updatePropertyById()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes. This is made injectable via
 * `ReactDOMComponent.BackendIDOperations`.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: function (id, name, value) {
    var node = ReactMount.getNode(id);
    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

    // If we're updating to null or undefined, we should remove the property
    // from the DOM node instead of inadvertantly setting to a string. This
    // brings us in line with the same behavior we have on initial render.
    if (value != null) {
      DOMPropertyOperations.setValueForProperty(node, name, value);
    } else {
      DOMPropertyOperations.deleteValueForProperty(node, name);
    }
  },

  /**
   * Updates a DOM node to remove a property. This should only be used to remove
   * DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A property name to remove, see `DOMProperty`.
   * @internal
   */
  deletePropertyByID: function (id, name, value) {
    var node = ReactMount.getNode(id);
    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
    DOMPropertyOperations.deleteValueForProperty(node, name, value);
  },

  /**
   * Updates a DOM node with new style values. If a value is specified as '',
   * the corresponding style property will be unset.
   *
   * @param {string} id ID of the node to update.
   * @param {object} styles Mapping from styles to values.
   * @internal
   */
  updateStylesByID: function (id, styles) {
    var node = ReactMount.getNode(id);
    CSSPropertyOperations.setValueForStyles(node, styles);
  },

  /**
   * Updates a DOM node's innerHTML.
   *
   * @param {string} id ID of the node to update.
   * @param {string} html An HTML string.
   * @internal
   */
  updateInnerHTMLByID: function (id, html) {
    var node = ReactMount.getNode(id);
    setInnerHTML(node, html);
  },

  /**
   * Updates a DOM node's text content set by `props.content`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} content Text content.
   * @internal
   */
  updateTextContentByID: function (id, content) {
    var node = ReactMount.getNode(id);
    DOMChildrenOperations.updateTextContent(node, content);
  },

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
    var node = ReactMount.getNode(id);
    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
  },

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (updates, markup) {
    for (var i = 0; i < updates.length; i++) {
      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
    }
    DOMChildrenOperations.processUpdates(updates, markup);
  }
};

ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
  updatePropertyByID: 'updatePropertyByID',
  deletePropertyByID: 'deletePropertyByID',
  updateStylesByID: 'updateStylesByID',
  updateInnerHTMLByID: 'updateInnerHTMLByID',
  updateTextContentByID: 'updateTextContentByID',
  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
});

module.exports = ReactDOMIDOperations;
}).call(this,require('_process'))

},{"./CSSPropertyOperations":14,"./DOMChildrenOperations":18,"./DOMPropertyOperations":20,"./ReactMount":87,"./ReactPerf":92,"./invariant":158,"./setInnerHTML":173,"_process":2}],59:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIframe
 */

'use strict';

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var iframe = ReactElement.createFactory('iframe');

/**
 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
 * capture it on the <iframe> element itself. There are lots of hacks we could
 * do to accomplish this, but the most reliable is to make <iframe> a composite
 * component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMIframe = ReactClass.createClass({
  displayName: 'ReactDOMIframe',
  tagName: 'IFRAME',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function () {
    return iframe(this.props);
  },

  componentDidMount: function () {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
  }
});

module.exports = ReactDOMIframe;
},{"./EventConstants":24,"./LocalEventTrapMixin":35,"./ReactBrowserComponentMixin":39,"./ReactClass":45,"./ReactElement":72}],60:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMImg
 */

'use strict';

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var img = ReactElement.createFactory('img');

/**
 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
 * capture it on the <img> element itself. There are lots of hacks we could do
 * to accomplish this, but the most reliable is to make <img> a composite
 * component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMImg = ReactClass.createClass({
  displayName: 'ReactDOMImg',
  tagName: 'IMG',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function () {
    return img(this.props);
  },

  componentDidMount: function () {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
  }
});

module.exports = ReactDOMImg;
},{"./EventConstants":24,"./LocalEventTrapMixin":35,"./ReactBrowserComponentMixin":39,"./ReactClass":45,"./ReactElement":72}],61:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInput
 */

'use strict';

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var findDOMNode = require("./findDOMNode");
var invariant = require("./invariant");

var input = ReactElement.createFactory('input');

var instancesByReactID = {};

function forceUpdateIfMounted() {
  /*jshint validthis:true */
  if (this.isMounted()) {
    this.forceUpdate();
  }
}

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = ReactClass.createClass({
  displayName: 'ReactDOMInput',
  tagName: 'INPUT',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function () {
    var defaultValue = this.props.defaultValue;
    return {
      initialChecked: this.props.defaultChecked || false,
      initialValue: defaultValue != null ? defaultValue : null
    };
  },

  render: function () {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    props.defaultChecked = null;
    props.defaultValue = null;

    var value = LinkedValueUtils.getValue(this.props);
    props.value = value != null ? value : this.state.initialValue;

    var checked = LinkedValueUtils.getChecked(this.props);
    props.checked = checked != null ? checked : this.state.initialChecked;

    props.onChange = this._handleChange;

    return input(props, this.props.children);
  },

  componentDidMount: function () {
    var id = ReactMount.getID(findDOMNode(this));
    instancesByReactID[id] = this;
  },

  componentWillUnmount: function () {
    var rootNode = findDOMNode(this);
    var id = ReactMount.getID(rootNode);
    delete instancesByReactID[id];
  },

  componentDidUpdate: function (prevProps, prevState, prevContext) {
    var rootNode = findDOMNode(this);
    if (this.props.checked != null) {
      DOMPropertyOperations.setValueForProperty(rootNode, 'checked', this.props.checked || false);
    }

    var value = LinkedValueUtils.getValue(this.props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function (event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this.props);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }
    // Here we use asap to wait until all updates have propagated, which
    // is important when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    ReactUpdates.asap(forceUpdateIfMounted, this);

    var name = this.props.name;
    if (this.props.type === 'radio' && name != null) {
      var rootNode = findDOMNode(this);
      var queryRoot = rootNode;

      while (queryRoot.parentNode) {
        queryRoot = queryRoot.parentNode;
      }

      // If `rootNode.form` was non-null, then we could try `form.elements`,
      // but that sometimes behaves strangely in IE8. We could also try using
      // `form.getElementsByName`, but that will only return direct children
      // and won't include inputs that use the HTML5 `form=` attribute. Since
      // the input might not even be in a form, let's just use the global
      // `querySelectorAll` to ensure we don't miss anything.
      var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

      for (var i = 0; i < group.length; i++) {
        var otherNode = group[i];
        if (otherNode === rootNode || otherNode.form !== rootNode.form) {
          continue;
        }
        var otherID = ReactMount.getID(otherNode);
        !otherID ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
        var otherInstance = instancesByReactID[otherID];
        !otherInstance ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
        // If this is a controlled radio button group, forcing the input that
        // was previously checked to update will cause it to be come re-checked
        // as appropriate.
        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
      }
    }

    return returnValue;
  }

});

module.exports = ReactDOMInput;
}).call(this,require('_process'))

},{"./AutoFocusMixin":10,"./DOMPropertyOperations":20,"./LinkedValueUtils":34,"./Object.assign":36,"./ReactBrowserComponentMixin":39,"./ReactClass":45,"./ReactElement":72,"./ReactMount":87,"./ReactUpdates":109,"./findDOMNode":141,"./invariant":158,"_process":2}],62:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMOption
 */

'use strict';

var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactChildren = require("./ReactChildren");
var ReactClass = require("./ReactClass");
var ReactDOMSelect = require("./ReactDOMSelect");
var ReactElement = require("./ReactElement");
var ReactPropTypes = require("./ReactPropTypes");

var assign = require("./Object.assign");
var warning = require("./warning");

var option = ReactElement.createFactory('option');

var valueContextKey = ReactDOMSelect.valueContextKey;

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = ReactClass.createClass({
  displayName: 'ReactDOMOption',
  tagName: 'OPTION',

  mixins: [ReactBrowserComponentMixin],

  getInitialState: function () {
    return { selected: null };
  },

  contextTypes: (function () {
    var obj = {};
    obj[valueContextKey] = ReactPropTypes.any;
    return obj;
  })(),

  componentWillMount: function () {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(this.props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
    }

    // Look up whether this option is 'selected' via parent-based context
    var context = this.context;
    var selectValue = context[valueContextKey];

    // If context key is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>) skip props
    if (selectValue != null) {
      var selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === '' + this.props.value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === '' + this.props.value;
      }
      this.setState({ selected: selected });
    }
  },

  render: function () {
    var props = this.props;

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (this.state.selected != null) {
      props = assign({}, props, { selected: this.state.selected });
    }

    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    ReactChildren.forEach(this.props.children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else {
        'production' !== process.env.NODE_ENV ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
      }
    });

    return option(props, content);
  }

});

module.exports = ReactDOMOption;
}).call(this,require('_process'))

},{"./Object.assign":36,"./ReactBrowserComponentMixin":39,"./ReactChildren":44,"./ReactClass":45,"./ReactDOMSelect":63,"./ReactElement":72,"./ReactPropTypes":96,"./warning":182,"_process":2}],63:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelect
 */

'use strict';

var AutoFocusMixin = require("./AutoFocusMixin");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");
var ReactUpdates = require("./ReactUpdates");
var ReactPropTypes = require("./ReactPropTypes");

var assign = require("./Object.assign");
var findDOMNode = require("./findDOMNode");

var select = ReactElement.createFactory('select');

var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

function updateOptionsIfPendingUpdateAndMounted() {
  /*jshint validthis:true */
  if (this._pendingUpdate) {
    this._pendingUpdate = false;
    var value = LinkedValueUtils.getValue(this.props);
    if (value != null && this.isMounted()) {
      updateOptions(this, value);
    }
  }
}

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function selectValueType(props, propName, componentName) {
  if (props[propName] == null) {
    return null;
  }
  if (props.multiple) {
    if (!Array.isArray(props[propName])) {
      return new Error('The `' + propName + '` prop supplied to <select> must be an array if ' + '`multiple` is true.');
    }
  } else {
    if (Array.isArray(props[propName])) {
      return new Error('The `' + propName + '` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.');
    }
  }
}

/**
 * @param {ReactComponent} component Instance of ReactDOMSelect
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(component, propValue) {
  var selectedValue, i;
  var options = findDOMNode(component).options;

  if (component.props.multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = ReactClass.createClass({
  displayName: 'ReactDOMSelect',
  tagName: 'SELECT',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  statics: {
    valueContextKey: valueContextKey
  },

  propTypes: {
    defaultValue: selectValueType,
    value: selectValueType
  },

  getInitialState: function () {
    // Pass down initial value so initial generated markup has correct
    // `selected` attributes
    var value = LinkedValueUtils.getValue(this.props);
    if (value != null) {
      return { initialValue: value };
    } else {
      return { initialValue: this.props.defaultValue };
    }
  },

  childContextTypes: (function () {
    var obj = {};
    obj[valueContextKey] = ReactPropTypes.any;
    return obj;
  })(),

  getChildContext: function () {
    var obj = {};
    obj[valueContextKey] = this.state.initialValue;
    return obj;
  },

  render: function () {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    props.onChange = this._handleChange;
    props.value = null;

    return select(props, this.props.children);
  },

  componentWillMount: function () {
    this._pendingUpdate = false;
  },

  componentWillReceiveProps: function (nextProps) {
    // After the initial mount, we control selected-ness manually so don't pass
    // the context value down
    this.setState({ initialValue: null });
  },

  componentDidUpdate: function (prevProps) {
    var value = LinkedValueUtils.getValue(this.props);
    if (value != null) {
      this._pendingUpdate = false;
      updateOptions(this, value);
    } else if (!prevProps.multiple !== !this.props.multiple) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (this.props.defaultValue != null) {
        updateOptions(this, this.props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(this, this.props.multiple ? [] : '');
      }
    }
  },

  _handleChange: function (event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this.props);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }

    this._pendingUpdate = true;
    ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
    return returnValue;
  }

});

module.exports = ReactDOMSelect;
},{"./AutoFocusMixin":10,"./LinkedValueUtils":34,"./Object.assign":36,"./ReactBrowserComponentMixin":39,"./ReactClass":45,"./ReactElement":72,"./ReactPropTypes":96,"./ReactUpdates":109,"./findDOMNode":141}],64:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelection
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var getNodeForCharacterOffset = require("./getNodeForCharacterOffset");
var getTextContentAccessor = require("./getTextContentAccessor");

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./ExecutionEnvironment":30,"./getNodeForCharacterOffset":152,"./getTextContentAccessor":153}],65:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMServer
 */

'use strict';

var ReactDefaultInjection = require("./ReactDefaultInjection");
var ReactServerRendering = require("./ReactServerRendering");

ReactDefaultInjection.inject();

var ReactDOMServer = {
  renderToString: ReactServerRendering.renderToString,
  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup
};

module.exports = ReactDOMServer;
},{"./ReactDefaultInjection":69,"./ReactServerRendering":101}],66:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextComponent
 * @typechecks static-only
 */

'use strict';

var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
var ReactDOMComponent = require("./ReactDOMComponent");

var assign = require("./Object.assign");
var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
var validateDOMNesting = require("./validateDOMNesting");

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (props) {};

assign(ReactDOMTextComponent.prototype, {

  /**
   * @param {ReactText} text
   * @internal
   */
  construct: function (text) {
    // TODO: This is really a ReactText (ReactNode), not a ReactElement
    this._currentElement = text;
    this._stringText = '' + text;

    // Properties
    this._rootNodeID = null;
    this._mountIndex = 0;
  },

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    if ('production' !== process.env.NODE_ENV) {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    this._rootNodeID = rootID;
    var escapedText = escapeTextContentForBrowser(this._stringText);

    if (transaction.renderToStaticMarkup) {
      // Normally we'd wrap this in a `span` for the reasons stated above, but
      // since this is a situation where React won't take over (static pages),
      // we can simply return the text as it is.
      return escapedText;
    }

    return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        ReactDOMComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextStringText);
      }
    }
  },

  unmountComponent: function () {
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
  }

});

module.exports = ReactDOMTextComponent;

// This constructor and its argument is currently used by mocks.
}).call(this,require('_process'))

},{"./DOMPropertyOperations":20,"./Object.assign":36,"./ReactComponentBrowserEnvironment":47,"./ReactDOMComponent":56,"./escapeTextContentForBrowser":140,"./validateDOMNesting":181,"_process":2}],67:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextarea
 */

'use strict';

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var findDOMNode = require("./findDOMNode");
var invariant = require("./invariant");

var warning = require("./warning");

var textarea = ReactElement.createFactory('textarea');

function forceUpdateIfMounted() {
  /*jshint validthis:true */
  if (this.isMounted()) {
    this.forceUpdate();
  }
}

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = ReactClass.createClass({
  displayName: 'ReactDOMTextarea',
  tagName: 'TEXTAREA',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function () {
    var defaultValue = this.props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = this.props.children;
    if (children != null) {
      if ('production' !== process.env.NODE_ENV) {
        'production' !== process.env.NODE_ENV ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
      }
      !(defaultValue == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? 'production' !== process.env.NODE_ENV ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(this.props);
    return {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue)
    };
  },

  render: function () {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    !(props.dangerouslySetInnerHTML == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

    props.defaultValue = null;
    props.value = null;
    props.onChange = this._handleChange;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    return textarea(props, this.state.initialValue);
  },

  componentDidUpdate: function (prevProps, prevState, prevContext) {
    var value = LinkedValueUtils.getValue(this.props);
    if (value != null) {
      var rootNode = findDOMNode(this);
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function (event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this.props);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }
    ReactUpdates.asap(forceUpdateIfMounted, this);
    return returnValue;
  }

});

module.exports = ReactDOMTextarea;
}).call(this,require('_process'))

},{"./AutoFocusMixin":10,"./DOMPropertyOperations":20,"./LinkedValueUtils":34,"./Object.assign":36,"./ReactBrowserComponentMixin":39,"./ReactClass":45,"./ReactElement":72,"./ReactUpdates":109,"./findDOMNode":141,"./invariant":158,"./warning":182,"_process":2}],68:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

'use strict';

var ReactUpdates = require("./ReactUpdates");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./Object.assign":36,"./ReactUpdates":109,"./Transaction":126,"./emptyFunction":138}],69:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultInjection
 */

'use strict';

var BeforeInputEventPlugin = require("./BeforeInputEventPlugin");
var ChangeEventPlugin = require("./ChangeEventPlugin");
var ClientReactRootIndex = require("./ClientReactRootIndex");
var DefaultEventPluginOrder = require("./DefaultEventPluginOrder");
var EnterLeaveEventPlugin = require("./EnterLeaveEventPlugin");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var HTMLDOMPropertyConfig = require("./HTMLDOMPropertyConfig");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactClass = require("./ReactClass");
var ReactComponentBrowserEnvironment = require("./ReactComponentBrowserEnvironment");
var ReactDefaultBatchingStrategy = require("./ReactDefaultBatchingStrategy");
var ReactDOMComponent = require("./ReactDOMComponent");
var ReactDOMButton = require("./ReactDOMButton");
var ReactDOMForm = require("./ReactDOMForm");
var ReactDOMImg = require("./ReactDOMImg");
var ReactDOMIDOperations = require("./ReactDOMIDOperations");
var ReactDOMIframe = require("./ReactDOMIframe");
var ReactDOMInput = require("./ReactDOMInput");
var ReactDOMOption = require("./ReactDOMOption");
var ReactDOMSelect = require("./ReactDOMSelect");
var ReactDOMTextarea = require("./ReactDOMTextarea");
var ReactDOMTextComponent = require("./ReactDOMTextComponent");
var ReactElement = require("./ReactElement");
var ReactEventListener = require("./ReactEventListener");
var ReactInjection = require("./ReactInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactMount = require("./ReactMount");
var ReactReconcileTransaction = require("./ReactReconcileTransaction");
var SelectEventPlugin = require("./SelectEventPlugin");
var ServerReactRootIndex = require("./ServerReactRootIndex");
var SimpleEventPlugin = require("./SimpleEventPlugin");
var SVGDOMPropertyConfig = require("./SVGDOMPropertyConfig");

var createFullPageComponent = require("./createFullPageComponent");

function autoGenerateWrapperClass(type) {
  return ReactClass.createClass({
    tagName: type.toUpperCase(),
    render: function () {
      // Copy owner down for debugging info
      var internalInstance = ReactInstanceMap.get(this);
      return new ReactElement(type, null, // key
      null, // ref
      internalInstance._currentElement._owner, // owner
      null, // context
      this.props);
    }
  });
}

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.NativeComponent.injectAutoWrapper(autoGenerateWrapperClass);

  // This needs to happen before createFullPageComponent() otherwise the mixin
  // won't be included.
  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.NativeComponent.injectComponentClasses({
    'button': ReactDOMButton,
    'form': ReactDOMForm,
    'iframe': ReactDOMIframe,
    'img': ReactDOMImg,
    'input': ReactDOMInput,
    'option': ReactDOMOption,
    'select': ReactDOMSelect,
    'textarea': ReactDOMTextarea,

    'html': createFullPageComponent('html'),
    'head': createFullPageComponent('head'),
    'body': createFullPageComponent('body')
  });

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
  ReactInjection.DOMComponent.injectIDOperations(ReactDOMIDOperations);

  if ('production' !== process.env.NODE_ENV) {
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
      var ReactDefaultPerf = require("./ReactDefaultPerf");
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};
}).call(this,require('_process'))

},{"./BeforeInputEventPlugin":11,"./ChangeEventPlugin":16,"./ClientReactRootIndex":17,"./DefaultEventPluginOrder":22,"./EnterLeaveEventPlugin":23,"./ExecutionEnvironment":30,"./HTMLDOMPropertyConfig":32,"./ReactBrowserComponentMixin":39,"./ReactClass":45,"./ReactComponentBrowserEnvironment":47,"./ReactDOMButton":54,"./ReactDOMComponent":56,"./ReactDOMForm":57,"./ReactDOMIDOperations":58,"./ReactDOMIframe":59,"./ReactDOMImg":60,"./ReactDOMInput":61,"./ReactDOMOption":62,"./ReactDOMSelect":63,"./ReactDOMTextComponent":66,"./ReactDOMTextarea":67,"./ReactDefaultBatchingStrategy":68,"./ReactDefaultPerf":70,"./ReactElement":72,"./ReactEventListener":77,"./ReactInjection":79,"./ReactInstanceHandles":81,"./ReactInstanceMap":82,"./ReactMount":87,"./ReactReconcileTransaction":97,"./SVGDOMPropertyConfig":111,"./SelectEventPlugin":112,"./ServerReactRootIndex":113,"./SimpleEventPlugin":114,"./createFullPageComponent":135,"_process":2}],70:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require("./DOMProperty");
var ReactDefaultPerfAnalysis = require("./ReactDefaultPerfAnalysis");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var performanceNow = require("./performanceNow");

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function () {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function () {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function () {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  getMeasurementsSummaryMap: function (measurements) {
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
    return summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    });
  },

  printWasted: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  printDOM: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function (item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result['type'] = item.type;
      result['args'] = JSON.stringify(item.args);
      return result;
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  _recordWrite: function (id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function (moduleName, fnName, func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
        return rv;
      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactDOMIDOperations') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === '_mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function (update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
          });
        } else {
          // basic format
          ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
      fnName === '_renderValidatedComponent')) {

        if (typeof this._currentElement.type === 'string') {
          return func.apply(this, args);
        }

        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.getName(),
          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;
},{"./DOMProperty":19,"./ReactDefaultPerfAnalysis":71,"./ReactMount":87,"./ReactPerf":92,"./performanceNow":170}],71:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

'use strict';

var assign = require("./Object.assign");

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  '_mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  TEXT_CONTENT: 'set textContent',
  'updatePropertyByID': 'update attribute',
  'deletePropertyByID': 'delete attribute',
  'updateStylesByID': 'update styles',
  'updateInnerHTMLByID': 'set innerHTML',
  'dangerouslyReplaceNodeWithMarkupByID': 'replace'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var id;

    for (id in measurement.writes) {
      measurement.writes[id].forEach(function (write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    }
  }
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function (a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function (a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggered
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;
},{"./Object.assign":36}],72:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

'use strict';

var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");

var assign = require("./Object.assign");
var warning = require("./warning");

var RESERVED_PROPS = {
  key: true,
  ref: true
};

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} object
 * @param {string} key
 */
function defineWarningProperty(object, key) {
  Object.defineProperty(object, key, {

    configurable: false,
    enumerable: true,

    get: function () {
      if (!this._store) {
        return null;
      }
      return this._store[key];
    },

    set: function (value) {
      'production' !== process.env.NODE_ENV ? warning(false, 'Don\'t set the %s property of the React element. Instead, ' + 'specify the correct value when initially creating the element.', key) : undefined;
      this._store[key] = value;
    }

  });
}

/**
 * This is updated to true if the membrane is successfully created.
 */
var useMutationMembrane = false;

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} element
 */
function defineMutationMembrane(prototype) {
  try {
    var pseudoFrozenProperties = {
      props: true
    };
    for (var key in pseudoFrozenProperties) {
      defineWarningProperty(prototype, key);
    }
    useMutationMembrane = true;
  } catch (x) {}
}

/**
 * Base constructor for all React elements. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @param {string|object} ref
 * @param {*} key
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, owner, context, props) {
  // Built-in properties that belong on the element
  this.type = type;
  this.key = key;
  this.ref = ref;

  // Record the component responsible for creating this element.
  this._owner = owner;

  if ('production' !== process.env.NODE_ENV) {
    // The validation flag and props are currently mutative. We put them on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    this._store = { props: props, originalProps: assign({}, props) };

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    try {
      Object.defineProperty(this._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true
      });
    } catch (x) {}
    this._store.validated = false;

    // We're not allowed to set props directly on the object so we early
    // return and rely on the prototype membrane to forward to the backing
    // store.
    if (useMutationMembrane) {
      Object.freeze(this);
      return;
    }
  }

  this.props = props;
};

// We intentionally don't expose the function on the constructor property.
// ReactElement should be indistinguishable from a plain object.
ReactElement.prototype = {
  _isReactElement: true
};

if ('production' !== process.env.NODE_ENV) {
  defineMutationMembrane(ReactElement.prototype);
}

ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;

  if (config != null) {
    ref = config.ref === undefined ? null : config.ref;
    key = config.key === undefined ? null : '' + config.key;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (typeof props[propName] === 'undefined') {
        props[propName] = defaultProps[propName];
      }
    }
  }

  return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props);
};

ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
  var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);

  if ('production' !== process.env.NODE_ENV) {
    // If the key on the original is valid, then the clone is valid
    newElement._store.validated = oldElement._store.validated;
  }
  return newElement;
};

ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (config.ref !== undefined) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (config.key !== undefined) {
      key = '' + config.key;
    }
    // Remaining properties override existing props
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return new ReactElement(element.type, key, ref, owner, element._context, props);
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  // ReactTestUtils is often used outside of beforeEach where as React is
  // within it. This leads to two different instances of React on the same
  // page. To identify a element from a different React instance we use
  // a flag instead of an instanceof check.
  var isElement = !!(object && object._isReactElement);
  // if (isElement && !(object instanceof ReactElement)) {
  // This is an indicator that you're using multiple versions of React at the
  // same time. This will screw with ownership and stuff. Fix it, please.
  // TODO: We could possibly warn here.
  // }
  return isElement;
};

module.exports = ReactElement;

// IE will fail on defineProperty
}).call(this,require('_process'))

},{"./Object.assign":36,"./ReactContext":51,"./ReactCurrentOwner":52,"./warning":182,"_process":2}],73:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactFragment = require("./ReactFragment");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactNativeComponent = require("./ReactNativeComponent");

var getIteratorFn = require("./getIteratorFn");
var invariant = require("./invariant");
var warning = require("./warning");

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

var loggedTypeFailures = {};

var NUMERIC_PROPERTY_REGEX = /^\d+$/;

/**
 * Gets the instance's name for use in warnings.
 *
 * @internal
 * @return {?string} Display name or undefined
 */
function getName(instance) {
  var publicInstance = instance && instance.getPublicInstance();
  if (!publicInstance) {
    return undefined;
  }
  var constructor = publicInstance.constructor;
  if (!constructor) {
    return undefined;
  }
  return constructor.displayName || constructor.name || undefined;
}

/**
 * Gets the current owner's displayName for use in warnings.
 *
 * @internal
 * @return {?string} Display name or undefined
 */
function getCurrentOwnerDisplayName() {
  var current = ReactCurrentOwner.current;
  return current && getName(current) || undefined;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  warnAndMonitorForKeyUse('Each child in an array or iterator should have a unique "key" prop.', element, parentType);
}

/**
 * Warn if the key is being defined as an object property but has an incorrect
 * value.
 *
 * @internal
 * @param {string} name Property name of the key.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validatePropertyKey(name, element, parentType) {
  if (!NUMERIC_PROPERTY_REGEX.test(name)) {
    return;
  }
  warnAndMonitorForKeyUse('Child objects should have non-numeric keys so ordering is preserved.', element, parentType);
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} message The base warning that gets output.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 */
function warnAndMonitorForKeyUse(message, element, parentType) {
  var ownerName = getCurrentOwnerDisplayName();
  var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

  var useName = ownerName || parentName;
  var memoizer = ownerHasKeyUseWarning[message] || (ownerHasKeyUseWarning[message] = {});
  if (memoizer.hasOwnProperty(useName)) {
    return;
  }
  memoizer[useName] = true;

  var parentOrOwnerAddendum = ownerName ? ' Check the render method of ' + ownerName + '.' : parentName ? ' Check the React.render call using <' + parentName + '>.' : '';

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwnerAddendum = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Name of the component that originally created this child.
    var childOwnerName = getName(element._owner);

    childOwnerAddendum = ' It was passed a child from ' + childOwnerName + '.';
  }

  'production' !== process.env.NODE_ENV ? warning(false, message + '%s%s See https://fb.me/react-warning-keys for more information.', parentOrOwnerAddendum, childOwnerAddendum) : undefined;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    node._store.validated = true;
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    } else if (typeof node === 'object') {
      var fragment = ReactFragment.extractIfFragment(node);
      for (var key in fragment) {
        if (fragment.hasOwnProperty(key)) {
          validatePropertyKey(key, fragment[key], parentType);
        }
      }
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof propTypes[propName] === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      'production' !== process.env.NODE_ENV ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum();
        'production' !== process.env.NODE_ENV ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
      }
    }
  }
}

var warnedPropsMutations = {};

/**
 * Warn about mutating props when setting `propName` on `element`.
 *
 * @param {string} propName The string key within props that was set
 * @param {ReactElement} element
 */
function warnForPropsMutation(propName, element) {
  var type = element.type;
  var elementName = typeof type === 'string' ? type : type.displayName;
  var ownerName = element._owner ? element._owner.getPublicInstance().constructor.displayName : null;

  var warningKey = propName + '|' + elementName + '|' + ownerName;
  if (warnedPropsMutations.hasOwnProperty(warningKey)) {
    return;
  }
  warnedPropsMutations[warningKey] = true;

  var elementInfo = '';
  if (elementName) {
    elementInfo = ' <' + elementName + ' />';
  }
  var ownerInfo = '';
  if (ownerName) {
    ownerInfo = ' The element was created by ' + ownerName + '.';
  }

  'production' !== process.env.NODE_ENV ? warning(false, 'Don\'t set .props.%s of the React component%s. Instead, specify the ' + 'correct value when initially creating the element or use ' + 'React.cloneElement to make a new element with updated props.%s', propName, elementInfo, ownerInfo) : undefined;
}

// Inline Object.is polyfill
function is(a, b) {
  if (a !== a) {
    // NaN
    return b !== b;
  }
  if (a === 0 && b === 0) {
    // +-0
    return 1 / a === 1 / b;
  }
  return a === b;
}

/**
 * Given an element, check if its props have been mutated since element
 * creation (or the last call to this function). In particular, check if any
 * new props have been added, which we can't directly catch by defining warning
 * properties on the props object.
 *
 * @param {ReactElement} element
 */
function checkAndWarnForMutatedProps(element) {
  if (!element._store) {
    // Element was created using `new ReactElement` directly or with
    // `ReactElement.createElement`; skip mutation checking
    return;
  }

  var originalProps = element._store.originalProps;
  var props = element.props;

  for (var propName in props) {
    if (props.hasOwnProperty(propName)) {
      if (!originalProps.hasOwnProperty(propName) || !is(originalProps[propName], props[propName])) {
        warnForPropsMutation(propName, element);

        // Copy over the new value so that the two props objects match again
        originalProps[propName] = props[propName];
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  if (!(typeof element.type === 'string' || typeof element.type === 'function')) {
    // This has already warned. Don't throw.
    return;
  }
  // Extract the component class from the element. Converts string types
  // to a composite class which may have propTypes.
  // TODO: Validating a string's propTypes is not decoupled from the
  // rendering target which is problematic.
  var componentClass = ReactNativeComponent.getComponentClassForElement(element);
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    'production' !== process.env.NODE_ENV ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
  }
}

var ReactElementValidator = {

  checkAndWarnForMutatedProps: checkAndWarnForMutatedProps,

  createElement: function (type, props, children) {
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    'production' !== process.env.NODE_ENV ? warning(typeof type === 'string' || typeof type === 'function', 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if ('production' !== process.env.NODE_ENV) {
      try {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            'production' !== process.env.NODE_ENV ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      } catch (x) {}
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;

// IE will fail on defineProperty (es5-shim/sham too)
}).call(this,require('_process'))

},{"./ReactCurrentOwner":52,"./ReactElement":72,"./ReactFragment":78,"./ReactNativeComponent":90,"./ReactPropTypeLocationNames":94,"./ReactPropTypeLocations":95,"./getIteratorFn":150,"./invariant":158,"./warning":182,"_process":2}],74:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponent
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactInstanceMap = require("./ReactInstanceMap");

var invariant = require("./invariant");

var component;
// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)
var nullComponentIDsRegistry = {};

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function (emptyComponent) {
    component = ReactElement.createFactory(emptyComponent);
  }
};

var ReactEmptyComponentType = function () {};
ReactEmptyComponentType.prototype.componentDidMount = function () {
  var internalInstance = ReactInstanceMap.get(this);
  // TODO: Make sure we run these methods in the correct order, we shouldn't
  // need this check. We're going to assume if we're here it means we ran
  // componentWillUnmount already so there is no internal instance (it gets
  // removed as part of the unmounting process).
  if (!internalInstance) {
    return;
  }
  registerNullComponentID(internalInstance._rootNodeID);
};
ReactEmptyComponentType.prototype.componentWillUnmount = function () {
  var internalInstance = ReactInstanceMap.get(this);
  // TODO: Get rid of this check. See TODO in componentDidMount.
  if (!internalInstance) {
    return;
  }
  deregisterNullComponentID(internalInstance._rootNodeID);
};
ReactEmptyComponentType.prototype.render = function () {
  !component ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Trying to return null from a render, but no null placeholder component ' + 'was injected.') : invariant(false) : undefined;
  return component();
};

var emptyElement = ReactElement.createElement(ReactEmptyComponentType);

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIDsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIDsRegistry[id];
}

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return !!nullComponentIDsRegistry[id];
}

var ReactEmptyComponent = {
  emptyElement: emptyElement,
  injection: ReactEmptyComponentInjection,
  isNullComponentID: isNullComponentID
};

module.exports = ReactEmptyComponent;
}).call(this,require('_process'))

},{"./ReactElement":72,"./ReactInstanceMap":82,"./invariant":158,"_process":2}],75:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

"use strict";

var ReactErrorUtils = {
  /**
   * Creates a guarded version of a function. This is supposed to make debugging
   * of event handlers easier. To aid debugging with the browser's debugger,
   * this currently simply returns the original function.
   *
   * @param {function} func Function to be executed
   * @param {string} name The name of the guard
   * @return {function}
   */
  guard: function (func, name) {
    return func;
  }
};

module.exports = ReactErrorUtils;
},{}],76:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventEmitterMixin
 */

'use strict';

var EventPluginHub = require("./EventPluginHub");

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue();
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);

    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":26}],77:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

'use strict';

var EventListener = require("./EventListener");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var PooledClass = require("./PooledClass");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var getEventTarget = require("./getEventTarget");
var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent);
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./EventListener":25,"./ExecutionEnvironment":30,"./Object.assign":36,"./PooledClass":37,"./ReactInstanceHandles":81,"./ReactMount":87,"./ReactUpdates":109,"./getEventTarget":149,"./getUnboundedScrollPosition":154}],78:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule ReactFragment
*/

'use strict';

var ReactElement = require("./ReactElement");

var warning = require("./warning");

/**
 * We used to allow keyed objects to serve as a collection of ReactElements,
 * or nested sets. This allowed us a way to explicitly key a set a fragment of
 * components. This is now being replaced with an opaque data structure.
 * The upgrade path is to call React.addons.createFragment({ key: value }) to
 * create a keyed fragment. The resulting data structure is opaque, for now.
 */

if ('production' !== process.env.NODE_ENV) {
  var fragmentKey = '_reactFragment';
  var didWarnKey = '_reactDidWarn';
  var canWarnForReactFragment = false;

  try {
    // Feature test. Don't even try to issue this warning if we can't use
    // enumerable: false.

    var dummy = function () {
      return 1;
    };

    Object.defineProperty({}, fragmentKey, { enumerable: false, value: true });

    Object.defineProperty({}, 'key', { enumerable: true, get: dummy });

    canWarnForReactFragment = true;
  } catch (x) {}

  var proxyPropertyAccessWithWarning = function (obj, key) {
    Object.defineProperty(obj, key, {
      enumerable: true,
      get: function () {
        'production' !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an opaque type. Accessing any of its ' + 'properties is deprecated. Pass it to one of the React.Children ' + 'helpers.') : undefined;
        this[didWarnKey] = true;
        return this[fragmentKey][key];
      },
      set: function (value) {
        'production' !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an immutable opaque type. Mutating its ' + 'properties is deprecated.') : undefined;
        this[didWarnKey] = true;
        this[fragmentKey][key] = value;
      }
    });
  };

  var issuedWarnings = {};

  var didWarnForFragment = function (fragment) {
    // We use the keys and the type of the value as a heuristic to dedupe the
    // warning to avoid spamming too much.
    var fragmentCacheKey = '';
    for (var key in fragment) {
      fragmentCacheKey += key + ':' + typeof fragment[key] + ',';
    }
    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];
    issuedWarnings[fragmentCacheKey] = true;
    return alreadyWarnedOnce;
  };
}

var ReactFragment = {
  // Wrap a keyed object in an opaque proxy that warns you if you access any
  // of its properties.
  create: function (object) {
    if ('production' !== process.env.NODE_ENV) {
      if (typeof object !== 'object' || !object || Array.isArray(object)) {
        'production' !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment only accepts a single object.', object) : undefined;
        return object;
      }
      if (ReactElement.isValidElement(object)) {
        'production' !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : undefined;
        return object;
      }
      if (canWarnForReactFragment) {
        var proxy = {};
        Object.defineProperty(proxy, fragmentKey, {
          enumerable: false,
          value: object
        });
        Object.defineProperty(proxy, didWarnKey, {
          writable: true,
          enumerable: false,
          value: false
        });
        for (var key in object) {
          proxyPropertyAccessWithWarning(proxy, key);
        }
        Object.preventExtensions(proxy);
        return proxy;
      }
    }
    return object;
  },
  // Extract the original keyed object from the fragment opaque type. Warn if
  // a plain object is passed here.
  extract: function (fragment) {
    if ('production' !== process.env.NODE_ENV) {
      if (canWarnForReactFragment) {
        if (!fragment[fragmentKey]) {
          'production' !== process.env.NODE_ENV ? warning(didWarnForFragment(fragment), 'Any use of a keyed object should be wrapped in ' + 'React.addons.createFragment(object) before being passed as a ' + 'child.') : undefined;
          return fragment;
        }
        return fragment[fragmentKey];
      }
    }
    return fragment;
  },
  // Check if this is a fragment and if so, extract the keyed object. If it
  // is a fragment-like object, warn that it should be wrapped. Ignore if we
  // can't determine what kind of object this is.
  extractIfFragment: function (fragment) {
    if ('production' !== process.env.NODE_ENV) {
      if (canWarnForReactFragment) {
        // If it is the opaque type, return the keyed object.
        if (fragment[fragmentKey]) {
          return fragment[fragmentKey];
        }
        // Otherwise, check each property if it has an element, if it does
        // it is probably meant as a fragment, so we can warn early. Defer,
        // the warning to extract.
        for (var key in fragment) {
          if (fragment.hasOwnProperty(key) && ReactElement.isValidElement(fragment[key])) {
            // This looks like a fragment object, we should provide an
            // early warning.
            return ReactFragment.extract(fragment);
          }
        }
      }
    }
    return fragment;
  }
};

module.exports = ReactFragment;
}).call(this,require('_process'))

},{"./ReactElement":72,"./warning":182,"_process":2}],79:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInjection
 */

'use strict';

var DOMProperty = require("./DOMProperty");
var EventPluginHub = require("./EventPluginHub");
var ReactComponentEnvironment = require("./ReactComponentEnvironment");
var ReactClass = require("./ReactClass");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactNativeComponent = require("./ReactNativeComponent");
var ReactDOMComponent = require("./ReactDOMComponent");
var ReactPerf = require("./ReactPerf");
var ReactRootIndex = require("./ReactRootIndex");
var ReactUpdates = require("./ReactUpdates");

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  Class: ReactClass.injection,
  DOMComponent: ReactDOMComponent.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  NativeComponent: ReactNativeComponent.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":19,"./EventPluginHub":26,"./ReactBrowserEventEmitter":40,"./ReactClass":45,"./ReactComponentEnvironment":48,"./ReactDOMComponent":56,"./ReactEmptyComponent":74,"./ReactNativeComponent":90,"./ReactPerf":92,"./ReactRootIndex":100,"./ReactUpdates":109}],80:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInputSelection
 */

'use strict';

var ReactDOMSelection = require("./ReactDOMSelection");

var containsNode = require("./containsNode");
var focusNode = require("./focusNode");
var getActiveElement = require("./getActiveElement");

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    return elem && (elem.nodeName === 'INPUT' && elem.type === 'text' || elem.nodeName === 'TEXTAREA' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName === 'INPUT') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName === 'INPUT') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":64,"./containsNode":133,"./focusNode":143,"./getActiveElement":145}],81:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

'use strict';

var ReactRootIndex = require("./ReactRootIndex");

var invariant = require("./invariant");

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 100;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  !(isValidID(ancestorID) && isValidID(destinationID)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
  !isAncestorIDOf(ancestorID, destinationID) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  var i;
  for (i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  !isValidID(longestCommonID) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  !(start !== stop) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
  var traverseUp = isAncestorIDOf(stop, start);
  !(traverseUp || isAncestorIDOf(start, stop)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start;; id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    !(depth++ < MAX_TREE_DEPTH) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop) : invariant(false) : undefined;
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function () {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function (rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function (id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Same as `traverseTwoPhase` but skips the `targetID`.
   */
  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, true);
      traverseParentPath(targetID, '', cb, arg, true, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function (targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;
/* until break */
}).call(this,require('_process'))

},{"./ReactRootIndex":100,"./invariant":158,"_process":2}],82:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceMap
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],83:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactIsomorphic
 */

'use strict';

var ReactChildren = require("./ReactChildren");
var ReactComponent = require("./ReactComponent");
var ReactClass = require("./ReactClass");
var ReactDOM = require("./ReactDOM");
var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactPropTypes = require("./ReactPropTypes");

var assign = require("./Object.assign");
var onlyChild = require("./onlyChild");

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if ('production' !== process.env.NODE_ENV) {
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    only: onlyChild
  },

  Component: ReactComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOM,

  // Hook for JSX spread, don't use this for anything else.
  __spread: assign
};

module.exports = React;
}).call(this,require('_process'))

},{"./Object.assign":36,"./ReactChildren":44,"./ReactClass":45,"./ReactComponent":46,"./ReactDOM":53,"./ReactElement":72,"./ReactElementValidator":73,"./ReactPropTypes":96,"./onlyChild":168,"_process":2}],84:[function(require,module,exports){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactLifeCycle
 */

'use strict';

/**
 * This module manages the bookkeeping when a component is in the process
 * of being mounted or being unmounted. This is used as a way to enforce
 * invariants (or warnings) when it is not recommended to call
 * setState/forceUpdate.
 *
 * currentlyMountingInstance: During the construction phase, it is not possible
 * to trigger an update since the instance is not fully mounted yet. However, we
 * currently allow this as a convenience for mutating the initial state.
 *
 * currentlyUnmountingInstance: During the unmounting phase, the instance is
 * still mounted and can therefore schedule an update. However, this is not
 * recommended and probably an error since it's about to be unmounted.
 * Therefore we still want to trigger in an error for that case.
 */

var ReactLifeCycle = {
  currentlyMountingInstance: null,
  currentlyUnmountingInstance: null
};

module.exports = ReactLifeCycle;
},{}],85:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactLink
 * @typechecks static-only
 */

'use strict';

/**
 * ReactLink encapsulates a common pattern in which a component wants to modify
 * a prop received from its parent. ReactLink allows the parent to pass down a
 * value coupled with a callback that, when invoked, expresses an intent to
 * modify that value. For example:
 *
 * React.createClass({
 *   getInitialState: function() {
 *     return {value: ''};
 *   },
 *   render: function() {
 *     var valueLink = new ReactLink(this.state.value, this._handleValueChange);
 *     return <input valueLink={valueLink} />;
 *   },
 *   this._handleValueChange: function(newValue) {
 *     this.setState({value: newValue});
 *   }
 * });
 *
 * We have provided some sugary mixins to make the creation and
 * consumption of ReactLink easier; see LinkedValueUtils and LinkedStateMixin.
 */

var React = require("./React");

/**
 * @param {*} value current value of the link
 * @param {function} requestChange callback to request a change
 */
function ReactLink(value, requestChange) {
  this.value = value;
  this.requestChange = requestChange;
}

/**
 * Creates a PropType that enforces the ReactLink API and optionally checks the
 * type of the value being passed inside the link. Example:
 *
 * MyComponent.propTypes = {
 *   tabIndexLink: ReactLink.PropTypes.link(React.PropTypes.number)
 * }
 */
function createLinkTypeChecker(linkType) {
  var shapes = {
    value: typeof linkType === 'undefined' ? React.PropTypes.any.isRequired : linkType.isRequired,
    requestChange: React.PropTypes.func.isRequired
  };
  return React.PropTypes.shape(shapes);
}

ReactLink.PropTypes = {
  link: createLinkTypeChecker
};

module.exports = ReactLink;
},{"./React":38}],86:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMarkupChecksum
 */

'use strict';

var adler32 = require("./adler32");

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);
    return markup.replace('>', ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">');
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":129}],87:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMount
 */

'use strict';

var DOMProperty = require("./DOMProperty");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactPerf = require("./ReactPerf");
var ReactReconciler = require("./ReactReconciler");
var ReactUpdateQueue = require("./ReactUpdateQueue");
var ReactUpdates = require("./ReactUpdates");

var emptyObject = require("./emptyObject");
var containsNode = require("./containsNode");
var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var validateDOMNesting = require("./validateDOMNesting");
var warning = require("./warning");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if ('production' !== process.env.NODE_ENV) {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        !!isValid(cached, id) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * Finds the node with the supplied public React instance.
 *
 * @param {*} instance A public React instance.
 * @return {?DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNodeFromInstance(instance) {
  var id = ReactInstanceMap.get(instance)._rootNodeID;
  if (ReactEmptyComponent.isNullComponentID(id)) {
    return null;
  }
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    !(internalGetID(node) === id) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
  if ('production' !== process.env.NODE_ENV) {
    if (context === emptyObject) {
      context = {};
    }
    var tag = container.nodeName.toLowerCase();
    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
  }
  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
  componentInstance._isTopLevel = true;
  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container) {
  ReactReconciler.unmountComponent(instance);

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {
  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
    if ('production' !== process.env.NODE_ENV) {
      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
    }

    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    if ('production' !== process.env.NODE_ENV) {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function (nextComponent, container) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? 'production' !== process.env.NODE_ENV ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    'production' !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    var componentInstance = instantiateReactComponent(nextElement, null);
    var reactRootID = ReactMount._registerComponent(componentInstance, container);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

    if ('production' !== process.env.NODE_ENV) {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
    }

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !ReactElement.isValidElement(nextElement) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'React.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

    'production' !== process.env.NODE_ENV ? warning(container && container.tagName !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevElement = prevComponent._currentElement;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback).getPublicInstance();
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);

    if ('production' !== process.env.NODE_ENV) {
      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (ReactMount.isRenderedByReact(rootElementSibling)) {
            'production' !== process.env.NODE_ENV ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
            break;
          }

          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
    var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject).getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into the supplied `container`.
   *
   * @param {function} constructor React component constructor.
   * @param {?object} props Initial props of the component instance.
   * @param {DOMElement} container DOM element to render into.
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  constructAndRenderComponent: function (constructor, props, container) {
    var element = ReactElement.createElement(constructor, props);
    return ReactMount.render(element, container);
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into a container node identified by supplied `id`.
   *
   * @param {function} componentConstructor React component constructor
   * @param {?object} props Initial props of the component instance.
   * @param {string} id ID of the DOM element to render into.
   * @return {ReactComponent} Component instance rendered in the container node.
   */
  constructAndRenderComponentByID: function (constructor, props, id) {
    var domNode = document.getElementById(id);
    !domNode ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Tried to get element with id of "%s" but it is not present on the page.', id) : invariant(false) : undefined;
    return ReactMount.constructAndRenderComponent(constructor, props, domNode);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function (container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    'production' !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      return false;
    }
    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if ('production' !== process.env.NODE_ENV) {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function (id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if ('production' !== process.env.NODE_ENV) {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        'production' !== process.env.NODE_ENV ? warning(
        // Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
        var containerChild = container.firstChild;
        if (containerChild && reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          'production' !== process.env.NODE_ENV ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode) : undefined;
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function (id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * True if the supplied `node` is rendered by React.
   *
   * @param {*} node DOM Element to check.
   * @return {boolean} True if the DOM Element appears to be rendered by React.
   * @internal
   */
  isRenderedByReact: function (node) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      return false;
    }
    var id = ReactMount.getID(node);
    return id ? id.charAt(0) === SEPARATOR : false;
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function (node) {
    var current = node;
    while (current && current.parentNode !== current) {
      if (ReactMount.isRenderedByReact(current)) {
        return current;
      }
      current = current.parentNode;
    }
    return null;
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function (ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }
        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    !false ? 'production' !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
  },

  _mountImageIntoNode: function (markup, container, shouldReuseMarkup) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var diffIndex = firstDifferenceIndex(markup, rootMarkup);
        var difference = ' (client) ' + markup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

        if ('production' !== process.env.NODE_ENV) {
          'production' !== process.env.NODE_ENV ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See React.renderToString() for server rendering.') : invariant(false) : undefined;

    setInnerHTML(container, markup);
  },

  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  getNodeFromInstance: getNodeFromInstance,

  purgeID: purgeID
};

ReactPerf.measureMethods(ReactMount, 'ReactMount', {
  _renderNewRootComponent: '_renderNewRootComponent',
  _mountImageIntoNode: '_mountImageIntoNode'
});

module.exports = ReactMount;
}).call(this,require('_process'))

},{"./DOMProperty":19,"./ReactBrowserEventEmitter":40,"./ReactCurrentOwner":52,"./ReactElement":72,"./ReactElementValidator":73,"./ReactEmptyComponent":74,"./ReactInstanceHandles":81,"./ReactInstanceMap":82,"./ReactMarkupChecksum":86,"./ReactPerf":92,"./ReactReconciler":98,"./ReactUpdateQueue":108,"./ReactUpdates":109,"./containsNode":133,"./emptyObject":139,"./instantiateReactComponent":157,"./invariant":158,"./setInnerHTML":173,"./shouldUpdateReactComponent":177,"./validateDOMNesting":181,"./warning":182,"_process":2}],88:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

'use strict';

var ReactComponentEnvironment = require("./ReactComponentEnvironment");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var ReactReconciler = require("./ReactReconciler");
var ReactChildReconciler = require("./ReactChildReconciler");

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    textContent: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    textContent: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;
      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index;
          mountImages.push(mountImage);
          index++;
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        // TODO: The setTextContent operation should be enough
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildren, transaction, context) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildren, transaction, context);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildren, transaction, context) {
      var prevChildren = this._renderedChildren;
      var nextChildren = ReactChildReconciler.updateChildren(prevChildren, nextNestedChildren, transaction, context);
      this._renderedChildren = nextChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChildByName(prevChild, name);
          }
          // The child must be instantiated before it's mounted.
          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          this._unmountChildByName(prevChildren[name], name);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function () {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, mountImage) {
      enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function (textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
      child._mountIndex = index;
      this.createChild(child, mountImage);
    },

    /**
     * Unmounts a rendered child by name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @param {string} name Name of the child in `this._renderedChildren`.
     * @private
     */
    _unmountChildByName: function (child, name) {
      this.removeChild(child);
      child._mountIndex = null;
    }

  }

};

module.exports = ReactMultiChild;
},{"./ReactChildReconciler":43,"./ReactComponentEnvironment":48,"./ReactMultiChildUpdateTypes":89,"./ReactReconciler":98}],89:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

'use strict';

var keyMirror = require("./keyMirror");

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;
},{"./keyMirror":164}],90:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeComponent
 */

'use strict';

var assign = require("./Object.assign");
var invariant = require("./invariant");

var autoGenerateWrapperClass = null;
var genericComponentClass = null;
// This registry keeps track of wrapper classes around native tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactNativeComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function (componentClasses) {
    assign(tagToComponentClass, componentClasses);
  },
  // Temporary hack since we expect DOM refs to behave like composites,
  // for this release.
  injectAutoWrapper: function (wrapperFactory) {
    autoGenerateWrapperClass = wrapperFactory;
  }
};

/**
 * Get a composite component wrapper class for a specific tag.
 *
 * @param {ReactElement} element The tag for which to get the class.
 * @return {function} The React class constructor function.
 */
function getComponentClassForElement(element) {
  if (typeof element.type === 'function') {
    return element.type;
  }
  var tag = element.type;
  var componentClass = tagToComponentClass[tag];
  if (componentClass == null) {
    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
  }
  return componentClass;
}

/**
 * Get a native internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? 'production' !== process.env.NODE_ENV ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
  return new genericComponentClass(element.type, element.props);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactNativeComponent = {
  getComponentClassForElement: getComponentClassForElement,
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactNativeComponentInjection
};

module.exports = ReactNativeComponent;
}).call(this,require('_process'))

},{"./Object.assign":36,"./invariant":158,"_process":2}],91:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactOwner
 */

'use strict';

var invariant = require("./invariant");

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function (object) {
    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to add a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(false) : undefined;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to remove a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(false) : undefined;
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],92:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

'use strict';

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */
var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * @param {object} object
   * @param {string} objectName
   * @param {object<string>} methodNames
   */
  measureMethods: function (object, objectName, methodNames) {
    if ('production' !== process.env.NODE_ENV) {
      for (var key in methodNames) {
        if (!methodNames.hasOwnProperty(key)) {
          continue;
        }
        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
      }
    }
  },

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function (objName, fnName, func) {
    if ('production' !== process.env.NODE_ENV) {
      var measuredFunc = null;
      var wrapper = function () {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
      wrapper.displayName = objName + '_' + fnName;
      return wrapper;
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function (measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;
}).call(this,require('_process'))

},{"_process":2}],93:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTransferer
 */

'use strict';

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var joinClasses = require("./joinClasses");

/**
 * Creates a transfer strategy that will merge prop values using the supplied
 * `mergeStrategy`. If a prop was previously unset, this just sets it.
 *
 * @param {function} mergeStrategy
 * @return {function}
 */
function createTransferStrategy(mergeStrategy) {
  return function (props, key, value) {
    if (!props.hasOwnProperty(key)) {
      props[key] = value;
    } else {
      props[key] = mergeStrategy(props[key], value);
    }
  };
}

var transferStrategyMerge = createTransferStrategy(function (a, b) {
  // `merge` overrides the first object's (`props[key]` above) keys using the
  // second object's (`value`) keys. An object's style's existing `propA` would
  // get overridden. Flip the order here.
  return assign({}, b, a);
});

/**
 * Transfer strategies dictate how props are transferred by `transferPropsTo`.
 * NOTE: if you add any more exceptions to this list you should be sure to
 * update `cloneWithProps()` accordingly.
 */
var TransferStrategies = {
  /**
   * Never transfer `children`.
   */
  children: emptyFunction,
  /**
   * Transfer the `className` prop by merging them.
   */
  className: createTransferStrategy(joinClasses),
  /**
   * Transfer the `style` prop (which is an object) by merging them.
   */
  style: transferStrategyMerge
};

/**
 * Mutates the first argument by transferring the properties from the second
 * argument.
 *
 * @param {object} props
 * @param {object} newProps
 * @return {object}
 */
function transferInto(props, newProps) {
  for (var thisKey in newProps) {
    if (!newProps.hasOwnProperty(thisKey)) {
      continue;
    }

    var transferStrategy = TransferStrategies[thisKey];

    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
      transferStrategy(props, thisKey, newProps[thisKey]);
    } else if (!props.hasOwnProperty(thisKey)) {
      props[thisKey] = newProps[thisKey];
    }
  }
  return props;
}

/**
 * ReactPropTransferer are capable of transferring props to another component
 * using a `transferPropsTo` method.
 *
 * @class ReactPropTransferer
 */
var ReactPropTransferer = {

  /**
   * Merge two props objects using TransferStrategies.
   *
   * @param {object} oldProps original props (they take precedence)
   * @param {object} newProps new props to merge in
   * @return {object} a new object containing both sets of props merged.
   */
  mergeProps: function (oldProps, newProps) {
    return transferInto(assign({}, oldProps), newProps);
  }

};

module.exports = ReactPropTransferer;
},{"./Object.assign":36,"./emptyFunction":138,"./joinClasses":163}],94:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

'use strict';

var ReactPropTypeLocationNames = {};

if ('production' !== process.env.NODE_ENV) {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
}).call(this,require('_process'))

},{"_process":2}],95:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

'use strict';

var keyMirror = require("./keyMirror");

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;
},{"./keyMirror":164}],96:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactFragment = require("./ReactFragment");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");

var emptyFunction = require("./emptyFunction");

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, '' + propFullName + '[' + i + ']');
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!ReactElement.isValidElement(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, '' + propFullName + '.' + key);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, '' + propFullName + '.' + key);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }
      propValue = ReactFragment.extractIfFragment(propValue);
      for (var k in propValue) {
        if (!isNode(propValue[k])) {
          return false;
        }
      }
      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

module.exports = ReactPropTypes;
},{"./ReactElement":72,"./ReactFragment":78,"./ReactPropTypeLocationNames":94,"./emptyFunction":138}],97:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

'use strict';

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactInputSelection = require("./ReactInputSelection");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occured. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction() {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap proceedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":15,"./Object.assign":36,"./PooledClass":37,"./ReactBrowserEventEmitter":40,"./ReactInputSelection":80,"./Transaction":126}],98:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconciler
 */

'use strict';

var ReactRef = require("./ReactRef");
var ReactElementValidator = require("./ReactElementValidator");

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, rootID, transaction, context) {
    var markup = internalInstance.mountComponent(rootID, transaction, context);
    if ('production' !== process.env.NODE_ENV) {
      ReactElementValidator.checkAndWarnForMutatedProps(internalInstance._currentElement);
    }
    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance) {
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent();
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && nextElement._owner != null) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.
      return;
    }

    if ('production' !== process.env.NODE_ENV) {
      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction) {
    internalInstance.performUpdateIfNecessary(transaction);
  }

};

module.exports = ReactReconciler;
}).call(this,require('_process'))

},{"./ReactElementValidator":73,"./ReactRef":99,"_process":2}],99:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRef
 */

'use strict';

var ReactOwner = require("./ReactOwner");

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  return nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref;
};

ReactRef.detachRefs = function (instance, element) {
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":91}],100:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

'use strict';

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function (_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;
},{}],101:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
'use strict';

var ReactElement = require("./ReactElement");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactServerRenderingTransaction = require("./ReactServerRenderingTransaction");

var emptyObject = require("./emptyObject");
var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup
 */
function renderToString(element) {
  !ReactElement.isValidElement(element) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup, without the extra React ID and checksum
 * (for generating static pages)
 */
function renderToStaticMarkup(element) {
  !ReactElement.isValidElement(element) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      return componentInstance.mountComponent(id, transaction, emptyObject);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

module.exports = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup
};
}).call(this,require('_process'))

},{"./ReactElement":72,"./ReactInstanceHandles":81,"./ReactMarkupChecksum":86,"./ReactServerRenderingTransaction":102,"./emptyObject":139,"./instantiateReactComponent":157,"./invariant":158,"_process":2}],102:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

'use strict';

var PooledClass = require("./PooledClass");
var CallbackQueue = require("./CallbackQueue");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap proceedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./CallbackQueue":15,"./Object.assign":36,"./PooledClass":37,"./Transaction":126,"./emptyFunction":138}],103:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactStateSetters
 */

'use strict';

var ReactStateSetters = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * @param {ReactCompositeComponent} component
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function (component, funcReturningState) {
    return function (a, b, c, d, e, f) {
      var partialState = funcReturningState.call(component, a, b, c, d, e, f);
      if (partialState) {
        component.setState(partialState);
      }
    };
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {ReactCompositeComponent} component
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function (component, key) {
    // Memoize the setters.
    var cache = component.__keySetters || (component.__keySetters = {});
    return cache[key] || (cache[key] = createStateKeySetter(component, key));
  }
};

function createStateKeySetter(component, key) {
  // Partial state is allocated outside of the function closure so it can be
  // reused with every call, avoiding memory allocation when this function
  // is called.
  var partialState = {};
  return function stateKeySetter(value) {
    partialState[key] = value;
    component.setState(partialState);
  };
}

ReactStateSetters.Mixin = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateSetter(function(xValue) {
   *     return {x: xValue};
   *   })(1);
   *
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function (funcReturningState) {
    return ReactStateSetters.createStateSetter(this, funcReturningState);
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateKeySetter('x')(1);
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function (key) {
    return ReactStateSetters.createStateKeySetter(this, key);
  }
};

module.exports = ReactStateSetters;
},{}],104:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTestUtils
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var React = require("./React");
var ReactElement = require("./ReactElement");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var assign = require("./Object.assign");
var emptyObject = require("./emptyObject");
var findDOMNode = require("./findDOMNode");

var topLevelTypes = EventConstants.topLevelTypes;

function Event(suffix) {}

/**
 * @class ReactTestUtils
 */

/**
 * Todo: Support the entire DOM.scry query syntax. For now, these simple
 * utilities will suffice for testing purposes.
 * @lends ReactTestUtils
 */
var ReactTestUtils = {
  renderIntoDocument: function (instance) {
    var div = document.createElement('div');
    // None of our tests actually require attaching the container to the
    // DOM, and doing so creates a mess that we rely on test isolation to
    // clean up, so we're going to stop honoring the name of this method
    // (and probably rename it eventually) if no problems arise.
    // document.documentElement.appendChild(div);
    return React.render(instance, div);
  },

  isElement: function (element) {
    return ReactElement.isValidElement(element);
  },

  isElementOfType: function (inst, convenienceConstructor) {
    return ReactElement.isValidElement(inst) && inst.type === convenienceConstructor;
  },

  isDOMComponent: function (inst) {
    // TODO: Fix this heuristic. It's just here because composites can currently
    // pretend to be DOM components.
    return !!(inst && inst.tagName && inst.getDOMNode);
  },

  isDOMComponentElement: function (inst) {
    return !!(inst && ReactElement.isValidElement(inst) && !!inst.tagName);
  },

  isCompositeComponent: function (inst) {
    return typeof inst.render === 'function' && typeof inst.setState === 'function';
  },

  isCompositeComponentWithType: function (inst, type) {
    return !!(ReactTestUtils.isCompositeComponent(inst) && inst.constructor === type);
  },

  isCompositeComponentElement: function (inst) {
    if (!ReactElement.isValidElement(inst)) {
      return false;
    }
    // We check the prototype of the type that will get mounted, not the
    // instance itself. This is a future proof way of duck typing.
    var prototype = inst.type.prototype;
    return typeof prototype.render === 'function' && typeof prototype.setState === 'function';
  },

  isCompositeComponentElementWithType: function (inst, type) {
    return !!(ReactTestUtils.isCompositeComponentElement(inst) && inst.constructor === type);
  },

  getRenderedChildOfCompositeComponent: function (inst) {
    if (!ReactTestUtils.isCompositeComponent(inst)) {
      return null;
    }
    var internalInstance = ReactInstanceMap.get(inst);
    return internalInstance._renderedComponent.getPublicInstance();
  },

  findAllInRenderedTree: function (inst, test) {
    if (!inst) {
      return [];
    }
    var ret = test(inst) ? [inst] : [];
    if (ReactTestUtils.isDOMComponent(inst)) {
      var internalInstance = ReactInstanceMap.get(inst);
      var renderedChildren = internalInstance._renderedComponent._renderedChildren;
      var key;
      for (key in renderedChildren) {
        if (!renderedChildren.hasOwnProperty(key)) {
          continue;
        }
        if (!renderedChildren[key].getPublicInstance) {
          continue;
        }
        ret = ret.concat(ReactTestUtils.findAllInRenderedTree(renderedChildren[key].getPublicInstance(), test));
      }
    } else if (ReactTestUtils.isCompositeComponent(inst)) {
      ret = ret.concat(ReactTestUtils.findAllInRenderedTree(ReactTestUtils.getRenderedChildOfCompositeComponent(inst), test));
    }
    return ret;
  },

  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the class name matching `className`.
   * @return an array of all the matches.
   */
  scryRenderedDOMComponentsWithClass: function (root, className) {
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      var instClassName = inst.props.className;
      return ReactTestUtils.isDOMComponent(inst) && (instClassName && (' ' + instClassName + ' ').indexOf(' ' + className + ' ') !== -1);
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithClass: function (root, className) {
    var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match ' + '(found: ' + all.length + ') for class:' + className);
    }
    return all[0];
  },

  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the tag name matching `tagName`.
   * @return an array of all the matches.
   */
  scryRenderedDOMComponentsWithTag: function (root, tagName) {
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      return ReactTestUtils.isDOMComponent(inst) && inst.tagName === tagName.toUpperCase();
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithTag: function (root, tagName) {
    var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for tag:' + tagName);
    }
    return all[0];
  },

  /**
   * Finds all instances of components with type equal to `componentType`.
   * @return an array of all the matches.
   */
  scryRenderedComponentsWithType: function (root, componentType) {
    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
      return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
    });
  },

  /**
   * Same as `scryRenderedComponentsWithType` but expects there to be one result
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactComponent} The one match.
   */
  findRenderedComponentWithType: function (root, componentType) {
    var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for componentType:' + componentType);
    }
    return all[0];
  },

  /**
   * Pass a mocked component module to this method to augment it with
   * useful methods that allow it to be used as a dummy React component.
   * Instead of rendering as usual, the component will become a simple
   * <div> containing any provided children.
   *
   * @param {object} module the mock function object exported from a
   *                        module that defines the component to be mocked
   * @param {?string} mockTagName optional dummy root tag name to return
   *                              from render method (overrides
   *                              module.mockTagName if provided)
   * @return {object} the ReactTestUtils object (for chaining)
   */
  mockComponent: function (module, mockTagName) {
    mockTagName = mockTagName || module.mockTagName || 'div';

    module.prototype.render.mockImplementation(function () {
      return React.createElement(mockTagName, null, this.props.children);
    });

    return this;
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occured
   * on an `Element` node.
   * @param topLevelType {Object} A type from `EventConstants.topLevelTypes`
   * @param {!Element} node The dom to simulate an event occurring on.
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnNode: function (topLevelType, node, fakeNativeEvent) {
    fakeNativeEvent.target = node;
    ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(topLevelType, fakeNativeEvent);
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occured
   * on the `ReactDOMComponent` `comp`.
   * @param topLevelType {Object} A type from `EventConstants.topLevelTypes`.
   * @param comp {!ReactDOMComponent}
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnDOMComponent: function (topLevelType, comp, fakeNativeEvent) {
    ReactTestUtils.simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
  },

  nativeTouchData: function (x, y) {
    return {
      touches: [{ pageX: x, pageY: y }]
    };
  },

  createRenderer: function () {
    return new ReactShallowRenderer();
  },

  Simulate: null,
  SimulateNative: {}
};

/**
 * @class ReactShallowRenderer
 */
var ReactShallowRenderer = function () {
  this._instance = null;
};

ReactShallowRenderer.prototype.getRenderOutput = function () {
  return this._instance && this._instance._renderedComponent && this._instance._renderedComponent._renderedOutput || null;
};

var NoopInternalComponent = function (element) {
  this._renderedOutput = element;
  this._currentElement = element === null || element === false ? ReactEmptyComponent.emptyElement : element;
};

NoopInternalComponent.prototype = {

  mountComponent: function () {},

  receiveComponent: function (element) {
    this._renderedOutput = element;
    this._currentElement = element === null || element === false ? ReactEmptyComponent.emptyElement : element;
  },

  unmountComponent: function () {}

};

var ShallowComponentWrapper = function () {};
assign(ShallowComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: function (element) {
    return new NoopInternalComponent(element);
  },
  _replaceNodeWithMarkupByID: function () {},
  _renderValidatedComponent: ReactCompositeComponent.Mixin._renderValidatedComponentWithoutOwnerOrContext
});

ReactShallowRenderer.prototype.render = function (element, context) {
  if (!context) {
    context = emptyObject;
  }
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
  this._render(element, transaction, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
};

ReactShallowRenderer.prototype.unmount = function () {
  if (this._instance) {
    this._instance.unmountComponent();
  }
};

ReactShallowRenderer.prototype._render = function (element, transaction, context) {
  if (!this._instance) {
    var rootID = ReactInstanceHandles.createReactRootID();
    var instance = new ShallowComponentWrapper(element.type);
    instance.construct(element);

    instance.mountComponent(rootID, transaction, context);

    this._instance = instance;
  } else {
    this._instance.receiveComponent(element, transaction, context);
  }
};

/**
 * Exports:
 *
 * - `ReactTestUtils.Simulate.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.change(Element/ReactDOMComponent)`
 * - ... (All keys from event plugin `eventTypes` objects)
 */
function makeSimulator(eventType) {
  return function (domComponentOrNode, eventData) {
    var node;
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      node = findDOMNode(domComponentOrNode);
    } else if (domComponentOrNode.tagName) {
      node = domComponentOrNode;
    }

    var dispatchConfig = ReactBrowserEventEmitter.eventNameDispatchConfigs[eventType];

    var fakeNativeEvent = new Event();
    fakeNativeEvent.target = node;
    // We don't use SyntheticEvent.getPooled in order to not have to worry about
    // properly destroying any properties assigned from `eventData` upon release
    var event = new SyntheticEvent(dispatchConfig, ReactMount.getID(node), fakeNativeEvent);
    assign(event, eventData);

    if (dispatchConfig.phasedRegistrationNames) {
      EventPropagators.accumulateTwoPhaseDispatches(event);
    } else {
      EventPropagators.accumulateDirectDispatches(event);
    }

    ReactUpdates.batchedUpdates(function () {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    });
  };
}

function buildSimulators() {
  ReactTestUtils.Simulate = {};

  var eventType;
  for (eventType in ReactBrowserEventEmitter.eventNameDispatchConfigs) {
    /**
     * @param {!Element || ReactDOMComponent} domComponentOrNode
     * @param {?object} eventData Fake event data to use in SyntheticEvent.
     */
    ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
  }
}

// Rebuild ReactTestUtils.Simulate whenever event plugins are injected
var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
EventPluginHub.injection.injectEventPluginOrder = function () {
  oldInjectEventPluginOrder.apply(this, arguments);
  buildSimulators();
};
var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
EventPluginHub.injection.injectEventPluginsByName = function () {
  oldInjectEventPlugins.apply(this, arguments);
  buildSimulators();
};

buildSimulators();

/**
 * Exports:
 *
 * - `ReactTestUtils.SimulateNative.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseIn/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseOut(Element/ReactDOMComponent)`
 * - ... (All keys from `EventConstants.topLevelTypes`)
 *
 * Note: Top level event types are a subset of the entire set of handler types
 * (which include a broader set of "synthetic" events). For example, onDragDone
 * is a synthetic event. Except when testing an event plugin or React's event
 * handling code specifically, you probably want to use ReactTestUtils.Simulate
 * to dispatch synthetic events.
 */

function makeNativeSimulator(eventType) {
  return function (domComponentOrNode, nativeEventData) {
    var fakeNativeEvent = new Event(eventType);
    assign(fakeNativeEvent, nativeEventData);
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      ReactTestUtils.simulateNativeEventOnDOMComponent(eventType, domComponentOrNode, fakeNativeEvent);
    } else if (!!domComponentOrNode.tagName) {
      // Will allow on actual dom nodes.
      ReactTestUtils.simulateNativeEventOnNode(eventType, domComponentOrNode, fakeNativeEvent);
    }
  };
}

var eventType;
for (eventType in topLevelTypes) {
  // Event type is stored as 'topClick' - we transform that to 'click'
  var convenienceName = eventType.indexOf('top') === 0 ? eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;
  /**
   * @param {!Element || ReactDOMComponent} domComponentOrNode
   * @param {?Event} nativeEventData Fake native event to use in SyntheticEvent.
   */
  ReactTestUtils.SimulateNative[convenienceName] = makeNativeSimulator(eventType);
}

module.exports = ReactTestUtils;
},{"./EventConstants":24,"./EventPluginHub":26,"./EventPropagators":29,"./Object.assign":36,"./React":38,"./ReactBrowserEventEmitter":40,"./ReactCompositeComponent":50,"./ReactElement":72,"./ReactEmptyComponent":74,"./ReactInstanceHandles":81,"./ReactInstanceMap":82,"./ReactMount":87,"./ReactUpdates":109,"./SyntheticEvent":118,"./emptyObject":139,"./findDOMNode":141}],105:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactTransitionChildMapping
 */

'use strict';

var ReactChildren = require("./ReactChildren");
var ReactFragment = require("./ReactFragment");

var ReactTransitionChildMapping = {
  /**
   * Given `this.props.children`, return an object mapping key to child. Just
   * simple syntactic sugar around ReactChildren.map().
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */
  getChildMapping: function (children) {
    if (!children) {
      return children;
    }
    return ReactFragment.extract(ReactChildren.map(children, function (child) {
      return child;
    }));
  },

  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */
  mergeChildMappings: function (prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      if (next.hasOwnProperty(key)) {
        return next[key];
      } else {
        return prev[key];
      }
    }

    // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextKeysPending = {};

    var pendingKeys = [];
    for (var prevKey in prev) {
      if (next.hasOwnProperty(prevKey)) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending.hasOwnProperty(nextKey)) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }

    // Finally, add the keys which didn't appear before any key in `next`
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }
};

module.exports = ReactTransitionChildMapping;
},{"./ReactChildren":44,"./ReactFragment":78}],106:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTransitionEvents
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

/**
 * EVENT_NAME_MAP is used to determine which event fired when a
 * transition/animation ends, based on the style property used to
 * define that event.
 */
var EVENT_NAME_MAP = {
  transitionend: {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'mozTransitionEnd',
    'OTransition': 'oTransitionEnd',
    'msTransition': 'MSTransitionEnd'
  },

  animationend: {
    'animation': 'animationend',
    'WebkitAnimation': 'webkitAnimationEnd',
    'MozAnimation': 'mozAnimationEnd',
    'OAnimation': 'oAnimationEnd',
    'msAnimation': 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are useable, and if not remove them
  // from the map
  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    var baseEvents = EVENT_NAME_MAP[baseEventName];
    for (var styleName in baseEvents) {
      if (styleName in style) {
        endEvents.push(baseEvents[styleName]);
        break;
      }
    }
  }
}

if (ExecutionEnvironment.canUseDOM) {
  detectEvents();
}

// We use the raw {add|remove}EventListener() call because EventListener
// does not know how to remove event listeners and we really should
// clean up. Also, these events are not triggered in older browsers
// so we should be A-OK here.

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var ReactTransitionEvents = {
  addEndEventListener: function (node, eventListener) {
    if (endEvents.length === 0) {
      // If CSS transitions are not supported, trigger an "end animation"
      // event immediately.
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },

  removeEndEventListener: function (node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

module.exports = ReactTransitionEvents;
},{"./ExecutionEnvironment":30}],107:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTransitionGroup
 */

'use strict';

var React = require("./React");
var ReactTransitionChildMapping = require("./ReactTransitionChildMapping");

var assign = require("./Object.assign");
var cloneWithProps = require("./cloneWithProps");
var emptyFunction = require("./emptyFunction");

var ReactTransitionGroup = React.createClass({
  displayName: 'ReactTransitionGroup',

  propTypes: {
    component: React.PropTypes.any,
    childFactory: React.PropTypes.func
  },

  getDefaultProps: function () {
    return {
      component: 'span',
      childFactory: emptyFunction.thatReturnsArgument
    };
  },

  getInitialState: function () {
    return {
      children: ReactTransitionChildMapping.getChildMapping(this.props.children)
    };
  },

  componentWillMount: function () {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  },

  componentDidMount: function () {
    var initialChildMapping = this.state.children;
    for (var key in initialChildMapping) {
      if (initialChildMapping[key]) {
        this.performAppear(key);
      }
    }
  },

  componentWillReceiveProps: function (nextProps) {
    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(nextProps.children);
    var prevChildMapping = this.state.children;

    this.setState({
      children: ReactTransitionChildMapping.mergeChildMappings(prevChildMapping, nextChildMapping)
    });

    var key;

    for (key in nextChildMapping) {
      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
        this.keysToEnter.push(key);
      }
    }

    for (key in prevChildMapping) {
      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
      if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
        this.keysToLeave.push(key);
      }
    }

    // If we want to someday check for reordering, we could do it here.
  },

  componentDidUpdate: function () {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  },

  performAppear: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];

    if (component.componentWillAppear) {
      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
    } else {
      this._handleDoneAppearing(key);
    }
  },

  _handleDoneAppearing: function (key) {
    var component = this.refs[key];
    if (component.componentDidAppear) {
      component.componentDidAppear();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully appeared. Remove it.
      this.performLeave(key);
    }
  },

  performEnter: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];

    if (component.componentWillEnter) {
      component.componentWillEnter(this._handleDoneEntering.bind(this, key));
    } else {
      this._handleDoneEntering(key);
    }
  },

  _handleDoneEntering: function (key) {
    var component = this.refs[key];
    if (component.componentDidEnter) {
      component.componentDidEnter();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully entered. Remove it.
      this.performLeave(key);
    }
  },

  performLeave: function (key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];
    if (component.componentWillLeave) {
      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
    } else {
      // Note that this is somewhat dangerous b/c it calls setState()
      // again, effectively mutating the component before all the work
      // is done.
      this._handleDoneLeaving(key);
    }
  },

  _handleDoneLeaving: function (key) {
    var component = this.refs[key];

    if (component.componentDidLeave) {
      component.componentDidLeave();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
      // This entered again before it fully left. Add it again.
      this.performEnter(key);
    } else {
      this.setState(function (state) {
        var newChildren = assign({}, state.children);
        delete newChildren[key];
        return { children: newChildren };
      });
    }
  },

  render: function () {
    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = [];
    for (var key in this.state.children) {
      var child = this.state.children[key];
      if (child) {
        // You may need to apply reactive updates to a child as it is leaving.
        // The normal React way to do it won't work since the child will have
        // already been removed. In case you need this behavior you can provide
        // a childFactory function to wrap every child, even the ones that are
        // leaving.
        childrenToRender.push(cloneWithProps(this.props.childFactory(child), { ref: key, key: key }));
      }
    }
    return React.createElement(this.props.component, this.props, childrenToRender);
  }
});

module.exports = ReactTransitionGroup;
},{"./Object.assign":36,"./React":38,"./ReactTransitionChildMapping":105,"./cloneWithProps":132,"./emptyFunction":138}],108:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdateQueue
 */

'use strict';

var ReactLifeCycle = require("./ReactLifeCycle");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var warning = require("./warning");

function enqueueUpdate(internalInstance) {
  if (internalInstance !== ReactLifeCycle.currentlyMountingInstance) {
    // If we're in a componentWillMount handler, don't enqueue a rerender
    // because ReactUpdates assumes we're in a browser context (which is
    // wrong for server rendering) and we're about to do a render anyway.
    // See bug in #1740.
    ReactUpdates.enqueueUpdate(internalInstance);
  }
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  !(ReactCurrentOwner.current == null) ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : invariant(false) : undefined;

  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if ('production' !== process.env.NODE_ENV) {
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      'production' !== process.env.NODE_ENV ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted ' + 'component. This is a no-op.', callerName, callerName) : undefined;
    }
    return null;
  }

  if (internalInstance === ReactLifeCycle.currentlyUnmountingInstance) {
    return null;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {
    !(typeof callback === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance || internalInstance === ReactLifeCycle.currentlyMountingInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    !(typeof callback === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldUpdateComponent`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function (publicInstance, partialProps) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');

    if (!internalInstance) {
      return;
    }

    !internalInstance._isTopLevel ? 'production' !== process.env.NODE_ENV ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var element = internalInstance._pendingElement || internalInstance._currentElement;
    var props = assign({}, element.props, partialProps);
    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function (publicInstance, props) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');

    if (!internalInstance) {
      return;
    }

    !internalInstance._isTopLevel ? 'production' !== process.env.NODE_ENV ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var element = internalInstance._pendingElement || internalInstance._currentElement;
    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, newElement) {
    internalInstance._pendingElement = newElement;
    enqueueUpdate(internalInstance);
  }

};

module.exports = ReactUpdateQueue;
}).call(this,require('_process'))

},{"./Object.assign":36,"./ReactCurrentOwner":52,"./ReactElement":72,"./ReactInstanceMap":82,"./ReactLifeCycle":84,"./ReactUpdates":109,"./invariant":158,"./warning":182,"_process":2}],109:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdates
 */

'use strict';

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactPerf = require("./ReactPerf");
var ReactReconciler = require("./ReactReconciler");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var warning = require("./warning");

var dirtyComponents = [];
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();
}

assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};
flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)
  'production' !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'enqueueUpdate(): Render methods should be a pure function of props ' + 'and state; triggering nested component updates from render is not ' + 'allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : undefined;

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
}).call(this,require('_process'))

},{"./CallbackQueue":15,"./Object.assign":36,"./PooledClass":37,"./ReactCurrentOwner":52,"./ReactPerf":92,"./ReactReconciler":98,"./Transaction":126,"./invariant":158,"./warning":182,"_process":2}],110:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactWithAddons
 */

/**
 * This module exists purely in the open source project, and is meant as a way
 * to create a separate standalone build of React. This build has "addons", or
 * functionality we've built and think might be useful but doesn't have a good
 * place to live inside React core.
 */

'use strict';

var LinkedStateMixin = require("./LinkedStateMixin");
var React = require("./React");
var ReactComponentWithPureRenderMixin = require("./ReactComponentWithPureRenderMixin");
var ReactCSSTransitionGroup = require("./ReactCSSTransitionGroup");
var ReactFragment = require("./ReactFragment");
var ReactTransitionGroup = require("./ReactTransitionGroup");
var ReactUpdates = require("./ReactUpdates");

var cloneWithProps = require("./cloneWithProps");
var renderSubtreeIntoContainer = require("./renderSubtreeIntoContainer");
var shallowCompare = require("./shallowCompare");
var update = require("./update");

React.addons = {
  CSSTransitionGroup: ReactCSSTransitionGroup,
  LinkedStateMixin: LinkedStateMixin,
  PureRenderMixin: ReactComponentWithPureRenderMixin,
  TransitionGroup: ReactTransitionGroup,

  batchedUpdates: ReactUpdates.batchedUpdates,
  cloneWithProps: cloneWithProps,
  createFragment: ReactFragment.create,
  renderSubtreeIntoContainer: renderSubtreeIntoContainer,
  shallowCompare: shallowCompare,
  update: update
};

if ('production' !== process.env.NODE_ENV) {
  React.addons.Perf = require("./ReactDefaultPerf");
  React.addons.TestUtils = require("./ReactTestUtils");
}

module.exports = React;
}).call(this,require('_process'))

},{"./LinkedStateMixin":33,"./React":38,"./ReactCSSTransitionGroup":41,"./ReactComponentWithPureRenderMixin":49,"./ReactDefaultPerf":70,"./ReactFragment":78,"./ReactTestUtils":104,"./ReactTransitionGroup":107,"./ReactUpdates":109,"./cloneWithProps":132,"./renderSubtreeIntoContainer":172,"./shallowCompare":175,"./update":180,"_process":2}],111:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SVGDOMPropertyConfig
 */

'use strict';

var DOMProperty = require("./DOMProperty");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

var SVGDOMPropertyConfig = {
  Properties: {
    clipPath: MUST_USE_ATTRIBUTE,
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    xlinkActuate: MUST_USE_ATTRIBUTE,
    xlinkArcrole: MUST_USE_ATTRIBUTE,
    xlinkHref: MUST_USE_ATTRIBUTE,
    xlinkRole: MUST_USE_ATTRIBUTE,
    xlinkShow: MUST_USE_ATTRIBUTE,
    xlinkTitle: MUST_USE_ATTRIBUTE,
    xlinkType: MUST_USE_ATTRIBUTE,
    xmlBase: MUST_USE_ATTRIBUTE,
    xmlLang: MUST_USE_ATTRIBUTE,
    xmlSpace: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {
    clipPath: 'clip-path',
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space'
  }
};

module.exports = SVGDOMPropertyConfig;
},{"./DOMProperty":19}],112:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectEventPlugin
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ReactInputSelection = require("./ReactInputSelection");
var SyntheticEvent = require("./SyntheticEvent");

var getActiveElement = require("./getActiveElement");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");
var shallowEqual = require("./shallowEqual");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSelect: null }),
      captured: keyOf({ onSelectCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events.
var hasListener = false;
var ON_SELECT_KEY = keyOf({ onSelect: null });

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @param {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {

    if (!hasListener) {
      return null;
    }

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't).
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      case topLevelTypes.topSelectionChange:
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent);
    }

    return null;
  },

  didPutListener: function (id, registrationName, listener) {
    if (registrationName === ON_SELECT_KEY) {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventConstants":24,"./EventPropagators":29,"./ReactInputSelection":80,"./SyntheticEvent":118,"./getActiveElement":145,"./isTextInputElement":161,"./keyOf":165,"./shallowEqual":176}],113:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

'use strict';

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */
var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function () {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;
},{}],114:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SimpleEventPlugin
 */

'use strict';

var EventConstants = require("./EventConstants");
var EventListener = require("./EventListener");
var EventPluginUtils = require("./EventPluginUtils");
var EventPropagators = require("./EventPropagators");
var ReactMount = require("./ReactMount");
var SyntheticClipboardEvent = require("./SyntheticClipboardEvent");
var SyntheticEvent = require("./SyntheticEvent");
var SyntheticFocusEvent = require("./SyntheticFocusEvent");
var SyntheticKeyboardEvent = require("./SyntheticKeyboardEvent");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");
var SyntheticDragEvent = require("./SyntheticDragEvent");
var SyntheticTouchEvent = require("./SyntheticTouchEvent");
var SyntheticUIEvent = require("./SyntheticUIEvent");
var SyntheticWheelEvent = require("./SyntheticWheelEvent");

var emptyFunction = require("./emptyFunction");
var getEventCharCode = require("./getEventCharCode");
var invariant = require("./invariant");
var keyOf = require("./keyOf");
var warning = require("./warning");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBlur: true }),
      captured: keyOf({ onBlurCapture: true })
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onClick: true }),
      captured: keyOf({ onClickCapture: true })
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onContextMenu: true }),
      captured: keyOf({ onContextMenuCapture: true })
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCopy: true }),
      captured: keyOf({ onCopyCapture: true })
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCut: true }),
      captured: keyOf({ onCutCapture: true })
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDoubleClick: true }),
      captured: keyOf({ onDoubleClickCapture: true })
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrag: true }),
      captured: keyOf({ onDragCapture: true })
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnd: true }),
      captured: keyOf({ onDragEndCapture: true })
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnter: true }),
      captured: keyOf({ onDragEnterCapture: true })
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragExit: true }),
      captured: keyOf({ onDragExitCapture: true })
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragLeave: true }),
      captured: keyOf({ onDragLeaveCapture: true })
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragOver: true }),
      captured: keyOf({ onDragOverCapture: true })
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragStart: true }),
      captured: keyOf({ onDragStartCapture: true })
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrop: true }),
      captured: keyOf({ onDropCapture: true })
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onFocus: true }),
      captured: keyOf({ onFocusCapture: true })
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onInput: true }),
      captured: keyOf({ onInputCapture: true })
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyDown: true }),
      captured: keyOf({ onKeyDownCapture: true })
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyPress: true }),
      captured: keyOf({ onKeyPressCapture: true })
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyUp: true }),
      captured: keyOf({ onKeyUpCapture: true })
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoad: true }),
      captured: keyOf({ onLoadCapture: true })
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onError: true }),
      captured: keyOf({ onErrorCapture: true })
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseDown: true }),
      captured: keyOf({ onMouseDownCapture: true })
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseMove: true }),
      captured: keyOf({ onMouseMoveCapture: true })
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOut: true }),
      captured: keyOf({ onMouseOutCapture: true })
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOver: true }),
      captured: keyOf({ onMouseOverCapture: true })
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseUp: true }),
      captured: keyOf({ onMouseUpCapture: true })
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPaste: true }),
      captured: keyOf({ onPasteCapture: true })
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onReset: true }),
      captured: keyOf({ onResetCapture: true })
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onScroll: true }),
      captured: keyOf({ onScrollCapture: true })
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSubmit: true }),
      captured: keyOf({ onSubmitCapture: true })
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchCancel: true }),
      captured: keyOf({ onTouchCancelCapture: true })
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchEnd: true }),
      captured: keyOf({ onTouchEndCapture: true })
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchMove: true }),
      captured: keyOf({ onTouchMoveCapture: true })
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchStart: true }),
      captured: keyOf({ onTouchStartCapture: true })
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWheel: true }),
      captured: keyOf({ onWheelCapture: true })
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topBlur: eventTypes.blur,
  topClick: eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy: eventTypes.copy,
  topCut: eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag: eventTypes.drag,
  topDragEnd: eventTypes.dragEnd,
  topDragEnter: eventTypes.dragEnter,
  topDragExit: eventTypes.dragExit,
  topDragLeave: eventTypes.dragLeave,
  topDragOver: eventTypes.dragOver,
  topDragStart: eventTypes.dragStart,
  topDrop: eventTypes.drop,
  topError: eventTypes.error,
  topFocus: eventTypes.focus,
  topInput: eventTypes.input,
  topKeyDown: eventTypes.keyDown,
  topKeyPress: eventTypes.keyPress,
  topKeyUp: eventTypes.keyUp,
  topLoad: eventTypes.load,
  topMouseDown: eventTypes.mouseDown,
  topMouseMove: eventTypes.mouseMove,
  topMouseOut: eventTypes.mouseOut,
  topMouseOver: eventTypes.mouseOver,
  topMouseUp: eventTypes.mouseUp,
  topPaste: eventTypes.paste,
  topReset: eventTypes.reset,
  topScroll: eventTypes.scroll,
  topSubmit: eventTypes.submit,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd: eventTypes.touchEnd,
  topTouchMove: eventTypes.touchMove,
  topTouchStart: eventTypes.touchStart,
  topWheel: eventTypes.wheel
};

for (var type in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[type].dependencies = [type];
}

var ON_CLICK_KEY = keyOf({ onClick: null });
var onClickListeners = {};

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * Same as the default implementation, except cancels the event when return
   * value is false. This behavior will be disabled in a future release.
   *
   * @param {object} Event to be dispatched.
   * @param {function} Application-level callback.
   * @param {string} domID DOM ID to pass to the callback.
   */
  executeDispatch: function (event, listener, domID) {
    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);

    'production' !== process.env.NODE_ENV ? warning(typeof returnValue !== 'boolean', 'Returning `false` from an event handler is deprecated and will be ' + 'ignored in a future release. Instead, manually call ' + 'e.stopPropagation() or e.preventDefault(), as appropriate.') : undefined;

    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  },

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topError:
      case topLevelTypes.topReset:
      case topLevelTypes.topSubmit:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? 'production' !== process.env.NODE_ENV ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (id, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    if (registrationName === ON_CLICK_KEY) {
      var node = ReactMount.getNode(id);
      if (!onClickListeners[id]) {
        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (id, registrationName) {
    if (registrationName === ON_CLICK_KEY) {
      onClickListeners[id].remove();
      delete onClickListeners[id];
    }
  }

};

module.exports = SimpleEventPlugin;
}).call(this,require('_process'))

},{"./EventConstants":24,"./EventListener":25,"./EventPluginUtils":28,"./EventPropagators":29,"./ReactMount":87,"./SyntheticClipboardEvent":115,"./SyntheticDragEvent":117,"./SyntheticEvent":118,"./SyntheticFocusEvent":119,"./SyntheticKeyboardEvent":121,"./SyntheticMouseEvent":122,"./SyntheticTouchEvent":123,"./SyntheticUIEvent":124,"./SyntheticWheelEvent":125,"./emptyFunction":138,"./getEventCharCode":146,"./invariant":158,"./keyOf":165,"./warning":182,"_process":2}],115:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":118}],116:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":118}],117:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":122}],118:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

'use strict';

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var getEventTarget = require("./getEventTarget");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: getEventTarget,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      this[propName] = nativeEvent[propName];
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);

module.exports = SyntheticEvent;
},{"./Object.assign":36,"./PooledClass":37,"./emptyFunction":138,"./getEventTarget":149}],119:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require("./SyntheticUIEvent");

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":124}],120:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":118}],121:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventCharCode = require("./getEventCharCode");
var getEventKey = require("./getEventKey");
var getEventModifierState = require("./getEventModifierState");

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":124,"./getEventCharCode":146,"./getEventKey":147,"./getEventModifierState":148}],122:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require("./SyntheticUIEvent");
var ViewportMetrics = require("./ViewportMetrics");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":124,"./ViewportMetrics":127,"./getEventModifierState":148}],123:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":124,"./getEventModifierState":148}],124:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require("./SyntheticEvent");

var getEventTarget = require("./getEventTarget");

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":118,"./getEventTarget":149}],125:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":122}],126:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Transaction
 */

'use strict';

var invariant = require("./invariant");

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (!this.wrapperInitData) {
      this.wrapperInitData = [];
    } else {
      this.wrapperInitData.length = 0;
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} args... Arguments to pass to the method (optional).
   *                           Helps prevent need to bind in many cases.
   * @return Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occured.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],127:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],128:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

'use strict';

var invariant = require("./invariant");

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],129:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adler32
 */

'use strict';

var MOD = 65521;

// This is a clean-room implementation of adler32 designed for detecting
// if markup is not what we expect it to be. It does not need to be
// cryptographically strong, only reasonably good at detecting if markup
// generated on the server is different than that on the client.
function adler32(data) {
  var a = 1;
  var b = 0;
  for (var i = 0; i < data.length; i++) {
    a = (a + data.charCodeAt(i)) % MOD;
    b = (b + a) % MOD;
  }
  return a | b << 16;
}

module.exports = adler32;
},{}],130:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelize
 * @typechecks
 */

"use strict";

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],131:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelizeStyleName
 * @typechecks
 */

'use strict';

var camelize = require("./camelize");

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":130}],132:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule cloneWithProps
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactPropTransferer = require("./ReactPropTransferer");

var keyOf = require("./keyOf");
var warning = require("./warning");

var CHILDREN_PROP = keyOf({ children: null });

/**
 * Sometimes you want to change the props of a child passed to you. Usually
 * this is to add a CSS class.
 *
 * @param {ReactElement} child child element you'd like to clone
 * @param {object} props props you'd like to modify. className and style will be
 * merged automatically.
 * @return {ReactElement} a clone of child with props merged in.
 */
function cloneWithProps(child, props) {
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(!child.ref, 'You are calling cloneWithProps() on a child with a ref. This is ' + 'dangerous because you\'re creating a new child which will not be ' + 'added as a ref to its parent.') : undefined;
  }

  var newProps = ReactPropTransferer.mergeProps(props, child.props);

  // Use `child.props.children` if it is provided.
  if (!newProps.hasOwnProperty(CHILDREN_PROP) && child.props.hasOwnProperty(CHILDREN_PROP)) {
    newProps.children = child.props.children;
  }

  // The current API doesn't retain _owner and _context, which is why this
  // doesn't use ReactElement.cloneAndReplaceProps.
  return ReactElement.createElement(child.type, newProps);
}

module.exports = cloneWithProps;
}).call(this,require('_process'))

},{"./ReactElement":72,"./ReactPropTransferer":93,"./keyOf":165,"./warning":182,"_process":2}],133:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule containsNode
 * @typechecks
 */

'use strict';

var isTextNode = require("./isTextNode");

/*jslint bitwise:true */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(_x, _x2) {
  var _again = true;

  _function: while (_again) {
    var outerNode = _x,
        innerNode = _x2;
    _again = false;

    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      _x = outerNode;
      _x2 = innerNode.parentNode;
      _again = true;
      continue _function;
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
}

module.exports = containsNode;
},{"./isTextNode":162}],134:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createArrayFromMixed
 * @typechecks
 */

'use strict';

var toArray = require("./toArray");

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj &&
    // not window
    !('setInterval' in obj) && typeof obj.nodeType != 'number' && (
    // a real array
    (Array.isArray(obj) || 'callee' in obj || 'item' in obj))
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;

// arrays are objects, NodeLists are functions in Safari

// quacks like an array

// no DOM node should be considered an array-like
// a 'select' element has 'length' and 'item' properties on IE8

// arguments

// HTMLCollection/NodeList
},{"./toArray":178}],135:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createFullPageComponent
 * @typechecks
 */

'use strict';

// Defeat circular references by requiring this directly.
var ReactClass = require("./ReactClass");
var ReactElement = require("./ReactElement");

var invariant = require("./invariant");

/**
 * Create a component that will throw an exception when unmounted.
 *
 * Components like <html> <head> and <body> can't be removed or added
 * easily in a cross-browser way, however it's valuable to be able to
 * take advantage of React's reconciliation for styling and <title>
 * management. So we just document it and throw in dangerous cases.
 *
 * @param {string} tag The tag to wrap
 * @return {function} convenience constructor of new component
 */
function createFullPageComponent(tag) {
  var elementFactory = ReactElement.createFactory(tag);

  var FullPageComponent = ReactClass.createClass({
    tagName: tag.toUpperCase(),
    displayName: 'ReactFullPageComponent' + tag,

    componentWillUnmount: function () {
      !false ? 'production' !== process.env.NODE_ENV ? invariant(false, '%s tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, <head>, ' + 'and <body>) reliably and efficiently. To fix this, have a single ' + 'top-level component that never unmounts render these elements.', this.constructor.displayName) : invariant(false) : undefined;
    },

    render: function () {
      return elementFactory(this.props);
    }
  });

  return FullPageComponent;
}

module.exports = createFullPageComponent;
}).call(this,require('_process'))

},{"./ReactClass":45,"./ReactElement":72,"./invariant":158,"_process":2}],136:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*jslint evil: true, sub: true */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createArrayFromMixed = require("./createArrayFromMixed");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? 'production' !== process.env.NODE_ENV ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? 'production' !== process.env.NODE_ENV ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = createArrayFromMixed(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":30,"./createArrayFromMixed":134,"./getMarkupWrap":151,"./invariant":158,"_process":2}],137:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require("./CSSProperty");

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"./CSSProperty":13}],138:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

"use strict";

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],139:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyObject
 */

"use strict";

var emptyObject = {};

if ("production" !== process.env.NODE_ENV) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
}).call(this,require('_process'))

},{"_process":2}],140:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule escapeTextContentForBrowser
 */

'use strict';

var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;',
  '"': '&quot;',
  '\'': '&#x27;'
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextContentForBrowser;
},{}],141:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findDOMNode
 * @typechecks static-only
 */

'use strict';

var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactInstanceMap = require("./ReactInstanceMap");
var ReactMount = require("./ReactMount");

var invariant = require("./invariant");
var isNode = require("./isNode");
var warning = require("./warning");

/**
 * Returns the DOM node rendered by this element.
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if ('production' !== process.env.NODE_ENV) {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      'production' !== process.env.NODE_ENV ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (isNode(componentOrElement)) {
    return componentOrElement;
  }
  if (ReactInstanceMap.has(componentOrElement)) {
    return ReactMount.getNodeFromInstance(componentOrElement);
  }
  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Component (with keys: %s) contains `render` method ' + 'but is not mounted in the DOM', Object.keys(componentOrElement)) : invariant(false) : undefined;
  !false ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
}

module.exports = findDOMNode;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":52,"./ReactInstanceMap":82,"./ReactMount":87,"./invariant":158,"./isNode":160,"./warning":182,"_process":2}],142:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule flattenChildren
 */

'use strict';

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = result[name] === undefined;
  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))

},{"./traverseAllChildren":179,"./warning":182,"_process":2}],143:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule focusNode
 */

"use strict";

/**
 * @param {DOMElement} node input/textarea to focus
 */
function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],144:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

'use strict';

/**
 * @param {array} an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function (arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;
},{}],145:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document body is not yet defined.
 */
"use strict";

function getActiveElement() /*?DOMElement*/{
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],146:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventCharCode
 * @typechecks static-only
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],147:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

'use strict';

var getEventCharCode = require("./getEventCharCode");

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":146}],148:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  /*jshint validthis:true */
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],149:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],150:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getIteratorFn
 * @typechecks static-only
 */

'use strict';

/* global Symbol */
var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],151:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getMarkupWrap
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var invariant = require("./invariant");

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */
var shouldWrap = {
  // Force wrapping for SVG elements because if they get created inside a <div>,
  // they will be initialized in the wrong namespace (and will not display).
  'circle': true,
  'clipPath': true,
  'defs': true,
  'ellipse': true,
  'g': true,
  'line': true,
  'linearGradient': true,
  'path': true,
  'polygon': true,
  'polyline': true,
  'radialGradient': true,
  'rect': true,
  'stop': true,
  'text': true
};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg>', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap,

  'circle': svgWrap,
  'clipPath': svgWrap,
  'defs': svgWrap,
  'ellipse': svgWrap,
  'g': svgWrap,
  'line': svgWrap,
  'linearGradient': svgWrap,
  'path': svgWrap,
  'polygon': svgWrap,
  'polyline': svgWrap,
  'radialGradient': svgWrap,
  'rect': svgWrap,
  'stop': svgWrap,
  'text': svgWrap
};

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":30,"./invariant":158,"_process":2}],152:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNodeForCharacterOffset
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],153:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentAccessor
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"./ExecutionEnvironment":30}],154:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

"use strict";

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],155:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenate
 * @typechecks
 */

'use strict';

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],156:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

'use strict';

var hyphenate = require("./hyphenate");

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":155}],157:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

'use strict';

var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactNativeComponent = require("./ReactNativeComponent");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var warning = require("./warning");

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function () {};
assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: instantiateReactComponent
});

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {*} parentCompositeType The composite type that resolved this.
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, parentCompositeType) {
  var instance;

  if (node === null || node === false) {
    node = ReactEmptyComponent.emptyElement;
  }

  if (typeof node === 'object') {
    var element = node;
    if ('production' !== process.env.NODE_ENV) {
      'production' !== process.env.NODE_ENV ? warning(element && (typeof element.type === 'function' || typeof element.type === 'string'), 'Only functions or strings can be mounted as React components.') : undefined;
    }

    // Special case string values
    if (parentCompositeType === element.type && typeof element.type === 'string') {
      // Avoid recursion if the wrapper renders itself.
      instance = ReactNativeComponent.createInternalComponent(element);
      // All native components are currently wrapped in a composite so we're
      // safe to assume that this is what we should instantiate.
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // represenations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);
    } else {
      instance = new ReactCompositeComponentWrapper();
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    !false ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
  }

  if ('production' !== process.env.NODE_ENV) {
    'production' !== process.env.NODE_ENV ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
  }

  // Sets up the instance. This can probably just move into the constructor now.
  instance.construct(node);

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if ('production' !== process.env.NODE_ENV) {
    instance._isOwnerNecessary = false;
    instance._warnedAboutRefsInRender = false;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if ('production' !== process.env.NODE_ENV) {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
}).call(this,require('_process'))

},{"./Object.assign":36,"./ReactCompositeComponent":50,"./ReactEmptyComponent":74,"./ReactNativeComponent":90,"./invariant":158,"./warning":182,"_process":2}],158:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function (condition, format, a, b, c, d, e, f) {
  if ('production' !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":2}],159:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"./ExecutionEnvironment":30}],160:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
'use strict';

function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],161:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextInputElement
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  return elem && (elem.nodeName === 'INPUT' && supportedInputTypes[elem.type] || elem.nodeName === 'TEXTAREA');
}

module.exports = isTextInputElement;
},{}],162:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextNode
 * @typechecks
 */

'use strict';

var isNode = require("./isNode");

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":160}],163:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule joinClasses
 * @typechecks static-only
 */

'use strict';

/**
 * Combines multiple className strings into one.
 * http://jsperf.com/joinclasses-args-vs-array
 *
 * @param {...?string} classes
 * @return {string}
 */
function joinClasses(className /*, ... */) {
  if (!className) {
    className = '';
  }
  var nextClass;
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var ii = 1; ii < argLength; ii++) {
      nextClass = arguments[ii];
      if (nextClass) {
        className = (className ? className + ' ' : '') + nextClass;
      }
    }
  }
  return className;
}

module.exports = joinClasses;
},{}],164:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

'use strict';

var invariant = require("./invariant");

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function (obj) {
  var ret = {};
  var key;
  !(obj instanceof Object && !Array.isArray(obj)) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],165:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without loosing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
"use strict";

var keyOf = function (oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};

module.exports = keyOf;
},{}],166:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule mapObject
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;
},{}],167:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */
function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],168:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
'use strict';

var ReactElement = require("./ReactElement");

var invariant = require("./invariant");

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
  return children;
}

module.exports = onlyChild;
}).call(this,require('_process'))

},{"./ReactElement":72,"./invariant":158,"_process":2}],169:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performance
 * @typechecks
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"./ExecutionEnvironment":30}],170:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performanceNow
 * @typechecks
 */

'use strict';

var performance = require("./performance");

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (!performance || !performance.now) {
  performance = Date;
}

var performanceNow = performance.now.bind(performance);

module.exports = performanceNow;
},{"./performance":169}],171:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule quoteAttributeValueForBrowser
 */

'use strict';

var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":140}],172:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule renderSubtreeIntoContainer
*/

'use strict';

var ReactMount = require("./ReactMount");

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":87}],173:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setInnerHTML
 */

/* globals MSApp */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function (node, html) {
  node.innerHTML = html;
};

// Win8 apps: Allow all html to be inserted
if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
  setInnerHTML = function (node, html) {
    MSApp.execUnsafeLocalFunction(function () {
      node.innerHTML = html;
    });
  };
}

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(65279) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;
},{"./ExecutionEnvironment":30}],174:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setTextContent
 */

'use strict';

var ExecutionEnvironment = require("./ExecutionEnvironment");
var escapeTextContentForBrowser = require("./escapeTextContentForBrowser");
var setInnerHTML = require("./setInnerHTML");

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./ExecutionEnvironment":30,"./escapeTextContentForBrowser":140,"./setInnerHTML":173}],175:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require("./shallowEqual");

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
},{"./shallowEqual":176}],176:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shallowEqual
 */

'use strict';

/**
 * Performs equality by iterating through keys on an object and returning
 * false when any key has values which are not strictly equal between
 * objA and objB. Returns true when the values of all keys are strictly equal.
 *
 * @return {boolean}
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],177:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */
function shouldUpdateReactComponent(prevElement, nextElement) {
  if (prevElement != null && nextElement != null) {
    var prevType = typeof prevElement;
    var nextType = typeof nextElement;
    if (prevType === 'string' || prevType === 'number') {
      return nextType === 'string' || nextType === 'number';
    } else {
      return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
  }
  return false;
}

module.exports = shouldUpdateReactComponent;
},{}],178:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule toArray
 * @typechecks
 */

'use strict';

var invariant = require("./invariant");

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

  !(typeof length === 'number') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

  !(length === 0 || length - 1 in obj) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {}
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;

// IE < 9 does not support Array#slice on collections objects
}).call(this,require('_process'))

},{"./invariant":158,"_process":2}],179:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

'use strict';

var ReactElement = require("./ReactElement");
var ReactFragment = require("./ReactFragment");
var ReactInstanceHandles = require("./ReactInstanceHandles");

var getIteratorFn = require("./getIteratorFn");
var invariant = require("./invariant");
var warning = require("./warning");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

var didWarnAboutMaps = false;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} key Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ('production' !== process.env.NODE_ENV) {
          'production' !== process.env.NODE_ENV ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      !(children.nodeType !== 1) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(false) : undefined;
      var fragment = ReactFragment.extract(children);
      for (var key in fragment) {
        if (fragment.hasOwnProperty(key)) {
          child = fragment[key];
          nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(child, 0);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
}).call(this,require('_process'))

},{"./ReactElement":72,"./ReactFragment":78,"./ReactInstanceHandles":81,"./getIteratorFn":150,"./invariant":158,"./warning":182,"_process":2}],180:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule update
 */

/* global hasOwnProperty:true */

'use strict';

var assign = require("./Object.assign");
var keyOf = require("./keyOf");
var invariant = require("./invariant");
var hasOwnProperty = ({}).hasOwnProperty;

function shallowCopy(x) {
  if (Array.isArray(x)) {
    return x.concat();
  } else if (x && typeof x === 'object') {
    return assign(new x.constructor(), x);
  } else {
    return x;
  }
}

var COMMAND_PUSH = keyOf({ $push: null });
var COMMAND_UNSHIFT = keyOf({ $unshift: null });
var COMMAND_SPLICE = keyOf({ $splice: null });
var COMMAND_SET = keyOf({ $set: null });
var COMMAND_MERGE = keyOf({ $merge: null });
var COMMAND_APPLY = keyOf({ $apply: null });

var ALL_COMMANDS_LIST = [COMMAND_PUSH, COMMAND_UNSHIFT, COMMAND_SPLICE, COMMAND_SET, COMMAND_MERGE, COMMAND_APPLY];

var ALL_COMMANDS_SET = {};

ALL_COMMANDS_LIST.forEach(function (command) {
  ALL_COMMANDS_SET[command] = true;
});

function invariantArrayCase(value, spec, command) {
  !Array.isArray(value) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected target of %s to be an array; got %s.', command, value) : invariant(false) : undefined;
  var specValue = spec[command];
  !Array.isArray(specValue) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected spec of %s to be an array; got %s. ' + 'Did you forget to wrap your parameter in an array?', command, specValue) : invariant(false) : undefined;
}

function update(value, spec) {
  !(typeof spec === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): You provided a key path to update() that did not contain one ' + 'of %s. Did you forget to include {%s: ...}?', ALL_COMMANDS_LIST.join(', '), COMMAND_SET) : invariant(false) : undefined;

  if (hasOwnProperty.call(spec, COMMAND_SET)) {
    !(Object.keys(spec).length === 1) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Cannot have more than one key in an object with %s', COMMAND_SET) : invariant(false) : undefined;

    return spec[COMMAND_SET];
  }

  var nextValue = shallowCopy(value);

  if (hasOwnProperty.call(spec, COMMAND_MERGE)) {
    var mergeObj = spec[COMMAND_MERGE];
    !(mergeObj && typeof mergeObj === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): %s expects a spec of type \'object\'; got %s', COMMAND_MERGE, mergeObj) : invariant(false) : undefined;
    !(nextValue && typeof nextValue === 'object') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): %s expects a target of type \'object\'; got %s', COMMAND_MERGE, nextValue) : invariant(false) : undefined;
    assign(nextValue, spec[COMMAND_MERGE]);
  }

  if (hasOwnProperty.call(spec, COMMAND_PUSH)) {
    invariantArrayCase(value, spec, COMMAND_PUSH);
    spec[COMMAND_PUSH].forEach(function (item) {
      nextValue.push(item);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_UNSHIFT)) {
    invariantArrayCase(value, spec, COMMAND_UNSHIFT);
    spec[COMMAND_UNSHIFT].forEach(function (item) {
      nextValue.unshift(item);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_SPLICE)) {
    !Array.isArray(value) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'Expected %s target to be an array; got %s', COMMAND_SPLICE, value) : invariant(false) : undefined;
    !Array.isArray(spec[COMMAND_SPLICE]) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. ' + 'Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : invariant(false) : undefined;
    spec[COMMAND_SPLICE].forEach(function (args) {
      !Array.isArray(args) ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. ' + 'Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : invariant(false) : undefined;
      nextValue.splice.apply(nextValue, args);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_APPLY)) {
    !(typeof spec[COMMAND_APPLY] === 'function') ? 'production' !== process.env.NODE_ENV ? invariant(false, 'update(): expected spec of %s to be a function; got %s.', COMMAND_APPLY, spec[COMMAND_APPLY]) : invariant(false) : undefined;
    nextValue = spec[COMMAND_APPLY](nextValue);
  }

  for (var k in spec) {
    if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {
      nextValue[k] = update(value[k], spec[k]);
    }
  }

  return nextValue;
}

module.exports = update;
}).call(this,require('_process'))

},{"./Object.assign":36,"./invariant":158,"./keyOf":165,"_process":2}],181:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule validateDOMNesting
 */

'use strict';

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var warning = require("./warning");

var validateDOMNesting = emptyFunction;

if ('production' !== process.env.NODE_ENV) {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    parentTag: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.parentTag = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    /*eslint-disable space-after-keywords */
    do {
      /*eslint-enable space-after-keywords */
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        'production' !== process.env.NODE_ENV ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
      } else {
        'production' !== process.env.NODE_ENV ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
      }
    }
  };

  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
}).call(this,require('_process'))

},{"./Object.assign":36,"./emptyFunction":138,"./warning":182,"_process":2}],182:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule warning
 */

'use strict';

var emptyFunction = require("./emptyFunction");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ('production' !== process.env.NODE_ENV) {
  warning = function (condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.length < 10 || /^[s\W]*$/.test(format)) {
      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
}).call(this,require('_process'))

},{"./emptyFunction":138,"_process":2}],183:[function(require,module,exports){
module.exports = require('./lib/React');

},{"./lib/React":38}],184:[function(require,module,exports){
var AppDispatcher = require('../dispatcher/AppDispatcher');

var InputActions = {

    upsert: function(input) {
        AppDispatcher.dispatch({
            actionType: input.actionType,
            modelKey: input.modelKey,
            modelValue: input.modelValue
        });
    }

};

module.exports = InputActions;

},{"../dispatcher/AppDispatcher":200}],185:[function(require,module,exports){
var React = require('react');
var MainComponent = require('./components/MainComponent');

React.render(React.createElement(MainComponent, null), document.getElementById('app'));

},{"./components/MainComponent":188,"react":183}],186:[function(require,module,exports){
var React = require('react');
var InputActions = require('../../actions/InputActions');

var InputComponent = React.createClass({displayName: "InputComponent",
    _onInputChange: function(){
        var input = React.findDOMNode(this.refs.input).value.trim();
        if(input === ''){
            input = undefined; //deleted their input; resort to undefined||defaults
        }
        if(this.props.isValid(input)){
            if(input !== undefined){
                input = this.props.convert(input);
            }
            InputActions.upsert({
                actionType: this.props.actionType,
                modelKey: this.props.id,
                modelValue: input
            });
        }
    },
    render: function() {
        var before, after;
        if(this.props.addOnBeforeInput === undefined || this.props.addOnBeforeInput){
            before = React.createElement("span", {className: "input-group-addon"}, this.props.addOn);
        }else{
            after = React.createElement("span", {className: "input-group-addon"}, this.props.addOn);
        }
        var required = this.props.required ? ' required' : '';
        return (
            React.createElement("div", null, 
                React.createElement("label", {className: "label label-default" + required, htmlFor: this.props.id}, this.props.label), 
                React.createElement("div", {className: "input-group"}, 
                    before, 
                    React.createElement("input", {
                        className: "form-control", 
                        id: this.props.id, 
                        type: this.props.type, 
                        name: this.props.id, 
                        placeholder: this.props.default, 
                        onChange: this._onInputChange, 
                        ref: "input"}
                    ), 
                    after
                )
            )
        );
    }
});

module.exports = InputComponent;

},{"../../actions/InputActions":184,"react":183}],187:[function(require,module,exports){
var React = require('react');
var InputComponent = require('./InputComponent');
var MonthlyCostInputDefinitions = require('../../defines/MonthlyCostInputDefinitions');
var ScenarioInputDefinitions = require('../../defines/ScenarioInputDefinitions');

var MainComponent = React.createClass({displayName: "MainComponent",
    render: function() {
        var inputs = ScenarioInputDefinitions.get();
        inputs = inputs.concat(MonthlyCostInputDefinitions.get());
        var inputComponents;
        if(inputs !== undefined && inputs.length > 0) {
            inputComponents = inputs.map(function (e) {
                return (
                    React.createElement(InputComponent, {
                        key: e.id, 
                        id: e.id, 
                        actionType: e.actionType, 
                        type: e.type, 
                        label: e.label, 
                        default: e.default, 
                        required: e.required, 
                        addOnBeforeInput: e.addOnBeforeInput||true, 
                        addOn: e.addOn, 
                        isValid: e.isValid, 
                        convert: e.convert}
                        )
                );
            });
        }
        return (
            React.createElement("div", {className: "inputList"}, 
                inputComponents
            )
        );
    }
});

module.exports = MainComponent;

},{"../../defines/MonthlyCostInputDefinitions":197,"../../defines/ScenarioInputDefinitions":198,"./InputComponent":186,"react":183}],188:[function(require,module,exports){
var React = require('react');
var TitleComponent = require('./TitleComponent/TitleComponent');
var InputListComponent = require('./InputListComponent/InputListComponent');
var ResultListComponent = require('./ResultListComponent/ResultListComponent');

var MainComponent = React.createClass({displayName: "MainComponent",
    render: function() {
        return (
            React.createElement("div", {className: "mainComponent"}, 
                React.createElement(TitleComponent, null), 
                React.createElement(InputListComponent, null), 
                React.createElement(ResultListComponent, null)
            )
        );
    }
});

module.exports = MainComponent;
},{"./InputListComponent/InputListComponent":187,"./ResultListComponent/ResultListComponent":193,"./TitleComponent/TitleComponent":194,"react":183}],189:[function(require,module,exports){
var React = require('react');
var Highcharts = require('react-highcharts');

var IncomeBreakdownComponent = React.createClass({displayName: "IncomeBreakdownComponent",
    render: function() {
        var incomeBreakDownChart;

        if(this.props.monthlyIncome > 0) {

            var breakdowns = [
                {
                    label: 'Take home',
                    value: (this.props.netIncome / this.props.monthlyIncome) * 100
                },
                {
                    label: 'Expenses',
                    value: (this.props.monthlyExpenses / this.props.monthlyIncome) * 100
                },
                {
                    label: 'Monthly Car Cost',
                    value: (this.props.monthlyCarCost / this.props.monthlyIncome) * 100
                }
            ];

            var data = [];
            breakdowns.forEach(function (e) {
                if (e.value > 0) {
                    data.push([e.label, e.value]);
                }
            });

            var config = {
                chart: {
                    plotBackgroundColor: null,
                    plotBorderWidth: 0,
                    plotShadow: false
                },
                title: {
                    text: 'Income<br>Breakdown',
                    align: 'center',
                    verticalAlign: 'middle',
                    y: 40
                },
                tooltip: {
                    pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'
                },
                plotOptions: {
                    pie: {
                        dataLabels: {
                            enabled: true,
                            distance: -50,
                            style: {
                                fontWeight: 'bold',
                                color: 'white',
                                textShadow: '0px 1px 2px black'
                            }
                        },
                        startAngle: -90,
                        endAngle: 90,
                        center: ['50%', '75%']
                    }
                },
                series: [{
                    type: 'pie',
                    name: 'Income Breakdown',
                    innerSize: '50%',
                    data: data
                }]
            };
            incomeBreakDownChart = React.createElement(Highcharts, {config: config});
        }
        return (
            React.createElement("div", null, 
                incomeBreakDownChart
            )
        );
    }
});

module.exports = IncomeBreakdownComponent;
},{"react":183,"react-highcharts":8}],190:[function(require,module,exports){
var React = require('react');

var NetIncomeTextComponent = React.createClass({displayName: "NetIncomeTextComponent",
    render: function() {
        return (
            React.createElement("div", null, 
                React.createElement("h2", {className: "well centerText"}, "Take Home Per Month After Expenses And Car Payment $", this.props.netIncome.toFixed(2)), ";"
            )
        );
    }
});

module.exports = NetIncomeTextComponent;

},{"react":183}],191:[function(require,module,exports){
var React = require('react');
var InputActionConstants = require('../../../../constants/InputActionConstants');
var InputStore = require('../../../../stores/InputStore');

var SafetyNetOverTimeComponent = React.createClass({displayName: "SafetyNetOverTimeComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        InputStore.addChangeListener(InputActionConstants.SAFETY_NET_CHANGE, this._onInputChange);
    },
    componentWillUnmount: function() {
        InputStore.removeChangeListener(InputActionConstants.SAFETY_NET_CHANGE, this._onInputChange);
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        var safetyNetEffectText;

        if(this.state.inputs.safetyNet > 0){
            var monthsOfSafetyNetEffect = 12;
            var overTime = [];
            for(var i=1; i<=monthsOfSafetyNetEffect; i++){
                overTime[i] = (this.state.inputs.safetyNet + (this.props.netIncome * i));
            }
            safetyNetEffectText = React.createElement("h2", {className: "well centerText"}, "After 6 Months Your Safety Net Would Be At $", overTime[6].toFixed(2));
        }

        return (
            React.createElement("div", null, 
                safetyNetEffectText
            )
        );
    }
});

module.exports = SafetyNetOverTimeComponent;

},{"../../../../constants/InputActionConstants":196,"../../../../stores/InputStore":201,"react":183}],192:[function(require,module,exports){
var React = require('react');

var InputActionConstants = require('../../../constants/InputActionConstants');
var InputStore = require('../../../stores/InputStore');
var Validators = require('../../../util/Validators');
var ScenarioInputDefinitions = require('../../../defines/ScenarioInputDefinitions');

var IncomeBreakdownComponent = require('./NetIncomeBasedComponents/IncomeBreakdownComponent');
var NetIncomeTextComponent = require('./NetIncomeBasedComponents/NetIncomeTextComponent');
var SafetyNetOverTimeComponent = require('./NetIncomeBasedComponents/SafetyNetOverTimeComponent');

var listenToActions = [
    InputActionConstants.MONTHLY_INCOME_CHANGE,
    InputActionConstants.MONTHLY_EXPENSES_CHANGE
];

var ResultListComponent = React.createClass({displayName: "ResultListComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        var self = this;
        listenToActions.forEach(function(actionTypeConstant){
            InputStore.addChangeListener(actionTypeConstant, self._onInputChange);
        });
    },
    componentWillUnmount: function() {
        var self = this;
        listenToActions.forEach(function(actionTypeConstant){
            InputStore.removeChangeListener(actionTypeConstant, self._onInputChange);
        });
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        var incomeBreakdownComponent;
        var netIncomeTextComponent;
        var safetyNetOverTimeComponent;

        if(Validators.validateRequiredInputsExist(ScenarioInputDefinitions.get(), this.state.inputs)){
            var netIncome = this.state.inputs.monthlyIncome - this.state.inputs.monthlyExpenses - this.props.monthlyCarCost;
            incomeBreakdownComponent = React.createElement(IncomeBreakdownComponent, {
                netIncome: netIncome, 
                monthlyIncome: this.state.inputs.monthlyIncome, 
                monthlyCarCost: this.props.monthlyCarCost, 
                monthlyExpenses: this.state.inputs.monthlyExpenses}
            );
            netIncomeTextComponent = React.createElement(NetIncomeTextComponent, {netIncome: netIncome});
            safetyNetOverTimeComponent = React.createElement(SafetyNetOverTimeComponent, {netIncome: netIncome});
        }
        return (
            React.createElement("div", null, 
                incomeBreakdownComponent, 
                netIncomeTextComponent, 
                safetyNetOverTimeComponent
            )
        );
    }
});

module.exports = ResultListComponent;
},{"../../../constants/InputActionConstants":196,"../../../defines/ScenarioInputDefinitions":198,"../../../stores/InputStore":201,"../../../util/Validators":203,"./NetIncomeBasedComponents/IncomeBreakdownComponent":189,"./NetIncomeBasedComponents/NetIncomeTextComponent":190,"./NetIncomeBasedComponents/SafetyNetOverTimeComponent":191,"react":183}],193:[function(require,module,exports){
var React = require('react');
var InputActionConstants = require('../../constants/InputActionConstants');
var InputStore = require('../../stores/InputStore');
var Validators = require('../../util/Validators');
var MonthlyCostInputDefinitions = require('../../defines/MonthlyCostInputDefinitions');
var Calculations = require('../../util/Calculations');
var NetIncomeBasedListComponent = require('./ResultComponents/NetIncomeBasedListComponent');

var ResultListComponent = React.createClass({displayName: "ResultListComponent",
    _onInputChange: function() {
        this.setState({
            inputs: InputStore.getAll()
        });
    },
    componentDidMount: function() {
        InputStore.addChangeListener(InputActionConstants.MONTHLY_COST_INPUT_CHANGE, this._onInputChange);
    },
    componentWillUnmount: function() {
        InputStore.removeChangeListener(InputActionConstants.MONTHLY_COST_INPUT_CHANGE, this._onInputChange);
    },
    getInitialState: function() {
        return {
            inputs: InputStore.getAll()
        };
    },
    render: function() {
        if(Validators.validateRequiredInputsExist(MonthlyCostInputDefinitions.get(), this.state.inputs)){
            var monthlyCarCost = Calculations.monthlyCost(
                this.state.inputs.vehiclePrice,
                this.state.inputs.downPayment,
                this.state.inputs.tradeIn,
                this.state.inputs.interestRate,
                this.state.inputs.salesTax,
                this.state.inputs.term
            );
            return (
                React.createElement("div", null, 
                    React.createElement("div", {id: "monthlyCost"}, 
                        React.createElement("h2", {className: "well centerText"}, "Car Payment $", monthlyCarCost, "/month")
                    ), 
                    React.createElement(NetIncomeBasedListComponent, {monthlyCarCost: monthlyCarCost})
                )
            );
        }
        return (
            React.createElement("div", null)
        );
    }
});

module.exports = ResultListComponent;
},{"../../constants/InputActionConstants":196,"../../defines/MonthlyCostInputDefinitions":197,"../../stores/InputStore":201,"../../util/Calculations":202,"../../util/Validators":203,"./ResultComponents/NetIncomeBasedListComponent":192,"react":183}],194:[function(require,module,exports){
var React = require('react');
var TitleDefinitions = require('../../defines/TitleDefinitions');
var titleIntervalTime = 10000;
var titleUpdateInterval;

var InputComponent = React.createClass({displayName: "InputComponent",
    getInitialState: function(){
        var titles = TitleDefinitions.get();
        return {
            title: titles[Math.floor((Math.random() * (titles.length)))]
        };
    },
    componentDidMount: function(){
        var self = this;
        titleUpdateInterval = setInterval(function(){
            var titles = TitleDefinitions.get();
            self.setState({
                title: titles[Math.floor((Math.random() * (titles.length)))]
            });
        }, titleIntervalTime);
    },
    componentWillUnmount: function(){
        clearInterval(titleUpdateInterval);
    },
    render: function() {
        return (
            React.createElement("div", {className: "title"}, 
                React.createElement("h5", {key: "title", className: "centerText"}, this.state.title)
            )
        );
    }
});

module.exports = InputComponent;
},{"../../defines/TitleDefinitions":199,"react":183}],195:[function(require,module,exports){
module.exports = {
    MONTHLY_INCOME_DEFAULT: 0,
    MONTHLY_EXPENSES_DEFAULT: 0,
    SAFETY_NET_DEFAULT: 0,
    VEHICLE_PRICE_DEFAULT: undefined, //only required field for app to do basic func
    DOWN_PAYMENT_DEFAULT: 0,
    TRADE_IN_DEFAULT: 0,
    SALES_TAX_DEFAULT: 5.1,
    INTEREST_RATE_DEFAULT: 2.9,
    TERM_DEFAULT: 72
};

},{}],196:[function(require,module,exports){
var keyMirror = require('keymirror');

module.exports = keyMirror({
    MONTHLY_COST_INPUT_CHANGE: null,
    MONTHLY_INCOME_CHANGE: null,
    MONTHLY_EXPENSES_CHANGE: null,
    SAFETY_NET_CHANGE: null
});

},{"keymirror":6}],197:[function(require,module,exports){
module.exports.get = function(){
    var DefaultInputConstants = require('../constants/DefaultInputValueConstants');
    var InputActions = require('../constants/InputActionConstants');
    var Validators = require('../util/Validators');
    var inputs = [
        {
            id: 'vehiclePrice',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Vehicle Price',
            default: DefaultInputConstants.VEHICLE_PRICE_DEFAULT,
            required: DefaultInputConstants.VEHICLE_PRICE_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'downPayment',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Down Payment',
            default: DefaultInputConstants.DOWN_PAYMENT_DEFAULT,
            required: DefaultInputConstants.DOWN_PAYMENT_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'tradeIn',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Trade In',
            default: DefaultInputConstants.TRADE_IN_DEFAULT,
            required: DefaultInputConstants.TRADE_IN_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'salesTax',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Sales Tax',
            default: DefaultInputConstants.SALES_TAX_DEFAULT,
            required: DefaultInputConstants.SALES_TAX_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: '%',
            isValid: Validators.validatePercentInput,
            convert: function(e){ return parseFloat(e); }
        },
        {
            id: 'interestRate',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Interest Rate (APR)',
            default: DefaultInputConstants.INTEREST_RATE_DEFAULT,
            required: DefaultInputConstants.INTEREST_RATE_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: '%',
            isValid: Validators.validatePercentInput,
            convert: function(e){ return parseFloat(e); }
        },
        {
            id: 'term',
            actionType: InputActions.MONTHLY_COST_INPUT_CHANGE,
            type: 'number',
            label: 'Term (Months)',
            default: DefaultInputConstants.TERM_DEFAULT,
            required: DefaultInputConstants.TERM_DEFAULT === undefined,
            addOnBeforeInput: false,
            addOn: 'months',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        }
    ];
    return inputs;
};

},{"../constants/DefaultInputValueConstants":195,"../constants/InputActionConstants":196,"../util/Validators":203}],198:[function(require,module,exports){
module.exports.get = function(){
    var DefaultInputConstants = require('../constants/DefaultInputValueConstants');
    var InputActionConstants = require('../constants/InputActionConstants');
    var Validators = require('../util/Validators');
    var inputs = [
        {
            id: 'monthlyIncome',
            actionType: InputActionConstants.MONTHLY_INCOME_CHANGE,
            type: 'number',
            label: 'Monthly Income',
            default: DefaultInputConstants.MONTHLY_INCOME_DEFAULT,
            required: DefaultInputConstants.MONTHLY_INCOME_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'monthlyExpenses',
            actionType: InputActionConstants.MONTHLY_EXPENSES_CHANGE,
            type: 'number',
            label: 'Monthly Expenses',
            default: DefaultInputConstants.MONTHLY_EXPENSES_DEFAULT,
            required: DefaultInputConstants.MONTHLY_EXPENSES_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        },
        {
            id: 'safetyNet',
            actionType: InputActionConstants.SAFETY_NET_CHANGE,
            type: 'number',
            label: 'Savings / Safety Net',
            default: DefaultInputConstants.SAFETY_NET_DEFAULT,
            required: DefaultInputConstants.SAFETY_NET_DEFAULT === undefined,
            addOn: '$',
            isValid: Validators.validateNumberInput,
            convert: function(e){ return parseInt(e); }
        }
    ];
    return inputs;
};

},{"../constants/DefaultInputValueConstants":195,"../constants/InputActionConstants":196,"../util/Validators":203}],199:[function(require,module,exports){
module.exports.get = function(){
    return [
        "It's Worth It. Sign. Trust Me.",
        "It's Only 5K Less Than A Mortgage.",
        "Can You Really Put A Price On Fun?",
        "Retirement Is Still 40 Years Out.",
        "When In Doubt Get A V8.",
        "Adrenaline Is Priceless.",
        "Life Is Too Short To Drive A Boring Car.",
        "Just Cut Back On Eating Out."
    ]
};
},{}],200:[function(require,module,exports){
var Dispatcher = require('flux').Dispatcher;

module.exports = new Dispatcher();

},{"flux":3}],201:[function(require,module,exports){
var AppDispatcher = require('../dispatcher/AppDispatcher');
var EventEmitter = require('events').EventEmitter;
var InputActionConstants = require('../constants/InputActionConstants');
var assign = require('object-assign');

var _inputs = {};

var InputStore = assign({}, EventEmitter.prototype, {

    get: function(key){
        return _inputs[key];
    },
    getAll: function() {
        return _inputs;
    },

    emitMonthlyCostInputChange: function() {
        this.emit(InputActionConstants.MONTHLY_COST_INPUT_CHANGE);
    },

    emitScenarioChange: function(scenarioActionTypeConstant) {
        this.emit(scenarioActionTypeConstant);
    },

    addChangeListener: function(TypeOfChange, callback) {
        this.on(TypeOfChange, callback);
    },
    removeChangeListener: function(TypeOfChange, callback) {
        this.removeListener(TypeOfChange, callback);
    }

});

AppDispatcher.register(function(action) {

    switch(action.actionType) {
        case InputActionConstants.MONTHLY_COST_INPUT_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitMonthlyCostInputChange();
            break;
        case InputActionConstants.MONTHLY_INCOME_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        case InputActionConstants.MONTHLY_EXPENSES_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        case InputActionConstants.SAFETY_NET_CHANGE:
            _inputs[action.modelKey] = action.modelValue;
            InputStore.emitScenarioChange(action.actionType);
            break;
        default:
        // no op
    }

});

module.exports = InputStore;

},{"../constants/InputActionConstants":196,"../dispatcher/AppDispatcher":200,"events":1,"object-assign":7}],202:[function(require,module,exports){
module.exports.monthlyCost = function(vehiclePrice, downPayment, tradeIn, interestRate, salesTax, term){
    var adjustedInterestRatePercent = interestRate * .01;
    var adjustedSalesTaxPercent = salesTax * .01; // 2.9 => .029
    var salesTaxAmount = vehiclePrice * adjustedSalesTaxPercent;
    var netCost = vehiclePrice + salesTaxAmount - downPayment - tradeIn;
    var rate = adjustedInterestRatePercent / 12;
    var rateCalc = (rate * Math.pow((1 + rate), term))/(Math.pow((1 + rate), term) - 1);
    return parseFloat((netCost * rateCalc).toFixed(2));
};

},{}],203:[function(require,module,exports){
/*
  undefined's are ok, defaults are set for inputs (and if no default, calc simply isn't made)
 */
module.exports.validateNumberInput = function(input){
    try{
        if(input === undefined){
            return true;
        }else{
            parseInt(input);
        }
        return true;
    }catch(e){
        return false;
    }
};
module.exports.validatePercentInput = function(percent){
    try{
        if(percent === undefined){
            return true;
        }else{
            return !isNaN(parseFloat(percent));
        }
    }catch(e){
        return false;
    }
};
module.exports.validateRequiredInputsExist = function(inputDefinitions, inputModels){
    var isValid = true;
    inputDefinitions.forEach(function(e){
        if(inputModels[e.id] === undefined){
            if(e.default !== undefined){
                inputModels[e.id] = e.default;
            }else{
                isValid = false;
            }
        }
    });
    return isValid;
};

},{}]},{},[185])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZmx1eC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4L2xpYi9EaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZsdXgvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9rZXltaXJyb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1oaWdoY2hhcnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2FkZG9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQXV0b0ZvY3VzTWl4aW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU0NvcmUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DbGllbnRSZWFjdFJvb3RJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9EYW5nZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFBsdWdpbkh1Yi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRQcm9wYWdhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRTdGF0ZU1peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Mb2NhbEV2ZW50VHJhcE1peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NQ2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01Gb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01JZnJhbWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NSW1nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVNlcnZlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmYuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEZyYWdtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZUhhbmRsZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RMaWZlQ3ljbGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0TGluay5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNb3VudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROYXRpdmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0T3duZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UGVyZi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHJhbnNmZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UmVmLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFJvb3RJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0U3RhdGVTZXR0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRlc3RVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkdyb3VwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFVwZGF0ZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0V2l0aEFkZG9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TZXJ2ZXJSZWFjdFJvb3RJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9UcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvYWRsZXIzMi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2FtZWxpemUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jbG9uZVdpdGhQcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvY29udGFpbnNOb2RlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZmluZERPTU5vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZm9jdXNOb2RlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRNYXJrdXBXcmFwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaHlwaGVuYXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNOb2RlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2lzVGV4dE5vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2pvaW5DbGFzc2VzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9rZXlNaXJyb3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2tleU9mLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tYXBPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3BlcmZvcm1hbmNlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3NldFRleHRDb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaGFsbG93Q29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvc2hhbGxvd0VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdXBkYXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3dhcm5pbmcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcYWN0aW9uc1xcSW5wdXRBY3Rpb25zLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGFwcC5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxjb21wb25lbnRzXFxJbnB1dExpc3RDb21wb25lbnRcXElucHV0Q29tcG9uZW50LmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGNvbXBvbmVudHNcXElucHV0TGlzdENvbXBvbmVudFxcSW5wdXRMaXN0Q29tcG9uZW50LmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGNvbXBvbmVudHNcXE1haW5Db21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcUmVzdWx0TGlzdENvbXBvbmVudFxcUmVzdWx0Q29tcG9uZW50c1xcTmV0SW5jb21lQmFzZWRDb21wb25lbnRzXFxJbmNvbWVCcmVha2Rvd25Db21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcUmVzdWx0TGlzdENvbXBvbmVudFxcUmVzdWx0Q29tcG9uZW50c1xcTmV0SW5jb21lQmFzZWRDb21wb25lbnRzXFxOZXRJbmNvbWVUZXh0Q29tcG9uZW50LmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGNvbXBvbmVudHNcXFJlc3VsdExpc3RDb21wb25lbnRcXFJlc3VsdENvbXBvbmVudHNcXE5ldEluY29tZUJhc2VkQ29tcG9uZW50c1xcU2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcUmVzdWx0TGlzdENvbXBvbmVudFxcUmVzdWx0Q29tcG9uZW50c1xcTmV0SW5jb21lQmFzZWRMaXN0Q29tcG9uZW50LmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGNvbXBvbmVudHNcXFJlc3VsdExpc3RDb21wb25lbnRcXFJlc3VsdExpc3RDb21wb25lbnQuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29tcG9uZW50c1xcVGl0bGVDb21wb25lbnRcXFRpdGxlQ29tcG9uZW50LmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGNvbnN0YW50c1xcRGVmYXVsdElucHV0VmFsdWVDb25zdGFudHMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcY29uc3RhbnRzXFxJbnB1dEFjdGlvbkNvbnN0YW50cy5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxkZWZpbmVzXFxNb250aGx5Q29zdElucHV0RGVmaW5pdGlvbnMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcZGVmaW5lc1xcU2NlbmFyaW9JbnB1dERlZmluaXRpb25zLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXGRlZmluZXNcXFRpdGxlRGVmaW5pdGlvbnMuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcZGlzcGF0Y2hlclxcQXBwRGlzcGF0Y2hlci5qcyIsIkM6XFxVc2Vyc1xcamFrZVxcRGVza3RvcFxcZGV2XFxjYXJjYWxjXFxzcmNcXGpzXFxzdG9yZXNcXElucHV0U3RvcmUuanMiLCJDOlxcVXNlcnNcXGpha2VcXERlc2t0b3BcXGRldlxcY2FyY2FsY1xcc3JjXFxqc1xcdXRpbFxcQ2FsY3VsYXRpb25zLmpzIiwiQzpcXFVzZXJzXFxqYWtlXFxEZXNrdG9wXFxkZXZcXGNhcmNhbGNcXHNyY1xcanNcXHV0aWxcXFZhbGlkYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd5bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3B4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25iQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNURBO0FBQ0E7O0FDREEsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLDZCQUE2QixDQUFDLENBQUM7O0FBRTNELElBQUksWUFBWSxHQUFHOztJQUVmLE1BQU0sRUFBRSxTQUFTLEtBQUssRUFBRTtRQUNwQixhQUFhLENBQUMsUUFBUSxDQUFDO1lBQ25CLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTtZQUM1QixRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVE7WUFDeEIsVUFBVSxFQUFFLEtBQUssQ0FBQyxVQUFVO1NBQy9CLENBQUMsQ0FBQztBQUNYLEtBQUs7O0FBRUwsQ0FBQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsWUFBWTs7O0FDZDdCLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsNEJBQTRCLENBQUMsQ0FBQzs7QUFFMUQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxvQkFBQyxhQUFhLEVBQUEsSUFBQSxDQUFHLENBQUEsRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7QUNIL0QsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDOztBQUV6RCxJQUFJLG9DQUFvQyw4QkFBQTtJQUNwQyxjQUFjLEVBQUUsVUFBVTtRQUN0QixJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzVELEdBQUcsS0FBSyxLQUFLLEVBQUUsQ0FBQztZQUNaLEtBQUssR0FBRyxTQUFTLENBQUM7U0FDckI7UUFDRCxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pCLEdBQUcsS0FBSyxLQUFLLFNBQVMsQ0FBQztnQkFDbkIsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsWUFBWSxDQUFDLE1BQU0sQ0FBQztnQkFDaEIsVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVTtnQkFDakMsUUFBUSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDdkIsVUFBVSxFQUFFLEtBQUs7YUFDcEIsQ0FBQyxDQUFDO1NBQ047S0FDSjtJQUNELE1BQU0sRUFBRSxXQUFXO1FBQ2YsSUFBSSxNQUFNLEVBQUUsS0FBSyxDQUFDO1FBQ2xCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQztZQUN4RSxNQUFNLEdBQUcsb0JBQUEsTUFBSyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxtQkFBb0IsQ0FBQSxFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBYSxDQUFBLENBQUM7U0FDMUUsSUFBSTtZQUNELEtBQUssR0FBRyxvQkFBQSxNQUFLLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLG1CQUFvQixDQUFBLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFhLENBQUEsQ0FBQztTQUN6RTtRQUNELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFDdEQ7WUFDSSxvQkFBQSxLQUFJLEVBQUEsSUFBQyxFQUFBO2dCQUNELG9CQUFBLE9BQU0sRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUUscUJBQXFCLEdBQUcsUUFBUSxFQUFDLENBQUMsT0FBQSxFQUFPLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFJLENBQUEsRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQWMsQ0FBQSxFQUFBO2dCQUN0RyxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGFBQWMsQ0FBQSxFQUFBO29CQUN4QixNQUFNLEVBQUM7b0JBQ1Isb0JBQUEsT0FBTSxFQUFBLENBQUE7d0JBQ0YsU0FBQSxFQUFTLENBQUMsY0FBQSxFQUFjO3dCQUN4QixFQUFBLEVBQUUsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBQzt3QkFDbEIsSUFBQSxFQUFJLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUM7d0JBQ3RCLElBQUEsRUFBSSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFDO3dCQUNwQixXQUFBLEVBQVcsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBQzt3QkFDaEMsUUFBQSxFQUFRLENBQUUsSUFBSSxDQUFDLGNBQWMsRUFBQzt3QkFDOUIsR0FBQSxFQUFHLENBQUMsT0FBTyxDQUFBO29CQUNiLENBQUEsRUFBQTtvQkFDRCxLQUFNO2dCQUNMLENBQUE7WUFDSixDQUFBO1VBQ1I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsY0FBYzs7O0FDakQvQixJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsSUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDakQsSUFBSSwyQkFBMkIsR0FBRyxPQUFPLENBQUMsMkNBQTJDLENBQUMsQ0FBQztBQUN2RixJQUFJLHdCQUF3QixHQUFHLE9BQU8sQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDOztBQUVqRixJQUFJLG1DQUFtQyw2QkFBQTtJQUNuQyxNQUFNLEVBQUUsV0FBVztRQUNmLElBQUksTUFBTSxHQUFHLHdCQUF3QixDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzVDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLDJCQUEyQixDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDMUQsSUFBSSxlQUFlLENBQUM7UUFDcEIsR0FBRyxNQUFNLEtBQUssU0FBUyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzFDLGVBQWUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUN0QztvQkFDSSxvQkFBQyxjQUFjLEVBQUEsQ0FBQTt3QkFDWCxHQUFBLEVBQUcsQ0FBRSxDQUFDLENBQUMsRUFBRSxFQUFDO3dCQUNWLEVBQUEsRUFBRSxDQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUM7d0JBQ1QsVUFBQSxFQUFVLENBQUUsQ0FBQyxDQUFDLFVBQVUsRUFBQzt3QkFDekIsSUFBQSxFQUFJLENBQUUsQ0FBQyxDQUFDLElBQUksRUFBQzt3QkFDYixLQUFBLEVBQUssQ0FBRSxDQUFDLENBQUMsS0FBSyxFQUFDO3dCQUNmLE9BQUEsRUFBTyxDQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUM7d0JBQ25CLFFBQUEsRUFBUSxDQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUM7d0JBQ3JCLGdCQUFBLEVBQWdCLENBQUUsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLElBQUksRUFBQzt3QkFDM0MsS0FBQSxFQUFLLENBQUUsQ0FBQyxDQUFDLEtBQUssRUFBQzt3QkFDZixPQUFBLEVBQU8sQ0FBRSxDQUFDLENBQUMsT0FBTyxFQUFDO3dCQUNuQixPQUFBLEVBQU8sQ0FBRSxDQUFDLENBQUMsT0FBUSxDQUFBO3dCQUNqQixDQUFBO2tCQUNSO2FBQ0wsQ0FBQyxDQUFDO1NBQ047UUFDRDtZQUNJLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsV0FBWSxDQUFBLEVBQUE7Z0JBQ3RCLGVBQWdCO1lBQ2YsQ0FBQTtVQUNSO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLGFBQWE7OztBQ3JDOUIsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLElBQUksY0FBYyxHQUFHLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0FBQ2hFLElBQUksa0JBQWtCLEdBQUcsT0FBTyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7QUFDNUUsSUFBSSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsMkNBQTJDLENBQUMsQ0FBQzs7QUFFL0UsSUFBSSxtQ0FBbUMsNkJBQUE7SUFDbkMsTUFBTSxFQUFFLFdBQVc7UUFDZjtZQUNJLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsZUFBZ0IsQ0FBQSxFQUFBO2dCQUMzQixvQkFBQyxjQUFjLEVBQUEsSUFBQSxDQUFHLENBQUEsRUFBQTtnQkFDbEIsb0JBQUMsa0JBQWtCLEVBQUEsSUFBQSxDQUFHLENBQUEsRUFBQTtnQkFDdEIsb0JBQUMsbUJBQW1CLEVBQUEsSUFBQSxDQUFHLENBQUE7WUFDckIsQ0FBQTtVQUNSO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQzs7QUNqQi9CLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7QUFFN0MsSUFBSSw4Q0FBOEMsd0NBQUE7SUFDOUMsTUFBTSxFQUFFLFdBQVc7QUFDdkIsUUFBUSxJQUFJLG9CQUFvQixDQUFDOztBQUVqQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFOztZQUU3QixJQUFJLFVBQVUsR0FBRztnQkFDYjtvQkFDSSxLQUFLLEVBQUUsV0FBVztvQkFDbEIsS0FBSyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLElBQUksR0FBRztpQkFDakU7Z0JBQ0Q7b0JBQ0ksS0FBSyxFQUFFLFVBQVU7b0JBQ2pCLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxJQUFJLEdBQUc7aUJBQ3ZFO2dCQUNEO29CQUNJLEtBQUssRUFBRSxrQkFBa0I7b0JBQ3pCLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxJQUFJLEdBQUc7aUJBQ3RFO0FBQ2pCLGFBQWEsQ0FBQzs7WUFFRixJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7WUFDZCxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUM1QixJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFO29CQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2lCQUNqQztBQUNqQixhQUFhLENBQUMsQ0FBQzs7WUFFSCxJQUFJLE1BQU0sR0FBRztnQkFDVCxLQUFLLEVBQUU7b0JBQ0gsbUJBQW1CLEVBQUUsSUFBSTtvQkFDekIsZUFBZSxFQUFFLENBQUM7b0JBQ2xCLFVBQVUsRUFBRSxLQUFLO2lCQUNwQjtnQkFDRCxLQUFLLEVBQUU7b0JBQ0gsSUFBSSxFQUFFLHFCQUFxQjtvQkFDM0IsS0FBSyxFQUFFLFFBQVE7b0JBQ2YsYUFBYSxFQUFFLFFBQVE7b0JBQ3ZCLENBQUMsRUFBRSxFQUFFO2lCQUNSO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxXQUFXLEVBQUUsK0NBQStDO2lCQUMvRDtnQkFDRCxXQUFXLEVBQUU7b0JBQ1QsR0FBRyxFQUFFO3dCQUNELFVBQVUsRUFBRTs0QkFDUixPQUFPLEVBQUUsSUFBSTs0QkFDYixRQUFRLEVBQUUsQ0FBQyxFQUFFOzRCQUNiLEtBQUssRUFBRTtnQ0FDSCxVQUFVLEVBQUUsTUFBTTtnQ0FDbEIsS0FBSyxFQUFFLE9BQU87Z0NBQ2QsVUFBVSxFQUFFLG1CQUFtQjs2QkFDbEM7eUJBQ0o7d0JBQ0QsVUFBVSxFQUFFLENBQUMsRUFBRTt3QkFDZixRQUFRLEVBQUUsRUFBRTt3QkFDWixNQUFNLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDO3FCQUN6QjtpQkFDSjtnQkFDRCxNQUFNLEVBQUUsQ0FBQztvQkFDTCxJQUFJLEVBQUUsS0FBSztvQkFDWCxJQUFJLEVBQUUsa0JBQWtCO29CQUN4QixTQUFTLEVBQUUsS0FBSztvQkFDaEIsSUFBSSxFQUFFLElBQUk7aUJBQ2IsQ0FBQzthQUNMLENBQUM7WUFDRixvQkFBb0IsR0FBRyxvQkFBQyxVQUFVLEVBQUEsQ0FBQSxDQUFDLE1BQUEsRUFBTSxHQUFJLE1BQVEsQ0FBYSxDQUFBLENBQUM7U0FDdEU7UUFDRDtZQUNJLG9CQUFBLEtBQUksRUFBQSxJQUFDLEVBQUE7Z0JBQ0Esb0JBQXFCO1lBQ3BCLENBQUE7VUFDUjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyx3QkFBd0IsQ0FBQzs7QUMvRTFDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFN0IsSUFBSSw0Q0FBNEMsc0NBQUE7SUFDNUMsTUFBTSxFQUFFLFdBQVc7UUFDZjtZQUNJLG9CQUFBLEtBQUksRUFBQSxJQUFDLEVBQUE7Z0JBQ0Qsb0JBQUEsSUFBRyxFQUFBLENBQUEsQ0FBQyxTQUFBLEVBQVMsQ0FBQyxpQkFBa0IsQ0FBQSxFQUFBLHNEQUFBLEVBQXFELElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQU8sQ0FBQSxFQUFBLEdBQUE7QUFBQSxZQUN4SCxDQUFBO1VBQ1I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsc0JBQXNCOzs7QUNadkMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLElBQUksb0JBQW9CLEdBQUcsT0FBTyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7QUFDakYsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLCtCQUErQixDQUFDLENBQUM7O0FBRTFELElBQUksZ0RBQWdELDBDQUFBO0lBQ2hELGNBQWMsRUFBRSxXQUFXO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDVixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sRUFBRTtTQUM5QixDQUFDLENBQUM7S0FDTjtJQUNELGlCQUFpQixFQUFFLFdBQVc7UUFDMUIsVUFBVSxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUM3RjtJQUNELG9CQUFvQixFQUFFLFdBQVc7UUFDN0IsVUFBVSxDQUFDLG9CQUFvQixDQUFDLG9CQUFvQixDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUNoRztJQUNELGVBQWUsRUFBRSxXQUFXO1FBQ3hCLE9BQU87WUFDSCxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sRUFBRTtTQUM5QixDQUFDO0tBQ0w7SUFDRCxNQUFNLEVBQUUsV0FBVztBQUN2QixRQUFRLElBQUksbUJBQW1CLENBQUM7O1FBRXhCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztZQUMvQixJQUFJLHVCQUF1QixHQUFHLEVBQUUsQ0FBQztZQUNqQyxJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7WUFDbEIsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLHVCQUF1QixFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUN6QyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDNUU7WUFDRCxtQkFBbUIsR0FBRyxvQkFBQSxJQUFHLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGlCQUFrQixDQUFBLEVBQUEsOENBQUEsRUFBNkMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQU8sQ0FBQSxDQUFDO0FBQzVJLFNBQVM7O1FBRUQ7WUFDSSxvQkFBQSxLQUFJLEVBQUEsSUFBQyxFQUFBO2dCQUNBLG1CQUFvQjtZQUNuQixDQUFBO1VBQ1I7S0FDTDtBQUNMLENBQUMsQ0FBQyxDQUFDOztBQUVILE1BQU0sQ0FBQyxPQUFPLEdBQUcsMEJBQTBCOzs7QUN6QzNDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFN0IsSUFBSSxvQkFBb0IsR0FBRyxPQUFPLENBQUMseUNBQXlDLENBQUMsQ0FBQztBQUM5RSxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUN2RCxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUNyRCxJQUFJLHdCQUF3QixHQUFHLE9BQU8sQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDOztBQUVwRixJQUFJLHdCQUF3QixHQUFHLE9BQU8sQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0FBQzlGLElBQUksc0JBQXNCLEdBQUcsT0FBTyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7QUFDMUYsSUFBSSwwQkFBMEIsR0FBRyxPQUFPLENBQUMsdURBQXVELENBQUMsQ0FBQzs7QUFFbEcsSUFBSSxlQUFlLEdBQUc7SUFDbEIsb0JBQW9CLENBQUMscUJBQXFCO0lBQzFDLG9CQUFvQixDQUFDLHVCQUF1QjtBQUNoRCxDQUFDLENBQUM7O0FBRUYsSUFBSSx5Q0FBeUMsbUNBQUE7SUFDekMsY0FBYyxFQUFFLFdBQVc7UUFDdkIsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNWLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxFQUFFO1NBQzlCLENBQUMsQ0FBQztLQUNOO0lBQ0QsaUJBQWlCLEVBQUUsV0FBVztRQUMxQixJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFDaEIsZUFBZSxDQUFDLE9BQU8sQ0FBQyxTQUFTLGtCQUFrQixDQUFDO1lBQ2hELFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxrQkFBa0IsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDekUsQ0FBQyxDQUFDO0tBQ047SUFDRCxvQkFBb0IsRUFBRSxXQUFXO1FBQzdCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUNoQixlQUFlLENBQUMsT0FBTyxDQUFDLFNBQVMsa0JBQWtCLENBQUM7WUFDaEQsVUFBVSxDQUFDLG9CQUFvQixDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUM1RSxDQUFDLENBQUM7S0FDTjtJQUNELGVBQWUsRUFBRSxXQUFXO1FBQ3hCLE9BQU87WUFDSCxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU0sRUFBRTtTQUM5QixDQUFDO0tBQ0w7SUFDRCxNQUFNLEVBQUUsV0FBVztRQUNmLElBQUksd0JBQXdCLENBQUM7UUFDN0IsSUFBSSxzQkFBc0IsQ0FBQztBQUNuQyxRQUFRLElBQUksMEJBQTBCLENBQUM7O1FBRS9CLEdBQUcsVUFBVSxDQUFDLDJCQUEyQixDQUFDLHdCQUF3QixDQUFDLEdBQUcsRUFBRSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDekYsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQztZQUNoSCx3QkFBd0IsR0FBRyxvQkFBQyx3QkFBd0IsRUFBQSxDQUFBO2dCQUNoRCxTQUFBLEVBQVMsQ0FBRSxTQUFTLEVBQUM7Z0JBQ3JCLGFBQUEsRUFBYSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBQztnQkFDL0MsY0FBQSxFQUFjLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUM7Z0JBQzFDLGVBQUEsRUFBZSxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGVBQWdCLENBQUE7WUFDckQsQ0FBQSxDQUFDO1lBQ0gsc0JBQXNCLEdBQUcsb0JBQUMsc0JBQXNCLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFFLFNBQVUsQ0FBQSxDQUFHLENBQUEsQ0FBQztZQUMxRSwwQkFBMEIsR0FBRyxvQkFBQywwQkFBMEIsRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUUsU0FBVSxDQUFBLENBQUcsQ0FBQSxDQUFDO1NBQ3JGO1FBQ0Q7WUFDSSxvQkFBQSxLQUFJLEVBQUEsSUFBQyxFQUFBO2dCQUNBLHdCQUF3QixFQUFDO2dCQUN6QixzQkFBc0IsRUFBQztnQkFDdkIsMEJBQTJCO1lBQzFCLENBQUE7VUFDUjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxtQkFBbUIsQ0FBQzs7QUNqRXJDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO0FBQzNFLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBQ3BELElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQ2xELElBQUksMkJBQTJCLEdBQUcsT0FBTyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7QUFDdkYsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFDdEQsSUFBSSwyQkFBMkIsR0FBRyxPQUFPLENBQUMsZ0RBQWdELENBQUMsQ0FBQzs7QUFFNUYsSUFBSSx5Q0FBeUMsbUNBQUE7SUFDekMsY0FBYyxFQUFFLFdBQVc7UUFDdkIsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNWLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxFQUFFO1NBQzlCLENBQUMsQ0FBQztLQUNOO0lBQ0QsaUJBQWlCLEVBQUUsV0FBVztRQUMxQixVQUFVLENBQUMsaUJBQWlCLENBQUMsb0JBQW9CLENBQUMseUJBQXlCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQ3JHO0lBQ0Qsb0JBQW9CLEVBQUUsV0FBVztRQUM3QixVQUFVLENBQUMsb0JBQW9CLENBQUMsb0JBQW9CLENBQUMseUJBQXlCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQ3hHO0lBQ0QsZUFBZSxFQUFFLFdBQVc7UUFDeEIsT0FBTztZQUNILE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxFQUFFO1NBQzlCLENBQUM7S0FDTDtJQUNELE1BQU0sRUFBRSxXQUFXO1FBQ2YsR0FBRyxVQUFVLENBQUMsMkJBQTJCLENBQUMsMkJBQTJCLENBQUMsR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM1RixJQUFJLGNBQWMsR0FBRyxZQUFZLENBQUMsV0FBVztnQkFDekMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsWUFBWTtnQkFDOUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVztnQkFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTztnQkFDekIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsWUFBWTtnQkFDOUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUTtnQkFDMUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSTthQUN6QixDQUFDO1lBQ0Y7Z0JBQ0ksb0JBQUEsS0FBSSxFQUFBLElBQUMsRUFBQTtvQkFDRCxvQkFBQSxLQUFJLEVBQUEsQ0FBQSxDQUFDLEVBQUEsRUFBRSxDQUFDLGFBQWMsQ0FBQSxFQUFBO3dCQUNsQixvQkFBQSxJQUFHLEVBQUEsQ0FBQSxDQUFDLFNBQUEsRUFBUyxDQUFDLGlCQUFrQixDQUFBLEVBQUEsZUFBQSxFQUFjLGNBQWMsRUFBQyxRQUFXLENBQUE7b0JBQ3RFLENBQUEsRUFBQTtvQkFDTixvQkFBQywyQkFBMkIsRUFBQSxDQUFBLENBQUMsY0FBQSxFQUFjLENBQUUsY0FBZSxDQUFBLENBQUcsQ0FBQTtnQkFDN0QsQ0FBQTtjQUNSO1NBQ0w7UUFDRDtZQUNJLG9CQUFBLEtBQUksRUFBQSxJQUFPLENBQUE7VUFDYjtLQUNMO0FBQ0wsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxtQkFBbUIsQ0FBQzs7QUNsRHJDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUM3QixJQUFJLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQ2pFLElBQUksaUJBQWlCLEdBQUcsS0FBSyxDQUFDO0FBQzlCLElBQUksbUJBQW1CLENBQUM7O0FBRXhCLElBQUksb0NBQW9DLDhCQUFBO0lBQ3BDLGVBQWUsRUFBRSxVQUFVO1FBQ3ZCLElBQUksTUFBTSxHQUFHLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BDLE9BQU87WUFDSCxLQUFLLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1NBQy9ELENBQUM7S0FDTDtJQUNELGlCQUFpQixFQUFFLFVBQVU7UUFDekIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLG1CQUFtQixHQUFHLFdBQVcsQ0FBQyxVQUFVO1lBQ3hDLElBQUksTUFBTSxHQUFHLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQ1YsS0FBSyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQzthQUMvRCxDQUFDLENBQUM7U0FDTixFQUFFLGlCQUFpQixDQUFDLENBQUM7S0FDekI7SUFDRCxvQkFBb0IsRUFBRSxVQUFVO1FBQzVCLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0tBQ3RDO0lBQ0QsTUFBTSxFQUFFLFdBQVc7UUFDZjtZQUNJLG9CQUFBLEtBQUksRUFBQSxDQUFBLENBQUMsU0FBQSxFQUFTLENBQUMsT0FBUSxDQUFBLEVBQUE7Z0JBQ25CLG9CQUFBLElBQUcsRUFBQSxDQUFBLENBQUMsR0FBQSxFQUFHLENBQUMsT0FBQSxFQUFPLENBQUMsU0FBQSxFQUFTLENBQUMsWUFBYSxDQUFBLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFXLENBQUE7WUFDNUQsQ0FBQTtVQUNSO0tBQ0w7QUFDTCxDQUFDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQzs7QUNqQ2hDLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDYixzQkFBc0IsRUFBRSxDQUFDO0lBQ3pCLHdCQUF3QixFQUFFLENBQUM7SUFDM0Isa0JBQWtCLEVBQUUsQ0FBQztJQUNyQixxQkFBcUIsRUFBRSxTQUFTO0lBQ2hDLG9CQUFvQixFQUFFLENBQUM7SUFDdkIsZ0JBQWdCLEVBQUUsQ0FBQztJQUNuQixpQkFBaUIsRUFBRSxHQUFHO0lBQ3RCLHFCQUFxQixFQUFFLEdBQUc7SUFDMUIsWUFBWSxFQUFFLEVBQUU7Q0FDbkI7OztBQ1ZELElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQzs7QUFFckMsTUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7SUFDdkIseUJBQXlCLEVBQUUsSUFBSTtJQUMvQixxQkFBcUIsRUFBRSxJQUFJO0lBQzNCLHVCQUF1QixFQUFFLElBQUk7SUFDN0IsaUJBQWlCLEVBQUUsSUFBSTtDQUMxQixDQUFDOzs7QUNQRixNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyxVQUFVO0lBQzNCLElBQUkscUJBQXFCLEdBQUcsT0FBTyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7SUFDL0UsSUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7SUFDaEUsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7SUFDL0MsSUFBSSxNQUFNLEdBQUc7UUFDVDtZQUNJLEVBQUUsRUFBRSxjQUFjO1lBQ2xCLFVBQVUsRUFBRSxZQUFZLENBQUMseUJBQXlCO1lBQ2xELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLGVBQWU7WUFDdEIsT0FBTyxFQUFFLHFCQUFxQixDQUFDLHFCQUFxQjtZQUNwRCxRQUFRLEVBQUUscUJBQXFCLENBQUMscUJBQXFCLEtBQUssU0FBUztZQUNuRSxLQUFLLEVBQUUsR0FBRztZQUNWLE9BQU8sRUFBRSxVQUFVLENBQUMsbUJBQW1CO1lBQ3ZDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDOUM7UUFDRDtZQUNJLEVBQUUsRUFBRSxhQUFhO1lBQ2pCLFVBQVUsRUFBRSxZQUFZLENBQUMseUJBQXlCO1lBQ2xELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLGNBQWM7WUFDckIsT0FBTyxFQUFFLHFCQUFxQixDQUFDLG9CQUFvQjtZQUNuRCxRQUFRLEVBQUUscUJBQXFCLENBQUMsb0JBQW9CLEtBQUssU0FBUztZQUNsRSxLQUFLLEVBQUUsR0FBRztZQUNWLE9BQU8sRUFBRSxVQUFVLENBQUMsbUJBQW1CO1lBQ3ZDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDOUM7UUFDRDtZQUNJLEVBQUUsRUFBRSxTQUFTO1lBQ2IsVUFBVSxFQUFFLFlBQVksQ0FBQyx5QkFBeUI7WUFDbEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsVUFBVTtZQUNqQixPQUFPLEVBQUUscUJBQXFCLENBQUMsZ0JBQWdCO1lBQy9DLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxnQkFBZ0IsS0FBSyxTQUFTO1lBQzlELEtBQUssRUFBRSxHQUFHO1lBQ1YsT0FBTyxFQUFFLFVBQVUsQ0FBQyxtQkFBbUI7WUFDdkMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUM5QztRQUNEO1lBQ0ksRUFBRSxFQUFFLFVBQVU7WUFDZCxVQUFVLEVBQUUsWUFBWSxDQUFDLHlCQUF5QjtZQUNsRCxJQUFJLEVBQUUsUUFBUTtZQUNkLEtBQUssRUFBRSxXQUFXO1lBQ2xCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxpQkFBaUI7WUFDaEQsUUFBUSxFQUFFLHFCQUFxQixDQUFDLGlCQUFpQixLQUFLLFNBQVM7WUFDL0QsZ0JBQWdCLEVBQUUsS0FBSztZQUN2QixLQUFLLEVBQUUsR0FBRztZQUNWLE9BQU8sRUFBRSxVQUFVLENBQUMsb0JBQW9CO1lBQ3hDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLE9BQU8sVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDaEQ7UUFDRDtZQUNJLEVBQUUsRUFBRSxjQUFjO1lBQ2xCLFVBQVUsRUFBRSxZQUFZLENBQUMseUJBQXlCO1lBQ2xELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLHFCQUFxQjtZQUM1QixPQUFPLEVBQUUscUJBQXFCLENBQUMscUJBQXFCO1lBQ3BELFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxxQkFBcUIsS0FBSyxTQUFTO1lBQ25FLGdCQUFnQixFQUFFLEtBQUs7WUFDdkIsS0FBSyxFQUFFLEdBQUc7WUFDVixPQUFPLEVBQUUsVUFBVSxDQUFDLG9CQUFvQjtZQUN4QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQ2hEO1FBQ0Q7WUFDSSxFQUFFLEVBQUUsTUFBTTtZQUNWLFVBQVUsRUFBRSxZQUFZLENBQUMseUJBQXlCO1lBQ2xELElBQUksRUFBRSxRQUFRO1lBQ2QsS0FBSyxFQUFFLGVBQWU7WUFDdEIsT0FBTyxFQUFFLHFCQUFxQixDQUFDLFlBQVk7WUFDM0MsUUFBUSxFQUFFLHFCQUFxQixDQUFDLFlBQVksS0FBSyxTQUFTO1lBQzFELGdCQUFnQixFQUFFLEtBQUs7WUFDdkIsS0FBSyxFQUFFLFFBQVE7WUFDZixPQUFPLEVBQUUsVUFBVSxDQUFDLG1CQUFtQjtZQUN2QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQzlDO0tBQ0osQ0FBQztJQUNGLE9BQU8sTUFBTSxDQUFDO0NBQ2pCOzs7QUM1RUQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsVUFBVTtJQUMzQixJQUFJLHFCQUFxQixHQUFHLE9BQU8sQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO0lBQy9FLElBQUksb0JBQW9CLEdBQUcsT0FBTyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7SUFDeEUsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7SUFDL0MsSUFBSSxNQUFNLEdBQUc7UUFDVDtZQUNJLEVBQUUsRUFBRSxlQUFlO1lBQ25CLFVBQVUsRUFBRSxvQkFBb0IsQ0FBQyxxQkFBcUI7WUFDdEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsZ0JBQWdCO1lBQ3ZCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxzQkFBc0I7WUFDckQsUUFBUSxFQUFFLHFCQUFxQixDQUFDLHNCQUFzQixLQUFLLFNBQVM7WUFDcEUsS0FBSyxFQUFFLEdBQUc7WUFDVixPQUFPLEVBQUUsVUFBVSxDQUFDLG1CQUFtQjtZQUN2QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQzlDO1FBQ0Q7WUFDSSxFQUFFLEVBQUUsaUJBQWlCO1lBQ3JCLFVBQVUsRUFBRSxvQkFBb0IsQ0FBQyx1QkFBdUI7WUFDeEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsa0JBQWtCO1lBQ3pCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyx3QkFBd0I7WUFDdkQsUUFBUSxFQUFFLHFCQUFxQixDQUFDLHdCQUF3QixLQUFLLFNBQVM7WUFDdEUsS0FBSyxFQUFFLEdBQUc7WUFDVixPQUFPLEVBQUUsVUFBVSxDQUFDLG1CQUFtQjtZQUN2QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQzlDO1FBQ0Q7WUFDSSxFQUFFLEVBQUUsV0FBVztZQUNmLFVBQVUsRUFBRSxvQkFBb0IsQ0FBQyxpQkFBaUI7WUFDbEQsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsc0JBQXNCO1lBQzdCLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxrQkFBa0I7WUFDakQsUUFBUSxFQUFFLHFCQUFxQixDQUFDLGtCQUFrQixLQUFLLFNBQVM7WUFDaEUsS0FBSyxFQUFFLEdBQUc7WUFDVixPQUFPLEVBQUUsVUFBVSxDQUFDLG1CQUFtQjtZQUN2QyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1NBQzlDO0tBQ0osQ0FBQztJQUNGLE9BQU8sTUFBTSxDQUFDO0NBQ2pCOzs7QUN4Q0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsVUFBVTtJQUMzQixPQUFPO1FBQ0gsZ0NBQWdDO1FBQ2hDLG9DQUFvQztRQUNwQyxvQ0FBb0M7UUFDcEMsbUNBQW1DO1FBQ25DLHlCQUF5QjtRQUN6QiwwQkFBMEI7UUFDMUIsMENBQTBDO1FBQzFDLDhCQUE4QjtLQUNqQztDQUNKLENBQUM7O0FDWEYsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsQ0FBQzs7QUFFNUMsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLFVBQVUsRUFBRTs7O0FDRmpDLElBQUksYUFBYSxHQUFHLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO0FBQzNELElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxZQUFZLENBQUM7QUFDbEQsSUFBSSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsbUNBQW1DLENBQUMsQ0FBQztBQUN4RSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7O0FBRXRDLElBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQzs7QUFFakIsSUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLEVBQUUsRUFBRSxZQUFZLENBQUMsU0FBUyxFQUFFOztJQUVoRCxHQUFHLEVBQUUsU0FBUyxHQUFHLENBQUM7UUFDZCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUN2QjtJQUNELE1BQU0sRUFBRSxXQUFXO1FBQ2YsT0FBTyxPQUFPLENBQUM7QUFDdkIsS0FBSzs7SUFFRCwwQkFBMEIsRUFBRSxXQUFXO1FBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUNsRSxLQUFLOztJQUVELGtCQUFrQixFQUFFLFNBQVMsMEJBQTBCLEVBQUU7UUFDckQsSUFBSSxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0FBQzlDLEtBQUs7O0lBRUQsaUJBQWlCLEVBQUUsU0FBUyxZQUFZLEVBQUUsUUFBUSxFQUFFO1FBQ2hELElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ25DO0lBQ0Qsb0JBQW9CLEVBQUUsU0FBUyxZQUFZLEVBQUUsUUFBUSxFQUFFO1FBQ25ELElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQ3BELEtBQUs7O0FBRUwsQ0FBQyxDQUFDLENBQUM7O0FBRUgsYUFBYSxDQUFDLFFBQVEsQ0FBQyxTQUFTLE1BQU0sRUFBRTs7SUFFcEMsT0FBTyxNQUFNLENBQUMsVUFBVTtRQUNwQixLQUFLLG9CQUFvQixDQUFDLHlCQUF5QjtZQUMvQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7WUFDN0MsVUFBVSxDQUFDLDBCQUEwQixFQUFFLENBQUM7WUFDeEMsTUFBTTtRQUNWLEtBQUssb0JBQW9CLENBQUMscUJBQXFCO1lBQzNDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztZQUM3QyxVQUFVLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2pELE1BQU07UUFDVixLQUFLLG9CQUFvQixDQUFDLHVCQUF1QjtZQUM3QyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7WUFDN0MsVUFBVSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNqRCxNQUFNO1FBQ1YsS0FBSyxvQkFBb0IsQ0FBQyxpQkFBaUI7WUFDdkMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1lBQzdDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDakQsTUFBTTtBQUNsQixRQUFRLFFBQVE7O0FBRWhCLEtBQUs7O0FBRUwsQ0FBQyxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFVOzs7QUMxRDNCLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHLFNBQVMsWUFBWSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUM7SUFDbkcsSUFBSSwyQkFBMkIsR0FBRyxZQUFZLEdBQUcsR0FBRyxDQUFDO0lBQ3JELElBQUksdUJBQXVCLEdBQUcsUUFBUSxHQUFHLEdBQUcsQ0FBQztJQUM3QyxJQUFJLGNBQWMsR0FBRyxZQUFZLEdBQUcsdUJBQXVCLENBQUM7SUFDNUQsSUFBSSxPQUFPLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxXQUFXLEdBQUcsT0FBTyxDQUFDO0lBQ3BFLElBQUksSUFBSSxHQUFHLDJCQUEyQixHQUFHLEVBQUUsQ0FBQztJQUM1QyxJQUFJLFFBQVEsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3BGLE9BQU8sVUFBVSxDQUFDLENBQUMsT0FBTyxHQUFHLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN0RDs7O0FDUkQ7O0dBRUc7QUFDSCxNQUFNLENBQUMsT0FBTyxDQUFDLG1CQUFtQixHQUFHLFNBQVMsS0FBSyxDQUFDO0lBQ2hELEdBQUc7UUFDQyxHQUFHLEtBQUssS0FBSyxTQUFTLENBQUM7WUFDbkIsT0FBTyxJQUFJLENBQUM7U0FDZixJQUFJO1lBQ0QsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ25CO1FBQ0QsT0FBTyxJQUFJLENBQUM7S0FDZixNQUFNLENBQUMsQ0FBQztRQUNMLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0NBQ0osQ0FBQztBQUNGLE1BQU0sQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEdBQUcsU0FBUyxPQUFPLENBQUM7SUFDbkQsR0FBRztRQUNDLEdBQUcsT0FBTyxLQUFLLFNBQVMsQ0FBQztZQUNyQixPQUFPLElBQUksQ0FBQztTQUNmLElBQUk7WUFDRCxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ3RDO0tBQ0osTUFBTSxDQUFDLENBQUM7UUFDTCxPQUFPLEtBQUssQ0FBQztLQUNoQjtDQUNKLENBQUM7QUFDRixNQUFNLENBQUMsT0FBTyxDQUFDLDJCQUEyQixHQUFHLFNBQVMsZ0JBQWdCLEVBQUUsV0FBVyxDQUFDO0lBQ2hGLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQztJQUNuQixnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDaEMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLFNBQVMsQ0FBQztZQUMvQixHQUFHLENBQUMsQ0FBQyxPQUFPLEtBQUssU0FBUyxDQUFDO2dCQUN2QixXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7YUFDakMsSUFBSTtnQkFDRCxPQUFPLEdBQUcsS0FBSyxDQUFDO2FBQ25CO1NBQ0o7S0FDSixDQUFDLENBQUM7SUFDSCxPQUFPLE9BQU8sQ0FBQztDQUNsQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9saWIvRGlzcGF0Y2hlcicpXG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERpc3BhdGNoZXJcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG52YXIgX2xhc3RJRCA9IDE7XG52YXIgX3ByZWZpeCA9ICdJRF8nO1xuXG4vKipcbiAqIERpc3BhdGNoZXIgaXMgdXNlZCB0byBicm9hZGNhc3QgcGF5bG9hZHMgdG8gcmVnaXN0ZXJlZCBjYWxsYmFja3MuIFRoaXMgaXNcbiAqIGRpZmZlcmVudCBmcm9tIGdlbmVyaWMgcHViLXN1YiBzeXN0ZW1zIGluIHR3byB3YXlzOlxuICpcbiAqICAgMSkgQ2FsbGJhY2tzIGFyZSBub3Qgc3Vic2NyaWJlZCB0byBwYXJ0aWN1bGFyIGV2ZW50cy4gRXZlcnkgcGF5bG9hZCBpc1xuICogICAgICBkaXNwYXRjaGVkIHRvIGV2ZXJ5IHJlZ2lzdGVyZWQgY2FsbGJhY2suXG4gKiAgIDIpIENhbGxiYWNrcyBjYW4gYmUgZGVmZXJyZWQgaW4gd2hvbGUgb3IgcGFydCB1bnRpbCBvdGhlciBjYWxsYmFja3MgaGF2ZVxuICogICAgICBiZWVuIGV4ZWN1dGVkLlxuICpcbiAqIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGlzIGh5cG90aGV0aWNhbCBmbGlnaHQgZGVzdGluYXRpb24gZm9ybSwgd2hpY2hcbiAqIHNlbGVjdHMgYSBkZWZhdWx0IGNpdHkgd2hlbiBhIGNvdW50cnkgaXMgc2VsZWN0ZWQ6XG4gKlxuICogICB2YXIgZmxpZ2h0RGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBjb3VudHJ5IGlzIHNlbGVjdGVkXG4gKiAgIHZhciBDb3VudHJ5U3RvcmUgPSB7Y291bnRyeTogbnVsbH07XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBjaXR5IGlzIHNlbGVjdGVkXG4gKiAgIHZhciBDaXR5U3RvcmUgPSB7Y2l0eTogbnVsbH07XG4gKlxuICogICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgYmFzZSBmbGlnaHQgcHJpY2Ugb2YgdGhlIHNlbGVjdGVkIGNpdHlcbiAqICAgdmFyIEZsaWdodFByaWNlU3RvcmUgPSB7cHJpY2U6IG51bGx9XG4gKlxuICogV2hlbiBhIHVzZXIgY2hhbmdlcyB0aGUgc2VsZWN0ZWQgY2l0eSwgd2UgZGlzcGF0Y2ggdGhlIHBheWxvYWQ6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAqICAgICBhY3Rpb25UeXBlOiAnY2l0eS11cGRhdGUnLFxuICogICAgIHNlbGVjdGVkQ2l0eTogJ3BhcmlzJ1xuICogICB9KTtcbiAqXG4gKiBUaGlzIHBheWxvYWQgaXMgZGlnZXN0ZWQgYnkgYENpdHlTdG9yZWA6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLnJlZ2lzdGVyKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAqICAgICBpZiAocGF5bG9hZC5hY3Rpb25UeXBlID09PSAnY2l0eS11cGRhdGUnKSB7XG4gKiAgICAgICBDaXR5U3RvcmUuY2l0eSA9IHBheWxvYWQuc2VsZWN0ZWRDaXR5O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogV2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgY291bnRyeSwgd2UgZGlzcGF0Y2ggdGhlIHBheWxvYWQ6XG4gKlxuICogICBmbGlnaHREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAqICAgICBhY3Rpb25UeXBlOiAnY291bnRyeS11cGRhdGUnLFxuICogICAgIHNlbGVjdGVkQ291bnRyeTogJ2F1c3RyYWxpYSdcbiAqICAgfSk7XG4gKlxuICogVGhpcyBwYXlsb2FkIGlzIGRpZ2VzdGVkIGJ5IGJvdGggc3RvcmVzOlxuICpcbiAqICAgIENvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgQ291bnRyeVN0b3JlLmNvdW50cnkgPSBwYXlsb2FkLnNlbGVjdGVkQ291bnRyeTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFdoZW4gdGhlIGNhbGxiYWNrIHRvIHVwZGF0ZSBgQ291bnRyeVN0b3JlYCBpcyByZWdpc3RlcmVkLCB3ZSBzYXZlIGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgcmV0dXJuZWQgdG9rZW4uIFVzaW5nIHRoaXMgdG9rZW4gd2l0aCBgd2FpdEZvcigpYCwgd2UgY2FuIGd1YXJhbnRlZVxuICogdGhhdCBgQ291bnRyeVN0b3JlYCBpcyB1cGRhdGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgdGhhdCB1cGRhdGVzIGBDaXR5U3RvcmVgXG4gKiBuZWVkcyB0byBxdWVyeSBpdHMgZGF0YS5cbiAqXG4gKiAgIENpdHlTdG9yZS5kaXNwYXRjaFRva2VuID0gZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgaWYgKHBheWxvYWQuYWN0aW9uVHlwZSA9PT0gJ2NvdW50cnktdXBkYXRlJykge1xuICogICAgICAgLy8gYENvdW50cnlTdG9yZS5jb3VudHJ5YCBtYXkgbm90IGJlIHVwZGF0ZWQuXG4gKiAgICAgICBmbGlnaHREaXNwYXRjaGVyLndhaXRGb3IoW0NvdW50cnlTdG9yZS5kaXNwYXRjaFRva2VuXSk7XG4gKiAgICAgICAvLyBgQ291bnRyeVN0b3JlLmNvdW50cnlgIGlzIG5vdyBndWFyYW50ZWVkIHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogICAgICAgLy8gU2VsZWN0IHRoZSBkZWZhdWx0IGNpdHkgZm9yIHRoZSBuZXcgY291bnRyeVxuICogICAgICAgQ2l0eVN0b3JlLmNpdHkgPSBnZXREZWZhdWx0Q2l0eUZvckNvdW50cnkoQ291bnRyeVN0b3JlLmNvdW50cnkpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIHVzYWdlIG9mIGB3YWl0Rm9yKClgIGNhbiBiZSBjaGFpbmVkLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgIEZsaWdodFByaWNlU3RvcmUuZGlzcGF0Y2hUb2tlbiA9XG4gKiAgICAgZmxpZ2h0RGlzcGF0Y2hlci5yZWdpc3RlcihmdW5jdGlvbihwYXlsb2FkKSB7XG4gKiAgICAgICBzd2l0Y2ggKHBheWxvYWQuYWN0aW9uVHlwZSkge1xuICogICAgICAgICBjYXNlICdjb3VudHJ5LXVwZGF0ZSc6XG4gKiAgICAgICAgICAgZmxpZ2h0RGlzcGF0Y2hlci53YWl0Rm9yKFtDaXR5U3RvcmUuZGlzcGF0Y2hUb2tlbl0pO1xuICogICAgICAgICAgIEZsaWdodFByaWNlU3RvcmUucHJpY2UgPVxuICogICAgICAgICAgICAgZ2V0RmxpZ2h0UHJpY2VTdG9yZShDb3VudHJ5U3RvcmUuY291bnRyeSwgQ2l0eVN0b3JlLmNpdHkpO1xuICogICAgICAgICAgIGJyZWFrO1xuICpcbiAqICAgICAgICAgY2FzZSAnY2l0eS11cGRhdGUnOlxuICogICAgICAgICAgIEZsaWdodFByaWNlU3RvcmUucHJpY2UgPVxuICogICAgICAgICAgICAgRmxpZ2h0UHJpY2VTdG9yZShDb3VudHJ5U3RvcmUuY291bnRyeSwgQ2l0eVN0b3JlLmNpdHkpO1xuICogICAgICAgICAgIGJyZWFrO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGBjb3VudHJ5LXVwZGF0ZWAgcGF5bG9hZCB3aWxsIGJlIGd1YXJhbnRlZWQgdG8gaW52b2tlIHRoZSBzdG9yZXMnXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcyBpbiBvcmRlcjogYENvdW50cnlTdG9yZWAsIGBDaXR5U3RvcmVgLCB0aGVuXG4gKiBgRmxpZ2h0UHJpY2VTdG9yZWAuXG4gKi9cblxuICBmdW5jdGlvbiBEaXNwYXRjaGVyKCkge1xuICAgIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc1BlbmRpbmcgPSB7fTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzSGFuZGxlZCA9IHt9O1xuICAgIHRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfcGVuZGluZ1BheWxvYWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2l0aCBldmVyeSBkaXNwYXRjaGVkIHBheWxvYWQuIFJldHVybnNcbiAgICogYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHdpdGggYHdhaXRGb3IoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gX3ByZWZpeCArIF9sYXN0SUQrKztcbiAgICB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrc1tpZF0gPSBjYWxsYmFjaztcbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjYWxsYmFjayBiYXNlZCBvbiBpdHMgdG9rZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKi9cbiAgRGlzcGF0Y2hlci5wcm90b3R5cGUudW5yZWdpc3Rlcj1mdW5jdGlvbihpZCkge1xuICAgIGludmFyaWFudChcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzW2lkXSxcbiAgICAgICdEaXNwYXRjaGVyLnVucmVnaXN0ZXIoLi4uKTogYCVzYCBkb2VzIG5vdCBtYXAgdG8gYSByZWdpc3RlcmVkIGNhbGxiYWNrLicsXG4gICAgICBpZFxuICAgICk7XG4gICAgZGVsZXRlIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSBjYWxsYmFja3Mgc3BlY2lmaWVkIHRvIGJlIGludm9rZWQgYmVmb3JlIGNvbnRpbnVpbmcgZXhlY3V0aW9uXG4gICAqIG9mIHRoZSBjdXJyZW50IGNhbGxiYWNrLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IGEgY2FsbGJhY2sgaW5cbiAgICogcmVzcG9uc2UgdG8gYSBkaXNwYXRjaGVkIHBheWxvYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gaWRzXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS53YWl0Rm9yPWZ1bmN0aW9uKGlkcykge1xuICAgIGludmFyaWFudChcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZyxcbiAgICAgICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogTXVzdCBiZSBpbnZva2VkIHdoaWxlIGRpc3BhdGNoaW5nLidcbiAgICApO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpZHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgaWQgPSBpZHNbaWldO1xuICAgICAgaWYgKHRoaXMuJERpc3BhdGNoZXJfaXNQZW5kaW5nW2lkXSkge1xuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0hhbmRsZWRbaWRdLFxuICAgICAgICAgICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogQ2lyY3VsYXIgZGVwZW5kZW5jeSBkZXRlY3RlZCB3aGlsZSAnICtcbiAgICAgICAgICAnd2FpdGluZyBmb3IgYCVzYC4nLFxuICAgICAgICAgIGlkXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW52YXJpYW50KFxuICAgICAgICB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrc1tpZF0sXG4gICAgICAgICdEaXNwYXRjaGVyLndhaXRGb3IoLi4uKTogYCVzYCBkb2VzIG5vdCBtYXAgdG8gYSByZWdpc3RlcmVkIGNhbGxiYWNrLicsXG4gICAgICAgIGlkXG4gICAgICApO1xuICAgICAgdGhpcy4kRGlzcGF0Y2hlcl9pbnZva2VDYWxsYmFjayhpZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgcGF5bG9hZCB0byBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXlsb2FkXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaD1mdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZyxcbiAgICAgICdEaXNwYXRjaC5kaXNwYXRjaCguLi4pOiBDYW5ub3QgZGlzcGF0Y2ggaW4gdGhlIG1pZGRsZSBvZiBhIGRpc3BhdGNoLidcbiAgICApO1xuICAgIHRoaXMuJERpc3BhdGNoZXJfc3RhcnREaXNwYXRjaGluZyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy4kRGlzcGF0Y2hlcl9jYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKHRoaXMuJERpc3BhdGNoZXJfaXNQZW5kaW5nW2lkXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJERpc3BhdGNoZXJfaW52b2tlQ2FsbGJhY2soaWQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLiREaXNwYXRjaGVyX3N0b3BEaXNwYXRjaGluZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhpcyBEaXNwYXRjaGVyIGN1cnJlbnRseSBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLmlzRGlzcGF0Y2hpbmc9ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJERpc3BhdGNoZXJfaXNEaXNwYXRjaGluZztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY2FsbGJhY2sgc3RvcmVkIHdpdGggdGhlIGdpdmVuIGlkLiBBbHNvIGRvIHNvbWUgaW50ZXJuYWxcbiAgICogYm9va2tlZXBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLiREaXNwYXRjaGVyX2ludm9rZUNhbGxiYWNrPWZ1bmN0aW9uKGlkKSB7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc1BlbmRpbmdbaWRdID0gdHJ1ZTtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2NhbGxiYWNrc1tpZF0odGhpcy4kRGlzcGF0Y2hlcl9wZW5kaW5nUGF5bG9hZCk7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0hhbmRsZWRbaWRdID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHVwIGJvb2trZWVwaW5nIG5lZWRlZCB3aGVuIGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGF5bG9hZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIERpc3BhdGNoZXIucHJvdG90eXBlLiREaXNwYXRjaGVyX3N0YXJ0RGlzcGF0Y2hpbmc9ZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuJERpc3BhdGNoZXJfY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLiREaXNwYXRjaGVyX2lzUGVuZGluZ1tpZF0gPSBmYWxzZTtcbiAgICAgIHRoaXMuJERpc3BhdGNoZXJfaXNIYW5kbGVkW2lkXSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiREaXNwYXRjaGVyX3BlbmRpbmdQYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLiREaXNwYXRjaGVyX2lzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBib29ra2VlcGluZyB1c2VkIGZvciBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBEaXNwYXRjaGVyLnByb3RvdHlwZS4kRGlzcGF0Y2hlcl9zdG9wRGlzcGF0Y2hpbmc9ZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9wZW5kaW5nUGF5bG9hZCA9IG51bGw7XG4gICAgdGhpcy4kRGlzcGF0Y2hlcl9pc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIH07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAoZmFsc2UpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnSW52YXJpYW50IFZpb2xhdGlvbjogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gVG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIG93bkVudW1lcmFibGVLZXlzKG9iaikge1xuXHR2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG5cblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKTtcblx0fVxuXG5cdHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIHByb3BJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSk7XG5cdH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIga2V5cztcblx0dmFyIHRvID0gVG9PYmplY3QodGFyZ2V0KTtcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBhcmd1bWVudHNbc107XG5cdFx0a2V5cyA9IG93bkVudW1lcmFibGVLZXlzKE9iamVjdChmcm9tKSk7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRvW2tleXNbaV1dID0gZnJvbVtrZXlzW2ldXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJyZWFjdC9hZGRvbnNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIiwgXCJyZWFjdC9hZGRvbnNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiSGlnaGNoYXJ0c1wiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QvYWRkb25zXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJIaWdoY2hhcnRzXCJdID0gZmFjdG9yeShyb290W1wicmVhY3RcIl0sIHJvb3RbXCJyZWFjdC9hZGRvbnNcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7Z2xvYmFsLkhpZ2hjaGFydHNBZGFwdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIEhpZ2hjaGFydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgUmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgdXBkYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5hZGRvbnMudXBkYXRlO1xuXHRtb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblx0ICBkaXNwbGF5TmFtZTogJ0hpZ2hjaGFydHMnLFxuXG5cdCAgcmVuZGVyQ2hhcnQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5wcm9wcy5jb25maWcpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maWcgaGFzIHRvIGJlIHNwZWNpZmllZCwgZm9yIHRoZSBIaWdoY2hhcnQgY29tcG9uZW50Jyk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb25maWcgPSB0aGlzLnByb3BzLmNvbmZpZztcblx0ICAgIHZhciBub2RlID0gdGhpcy5yZWZzLmNoYXJ0LmdldERPTU5vZGUoKTtcblxuXHQgICAgaWYgKCFjb25maWcuY2hhcnQpIHtcblx0ICAgICAgY29uZmlnID0gdXBkYXRlKGNvbmZpZywge2NoYXJ0OiB7JHNldDoge319fSlcblx0ICAgIH1cblxuXHQgICAgY29uZmlnID0gdXBkYXRlKGNvbmZpZywge2NoYXJ0OiB7cmVuZGVyVG86IHskc2V0OiBub2RlfX19KTtcblxuXHQgICAgbmV3IEhpZ2hjaGFydHMuQ2hhcnQoY29uZmlnKTtcblx0ICB9LFxuXG5cdCAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcblx0ICB9LFxuXHQgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5yZW5kZXJDaGFydCgpO1xuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcImNoYXJ0XCIsIHJlZjogXCJjaGFydFwifSlcblx0ICB9XG5cdH0pO1xuXG5cdG1vZHVsZS5leHBvcnRzLkhpZ2hjaGFydHMgPSBIaWdoY2hhcnRzO1xuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fO1xuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXztcblxuLyoqKi8gfSxcbi8qIDQgKi8sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0ICogQGxpY2Vuc2UgQHByb2R1Y3QubmFtZUAgSlMgdkBwcm9kdWN0LnZlcnNpb25AIChAcHJvZHVjdC5kYXRlQClcblx0ICpcblx0ICogU3RhbmRhbG9uZSBIaWdoY2hhcnRzIEZyYW1ld29ya1xuXHQgKlxuXHQgKiBMaWNlbnNlOiBNSVQgTGljZW5zZVxuXHQgKi9cblxuXG5cdC8qZ2xvYmFsIEhpZ2hjaGFydHMgKi9cblx0dmFyIEhpZ2hjaGFydHNBZGFwdGVyID0gKGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgVU5ERUZJTkVELFxuXHRcdGRvYyA9IGRvY3VtZW50LFxuXHRcdGVtcHR5QXJyYXkgPSBbXSxcblx0XHR0aW1lcnMgPSBbXSxcblx0XHR0aW1lcklkLFxuXHRcdGFuaW1TZXR0ZXJzID0ge30sXG5cdFx0Rng7XG5cblx0TWF0aC5lYXNlSW5PdXRTaW5lID0gZnVuY3Rpb24gKHQsIGIsIGMsIGQpIHtcblx0XHRyZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gZCkgLSAxKSArIGI7XG5cdH07XG5cblxuXG5cdC8qKlxuXHQgKiBFeHRlbmQgZ2l2ZW4gb2JqZWN0IHdpdGggY3VzdG9tIGV2ZW50c1xuXHQgKi9cblx0ZnVuY3Rpb24gYXVnbWVudChvYmopIHtcblx0XHRmdW5jdGlvbiByZW1vdmVPbmVFdmVudChlbCwgdHlwZSwgZm4pIHtcblx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBJRVJlbW92ZU9uZUV2ZW50KGVsLCB0eXBlLCBmbikge1xuXHRcdFx0Zm4gPSBlbC5IQ1Byb3hpZWRNZXRob2RzW2ZuLnRvU3RyaW5nKCldO1xuXHRcdFx0ZWwuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVBbGxFdmVudHMoZWwsIHR5cGUpIHtcblx0XHRcdHZhciBldmVudHMgPSBlbC5IQ0V2ZW50cyxcblx0XHRcdFx0cmVtb3ZlLFxuXHRcdFx0XHR0eXBlcyxcblx0XHRcdFx0bGVuLFxuXHRcdFx0XHRuO1xuXG5cdFx0XHRpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0XHRyZW1vdmUgPSByZW1vdmVPbmVFdmVudDtcblx0XHRcdH0gZWxzZSBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcblx0XHRcdFx0cmVtb3ZlID0gSUVSZW1vdmVPbmVFdmVudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjsgLy8gYnJlYWsgb24gbm9uLURPTSBldmVudHNcblx0XHRcdH1cblxuXG5cdFx0XHRpZiAodHlwZSkge1xuXHRcdFx0XHR0eXBlcyA9IHt9O1xuXHRcdFx0XHR0eXBlc1t0eXBlXSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlcyA9IGV2ZW50cztcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChuIGluIHR5cGVzKSB7XG5cdFx0XHRcdGlmIChldmVudHNbbl0pIHtcblx0XHRcdFx0XHRsZW4gPSBldmVudHNbbl0ubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChsZW4tLSkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlKGVsLCBuLCBldmVudHNbbl1bbGVuXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFvYmouSENFeHRlbmRlZCkge1xuXHRcdFx0SGlnaGNoYXJ0cy5leHRlbmQob2JqLCB7XG5cdFx0XHRcdEhDRXh0ZW5kZWQ6IHRydWUsXG5cblx0XHRcdFx0SENFdmVudHM6IHt9LFxuXG5cdFx0XHRcdGJpbmQ6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuXHRcdFx0XHRcdHZhciBlbCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRldmVudHMgPSB0aGlzLkhDRXZlbnRzLFxuXHRcdFx0XHRcdFx0d3JhcHBlZEZuO1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIERPTSBldmVudHMgaW4gbW9kZXJuIGJyb3dzZXJzXG5cdFx0XHRcdFx0aWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZm4sIGZhbHNlKTtcblxuXHRcdFx0XHRcdC8vIGhhbmRsZSBvbGQgSUUgaW1wbGVtZW50YXRpb25cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdGUudGFyZ2V0ID0gZS5zcmNFbGVtZW50IHx8IHdpbmRvdzsgLy8gIzI4MjBcblx0XHRcdFx0XHRcdFx0Zm4uY2FsbChlbCwgZSk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRpZiAoIWVsLkhDUHJveGllZE1ldGhvZHMpIHtcblx0XHRcdFx0XHRcdFx0ZWwuSENQcm94aWVkTWV0aG9kcyA9IHt9O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBsaW5rIHdyYXBwZWQgZm4gd2l0aCBvcmlnaW5hbCBmbiwgc28gd2UgY2FuIGdldCB0aGlzIGluIHJlbW92ZUV2ZW50XG5cdFx0XHRcdFx0XHRlbC5IQ1Byb3hpZWRNZXRob2RzW2ZuLnRvU3RyaW5nKCldID0gd3JhcHBlZEZuO1xuXG5cdFx0XHRcdFx0XHRlbC5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgd3JhcHBlZEZuKTtcblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGlmIChldmVudHNbbmFtZV0gPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0ZXZlbnRzW25hbWVdID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZXZlbnRzW25hbWVdLnB1c2goZm4pO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVuYmluZDogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG5cdFx0XHRcdFx0dmFyIGV2ZW50cyxcblx0XHRcdFx0XHRcdGluZGV4O1xuXG5cdFx0XHRcdFx0aWYgKG5hbWUpIHtcblx0XHRcdFx0XHRcdGV2ZW50cyA9IHRoaXMuSENFdmVudHNbbmFtZV0gfHwgW107XG5cdFx0XHRcdFx0XHRpZiAoZm4pIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBIaWdoY2hhcnRzQWRhcHRlci5pbkFycmF5KGZuLCBldmVudHMpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5kZXggPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuSENFdmVudHNbbmFtZV0gPSBldmVudHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0XHRcdFx0XHRcdHJlbW92ZU9uZUV2ZW50KHRoaXMsIG5hbWUsIGZuKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0SUVSZW1vdmVPbmVFdmVudCh0aGlzLCBuYW1lLCBmbik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZUFsbEV2ZW50cyh0aGlzLCBuYW1lKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5IQ0V2ZW50c1tuYW1lXSA9IFtdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVBbGxFdmVudHModGhpcyk7XG5cdFx0XHRcdFx0XHR0aGlzLkhDRXZlbnRzID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG5cdFx0XHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuSENFdmVudHNbbmFtZV0gfHwgW10sXG5cdFx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0bGVuID0gZXZlbnRzLmxlbmd0aCxcblx0XHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdCxcblx0XHRcdFx0XHRcdGZuO1xuXG5cdFx0XHRcdFx0Ly8gQXR0YWNoIGEgc2ltcGxlIHByZXZlbnREZWZhdWx0IGZ1bmN0aW9uIHRvIHNraXAgZGVmYXVsdCBoYW5kbGVyIGlmIGNhbGxlZFxuXHRcdFx0XHRcdHByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0YXJncy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0Zm4gPSBldmVudHNbaV07XG5cblx0XHRcdFx0XHRcdC8vIGFyZ3MgaXMgbmV2ZXIgbnVsbCBoZXJlXG5cdFx0XHRcdFx0XHRpZiAoYXJncy5zdG9wcGVkKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YXJncy5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuXHRcdFx0XHRcdFx0YXJncy50YXJnZXQgPSB0YXJnZXQ7XG5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSB0eXBlIGlzIG5vdCBzZXQsIHdlJ3JlIHJ1bm5pbmcgYSBjdXN0b20gZXZlbnQgKCMyMjk3KS4gSWYgaXQgaXMgc2V0LFxuXHRcdFx0XHRcdFx0Ly8gd2UncmUgcnVubmluZyBhIGJyb3dzZXIgZXZlbnQsIGFuZCBzZXR0aW5nIGl0IHdpbGwgY2F1c2UgZW4gZXJyb3IgaW5cblx0XHRcdFx0XHRcdC8vIElFOCAoIzI0NjUpLlxuXHRcdFx0XHRcdFx0aWYgKCFhcmdzLnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0YXJncy50eXBlID0gbmFtZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBldmVudCBoYW5kbGVyIHJldHVybiBmYWxzZSwgcHJldmVudCB0aGUgZGVmYXVsdCBoYW5kbGVyIGZyb20gZXhlY3V0aW5nXG5cdFx0XHRcdFx0XHRpZiAoZm4uY2FsbCh0aGlzLCBhcmdzKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0YXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cblx0cmV0dXJuIHtcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIGFkYXB0ZXIuIFRoaXMgaXMgcnVuIG9uY2UgYXMgSGlnaGNoYXJ0cyBpcyBmaXJzdCBydW4uXG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKHBhdGhBbmltKSB7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ29tcGF0aWJpbGl0eSBzZWN0aW9uIHRvIGFkZCBzdXBwb3J0IGZvciBsZWdhY3kgSUUuIFRoaXMgY2FuIGJlIHJlbW92ZWQgaWYgb2xkIElFIFxuXHRcdFx0ICogc3VwcG9ydCBpcyBub3QgbmVlZGVkLlxuXHRcdFx0ICovXG5cdFx0XHRpZiAoIWRvYy5kZWZhdWx0Vmlldykge1xuXHRcdFx0XHR0aGlzLl9nZXRTdHlsZSA9IGZ1bmN0aW9uIChlbCwgcHJvcCkge1xuXHRcdFx0XHRcdHZhciB2YWw7XG5cdFx0XHRcdFx0aWYgKGVsLnN0eWxlW3Byb3BdKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWwuc3R5bGVbcHJvcF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChwcm9wID09PSAnb3BhY2l0eScpIHtcblx0XHRcdFx0XHRcdFx0cHJvcCA9ICdmaWx0ZXInO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogdHJ1ZSovXG5cdFx0XHRcdFx0XHR2YWwgPSBlbC5jdXJyZW50U3R5bGVbcHJvcC5yZXBsYWNlKC9cXC0oXFx3KS9nLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi50b1VwcGVyQ2FzZSgpOyB9KV07XG5cdFx0XHRcdFx0XHRpZiAocHJvcCA9PT0gJ2ZpbHRlcicpIHtcblx0XHRcdFx0XHRcdFx0dmFsID0gdmFsLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdFx0L2FscGhhXFwob3BhY2l0eT0oWzAtOV0rKVxcKS8sIFxuXHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uIChhLCBiKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGIgLyAxMDA7IFxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8qanNsaW50IHVucGFyYW06IGZhbHNlKi9cblx0XHRcdFx0XHRcdHJldHVybiB2YWwgPT09ICcnID8gMSA6IHZhbDtcblx0XHRcdFx0XHR9IFxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmFkYXB0ZXJSdW4gPSBmdW5jdGlvbiAoZWxlbSwgbWV0aG9kKSB7XG5cdFx0XHRcdFx0dmFyIGFsaWFzID0geyB3aWR0aDogJ2NsaWVudFdpZHRoJywgaGVpZ2h0OiAnY2xpZW50SGVpZ2h0JyB9W21ldGhvZF07XG5cblx0XHRcdFx0XHRpZiAoYWxpYXMpIHtcblx0XHRcdFx0XHRcdGVsZW0uc3R5bGUuem9vbSA9IDE7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbVthbGlhc10gLSAyICogcGFyc2VJbnQoSGlnaGNoYXJ0c0FkYXB0ZXIuX2dldFN0eWxlKGVsZW0sICdwYWRkaW5nJyksIDEwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcblx0XHRcdFx0dGhpcy5lYWNoID0gZnVuY3Rpb24gKGFyciwgZm4pIHsgLy8gbGVnYWN5XG5cdFx0XHRcdFx0dmFyIGkgPSAwLCBcblx0XHRcdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yICg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGZuLmNhbGwoYXJyW2ldLCBhcnJbaV0sIGksIGFycikgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuXHRcdFx0XHR0aGlzLmluQXJyYXkgPSBmdW5jdGlvbiAoaXRlbSwgYXJyKSB7XG5cdFx0XHRcdFx0dmFyIGxlbiwgXG5cdFx0XHRcdFx0XHRpID0gMDtcblxuXHRcdFx0XHRcdGlmIChhcnIpIHtcblx0XHRcdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFycltpXSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0XHRcdFx0dGhpcy5ncmVwID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuXHRcdFx0XHRcdHZhciByZXQgPSBbXSxcblx0XHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKCEhY2FsbGJhY2soZWxlbWVudHNbaV0sIGkpKSB7XG5cdFx0XHRcdFx0XHRcdHJldC5wdXNoKGVsZW1lbnRzW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLy0tLSBFbmQgY29tcGF0aWJpbGl0eSBzZWN0aW9uIC0tLVxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3RhcnQgb2YgYW5pbWF0aW9uIHNwZWNpZmljIGNvZGVcblx0XHRcdCAqL1xuXHRcdFx0RnggPSBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucywgcHJvcCkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdFx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdFx0fTtcblx0XHRcdEZ4LnByb3RvdHlwZSA9IHtcblx0XHRcdFx0XG5cdFx0XHRcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBzdHlsZXMsXG5cdFx0XHRcdFx0XHRwYXRocyA9IHRoaXMucGF0aHMsXG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpcy5lbGVtLFxuXHRcdFx0XHRcdFx0ZWxlbWVsZW0gPSBlbGVtLmVsZW1lbnQ7IC8vIGlmIGRlc3Ryb3llZCwgaXQgaXMgbnVsbFxuXG5cdFx0XHRcdFx0Ly8gQW5pbWF0aW9uIHNldHRlciBkZWZpbmVkIGZyb20gb3V0c2lkZVxuXHRcdFx0XHRcdGlmIChhbmltU2V0dGVyc1t0aGlzLnByb3BdKSB7XG5cdFx0XHRcdFx0XHRhbmltU2V0dGVyc1t0aGlzLnByb3BdKHRoaXMpO1xuXG5cdFx0XHRcdFx0Ly8gQW5pbWF0aW5nIGEgcGF0aCBkZWZpbml0aW9uIG9uIFNWR0VsZW1lbnRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBhdGhzICYmIGVsZW1lbGVtKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmF0dHIoJ2QnLCBwYXRoQW5pbS5zdGVwKHBhdGhzWzBdLCBwYXRoc1sxXSwgdGhpcy5ub3csIHRoaXMudG9EKSk7XG5cblx0XHRcdFx0XHQvLyBPdGhlciBhbmltYXRpb25zIG9uIFNWR0VsZW1lbnRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsZW0uYXR0cikge1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbGVtKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0uYXR0cih0aGlzLnByb3AsIHRoaXMubm93KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEhUTUwgc3R5bGVzXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlcyA9IHt9O1xuXHRcdFx0XHRcdFx0c3R5bGVzW3RoaXMucHJvcF0gPSB0aGlzLm5vdyArIHRoaXMudW5pdDtcblx0XHRcdFx0XHRcdEhpZ2hjaGFydHMuY3NzKGVsZW0sIHN0eWxlcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3RlcCkge1xuXHRcdFx0XHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0Y3VzdG9tOiBmdW5jdGlvbiAoZnJvbSwgdG8sIHVuaXQpIHtcblx0XHRcdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdFx0XHR0ID0gZnVuY3Rpb24gKGdvdG9FbmQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNlbGYuc3RlcChnb3RvRW5kKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRpO1xuXG5cdFx0XHRcdFx0dGhpcy5zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHRcdFx0XHR0aGlzLnN0YXJ0ID0gZnJvbTtcblx0XHRcdFx0XHR0aGlzLmVuZCA9IHRvO1xuXHRcdFx0XHRcdHRoaXMudW5pdCA9IHVuaXQ7XG5cdFx0XHRcdFx0dGhpcy5ub3cgPSB0aGlzLnN0YXJ0O1xuXHRcdFx0XHRcdHRoaXMucG9zID0gdGhpcy5zdGF0ZSA9IDA7XG5cblx0XHRcdFx0XHR0LmVsZW0gPSB0aGlzLmVsZW07XG5cblx0XHRcdFx0XHRpZiAodCgpICYmIHRpbWVycy5wdXNoKHQpID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGlmICghdGltZXJzW2ldKCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIXRpbWVycy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRjbGVhckludGVydmFsKHRpbWVySWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCAxMyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcblx0XHRcdFx0c3RlcDogZnVuY3Rpb24gKGdvdG9FbmQpIHtcblx0XHRcdFx0XHR2YXIgdCA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdFx0cmV0LFxuXHRcdFx0XHRcdFx0ZG9uZSxcblx0XHRcdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpcy5lbGVtLFxuXHRcdFx0XHRcdFx0aTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZWxlbS5zdG9wQW5pbWF0aW9uIHx8IChlbGVtLmF0dHIgJiYgIWVsZW0uZWxlbWVudCkpIHsgLy8gIzI2MTYsIGVsZW1lbnQgaW5jbHVkaW5nIGZsYWcgaXMgZGVzdHJveWVkXG5cdFx0XHRcdFx0XHRyZXQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZ290b0VuZCB8fCB0ID49IG9wdGlvbnMuZHVyYXRpb24gKyB0aGlzLnN0YXJ0VGltZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5ub3cgPSB0aGlzLmVuZDtcblx0XHRcdFx0XHRcdHRoaXMucG9zID0gdGhpcy5zdGF0ZSA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0XHR0aGlzLm9wdGlvbnMuY3VyQW5pbVt0aGlzLnByb3BdID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0ZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRmb3IgKGkgaW4gb3B0aW9ucy5jdXJBbmltKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLmN1ckFuaW1baV0gIT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRkb25lID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGRvbmUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMuY29tcGxldGUpIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlLmNhbGwoZWxlbSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBuID0gdCAtIHRoaXMuc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IG4gLyBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0XHRcdFx0dGhpcy5wb3MgPSBvcHRpb25zLmVhc2luZyhuLCAwLCAxLCBvcHRpb25zLmR1cmF0aW9uKTtcblx0XHRcdFx0XHRcdHRoaXMubm93ID0gdGhpcy5zdGFydCArICgodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHRoaXMucG9zKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRyZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBhZGFwdGVyIGFuaW1hdGUgbWV0aG9kXG5cdFx0XHQgKi9cblx0XHRcdHRoaXMuYW5pbWF0ZSA9IGZ1bmN0aW9uIChlbCwgcHJvcCwgb3B0KSB7XG5cdFx0XHRcdHZhciBzdGFydCxcblx0XHRcdFx0XHR1bml0ID0gJycsXG5cdFx0XHRcdFx0ZW5kLFxuXHRcdFx0XHRcdGZ4LFxuXHRcdFx0XHRcdGFyZ3MsXG5cdFx0XHRcdFx0bmFtZTtcblxuXHRcdFx0XHRlbC5zdG9wQW5pbWF0aW9uID0gZmFsc2U7IC8vIHJlYWR5IGZvciBuZXdcblxuXHRcdFx0XHRpZiAodHlwZW9mIG9wdCAhPT0gJ29iamVjdCcgfHwgb3B0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRvcHQgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogYXJnc1syXSxcblx0XHRcdFx0XHRcdGVhc2luZzogYXJnc1szXSxcblx0XHRcdFx0XHRcdGNvbXBsZXRlOiBhcmdzWzRdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRvcHQuZHVyYXRpb24gPSA0MDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0LmVhc2luZyA9IE1hdGhbb3B0LmVhc2luZ10gfHwgTWF0aC5lYXNlSW5PdXRTaW5lO1xuXHRcdFx0XHRvcHQuY3VyQW5pbSA9IEhpZ2hjaGFydHMuZXh0ZW5kKHt9LCBwcm9wKTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAobmFtZSBpbiBwcm9wKSB7XG5cdFx0XHRcdFx0ZnggPSBuZXcgRngoZWwsIG9wdCwgbmFtZSk7XG5cdFx0XHRcdFx0ZW5kID0gbnVsbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ2QnKSB7XG5cdFx0XHRcdFx0XHRmeC5wYXRocyA9IHBhdGhBbmltLmluaXQoXG5cdFx0XHRcdFx0XHRcdGVsLFxuXHRcdFx0XHRcdFx0XHRlbC5kLFxuXHRcdFx0XHRcdFx0XHRwcm9wLmRcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRmeC50b0QgPSBwcm9wLmQ7XG5cdFx0XHRcdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRcdFx0XHRlbmQgPSAxO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZWwuYXR0cikge1xuXHRcdFx0XHRcdFx0c3RhcnQgPSBlbC5hdHRyKG5hbWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGFydCA9IHBhcnNlRmxvYXQoSGlnaGNoYXJ0c0FkYXB0ZXIuX2dldFN0eWxlKGVsLCBuYW1lKSkgfHwgMDtcblx0XHRcdFx0XHRcdGlmIChuYW1lICE9PSAnb3BhY2l0eScpIHtcblx0XHRcdFx0XHRcdFx0dW5pdCA9ICdweCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRcdGlmICghZW5kKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBwcm9wW25hbWVdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmeC5jdXN0b20oc3RhcnQsIGVuZCwgdW5pdCk7XG5cdFx0XHRcdH1cdFxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW50ZXJuYWwgbWV0aG9kIHRvIHJldHVybiBDU1MgdmFsdWUgZm9yIGdpdmVuIGVsZW1lbnQgYW5kIHByb3BlcnR5XG5cdFx0ICovXG5cdFx0X2dldFN0eWxlOiBmdW5jdGlvbiAoZWwsIHByb3ApIHtcblx0XHRcdHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgdW5kZWZpbmVkKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGQgYW4gYW5pbWF0aW9uIHNldHRlciBmb3IgYSBzcGVjaWZpYyBwcm9wZXJ0eVxuXHRcdCAqL1xuXHRcdGFkZEFuaW1TZXR0ZXI6IGZ1bmN0aW9uIChwcm9wLCBmbikge1xuXHRcdFx0YW5pbVNldHRlcnNbcHJvcF0gPSBmbjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRG93bmxvYWRzIGEgc2NyaXB0IGFuZCBleGVjdXRlcyBhIGNhbGxiYWNrIHdoZW4gZG9uZS5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc2NyaXB0TG9jYXRpb25cblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdCAqL1xuXHRcdGdldFNjcmlwdDogZnVuY3Rpb24gKHNjcmlwdExvY2F0aW9uLCBjYWxsYmFjaykge1xuXHRcdFx0Ly8gV2UgY2Fubm90IGFzc3VtZSB0aGF0IEFzc2V0cyBjbGFzcyBmcm9tIG1vb3Rvb2xzLW1vcmUgaXMgYXZhaWxhYmxlIHNvIGluc3RlYWQgaW5zZXJ0IGEgc2NyaXB0IHRhZyB0byBkb3dubG9hZCBzY3JpcHQuXG5cdFx0XHR2YXIgaGVhZCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuXHRcdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cblx0XHRcdHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG5cdFx0XHRzY3JpcHQuc3JjID0gc2NyaXB0TG9jYXRpb247XG5cdFx0XHRzY3JpcHQub25sb2FkID0gY2FsbGJhY2s7XG5cblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSBpbmRleCBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZiBub3QgZm91bmRcblx0XHQgKi9cblx0XHRpbkFycmF5OiBmdW5jdGlvbiAoaXRlbSwgYXJyKSB7XG5cdFx0XHRyZXR1cm4gYXJyLmluZGV4T2YgPyBhcnIuaW5kZXhPZihpdGVtKSA6IGVtcHR5QXJyYXkuaW5kZXhPZi5jYWxsKGFyciwgaXRlbSk7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogQSBkaXJlY3QgbGluayB0byBhZGFwdGVyIG1ldGhvZHNcblx0XHQgKi9cblx0XHRhZGFwdGVyUnVuOiBmdW5jdGlvbiAoZWxlbSwgbWV0aG9kKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQoSGlnaGNoYXJ0c0FkYXB0ZXIuX2dldFN0eWxlKGVsZW0sIG1ldGhvZCksIDEwKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRmlsdGVyIGFuIGFycmF5XG5cdFx0ICovXG5cdFx0Z3JlcDogZnVuY3Rpb24gKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuXHRcdFx0cmV0dXJuIGVtcHR5QXJyYXkuZmlsdGVyLmNhbGwoZWxlbWVudHMsIGNhbGxiYWNrKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTWFwIGFuIGFycmF5XG5cdFx0ICovXG5cdFx0bWFwOiBmdW5jdGlvbiAoYXJyLCBmbikge1xuXHRcdFx0dmFyIHJlc3VsdHMgPSBbXSwgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7XG5cblx0XHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0c1tpXSA9IGZuLmNhbGwoYXJyW2ldLCBhcnJbaV0sIGksIGFycik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGVsZW1lbnQncyBvZmZzZXQgcG9zaXRpb24sIGNvcnJlY3RlZCBieSBvdmVyZmxvdzphdXRvLiBMb29zZWx5IGJhc2VkIG9uIGpRdWVyeSdzIG9mZnNldCBtZXRob2QuXG5cdFx0ICovXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHRib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiBib3gudG9wICArICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3ApICAtIChkb2NFbGVtLmNsaWVudFRvcCAgfHwgMCksXG5cdFx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgKHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbExlZnQpIC0gKGRvY0VsZW0uY2xpZW50TGVmdCB8fCAwKVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdFx0ICovXG5cdFx0YWRkRXZlbnQ6IGZ1bmN0aW9uIChlbCwgdHlwZSwgZm4pIHtcblx0XHRcdGF1Z21lbnQoZWwpLmJpbmQodHlwZSwgZm4pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgZXZlbnQgYWRkZWQgd2l0aCBhZGRFdmVudFxuXHRcdCAqL1xuXHRcdHJlbW92ZUV2ZW50OiBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuKSB7XG5cdFx0XHRhdWdtZW50KGVsKS51bmJpbmQodHlwZSwgZm4pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGaXJlIGFuIGV2ZW50IG9uIGEgY3VzdG9tIG9iamVjdFxuXHRcdCAqL1xuXHRcdGZpcmVFdmVudDogZnVuY3Rpb24gKGVsLCB0eXBlLCBldmVudEFyZ3VtZW50cywgZGVmYXVsdEZ1bmN0aW9uKSB7XG5cdFx0XHR2YXIgZTtcblxuXHRcdFx0aWYgKGRvYy5jcmVhdGVFdmVudCAmJiAoZWwuZGlzcGF0Y2hFdmVudCB8fCBlbC5maXJlRXZlbnQpKSB7XG5cdFx0XHRcdGUgPSBkb2MuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuXHRcdFx0XHRlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0ZS50YXJnZXQgPSBlbDtcblxuXHRcdFx0XHRIaWdoY2hhcnRzLmV4dGVuZChlLCBldmVudEFyZ3VtZW50cyk7XG5cblx0XHRcdFx0aWYgKGVsLmRpc3BhdGNoRXZlbnQpIHtcblx0XHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsLmZpcmVFdmVudCh0eXBlLCBlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKGVsLkhDRXh0ZW5kZWQgPT09IHRydWUpIHtcblx0XHRcdFx0ZXZlbnRBcmd1bWVudHMgPSBldmVudEFyZ3VtZW50cyB8fCB7fTtcblx0XHRcdFx0ZWwudHJpZ2dlcih0eXBlLCBldmVudEFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudEFyZ3VtZW50cyAmJiBldmVudEFyZ3VtZW50cy5kZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdGRlZmF1bHRGdW5jdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkZWZhdWx0RnVuY3Rpb24pIHtcblx0XHRcdFx0ZGVmYXVsdEZ1bmN0aW9uKGV2ZW50QXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0d2FzaE1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRyZXR1cm4gZTtcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBTdG9wIHJ1bm5pbmcgYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0c3RvcDogZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRlbC5zdG9wQW5pbWF0aW9uID0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXRpbGl0eSBmb3IgaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkuIFBhcmFtZXRlcnMgYXJlIHJldmVyc2VkIGNvbXBhcmVkIHRvIGpRdWVyeS5cblx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHRcdCAqL1xuXHRcdGVhY2g6IGZ1bmN0aW9uIChhcnIsIGZuKSB7IC8vIG1vZGVybiBicm93c2Vyc1xuXHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJyLCBmbik7XG5cdFx0fVxuXHR9O1xuXHR9KCkpO1xuXG5cblx0LyoqKiBFWFBPUlRTIEZST00gZXhwb3J0cy1sb2FkZXIgKioqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IEhpZ2hjaGFydHNBZGFwdGVyXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyA9PUNsb3N1cmVDb21waWxlcj09XG5cdC8vIEBjb21waWxhdGlvbl9sZXZlbCBTSU1QTEVfT1BUSU1JWkFUSU9OU1xuXG5cdC8qKlxuXHQgKiBAbGljZW5zZSBIaWdoY2hhcnRzIEpTIHY0LjEuNC1tb2RpZmllZCAoKVxuXHQgKlxuXHQgKiAoYykgMjAwOS0yMDE0IFRvcnN0ZWluIEhvbnNpXG5cdCAqXG5cdCAqIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG5cdCAqL1xuXG5cdC8vIEpTTGludCBvcHRpb25zOlxuXHQvKmdsb2JhbCBIaWdoY2hhcnRzLCBIaWdoY2hhcnRzQWRhcHRlciwgZG9jdW1lbnQsIHdpbmRvdywgbmF2aWdhdG9yLCBzZXRJbnRlcnZhbCwgY2xlYXJJbnRlcnZhbCwgY2xlYXJUaW1lb3V0LCBzZXRUaW1lb3V0LCBsb2NhdGlvbiwgalF1ZXJ5LCAkLCBjb25zb2xlLCBlYWNoLCBncmVwICovXG5cdC8qanNsaW50IGFzczogdHJ1ZSwgc2xvcHB5OiB0cnVlLCBmb3JpbjogdHJ1ZSwgcGx1c3BsdXM6IHRydWUsIG5vbWVuOiB0cnVlLCB2YXJzOiB0cnVlLCByZWdleHA6IHRydWUsIG5ld2NhcDogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSwgY29udGludWU6IHRydWUsIHdoaXRlOiB0cnVlICovXG5cdChmdW5jdGlvbiAoKSB7XG5cdC8vIGVuY2Fwc3VsYXRlZCB2YXJpYWJsZXNcblx0dmFyIFVOREVGSU5FRCxcblx0XHRkb2MgPSBkb2N1bWVudCxcblx0XHR3aW4gPSB3aW5kb3csXG5cdFx0bWF0aCA9IE1hdGgsXG5cdFx0bWF0aFJvdW5kID0gbWF0aC5yb3VuZCxcblx0XHRtYXRoRmxvb3IgPSBtYXRoLmZsb29yLFxuXHRcdG1hdGhDZWlsID0gbWF0aC5jZWlsLFxuXHRcdG1hdGhNYXggPSBtYXRoLm1heCxcblx0XHRtYXRoTWluID0gbWF0aC5taW4sXG5cdFx0bWF0aEFicyA9IG1hdGguYWJzLFxuXHRcdG1hdGhDb3MgPSBtYXRoLmNvcyxcblx0XHRtYXRoU2luID0gbWF0aC5zaW4sXG5cdFx0bWF0aFBJID0gbWF0aC5QSSxcblx0XHRkZWcycmFkID0gbWF0aFBJICogMiAvIDM2MCxcblxuXG5cdFx0Ly8gc29tZSB2YXJpYWJsZXNcblx0XHR1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXHRcdGlzT3BlcmEgPSB3aW4ub3BlcmEsXG5cdFx0aXNJRSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QodXNlckFnZW50KSAmJiAhaXNPcGVyYSxcblx0XHRkb2NNb2RlOCA9IGRvYy5kb2N1bWVudE1vZGUgPT09IDgsXG5cdFx0aXNXZWJLaXQgPSAvQXBwbGVXZWJLaXQvLnRlc3QodXNlckFnZW50KSxcblx0XHRpc0ZpcmVmb3ggPSAvRmlyZWZveC8udGVzdCh1c2VyQWdlbnQpLFxuXHRcdGlzVG91Y2hEZXZpY2UgPSAvKE1vYmlsZXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUpLy50ZXN0KHVzZXJBZ2VudCksXG5cdFx0U1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRoYXNTVkcgPSAhIWRvYy5jcmVhdGVFbGVtZW50TlMgJiYgISFkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgJ3N2ZycpLmNyZWF0ZVNWR1JlY3QsXG5cdFx0aGFzQmlkaUJ1ZyA9IGlzRmlyZWZveCAmJiBwYXJzZUludCh1c2VyQWdlbnQuc3BsaXQoJ0ZpcmVmb3gvJylbMV0sIDEwKSA8IDQsIC8vIGlzc3VlICMzOFxuXHRcdHVzZUNhblZHID0gIWhhc1NWRyAmJiAhaXNJRSAmJiAhIWRvYy5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0LFxuXHRcdFJlbmRlcmVyLFxuXHRcdGhhc1RvdWNoLFxuXHRcdHN5bWJvbFNpemVzID0ge30sXG5cdFx0aWRDb3VudGVyID0gMCxcblx0XHRnYXJiYWdlQmluLFxuXHRcdGRlZmF1bHRPcHRpb25zLFxuXHRcdGRhdGVGb3JtYXQsIC8vIGZ1bmN0aW9uXG5cdFx0Z2xvYmFsQW5pbWF0aW9uLFxuXHRcdHBhdGhBbmltLFxuXHRcdHRpbWVVbml0cyxcblx0XHRub29wID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gVU5ERUZJTkVEOyB9LFxuXHRcdGNoYXJ0cyA9IFtdLFxuXHRcdGNoYXJ0Q291bnQgPSAwLFxuXHRcdFBST0RVQ1QgPSAnSGlnaGNoYXJ0cycsXG5cdFx0VkVSU0lPTiA9ICc0LjEuNC1tb2RpZmllZCcsXG5cblx0XHQvLyBzb21lIGNvbnN0YW50cyBmb3IgZnJlcXVlbnRseSB1c2VkIHN0cmluZ3Ncblx0XHRESVYgPSAnZGl2Jyxcblx0XHRBQlNPTFVURSA9ICdhYnNvbHV0ZScsXG5cdFx0UkVMQVRJVkUgPSAncmVsYXRpdmUnLFxuXHRcdEhJRERFTiA9ICdoaWRkZW4nLFxuXHRcdFBSRUZJWCA9ICdoaWdoY2hhcnRzLScsXG5cdFx0VklTSUJMRSA9ICd2aXNpYmxlJyxcblx0XHRQWCA9ICdweCcsXG5cdFx0Tk9ORSA9ICdub25lJyxcblx0XHRNID0gJ00nLFxuXHRcdEwgPSAnTCcsXG5cdFx0bnVtUmVnZXggPSAvXlswLTldKyQvLFxuXHRcdE5PUk1BTF9TVEFURSA9ICcnLFxuXHRcdEhPVkVSX1NUQVRFID0gJ2hvdmVyJyxcblx0XHRTRUxFQ1RfU1RBVEUgPSAnc2VsZWN0Jyxcblx0XHRtYXJnaW5OYW1lcyA9IFsncGxvdFRvcCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Cb3R0b20nLCAncGxvdExlZnQnXSxcblx0XHRcblx0XHQvLyBPYmplY3QgZm9yIGV4dGVuZGluZyBBeGlzXG5cdFx0QXhpc1Bsb3RMaW5lT3JCYW5kRXh0ZW5zaW9uLFxuXG5cdFx0Ly8gY29uc3RhbnRzIGZvciBhdHRyaWJ1dGVzXG5cdFx0U1RST0tFX1dJRFRIID0gJ3N0cm9rZS13aWR0aCcsXG5cblx0XHQvLyB0aW1lIG1ldGhvZHMsIGNoYW5nZWQgYmFzZWQgb24gd2hldGhlciBvciBub3QgVVRDIGlzIHVzZWRcblx0XHREYXRlLCAgLy8gQWxsb3cgdXNpbmcgYSBkaWZmZXJlbnQgRGF0ZSBjbGFzc1xuXHRcdG1ha2VUaW1lLFxuXHRcdHRpbWV6b25lT2Zmc2V0LFxuXHRcdGdldFRpbWV6b25lT2Zmc2V0LFxuXHRcdGdldE1pbnV0ZXMsXG5cdFx0Z2V0SG91cnMsXG5cdFx0Z2V0RGF5LFxuXHRcdGdldERhdGUsXG5cdFx0Z2V0TW9udGgsXG5cdFx0Z2V0RnVsbFllYXIsXG5cdFx0c2V0TWludXRlcyxcblx0XHRzZXRIb3Vycyxcblx0XHRzZXREYXRlLFxuXHRcdHNldE1vbnRoLFxuXHRcdHNldEZ1bGxZZWFyLFxuXG5cblx0XHQvLyBsb29rdXAgb3ZlciB0aGUgdHlwZXMgYW5kIHRoZSBhc3NvY2lhdGVkIGNsYXNzZXNcblx0XHRzZXJpZXNUeXBlcyA9IHt9LFxuXHRcdEhpZ2hjaGFydHM7XG5cblx0Ly8gVGhlIEhpZ2hjaGFydHMgbmFtZXNwYWNlXG5cdEhpZ2hjaGFydHMgPSB3aW4uSGlnaGNoYXJ0cyA9IHdpbi5IaWdoY2hhcnRzID8gZXJyb3IoMTYsIHRydWUpIDoge307XG5cblx0SGlnaGNoYXJ0cy5zZXJpZXNUeXBlcyA9IHNlcmllc1R5cGVzO1xuXG5cdC8qKlxuXHQgKiBFeHRlbmQgYW4gb2JqZWN0IHdpdGggdGhlIG1lbWJlcnMgb2YgYW5vdGhlclxuXHQgKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBmaXJzdCBvbmVcblx0ICovXG5cdHZhciBleHRlbmQgPSBIaWdoY2hhcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0dmFyIG47XG5cdFx0aWYgKCFhKSB7XG5cdFx0XHRhID0ge307XG5cdFx0fVxuXHRcdGZvciAobiBpbiBiKSB7XG5cdFx0XHRhW25dID0gYltuXTtcblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH07XG5cdFx0XG5cdC8qKlxuXHQgKiBEZWVwIG1lcmdlIHR3byBvciBtb3JlIG9iamVjdHMgYW5kIHJldHVybiBhIHRoaXJkIG9iamVjdC4gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzXG5cdCAqIHRydWUsIHRoZSBjb250ZW50cyBvZiB0aGUgc2Vjb25kIG9iamVjdCBpcyBjb3BpZWQgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuXHQgKiBQcmV2aW91c2x5IHRoaXMgZnVuY3Rpb24gcmVkaXJlY3RlZCB0byBqUXVlcnkuZXh0ZW5kKHRydWUpLCBidXQgdGhpcyBoYWQgdHdvIGxpbWl0YXRpb25zLlxuXHQgKiBGaXJzdCwgaXQgZGVlcCBtZXJnZWQgYXJyYXlzLCB3aGljaCBsZWFkIHRvIHdvcmthcm91bmRzIGluIEhpZ2hjaGFydHMuIFNlY29uZCxcblx0ICogaXQgY29waWVkIHByb3BlcnRpZXMgZnJvbSBleHRlbmRlZCBwcm90b3R5cGVzLiBcblx0ICovXG5cdGZ1bmN0aW9uIG1lcmdlKCkge1xuXHRcdHZhciBpLFxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdGxlbixcblx0XHRcdHJldCA9IHt9LFxuXHRcdFx0ZG9Db3B5ID0gZnVuY3Rpb24gKGNvcHksIG9yaWdpbmFsKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwga2V5O1xuXG5cdFx0XHRcdC8vIEFuIG9iamVjdCBpcyByZXBsYWNpbmcgYSBwcmltaXRpdmVcblx0XHRcdFx0aWYgKHR5cGVvZiBjb3B5ICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGNvcHkgPSB7fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoa2V5IGluIG9yaWdpbmFsKSB7XG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gb3JpZ2luYWxba2V5XTtcblxuXHRcdFx0XHRcdFx0Ly8gQ29weSB0aGUgY29udGVudHMgb2Ygb2JqZWN0cywgYnV0IG5vdCBhcnJheXMgb3IgRE9NIG5vZGVzXG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHRcdFx0XHRcdFx0a2V5ICE9PSAncmVuZGVyVG8nICYmIHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdFx0Y29weVtrZXldID0gZG9Db3B5KGNvcHlba2V5XSB8fCB7fSwgdmFsdWUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gUHJpbWl0aXZlcyBhbmQgYXJyYXlzIGFyZSBjb3BpZWQgb3ZlciBkaXJlY3RseVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29weVtrZXldID0gb3JpZ2luYWxba2V5XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgZmlyc3QgYXJndW1lbnQgaXMgdHJ1ZSwgY29weSBpbnRvIHRoZSBleGlzdGluZyBvYmplY3QuIFVzZWQgaW4gc2V0T3B0aW9ucy5cblx0XHRpZiAoYXJnc1swXSA9PT0gdHJ1ZSkge1xuXHRcdFx0cmV0ID0gYXJnc1sxXTtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAyKTtcblx0XHR9XG5cblx0XHQvLyBGb3IgZWFjaCBhcmd1bWVudCwgZXh0ZW5kIHRoZSByZXR1cm5cblx0XHRsZW4gPSBhcmdzLmxlbmd0aDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHJldCA9IGRvQ29weShyZXQsIGFyZ3NbaV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnRjdXQgZm9yIHBhcnNlSW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYWcgTWFnbml0dWRlXG5cdCAqL1xuXHRmdW5jdGlvbiBwSW50KHMsIG1hZykge1xuXHRcdHJldHVybiBwYXJzZUludChzLCBtYWcgfHwgMTApO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGZvciBzdHJpbmdcblx0ICogQHBhcmFtIHtPYmplY3R9IHNcblx0ICovXG5cdGZ1bmN0aW9uIGlzU3RyaW5nKHMpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGZvciBvYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHQgKi9cblx0ZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG5cdFx0cmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBmb3IgYXJyYXlcblx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHQgKi9cblx0ZnVuY3Rpb24gaXNBcnJheShvYmopIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgZm9yIG51bWJlclxuXHQgKiBAcGFyYW0ge09iamVjdH0gblxuXHQgKi9cblx0ZnVuY3Rpb24gaXNOdW1iZXIobikge1xuXHRcdHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcic7XG5cdH1cblxuXHRmdW5jdGlvbiBsb2cybGluKG51bSkge1xuXHRcdHJldHVybiBtYXRoLmxvZyhudW0pIC8gbWF0aC5MTjEwO1xuXHR9XG5cdGZ1bmN0aW9uIGxpbjJsb2cobnVtKSB7XG5cdFx0cmV0dXJuIG1hdGgucG93KDEwLCBudW0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBsYXN0IG9jY3VyZW5jZSBvZiBhbiBpdGVtIGZyb20gYW4gYXJyYXlcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyXG5cdCAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW1cblx0ICovXG5cdGZ1bmN0aW9uIGVyYXNlKGFyciwgaXRlbSkge1xuXHRcdHZhciBpID0gYXJyLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAoYXJyW2ldID09PSBpdGVtKSB7XG5cdFx0XHRcdGFyci5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvL3JldHVybiBhcnI7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkLiBMaWtlIE1vb1Rvb2xzJyAkLmRlZmluZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICovXG5cdGZ1bmN0aW9uIGRlZmluZWQob2JqKSB7XG5cdFx0cmV0dXJuIG9iaiAhPT0gVU5ERUZJTkVEICYmIG9iaiAhPT0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgb3IgZ2V0IGFuIGF0dHJpYnV0ZSBvciBhbiBvYmplY3Qgb2YgYXR0cmlidXRlcy4gQ2FuJ3QgdXNlIGpRdWVyeSBhdHRyIGJlY2F1c2Vcblx0ICogaXQgYXR0ZW1wdHMgdG8gc2V0IGV4cGFuZG8gcHJvcGVydGllcyBvbiB0aGUgU1ZHIGVsZW1lbnQsIHdoaWNoIGlzIG5vdCBhbGxvd2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZWxlbSBUaGUgRE9NIGVsZW1lbnQgdG8gcmVjZWl2ZSB0aGUgYXR0cmlidXRlKHMpXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcCBUaGUgcHJvcGVydHkgb3IgYW4gYWJqZWN0IG9mIGtleS12YWx1ZSBwYWlyc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIGlmIGEgc2luZ2xlIHByb3BlcnR5IGlzIHNldFxuXHQgKi9cblx0ZnVuY3Rpb24gYXR0cihlbGVtLCBwcm9wLCB2YWx1ZSkge1xuXHRcdHZhciBrZXksXG5cdFx0XHRyZXQ7XG5cblx0XHQvLyBpZiB0aGUgcHJvcCBpcyBhIHN0cmluZ1xuXHRcdGlmIChpc1N0cmluZyhwcm9wKSkge1xuXHRcdFx0Ly8gc2V0IHRoZSB2YWx1ZVxuXHRcdFx0aWYgKGRlZmluZWQodmFsdWUpKSB7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcblxuXHRcdFx0Ly8gZ2V0IHRoZSB2YWx1ZVxuXHRcdFx0fSBlbHNlIGlmIChlbGVtICYmIGVsZW0uZ2V0QXR0cmlidXRlKSB7IC8vIGVsZW0gbm90IGRlZmluZWQgd2hlbiBwcmludGluZyBwaWUgZGVtby4uLlxuXHRcdFx0XHRyZXQgPSBlbGVtLmdldEF0dHJpYnV0ZShwcm9wKTtcblx0XHRcdH1cblxuXHRcdC8vIGVsc2UgaWYgcHJvcCBpcyBkZWZpbmVkLCBpdCBpcyBhIGhhc2ggb2Yga2V5L3ZhbHVlIHBhaXJzXG5cdFx0fSBlbHNlIGlmIChkZWZpbmVkKHByb3ApICYmIGlzT2JqZWN0KHByb3ApKSB7XG5cdFx0XHRmb3IgKGtleSBpbiBwcm9wKSB7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKGtleSwgcHJvcFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXHQvKipcblx0ICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhbiBhcnJheSwgYW5kIGlmIG5vdCwgbWFrZSBpdCBpbnRvIGFuIGFycmF5LiBMaWtlXG5cdCAqIE1vb1Rvb2xzJyAkLnNwbGF0LlxuXHQgKi9cblx0ZnVuY3Rpb24gc3BsYXQob2JqKSB7XG5cdFx0cmV0dXJuIGlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xuXHR9XG5cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB0aGF0IGlzIGRlZmluZWQuIExpa2UgTW9vVG9vbHMnICQucGljay5cblx0ICovXG5cdHZhciBwaWNrID0gSGlnaGNoYXJ0cy5waWNrID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0aSxcblx0XHRcdGFyZyxcblx0XHRcdGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0YXJnID0gYXJnc1tpXTtcblx0XHRcdGlmIChhcmcgIT09IFVOREVGSU5FRCAmJiBhcmcgIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGFyZztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCBDU1Mgb24gYSBnaXZlbiBlbGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIFN0eWxlIG9iamVjdCB3aXRoIGNhbWVsIGNhc2UgcHJvcGVydHkgbmFtZXNcblx0ICovXG5cdGZ1bmN0aW9uIGNzcyhlbCwgc3R5bGVzKSB7XG5cdFx0aWYgKGlzSUUgJiYgIWhhc1NWRykgeyAvLyAjMjY4NlxuXHRcdFx0aWYgKHN0eWxlcyAmJiBzdHlsZXMub3BhY2l0eSAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdHN0eWxlcy5maWx0ZXIgPSAnYWxwaGEob3BhY2l0eT0nICsgKHN0eWxlcy5vcGFjaXR5ICogMTAwKSArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZXh0ZW5kKGVsLnN0eWxlLCBzdHlsZXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGVzIGFuZCBzdHlsZXNcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlic1xuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG5vcGFkXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cmlicywgc3R5bGVzLCBwYXJlbnQsIG5vcGFkKSB7XG5cdFx0dmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcblx0XHRpZiAoYXR0cmlicykge1xuXHRcdFx0ZXh0ZW5kKGVsLCBhdHRyaWJzKTtcblx0XHR9XG5cdFx0aWYgKG5vcGFkKSB7XG5cdFx0XHRjc3MoZWwsIHtwYWRkaW5nOiAwLCBib3JkZXI6IE5PTkUsIG1hcmdpbjogMH0pO1xuXHRcdH1cblx0XHRpZiAoc3R5bGVzKSB7XG5cdFx0XHRjc3MoZWwsIHN0eWxlcyk7XG5cdFx0fVxuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XG5cdFx0fVxuXHRcdHJldHVybiBlbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRlbmQgYSBwcm90b3R5cGVkIGNsYXNzIGJ5IG5ldyBtZW1iZXJzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG1lbWJlcnNcblx0ICovXG5cdGZ1bmN0aW9uIGV4dGVuZENsYXNzKHBhcmVudCwgbWVtYmVycykge1xuXHRcdHZhciBvYmplY3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBVTkRFRklORUQ7IH07XG5cdFx0b2JqZWN0LnByb3RvdHlwZSA9IG5ldyBwYXJlbnQoKTtcblx0XHRleHRlbmQob2JqZWN0LnByb3RvdHlwZSwgbWVtYmVycyk7XG5cdFx0cmV0dXJuIG9iamVjdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYWQgYSBzdHJpbmcgdG8gYSBnaXZlbiBsZW5ndGggYnkgYWRkaW5nIDAgdG8gdGhlIGJlZ2lubmluZ1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcblx0ICovXG5cdGZ1bmN0aW9uIHBhZChudW1iZXIsIGxlbmd0aCkge1xuXHRcdC8vIENyZWF0ZSBhbiBhcnJheSBvZiB0aGUgcmVtYWluaW5nIGxlbmd0aCArMSBhbmQgam9pbiBpdCB3aXRoIDAnc1xuXHRcdHJldHVybiBuZXcgQXJyYXkoKGxlbmd0aCB8fCAyKSArIDEgLSBTdHJpbmcobnVtYmVyKS5sZW5ndGgpLmpvaW4oMCkgKyBudW1iZXI7XG5cdH1cblxuXHQvKipcblx0ICogV3JhcCBhIG1ldGhvZCB3aXRoIGV4dGVuZGVkIGZ1bmN0aW9uYWxpdHksIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIGNvbnRleHQgb2JqZWN0IHRoYXQgdGhlIG1ldGhvZCBiZWxvbmdzIHRvIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gZXh0ZW5kXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgQSB3cmFwcGVyIGZ1bmN0aW9uIGNhbGxiYWNrLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuXHQgKiBhcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24sIGV4Y2VwdCB0aGF0IHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBpcyB1bnNoaWZ0ZWQgYW5kIHBhc3NlZCBhcyB0aGUgZmlyc3QgXG5cdCAqIGFyZ3VtZW50LiBcblx0ICovXG5cdHZhciB3cmFwID0gSGlnaGNoYXJ0cy53cmFwID0gZnVuY3Rpb24gKG9iaiwgbWV0aG9kLCBmdW5jKSB7XG5cdFx0dmFyIHByb2NlZWQgPSBvYmpbbWV0aG9kXTtcblx0XHRvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdGFyZ3MudW5zaGlmdChwcm9jZWVkKTtcblx0XHRcdHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH07XG5cdH07XG5cblxuXHRmdW5jdGlvbiBnZXRUWk9mZnNldCh0aW1lc3RhbXApIHtcblx0XHRyZXR1cm4gKChnZXRUaW1lem9uZU9mZnNldCAmJiBnZXRUaW1lem9uZU9mZnNldCh0aW1lc3RhbXApKSB8fCB0aW1lem9uZU9mZnNldCB8fCAwKSAqIDYwMDAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJhc2VkIG9uIGh0dHA6Ly93d3cucGhwLm5ldC9tYW51YWwvZW4vZnVuY3Rpb24uc3RyZnRpbWUucGhwXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcGl0YWxpemVcblx0ICovXG5cdGRhdGVGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0LCB0aW1lc3RhbXAsIGNhcGl0YWxpemUpIHtcblx0XHRpZiAoIWRlZmluZWQodGltZXN0YW1wKSB8fCBpc05hTih0aW1lc3RhbXApKSB7XG5cdFx0XHRyZXR1cm4gJ0ludmFsaWQgZGF0ZSc7XG5cdFx0fVxuXHRcdGZvcm1hdCA9IHBpY2soZm9ybWF0LCAnJVktJW0tJWQgJUg6JU06JVMnKTtcblxuXHRcdHZhciBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wIC0gZ2V0VFpPZmZzZXQodGltZXN0YW1wKSksXG5cdFx0XHRrZXksIC8vIHVzZWQgaW4gZm9yIGNvbnN0dWN0IGJlbG93XG5cdFx0XHQvLyBnZXQgdGhlIGJhc2ljIHRpbWUgdmFsdWVzXG5cdFx0XHRob3VycyA9IGRhdGVbZ2V0SG91cnNdKCksXG5cdFx0XHRkYXkgPSBkYXRlW2dldERheV0oKSxcblx0XHRcdGRheU9mTW9udGggPSBkYXRlW2dldERhdGVdKCksXG5cdFx0XHRtb250aCA9IGRhdGVbZ2V0TW9udGhdKCksXG5cdFx0XHRmdWxsWWVhciA9IGRhdGVbZ2V0RnVsbFllYXJdKCksXG5cdFx0XHRsYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZyxcblx0XHRcdGxhbmdXZWVrZGF5cyA9IGxhbmcud2Vla2RheXMsXG5cblx0XHRcdC8vIExpc3QgYWxsIGZvcm1hdCBrZXlzLiBDdXN0b20gZm9ybWF0cyBjYW4gYmUgYWRkZWQgZnJvbSB0aGUgb3V0c2lkZS4gXG5cdFx0XHRyZXBsYWNlbWVudHMgPSBleHRlbmQoe1xuXG5cdFx0XHRcdC8vIERheVxuXHRcdFx0XHQnYSc6IGxhbmdXZWVrZGF5c1tkYXldLnN1YnN0cigwLCAzKSwgLy8gU2hvcnQgd2Vla2RheSwgbGlrZSAnTW9uJ1xuXHRcdFx0XHQnQSc6IGxhbmdXZWVrZGF5c1tkYXldLCAvLyBMb25nIHdlZWtkYXksIGxpa2UgJ01vbmRheSdcblx0XHRcdFx0J2QnOiBwYWQoZGF5T2ZNb250aCksIC8vIFR3byBkaWdpdCBkYXkgb2YgdGhlIG1vbnRoLCAwMSB0byAzMVxuXHRcdFx0XHQnZSc6IGRheU9mTW9udGgsIC8vIERheSBvZiB0aGUgbW9udGgsIDEgdGhyb3VnaCAzMVxuXHRcdFx0XHQndyc6IGRheSxcblxuXHRcdFx0XHQvLyBXZWVrIChub25lIGltcGxlbWVudGVkKVxuXHRcdFx0XHQvLydXJzogd2Vla051bWJlcigpLFxuXG5cdFx0XHRcdC8vIE1vbnRoXG5cdFx0XHRcdCdiJzogbGFuZy5zaG9ydE1vbnRoc1ttb250aF0sIC8vIFNob3J0IG1vbnRoLCBsaWtlICdKYW4nXG5cdFx0XHRcdCdCJzogbGFuZy5tb250aHNbbW9udGhdLCAvLyBMb25nIG1vbnRoLCBsaWtlICdKYW51YXJ5J1xuXHRcdFx0XHQnbSc6IHBhZChtb250aCArIDEpLCAvLyBUd28gZGlnaXQgbW9udGggbnVtYmVyLCAwMSB0aHJvdWdoIDEyXG5cblx0XHRcdFx0Ly8gWWVhclxuXHRcdFx0XHQneSc6IGZ1bGxZZWFyLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIpLCAvLyBUd28gZGlnaXRzIHllYXIsIGxpa2UgMDkgZm9yIDIwMDlcblx0XHRcdFx0J1knOiBmdWxsWWVhciwgLy8gRm91ciBkaWdpdHMgeWVhciwgbGlrZSAyMDA5XG5cblx0XHRcdFx0Ly8gVGltZVxuXHRcdFx0XHQnSCc6IHBhZChob3VycyksIC8vIFR3byBkaWdpdHMgaG91cnMgaW4gMjRoIGZvcm1hdCwgMDAgdGhyb3VnaCAyM1xuXHRcdFx0XHQnSSc6IHBhZCgoaG91cnMgJSAxMikgfHwgMTIpLCAvLyBUd28gZGlnaXRzIGhvdXJzIGluIDEyaCBmb3JtYXQsIDAwIHRocm91Z2ggMTFcblx0XHRcdFx0J2wnOiAoaG91cnMgJSAxMikgfHwgMTIsIC8vIEhvdXJzIGluIDEyaCBmb3JtYXQsIDEgdGhyb3VnaCAxMlxuXHRcdFx0XHQnTSc6IHBhZChkYXRlW2dldE1pbnV0ZXNdKCkpLCAvLyBUd28gZGlnaXRzIG1pbnV0ZXMsIDAwIHRocm91Z2ggNTlcblx0XHRcdFx0J3AnOiBob3VycyA8IDEyID8gJ0FNJyA6ICdQTScsIC8vIFVwcGVyIGNhc2UgQU0gb3IgUE1cblx0XHRcdFx0J1AnOiBob3VycyA8IDEyID8gJ2FtJyA6ICdwbScsIC8vIExvd2VyIGNhc2UgQU0gb3IgUE1cblx0XHRcdFx0J1MnOiBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkpLCAvLyBUd28gZGlnaXRzIHNlY29uZHMsIDAwIHRocm91Z2ggIDU5XG5cdFx0XHRcdCdMJzogcGFkKG1hdGhSb3VuZCh0aW1lc3RhbXAgJSAxMDAwKSwgMykgLy8gTWlsbGlzZWNvbmRzIChuYW1pbmcgZnJvbSBSdWJ5KVxuXHRcdFx0fSwgSGlnaGNoYXJ0cy5kYXRlRm9ybWF0cyk7XG5cblxuXHRcdC8vIGRvIHRoZSByZXBsYWNlc1xuXHRcdGZvciAoa2V5IGluIHJlcGxhY2VtZW50cykge1xuXHRcdFx0d2hpbGUgKGZvcm1hdC5pbmRleE9mKCclJyArIGtleSkgIT09IC0xKSB7IC8vIHJlZ2V4IHdvdWxkIGRvIGl0IGluIG9uZSBsaW5lLCBidXQgdGhpcyBpcyBmYXN0ZXJcblx0XHRcdFx0Zm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyUnICsga2V5LCB0eXBlb2YgcmVwbGFjZW1lbnRzW2tleV0gPT09ICdmdW5jdGlvbicgPyByZXBsYWNlbWVudHNba2V5XSh0aW1lc3RhbXApIDogcmVwbGFjZW1lbnRzW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9wdGlvbmFsbHkgY2FwaXRhbGl6ZSB0aGUgc3RyaW5nIGFuZCByZXR1cm5cblx0XHRyZXR1cm4gY2FwaXRhbGl6ZSA/IGZvcm1hdC5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIGZvcm1hdC5zdWJzdHIoMSkgOiBmb3JtYXQ7XG5cdH07XG5cblx0LyoqIFxuXHQgKiBGb3JtYXQgYSBzaW5nbGUgdmFyaWFibGUuIFNpbWlsYXIgdG8gc3ByaW50Ziwgd2l0aG91dCB0aGUgJSBwcmVmaXguXG5cdCAqL1xuXHRmdW5jdGlvbiBmb3JtYXRTaW5nbGUoZm9ybWF0LCB2YWwpIHtcblx0XHR2YXIgZmxvYXRSZWdleCA9IC9mJC8sXG5cdFx0XHRkZWNSZWdleCA9IC9cXC4oWzAtOV0pLyxcblx0XHRcdGxhbmcgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLFxuXHRcdFx0ZGVjaW1hbHM7XG5cblx0XHRpZiAoZmxvYXRSZWdleC50ZXN0KGZvcm1hdCkpIHsgLy8gZmxvYXRcblx0XHRcdGRlY2ltYWxzID0gZm9ybWF0Lm1hdGNoKGRlY1JlZ2V4KTtcblx0XHRcdGRlY2ltYWxzID0gZGVjaW1hbHMgPyBkZWNpbWFsc1sxXSA6IC0xO1xuXHRcdFx0aWYgKHZhbCAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YWwgPSBIaWdoY2hhcnRzLm51bWJlckZvcm1hdChcblx0XHRcdFx0XHR2YWwsXG5cdFx0XHRcdFx0ZGVjaW1hbHMsXG5cdFx0XHRcdFx0bGFuZy5kZWNpbWFsUG9pbnQsXG5cdFx0XHRcdFx0Zm9ybWF0LmluZGV4T2YoJywnKSA+IC0xID8gbGFuZy50aG91c2FuZHNTZXAgOiAnJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWwgPSBkYXRlRm9ybWF0KGZvcm1hdCwgdmFsKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3JtYXQgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgc3Vic2V0IG9mIHRoZSBydWxlcyBvZiBQeXRob24ncyBTdHJpbmcuZm9ybWF0IG1ldGhvZC5cblx0ICovXG5cdGZ1bmN0aW9uIGZvcm1hdChzdHIsIGN0eCkge1xuXHRcdHZhciBzcGxpdHRlciA9ICd7Jyxcblx0XHRcdGlzSW5zaWRlID0gZmFsc2UsXG5cdFx0XHRzZWdtZW50LFxuXHRcdFx0dmFsdWVBbmRGb3JtYXQsXG5cdFx0XHRwYXRoLFxuXHRcdFx0aSxcblx0XHRcdGxlbixcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0dmFsLFxuXHRcdFx0aW5kZXg7XG5cdFx0XG5cdFx0d2hpbGUgKChpbmRleCA9IHN0ci5pbmRleE9mKHNwbGl0dGVyKSkgIT09IC0xKSB7XG5cdFx0XHRcblx0XHRcdHNlZ21lbnQgPSBzdHIuc2xpY2UoMCwgaW5kZXgpO1xuXHRcdFx0aWYgKGlzSW5zaWRlKSB7IC8vIHdlJ3JlIG9uIHRoZSBjbG9zaW5nIGJyYWNrZXQgbG9va2luZyBiYWNrXG5cdFx0XHRcdFxuXHRcdFx0XHR2YWx1ZUFuZEZvcm1hdCA9IHNlZ21lbnQuc3BsaXQoJzonKTtcblx0XHRcdFx0cGF0aCA9IHZhbHVlQW5kRm9ybWF0LnNoaWZ0KCkuc3BsaXQoJy4nKTsgLy8gZ2V0IGZpcnN0IGFuZCBsZWF2ZSBmb3JtYXRcblx0XHRcdFx0bGVuID0gcGF0aC5sZW5ndGg7XG5cdFx0XHRcdHZhbCA9IGN0eDtcblxuXHRcdFx0XHQvLyBBc3NpZ24gZGVlcGVyIHBhdGhzXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdHZhbCA9IHZhbFtwYXRoW2ldXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcm1hdCB0aGUgcmVwbGFjZW1lbnRcblx0XHRcdFx0aWYgKHZhbHVlQW5kRm9ybWF0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhbCA9IGZvcm1hdFNpbmdsZSh2YWx1ZUFuZEZvcm1hdC5qb2luKCc6JyksIHZhbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQdXNoIHRoZSByZXN1bHQgYW5kIGFkdmFuY2UgdGhlIGN1cnNvclxuXHRcdFx0XHRyZXQucHVzaCh2YWwpO1xuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldC5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdHN0ciA9IHN0ci5zbGljZShpbmRleCArIDEpOyAvLyB0aGUgcmVzdFxuXHRcdFx0aXNJbnNpZGUgPSAhaXNJbnNpZGU7IC8vIHRvZ2dsZVxuXHRcdFx0c3BsaXR0ZXIgPSBpc0luc2lkZSA/ICd9JyA6ICd7JzsgLy8gbm93IGxvb2sgZm9yIG5leHQgbWF0Y2hpbmcgYnJhY2tldFxuXHRcdH1cblx0XHRyZXQucHVzaChzdHIpO1xuXHRcdHJldHVybiByZXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBtYWduaXR1ZGUgb2YgYSBudW1iZXJcblx0ICovXG5cdGZ1bmN0aW9uIGdldE1hZ25pdHVkZShudW0pIHtcblx0XHRyZXR1cm4gbWF0aC5wb3coMTAsIG1hdGhGbG9vcihtYXRoLmxvZyhudW0pIC8gbWF0aC5MTjEwKSk7XG5cdH1cblxuXHQvKipcblx0ICogVGFrZSBhbiBpbnRlcnZhbCBhbmQgbm9ybWFsaXplIGl0IHRvIG11bHRpcGxlcyBvZiAxLCAyLCAyLjUgYW5kIDVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG11bHRpcGxlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbWFnbml0dWRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqL1xuXHRmdW5jdGlvbiBub3JtYWxpemVUaWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIG11bHRpcGxlcywgbWFnbml0dWRlLCBhbGxvd0RlY2ltYWxzLCBwcmV2ZW50RXhjZWVkKSB7XG5cdFx0dmFyIG5vcm1hbGl6ZWQsIFxuXHRcdFx0aSxcblx0XHRcdHJldEludGVydmFsID0gaW50ZXJ2YWw7XG5cblx0XHQvLyByb3VuZCB0byBhIHRlbmZvbGQgb2YgMSwgMiwgMi41IG9yIDVcblx0XHRtYWduaXR1ZGUgPSBwaWNrKG1hZ25pdHVkZSwgMSk7XG5cdFx0bm9ybWFsaXplZCA9IGludGVydmFsIC8gbWFnbml0dWRlO1xuXG5cdFx0Ly8gbXVsdGlwbGVzIGZvciBhIGxpbmVhciBzY2FsZVxuXHRcdGlmICghbXVsdGlwbGVzKSB7XG5cdFx0XHRtdWx0aXBsZXMgPSBbMSwgMiwgMi41LCA1LCAxMF07XG5cblx0XHRcdC8vIHRoZSBhbGxvd0RlY2ltYWxzIG9wdGlvblxuXHRcdFx0aWYgKGFsbG93RGVjaW1hbHMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChtYWduaXR1ZGUgPT09IDEpIHtcblx0XHRcdFx0XHRtdWx0aXBsZXMgPSBbMSwgMiwgNSwgMTBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hZ25pdHVkZSA8PSAwLjEpIHtcblx0XHRcdFx0XHRtdWx0aXBsZXMgPSBbMSAvIG1hZ25pdHVkZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBub3JtYWxpemUgdGhlIGludGVydmFsIHRvIHRoZSBuZWFyZXN0IG11bHRpcGxlXG5cdFx0Zm9yIChpID0gMDsgaSA8IG11bHRpcGxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmV0SW50ZXJ2YWwgPSBtdWx0aXBsZXNbaV07XG5cdFx0XHRpZiAoKHByZXZlbnRFeGNlZWQgJiYgcmV0SW50ZXJ2YWwgKiBtYWduaXR1ZGUgPj0gaW50ZXJ2YWwpIHx8IC8vIG9ubHkgYWxsb3cgdGljayBhbW91bnRzIHNtYWxsZXIgdGhhbiBuYXR1cmFsXG5cdFx0XHRcdCghcHJldmVudEV4Y2VlZCAmJiAobm9ybWFsaXplZCA8PSAobXVsdGlwbGVzW2ldICsgKG11bHRpcGxlc1tpICsgMV0gfHwgbXVsdGlwbGVzW2ldKSkgLyAyKSkpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbXVsdGlwbHkgYmFjayB0byB0aGUgY29ycmVjdCBtYWduaXR1ZGVcblx0XHRyZXRJbnRlcnZhbCAqPSBtYWduaXR1ZGU7XG5cdFx0XG5cdFx0cmV0dXJuIHJldEludGVydmFsO1xuXHR9XG5cblxuXHQvKipcblx0ICogVXRpbGl0eSBtZXRob2QgdGhhdCBzb3J0cyBhbiBvYmplY3QgYXJyYXkgYW5kIGtlZXBpbmcgdGhlIG9yZGVyIG9mIGVxdWFsIGl0ZW1zLlxuXHQgKiBFQ01BIHNjcmlwdCBzdGFuZGFyZCBkb2VzIG5vdCBzcGVjaWZ5IHRoZSBiZWhhdmlvdXIgd2hlbiBpdGVtcyBhcmUgZXF1YWwuXG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgc29ydEZ1bmN0aW9uKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsXG5cdFx0XHRzb3J0VmFsdWUsXG5cdFx0XHRpO1xuXG5cdFx0Ly8gQWRkIGluZGV4IHRvIGVhY2ggaXRlbVxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0YXJyW2ldLnNzX2kgPSBpOyAvLyBzdGFibGUgc29ydCBpbmRleFxuXHRcdH1cblxuXHRcdGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRzb3J0VmFsdWUgPSBzb3J0RnVuY3Rpb24oYSwgYik7XG5cdFx0XHRyZXR1cm4gc29ydFZhbHVlID09PSAwID8gYS5zc19pIC0gYi5zc19pIDogc29ydFZhbHVlO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVtb3ZlIGluZGV4IGZyb20gaXRlbXNcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGRlbGV0ZSBhcnJbaV0uc3NfaTsgLy8gc3RhYmxlIHNvcnQgaW5kZXhcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTm9uLXJlY3Vyc2l2ZSBtZXRob2QgdG8gZmluZCB0aGUgbG93ZXN0IG1lbWJlciBvZiBhbiBhcnJheS4gTWF0aC5taW4gcmFpc2VzIGEgbWF4aW11bVxuXHQgKiBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQgZXJyb3IgaW4gQ2hyb21lIHdoZW4gdHJ5aW5nIHRvIGFwcGx5IG1vcmUgdGhhbiAxNTAuMDAwIHBvaW50cy4gVGhpc1xuXHQgKiBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgc2FmZS5cblx0ICovXG5cdGZ1bmN0aW9uIGFycmF5TWluKGRhdGEpIHtcblx0XHR2YXIgaSA9IGRhdGEubGVuZ3RoLFxuXHRcdFx0bWluID0gZGF0YVswXTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChkYXRhW2ldIDwgbWluKSB7XG5cdFx0XHRcdG1pbiA9IGRhdGFbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHQvKipcblx0ICogTm9uLXJlY3Vyc2l2ZSBtZXRob2QgdG8gZmluZCB0aGUgbG93ZXN0IG1lbWJlciBvZiBhbiBhcnJheS4gTWF0aC5taW4gcmFpc2VzIGEgbWF4aW11bVxuXHQgKiBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQgZXJyb3IgaW4gQ2hyb21lIHdoZW4gdHJ5aW5nIHRvIGFwcGx5IG1vcmUgdGhhbiAxNTAuMDAwIHBvaW50cy4gVGhpc1xuXHQgKiBtZXRob2QgaXMgc2xpZ2h0bHkgc2xvd2VyLCBidXQgc2FmZS5cblx0ICovXG5cdGZ1bmN0aW9uIGFycmF5TWF4KGRhdGEpIHtcblx0XHR2YXIgaSA9IGRhdGEubGVuZ3RoLFxuXHRcdFx0bWF4ID0gZGF0YVswXTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChkYXRhW2ldID4gbWF4KSB7XG5cdFx0XHRcdG1heCA9IGRhdGFbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXg7XG5cdH1cblxuXHQvKipcblx0ICogVXRpbGl0eSBtZXRob2QgdGhhdCBkZXN0cm95cyBhbnkgU1ZHRWxlbWVudCBvciBWTUxFbGVtZW50IHRoYXQgYXJlIHByb3BlcnRpZXMgb24gdGhlIGdpdmVuIG9iamVjdC5cblx0ICogSXQgbG9vcHMgYWxsIHByb3BlcnRpZXMgYW5kIGludm9rZXMgZGVzdHJveSBpZiB0aGVyZSBpcyBhIGRlc3Ryb3kgbWV0aG9kLiBUaGUgcHJvcGVydHkgaXNcblx0ICogdGhlbiBkZWxldGUnZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgb2JqZWN0IHRvIGRlc3Ryb3kgcHJvcGVydGllcyBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gRXhjZXB0aW9uLCBkbyBub3QgZGVzdHJveSB0aGlzIHByb3BlcnR5LCBvbmx5IGRlbGV0ZSBpdC5cblx0ICovXG5cdGZ1bmN0aW9uIGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKG9iaiwgZXhjZXB0KSB7XG5cdFx0dmFyIG47XG5cdFx0Zm9yIChuIGluIG9iaikge1xuXHRcdFx0Ly8gSWYgdGhlIG9iamVjdCBpcyBub24tbnVsbCBhbmQgZGVzdHJveSBpcyBkZWZpbmVkXG5cdFx0XHRpZiAob2JqW25dICYmIG9ialtuXSAhPT0gZXhjZXB0ICYmIG9ialtuXS5kZXN0cm95KSB7XG5cdFx0XHRcdC8vIEludm9rZSB0aGUgZGVzdHJveVxuXHRcdFx0XHRvYmpbbl0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZWxldGUgdGhlIHByb3BlcnR5IGZyb20gdGhlIG9iamVjdC5cblx0XHRcdGRlbGV0ZSBvYmpbbl07XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogRGlzY2FyZCBhbiBlbGVtZW50IGJ5IG1vdmluZyBpdCB0byB0aGUgYmluIGFuZCBkZWxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IFRoZSBIVE1MIG5vZGUgdG8gZGlzY2FyZFxuXHQgKi9cblx0ZnVuY3Rpb24gZGlzY2FyZEVsZW1lbnQoZWxlbWVudCkge1xuXHRcdC8vIGNyZWF0ZSBhIGdhcmJhZ2UgYmluIGVsZW1lbnQsIG5vdCBwYXJ0IG9mIHRoZSBET01cblx0XHRpZiAoIWdhcmJhZ2VCaW4pIHtcblx0XHRcdGdhcmJhZ2VCaW4gPSBjcmVhdGVFbGVtZW50KERJVik7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZSB0aGUgbm9kZSBhbmQgZW1wdHkgYmluXG5cdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdGdhcmJhZ2VCaW4uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0fVxuXHRcdGdhcmJhZ2VCaW4uaW5uZXJIVE1MID0gJyc7XG5cdH1cblxuXHQvKipcblx0ICogUHJvdmlkZSBlcnJvciBtZXNzYWdlcyBmb3IgZGVidWdnaW5nLCB3aXRoIGxpbmtzIHRvIG9ubGluZSBleHBsYW5hdGlvbiBcblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yIChjb2RlLCBzdG9wKSB7XG5cdFx0dmFyIG1zZyA9ICdIaWdoY2hhcnRzIGVycm9yICMnICsgY29kZSArICc6IHd3dy5oaWdoY2hhcnRzLmNvbS9lcnJvcnMvJyArIGNvZGU7XG5cdFx0aWYgKHN0b3ApIHtcblx0XHRcdHRocm93IG1zZztcblx0XHR9XG5cdFx0Ly8gZWxzZSAuLi5cblx0XHRpZiAod2luLmNvbnNvbGUpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEZpeCBKUyByb3VuZCBvZmYgZmxvYXQgZXJyb3JzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1cblx0ICovXG5cdGZ1bmN0aW9uIGNvcnJlY3RGbG9hdChudW0pIHtcblx0XHRyZXR1cm4gcGFyc2VGbG9hdChcblx0XHRcdG51bS50b1ByZWNpc2lvbigxNClcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZ2xvYmFsIGFuaW1hdGlvbiB0byBlaXRoZXIgYSBnaXZlbiB2YWx1ZSwgb3IgZmFsbCBiYWNrIHRvIHRoZVxuXHQgKiBnaXZlbiBjaGFydCdzIGFuaW1hdGlvbiBvcHRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGFuaW1hdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcblx0ICovXG5cdGZ1bmN0aW9uIHNldEFuaW1hdGlvbihhbmltYXRpb24sIGNoYXJ0KSB7XG5cdFx0Z2xvYmFsQW5pbWF0aW9uID0gcGljayhhbmltYXRpb24sIGNoYXJ0LmFuaW1hdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHRpbWUgdW5pdCBsb29rdXBcblx0ICovXG5cdHRpbWVVbml0cyA9IHtcblx0XHRtaWxsaXNlY29uZDogMSxcblx0XHRzZWNvbmQ6IDEwMDAsXG5cdFx0bWludXRlOiA2MDAwMCxcblx0XHRob3VyOiAzNjAwMDAwLFxuXHRcdGRheTogMjQgKiAzNjAwMDAwLFxuXHRcdHdlZWs6IDcgKiAyNCAqIDM2MDAwMDAsXG5cdFx0bW9udGg6IDI4ICogMjQgKiAzNjAwMDAwLFxuXHRcdHllYXI6IDM2NCAqIDI0ICogMzYwMDAwMFxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEZvcm1hdCBhIG51bWJlciBhbmQgcmV0dXJuIGEgc3RyaW5nIGJhc2VkIG9uIGlucHV0IHNldHRpbmdzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgVGhlIGlucHV0IG51bWJlciB0byBmb3JtYXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxzIFRoZSBhbW91bnQgb2YgZGVjaW1hbHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRlY1BvaW50IFRoZSBkZWNpbWFsIHBvaW50LCBkZWZhdWx0cyB0byB0aGUgb25lIGdpdmVuIGluIHRoZSBsYW5nIG9wdGlvbnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRob3VzYW5kc1NlcCBUaGUgdGhvdXNhbmRzIHNlcGFyYXRvciwgZGVmYXVsdHMgdG8gdGhlIG9uZSBnaXZlbiBpbiB0aGUgbGFuZyBvcHRpb25zXG5cdCAqL1xuXHRIaWdoY2hhcnRzLm51bWJlckZvcm1hdCA9IGZ1bmN0aW9uIChudW1iZXIsIGRlY2ltYWxzLCBkZWNQb2ludCwgdGhvdXNhbmRzU2VwKSB7XG5cdFx0dmFyIGxhbmcgPSBkZWZhdWx0T3B0aW9ucy5sYW5nLFxuXHRcdFx0Ly8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQvdGVjaGJsb2cvYXJ0aWNsZS9qYXZhc2NyaXB0X2VxdWl2YWxlbnRfZm9yX3BocHNfbnVtYmVyX2Zvcm1hdC9cblx0XHRcdG4gPSArbnVtYmVyIHx8IDAsXG5cdFx0XHRjID0gZGVjaW1hbHMgPT09IC0xID9cblx0XHRcdFx0bWF0aE1pbigobi50b1N0cmluZygpLnNwbGl0KCcuJylbMV0gfHwgJycpLmxlbmd0aCwgMjApIDogLy8gUHJlc2VydmUgZGVjaW1hbHMuIE5vdCBodWdlIG51bWJlcnMgKCMzNzkzKS5cblx0XHRcdFx0KGlzTmFOKGRlY2ltYWxzID0gbWF0aEFicyhkZWNpbWFscykpID8gMiA6IGRlY2ltYWxzKSxcblx0XHRcdGQgPSBkZWNQb2ludCA9PT0gdW5kZWZpbmVkID8gbGFuZy5kZWNpbWFsUG9pbnQgOiBkZWNQb2ludCxcblx0XHRcdHQgPSB0aG91c2FuZHNTZXAgPT09IHVuZGVmaW5lZCA/IGxhbmcudGhvdXNhbmRzU2VwIDogdGhvdXNhbmRzU2VwLFxuXHRcdFx0cyA9IG4gPCAwID8gXCItXCIgOiBcIlwiLFxuXHRcdFx0aSA9IFN0cmluZyhwSW50KG4gPSBtYXRoQWJzKG4pLnRvRml4ZWQoYykpKSxcblx0XHRcdGogPSBpLmxlbmd0aCA+IDMgPyBpLmxlbmd0aCAlIDMgOiAwO1xuXG5cdFx0cmV0dXJuIChzICsgKGogPyBpLnN1YnN0cigwLCBqKSArIHQgOiBcIlwiKSArIGkuc3Vic3RyKGopLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLCBcIiQxXCIgKyB0KSArXG5cdFx0XHRcdChjID8gZCArIG1hdGhBYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiBcIlwiKSk7XG5cdH07XG5cdC8qKlxuXHQgKiBQYXRoIGludGVycG9sYXRpb24gYWxnb3JpdGhtIHVzZWQgYWNyb3NzIGFkYXB0ZXJzXG5cdCAqL1xuXHRwYXRoQW5pbSA9IHtcblx0XHQvKipcblx0XHQgKiBQcmVwYXJlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIHNvIHRoYXQgdGhlIHBhdGggY2FuIGJlIGFuaW1hdGVkIG9uZSB0byBvbmVcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoZWxlbSwgZnJvbUQsIHRvRCkge1xuXHRcdFx0ZnJvbUQgPSBmcm9tRCB8fCAnJztcblx0XHRcdHZhciBzaGlmdCA9IGVsZW0uc2hpZnQsXG5cdFx0XHRcdGJlemllciA9IGZyb21ELmluZGV4T2YoJ0MnKSA+IC0xLFxuXHRcdFx0XHRudW1QYXJhbXMgPSBiZXppZXIgPyA3IDogMyxcblx0XHRcdFx0ZW5kTGVuZ3RoLFxuXHRcdFx0XHRzbGljZSxcblx0XHRcdFx0aSxcblx0XHRcdFx0c3RhcnQgPSBmcm9tRC5zcGxpdCgnICcpLFxuXHRcdFx0XHRlbmQgPSBbXS5jb25jYXQodG9EKSwgLy8gY29weVxuXHRcdFx0XHRzdGFydEJhc2VMaW5lLFxuXHRcdFx0XHRlbmRCYXNlTGluZSxcblx0XHRcdFx0c2l4aWZ5ID0gZnVuY3Rpb24gKGFycikgeyAvLyBpbiBzcGxpbmVzIG1ha2UgbW92ZSBwb2ludHMgaGF2ZSBzaXggcGFyYW1ldGVycyBsaWtlIGJlemllciBjdXJ2ZXNcblx0XHRcdFx0XHRpID0gYXJyLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0XHRpZiAoYXJyW2ldID09PSBNKSB7XG5cdFx0XHRcdFx0XHRcdGFyci5zcGxpY2UoaSArIDEsIDAsIGFycltpICsgMV0sIGFycltpICsgMl0sIGFycltpICsgMV0sIGFycltpICsgMl0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0aWYgKGJlemllcikge1xuXHRcdFx0XHRzaXhpZnkoc3RhcnQpO1xuXHRcdFx0XHRzaXhpZnkoZW5kKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHVsbCBvdXQgdGhlIGJhc2UgbGluZXMgYmVmb3JlIHBhZGRpbmdcblx0XHRcdGlmIChlbGVtLmlzQXJlYSkge1xuXHRcdFx0XHRzdGFydEJhc2VMaW5lID0gc3RhcnQuc3BsaWNlKHN0YXJ0Lmxlbmd0aCAtIDYsIDYpO1xuXHRcdFx0XHRlbmRCYXNlTGluZSA9IGVuZC5zcGxpY2UoZW5kLmxlbmd0aCAtIDYsIDYpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiBzaGlmdGluZyBwb2ludHMsIHByZXBlbmQgYSBkdW1teSBwb2ludCB0byB0aGUgZW5kIHBhdGhcblx0XHRcdGlmIChzaGlmdCA8PSBlbmQubGVuZ3RoIC8gbnVtUGFyYW1zICYmIHN0YXJ0Lmxlbmd0aCA9PT0gZW5kLmxlbmd0aCkge1xuXHRcdFx0XHR3aGlsZSAoc2hpZnQtLSkge1xuXHRcdFx0XHRcdGVuZCA9IFtdLmNvbmNhdChlbmQpLnNwbGljZSgwLCBudW1QYXJhbXMpLmNvbmNhdChlbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbGVtLnNoaWZ0ID0gMDsgLy8gcmVzZXQgZm9yIGZvbGxvd2luZyBhbmltYXRpb25zXG5cblx0XHRcdC8vIGNvcHkgYW5kIGFwcGVuZCBsYXN0IHBvaW50IHVudGlsIHRoZSBsZW5ndGggbWF0Y2hlcyB0aGUgZW5kIGxlbmd0aFxuXHRcdFx0aWYgKHN0YXJ0Lmxlbmd0aCkge1xuXHRcdFx0XHRlbmRMZW5ndGggPSBlbmQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoc3RhcnQubGVuZ3RoIDwgZW5kTGVuZ3RoKSB7XG5cblx0XHRcdFx0XHQvL2JlemllciAmJiBzaXhpZnkoc3RhcnQpO1xuXHRcdFx0XHRcdHNsaWNlID0gW10uY29uY2F0KHN0YXJ0KS5zcGxpY2Uoc3RhcnQubGVuZ3RoIC0gbnVtUGFyYW1zLCBudW1QYXJhbXMpO1xuXHRcdFx0XHRcdGlmIChiZXppZXIpIHsgLy8gZGlzYWJsZSBmaXJzdCBjb250cm9sIHBvaW50XG5cdFx0XHRcdFx0XHRzbGljZVtudW1QYXJhbXMgLSA2XSA9IHNsaWNlW251bVBhcmFtcyAtIDJdO1xuXHRcdFx0XHRcdFx0c2xpY2VbbnVtUGFyYW1zIC0gNV0gPSBzbGljZVtudW1QYXJhbXMgLSAxXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RhcnQgPSBzdGFydC5jb25jYXQoc2xpY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdGFydEJhc2VMaW5lKSB7IC8vIGFwcGVuZCB0aGUgYmFzZSBsaW5lcyBmb3IgYXJlYXNcblx0XHRcdFx0c3RhcnQgPSBzdGFydC5jb25jYXQoc3RhcnRCYXNlTGluZSk7XG5cdFx0XHRcdGVuZCA9IGVuZC5jb25jYXQoZW5kQmFzZUxpbmUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtzdGFydCwgZW5kXTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW50ZXJwb2xhdGUgZWFjaCB2YWx1ZSBvZiB0aGUgcGF0aCBhbmQgcmV0dXJuIHRoZSBhcnJheVxuXHRcdCAqL1xuXHRcdHN0ZXA6IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwb3MsIGNvbXBsZXRlKSB7XG5cdFx0XHR2YXIgcmV0ID0gW10sXG5cdFx0XHRcdGkgPSBzdGFydC5sZW5ndGgsXG5cdFx0XHRcdHN0YXJ0VmFsO1xuXG5cdFx0XHRpZiAocG9zID09PSAxKSB7IC8vIGxhbmQgb24gdGhlIGZpbmFsIHBhdGggd2l0aG91dCBhZGp1c3RtZW50IHBvaW50cyBhcHBlbmRlZCBpbiB0aGUgZW5kc1xuXHRcdFx0XHRyZXQgPSBjb21wbGV0ZTtcblxuXHRcdFx0fSBlbHNlIGlmIChpID09PSBlbmQubGVuZ3RoICYmIHBvcyA8IDEpIHtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHN0YXJ0VmFsID0gcGFyc2VGbG9hdChzdGFydFtpXSk7XG5cdFx0XHRcdFx0cmV0W2ldID1cblx0XHRcdFx0XHRcdGlzTmFOKHN0YXJ0VmFsKSA/IC8vIGEgbGV0dGVyIGluc3RydWN0aW9uIGxpa2UgTSBvciBMXG5cdFx0XHRcdFx0XHRcdHN0YXJ0W2ldIDpcblx0XHRcdFx0XHRcdFx0cG9zICogKHBhcnNlRmxvYXQoZW5kW2ldIC0gc3RhcnRWYWwpKSArIHN0YXJ0VmFsO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7IC8vIGlmIGFuaW1hdGlvbiBpcyBmaW5pc2hlZCBvciBsZW5ndGggbm90IG1hdGNoaW5nLCBsYW5kIG9uIHJpZ2h0IHZhbHVlXG5cdFx0XHRcdHJldCA9IGVuZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xuXG5cdChmdW5jdGlvbiAoJCkge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBkZWZhdWx0IEhpZ2hjaGFydHNBZGFwdGVyIGZvciBqUXVlcnlcblx0XHQgKi9cblx0XHR3aW4uSGlnaGNoYXJ0c0FkYXB0ZXIgPSB3aW4uSGlnaGNoYXJ0c0FkYXB0ZXIgfHwgKCQgJiYge1xuXHRcdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEluaXRpYWxpemUgdGhlIGFkYXB0ZXIgYnkgYXBwbHlpbmcgc29tZSBleHRlbnNpb25zIHRvIGpRdWVyeVxuXHRcdFx0ICovXG5cdFx0XHRpbml0OiBmdW5jdGlvbiAocGF0aEFuaW0pIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGV4dGVuZCB0aGUgYW5pbWF0ZSBmdW5jdGlvbiB0byBhbGxvdyBTVkcgYW5pbWF0aW9uc1xuXHRcdFx0XHR2YXIgRnggPSAkLmZ4O1xuXHRcdFx0XHRcblx0XHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogdHJ1ZSovLyogYWxsb3cgdW51c2VkIHBhcmFtIHggaW4gdGhpcyBmdW5jdGlvbiAqL1xuXHRcdFx0XHQkLmV4dGVuZCgkLmVhc2luZywge1xuXHRcdFx0XHRcdGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiBmYWxzZSovXG5cdFx0XHRcblx0XHRcdFx0Ly8gZXh0ZW5kIHNvbWUgbWV0aG9kcyB0byBjaGVjayBmb3IgZWxlbS5hdHRyLCB3aGljaCBtZWFucyBpdCBpcyBhIEhpZ2hjaGFydHMgU1ZHIG9iamVjdFxuXHRcdFx0XHQkLmVhY2goWydjdXInLCAnX2RlZmF1bHQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ29wYWNpdHknXSwgZnVuY3Rpb24gKGksIGZuKSB7XG5cdFx0XHRcdFx0dmFyIG9iaiA9IEZ4LnN0ZXAsXG5cdFx0XHRcdFx0XHRiYXNlO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGRpZmZlcmVudCBwYXJlbnQgb2JqZWN0c1xuXHRcdFx0XHRcdGlmIChmbiA9PT0gJ2N1cicpIHtcblx0XHRcdFx0XHRcdG9iaiA9IEZ4LnByb3RvdHlwZTsgLy8gJ2N1cicsIHRoZSBnZXR0ZXIsIHJlbGF0ZXMgdG8gRngucHJvdG90eXBlXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChmbiA9PT0gJ19kZWZhdWx0JyAmJiAkLlR3ZWVuKSB7IC8vIGpRdWVyeSAxLjggbW9kZWxcblx0XHRcdFx0XHRcdG9iaiA9ICQuVHdlZW4ucHJvcEhvb2tzW2ZuXTtcblx0XHRcdFx0XHRcdGZuID0gJ3NldCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdFx0Ly8gT3ZlcndyaXRlIHRoZSBtZXRob2Rcblx0XHRcdFx0XHRiYXNlID0gb2JqW2ZuXTtcblx0XHRcdFx0XHRpZiAoYmFzZSkgeyAvLyBzdGVwLndpZHRoIGFuZCBzdGVwLmhlaWdodCBkb24ndCBleGlzdCBpbiBqUXVlcnkgPCAxLjdcblx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gY3JlYXRlIHRoZSBleHRlbmRlZCBmdW5jdGlvbiByZXBsYWNlbWVudFxuXHRcdFx0XHRcdFx0b2JqW2ZuXSA9IGZ1bmN0aW9uIChmeCkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gRngucHJvdG90eXBlLmN1ciBkb2VzIG5vdCB1c2UgZnggYXJndW1lbnRcblx0XHRcdFx0XHRcdFx0ZnggPSBpID8gZnggOiB0aGlzO1xuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJ1biBhbmltYXRpb25zIG9uIHRleHR1YWwgcHJvcGVydGllcyBsaWtlIGFsaWduICgjMTgyMSlcblx0XHRcdFx0XHRcdFx0aWYgKGZ4LnByb3AgPT09ICdhbGlnbicpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBzaG9ydGN1dFxuXHRcdFx0XHRcdFx0XHRlbGVtID0gZnguZWxlbTtcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBGeC5wcm90b3R5cGUuY3VyIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUuIFRoZSBvdGhlciBvbmVzIGFyZSBzZXR0ZXJzXG5cdFx0XHRcdFx0XHRcdC8vIGFuZCByZXR1cm5pbmcgYSB2YWx1ZSBoYXMgbm8gZWZmZWN0LlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5hdHRyID8gLy8gaXMgU1ZHIGVsZW1lbnQgd3JhcHBlclxuXHRcdFx0XHRcdFx0XHRcdGVsZW0uYXR0cihmeC5wcm9wLCBmbiA9PT0gJ2N1cicgPyBVTkRFRklORUQgOiBmeC5ub3cpIDogLy8gYXBwbHkgdGhlIFNWRyB3cmFwcGVyJ3MgbWV0aG9kXG5cdFx0XHRcdFx0XHRcdFx0YmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyB1c2UgalF1ZXJ5J3MgYnVpbHQtaW4gbWV0aG9kXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gRXh0ZW5kIHRoZSBvcGFjaXR5IGdldHRlciwgbmVlZGVkIGZvciBmYWRpbmcgb3BhY2l0eSB3aXRoIElFOSBhbmQgalF1ZXJ5IDEuMTArXG5cdFx0XHRcdHdyYXAoJC5jc3NIb29rcy5vcGFjaXR5LCAnZ2V0JywgZnVuY3Rpb24gKHByb2NlZWQsIGVsZW0sIGNvbXB1dGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uYXR0ciA/IChlbGVtLm9wYWNpdHkgfHwgMCkgOiBwcm9jZWVkLmNhbGwodGhpcywgZWxlbSwgY29tcHV0ZWQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIERlZmluZSB0aGUgc2V0dGVyIGZ1bmN0aW9uIGZvciBkIChwYXRoIGRlZmluaXRpb25zKVxuXHRcdFx0XHR0aGlzLmFkZEFuaW1TZXR0ZXIoJ2QnLCBmdW5jdGlvbiAoZngpIHtcblx0XHRcdFx0XHR2YXIgZWxlbSA9IGZ4LmVsZW0sXG5cdFx0XHRcdFx0XHRlbmRzO1xuXHRcdFx0XG5cdFx0XHRcdFx0Ly8gTm9ybWFsbHkgc3RhcnQgYW5kIGVuZCBzaG91bGQgYmUgc2V0IGluIHN0YXRlID09IDAsIGJ1dCBzb21ldGltZXMsXG5cdFx0XHRcdFx0Ly8gZm9yIHJlYXNvbnMgdW5rbm93biwgdGhpcyBkb2Vzbid0IGhhcHBlbi4gUGVyaGFwcyBzdGF0ZSA9PSAwIGlzIHNraXBwZWRcblx0XHRcdFx0XHQvLyBpbiB0aGVzZSBjYXNlc1xuXHRcdFx0XHRcdGlmICghZnguc3RhcnRlZCkge1xuXHRcdFx0XHRcdFx0ZW5kcyA9IHBhdGhBbmltLmluaXQoZWxlbSwgZWxlbS5kLCBlbGVtLnRvRCk7XG5cdFx0XHRcdFx0XHRmeC5zdGFydCA9IGVuZHNbMF07XG5cdFx0XHRcdFx0XHRmeC5lbmQgPSBlbmRzWzFdO1xuXHRcdFx0XHRcdFx0Znguc3RhcnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdFx0Ly8gSW50ZXJwb2xhdGUgZWFjaCB2YWx1ZSBvZiB0aGUgcGF0aFxuXHRcdFx0XHRcdGVsZW0uYXR0cignZCcsIHBhdGhBbmltLnN0ZXAoZnguc3RhcnQsIGZ4LmVuZCwgZngucG9zLCBlbGVtLnRvRCkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBVdGlsaXR5IGZvciBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheS4gUGFyYW1ldGVycyBhcmUgcmV2ZXJzZWQgY29tcGFyZWQgdG8galF1ZXJ5LlxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBhcnJcblx0XHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMuZWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID9cblx0XHRcdFx0XHRmdW5jdGlvbiAoYXJyLCBmbikgeyAvLyBtb2Rlcm4gYnJvd3NlcnNcblx0XHRcdFx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFyciwgZm4pO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fSA6IFxuXHRcdFx0XHRcdGZ1bmN0aW9uIChhcnIsIGZuKSB7IC8vIGxlZ2FjeVxuXHRcdFx0XHRcdFx0dmFyIGksIFxuXHRcdFx0XHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChmbi5jYWxsKGFycltpXSwgYXJyW2ldLCBpLCBhcnIpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBSZWdpc3RlciBIaWdoY2hhcnRzIGFzIGEgcGx1Z2luIGluIHRoZSByZXNwZWN0aXZlIGZyYW1ld29ya1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0JC5mbi5oaWdoY2hhcnRzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHZhciBjb25zdHIgPSAnQ2hhcnQnLCAvLyBkZWZhdWx0IGNvbnN0cnVjdG9yXG5cdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0XHRcdHJldCxcblx0XHRcdFx0XHRcdGNoYXJ0O1xuXG5cdFx0XHRcdFx0aWYgKHRoaXNbMF0pIHtcblxuXHRcdFx0XHRcdFx0aWYgKGlzU3RyaW5nKGFyZ3NbMF0pKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0ciA9IGFyZ3NbMF07XG5cdFx0XHRcdFx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvcHRpb25zID0gYXJnc1swXTtcblxuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBjaGFydFxuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHQvKmpzbGludCB1bnVzZWQ6ZmFsc2UqL1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zLmNoYXJ0ID0gb3B0aW9ucy5jaGFydCB8fCB7fTtcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5jaGFydC5yZW5kZXJUbyA9IHRoaXNbMF07XG5cdFx0XHRcdFx0XHRcdGNoYXJ0ID0gbmV3IEhpZ2hjaGFydHNbY29uc3RyXShvcHRpb25zLCBhcmdzWzFdKTtcblx0XHRcdFx0XHRcdFx0cmV0ID0gdGhpcztcblx0XHRcdFx0XHRcdFx0Lypqc2xpbnQgdW51c2VkOnRydWUqL1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBXaGVuIGNhbGxlZCB3aXRob3V0IHBhcmFtZXRlcnMgb3Igd2l0aCB0aGUgcmV0dXJuIGFyZ3VtZW50LCBnZXQgYSBwcmVkZWZpbmVkIGNoYXJ0XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucyA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGNoYXJ0c1thdHRyKHRoaXNbMF0sICdkYXRhLWhpZ2hjaGFydHMtY2hhcnQnKV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH07XG5cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkIGFuIGFuaW1hdGlvbiBzZXR0ZXIgZm9yIGEgc3BlY2lmaWMgcHJvcGVydHlcblx0XHRcdCAqL1xuXHRcdFx0YWRkQW5pbVNldHRlcjogZnVuY3Rpb24gKHByb3AsIHNldHRlcikge1xuXHRcdFx0XHQvLyBqUXVlcnkgMS44IHN0eWxlXG5cdFx0XHRcdGlmICgkLlR3ZWVuKSB7XG5cdFx0XHRcdFx0JC5Ud2Vlbi5wcm9wSG9va3NbcHJvcF0gPSB7XG5cdFx0XHRcdFx0XHRzZXQ6IHNldHRlclxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdC8vIHByZSAxLjhcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmZ4LnN0ZXBbcHJvcF0gPSBzZXR0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRG93bmxvYWRzIGEgc2NyaXB0IGFuZCBleGVjdXRlcyBhIGNhbGxiYWNrIHdoZW4gZG9uZS5cblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzY3JpcHRMb2NhdGlvblxuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0XHRcdCAqL1xuXHRcdFx0Z2V0U2NyaXB0OiAkLmdldFNjcmlwdCxcblx0XHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm4gdGhlIGluZGV4IG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIG5vdCBmb3VuZFxuXHRcdFx0ICovXG5cdFx0XHRpbkFycmF5OiAkLmluQXJyYXksXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQSBkaXJlY3QgbGluayB0byBqUXVlcnkgbWV0aG9kcy4gTW9vVG9vbHMgYW5kIFByb3RvdHlwZSBhZGFwdGVycyBtdXN0IGJlIGltcGxlbWVudGVkIGZvciBlYWNoIGNhc2Ugb2YgbWV0aG9kLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsZW0gVGhlIEhUTUwgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBXaGljaCBtZXRob2QgdG8gcnVuIG9uIHRoZSB3cmFwcGVkIGVsZW1lbnRcblx0XHRcdCAqL1xuXHRcdFx0YWRhcHRlclJ1bjogZnVuY3Rpb24gKGVsZW0sIG1ldGhvZCkge1xuXHRcdFx0XHRyZXR1cm4gJChlbGVtKVttZXRob2RdKCk7XG5cdFx0XHR9LFxuXHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaWx0ZXIgYW4gYXJyYXlcblx0XHRcdCAqL1xuXHRcdFx0Z3JlcDogJC5ncmVwLFxuXHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBNYXAgYW4gYXJyYXlcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGFyclxuXHRcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0XHRcdCAqL1xuXHRcdFx0bWFwOiBmdW5jdGlvbiAoYXJyLCBmbikge1xuXHRcdFx0XHQvL3JldHVybiBqUXVlcnkubWFwKGFyciwgZm4pO1xuXHRcdFx0XHR2YXIgcmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRyZXN1bHRzW2ldID0gZm4uY2FsbChhcnJbaV0sIGFycltpXSwgaSwgYXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcblx0XHRcdH0sXG5cdFx0XG5cdFx0XHQvKipcblx0XHRcdCAqIEdldCB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgdG9wIGxlZnQgb2YgdGhlIHBhZ2Vcblx0XHRcdCAqL1xuXHRcdFx0b2Zmc2V0OiBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdFx0cmV0dXJuICQoZWwpLm9mZnNldCgpO1xuXHRcdFx0fSxcblx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWwgQSBIVE1MIGVsZW1lbnQgb3IgY3VzdG9tIG9iamVjdFxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB0eXBlXG5cdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZXZlbnQgaGFuZGxlclxuXHRcdFx0ICovXG5cdFx0XHRhZGRFdmVudDogZnVuY3Rpb24gKGVsLCBldmVudCwgZm4pIHtcblx0XHRcdFx0JChlbCkuYmluZChldmVudCwgZm4pO1xuXHRcdFx0fSxcblx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVtb3ZlIGV2ZW50IGFkZGVkIHdpdGggYWRkRXZlbnRcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbCBUaGUgb2JqZWN0XG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIFRoZSBldmVudCB0eXBlLiBMZWF2ZSBibGFuayB0byByZW1vdmUgYWxsIGV2ZW50cy5cblx0XHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIHJlbW92ZVxuXHRcdFx0ICovXG5cdFx0XHRyZW1vdmVFdmVudDogZnVuY3Rpb24gKGVsLCBldmVudFR5cGUsIGhhbmRsZXIpIHtcblx0XHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgalF1ZXJ5IGlzc3VlIHdpdGggdW5iaW5kaW5nIGN1c3RvbSBldmVudHM6XG5cdFx0XHRcdC8vIGh0dHA6Ly9mb3J1bS5qUXVlcnkuY29tL3RvcGljL2phdmFzY3JpcHQtZXJyb3Itd2hlbi11bmJpbmRpbmctYS1jdXN0b20tZXZlbnQtdXNpbmctalF1ZXJ5LTEtNC0yXG5cdFx0XHRcdHZhciBmdW5jID0gZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnZGV0YWNoRXZlbnQnO1xuXHRcdFx0XHRpZiAoZG9jW2Z1bmNdICYmIGVsICYmICFlbFtmdW5jXSkge1xuXHRcdFx0XHRcdGVsW2Z1bmNdID0gZnVuY3Rpb24gKCkge307XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0JChlbCkudW5iaW5kKGV2ZW50VHlwZSwgaGFuZGxlcik7XG5cdFx0XHR9LFxuXHRcdFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBGaXJlIGFuIGV2ZW50IG9uIGEgY3VzdG9tIG9iamVjdFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGVsXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50QXJndW1lbnRzXG5cdFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWZhdWx0RnVuY3Rpb25cblx0XHRcdCAqL1xuXHRcdFx0ZmlyZUV2ZW50OiBmdW5jdGlvbiAoZWwsIHR5cGUsIGV2ZW50QXJndW1lbnRzLCBkZWZhdWx0RnVuY3Rpb24pIHtcblx0XHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCh0eXBlKSxcblx0XHRcdFx0XHRkZXRhY2hlZFR5cGUgPSAnZGV0YWNoZWQnICsgdHlwZSxcblx0XHRcdFx0XHRkZWZhdWx0UHJldmVudGVkO1xuXHRcdFxuXHRcdFx0XHQvLyBSZW1vdmUgd2FybmluZ3MgaW4gQ2hyb21lIHdoZW4gYWNjZXNzaW5nIHJldHVyblZhbHVlICgjMjc5MCksIGxheWVyWCBhbmQgbGF5ZXJZLiBBbHRob3VnaCBIaWdoY2hhcnRzXG5cdFx0XHRcdC8vIG5ldmVyIHVzZXMgdGhlc2UgcHJvcGVydGllcywgQ2hyb21lIGluY2x1ZGVzIHRoZW0gaW4gdGhlIGRlZmF1bHQgY2xpY2sgZXZlbnQgYW5kXG5cdFx0XHRcdC8vIHJhaXNlcyB0aGUgd2FybmluZyB3aGVuIHRoZXkgYXJlIGNvcGllZCBvdmVyIGluIHRoZSBleHRlbmQgc3RhdGVtZW50IGJlbG93LlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBUbyBhdm9pZCBwcm9ibGVtcyBpbiBJRSAoc2VlICMxMDEwKSB3aGVyZSB3ZSBjYW5ub3QgZGVsZXRlIHRoZSBwcm9wZXJ0aWVzIGFuZCBhdm9pZFxuXHRcdFx0XHQvLyB0ZXN0aW5nIGlmIHRoZXkgYXJlIHRoZXJlICh3YXJuaW5nIGluIGNocm9tZSkgdGhlIG9ubHkgb3B0aW9uIGlzIHRvIHRlc3QgaWYgcnVubmluZyBJRS5cblx0XHRcdFx0aWYgKCFpc0lFICYmIGV2ZW50QXJndW1lbnRzKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGV2ZW50QXJndW1lbnRzLmxheWVyWDtcblx0XHRcdFx0XHRkZWxldGUgZXZlbnRBcmd1bWVudHMubGF5ZXJZO1xuXHRcdFx0XHRcdGRlbGV0ZSBldmVudEFyZ3VtZW50cy5yZXR1cm5WYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRleHRlbmQoZXZlbnQsIGV2ZW50QXJndW1lbnRzKTtcblx0XHRcblx0XHRcdFx0Ly8gUHJldmVudCBqUXVlcnkgZnJvbSB0cmlnZ2VyaW5nIHRoZSBvYmplY3QgbWV0aG9kIHRoYXQgaXMgbmFtZWQgdGhlXG5cdFx0XHRcdC8vIHNhbWUgYXMgdGhlIGV2ZW50LiBGb3IgZXhhbXBsZSwgaWYgdGhlIGV2ZW50IGlzICdzZWxlY3QnLCBqUXVlcnlcblx0XHRcdFx0Ly8gYXR0ZW1wdHMgY2FsbGluZyBlbC5zZWxlY3QgYW5kIGl0IGdvZXMgaW50byBhIGxvb3AuXG5cdFx0XHRcdGlmIChlbFt0eXBlXSkge1xuXHRcdFx0XHRcdGVsW2RldGFjaGVkVHlwZV0gPSBlbFt0eXBlXTtcblx0XHRcdFx0XHRlbFt0eXBlXSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0Ly8gV3JhcCBwcmV2ZW50RGVmYXVsdCBhbmQgc3RvcFByb3BhZ2F0aW9uIGluIHRyeS9jYXRjaCBibG9ja3MgaW5cblx0XHRcdFx0Ly8gb3JkZXIgdG8gcHJldmVudCBKUyBlcnJvcnMgd2hlbiBjYW5jZWxsaW5nIGV2ZW50cyBvbiBub24tRE9NXG5cdFx0XHRcdC8vIG9iamVjdHMuICM2MTUuXG5cdFx0XHRcdC8qanNsaW50IHVucGFyYW06IHRydWUqL1xuXHRcdFx0XHQkLmVhY2goWydwcmV2ZW50RGVmYXVsdCcsICdzdG9wUHJvcGFnYXRpb24nXSwgZnVuY3Rpb24gKGksIGZuKSB7XG5cdFx0XHRcdFx0dmFyIGJhc2UgPSBldmVudFtmbl07XG5cdFx0XHRcdFx0ZXZlbnRbZm5dID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0YmFzZS5jYWxsKGV2ZW50KTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGZuID09PSAncHJldmVudERlZmF1bHQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Lypqc2xpbnQgdW5wYXJhbTogZmFsc2UqL1xuXHRcdFxuXHRcdFx0XHQvLyB0cmlnZ2VyIGl0XG5cdFx0XHRcdCQoZWwpLnRyaWdnZXIoZXZlbnQpO1xuXHRcdFxuXHRcdFx0XHQvLyBhdHRhY2ggdGhlIG1ldGhvZFxuXHRcdFx0XHRpZiAoZWxbZGV0YWNoZWRUeXBlXSkge1xuXHRcdFx0XHRcdGVsW3R5cGVdID0gZWxbZGV0YWNoZWRUeXBlXTtcblx0XHRcdFx0XHRlbFtkZXRhY2hlZFR5cGVdID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRpZiAoZGVmYXVsdEZ1bmN0aW9uICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiAhZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRcdGRlZmF1bHRGdW5jdGlvbihldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogRXh0ZW5zaW9uIG1ldGhvZCBuZWVkZWQgZm9yIE1vb1Rvb2xzXG5cdFx0XHQgKi9cblx0XHRcdHdhc2hNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR2YXIgcmV0ID0gZS5vcmlnaW5hbEV2ZW50IHx8IGU7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjb21wdXRlZCBieSBqUXVlcnksIG5lZWRlZCBieSBJRThcblx0XHRcdFx0aWYgKHJldC5wYWdlWCA9PT0gVU5ERUZJTkVEKSB7IC8vICMxMjM2XG5cdFx0XHRcdFx0cmV0LnBhZ2VYID0gZS5wYWdlWDtcblx0XHRcdFx0XHRyZXQucGFnZVkgPSBlLnBhZ2VZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSxcblx0XHRcblx0XHRcdC8qKlxuXHRcdFx0ICogQW5pbWF0ZSBhIEhUTUwgZWxlbWVudCBvciBTVkcgZWxlbWVudCB3cmFwcGVyXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWxcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGpRdWVyeS1saWtlIGFuaW1hdGlvbiBvcHRpb25zOiBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFja1xuXHRcdFx0ICovXG5cdFx0XHRhbmltYXRlOiBmdW5jdGlvbiAoZWwsIHBhcmFtcywgb3B0aW9ucykge1xuXHRcdFx0XHR2YXIgJGVsID0gJChlbCk7XG5cdFx0XHRcdGlmICghZWwuc3R5bGUpIHtcblx0XHRcdFx0XHRlbC5zdHlsZSA9IHt9OyAvLyAjMTg4MVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYXJhbXMuZCkge1xuXHRcdFx0XHRcdGVsLnRvRCA9IHBhcmFtcy5kOyAvLyBrZWVwIHRoZSBhcnJheSBmb3JtIGZvciBwYXRocywgdXNlZCBpbiAkLmZ4LnN0ZXAuZFxuXHRcdFx0XHRcdHBhcmFtcy5kID0gMTsgLy8gYmVjYXVzZSBpbiBqUXVlcnksIGFuaW1hdGluZyB0byBhbiBhcnJheSBoYXMgYSBkaWZmZXJlbnQgbWVhbmluZ1xuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdCRlbC5zdG9wKCk7XG5cdFx0XHRcdGlmIChwYXJhbXMub3BhY2l0eSAhPT0gVU5ERUZJTkVEICYmIGVsLmF0dHIpIHtcblx0XHRcdFx0XHRwYXJhbXMub3BhY2l0eSArPSAncHgnOyAvLyBmb3JjZSBqUXVlcnkgdG8gdXNlIHNhbWUgbG9naWMgYXMgd2lkdGggYW5kIGhlaWdodCAoIzIxNjEpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWwuaGFzQW5pbSA9IDE7IC8vICMzMzQyXG5cdFx0XHRcdCRlbC5hbmltYXRlKHBhcmFtcywgb3B0aW9ucyk7XG5cdFx0XG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTdG9wIHJ1bm5pbmcgYW5pbWF0aW9uXG5cdFx0XHQgKi9cblx0XHRcdHN0b3A6IGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0XHRpZiAoZWwuaGFzQW5pbSkgeyAvLyAjMzM0MiwgbWVtb3J5IGxlYWsgb24gY2FsbGluZyAkKGVsKSBmcm9tIGRlc3Ryb3lcblx0XHRcdFx0XHQkKGVsKS5zdG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSh3aW4ualF1ZXJ5KSk7XG5cblxuXHQvLyBjaGVjayBmb3IgYSBjdXN0b20gSGlnaGNoYXJ0c0FkYXB0ZXIgZGVmaW5lZCBwcmlvciB0byB0aGlzIGZpbGVcblx0dmFyIGdsb2JhbEFkYXB0ZXIgPSB3aW4uSGlnaGNoYXJ0c0FkYXB0ZXIsXG5cdFx0YWRhcHRlciA9IGdsb2JhbEFkYXB0ZXIgfHwge307XG5cdFx0XG5cdC8vIEluaXRpYWxpemUgdGhlIGFkYXB0ZXJcblx0aWYgKGdsb2JhbEFkYXB0ZXIpIHtcblx0XHRnbG9iYWxBZGFwdGVyLmluaXQuY2FsbChnbG9iYWxBZGFwdGVyLCBwYXRoQW5pbSk7XG5cdH1cblxuXG5cdC8vIFV0aWxpdHkgZnVuY3Rpb25zLiBJZiB0aGUgSGlnaGNoYXJ0c0FkYXB0ZXIgaXMgbm90IGRlZmluZWQsIGFkYXB0ZXIgaXMgYW4gZW1wdHkgb2JqZWN0XG5cdC8vIGFuZCBhbGwgdGhlIHV0aWxpdHkgZnVuY3Rpb25zIHdpbGwgYmUgbnVsbC4gSW4gdGhhdCBjYXNlIHRoZXkgYXJlIHBvcHVsYXRlZCBieSB0aGVcblx0Ly8gZGVmYXVsdCBhZGFwdGVycyBiZWxvdy5cblx0dmFyIGFkYXB0ZXJSdW4gPSBhZGFwdGVyLmFkYXB0ZXJSdW4sXG5cdFx0Z2V0U2NyaXB0ID0gYWRhcHRlci5nZXRTY3JpcHQsXG5cdFx0aW5BcnJheSA9IGFkYXB0ZXIuaW5BcnJheSxcblx0XHRlYWNoID0gSGlnaGNoYXJ0cy5lYWNoID0gYWRhcHRlci5lYWNoLFxuXHRcdGdyZXAgPSBhZGFwdGVyLmdyZXAsXG5cdFx0b2Zmc2V0ID0gYWRhcHRlci5vZmZzZXQsXG5cdFx0bWFwID0gYWRhcHRlci5tYXAsXG5cdFx0YWRkRXZlbnQgPSBhZGFwdGVyLmFkZEV2ZW50LFxuXHRcdHJlbW92ZUV2ZW50ID0gYWRhcHRlci5yZW1vdmVFdmVudCxcblx0XHRmaXJlRXZlbnQgPSBhZGFwdGVyLmZpcmVFdmVudCxcblx0XHR3YXNoTW91c2VFdmVudCA9IGFkYXB0ZXIud2FzaE1vdXNlRXZlbnQsXG5cdFx0YW5pbWF0ZSA9IGFkYXB0ZXIuYW5pbWF0ZSxcblx0XHRzdG9wID0gYWRhcHRlci5zdG9wO1xuXG5cblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIEhhbmRsZSB0aGUgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRkZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRjb2xvcnM6IFsnIzdjYjVlYycsICcjNDM0MzQ4JywgJyM5MGVkN2QnLCAnI2Y3YTM1YycsIFxuXHRcdFx0ICAgICcjODA4NWU5JywgJyNmMTVjODAnLCAnI2U0ZDM1NCcsICcjMmI5MDhmJywgJyNmNDViNWInLCAnIzkxZThlMSddLFxuXHRcdHN5bWJvbHM6IFsnY2lyY2xlJywgJ2RpYW1vbmQnLCAnc3F1YXJlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLWRvd24nXSxcblx0XHRsYW5nOiB7XG5cdFx0XHRsb2FkaW5nOiAnTG9hZGluZy4uLicsXG5cdFx0XHRtb250aHM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5Jyxcblx0XHRcdFx0XHQnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG5cdFx0XHRzaG9ydE1vbnRoczogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuXHRcdFx0d2Vla2RheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcblx0XHRcdGRlY2ltYWxQb2ludDogJy4nLFxuXHRcdFx0bnVtZXJpY1N5bWJvbHM6IFsnaycsICdNJywgJ0cnLCAnVCcsICdQJywgJ0UnXSwgLy8gU0kgcHJlZml4ZXMgdXNlZCBpbiBheGlzIGxhYmVsc1xuXHRcdFx0cmVzZXRab29tOiAnUmVzZXQgem9vbScsXG5cdFx0XHRyZXNldFpvb21UaXRsZTogJ1Jlc2V0IHpvb20gbGV2ZWwgMToxJyxcblx0XHRcdHRob3VzYW5kc1NlcDogJyAnXG5cdFx0fSxcblx0XHRnbG9iYWw6IHtcblx0XHRcdHVzZVVUQzogdHJ1ZSxcblx0XHRcdC8vdGltZXpvbmVPZmZzZXQ6IDAsXG5cdFx0XHRjYW52YXNUb29sc1VSTDogJ2h0dHA6Ly9jb2RlLmhpZ2hjaGFydHMuY29tLzQuMS40LW1vZGlmaWVkL21vZHVsZXMvY2FudmFzLXRvb2xzLmpzJyxcblx0XHRcdFZNTFJhZGlhbEdyYWRpZW50VVJMOiAnaHR0cDovL2NvZGUuaGlnaGNoYXJ0cy5jb20vNC4xLjQtbW9kaWZpZWQvZ2Z4L3ZtbC1yYWRpYWwtZ3JhZGllbnQucG5nJ1xuXHRcdH0sXG5cdFx0Y2hhcnQ6IHtcblx0XHRcdC8vYW5pbWF0aW9uOiB0cnVlLFxuXHRcdFx0Ly9hbGlnblRpY2tzOiBmYWxzZSxcblx0XHRcdC8vcmVmbG93OiB0cnVlLFxuXHRcdFx0Ly9jbGFzc05hbWU6IG51bGwsXG5cdFx0XHQvL2V2ZW50czogeyBsb2FkLCBzZWxlY3Rpb24gfSxcblx0XHRcdC8vbWFyZ2luOiBbbnVsbF0sXG5cdFx0XHQvL21hcmdpblRvcDogbnVsbCxcblx0XHRcdC8vbWFyZ2luUmlnaHQ6IG51bGwsXG5cdFx0XHQvL21hcmdpbkJvdHRvbTogbnVsbCxcblx0XHRcdC8vbWFyZ2luTGVmdDogbnVsbCxcblx0XHRcdGJvcmRlckNvbG9yOiAnIzQ1NzJBNycsXG5cdFx0XHQvL2JvcmRlcldpZHRoOiAwLFxuXHRcdFx0Ym9yZGVyUmFkaXVzOiAwLFxuXHRcdFx0ZGVmYXVsdFNlcmllc1R5cGU6ICdsaW5lJyxcblx0XHRcdGlnbm9yZUhpZGRlblNlcmllczogdHJ1ZSxcblx0XHRcdC8vaW52ZXJ0ZWQ6IGZhbHNlLFxuXHRcdFx0Ly9zaGFkb3c6IGZhbHNlLFxuXHRcdFx0c3BhY2luZzogWzEwLCAxMCwgMTUsIDEwXSxcblx0XHRcdC8vc3BhY2luZ1RvcDogMTAsXG5cdFx0XHQvL3NwYWNpbmdSaWdodDogMTAsXG5cdFx0XHQvL3NwYWNpbmdCb3R0b206IDE1LFxuXHRcdFx0Ly9zcGFjaW5nTGVmdDogMTAsXG5cdFx0XHQvL3N0eWxlOiB7XG5cdFx0XHQvL1x0Zm9udEZhbWlseTogJ1wiTHVjaWRhIEdyYW5kZVwiLCBcIkx1Y2lkYSBTYW5zIFVuaWNvZGVcIiwgVmVyZGFuYSwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsIC8vIGRlZmF1bHQgZm9udFxuXHRcdFx0Ly9cdGZvbnRTaXplOiAnMTJweCdcblx0XHRcdC8vfSxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJyNGRkZGRkYnLFxuXHRcdFx0Ly9wbG90QmFja2dyb3VuZENvbG9yOiBudWxsLFxuXHRcdFx0cGxvdEJvcmRlckNvbG9yOiAnI0MwQzBDMCcsXG5cdFx0XHQvL3Bsb3RCb3JkZXJXaWR0aDogMCxcblx0XHRcdC8vcGxvdFNoYWRvdzogZmFsc2UsXG5cdFx0XHQvL3pvb21UeXBlOiAnJ1xuXHRcdFx0cmVzZXRab29tQnV0dG9uOiB7XG5cdFx0XHRcdHRoZW1lOiB7XG5cdFx0XHRcdFx0ekluZGV4OiAyMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHRcdGFsaWduOiAncmlnaHQnLFxuXHRcdFx0XHRcdHg6IC0xMCxcblx0XHRcdFx0XHQvL3ZlcnRpY2FsQWxpZ246ICd0b3AnLFxuXHRcdFx0XHRcdHk6IDEwXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcmVsYXRpdmVUbzogJ3Bsb3QnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0aXRsZToge1xuXHRcdFx0dGV4dDogJ0NoYXJ0IHRpdGxlJyxcblx0XHRcdGFsaWduOiAnY2VudGVyJyxcblx0XHRcdC8vIGZsb2F0aW5nOiBmYWxzZSxcblx0XHRcdG1hcmdpbjogMTUsXG5cdFx0XHQvLyB4OiAwLFxuXHRcdFx0Ly8gdmVydGljYWxBbGlnbjogJ3RvcCcsXG5cdFx0XHQvLyB5OiBudWxsLFxuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Y29sb3I6ICcjMzMzMzMzJyxcblx0XHRcdFx0Zm9udFNpemU6ICcxOHB4J1xuXHRcdFx0fVxuXG5cdFx0fSxcblx0XHRzdWJ0aXRsZToge1xuXHRcdFx0dGV4dDogJycsXG5cdFx0XHRhbGlnbjogJ2NlbnRlcicsXG5cdFx0XHQvLyBmbG9hdGluZzogZmFsc2Vcblx0XHRcdC8vIHg6IDAsXG5cdFx0XHQvLyB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcblx0XHRcdC8vIHk6IG51bGwsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRjb2xvcjogJyM1NTU1NTUnXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHBsb3RPcHRpb25zOiB7XG5cdFx0XHRsaW5lOiB7IC8vIGJhc2Ugc2VyaWVzIG9wdGlvbnNcblx0XHRcdFx0YWxsb3dQb2ludFNlbGVjdDogZmFsc2UsXG5cdFx0XHRcdHNob3dDaGVja2JveDogZmFsc2UsXG5cdFx0XHRcdGFuaW1hdGlvbjoge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiAxMDAwXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vY29ubmVjdE51bGxzOiBmYWxzZSxcblx0XHRcdFx0Ly9jdXJzb3I6ICdkZWZhdWx0Jyxcblx0XHRcdFx0Ly9jbGlwOiB0cnVlLFxuXHRcdFx0XHQvL2Rhc2hTdHlsZTogbnVsbCxcblx0XHRcdFx0Ly9lbmFibGVNb3VzZVRyYWNraW5nOiB0cnVlLFxuXHRcdFx0XHRldmVudHM6IHt9LFxuXHRcdFx0XHQvL2xlZ2VuZEluZGV4OiAwLFxuXHRcdFx0XHQvL2xpbmVjYXA6ICdyb3VuZCcsXG5cdFx0XHRcdGxpbmVXaWR0aDogMixcblx0XHRcdFx0Ly9zaGFkb3c6IGZhbHNlLFxuXHRcdFx0XHQvLyBzdGFja2luZzogbnVsbCxcblx0XHRcdFx0bWFya2VyOiB7XG5cdFx0XHRcdFx0Ly9lbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRcdC8vc3ltYm9sOiBudWxsLFxuXHRcdFx0XHRcdGxpbmVXaWR0aDogMCxcblx0XHRcdFx0XHRyYWRpdXM6IDQsXG5cdFx0XHRcdFx0bGluZUNvbG9yOiAnI0ZGRkZGRicsXG5cdFx0XHRcdFx0Ly9maWxsQ29sb3I6IG51bGwsXG5cdFx0XHRcdFx0c3RhdGVzOiB7IC8vIHN0YXRlcyBmb3IgYSBzaW5nbGUgcG9pbnRcblx0XHRcdFx0XHRcdGhvdmVyOiB7XG5cdFx0XHRcdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aFBsdXM6IDEsXG5cdFx0XHRcdFx0XHRcdHJhZGl1c1BsdXM6IDJcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRzZWxlY3Q6IHtcblx0XHRcdFx0XHRcdFx0ZmlsbENvbG9yOiAnI0ZGRkZGRicsXG5cdFx0XHRcdFx0XHRcdGxpbmVDb2xvcjogJyMwMDAwMDAnLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IDJcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHBvaW50OiB7XG5cdFx0XHRcdFx0ZXZlbnRzOiB7fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRkYXRhTGFiZWxzOiB7XG5cdFx0XHRcdFx0YWxpZ246ICdjZW50ZXInLFxuXHRcdFx0XHRcdC8vIGRlZmVyOiB0cnVlLFxuXHRcdFx0XHRcdC8vIGVuYWJsZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMueSA9PT0gbnVsbCA/ICcnIDogSGlnaGNoYXJ0cy5udW1iZXJGb3JtYXQodGhpcy55LCAtMSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0Y29sb3I6ICdjb250cmFzdCcsXG5cdFx0XHRcdFx0XHRmb250U2l6ZTogJzExcHgnLFxuXHRcdFx0XHRcdFx0Zm9udFdlaWdodDogJ2JvbGQnLFxuXHRcdFx0XHRcdFx0dGV4dFNoYWRvdzogJzAgMCA2cHggY29udHJhc3QsIDAgMCAzcHggY29udHJhc3QnXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJywgLy8gYWJvdmUgc2luZ3VsYXIgcG9pbnRcblx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0Ly8gYmFja2dyb3VuZENvbG9yOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0Ly8gYm9yZGVyQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHQvLyBib3JkZXJSYWRpdXM6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHQvLyBib3JkZXJXaWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHBhZGRpbmc6IDVcblx0XHRcdFx0XHQvLyBzaGFkb3c6IGZhbHNlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNyb3BUaHJlc2hvbGQ6IDMwMCwgLy8gZHJhdyBwb2ludHMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhIHdoZW4gdGhlIG51bWJlciBvZiBwb2ludHMgaXMgbGVzcyB0aGFuIHRoaXNcblx0XHRcdFx0cG9pbnRSYW5nZTogMCxcblx0XHRcdFx0Ly9wb2ludFN0YXJ0OiAwLFxuXHRcdFx0XHQvL3BvaW50SW50ZXJ2YWw6IDEsXG5cdFx0XHRcdC8vc2hvd0luTGVnZW5kOiBudWxsLCAvLyBhdXRvOiB0cnVlIGZvciBzdGFuZGFsb25lIHNlcmllcywgZmFsc2UgZm9yIGxpbmtlZCBzZXJpZXNcblx0XHRcdFx0c3RhdGVzOiB7IC8vIHN0YXRlcyBmb3IgdGhlIGVudGlyZSBzZXJpZXNcblx0XHRcdFx0XHRob3Zlcjoge1xuXHRcdFx0XHRcdFx0Ly9lbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0XHRcdGxpbmVXaWR0aFBsdXM6IDEsXG5cdFx0XHRcdFx0XHRtYXJrZXI6IHtcblx0XHRcdFx0XHRcdFx0Ly8gbGluZVdpZHRoOiBiYXNlICsgMSxcblx0XHRcdFx0XHRcdFx0Ly8gcmFkaXVzOiBiYXNlICsgMVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGhhbG86IHtcblx0XHRcdFx0XHRcdFx0c2l6ZTogMTAsXG5cdFx0XHRcdFx0XHRcdG9wYWNpdHk6IDAuMjVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHNlbGVjdDoge1xuXHRcdFx0XHRcdFx0bWFya2VyOiB7fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c3RpY2t5VHJhY2tpbmc6IHRydWUsXG5cdFx0XHRcdC8vdG9vbHRpcDoge1xuXHRcdFx0XHRcdC8vcG9pbnRGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImNvbG9yOntwb2ludC5jb2xvcn1cIj5cXHUyNUNGPC9zcGFuPiB7c2VyaWVzLm5hbWV9OiA8Yj57cG9pbnQueX08L2I+J1xuXHRcdFx0XHRcdC8vdmFsdWVEZWNpbWFsczogbnVsbCxcblx0XHRcdFx0XHQvL3hEYXRlRm9ybWF0OiAnJUEsICViICVlLCAlWScsXG5cdFx0XHRcdFx0Ly92YWx1ZVByZWZpeDogJycsXG5cdFx0XHRcdFx0Ly95U3VmZml4OiAnJ1x0XHRcdFx0XG5cdFx0XHRcdC8vfVxuXHRcdFx0XHR0dXJib1RocmVzaG9sZDogMTAwMFxuXHRcdFx0XHQvLyB6SW5kZXg6IG51bGxcblx0XHRcdH1cblx0XHR9LFxuXHRcdGxhYmVsczoge1xuXHRcdFx0Ly9pdGVtczogW10sXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHQvL2ZvbnQ6IGRlZmF1bHRGb250LFxuXHRcdFx0XHRwb3NpdGlvbjogQUJTT0xVVEUsXG5cdFx0XHRcdGNvbG9yOiAnIzNFNTc2Ridcblx0XHRcdH1cblx0XHR9LFxuXHRcdGxlZ2VuZDoge1xuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdGFsaWduOiAnY2VudGVyJyxcblx0XHRcdC8vZmxvYXRpbmc6IGZhbHNlLFxuXHRcdFx0bGF5b3V0OiAnaG9yaXpvbnRhbCcsXG5cdFx0XHRsYWJlbEZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5uYW1lO1xuXHRcdFx0fSxcblx0XHRcdC8vYm9yZGVyV2lkdGg6IDAsXG5cdFx0XHRib3JkZXJDb2xvcjogJyM5MDkwOTAnLFxuXHRcdFx0Ym9yZGVyUmFkaXVzOiAwLFxuXHRcdFx0bmF2aWdhdGlvbjoge1xuXHRcdFx0XHQvLyBhbmltYXRpb246IHRydWUsXG5cdFx0XHRcdGFjdGl2ZUNvbG9yOiAnIzI3NGI2ZCcsXG5cdFx0XHRcdC8vIGFycm93U2l6ZTogMTJcblx0XHRcdFx0aW5hY3RpdmVDb2xvcjogJyNDQ0MnXG5cdFx0XHRcdC8vIHN0eWxlOiB7fSAvLyB0ZXh0IHN0eWxlc1xuXHRcdFx0fSxcblx0XHRcdC8vIG1hcmdpbjogMjAsXG5cdFx0XHQvLyByZXZlcnNlZDogZmFsc2UsXG5cdFx0XHRzaGFkb3c6IGZhbHNlLFxuXHRcdFx0Ly8gYmFja2dyb3VuZENvbG9yOiBudWxsLFxuXHRcdFx0LypzdHlsZToge1xuXHRcdFx0XHRwYWRkaW5nOiAnNXB4J1xuXHRcdFx0fSwqL1xuXHRcdFx0aXRlbVN0eWxlOiB7XHRcdFx0XG5cdFx0XHRcdGNvbG9yOiAnIzMzMzMzMycsXG5cdFx0XHRcdGZvbnRTaXplOiAnMTJweCcsXG5cdFx0XHRcdGZvbnRXZWlnaHQ6ICdib2xkJ1xuXHRcdFx0fSxcblx0XHRcdGl0ZW1Ib3ZlclN0eWxlOiB7XG5cdFx0XHRcdC8vY3Vyc29yOiAncG9pbnRlcicsIHJlbW92ZWQgYXMgb2YgIzYwMVxuXHRcdFx0XHRjb2xvcjogJyMwMDAnXG5cdFx0XHR9LFxuXHRcdFx0aXRlbUhpZGRlblN0eWxlOiB7XG5cdFx0XHRcdGNvbG9yOiAnI0NDQydcblx0XHRcdH0sXG5cdFx0XHRpdGVtQ2hlY2tib3hTdHlsZToge1xuXHRcdFx0XHRwb3NpdGlvbjogQUJTT0xVVEUsXG5cdFx0XHRcdHdpZHRoOiAnMTNweCcsIC8vIGZvciBJRSBwcmVjaXNpb25cblx0XHRcdFx0aGVpZ2h0OiAnMTNweCdcblx0XHRcdH0sXG5cdFx0XHQvLyBpdGVtV2lkdGg6IHVuZGVmaW5lZCxcblx0XHRcdC8vIHN5bWJvbFJhZGl1czogMCxcblx0XHRcdC8vIHN5bWJvbFdpZHRoOiAxNixcblx0XHRcdHN5bWJvbFBhZGRpbmc6IDUsXG5cdFx0XHR2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyxcblx0XHRcdC8vIHdpZHRoOiB1bmRlZmluZWQsXG5cdFx0XHR4OiAwLFxuXHRcdFx0eTogMCxcblx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdC8vdGV4dDogbnVsbCxcblx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRmb250V2VpZ2h0OiAnYm9sZCdcblx0XHRcdFx0fVxuXHRcdFx0fVx0XHRcdFxuXHRcdH0sXG5cblx0XHRsb2FkaW5nOiB7XG5cdFx0XHQvLyBoaWRlRHVyYXRpb246IDEwMCxcblx0XHRcdGxhYmVsU3R5bGU6IHtcblx0XHRcdFx0Zm9udFdlaWdodDogJ2JvbGQnLFxuXHRcdFx0XHRwb3NpdGlvbjogUkVMQVRJVkUsXG5cdFx0XHRcdHRvcDogJzQ1JSdcblx0XHRcdH0sXG5cdFx0XHQvLyBzaG93RHVyYXRpb246IDAsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRwb3NpdGlvbjogQUJTT0xVVEUsXG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcblx0XHRcdFx0b3BhY2l0eTogMC41LFxuXHRcdFx0XHR0ZXh0QWxpZ246ICdjZW50ZXInXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRvb2x0aXA6IHtcblx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRhbmltYXRpb246IGhhc1NWRyxcblx0XHRcdC8vY3Jvc3NoYWlyczogbnVsbCxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjQ5LCAyNDksIDI0OSwgLjg1KScsXG5cdFx0XHRib3JkZXJXaWR0aDogMSxcblx0XHRcdGJvcmRlclJhZGl1czogMyxcblx0XHRcdGRhdGVUaW1lTGFiZWxGb3JtYXRzOiB7IFxuXHRcdFx0XHRtaWxsaXNlY29uZDogJyVBLCAlYiAlZSwgJUg6JU06JVMuJUwnLFxuXHRcdFx0XHRzZWNvbmQ6ICclQSwgJWIgJWUsICVIOiVNOiVTJyxcblx0XHRcdFx0bWludXRlOiAnJUEsICViICVlLCAlSDolTScsXG5cdFx0XHRcdGhvdXI6ICclQSwgJWIgJWUsICVIOiVNJyxcblx0XHRcdFx0ZGF5OiAnJUEsICViICVlLCAlWScsXG5cdFx0XHRcdHdlZWs6ICdXZWVrIGZyb20gJUEsICViICVlLCAlWScsXG5cdFx0XHRcdG1vbnRoOiAnJUIgJVknLFxuXHRcdFx0XHR5ZWFyOiAnJVknXG5cdFx0XHR9LFxuXHRcdFx0Zm9vdGVyRm9ybWF0OiAnJyxcblx0XHRcdC8vZm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxuXHRcdFx0aGVhZGVyRm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHhcIj57cG9pbnQua2V5fTwvc3Bhbj48YnIvPicsXG5cdFx0XHRwb2ludEZvcm1hdDogJzxzcGFuIHN0eWxlPVwiY29sb3I6e3BvaW50LmNvbG9yfVwiPlxcdTI1Q0Y8L3NwYW4+IHtzZXJpZXMubmFtZX06IDxiPntwb2ludC55fTwvYj48YnIvPicsXG5cdFx0XHRzaGFkb3c6IHRydWUsXG5cdFx0XHQvL3NoYXBlOiAnY2FsbG91dCcsXG5cdFx0XHQvL3NoYXJlZDogZmFsc2UsXG5cdFx0XHRzbmFwOiBpc1RvdWNoRGV2aWNlID8gMjUgOiAxMCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGNvbG9yOiAnIzMzMzMzMycsXG5cdFx0XHRcdGN1cnNvcjogJ2RlZmF1bHQnLFxuXHRcdFx0XHRmb250U2l6ZTogJzEycHgnLFxuXHRcdFx0XHRwYWRkaW5nOiAnOHB4Jyxcblx0XHRcdFx0d2hpdGVTcGFjZTogJ25vd3JhcCdcblx0XHRcdH1cblx0XHRcdC8veERhdGVGb3JtYXQ6ICclQSwgJWIgJWUsICVZJyxcblx0XHRcdC8vdmFsdWVEZWNpbWFsczogbnVsbCxcblx0XHRcdC8vdmFsdWVQcmVmaXg6ICcnLFxuXHRcdFx0Ly92YWx1ZVN1ZmZpeDogJydcblx0XHR9LFxuXG5cdFx0Y3JlZGl0czoge1xuXHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdHRleHQ6ICdIaWdoY2hhcnRzLmNvbScsXG5cdFx0XHRocmVmOiAnaHR0cDovL3d3dy5oaWdoY2hhcnRzLmNvbScsXG5cdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHRhbGlnbjogJ3JpZ2h0Jyxcblx0XHRcdFx0eDogLTEwLFxuXHRcdFx0XHR2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyxcblx0XHRcdFx0eTogLTVcblx0XHRcdH0sXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRjdXJzb3I6ICdwb2ludGVyJyxcblx0XHRcdFx0Y29sb3I6ICcjOTA5MDkwJyxcblx0XHRcdFx0Zm9udFNpemU6ICc5cHgnXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblxuXG5cdC8vIFNlcmllcyBkZWZhdWx0c1xuXHR2YXIgZGVmYXVsdFBsb3RPcHRpb25zID0gZGVmYXVsdE9wdGlvbnMucGxvdE9wdGlvbnMsXG5cdFx0ZGVmYXVsdFNlcmllc09wdGlvbnMgPSBkZWZhdWx0UGxvdE9wdGlvbnMubGluZTtcblxuXHQvLyBzZXQgdGhlIGRlZmF1bHQgdGltZSBtZXRob2RzXG5cdHNldFRpbWVNZXRob2RzKCk7XG5cblxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHRpbWUgbWV0aG9kcyBnbG9iYWxseSBiYXNlZCBvbiB0aGUgdXNlVVRDIG9wdGlvbi4gVGltZSBtZXRob2QgY2FuIGJlIGVpdGhlclxuXHQgKiBsb2NhbCB0aW1lIG9yIFVUQyAoZGVmYXVsdCkuXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXRUaW1lTWV0aG9kcygpIHtcblx0XHR2YXIgZ2xvYmFsT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zLmdsb2JhbCxcblx0XHRcdHVzZVVUQyA9IGdsb2JhbE9wdGlvbnMudXNlVVRDLFxuXHRcdFx0R0VUID0gdXNlVVRDID8gJ2dldFVUQycgOiAnZ2V0Jyxcblx0XHRcdFNFVCA9IHVzZVVUQyA/ICdzZXRVVEMnIDogJ3NldCc7XG5cblxuXHRcdERhdGUgPSBnbG9iYWxPcHRpb25zLkRhdGUgfHwgd2luZG93LkRhdGU7XG5cdFx0dGltZXpvbmVPZmZzZXQgPSB1c2VVVEMgJiYgZ2xvYmFsT3B0aW9ucy50aW1lem9uZU9mZnNldDtcblx0XHRnZXRUaW1lem9uZU9mZnNldCA9IHVzZVVUQyAmJiBnbG9iYWxPcHRpb25zLmdldFRpbWV6b25lT2Zmc2V0O1xuXHRcdG1ha2VUaW1lID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcywgc2Vjb25kcykge1xuXHRcdFx0dmFyIGQ7XG5cdFx0XHRpZiAodXNlVVRDKSB7XG5cdFx0XHRcdGQgPSBEYXRlLlVUQy5hcHBseSgwLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRkICs9IGdldFRaT2Zmc2V0KGQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZCA9IG5ldyBEYXRlKFxuXHRcdFx0XHRcdHllYXIsXG5cdFx0XHRcdFx0bW9udGgsXG5cdFx0XHRcdFx0cGljayhkYXRlLCAxKSxcblx0XHRcdFx0XHRwaWNrKGhvdXJzLCAwKSxcblx0XHRcdFx0XHRwaWNrKG1pbnV0ZXMsIDApLFxuXHRcdFx0XHRcdHBpY2soc2Vjb25kcywgMClcblx0XHRcdFx0KS5nZXRUaW1lKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZDtcblx0XHR9O1xuXHRcdGdldE1pbnV0ZXMgPSAgR0VUICsgJ01pbnV0ZXMnO1xuXHRcdGdldEhvdXJzID0gICAgR0VUICsgJ0hvdXJzJztcblx0XHRnZXREYXkgPSAgICAgIEdFVCArICdEYXknO1xuXHRcdGdldERhdGUgPSAgICAgR0VUICsgJ0RhdGUnO1xuXHRcdGdldE1vbnRoID0gICAgR0VUICsgJ01vbnRoJztcblx0XHRnZXRGdWxsWWVhciA9IEdFVCArICdGdWxsWWVhcic7XG5cdFx0c2V0TWludXRlcyA9ICBTRVQgKyAnTWludXRlcyc7XG5cdFx0c2V0SG91cnMgPSAgICBTRVQgKyAnSG91cnMnO1xuXHRcdHNldERhdGUgPSAgICAgU0VUICsgJ0RhdGUnO1xuXHRcdHNldE1vbnRoID0gICAgU0VUICsgJ01vbnRoJztcblx0XHRzZXRGdWxsWWVhciA9IFNFVCArICdGdWxsWWVhcic7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNZXJnZSB0aGUgZGVmYXVsdCBvcHRpb25zIHdpdGggY3VzdG9tIG9wdGlvbnMgYW5kIHJldHVybiB0aGUgbmV3IG9wdGlvbnMgc3RydWN0dXJlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBuZXcgY3VzdG9tIG9wdGlvbnNcblx0ICovXG5cdGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuXHRcdFxuXHRcdC8vIENvcHkgaW4gdGhlIGRlZmF1bHQgb3B0aW9uc1xuXHRcdGRlZmF1bHRPcHRpb25zID0gbWVyZ2UodHJ1ZSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXHRcdFxuXHRcdC8vIEFwcGx5IFVUQ1xuXHRcdHNldFRpbWVNZXRob2RzKCk7XG5cblx0XHRyZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSB1cGRhdGVkIGRlZmF1bHQgb3B0aW9ucy4gVW50aWwgMy4wLjcsIG1lcmVseSBleHBvc2luZyBkZWZhdWx0T3B0aW9ucyBmb3Igb3V0c2lkZSBtb2R1bGVzXG5cdCAqIHdhc24ndCBlbm91Z2ggYmVjYXVzZSB0aGUgc2V0T3B0aW9ucyBtZXRob2QgY3JlYXRlZCBhIG5ldyBvYmplY3QuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuXHRcdHJldHVybiBkZWZhdWx0T3B0aW9ucztcblx0fVxuXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBjb2xvciBvcGVyYXRpb25zLiBUaGUgb2JqZWN0IG1ldGhvZHMgYXJlIGNoYWluYWJsZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBpbnB1dCBjb2xvciBpbiBlaXRoZXIgcmJnYSBvciBoZXggZm9ybWF0XG5cdCAqL1xuXHR2YXIgcmdiYVJlZ0V4ID0gL3JnYmFcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldPyg/OlxcLlswLTldKyk/KVxccypcXCkvLFxuXHRcdGhleFJlZ0V4ID0gLyMoW2EtZkEtRjAtOV17Mn0pKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkvLFxuXHRcdHJnYlJlZ0V4ID0gL3JnYlxcKFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqXFwpLztcblxuXHR2YXIgQ29sb3IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblx0XHQvLyBkZWNsYXJlIHZhcmlhYmxlc1xuXHRcdHZhciByZ2JhID0gW10sIHJlc3VsdCwgc3RvcHM7XG5cblx0XHQvKipcblx0XHQgKiBQYXJzZSB0aGUgaW5wdXQgY29sb3IgdG8gcmdiYSBhcnJheVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGluaXQoaW5wdXQpIHtcblxuXHRcdFx0Ly8gR3JhZGllbnRzXG5cdFx0XHRpZiAoaW5wdXQgJiYgaW5wdXQuc3RvcHMpIHtcblx0XHRcdFx0c3RvcHMgPSBtYXAoaW5wdXQuc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG5cdFx0XHRcdFx0cmV0dXJuIENvbG9yKHN0b3BbMV0pO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gU29saWQgY29sb3JzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyByZ2JhXG5cdFx0XHRcdHJlc3VsdCA9IHJnYmFSZWdFeC5leGVjKGlucHV0KTtcblx0XHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRcdHJnYmEgPSBbcEludChyZXN1bHRbMV0pLCBwSW50KHJlc3VsdFsyXSksIHBJbnQocmVzdWx0WzNdKSwgcGFyc2VGbG9hdChyZXN1bHRbNF0sIDEwKV07XG5cdFx0XHRcdH0gZWxzZSB7IFxuXHRcdFx0XHRcdC8vIGhleFxuXHRcdFx0XHRcdHJlc3VsdCA9IGhleFJlZ0V4LmV4ZWMoaW5wdXQpO1xuXHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdHJnYmEgPSBbcEludChyZXN1bHRbMV0sIDE2KSwgcEludChyZXN1bHRbMl0sIDE2KSwgcEludChyZXN1bHRbM10sIDE2KSwgMV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHJnYlxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gcmdiUmVnRXguZXhlYyhpbnB1dCk7XG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRcdHJnYmEgPSBbcEludChyZXN1bHRbMV0pLCBwSW50KHJlc3VsdFsyXSksIHBJbnQocmVzdWx0WzNdKSwgMV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XHRcdFxuXG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0aGUgY29sb3IgYSBzcGVjaWZpZWQgZm9ybWF0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGdldChmb3JtYXQpIHtcblx0XHRcdHZhciByZXQ7XG5cblx0XHRcdGlmIChzdG9wcykge1xuXHRcdFx0XHRyZXQgPSBtZXJnZShpbnB1dCk7XG5cdFx0XHRcdHJldC5zdG9wcyA9IFtdLmNvbmNhdChyZXQuc3RvcHMpO1xuXHRcdFx0XHRlYWNoKHN0b3BzLCBmdW5jdGlvbiAoc3RvcCwgaSkge1xuXHRcdFx0XHRcdHJldC5zdG9wc1tpXSA9IFtyZXQuc3RvcHNbaV1bMF0sIHN0b3AuZ2V0KGZvcm1hdCldO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gaXQncyBOYU4gaWYgZ3JhZGllbnQgY29sb3JzIG9uIGEgY29sdW1uIGNoYXJ0XG5cdFx0XHR9IGVsc2UgaWYgKHJnYmEgJiYgIWlzTmFOKHJnYmFbMF0pKSB7XG5cdFx0XHRcdGlmIChmb3JtYXQgPT09ICdyZ2InKSB7XG5cdFx0XHRcdFx0cmV0ID0gJ3JnYignICsgcmdiYVswXSArICcsJyArIHJnYmFbMV0gKyAnLCcgKyByZ2JhWzJdICsgJyknO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2EnKSB7XG5cdFx0XHRcdFx0cmV0ID0gcmdiYVszXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXQgPSAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldCA9IGlucHV0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBCcmlnaHRlbiB0aGUgY29sb3Jcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYWxwaGFcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBicmlnaHRlbihhbHBoYSkge1xuXHRcdFx0aWYgKHN0b3BzKSB7XG5cdFx0XHRcdGVhY2goc3RvcHMsIGZ1bmN0aW9uIChzdG9wKSB7XG5cdFx0XHRcdFx0c3RvcC5icmlnaHRlbihhbHBoYSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR9IGVsc2UgaWYgKGlzTnVtYmVyKGFscGhhKSAmJiBhbHBoYSAhPT0gMCkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHRcdHJnYmFbaV0gKz0gcEludChhbHBoYSAqIDI1NSk7XG5cblx0XHRcdFx0XHRpZiAocmdiYVtpXSA8IDApIHtcblx0XHRcdFx0XHRcdHJnYmFbaV0gPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocmdiYVtpXSA+IDI1NSkge1xuXHRcdFx0XHRcdFx0cmdiYVtpXSA9IDI1NTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGNvbG9yJ3Mgb3BhY2l0eSB0byBhIGdpdmVuIGFscGhhIHZhbHVlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gc2V0T3BhY2l0eShhbHBoYSkge1xuXHRcdFx0cmdiYVszXSA9IGFscGhhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gaW5pdGlhbGl6ZTogcGFyc2UgdGhlIGlucHV0XG5cdFx0aW5pdChpbnB1dCk7XG5cblx0XHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRcdHJldHVybiB7XG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdGJyaWdodGVuOiBicmlnaHRlbixcblx0XHRcdHJnYmE6IHJnYmEsXG5cdFx0XHRzZXRPcGFjaXR5OiBzZXRPcGFjaXR5LFxuXHRcdFx0cmF3OiBpbnB1dFxuXHRcdH07XG5cdH07XG5cblxuXHQvKipcblx0ICogQSB3cmFwcGVyIG9iamVjdCBmb3IgU1ZHIGVsZW1lbnRzXG5cdCAqL1xuXHRmdW5jdGlvbiBTVkdFbGVtZW50KCkge31cblxuXHRTVkdFbGVtZW50LnByb3RvdHlwZSA9IHtcblx0XHRcblx0XHQvLyBEZWZhdWx0IGJhc2UgZm9yIGFuaW1hdGlvblxuXHRcdG9wYWNpdHk6IDEsXG5cdFx0Ly8gRm9yIGxhYmVscywgdGhlc2UgQ1NTIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gdGhlIDx0ZXh0PiBub2RlIGRpcmVjdGx5XG5cdFx0dGV4dFByb3BzOiBbJ2ZvbnRTaXplJywgJ2ZvbnRXZWlnaHQnLCAnZm9udEZhbWlseScsICdjb2xvcicsIFxuXHRcdFx0J2xpbmVIZWlnaHQnLCAnd2lkdGgnLCAndGV4dERlY29yYXRpb24nLCAndGV4dFNoYWRvdyddLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIFNWRyByZW5kZXJlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJlclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChyZW5kZXJlciwgbm9kZU5hbWUpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcztcblx0XHRcdHdyYXBwZXIuZWxlbWVudCA9IG5vZGVOYW1lID09PSAnc3BhbicgP1xuXHRcdFx0XHRjcmVhdGVFbGVtZW50KG5vZGVOYW1lKSA6XG5cdFx0XHRcdGRvYy5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBub2RlTmFtZSk7XG5cdFx0XHR3cmFwcGVyLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBbmltYXRlIGEgZ2l2ZW4gYXR0cmlidXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zIFRoZSBzYW1lIG9wdGlvbnMgYXMgaW4galF1ZXJ5IGFuaW1hdGlvblxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBsZXRlIEZ1bmN0aW9uIHRvIHBlcmZvcm0gYXQgdGhlIGVuZCBvZiBhbmltYXRpb25cblx0XHQgKi9cblx0XHRhbmltYXRlOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zLCBjb21wbGV0ZSkge1xuXHRcdFx0dmFyIGFuaW1PcHRpb25zID0gcGljayhvcHRpb25zLCBnbG9iYWxBbmltYXRpb24sIHRydWUpO1xuXHRcdFx0c3RvcCh0aGlzKTsgLy8gc3RvcCByZWdhcmRsZXNzIG9mIGFuaW1hdGlvbiBhY3R1YWxseSBydW5uaW5nLCBvciByZXZlcnRpbmcgdG8gLmF0dHIgKCM2MDcpXG5cdFx0XHRpZiAoYW5pbU9wdGlvbnMpIHtcblx0XHRcdFx0YW5pbU9wdGlvbnMgPSBtZXJnZShhbmltT3B0aW9ucywge30pOyAvLyMyNjI1XG5cdFx0XHRcdGlmIChjb21wbGV0ZSkgeyAvLyBhbGxvd3MgdXNpbmcgYSBjYWxsYmFjayB3aXRoIHRoZSBnbG9iYWwgYW5pbWF0aW9uIHdpdGhvdXQgb3ZlcndyaXRpbmcgaXRcblx0XHRcdFx0XHRhbmltT3B0aW9ucy5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFuaW1hdGUodGhpcywgcGFyYW1zLCBhbmltT3B0aW9ucyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmF0dHIocGFyYW1zKTtcblx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0Y29tcGxldGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEJ1aWxkIGFuIFNWRyBncmFkaWVudCBvdXQgb2YgYSBjb21tb24gSmF2YVNjcmlwdCBjb25maWd1cmF0aW9uIG9iamVjdFxuXHRcdCAqL1xuXHRcdGNvbG9yR3JhZGllbnQ6IGZ1bmN0aW9uIChjb2xvciwgcHJvcCwgZWxlbSkge1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcblx0XHRcdFx0Y29sb3JPYmplY3QsXG5cdFx0XHRcdGdyYWROYW1lLFxuXHRcdFx0XHRncmFkQXR0cixcblx0XHRcdFx0Z3JhZGllbnRzLFxuXHRcdFx0XHRncmFkaWVudE9iamVjdCxcblx0XHRcdFx0c3RvcHMsXG5cdFx0XHRcdHN0b3BDb2xvcixcblx0XHRcdFx0c3RvcE9wYWNpdHksXG5cdFx0XHRcdHJhZGlhbFJlZmVyZW5jZSxcblx0XHRcdFx0bixcblx0XHRcdFx0aWQsXG5cdFx0XHRcdGtleSA9IFtdO1xuXG5cdFx0XHQvLyBBcHBseSBsaW5lYXIgb3IgcmFkaWFsIGdyYWRpZW50c1xuXHRcdFx0aWYgKGNvbG9yLmxpbmVhckdyYWRpZW50KSB7XG5cdFx0XHRcdGdyYWROYW1lID0gJ2xpbmVhckdyYWRpZW50Jztcblx0XHRcdH0gZWxzZSBpZiAoY29sb3IucmFkaWFsR3JhZGllbnQpIHtcblx0XHRcdFx0Z3JhZE5hbWUgPSAncmFkaWFsR3JhZGllbnQnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ3JhZE5hbWUpIHtcblx0XHRcdFx0Z3JhZEF0dHIgPSBjb2xvcltncmFkTmFtZV07XG5cdFx0XHRcdGdyYWRpZW50cyA9IHJlbmRlcmVyLmdyYWRpZW50cztcblx0XHRcdFx0c3RvcHMgPSBjb2xvci5zdG9wcztcblx0XHRcdFx0cmFkaWFsUmVmZXJlbmNlID0gZWxlbS5yYWRpYWxSZWZlcmVuY2U7XG5cblx0XHRcdFx0Ly8gS2VlcCA8IDIuMiBrb21wYXRpYmlsaXR5XG5cdFx0XHRcdGlmIChpc0FycmF5KGdyYWRBdHRyKSkge1xuXHRcdFx0XHRcdGNvbG9yW2dyYWROYW1lXSA9IGdyYWRBdHRyID0ge1xuXHRcdFx0XHRcdFx0eDE6IGdyYWRBdHRyWzBdLFxuXHRcdFx0XHRcdFx0eTE6IGdyYWRBdHRyWzFdLFxuXHRcdFx0XHRcdFx0eDI6IGdyYWRBdHRyWzJdLFxuXHRcdFx0XHRcdFx0eTI6IGdyYWRBdHRyWzNdLFxuXHRcdFx0XHRcdFx0Z3JhZGllbnRVbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb3JyZWN0IHRoZSByYWRpYWwgZ3JhZGllbnQgZm9yIHRoZSByYWRpYWwgcmVmZXJlbmNlIHN5c3RlbVxuXHRcdFx0XHRpZiAoZ3JhZE5hbWUgPT09ICdyYWRpYWxHcmFkaWVudCcgJiYgcmFkaWFsUmVmZXJlbmNlICYmICFkZWZpbmVkKGdyYWRBdHRyLmdyYWRpZW50VW5pdHMpKSB7XG5cdFx0XHRcdFx0Z3JhZEF0dHIgPSBtZXJnZShncmFkQXR0ciwge1xuXHRcdFx0XHRcdFx0Y3g6IChyYWRpYWxSZWZlcmVuY2VbMF0gLSByYWRpYWxSZWZlcmVuY2VbMl0gLyAyKSArIGdyYWRBdHRyLmN4ICogcmFkaWFsUmVmZXJlbmNlWzJdLFxuXHRcdFx0XHRcdFx0Y3k6IChyYWRpYWxSZWZlcmVuY2VbMV0gLSByYWRpYWxSZWZlcmVuY2VbMl0gLyAyKSArIGdyYWRBdHRyLmN5ICogcmFkaWFsUmVmZXJlbmNlWzJdLFxuXHRcdFx0XHRcdFx0cjogZ3JhZEF0dHIuciAqIHJhZGlhbFJlZmVyZW5jZVsyXSxcblx0XHRcdFx0XHRcdGdyYWRpZW50VW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEJ1aWxkIHRoZSB1bmlxdWUga2V5IHRvIGRldGVjdCB3aGV0aGVyIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnQgKCMxMjgyKVxuXHRcdFx0XHRmb3IgKG4gaW4gZ3JhZEF0dHIpIHtcblx0XHRcdFx0XHRpZiAobiAhPT0gJ2lkJykge1xuXHRcdFx0XHRcdFx0a2V5LnB1c2gobiwgZ3JhZEF0dHJbbl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKG4gaW4gc3RvcHMpIHtcblx0XHRcdFx0XHRrZXkucHVzaChzdG9wc1tuXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5ID0ga2V5LmpvaW4oJywnKTtcblxuXHRcdFx0XHQvLyBDaGVjayBpZiBhIGdyYWRpZW50IG9iamVjdCB3aXRoIHRoZSBzYW1lIGNvbmZpZyBvYmplY3QgaXMgY3JlYXRlZCB3aXRoaW4gdGhpcyByZW5kZXJlclxuXHRcdFx0XHRpZiAoZ3JhZGllbnRzW2tleV0pIHtcblx0XHRcdFx0XHRpZCA9IGdyYWRpZW50c1trZXldLmF0dHIoJ2lkJyk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFNldCB0aGUgaWQgYW5kIGNyZWF0ZSB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGdyYWRBdHRyLmlkID0gaWQgPSBQUkVGSVggKyBpZENvdW50ZXIrKztcblx0XHRcdFx0XHRncmFkaWVudHNba2V5XSA9IGdyYWRpZW50T2JqZWN0ID0gcmVuZGVyZXIuY3JlYXRlRWxlbWVudChncmFkTmFtZSlcblx0XHRcdFx0XHRcdC5hdHRyKGdyYWRBdHRyKVxuXHRcdFx0XHRcdFx0LmFkZChyZW5kZXJlci5kZWZzKTtcblxuXG5cdFx0XHRcdFx0Ly8gVGhlIGdyYWRpZW50IG5lZWRzIHRvIGtlZXAgYSBsaXN0IG9mIHN0b3BzIHRvIGJlIGFibGUgdG8gZGVzdHJveSB0aGVtXG5cdFx0XHRcdFx0Z3JhZGllbnRPYmplY3Quc3RvcHMgPSBbXTtcblx0XHRcdFx0XHRlYWNoKHN0b3BzLCBmdW5jdGlvbiAoc3RvcCkge1xuXHRcdFx0XHRcdFx0dmFyIHN0b3BPYmplY3Q7XG5cdFx0XHRcdFx0XHRpZiAoc3RvcFsxXS5pbmRleE9mKCdyZ2JhJykgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0Y29sb3JPYmplY3QgPSBDb2xvcihzdG9wWzFdKTtcblx0XHRcdFx0XHRcdFx0c3RvcENvbG9yID0gY29sb3JPYmplY3QuZ2V0KCdyZ2InKTtcblx0XHRcdFx0XHRcdFx0c3RvcE9wYWNpdHkgPSBjb2xvck9iamVjdC5nZXQoJ2EnKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0b3BDb2xvciA9IHN0b3BbMV07XG5cdFx0XHRcdFx0XHRcdHN0b3BPcGFjaXR5ID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0b3BPYmplY3QgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KCdzdG9wJykuYXR0cih7XG5cdFx0XHRcdFx0XHRcdG9mZnNldDogc3RvcFswXSxcblx0XHRcdFx0XHRcdFx0J3N0b3AtY29sb3InOiBzdG9wQ29sb3IsXG5cdFx0XHRcdFx0XHRcdCdzdG9wLW9wYWNpdHknOiBzdG9wT3BhY2l0eVxuXHRcdFx0XHRcdFx0fSkuYWRkKGdyYWRpZW50T2JqZWN0KTtcblxuXHRcdFx0XHRcdFx0Ly8gQWRkIHRoZSBzdG9wIGVsZW1lbnQgdG8gdGhlIGdyYWRpZW50XG5cdFx0XHRcdFx0XHRncmFkaWVudE9iamVjdC5zdG9wcy5wdXNoKHN0b3BPYmplY3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGdyYWRpZW50IG9iamVjdFxuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZShwcm9wLCAndXJsKCcgKyByZW5kZXJlci51cmwgKyAnIycgKyBpZCArICcpJyk7XG5cdFx0XHR9IFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBcHBseSBhIHBvbHlmaWxsIHRvIHRoZSB0ZXh0LXN0cm9rZSBDU1MgcHJvcGVydHksIGJ5IGNvcHlpbmcgdGhlIHRleHQgZWxlbWVudFxuXHRcdCAqIGFuZCBhcHBseSBzdHJva2VzIHRvIHRoZSBjb3B5LlxuXHRcdCAqXG5cdFx0ICogZG9jczogdXBkYXRlIGRlZmF1bHQsIGRvY3VtZW50IHRoZSBwb2x5ZmlsbCBhbmQgdGhlIGxpbWl0YXRpb25zIG9uIGhleCBjb2xvcnMgYW5kIHBpeGVsIHZhbHVlcywgZG9jdW1lbnQgY29udHJhc3QgcHNldWRvLWNvbG9yXG5cdFx0ICogVE9ETzogXG5cdFx0ICogLSB1cGRhdGUgZGVmYXVsdHNcblx0XHQgKi9cblx0XHRhcHBseVRleHRTaGFkb3c6IGZ1bmN0aW9uICh0ZXh0U2hhZG93KSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0dHNwYW5zLFxuXHRcdFx0XHRoYXNDb250cmFzdCA9IHRleHRTaGFkb3cuaW5kZXhPZignY29udHJhc3QnKSAhPT0gLTEsXG5cdFx0XHRcdC8vIElFMTAgYW5kIElFMTEgcmVwb3J0IHRleHRTaGFkb3cgaW4gZWxlbS5zdHlsZSBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHdvcmsuIENoZWNrXG5cdFx0XHRcdC8vIHRoaXMgYWdhaW4gd2l0aCBuZXcgSUUgcmVsZWFzZS4gSW4gZXhwb3J0cywgdGhlIHJlbmRlcmluZyBpcyBwYXNzZWQgdG8gUGhhbnRvbUpTLiBcblx0XHRcdFx0c3VwcG9ydHMgPSB0aGlzLnJlbmRlcmVyLmZvckV4cG9ydCB8fCAoZWxlbS5zdHlsZS50ZXh0U2hhZG93ICE9PSBVTkRFRklORUQgJiYgIWlzSUUpO1xuXG5cdFx0XHQvLyBXaGVuIHRoZSB0ZXh0IHNoYWRvdyBpcyBzZXQgdG8gY29udHJhc3QsIHVzZSBkYXJrIHN0cm9rZSBmb3IgbGlnaHQgdGV4dCBhbmQgdmljZSB2ZXJzYVxuXHRcdFx0aWYgKGhhc0NvbnRyYXN0KSB7XG5cdFx0XHRcdHRleHRTaGFkb3cgPSB0ZXh0U2hhZG93LnJlcGxhY2UoL2NvbnRyYXN0L2csIHRoaXMucmVuZGVyZXIuZ2V0Q29udHJhc3QoZWxlbS5zdHlsZS5maWxsKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIFNlbGVjdGl2ZSBzaWRlLWJ5LXNpZGUgdGVzdGluZyBpbiBzdXBwb3J0ZWQgYnJvd3NlciAoaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzLzczTDFwdHJoLylcblx0XHRcdGlmIChlbGVtLnRleHRDb250ZW50LmluZGV4T2YoJzIuJykgPT09IDApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZVsndGV4dC1zaGFkb3cnXSA9ICdub25lJztcblx0XHRcdFx0c3VwcG9ydHMgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vICovXG5cblx0XHRcdC8vIE5vIHJlYXNvbiB0byBwb2x5ZmlsbCwgd2UndmUgZ290IG5hdGl2ZSBzdXBwb3J0XG5cdFx0XHRpZiAoc3VwcG9ydHMpIHtcblx0XHRcdFx0aWYgKGhhc0NvbnRyYXN0KSB7IC8vIEFwcGx5IHRoZSBhbHRlcmVkIHN0eWxlXG5cdFx0XHRcdFx0Y3NzKGVsZW0sIHtcblx0XHRcdFx0XHRcdHRleHRTaGFkb3c6IHRleHRTaGFkb3dcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmZha2VUUyA9IHRydWU7IC8vIEZha2UgdGV4dCBzaGFkb3dcblxuXHRcdFx0XHQvLyBJbiBvcmRlciB0byBnZXQgdGhlIHJpZ2h0IHkgcG9zaXRpb24gb2YgdGhlIGNsb25lcywgXG5cdFx0XHRcdC8vIGNvcHkgb3ZlciB0aGUgeSBzZXR0ZXJcblx0XHRcdFx0dGhpcy55U2V0dGVyID0gdGhpcy54U2V0dGVyO1xuXG5cdFx0XHRcdHRzcGFucyA9IFtdLnNsaWNlLmNhbGwoZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHNwYW4nKSk7XG5cdFx0XHRcdGVhY2godGV4dFNoYWRvdy5zcGxpdCgvXFxzPyxcXHM/L2cpLCBmdW5jdGlvbiAodGV4dFNoYWRvdykge1xuXHRcdFx0XHRcdHZhciBmaXJzdENoaWxkID0gZWxlbS5maXJzdENoaWxkLFxuXHRcdFx0XHRcdFx0Y29sb3IsXG5cdFx0XHRcdFx0XHRzdHJva2VXaWR0aDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0ZXh0U2hhZG93ID0gdGV4dFNoYWRvdy5zcGxpdCgnICcpO1xuXHRcdFx0XHRcdGNvbG9yID0gdGV4dFNoYWRvd1t0ZXh0U2hhZG93Lmxlbmd0aCAtIDFdO1xuXG5cdFx0XHRcdFx0Ly8gQXBwcm94aW1hdGVseSB0dW5lIHRoZSBzZXR0aW5ncyB0byB0aGUgdGV4dC1zaGFkb3cgYmVoYXZpb3VyXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSB0ZXh0U2hhZG93W3RleHRTaGFkb3cubGVuZ3RoIC0gMl07XG5cblx0XHRcdFx0XHRpZiAoc3Ryb2tlV2lkdGgpIHtcblx0XHRcdFx0XHRcdGVhY2godHNwYW5zLCBmdW5jdGlvbiAodHNwYW4sIHkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGNsb25lO1xuXG5cdFx0XHRcdFx0XHRcdC8vIExldCB0aGUgZmlyc3QgbGluZSBzdGFydCBhdCB0aGUgY29ycmVjdCBYIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdGlmICh5ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dHNwYW4uc2V0QXR0cmlidXRlKCd4JywgZWxlbS5nZXRBdHRyaWJ1dGUoJ3gnKSk7XG5cdFx0XHRcdFx0XHRcdFx0eSA9IGVsZW0uZ2V0QXR0cmlidXRlKCd5Jyk7XG5cdFx0XHRcdFx0XHRcdFx0dHNwYW4uc2V0QXR0cmlidXRlKCd5JywgeSB8fCAwKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoeSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBDcmVhdGUgdGhlIGNsb25lIGFuZCBhcHBseSBzaGFkb3cgcHJvcGVydGllc1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHRzcGFuLmNsb25lTm9kZSgxKTtcblx0XHRcdFx0XHRcdFx0YXR0cihjbG9uZSwge1xuXHRcdFx0XHRcdFx0XHRcdCdjbGFzcyc6IFBSRUZJWCArICd0ZXh0LXNoYWRvdycsXG5cdFx0XHRcdFx0XHRcdFx0J2ZpbGwnOiBjb2xvcixcblx0XHRcdFx0XHRcdFx0XHQnc3Ryb2tlJzogY29sb3IsXG5cdFx0XHRcdFx0XHRcdFx0J3N0cm9rZS1vcGFjaXR5JzogMSAvIG1hdGhNYXgocEludChzdHJva2VXaWR0aCksIDMpLFxuXHRcdFx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHQnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJ1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbnNlcnRCZWZvcmUoY2xvbmUsIGZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IG9yIGdldCBhIGdpdmVuIGF0dHJpYnV0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaGFzaFxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR8VW5kZWZpbmVkfSB2YWxcblx0XHQgKi9cblx0XHRhdHRyOiBmdW5jdGlvbiAoaGFzaCwgdmFsKSB7XG5cdFx0XHR2YXIga2V5LFxuXHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0aGFzU2V0U3ltYm9sU2l6ZSxcblx0XHRcdFx0cmV0ID0gdGhpcyxcblx0XHRcdFx0c2tpcEF0dHI7XG5cblx0XHRcdC8vIHNpbmdsZSBrZXktdmFsdWUgcGFpclxuXHRcdFx0aWYgKHR5cGVvZiBoYXNoID09PSAnc3RyaW5nJyAmJiB2YWwgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRrZXkgPSBoYXNoO1xuXHRcdFx0XHRoYXNoID0ge307XG5cdFx0XHRcdGhhc2hba2V5XSA9IHZhbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXNlZCBhcyBhIGdldHRlcjogZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHNlY29uZCBpcyB1bmRlZmluZWRcblx0XHRcdGlmICh0eXBlb2YgaGFzaCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0ID0gKHRoaXNbaGFzaCArICdHZXR0ZXInXSB8fCB0aGlzLl9kZWZhdWx0R2V0dGVyKS5jYWxsKHRoaXMsIGhhc2gsIGVsZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBzZXR0ZXJcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Zm9yIChrZXkgaW4gaGFzaCkge1xuXHRcdFx0XHRcdHZhbHVlID0gaGFzaFtrZXldO1xuXHRcdFx0XHRcdHNraXBBdHRyID0gZmFsc2U7XG5cblxuXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3ltYm9sTmFtZSAmJiAvXih4fHl8d2lkdGh8aGVpZ2h0fHJ8c3RhcnR8ZW5kfGlubmVyUnxhbmNob3JYfGFuY2hvclkpLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHRcdGlmICghaGFzU2V0U3ltYm9sU2l6ZSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN5bWJvbEF0dHIoaGFzaCk7XG5cdFx0XHRcdFx0XHRcdGhhc1NldFN5bWJvbFNpemUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2tpcEF0dHIgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aGlzLnJvdGF0aW9uICYmIChrZXkgPT09ICd4JyB8fCBrZXkgPT09ICd5JykpIHtcblx0XHRcdFx0XHRcdHRoaXMuZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoIXNraXBBdHRyKSB7XG5cdFx0XHRcdFx0XHQodGhpc1trZXkgKyAnU2V0dGVyJ10gfHwgdGhpcy5fZGVmYXVsdFNldHRlcikuY2FsbCh0aGlzLCB2YWx1ZSwga2V5LCBlbGVtZW50KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZXQgdGhlIHNoYWRvdyBmb2xsb3cgdGhlIG1haW4gZWxlbWVudFxuXHRcdFx0XHRcdGlmICh0aGlzLnNoYWRvd3MgJiYgL14od2lkdGh8aGVpZ2h0fHZpc2liaWxpdHl8eHx5fGR8dHJhbnNmb3JtfGN4fGN5fHIpJC8udGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZVNoYWRvd3Moa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHRyYW5zZm9ybS4gRG8gdGhpcyBvdXRzaWRlIHRoZSBsb29wIHRvIHByZXZlbnQgcmVkdW5kYW50IHVwZGF0aW5nIGZvciBiYXRjaCBzZXR0aW5nXG5cdFx0XHRcdC8vIG9mIGF0dHJpYnV0ZXMuXG5cdFx0XHRcdGlmICh0aGlzLmRvVHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdFx0XHR0aGlzLmRvVHJhbnNmb3JtID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblx0XHR1cGRhdGVTaGFkb3dzOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0dmFyIHNoYWRvd3MgPSB0aGlzLnNoYWRvd3MsXG5cdFx0XHRcdGkgPSBzaGFkb3dzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0c2hhZG93c1tpXS5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGtleSA9PT0gJ2hlaWdodCcgP1xuXHRcdFx0XHRcdFx0bWF0aE1heCh2YWx1ZSAtIChzaGFkb3dzW2ldLmN1dEhlaWdodCB8fCAwKSwgMCkgOlxuXHRcdFx0XHRcdFx0a2V5ID09PSAnZCcgPyB0aGlzLmQgOiB2YWx1ZVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGQgYSBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcblx0XHQgKi9cblx0XHRhZGRDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdGN1cnJlbnRDbGFzc05hbWUgPSBhdHRyKGVsZW1lbnQsICdjbGFzcycpIHx8ICcnO1xuXG5cdFx0XHRpZiAoY3VycmVudENsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZSkgPT09IC0xKSB7XG5cdFx0XHRcdGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgY3VycmVudENsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdC8qIGhhc0NsYXNzIGFuZCByZW1vdmVDbGFzcyBhcmUgbm90ICh5ZXQpIG5lZWRlZFxuXHRcdGhhc0NsYXNzOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRyZXR1cm4gYXR0cih0aGlzLmVsZW1lbnQsICdjbGFzcycpLmluZGV4T2YoY2xhc3NOYW1lKSAhPT0gLTE7XG5cdFx0fSxcblx0XHRyZW1vdmVDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHRcdFx0YXR0cih0aGlzLmVsZW1lbnQsICdjbGFzcycsIGF0dHIodGhpcy5lbGVtZW50LCAnY2xhc3MnKS5yZXBsYWNlKGNsYXNzTmFtZSwgJycpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cdFx0Ki9cblxuXHRcdC8qKlxuXHRcdCAqIElmIG9uZSBvZiB0aGUgc3ltYm9sIHNpemUgYWZmZWN0aW5nIHBhcmFtZXRlcnMgYXJlIGNoYW5nZWQsXG5cdFx0ICogY2hlY2sgYWxsIHRoZSBvdGhlcnMgb25seSBvbmNlIGZvciBlYWNoIGNhbGwgdG8gYW4gZWxlbWVudCdzXG5cdFx0ICogLmF0dHIoKSBtZXRob2Rcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaGFzaFxuXHRcdCAqL1xuXHRcdHN5bWJvbEF0dHI6IGZ1bmN0aW9uIChoYXNoKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXM7XG5cblx0XHRcdGVhY2goWyd4JywgJ3knLCAncicsICdzdGFydCcsICdlbmQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2lubmVyUicsICdhbmNob3JYJywgJ2FuY2hvclknXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHR3cmFwcGVyW2tleV0gPSBwaWNrKGhhc2hba2V5XSwgd3JhcHBlcltrZXldKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR3cmFwcGVyLmF0dHIoe1xuXHRcdFx0XHRkOiB3cmFwcGVyLnJlbmRlcmVyLnN5bWJvbHNbd3JhcHBlci5zeW1ib2xOYW1lXShcblx0XHRcdFx0XHR3cmFwcGVyLngsXG5cdFx0XHRcdFx0d3JhcHBlci55LFxuXHRcdFx0XHRcdHdyYXBwZXIud2lkdGgsXG5cdFx0XHRcdFx0d3JhcHBlci5oZWlnaHQsXG5cdFx0XHRcdFx0d3JhcHBlclxuXHRcdFx0XHQpXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgYSBjbGlwcGluZyBwYXRoIHRvIHRoaXMgb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlkXG5cdFx0ICovXG5cdFx0Y2xpcDogZnVuY3Rpb24gKGNsaXBSZWN0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwUmVjdCA/ICd1cmwoJyArIHRoaXMucmVuZGVyZXIudXJsICsgJyMnICsgY2xpcFJlY3QuaWQgKyAnKScgOiBOT05FKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlcyBuZWVkZWQgZm9yIGRyYXdpbmcgYSByZWN0YW5nbGUgY3Jpc3BseSBhbmQgcmV0dXJuIHRoZVxuXHRcdCAqIGNhbGN1bGF0ZWQgYXR0cmlidXRlc1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdHJva2VXaWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICovXG5cdFx0Y3Jpc3A6IGZ1bmN0aW9uIChyZWN0KSB7XG5cblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRhdHRyaWJzID0ge30sXG5cdFx0XHRcdG5vcm1hbGl6ZXIsXG5cdFx0XHRcdHN0cm9rZVdpZHRoID0gcmVjdC5zdHJva2VXaWR0aCB8fCB3cmFwcGVyLnN0cm9rZVdpZHRoIHx8IDA7XG5cblx0XHRcdG5vcm1hbGl6ZXIgPSBtYXRoUm91bmQoc3Ryb2tlV2lkdGgpICUgMiAvIDI7IC8vIG1hdGhSb3VuZCBiZWNhdXNlIHN0cm9rZVdpZHRoIGNhbiBzb21ldGltZXMgaGF2ZSByb3VuZG9mZiBlcnJvcnNcblxuXHRcdFx0Ly8gbm9ybWFsaXplIGZvciBjcmlzcCBlZGdlc1xuXHRcdFx0cmVjdC54ID0gbWF0aEZsb29yKHJlY3QueCB8fCB3cmFwcGVyLnggfHwgMCkgKyBub3JtYWxpemVyO1xuXHRcdFx0cmVjdC55ID0gbWF0aEZsb29yKHJlY3QueSB8fCB3cmFwcGVyLnkgfHwgMCkgKyBub3JtYWxpemVyO1xuXHRcdFx0cmVjdC53aWR0aCA9IG1hdGhGbG9vcigocmVjdC53aWR0aCB8fCB3cmFwcGVyLndpZHRoIHx8IDApIC0gMiAqIG5vcm1hbGl6ZXIpO1xuXHRcdFx0cmVjdC5oZWlnaHQgPSBtYXRoRmxvb3IoKHJlY3QuaGVpZ2h0IHx8IHdyYXBwZXIuaGVpZ2h0IHx8IDApIC0gMiAqIG5vcm1hbGl6ZXIpO1xuXHRcdFx0cmVjdC5zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoO1xuXG5cdFx0XHRmb3IgKGtleSBpbiByZWN0KSB7XG5cdFx0XHRcdGlmICh3cmFwcGVyW2tleV0gIT09IHJlY3Rba2V5XSkgeyAvLyBvbmx5IHNldCBhdHRyaWJ1dGUgaWYgY2hhbmdlZFxuXHRcdFx0XHRcdHdyYXBwZXJba2V5XSA9IGF0dHJpYnNba2V5XSA9IHJlY3Rba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXR0cmlicztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHN0eWxlcyBmb3IgdGhlIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG5cdFx0ICovXG5cdFx0Y3NzOiBmdW5jdGlvbiAoc3R5bGVzKSB7XG5cdFx0XHR2YXIgZWxlbVdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRvbGRTdHlsZXMgPSBlbGVtV3JhcHBlci5zdHlsZXMsXG5cdFx0XHRcdG5ld1N0eWxlcyA9IHt9LFxuXHRcdFx0XHRlbGVtID0gZWxlbVdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0dGV4dFdpZHRoLFxuXHRcdFx0XHRuLFxuXHRcdFx0XHRzZXJpYWxpemVkQ3NzID0gJycsXG5cdFx0XHRcdGh5cGhlbmF0ZSxcblx0XHRcdFx0aGFzTmV3ID0gIW9sZFN0eWxlcztcblxuXHRcdFx0Ly8gY29udmVydCBsZWdhY3lcblx0XHRcdGlmIChzdHlsZXMgJiYgc3R5bGVzLmNvbG9yKSB7XG5cdFx0XHRcdHN0eWxlcy5maWxsID0gc3R5bGVzLmNvbG9yO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IGV4aXN0aW5nIHN0eWxlcyB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZSAoIzI2NDApXG5cdFx0XHRpZiAob2xkU3R5bGVzKSB7XG5cdFx0XHRcdGZvciAobiBpbiBzdHlsZXMpIHtcblx0XHRcdFx0XHRpZiAoc3R5bGVzW25dICE9PSBvbGRTdHlsZXNbbl0pIHtcblx0XHRcdFx0XHRcdG5ld1N0eWxlc1tuXSA9IHN0eWxlc1tuXTtcblx0XHRcdFx0XHRcdGhhc05ldyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzTmV3KSB7XG5cdFx0XHRcdHRleHRXaWR0aCA9IGVsZW1XcmFwcGVyLnRleHRXaWR0aCA9IFxuXHRcdFx0XHRcdChzdHlsZXMgJiYgc3R5bGVzLndpZHRoICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQnICYmIHBJbnQoc3R5bGVzLndpZHRoKSkgfHwgXG5cdFx0XHRcdFx0ZWxlbVdyYXBwZXIudGV4dFdpZHRoOyAvLyAjMzUwMVxuXG5cdFx0XHRcdC8vIE1lcmdlIHRoZSBuZXcgc3R5bGVzIHdpdGggdGhlIG9sZCBvbmVzXG5cdFx0XHRcdGlmIChvbGRTdHlsZXMpIHtcblx0XHRcdFx0XHRzdHlsZXMgPSBleHRlbmQoXG5cdFx0XHRcdFx0XHRvbGRTdHlsZXMsXG5cdFx0XHRcdFx0XHRuZXdTdHlsZXNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XHRcdFxuXG5cdFx0XHRcdC8vIHN0b3JlIG9iamVjdFxuXHRcdFx0XHRlbGVtV3JhcHBlci5zdHlsZXMgPSBzdHlsZXM7XG5cblx0XHRcdFx0aWYgKHRleHRXaWR0aCAmJiAodXNlQ2FuVkcgfHwgKCFoYXNTVkcgJiYgZWxlbVdyYXBwZXIucmVuZGVyZXIuZm9yRXhwb3J0KSkpIHtcblx0XHRcdFx0XHRkZWxldGUgc3R5bGVzLndpZHRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2VyaWFsaXplIGFuZCBzZXQgc3R5bGUgYXR0cmlidXRlXG5cdFx0XHRcdGlmIChpc0lFICYmICFoYXNTVkcpIHtcblx0XHRcdFx0XHRjc3MoZWxlbVdyYXBwZXIuZWxlbWVudCwgc3R5bGVzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKmpzbGludCB1bnBhcmFtOiB0cnVlKi9cblx0XHRcdFx0XHRoeXBoZW5hdGUgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gJy0nICsgYi50b0xvd2VyQ2FzZSgpOyB9O1xuXHRcdFx0XHRcdC8qanNsaW50IHVucGFyYW06IGZhbHNlKi9cblx0XHRcdFx0XHRmb3IgKG4gaW4gc3R5bGVzKSB7XG5cdFx0XHRcdFx0XHRzZXJpYWxpemVkQ3NzICs9IG4ucmVwbGFjZSgvKFtBLVpdKS9nLCBoeXBoZW5hdGUpICsgJzonICsgc3R5bGVzW25dICsgJzsnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhdHRyKGVsZW0sICdzdHlsZScsIHNlcmlhbGl6ZWRDc3MpOyAvLyAjMTg4MVxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyByZS1idWlsZCB0ZXh0XG5cdFx0XHRcdGlmICh0ZXh0V2lkdGggJiYgZWxlbVdyYXBwZXIuYWRkZWQpIHtcblx0XHRcdFx0XHRlbGVtV3JhcHBlci5yZW5kZXJlci5idWlsZFRleHQoZWxlbVdyYXBwZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtV3JhcHBlcjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcblx0XHQgKi9cblx0XHRvbjogZnVuY3Rpb24gKGV2ZW50VHlwZSwgaGFuZGxlcikge1xuXHRcdFx0dmFyIHN2Z0VsZW1lbnQgPSB0aGlzLFxuXHRcdFx0XHRlbGVtZW50ID0gc3ZnRWxlbWVudC5lbGVtZW50O1xuXHRcdFx0XG5cdFx0XHQvLyB0b3VjaFxuXHRcdFx0aWYgKGhhc1RvdWNoICYmIGV2ZW50VHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRlbGVtZW50Lm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlKSB7XHRcdFx0XG5cdFx0XHRcdFx0c3ZnRWxlbWVudC50b3VjaEV2ZW50RmlyZWQgPSBEYXRlLm5vdygpO1x0XHRcdFx0XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdGhhbmRsZXIuY2FsbChlbGVtZW50LCBlKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0ZWxlbWVudC5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAodXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA9PT0gLTEgfHwgRGF0ZS5ub3coKSAtIChzdmdFbGVtZW50LnRvdWNoRXZlbnRGaXJlZCB8fCAwKSA+IDExMDApIHsgLy8gIzIyNjlcblx0XHRcdFx0XHRcdGhhbmRsZXIuY2FsbChlbGVtZW50LCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XHRcdFx0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBzaW1wbGVzdCBwb3NzaWJsZSBldmVudCBtb2RlbCBmb3IgaW50ZXJuYWwgdXNlXG5cdFx0XHRcdGVsZW1lbnRbJ29uJyArIGV2ZW50VHlwZV0gPSBoYW5kbGVyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgY29vcmRpbmF0ZXMgbmVlZGVkIHRvIGRyYXcgYSBjb25zaXN0ZW50IHJhZGlhbCBncmFkaWVudCBhY3Jvc3Ncblx0XHQgKiBwaWUgc2xpY2VzIHJlZ2FyZGxlc3Mgb2YgcG9zaXRpb25pbmcgaW5zaWRlIHRoZSBjaGFydC4gVGhlIGZvcm1hdCBpc1xuXHRcdCAqIFtjZW50ZXJYLCBjZW50ZXJZLCBkaWFtZXRlcl0gaW4gcGl4ZWxzLlxuXHRcdCAqL1xuXHRcdHNldFJhZGlhbFJlZmVyZW5jZTogZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucmFkaWFsUmVmZXJlbmNlID0gY29vcmRpbmF0ZXM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTW92ZSBhbiBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbiBieSB4IGFuZCB5IHZhbHVlc1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKi9cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKHtcblx0XHRcdFx0dHJhbnNsYXRlWDogeCxcblx0XHRcdFx0dHJhbnNsYXRlWTogeVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEludmVydCBhIGdyb3VwLCByb3RhdGUgYW5kIGZsaXBcblx0XHQgKi9cblx0XHRpbnZlcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcztcblx0XHRcdHdyYXBwZXIuaW52ZXJ0ZWQgPSB0cnVlO1xuXHRcdFx0d3JhcHBlci51cGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQcml2YXRlIG1ldGhvZCB0byB1cGRhdGUgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgYmFzZWQgb24gaW50ZXJuYWxcblx0XHQgKiBwcm9wZXJ0aWVzXG5cdFx0ICovXG5cdFx0dXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdHRyYW5zbGF0ZVggPSB3cmFwcGVyLnRyYW5zbGF0ZVggfHwgMCxcblx0XHRcdFx0dHJhbnNsYXRlWSA9IHdyYXBwZXIudHJhbnNsYXRlWSB8fCAwLFxuXHRcdFx0XHRzY2FsZVggPSB3cmFwcGVyLnNjYWxlWCxcblx0XHRcdFx0c2NhbGVZID0gd3JhcHBlci5zY2FsZVksXG5cdFx0XHRcdGludmVydGVkID0gd3JhcHBlci5pbnZlcnRlZCxcblx0XHRcdFx0cm90YXRpb24gPSB3cmFwcGVyLnJvdGF0aW9uLFxuXHRcdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0XHR0cmFuc2Zvcm07XG5cblx0XHRcdC8vIGZsaXBwaW5nIGFmZmVjdHMgdHJhbnNsYXRlIGFzIGFkanVzdG1lbnQgZm9yIGZsaXBwaW5nIGFyb3VuZCB0aGUgZ3JvdXAncyBheGlzXG5cdFx0XHRpZiAoaW52ZXJ0ZWQpIHtcblx0XHRcdFx0dHJhbnNsYXRlWCArPSB3cmFwcGVyLmF0dHIoJ3dpZHRoJyk7XG5cdFx0XHRcdHRyYW5zbGF0ZVkgKz0gd3JhcHBlci5hdHRyKCdoZWlnaHQnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgdHJhbnNsYXRlLiBOZWFybHkgYWxsIHRyYW5zZm9ybWVkIGVsZW1lbnRzIGhhdmUgdHJhbnNsYXRpb24sIHNvIGluc3RlYWRcblx0XHRcdC8vIG9mIGNoZWNraW5nIGZvciB0cmFuc2xhdGUgPSAwLCBkbyBpdCBhbHdheXMgKCMxNzY3LCAjMTg0NikuXG5cdFx0XHR0cmFuc2Zvcm0gPSBbJ3RyYW5zbGF0ZSgnICsgdHJhbnNsYXRlWCArICcsJyArIHRyYW5zbGF0ZVkgKyAnKSddO1xuXG5cdFx0XHQvLyBhcHBseSByb3RhdGlvblxuXHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdHRyYW5zZm9ybS5wdXNoKCdyb3RhdGUoOTApIHNjYWxlKC0xLDEpJyk7XG5cdFx0XHR9IGVsc2UgaWYgKHJvdGF0aW9uKSB7IC8vIHRleHQgcm90YXRpb25cblx0XHRcdFx0dHJhbnNmb3JtLnB1c2goJ3JvdGF0ZSgnICsgcm90YXRpb24gKyAnICcgKyAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwKSArICcgJyArIChlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDApICsgJyknKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIERlbGV0ZSBiQm94IG1lbW8gd2hlbiB0aGUgcm90YXRpb24gY2hhbmdlc1xuXHRcdFx0XHQvL2RlbGV0ZSB3cmFwcGVyLmJCb3g7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFwcGx5IHNjYWxlXG5cdFx0XHRpZiAoZGVmaW5lZChzY2FsZVgpIHx8IGRlZmluZWQoc2NhbGVZKSkge1xuXHRcdFx0XHR0cmFuc2Zvcm0ucHVzaCgnc2NhbGUoJyArIHBpY2soc2NhbGVYLCAxKSArICcgJyArIHBpY2soc2NhbGVZLCAxKSArICcpJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0cmFuc2Zvcm0ubGVuZ3RoKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0uam9pbignICcpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEJyaW5nIHRoZSBlbGVtZW50IHRvIHRoZSBmcm9udFxuXHRcdCAqL1xuXHRcdHRvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogQnJlYWsgZG93biBhbGlnbm1lbnQgb3B0aW9ucyBsaWtlIGFsaWduLCB2ZXJ0aWNhbEFsaWduLCB4IGFuZCB5XG5cdFx0ICogdG8geCBhbmQgeSByZWxhdGl2ZSB0byB0aGUgY2hhcnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gYWxpZ25PcHRpb25zXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBhbGlnbkJ5VHJhbnNsYXRlXG5cdFx0ICogQHBhcmFtIHtTdHJpbmdbT2JqZWN0fSBib3ggVGhlIGJveCB0byBhbGlnbiB0bywgbmVlZHMgYSB3aWR0aCBhbmQgaGVpZ2h0LiBXaGVuIHRoZVxuXHRcdCAqXHRcdGJveCBpcyBhIHN0cmluZywgaXQgcmVmZXJzIHRvIGFuIG9iamVjdCBpbiB0aGUgUmVuZGVyZXIuIEZvciBleGFtcGxlLCB3aGVuXG5cdFx0ICpcdFx0Ym94IGlzICdzcGFjaW5nQm94JywgaXQgcmVmZXJzIHRvIFJlbmRlcmVyLnNwYWNpbmdCb3ggd2hpY2ggaG9sZHMgd2lkdGgsIGhlaWdodFxuXHRcdCAqXHRcdHggYW5kIHkgcHJvcGVydGllcy5cblx0XHQgKlxuXHRcdCAqL1xuXHRcdGFsaWduOiBmdW5jdGlvbiAoYWxpZ25PcHRpb25zLCBhbGlnbkJ5VHJhbnNsYXRlLCBib3gpIHtcblx0XHRcdHZhciBhbGlnbixcblx0XHRcdFx0dkFsaWduLFxuXHRcdFx0XHR4LFxuXHRcdFx0XHR5LFxuXHRcdFx0XHRhdHRyaWJzID0ge30sXG5cdFx0XHRcdGFsaWduVG8sXG5cdFx0XHRcdHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcblx0XHRcdFx0YWxpZ25lZE9iamVjdHMgPSByZW5kZXJlci5hbGlnbmVkT2JqZWN0cztcblxuXHRcdFx0Ly8gRmlyc3QgY2FsbCBvbiBpbnN0YW5jaWF0ZVxuXHRcdFx0aWYgKGFsaWduT3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLmFsaWduT3B0aW9ucyA9IGFsaWduT3B0aW9ucztcblx0XHRcdFx0dGhpcy5hbGlnbkJ5VHJhbnNsYXRlID0gYWxpZ25CeVRyYW5zbGF0ZTtcblx0XHRcdFx0aWYgKCFib3ggfHwgaXNTdHJpbmcoYm94KSkgeyAvLyBib3hlcyBvdGhlciB0aGFuIHJlbmRlcmVyIGhhbmRsZSB0aGlzIGludGVybmFsbHlcblx0XHRcdFx0XHR0aGlzLmFsaWduVG8gPSBhbGlnblRvID0gYm94IHx8ICdyZW5kZXJlcic7XG5cdFx0XHRcdFx0ZXJhc2UoYWxpZ25lZE9iamVjdHMsIHRoaXMpOyAvLyBwcmV2ZW50IGR1cGxpY2F0ZXMsIGxpa2UgbGVnZW5kR3JvdXAgYWZ0ZXIgcmVzaXplXG5cdFx0XHRcdFx0YWxpZ25lZE9iamVjdHMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHRib3ggPSBudWxsOyAvLyByZWFzc2lnbiBpdCBiZWxvd1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFdoZW4gY2FsbGVkIG9uIHJlc2l6ZSwgbm8gYXJndW1lbnRzIGFyZSBzdXBwbGllZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWxpZ25PcHRpb25zID0gdGhpcy5hbGlnbk9wdGlvbnM7XG5cdFx0XHRcdGFsaWduQnlUcmFuc2xhdGUgPSB0aGlzLmFsaWduQnlUcmFuc2xhdGU7XG5cdFx0XHRcdGFsaWduVG8gPSB0aGlzLmFsaWduVG87XG5cdFx0XHR9XG5cblx0XHRcdGJveCA9IHBpY2soYm94LCByZW5kZXJlclthbGlnblRvXSwgcmVuZGVyZXIpO1xuXG5cdFx0XHQvLyBBc3NpZ24gdmFyaWFibGVzXG5cdFx0XHRhbGlnbiA9IGFsaWduT3B0aW9ucy5hbGlnbjtcblx0XHRcdHZBbGlnbiA9IGFsaWduT3B0aW9ucy52ZXJ0aWNhbEFsaWduO1xuXHRcdFx0eCA9IChib3gueCB8fCAwKSArIChhbGlnbk9wdGlvbnMueCB8fCAwKTsgLy8gZGVmYXVsdDogbGVmdCBhbGlnblxuXHRcdFx0eSA9IChib3gueSB8fCAwKSArIChhbGlnbk9wdGlvbnMueSB8fCAwKTsgLy8gZGVmYXVsdDogdG9wIGFsaWduXG5cblx0XHRcdC8vIEFsaWduXG5cdFx0XHRpZiAoYWxpZ24gPT09ICdyaWdodCcgfHwgYWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRcdHggKz0gKGJveC53aWR0aCAtIChhbGlnbk9wdGlvbnMud2lkdGggfHwgMCkpIC9cblx0XHRcdFx0XHRcdHsgcmlnaHQ6IDEsIGNlbnRlcjogMiB9W2FsaWduXTtcblx0XHRcdH1cblx0XHRcdGF0dHJpYnNbYWxpZ25CeVRyYW5zbGF0ZSA/ICd0cmFuc2xhdGVYJyA6ICd4J10gPSBtYXRoUm91bmQoeCk7XG5cblxuXHRcdFx0Ly8gVmVydGljYWwgYWxpZ25cblx0XHRcdGlmICh2QWxpZ24gPT09ICdib3R0b20nIHx8IHZBbGlnbiA9PT0gJ21pZGRsZScpIHtcblx0XHRcdFx0eSArPSAoYm94LmhlaWdodCAtIChhbGlnbk9wdGlvbnMuaGVpZ2h0IHx8IDApKSAvXG5cdFx0XHRcdFx0XHQoeyBib3R0b206IDEsIG1pZGRsZTogMiB9W3ZBbGlnbl0gfHwgMSk7XG5cblx0XHRcdH1cblx0XHRcdGF0dHJpYnNbYWxpZ25CeVRyYW5zbGF0ZSA/ICd0cmFuc2xhdGVZJyA6ICd5J10gPSBtYXRoUm91bmQoeSk7XG5cblx0XHRcdC8vIEFuaW1hdGUgb25seSBpZiBhbHJlYWR5IHBsYWNlZFxuXHRcdFx0dGhpc1t0aGlzLnBsYWNlZCA/ICdhbmltYXRlJyA6ICdhdHRyJ10oYXR0cmlicyk7XG5cdFx0XHR0aGlzLnBsYWNlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmFsaWduQXR0ciA9IGF0dHJpYnM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGJvdW5kaW5nIGJveCAod2lkdGgsIGhlaWdodCwgeCBhbmQgeSkgZm9yIHRoZSBlbGVtZW50XG5cdFx0ICovXG5cdFx0Z2V0QkJveDogZnVuY3Rpb24gKHJlbG9hZCkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRiQm94LC8vID0gd3JhcHBlci5iQm94LFxuXHRcdFx0XHRyZW5kZXJlciA9IHdyYXBwZXIucmVuZGVyZXIsXG5cdFx0XHRcdHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQsXG5cdFx0XHRcdHJvdGF0aW9uID0gd3JhcHBlci5yb3RhdGlvbixcblx0XHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0c3R5bGVzID0gd3JhcHBlci5zdHlsZXMsXG5cdFx0XHRcdHJhZCA9IHJvdGF0aW9uICogZGVnMnJhZCxcblx0XHRcdFx0dGV4dFN0ciA9IHdyYXBwZXIudGV4dFN0cixcblx0XHRcdFx0dGV4dFNoYWRvdyxcblx0XHRcdFx0ZWxlbVN0eWxlID0gZWxlbWVudC5zdHlsZSxcblx0XHRcdFx0dG9nZ2xlVGV4dFNoYWRvd1NoaW0sXG5cdFx0XHRcdGNhY2hlS2V5O1xuXG5cdFx0XHRpZiAodGV4dFN0ciAhPT0gVU5ERUZJTkVEKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGVydGllcyB0aGF0IGFmZmVjdCBib3VuZGluZyBib3hcblx0XHRcdFx0Y2FjaGVLZXkgPSBbJycsIHJvdGF0aW9uIHx8IDAsIHN0eWxlcyAmJiBzdHlsZXMuZm9udFNpemUsIGVsZW1lbnQuc3R5bGUud2lkdGhdLmpvaW4oJywnKTtcblxuXHRcdFx0XHQvLyBTaW5jZSBudW1iZXJzIGFyZSBtb25vc3BhY2VkLCBhbmQgbnVtZXJpY2FsIGxhYmVscyBhcHBlYXIgYSBsb3QgaW4gYSBjaGFydCxcblx0XHRcdFx0Ly8gd2UgYXNzdW1lIHRoYXQgYSBsYWJlbCBvZiBuIGNoYXJhY3RlcnMgaGFzIHRoZSBzYW1lIGJvdW5kaW5nIGJveCBhcyBvdGhlcnMgXG5cdFx0XHRcdC8vIG9mIHRoZSBzYW1lIGxlbmd0aC5cblx0XHRcdFx0aWYgKHRleHRTdHIgPT09ICcnIHx8IG51bVJlZ2V4LnRlc3QodGV4dFN0cikpIHtcblx0XHRcdFx0XHRjYWNoZUtleSA9ICdudW06JyArIHRleHRTdHIudG9TdHJpbmcoKS5sZW5ndGggKyBjYWNoZUtleTtcblxuXHRcdFx0XHQvLyBDYWNoaW5nIGFsbCBzdHJpbmdzIHJlZHVjZXMgcmVuZGVyaW5nIHRpbWUgYnkgNC01JS5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYWNoZUtleSA9IHRleHRTdHIgKyBjYWNoZUtleTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2FjaGVLZXkgJiYgIXJlbG9hZCkge1xuXHRcdFx0XHRiQm94ID0gcmVuZGVyZXIuY2FjaGVbY2FjaGVLZXldO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBObyBjYWNoZSBmb3VuZFxuXHRcdFx0aWYgKCFiQm94KSB7XG5cblx0XHRcdFx0Ly8gU1ZHIGVsZW1lbnRzXG5cdFx0XHRcdGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05TIHx8IHJlbmRlcmVyLmZvckV4cG9ydCkge1xuXHRcdFx0XHRcdHRyeSB7IC8vIEZhaWxzIGluIEZpcmVmb3ggaWYgdGhlIGNvbnRhaW5lciBoYXMgZGlzcGxheTogbm9uZS5cblxuXHRcdFx0XHRcdFx0Ly8gV2hlbiB0aGUgdGV4dCBzaGFkb3cgc2hpbSBpcyB1c2VkLCB3ZSBuZWVkIHRvIGhpZGUgdGhlIGZha2Ugc2hhZG93c1xuXHRcdFx0XHRcdFx0Ly8gdG8gZ2V0IHRoZSBjb3JyZWN0IGJvdW5kaW5nIGJveCAoIzM4NzIpXG5cdFx0XHRcdFx0XHR0b2dnbGVUZXh0U2hhZG93U2hpbSA9IHRoaXMuZmFrZVRTICYmIGZ1bmN0aW9uIChkaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHRcdGVhY2goZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIFBSRUZJWCArICd0ZXh0LXNoYWRvdycpLCBmdW5jdGlvbiAodHNwYW4pIHtcblx0XHRcdFx0XHRcdFx0XHR0c3Bhbi5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyBXb3JrYXJvdW5kIGZvciAjMzg0MiwgRmlyZWZveCByZXBvcnRpbmcgd3JvbmcgYm91bmRpbmcgYm94IGZvciBzaGFkb3dzXG5cdFx0XHRcdFx0XHRpZiAoaXNGaXJlZm94ICYmIGVsZW1TdHlsZS50ZXh0U2hhZG93KSB7XG5cdFx0XHRcdFx0XHRcdHRleHRTaGFkb3cgPSBlbGVtU3R5bGUudGV4dFNoYWRvdztcblx0XHRcdFx0XHRcdFx0ZWxlbVN0eWxlLnRleHRTaGFkb3cgPSAnJztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodG9nZ2xlVGV4dFNoYWRvd1NoaW0pIHtcblx0XHRcdFx0XHRcdFx0dG9nZ2xlVGV4dFNoYWRvd1NoaW0oTk9ORSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJCb3ggPSBlbGVtZW50LmdldEJCb3ggP1xuXHRcdFx0XHRcdFx0XHQvLyBTVkc6IHVzZSBleHRlbmQgYmVjYXVzZSBJRTkgaXMgbm90IGFsbG93ZWQgdG8gY2hhbmdlIHdpZHRoIGFuZCBoZWlnaHQgaW4gY2FzZVxuXHRcdFx0XHRcdFx0XHQvLyBvZiByb3RhdGlvbiAoYmVsb3cpXG5cdFx0XHRcdFx0XHRcdGV4dGVuZCh7fSwgZWxlbWVudC5nZXRCQm94KCkpIDpcblx0XHRcdFx0XHRcdFx0Ly8gQ2FudmFzIHJlbmRlcmVyIGFuZCBsZWdhY3kgSUUgaW4gZXhwb3J0IG1vZGVcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcblx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Ly8gIzM4NDJcblx0XHRcdFx0XHRcdGlmICh0ZXh0U2hhZG93KSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1TdHlsZS50ZXh0U2hhZG93ID0gdGV4dFNoYWRvdztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodG9nZ2xlVGV4dFNoYWRvd1NoaW0pIHtcblx0XHRcdFx0XHRcdFx0dG9nZ2xlVGV4dFNoYWRvd1NoaW0oJycpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgYkJveCBpcyBub3Qgc2V0LCB0aGUgdHJ5LWNhdGNoIGJsb2NrIGFib3ZlIGZhaWxlZC4gVGhlIG90aGVyIGNvbmRpdGlvblxuXHRcdFx0XHRcdC8vIGlzIGZvciBPcGVyYSB0aGF0IHJldHVybnMgYSB3aWR0aCBvZiAtSW5maW5pdHkgb24gaGlkZGVuIGVsZW1lbnRzLlxuXHRcdFx0XHRcdGlmICghYkJveCB8fCBiQm94LndpZHRoIDwgMCkge1xuXHRcdFx0XHRcdFx0YkJveCA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vIFZNTCBSZW5kZXJlciBvciB1c2VIVE1MIHdpdGhpbiBTVkdcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGJCb3ggPSB3cmFwcGVyLmh0bWxHZXRCQm94KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRydWUgU1ZHIGVsZW1lbnRzIGFzIHdlbGwgYXMgSFRNTCBlbGVtZW50cyBpbiBtb2Rlcm4gYnJvd3NlcnMgdXNpbmcgdGhlIC51c2VIVE1MIG9wdGlvblxuXHRcdFx0XHQvLyBuZWVkIHRvIGNvbXBlbnNhdGVkIGZvciByb3RhdGlvblxuXHRcdFx0XHRpZiAocmVuZGVyZXIuaXNTVkcpIHtcblx0XHRcdFx0XHR3aWR0aCA9IGJCb3gud2lkdGg7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gYkJveC5oZWlnaHQ7XG5cblx0XHRcdFx0XHQvLyBXb3JrYXJvdW5kIGZvciB3cm9uZyBib3VuZGluZyBib3ggaW4gSUU5IGFuZCBJRTEwICgjMTEwMSwgIzE1MDUsICMxNjY5LCAjMjU2OClcblx0XHRcdFx0XHRpZiAoaXNJRSAmJiBzdHlsZXMgJiYgc3R5bGVzLmZvbnRTaXplID09PSAnMTFweCcgJiYgaGVpZ2h0LnRvUHJlY2lzaW9uKDMpID09PSAnMTYuOScpIHtcblx0XHRcdFx0XHRcdGJCb3guaGVpZ2h0ID0gaGVpZ2h0ID0gMTQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IGZvciByb3RhdGVkIHRleHRcblx0XHRcdFx0XHRpZiAocm90YXRpb24pIHtcblx0XHRcdFx0XHRcdGJCb3gud2lkdGggPSBtYXRoQWJzKGhlaWdodCAqIG1hdGhTaW4ocmFkKSkgKyBtYXRoQWJzKHdpZHRoICogbWF0aENvcyhyYWQpKTtcblx0XHRcdFx0XHRcdGJCb3guaGVpZ2h0ID0gbWF0aEFicyhoZWlnaHQgKiBtYXRoQ29zKHJhZCkpICsgbWF0aEFicyh3aWR0aCAqIG1hdGhTaW4ocmFkKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FjaGUgaXRcblx0XHRcdFx0cmVuZGVyZXIuY2FjaGVbY2FjaGVLZXldID0gYkJveDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBiQm94O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTaG93IHRoZSBlbGVtZW50XG5cdFx0ICovXG5cdFx0c2hvdzogZnVuY3Rpb24gKGluaGVyaXQpIHtcblx0XHRcdC8vIElFOS0xMSBkb2Vzbid0IGhhbmRsZSB2aXNpYmlsdHk6aW5oZXJpdCB3ZWxsLCBzbyB3ZSByZW1vdmUgdGhlIGF0dHJpYnV0ZSBpbnN0ZWFkICgjMjg4MSlcblx0XHRcdGlmIChpbmhlcml0ICYmIHRoaXMuZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OUykge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd2aXNpYmlsaXR5Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmF0dHIoeyB2aXNpYmlsaXR5OiBpbmhlcml0ID8gJ2luaGVyaXQnIDogVklTSUJMRSB9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaWRlIHRoZSBlbGVtZW50XG5cdFx0ICovXG5cdFx0aGlkZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0cih7IHZpc2liaWxpdHk6IEhJRERFTiB9KTtcblx0XHR9LFxuXG5cdFx0ZmFkZU91dDogZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgZWxlbVdyYXBwZXIgPSB0aGlzO1xuXHRcdFx0ZWxlbVdyYXBwZXIuYW5pbWF0ZSh7XG5cdFx0XHRcdG9wYWNpdHk6IDBcblx0XHRcdH0sIHtcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uIHx8IDE1MCxcblx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRlbGVtV3JhcHBlci5hdHRyKHsgeTogLTk5OTkgfSk7IC8vICMzMDg4LCBhc3N1bWluZyB3ZSdyZSBvbmx5IHVzaW5nIHRoaXMgZm9yIHRvb2x0aXBzXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGQgdGhlIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdHxVbmRlZmluZWR9IHBhcmVudCBDYW4gYmUgYW4gZWxlbWVudCwgYW4gZWxlbWVudCB3cmFwcGVyIG9yIHVuZGVmaW5lZFxuXHRcdCAqXHR0byBhcHBlbmQgdGhlIGVsZW1lbnQgdG8gdGhlIHJlbmRlcmVyLmJveC5cblx0XHQgKi9cblx0XHRhZGQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcblxuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0aW5zZXJ0ZWQ7XG5cblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnRHcm91cCA9IHBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbWFyayBhcyBpbnZlcnRlZFxuXHRcdFx0dGhpcy5wYXJlbnRJbnZlcnRlZCA9IHBhcmVudCAmJiBwYXJlbnQuaW52ZXJ0ZWQ7XG5cblx0XHRcdC8vIGJ1aWxkIGZvcm1hdHRlZCB0ZXh0XG5cdFx0XHRpZiAodGhpcy50ZXh0U3RyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmVuZGVyZXIuYnVpbGRUZXh0KHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXJrIGFzIGFkZGVkXG5cdFx0XHR0aGlzLmFkZGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gSWYgd2UncmUgYWRkaW5nIHRvIHJlbmRlcmVyIHJvb3QsIG9yIG90aGVyIGVsZW1lbnRzIGluIHRoZSBncm91cCBcblx0XHRcdC8vIGhhdmUgYSB6IGluZGV4LCB3ZSBuZWVkIHRvIGhhbmRsZSBpdFxuXHRcdFx0aWYgKCFwYXJlbnQgfHwgcGFyZW50LmhhbmRsZVogfHwgdGhpcy56SW5kZXgpIHtcblx0XHRcdFx0aW5zZXJ0ZWQgPSB0aGlzLnpJbmRleFNldHRlcigpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB6SW5kZXggaXMgbm90IGhhbmRsZWQsIGFwcGVuZCBhdCB0aGUgZW5kXG5cdFx0XHRpZiAoIWluc2VydGVkKSB7XG5cdFx0XHRcdChwYXJlbnQgPyBwYXJlbnQuZWxlbWVudCA6IHJlbmRlcmVyLmJveCkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZpcmUgYW4gZXZlbnQgZm9yIGludGVybmFsIGhvb2tzXG5cdFx0XHRpZiAodGhpcy5vbkFkZCkge1xuXHRcdFx0XHR0aGlzLm9uQWRkKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIGEgY2hpbGQgZWl0aGVyIGJ5IHJlbW92ZUNoaWxkIG9yIG1vdmUgdG8gZ2FyYmFnZUJpbi5cblx0XHQgKiBJc3N1ZSA0OTA7IGluIFZNTCByZW1vdmVDaGlsZCByZXN1bHRzIGluIE9ycGhhbmVkIG5vZGVzIGFjY29yZGluZyB0byBzSUV2ZSwgZGlzY2FyZEVsZW1lbnQgZG9lcyBub3QuXG5cdFx0ICovXG5cdFx0c2FmZVJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0dmFyIHBhcmVudE5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0XHRpZiAocGFyZW50Tm9kZSkge1xuXHRcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95IHRoZSBlbGVtZW50IGFuZCBlbGVtZW50IHdyYXBwZXJcblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQgfHwge30sXG5cdFx0XHRcdHNoYWRvd3MgPSB3cmFwcGVyLnNoYWRvd3MsXG5cdFx0XHRcdHBhcmVudFRvQ2xlYW4gPSB3cmFwcGVyLnJlbmRlcmVyLmlzU1ZHICYmIGVsZW1lbnQubm9kZU5hbWUgPT09ICdTUEFOJyAmJiB3cmFwcGVyLnBhcmVudEdyb3VwLFxuXHRcdFx0XHRncmFuZFBhcmVudCxcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRpO1xuXG5cdFx0XHQvLyByZW1vdmUgZXZlbnRzXG5cdFx0XHRlbGVtZW50Lm9uY2xpY2sgPSBlbGVtZW50Lm9ubW91c2VvdXQgPSBlbGVtZW50Lm9ubW91c2VvdmVyID0gZWxlbWVudC5vbm1vdXNlbW92ZSA9IGVsZW1lbnQucG9pbnQgPSBudWxsO1xuXHRcdFx0c3RvcCh3cmFwcGVyKTsgLy8gc3RvcCBydW5uaW5nIGFuaW1hdGlvbnNcblxuXHRcdFx0aWYgKHdyYXBwZXIuY2xpcFBhdGgpIHtcblx0XHRcdFx0d3JhcHBlci5jbGlwUGF0aCA9IHdyYXBwZXIuY2xpcFBhdGguZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXN0cm95IHN0b3BzIGluIGNhc2UgdGhpcyBpcyBhIGdyYWRpZW50IG9iamVjdFxuXHRcdFx0aWYgKHdyYXBwZXIuc3RvcHMpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHdyYXBwZXIuc3RvcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR3cmFwcGVyLnN0b3BzW2ldID0gd3JhcHBlci5zdG9wc1tpXS5kZXN0cm95KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d3JhcHBlci5zdG9wcyA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBlbGVtZW50XG5cdFx0XHR3cmFwcGVyLnNhZmVSZW1vdmVDaGlsZChlbGVtZW50KTtcblxuXHRcdFx0Ly8gZGVzdHJveSBzaGFkb3dzXG5cdFx0XHRpZiAoc2hhZG93cykge1xuXHRcdFx0XHRlYWNoKHNoYWRvd3MsIGZ1bmN0aW9uIChzaGFkb3cpIHtcblx0XHRcdFx0XHR3cmFwcGVyLnNhZmVSZW1vdmVDaGlsZChzaGFkb3cpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW4gY2FzZSBvZiB1c2VIVE1MLCBjbGVhbiB1cCBlbXB0eSBjb250YWluZXJzIGVtdWxhdGluZyBTVkcgZ3JvdXBzICgjMTk2MCwgIzIzOTMsICMyNjk3KS5cblx0XHRcdHdoaWxlIChwYXJlbnRUb0NsZWFuICYmIHBhcmVudFRvQ2xlYW4uZGl2ICYmIHBhcmVudFRvQ2xlYW4uZGl2LmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGdyYW5kUGFyZW50ID0gcGFyZW50VG9DbGVhbi5wYXJlbnRHcm91cDtcblx0XHRcdFx0d3JhcHBlci5zYWZlUmVtb3ZlQ2hpbGQocGFyZW50VG9DbGVhbi5kaXYpO1xuXHRcdFx0XHRkZWxldGUgcGFyZW50VG9DbGVhbi5kaXY7XG5cdFx0XHRcdHBhcmVudFRvQ2xlYW4gPSBncmFuZFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGZyb20gYWxpZ25PYmplY3RzXG5cdFx0XHRpZiAod3JhcHBlci5hbGlnblRvKSB7XG5cdFx0XHRcdGVyYXNlKHdyYXBwZXIucmVuZGVyZXIuYWxpZ25lZE9iamVjdHMsIHdyYXBwZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGtleSBpbiB3cmFwcGVyKSB7XG5cdFx0XHRcdGRlbGV0ZSB3cmFwcGVyW2tleV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGQgYSBzaGFkb3cgdG8gdGhlIGVsZW1lbnQuIE11c3QgYmUgZG9uZSBhZnRlciB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgRE9NXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gc2hhZG93T3B0aW9uc1xuXHRcdCAqL1xuXHRcdHNoYWRvdzogZnVuY3Rpb24gKHNoYWRvd09wdGlvbnMsIGdyb3VwLCBjdXRPZmYpIHtcblx0XHRcdHZhciBzaGFkb3dzID0gW10sXG5cdFx0XHRcdGksXG5cdFx0XHRcdHNoYWRvdyxcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdFx0c3Ryb2tlV2lkdGgsXG5cdFx0XHRcdHNoYWRvd1dpZHRoLFxuXHRcdFx0XHRzaGFkb3dFbGVtZW50T3BhY2l0eSxcblxuXHRcdFx0XHQvLyBjb21wZW5zYXRlIGZvciBpbnZlcnRlZCBwbG90IGFyZWFcblx0XHRcdFx0dHJhbnNmb3JtO1xuXG5cblx0XHRcdGlmIChzaGFkb3dPcHRpb25zKSB7XG5cdFx0XHRcdHNoYWRvd1dpZHRoID0gcGljayhzaGFkb3dPcHRpb25zLndpZHRoLCAzKTtcblx0XHRcdFx0c2hhZG93RWxlbWVudE9wYWNpdHkgPSAoc2hhZG93T3B0aW9ucy5vcGFjaXR5IHx8IDAuMTUpIC8gc2hhZG93V2lkdGg7XG5cdFx0XHRcdHRyYW5zZm9ybSA9IHRoaXMucGFyZW50SW52ZXJ0ZWQgP1xuXHRcdFx0XHRcdCcoLTEsLTEpJyA6XG5cdFx0XHRcdFx0JygnICsgcGljayhzaGFkb3dPcHRpb25zLm9mZnNldFgsIDEpICsgJywgJyArIHBpY2soc2hhZG93T3B0aW9ucy5vZmZzZXRZLCAxKSArICcpJztcblx0XHRcdFx0Zm9yIChpID0gMTsgaSA8PSBzaGFkb3dXaWR0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c2hhZG93ID0gZWxlbWVudC5jbG9uZU5vZGUoMCk7XG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSAoc2hhZG93V2lkdGggKiAyKSArIDEgLSAoMiAqIGkpO1xuXHRcdFx0XHRcdGF0dHIoc2hhZG93LCB7XG5cdFx0XHRcdFx0XHQnaXNTaGFkb3cnOiAndHJ1ZScsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlJzogc2hhZG93T3B0aW9ucy5jb2xvciB8fCAnYmxhY2snLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS1vcGFjaXR5Jzogc2hhZG93RWxlbWVudE9wYWNpdHkgKiBpLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoLFxuXHRcdFx0XHRcdFx0J3RyYW5zZm9ybSc6ICd0cmFuc2xhdGUnICsgdHJhbnNmb3JtLFxuXHRcdFx0XHRcdFx0J2ZpbGwnOiBOT05FXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYgKGN1dE9mZikge1xuXHRcdFx0XHRcdFx0YXR0cihzaGFkb3csICdoZWlnaHQnLCBtYXRoTWF4KGF0dHIoc2hhZG93LCAnaGVpZ2h0JykgLSBzdHJva2VXaWR0aCwgMCkpO1xuXHRcdFx0XHRcdFx0c2hhZG93LmN1dEhlaWdodCA9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChncm91cCkge1xuXHRcdFx0XHRcdFx0Z3JvdXAuZWxlbWVudC5hcHBlbmRDaGlsZChzaGFkb3cpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNoYWRvdywgZWxlbWVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2hhZG93cy5wdXNoKHNoYWRvdyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNoYWRvd3MgPSBzaGFkb3dzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0eEdldHRlcjogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKHRoaXMuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0a2V5ID0geyB4OiAnY3gnLCB5OiAnY3knIH1ba2V5XSB8fCBrZXk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGVmYXVsdEdldHRlcihrZXkpO1xuXHRcdH0sXG5cblx0XHQvKiogXG5cdFx0ICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvciBwc2V1ZG8gYXR0cmlidXRlLCB1c2VkIG1haW5seVxuXHRcdCAqIGZvciBhbmltYXRpb24uXG5cdFx0ICovXG5cdFx0X2RlZmF1bHRHZXR0ZXI6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHZhciByZXQgPSBwaWNrKHRoaXNba2V5XSwgdGhpcy5lbGVtZW50ID8gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShrZXkpIDogbnVsbCwgMCk7XG5cblx0XHRcdGlmICgvXltcXC0wLTlcXC5dKyQvLnRlc3QocmV0KSkgeyAvLyBpcyBudW1lcmljYWxcblx0XHRcdFx0cmV0ID0gcGFyc2VGbG9hdChyZXQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cblx0XHRkU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmpvaW4pIHsgLy8gam9pbiBwYXRoXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUuam9pbignICcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKC8oTmFOfCB7Mn18XiQpLy50ZXN0KHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZSA9ICdNIDAgMCc7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblxuXHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0fSxcblx0XHRkYXNoc3R5bGVTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVxuXHRcdFx0XHRcdC5yZXBsYWNlKCdzaG9ydGRhc2hkb3Rkb3QnLCAnMywxLDEsMSwxLDEsJylcblx0XHRcdFx0XHQucmVwbGFjZSgnc2hvcnRkYXNoZG90JywgJzMsMSwxLDEnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCdzaG9ydGRvdCcsICcxLDEsJylcblx0XHRcdFx0XHQucmVwbGFjZSgnc2hvcnRkYXNoJywgJzMsMSwnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCdsb25nZGFzaCcsICc4LDMsJylcblx0XHRcdFx0XHQucmVwbGFjZSgvZG90L2csICcxLDMsJylcblx0XHRcdFx0XHQucmVwbGFjZSgnZGFzaCcsICc0LDMsJylcblx0XHRcdFx0XHQucmVwbGFjZSgvLCQvLCAnJylcblx0XHRcdFx0XHQuc3BsaXQoJywnKTsgLy8gZW5kaW5nIGNvbW1hXG5cblx0XHRcdFx0aSA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHZhbHVlW2ldID0gcEludCh2YWx1ZVtpXSkgKiB0aGlzWydzdHJva2Utd2lkdGgnXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmpvaW4oJywnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCdOYU4nLCAnbm9uZScpOyAvLyAjMzIyNlxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWxpZ25TZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCB7IGxlZnQ6ICdzdGFydCcsIGNlbnRlcjogJ21pZGRsZScsIHJpZ2h0OiAnZW5kJyB9W3ZhbHVlXSk7XG5cdFx0fSxcblx0XHRvcGFjaXR5U2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHR9LFxuXHRcdHRpdGxlU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHZhciB0aXRsZU5vZGUgPSB0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RpdGxlJylbMF07XG5cdFx0XHRpZiAoIXRpdGxlTm9kZSkge1xuXHRcdFx0XHR0aXRsZU5vZGUgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgJ3RpdGxlJyk7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aXRsZU5vZGUpO1xuXHRcdFx0fVxuXHRcdFx0dGl0bGVOb2RlLnRleHRDb250ZW50ID0gKFN0cmluZyhwaWNrKHZhbHVlKSwgJycpKS5yZXBsYWNlKC88W14+XSo+L2csICcnKTsgLy8gIzMyNzYgIzM4OTVcblx0XHR9LFxuXHRcdHRleHRTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9PSB0aGlzLnRleHRTdHIpIHtcblx0XHRcdFx0Ly8gRGVsZXRlIGJCb3ggbWVtbyB3aGVuIHRoZSB0ZXh0IGNoYW5nZXNcblx0XHRcdFx0ZGVsZXRlIHRoaXMuYkJveDtcblx0XHRcdFxuXHRcdFx0XHR0aGlzLnRleHRTdHIgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKHRoaXMuYWRkZWQpIHtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZmlsbFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmNvbG9yR3JhZGllbnQodmFsdWUsIGtleSwgZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR6SW5kZXhTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0XHRwYXJlbnRHcm91cCA9IHRoaXMucGFyZW50R3JvdXAsXG5cdFx0XHRcdHBhcmVudFdyYXBwZXIgPSBwYXJlbnRHcm91cCB8fCByZW5kZXJlcixcblx0XHRcdFx0cGFyZW50Tm9kZSA9IHBhcmVudFdyYXBwZXIuZWxlbWVudCB8fCByZW5kZXJlci5ib3gsXG5cdFx0XHRcdGNoaWxkTm9kZXMsXG5cdFx0XHRcdG90aGVyRWxlbWVudCxcblx0XHRcdFx0b3RoZXJaSW5kZXgsXG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdGluc2VydGVkLFxuXHRcdFx0XHRydW4gPSB0aGlzLmFkZGVkLFxuXHRcdFx0XHRpO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7IC8vIFNvIHdlIGNhbiByZWFkIGl0IGZvciBvdGhlciBlbGVtZW50cyBpbiB0aGUgZ3JvdXBcblx0XHRcdFx0dmFsdWUgPSArdmFsdWU7XG5cdFx0XHRcdGlmICh0aGlzW2tleV0gPT09IHZhbHVlKSB7IC8vIE9ubHkgdXBkYXRlIHdoZW4gbmVlZGVkICgjMzg2NSlcblx0XHRcdFx0XHRydW4gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5zZXJ0IGFjY29yZGluZyB0byB0aGlzIGFuZCBvdGhlciBlbGVtZW50cycgekluZGV4LiBCZWZvcmUgLmFkZCgpIGlzIGNhbGxlZCxcblx0XHRcdC8vIG5vdGhpbmcgaXMgZG9uZS4gVGhlbiBvbiBhZGQsIG9yIGJ5IGxhdGVyIGNhbGxzIHRvIHpJbmRleFNldHRlciwgdGhlIG5vZGVcblx0XHRcdC8vIGlzIHBsYWNlZCBvbiB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIERPTS5cblx0XHRcdGlmIChydW4pIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnpJbmRleDtcblxuXHRcdFx0XHRpZiAodmFsdWUgJiYgcGFyZW50R3JvdXApIHtcblx0XHRcdFx0XHRwYXJlbnRHcm91cC5oYW5kbGVaID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcdGNoaWxkTm9kZXMgPSBwYXJlbnROb2RlLmNoaWxkTm9kZXM7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aCAmJiAhaW5zZXJ0ZWQ7IGkrKykge1xuXHRcdFx0XHRcdG90aGVyRWxlbWVudCA9IGNoaWxkTm9kZXNbaV07XG5cdFx0XHRcdFx0b3RoZXJaSW5kZXggPSBhdHRyKG90aGVyRWxlbWVudCwgJ3pJbmRleCcpO1xuXHRcdFx0XHRcdGlmIChvdGhlckVsZW1lbnQgIT09IGVsZW1lbnQgJiYgKFxuXHRcdFx0XHRcdFx0XHQvLyBJbnNlcnQgYmVmb3JlIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggYSBoaWdoZXIgekluZGV4XG5cdFx0XHRcdFx0XHRcdHBJbnQob3RoZXJaSW5kZXgpID4gdmFsdWUgfHxcblx0XHRcdFx0XHRcdFx0Ly8gSWYgbm8gekluZGV4IGdpdmVuLCBpbnNlcnQgYmVmb3JlIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggYSB6SW5kZXhcblx0XHRcdFx0XHRcdFx0KCFkZWZpbmVkKHZhbHVlKSAmJiBkZWZpbmVkKG90aGVyWkluZGV4KSlcblxuXHRcdFx0XHRcdFx0XHQpKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBvdGhlckVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0aW5zZXJ0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWluc2VydGVkKSB7XG5cdFx0XHRcdFx0cGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluc2VydGVkO1xuXHRcdH0sXG5cdFx0X2RlZmF1bHRTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gU29tZSBzaGFyZWQgc2V0dGVycyBhbmQgZ2V0dGVyc1xuXHRTVkdFbGVtZW50LnByb3RvdHlwZS55R2V0dGVyID0gU1ZHRWxlbWVudC5wcm90b3R5cGUueEdldHRlcjtcblx0U1ZHRWxlbWVudC5wcm90b3R5cGUudHJhbnNsYXRlWFNldHRlciA9IFNWR0VsZW1lbnQucHJvdG90eXBlLnRyYW5zbGF0ZVlTZXR0ZXIgPSBcblx0XHRcdFNWR0VsZW1lbnQucHJvdG90eXBlLnJvdGF0aW9uU2V0dGVyID0gU1ZHRWxlbWVudC5wcm90b3R5cGUudmVydGljYWxBbGlnblNldHRlciA9IFxuXHRcdFx0U1ZHRWxlbWVudC5wcm90b3R5cGUuc2NhbGVYU2V0dGVyID0gU1ZHRWxlbWVudC5wcm90b3R5cGUuc2NhbGVZU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHR0aGlzW2tleV0gPSB2YWx1ZTtcblx0XHR0aGlzLmRvVHJhbnNmb3JtID0gdHJ1ZTtcblx0fTtcblxuXHQvLyBXZWJLaXQgYW5kIEJhdGlrIGhhdmUgcHJvYmxlbXMgd2l0aCBhIHN0cm9rZS13aWR0aCBvZiB6ZXJvLCBzbyBpbiB0aGlzIGNhc2Ugd2UgcmVtb3ZlIHRoZSBcblx0Ly8gc3Ryb2tlIGF0dHJpYnV0ZSBhbHRvZ2V0aGVyLiAjMTI3MCwgIzEzNjksICMzMDY1LCAjMzA3Mi5cblx0U1ZHRWxlbWVudC5wcm90b3R5cGVbJ3N0cm9rZS13aWR0aFNldHRlciddID0gU1ZHRWxlbWVudC5wcm90b3R5cGUuc3Ryb2tlU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHR0aGlzW2tleV0gPSB2YWx1ZTtcblx0XHQvLyBPbmx5IGFwcGx5IHRoZSBzdHJva2UgYXR0cmlidXRlIGlmIHRoZSBzdHJva2Ugd2lkdGggaXMgZGVmaW5lZCBhbmQgbGFyZ2VyIHRoYW4gMFxuXHRcdGlmICh0aGlzLnN0cm9rZSAmJiB0aGlzWydzdHJva2Utd2lkdGgnXSkge1xuXHRcdFx0dGhpcy5zdHJva2VXaWR0aCA9IHRoaXNbJ3N0cm9rZS13aWR0aCddO1xuXHRcdFx0U1ZHRWxlbWVudC5wcm90b3R5cGUuZmlsbFNldHRlci5jYWxsKHRoaXMsIHRoaXMuc3Ryb2tlLCAnc3Ryb2tlJywgZWxlbWVudCk7IC8vIHVzZSBwcm90b3R5cGUgYXMgaW5zdGFuY2UgbWF5IGJlIG92ZXJyaWRkZW5cblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzWydzdHJva2Utd2lkdGgnXSk7XG5cdFx0XHR0aGlzLmhhc1N0cm9rZSA9IHRydWU7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHJva2Utd2lkdGgnICYmIHZhbHVlID09PSAwICYmIHRoaXMuaGFzU3Ryb2tlKSB7XG5cdFx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlJyk7XG5cdFx0XHR0aGlzLmhhc1N0cm9rZSA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBTVkcgcmVuZGVyZXJcblx0ICovXG5cdHZhciBTVkdSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblx0U1ZHUmVuZGVyZXIucHJvdG90eXBlID0ge1xuXHRcdEVsZW1lbnQ6IFNWR0VsZW1lbnQsXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBTVkdSZW5kZXJlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JFeHBvcnRcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoY29udGFpbmVyLCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgZm9yRXhwb3J0KSB7XG5cdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0XHRsb2MgPSBsb2NhdGlvbixcblx0XHRcdFx0Ym94V3JhcHBlcixcblx0XHRcdFx0ZWxlbWVudCxcblx0XHRcdFx0ZGVzYztcblxuXHRcdFx0Ym94V3JhcHBlciA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ3N2ZycpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHR2ZXJzaW9uOiAnMS4xJ1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKHRoaXMuZ2V0U3R5bGUoc3R5bGUpKTtcblx0XHRcdGVsZW1lbnQgPSBib3hXcmFwcGVyLmVsZW1lbnQ7XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cblx0XHRcdC8vIEZvciBicm93c2VycyBvdGhlciB0aGFuIElFLCBhZGQgdGhlIG5hbWVzcGFjZSBhdHRyaWJ1dGUgKCMxOTc4KVxuXHRcdFx0aWYgKGNvbnRhaW5lci5pbm5lckhUTUwuaW5kZXhPZigneG1sbnMnKSA9PT0gLTEpIHtcblx0XHRcdFx0YXR0cihlbGVtZW50LCAneG1sbnMnLCBTVkdfTlMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBvYmplY3QgcHJvcGVydGllc1xuXHRcdFx0cmVuZGVyZXIuaXNTVkcgPSB0cnVlO1xuXHRcdFx0cmVuZGVyZXIuYm94ID0gZWxlbWVudDtcblx0XHRcdHJlbmRlcmVyLmJveFdyYXBwZXIgPSBib3hXcmFwcGVyO1xuXHRcdFx0cmVuZGVyZXIuYWxpZ25lZE9iamVjdHMgPSBbXTtcblxuXHRcdFx0Ly8gUGFnZSB1cmwgdXNlZCBmb3IgaW50ZXJuYWwgcmVmZXJlbmNlcy4gIzI0LCAjNjcyLCAjMTA3MFxuXHRcdFx0cmVuZGVyZXIudXJsID0gKGlzRmlyZWZveCB8fCBpc1dlYktpdCkgJiYgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdiYXNlJykubGVuZ3RoID9cblx0XHRcdFx0bG9jLmhyZWZcblx0XHRcdFx0XHQucmVwbGFjZSgvIy4qPyQvLCAnJykgLy8gcmVtb3ZlIHRoZSBoYXNoXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyhbXFwoJ1xcKV0pL2csICdcXFxcJDEnKSAvLyBlc2NhcGUgcGFyYW50aGVzZXMgYW5kIHF1b3Rlc1xuXHRcdFx0XHRcdC5yZXBsYWNlKC8gL2csICclMjAnKSA6IC8vIHJlcGxhY2Ugc3BhY2VzIChuZWVkZWQgZm9yIFNhZmFyaSBvbmx5KVxuXHRcdFx0XHQnJztcblxuXHRcdFx0Ly8gQWRkIGRlc2NyaXB0aW9uXG5cdFx0XHRkZXNjID0gdGhpcy5jcmVhdGVFbGVtZW50KCdkZXNjJykuYWRkKCk7XG5cdFx0XHRkZXNjLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKCdDcmVhdGVkIHdpdGggJyArIFBST0RVQ1QgKyAnICcgKyBWRVJTSU9OKSk7XG5cblxuXHRcdFx0cmVuZGVyZXIuZGVmcyA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZGVmcycpLmFkZCgpO1xuXHRcdFx0cmVuZGVyZXIuZm9yRXhwb3J0ID0gZm9yRXhwb3J0O1xuXHRcdFx0cmVuZGVyZXIuZ3JhZGllbnRzID0ge307IC8vIE9iamVjdCB3aGVyZSBncmFkaWVudCBTdmdFbGVtZW50cyBhcmUgc3RvcmVkXG5cdFx0XHRyZW5kZXJlci5jYWNoZSA9IHt9OyAvLyBDYWNoZSBmb3IgbnVtZXJpY2FsIGJvdW5kaW5nIGJveGVzXG5cblx0XHRcdHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCwgZmFsc2UpO1xuXG5cblxuXHRcdFx0Ly8gSXNzdWUgMTEwIHdvcmthcm91bmQ6XG5cdFx0XHQvLyBJbiBGaXJlZm94LCBpZiBhIGRpdiBpcyBwb3NpdGlvbmVkIGJ5IHBlcmNlbnRhZ2UsIGl0cyBwaXhlbCBwb3NpdGlvbiBtYXkgbGFuZFxuXHRcdFx0Ly8gYmV0d2VlbiBwaXhlbHMuIFRoZSBjb250YWluZXIgaXRzZWxmIGRvZXNuJ3QgZGlzcGxheSB0aGlzLCBidXQgYW4gU1ZHIGVsZW1lbnRcblx0XHRcdC8vIGluc2lkZSB0aGlzIGNvbnRhaW5lciB3aWxsIGJlIGRyYXduIGF0IHN1YnBpeGVsIHByZWNpc2lvbi4gSW4gb3JkZXIgdG8gZHJhd1xuXHRcdFx0Ly8gc2hhcnAgbGluZXMsIHRoaXMgbXVzdCBiZSBjb21wZW5zYXRlZCBmb3IuIFRoaXMgZG9lc24ndCBzZWVtIHRvIHdvcmsgaW5zaWRlXG5cdFx0XHQvLyBpZnJhbWVzIHRob3VnaCAobGlrZSBpbiBqc0ZpZGRsZSkuXG5cdFx0XHR2YXIgc3ViUGl4ZWxGaXgsIHJlY3Q7XG5cdFx0XHRpZiAoaXNGaXJlZm94ICYmIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcblx0XHRcdFx0cmVuZGVyZXIuc3ViUGl4ZWxGaXggPSBzdWJQaXhlbEZpeCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjc3MoY29udGFpbmVyLCB7IGxlZnQ6IDAsIHRvcDogMCB9KTtcblx0XHRcdFx0XHRyZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRcdGNzcyhjb250YWluZXIsIHtcblx0XHRcdFx0XHRcdGxlZnQ6IChtYXRoQ2VpbChyZWN0LmxlZnQpIC0gcmVjdC5sZWZ0KSArIFBYLFxuXHRcdFx0XHRcdFx0dG9wOiAobWF0aENlaWwocmVjdC50b3ApIC0gcmVjdC50b3ApICsgUFhcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBydW4gdGhlIGZpeCBub3dcblx0XHRcdFx0c3ViUGl4ZWxGaXgoKTtcblxuXHRcdFx0XHQvLyBydW4gaXQgb24gcmVzaXplXG5cdFx0XHRcdGFkZEV2ZW50KHdpbiwgJ3Jlc2l6ZScsIHN1YlBpeGVsRml4KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuXHRcdFx0cmV0dXJuICh0aGlzLnN0eWxlID0gZXh0ZW5kKHtcblx0XHRcdFx0Zm9udEZhbWlseTogJ1wiTHVjaWRhIEdyYW5kZVwiLCBcIkx1Y2lkYSBTYW5zIFVuaWNvZGVcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsIC8vIGRlZmF1bHQgZm9udFxuXHRcdFx0XHRmb250U2l6ZTogJzEycHgnXG5cdFx0XHR9LCBzdHlsZSkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXRlY3Qgd2hldGhlciB0aGUgcmVuZGVyZXIgaXMgaGlkZGVuLiBUaGlzIGhhcHBlbnMgd2hlbiBvbmUgb2YgdGhlIHBhcmVudCBlbGVtZW50c1xuXHRcdCAqIGhhcyBkaXNwbGF5OiBub25lLiAjNjA4LlxuXHRcdCAqL1xuXHRcdGlzSGlkZGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gIXRoaXMuYm94V3JhcHBlci5nZXRCQm94KCkud2lkdGg7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3lzIHRoZSByZW5kZXJlciBhbmQgaXRzIGFsbG9jYXRlZCBtZW1iZXJzLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdHJlbmRlcmVyRGVmcyA9IHJlbmRlcmVyLmRlZnM7XG5cdFx0XHRyZW5kZXJlci5ib3ggPSBudWxsO1xuXHRcdFx0cmVuZGVyZXIuYm94V3JhcHBlciA9IHJlbmRlcmVyLmJveFdyYXBwZXIuZGVzdHJveSgpO1xuXG5cdFx0XHQvLyBDYWxsIGRlc3Ryb3kgb24gYWxsIGdyYWRpZW50IGVsZW1lbnRzXG5cdFx0XHRkZXN0cm95T2JqZWN0UHJvcGVydGllcyhyZW5kZXJlci5ncmFkaWVudHMgfHwge30pO1xuXHRcdFx0cmVuZGVyZXIuZ3JhZGllbnRzID0gbnVsbDtcblxuXHRcdFx0Ly8gRGVmcyBhcmUgbnVsbCBpbiBWTUxSZW5kZXJlclxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBkZXN0cm95IHRoZW0gaGVyZS5cblx0XHRcdGlmIChyZW5kZXJlckRlZnMpIHtcblx0XHRcdFx0cmVuZGVyZXIuZGVmcyA9IHJlbmRlcmVyRGVmcy5kZXN0cm95KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBzdWIgcGl4ZWwgZml4IGhhbmRsZXJcblx0XHRcdC8vIFdlIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGVyZSBpcyBhIGhhbmRsZXIsIG90aGVyd2lzZSBhbGwgZnVuY3Rpb25zIHRoYXQgYXJlIHJlZ2lzdGVyZWQgZm9yIGV2ZW50ICdyZXNpemUnIGFyZSByZW1vdmVkXG5cdFx0XHQvLyBTZWUgaXNzdWUgIzk4MlxuXHRcdFx0aWYgKHJlbmRlcmVyLnN1YlBpeGVsRml4KSB7XG5cdFx0XHRcdHJlbW92ZUV2ZW50KHdpbiwgJ3Jlc2l6ZScsIHJlbmRlcmVyLnN1YlBpeGVsRml4KTtcblx0XHRcdH1cblxuXHRcdFx0cmVuZGVyZXIuYWxpZ25lZE9iamVjdHMgPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgd3JhcHBlciBmb3IgYW4gU1ZHIGVsZW1lbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZU5hbWVcblx0XHQgKi9cblx0XHRjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAobm9kZU5hbWUpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gbmV3IHRoaXMuRWxlbWVudCgpO1xuXHRcdFx0d3JhcHBlci5pbml0KHRoaXMsIG5vZGVOYW1lKTtcblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEdW1teSBmdW5jdGlvbiBmb3IgdXNlIGluIGNhbnZhcyByZW5kZXJlclxuXHRcdCAqL1xuXHRcdGRyYXc6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdFx0LyoqXG5cdFx0ICogUGFyc2UgYSBzaW1wbGUgSFRNTCBzdHJpbmcgaW50byBTVkcgdHNwYW5zXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGV4dE5vZGUgVGhlIHBhcmVudCB0ZXh0IFNWRyBub2RlXG5cdFx0ICovXG5cdFx0YnVpbGRUZXh0OiBmdW5jdGlvbiAod3JhcHBlcikge1xuXHRcdFx0dmFyIHRleHROb2RlID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0XHRyZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGZvckV4cG9ydCA9IHJlbmRlcmVyLmZvckV4cG9ydCxcblx0XHRcdFx0dGV4dFN0ciA9IHBpY2sod3JhcHBlci50ZXh0U3RyLCAnJykudG9TdHJpbmcoKSxcblx0XHRcdFx0aGFzTWFya3VwID0gdGV4dFN0ci5pbmRleE9mKCc8JykgIT09IC0xLFxuXHRcdFx0XHRsaW5lcyxcblx0XHRcdFx0Y2hpbGROb2RlcyA9IHRleHROb2RlLmNoaWxkTm9kZXMsXG5cdFx0XHRcdHN0eWxlUmVnZXgsXG5cdFx0XHRcdGhyZWZSZWdleCxcblx0XHRcdFx0cGFyZW50WCA9IGF0dHIodGV4dE5vZGUsICd4JyksXG5cdFx0XHRcdHRleHRTdHlsZXMgPSB3cmFwcGVyLnN0eWxlcyxcblx0XHRcdFx0d2lkdGggPSB3cmFwcGVyLnRleHRXaWR0aCxcblx0XHRcdFx0dGV4dExpbmVIZWlnaHQgPSB0ZXh0U3R5bGVzICYmIHRleHRTdHlsZXMubGluZUhlaWdodCxcblx0XHRcdFx0dGV4dFNoYWRvdyA9IHRleHRTdHlsZXMgJiYgdGV4dFN0eWxlcy50ZXh0U2hhZG93LFxuXHRcdFx0XHRlbGxpcHNpcyA9IHRleHRTdHlsZXMgJiYgdGV4dFN0eWxlcy50ZXh0T3ZlcmZsb3cgPT09ICdlbGxpcHNpcycsXG5cdFx0XHRcdGkgPSBjaGlsZE5vZGVzLmxlbmd0aCxcblx0XHRcdFx0dGVtcFBhcmVudCA9IHdpZHRoICYmICF3cmFwcGVyLmFkZGVkICYmIHRoaXMuYm94LFxuXHRcdFx0XHRnZXRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKHRzcGFuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRleHRMaW5lSGVpZ2h0ID8gXG5cdFx0XHRcdFx0XHRwSW50KHRleHRMaW5lSGVpZ2h0KSA6XG5cdFx0XHRcdFx0XHRyZW5kZXJlci5mb250TWV0cmljcyhcblx0XHRcdFx0XHRcdFx0LyhweHxlbSkkLy50ZXN0KHRzcGFuICYmIHRzcGFuLnN0eWxlLmZvbnRTaXplKSA/XG5cdFx0XHRcdFx0XHRcdFx0dHNwYW4uc3R5bGUuZm9udFNpemUgOlxuXHRcdFx0XHRcdFx0XHRcdCgodGV4dFN0eWxlcyAmJiB0ZXh0U3R5bGVzLmZvbnRTaXplKSB8fCByZW5kZXJlci5zdHlsZS5mb250U2l6ZSB8fCAxMiksXG5cdFx0XHRcdFx0XHRcdHRzcGFuXG5cdFx0XHRcdFx0XHQpLmg7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVuZXNjYXBlQW5nbGVCcmFja2V0cyA9IGZ1bmN0aW9uIChpbnB1dFN0cikge1xuXHRcdFx0XHRcdHJldHVybiBpbnB1dFN0ci5yZXBsYWNlKC8mbHQ7L2csICc8JykucmVwbGFjZSgvJmd0Oy9nLCAnPicpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLy8gcmVtb3ZlIG9sZCB0ZXh0XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHRleHROb2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTa2lwIHRzcGFucywgYWRkIHRleHQgZGlyZWN0bHkgdG8gdGV4dCBub2RlLiBUaGUgZm9yY2VUU3BhbiBpcyBhIGhvb2sgXG5cdFx0XHQvLyB1c2VkIGluIHRleHQgb3V0bGluZSBoYWNrLlxuXHRcdFx0aWYgKCFoYXNNYXJrdXAgJiYgIXRleHRTaGFkb3cgJiYgIWVsbGlwc2lzICYmIHRleHRTdHIuaW5kZXhPZignICcpID09PSAtMSkge1xuXHRcdFx0XHR0ZXh0Tm9kZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUodW5lc2NhcGVBbmdsZUJyYWNrZXRzKHRleHRTdHIpKSk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gQ29tcGxleCBzdHJpbmdzLCBhZGQgbW9yZSBsb2dpY1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdHlsZVJlZ2V4ID0gLzwuKnN0eWxlPVwiKFteXCJdKylcIi4qPi87XG5cdFx0XHRcdGhyZWZSZWdleCA9IC88LipocmVmPVwiKGh0dHBbXlwiXSspXCIuKj4vO1xuXG5cdFx0XHRcdGlmICh0ZW1wUGFyZW50KSB7XG5cdFx0XHRcdFx0dGVtcFBhcmVudC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7IC8vIGF0dGFjaCBpdCB0byB0aGUgRE9NIHRvIHJlYWQgb2Zmc2V0IHdpZHRoXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaGFzTWFya3VwKSB7XG5cdFx0XHRcdFx0bGluZXMgPSB0ZXh0U3RyXG5cdFx0XHRcdFx0XHQucmVwbGFjZSgvPChifHN0cm9uZyk+L2csICc8c3BhbiBzdHlsZT1cImZvbnQtd2VpZ2h0OmJvbGRcIj4nKVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoLzwoaXxlbSk+L2csICc8c3BhbiBzdHlsZT1cImZvbnQtc3R5bGU6aXRhbGljXCI+Jylcblx0XHRcdFx0XHRcdC5yZXBsYWNlKC88YS9nLCAnPHNwYW4nKVxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoLzxcXC8oYnxzdHJvbmd8aXxlbXxhKT4vZywgJzwvc3Bhbj4nKVxuXHRcdFx0XHRcdFx0LnNwbGl0KC88YnIuKj8+L2cpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGluZXMgPSBbdGV4dFN0cl07XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vIHJlbW92ZSBlbXB0eSBsaW5lIGF0IGVuZFxuXHRcdFx0XHRpZiAobGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG5cdFx0XHRcdFx0bGluZXMucG9wKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gYnVpbGQgdGhlIGxpbmVzXG5cdFx0XHRcdGVhY2gobGluZXMsIGZ1bmN0aW9uIChsaW5lLCBsaW5lTm8pIHtcblx0XHRcdFx0XHR2YXIgc3BhbnMsIHNwYW5ObyA9IDA7XG5cblx0XHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKC88c3Bhbi9nLCAnfHx8PHNwYW4nKS5yZXBsYWNlKC88XFwvc3Bhbj4vZywgJzwvc3Bhbj58fHwnKTtcblx0XHRcdFx0XHRzcGFucyA9IGxpbmUuc3BsaXQoJ3x8fCcpO1xuXG5cdFx0XHRcdFx0ZWFjaChzcGFucywgZnVuY3Rpb24gKHNwYW4pIHtcblx0XHRcdFx0XHRcdGlmIChzcGFuICE9PSAnJyB8fCBzcGFucy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB7fSxcblx0XHRcdFx0XHRcdFx0XHR0c3BhbiA9IGRvYy5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAndHNwYW4nKSxcblx0XHRcdFx0XHRcdFx0XHRzcGFuU3R5bGU7IC8vICMzOTBcblx0XHRcdFx0XHRcdFx0aWYgKHN0eWxlUmVnZXgudGVzdChzcGFuKSkge1xuXHRcdFx0XHRcdFx0XHRcdHNwYW5TdHlsZSA9IHNwYW4ubWF0Y2goc3R5bGVSZWdleClbMV0ucmVwbGFjZSgvKDt8IHxeKWNvbG9yKFsgOl0pLywgJyQxZmlsbCQyJyk7XG5cdFx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgJ3N0eWxlJywgc3BhblN0eWxlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoaHJlZlJlZ2V4LnRlc3Qoc3BhbikgJiYgIWZvckV4cG9ydCkgeyAvLyBOb3QgZm9yIGV4cG9ydCAtICMxNTI5XG5cdFx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgJ29uY2xpY2snLCAnbG9jYXRpb24uaHJlZj1cXFwiJyArIHNwYW4ubWF0Y2goaHJlZlJlZ2V4KVsxXSArICdcXFwiJyk7XG5cdFx0XHRcdFx0XHRcdFx0Y3NzKHRzcGFuLCB7IGN1cnNvcjogJ3BvaW50ZXInIH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0c3BhbiA9IHVuZXNjYXBlQW5nbGVCcmFja2V0cyhzcGFuLnJlcGxhY2UoLzwoLnxcXG4pKj8+L2csICcnKSB8fCAnICcpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIE5lc3RlZCB0YWdzIGFyZW4ndCBzdXBwb3J0ZWQsIGFuZCBjYXVzZSBjcmFzaCBpbiBTYWZhcmkgKCMxNTk2KVxuXHRcdFx0XHRcdFx0XHRpZiAoc3BhbiAhPT0gJyAnKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBhZGQgdGhlIHRleHQgbm9kZVxuXHRcdFx0XHRcdFx0XHRcdHRzcGFuLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShzcGFuKSk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIXNwYW5ObykgeyAvLyBmaXJzdCBzcGFuIGluIGEgbGluZSwgYWxpZ24gaXQgdG8gdGhlIGxlZnRcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChsaW5lTm8gJiYgcGFyZW50WCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGVzLnggPSBwYXJlbnRYO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGVzLmR4ID0gMDsgLy8gIzE2XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYWRkIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0XHRhdHRyKHRzcGFuLCBhdHRyaWJ1dGVzKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEFwcGVuZCBpdFxuXHRcdFx0XHRcdFx0XHRcdHRleHROb2RlLmFwcGVuZENoaWxkKHRzcGFuKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGZpcnN0IHNwYW4gb24gc3Vic2VxdWVudCBsaW5lLCBhZGQgdGhlIGxpbmUgaGVpZ2h0XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFzcGFuTm8gJiYgbGluZU5vKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIGFsbG93IGdldHRpbmcgdGhlIHJpZ2h0IG9mZnNldCBoZWlnaHQgaW4gZXhwb3J0aW5nIGluIElFXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWhhc1NWRyAmJiBmb3JFeHBvcnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3NzKHRzcGFuLCB7IGRpc3BsYXk6ICdibG9jaycgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFNldCB0aGUgbGluZSBoZWlnaHQgYmFzZWQgb24gdGhlIGZvbnQgc2l6ZSBvZiBlaXRoZXJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoZSB0ZXh0IGVsZW1lbnQgb3IgdGhlIHRzcGFuIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdGF0dHIoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnZHknLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRnZXRMaW5lSGVpZ2h0KHRzcGFuKVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKmlmICh3aWR0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuYnJlYWtUZXh0KHdyYXBwZXIsIHdpZHRoKTtcblx0XHRcdFx0XHRcdFx0XHR9Ki9cblxuXHRcdFx0XHRcdFx0XHRcdC8vIENoZWNrIHdpZHRoIGFuZCBhcHBseSBzb2Z0IGJyZWFrcyBvciBlbGxpcHNpc1xuXHRcdFx0XHRcdFx0XHRcdGlmICh3aWR0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHdvcmRzID0gc3Bhbi5yZXBsYWNlKC8oW15cXF5dKS0vZywgJyQxLSAnKS5zcGxpdCgnICcpLCAvLyAjMTI3M1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRoYXNXaGl0ZVNwYWNlID0gc3BhbnMubGVuZ3RoID4gMSB8fCBsaW5lTm8gfHwgKHdvcmRzLmxlbmd0aCA+IDEgJiYgdGV4dFN0eWxlcy53aGl0ZVNwYWNlICE9PSAnbm93cmFwJyksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRvb0xvbmcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdhc1Rvb0xvbmcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFjdHVhbFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN0ID0gW10sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGR5ID0gZ2V0TGluZUhlaWdodCh0c3BhbiksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNvZnRMaW5lTm8gPSAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyb3RhdGlvbiA9IHdyYXBwZXIucm90YXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdvcmRTdHIgPSBzcGFuLCAvLyBmb3IgZWxsaXBzaXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3Vyc29yID0gd29yZFN0ci5sZW5ndGgsIC8vIGJpbmFyeSBzZWFyY2ggY3Vyc29yXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJCb3g7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICgoaGFzV2hpdGVTcGFjZSB8fCBlbGxpcHNpcykgJiYgKHdvcmRzLmxlbmd0aCB8fCByZXN0Lmxlbmd0aCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0d3JhcHBlci5yb3RhdGlvbiA9IDA7IC8vIGRpc2NhcmQgcm90YXRpb24gd2hlbiBjb21wdXRpbmcgYm94XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJCb3ggPSB3cmFwcGVyLmdldEJCb3godHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFjdHVhbFdpZHRoID0gYkJveC53aWR0aDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbGQgSUUgY2Fubm90IG1lYXN1cmUgdGhlIGFjdHVhbFdpZHRoIGZvciBTVkcgZWxlbWVudHMgKCMyMzE0KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWhhc1NWRyAmJiByZW5kZXJlci5mb3JFeHBvcnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhY3R1YWxXaWR0aCA9IHJlbmRlcmVyLm1lYXN1cmVTcGFuV2lkdGgodHNwYW4uZmlyc3RDaGlsZC5kYXRhLCB3cmFwcGVyLnN0eWxlcyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0b29Mb25nID0gYWN0dWFsV2lkdGggPiB3aWR0aDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgZWxsaXBzaXMsIGRvIGEgYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGNvcnJlY3Qgc3RyaW5nIGxlbmd0aFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAod2FzVG9vTG9uZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0d2FzVG9vTG9uZyA9IHRvb0xvbmc7IC8vIEZpcnN0IHRpbWVcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWxsaXBzaXMgJiYgd2FzVG9vTG9uZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnNvciAvPSAyO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHdvcmRTdHIgPT09ICcnIHx8ICghdG9vTG9uZyAmJiBjdXJzb3IgPCAwLjUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3b3JkcyA9IFtdOyAvLyBBbGwgb2ssIGJyZWFrIG91dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodG9vTG9uZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3YXNUb29Mb25nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdvcmRTdHIgPSBzcGFuLnN1YnN0cmluZygwLCB3b3JkU3RyLmxlbmd0aCArICh0b29Mb25nID8gLTEgOiAxKSAqIG1hdGhDZWlsKGN1cnNvcikpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0d29yZHMgPSBbd29yZFN0ciArICdcXHUyMDI2J107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0c3Bhbi5yZW1vdmVDaGlsZCh0c3Bhbi5maXJzdENoaWxkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTG9vcGluZyBkb3duLCB0aGlzIGlzIHRoZSBmaXJzdCB3b3JkIHNlcXVlbmNlIHRoYXQgaXMgbm90IHRvbyBsb25nLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBzbyB3ZSBjYW4gbW92ZSBvbiB0byBidWlsZCB0aGUgbmV4dCBsaW5lLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCF0b29Mb25nIHx8IHdvcmRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdvcmRzID0gcmVzdDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN0ID0gW107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh3b3Jkcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNvZnRMaW5lTm8rKztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHNwYW4gPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgJ3RzcGFuJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhdHRyKHRzcGFuLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGR5OiBkeSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eDogcGFyZW50WFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3BhblN0eWxlKSB7IC8vICMzOTBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXR0cih0c3BhbiwgJ3N0eWxlJywgc3BhblN0eWxlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleHROb2RlLmFwcGVuZENoaWxkKHRzcGFuKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFjdHVhbFdpZHRoID4gd2lkdGgpIHsgLy8gYSBzaW5nbGUgd29yZCBpcyBwcmVzc2luZyBpdCBvdXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoID0gYWN0dWFsV2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBhcHBlbmQgdG8gZXhpc3RpbmcgbGluZSB0c3BhblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLnJlbW92ZUNoaWxkKHRzcGFuLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3QudW5zaGlmdCh3b3Jkcy5wb3AoKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHdvcmRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRzcGFuLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh3b3Jkcy5qb2luKCcgJykucmVwbGFjZSgvLSAvZywgJy0nKSkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod2FzVG9vTG9uZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR3cmFwcGVyLmF0dHIoJ3RpdGxlJywgd3JhcHBlci50ZXh0U3RyKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHdyYXBwZXIucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRzcGFuTm8rKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHRlbXBQYXJlbnQpIHtcblx0XHRcdFx0XHR0ZW1wUGFyZW50LnJlbW92ZUNoaWxkKHRleHROb2RlKTsgLy8gYXR0YWNoIGl0IHRvIHRoZSBET00gdG8gcmVhZCBvZmZzZXQgd2lkdGhcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IHRoZSB0ZXh0IHNoYWRvd1xuXHRcdFx0XHRpZiAodGV4dFNoYWRvdyAmJiB3cmFwcGVyLmFwcGx5VGV4dFNoYWRvdykge1xuXHRcdFx0XHRcdHdyYXBwZXIuYXBwbHlUZXh0U2hhZG93KHRleHRTaGFkb3cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdFxuXG5cdFx0Lypcblx0XHRicmVha1RleHQ6IGZ1bmN0aW9uICh3cmFwcGVyLCB3aWR0aCkge1xuXHRcdFx0dmFyIGJCb3ggPSB3cmFwcGVyLmdldEJCb3goKSxcblx0XHRcdFx0bm9kZSA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0dGV4dExlbmd0aCA9IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoLFxuXHRcdFx0XHRwb3MgPSBtYXRoUm91bmQod2lkdGggKiB0ZXh0TGVuZ3RoIC8gYkJveC53aWR0aCksIC8vIHRyeSB0aGlzIHBvc2l0aW9uIGZpcnN0LCBiYXNlZCBvbiBhdmVyYWdlIGNoYXJhY3RlciB3aWR0aFxuXHRcdFx0XHRpbmNyZW1lbnQgPSAwLFxuXHRcdFx0XHRmaW5hbFBvcztcblxuXHRcdFx0aWYgKGJCb3gud2lkdGggPiB3aWR0aCkge1xuXHRcdFx0XHR3aGlsZSAoZmluYWxQb3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRleHRMZW5ndGggPSBub2RlLmdldFN1YlN0cmluZ0xlbmd0aCgwLCBwb3MpO1xuXG5cdFx0XHRcdFx0aWYgKHRleHRMZW5ndGggPD0gd2lkdGgpIHtcblx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnQgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGZpbmFsUG9zID0gcG9zO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW5jcmVtZW50ID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGluY3JlbWVudCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRmaW5hbFBvcyA9IHBvcyAtIDE7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpbmNyZW1lbnQgPSAtMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zICs9IGluY3JlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS5sb2coZmluYWxQb3MsIG5vZGUuZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsIGZpbmFsUG9zKSlcblx0XHR9LFxuXHRcdCovXG5cblx0XHQvKiogXG5cdFx0ICogUmV0dXJucyB3aGl0ZSBmb3IgZGFyayBjb2xvcnMgYW5kIGJsYWNrIGZvciBicmlnaHQgY29sb3JzXG5cdFx0ICovXG5cdFx0Z2V0Q29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdFx0Y29sb3IgPSBDb2xvcihjb2xvcikucmdiYTtcblx0XHRcdHJldHVybiBjb2xvclswXSArIGNvbG9yWzFdICsgY29sb3JbMl0gPiAzODQgPyAnIzAwMCcgOiAnI0ZGRic7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIGJ1dHRvbiB3aXRoIHByZXNldCBzdGF0ZXNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub3JtYWxTdGF0ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBob3ZlclN0YXRlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHByZXNzZWRTdGF0ZVxuXHRcdCAqL1xuXHRcdGJ1dHRvbjogZnVuY3Rpb24gKHRleHQsIHgsIHksIGNhbGxiYWNrLCBub3JtYWxTdGF0ZSwgaG92ZXJTdGF0ZSwgcHJlc3NlZFN0YXRlLCBkaXNhYmxlZFN0YXRlLCBzaGFwZSkge1xuXHRcdFx0dmFyIGxhYmVsID0gdGhpcy5sYWJlbCh0ZXh0LCB4LCB5LCBzaGFwZSwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgJ2J1dHRvbicpLFxuXHRcdFx0XHRjdXJTdGF0ZSA9IDAsXG5cdFx0XHRcdHN0YXRlT3B0aW9ucyxcblx0XHRcdFx0c3RhdGVTdHlsZSxcblx0XHRcdFx0bm9ybWFsU3R5bGUsXG5cdFx0XHRcdGhvdmVyU3R5bGUsXG5cdFx0XHRcdHByZXNzZWRTdHlsZSxcblx0XHRcdFx0ZGlzYWJsZWRTdHlsZSxcblx0XHRcdFx0dmVydGljYWxHcmFkaWVudCA9IHsgeDE6IDAsIHkxOiAwLCB4MjogMCwgeTI6IDEgfTtcblxuXHRcdFx0Ly8gTm9ybWFsIHN0YXRlIC0gcHJlcGFyZSB0aGUgYXR0cmlidXRlc1xuXHRcdFx0bm9ybWFsU3RhdGUgPSBtZXJnZSh7XG5cdFx0XHRcdCdzdHJva2Utd2lkdGgnOiAxLFxuXHRcdFx0XHRzdHJva2U6ICcjQ0NDQ0NDJyxcblx0XHRcdFx0ZmlsbDoge1xuXHRcdFx0XHRcdGxpbmVhckdyYWRpZW50OiB2ZXJ0aWNhbEdyYWRpZW50LFxuXHRcdFx0XHRcdHN0b3BzOiBbXG5cdFx0XHRcdFx0XHRbMCwgJyNGRUZFRkUnXSxcblx0XHRcdFx0XHRcdFsxLCAnI0Y2RjZGNiddXG5cdFx0XHRcdFx0XVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyOiAyLFxuXHRcdFx0XHRwYWRkaW5nOiA1LFxuXHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdGNvbG9yOiAnYmxhY2snXG5cdFx0XHRcdH1cblx0XHRcdH0sIG5vcm1hbFN0YXRlKTtcblx0XHRcdG5vcm1hbFN0eWxlID0gbm9ybWFsU3RhdGUuc3R5bGU7XG5cdFx0XHRkZWxldGUgbm9ybWFsU3RhdGUuc3R5bGU7XG5cblx0XHRcdC8vIEhvdmVyIHN0YXRlXG5cdFx0XHRob3ZlclN0YXRlID0gbWVyZ2Uobm9ybWFsU3RhdGUsIHtcblx0XHRcdFx0c3Ryb2tlOiAnIzY4QScsXG5cdFx0XHRcdGZpbGw6IHtcblx0XHRcdFx0XHRsaW5lYXJHcmFkaWVudDogdmVydGljYWxHcmFkaWVudCxcblx0XHRcdFx0XHRzdG9wczogW1xuXHRcdFx0XHRcdFx0WzAsICcjRkZGJ10sXG5cdFx0XHRcdFx0XHRbMSwgJyNBQ0YnXVxuXHRcdFx0XHRcdF1cblx0XHRcdFx0fVxuXHRcdFx0fSwgaG92ZXJTdGF0ZSk7XG5cdFx0XHRob3ZlclN0eWxlID0gaG92ZXJTdGF0ZS5zdHlsZTtcblx0XHRcdGRlbGV0ZSBob3ZlclN0YXRlLnN0eWxlO1xuXG5cdFx0XHQvLyBQcmVzc2VkIHN0YXRlXG5cdFx0XHRwcmVzc2VkU3RhdGUgPSBtZXJnZShub3JtYWxTdGF0ZSwge1xuXHRcdFx0XHRzdHJva2U6ICcjNjhBJyxcblx0XHRcdFx0ZmlsbDoge1xuXHRcdFx0XHRcdGxpbmVhckdyYWRpZW50OiB2ZXJ0aWNhbEdyYWRpZW50LFxuXHRcdFx0XHRcdHN0b3BzOiBbXG5cdFx0XHRcdFx0XHRbMCwgJyM5QkQnXSxcblx0XHRcdFx0XHRcdFsxLCAnI0NERiddXG5cdFx0XHRcdFx0XVxuXHRcdFx0XHR9XG5cdFx0XHR9LCBwcmVzc2VkU3RhdGUpO1xuXHRcdFx0cHJlc3NlZFN0eWxlID0gcHJlc3NlZFN0YXRlLnN0eWxlO1xuXHRcdFx0ZGVsZXRlIHByZXNzZWRTdGF0ZS5zdHlsZTtcblxuXHRcdFx0Ly8gRGlzYWJsZWQgc3RhdGVcblx0XHRcdGRpc2FibGVkU3RhdGUgPSBtZXJnZShub3JtYWxTdGF0ZSwge1xuXHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdGNvbG9yOiAnI0NDQydcblx0XHRcdFx0fVxuXHRcdFx0fSwgZGlzYWJsZWRTdGF0ZSk7XG5cdFx0XHRkaXNhYmxlZFN0eWxlID0gZGlzYWJsZWRTdGF0ZS5zdHlsZTtcblx0XHRcdGRlbGV0ZSBkaXNhYmxlZFN0YXRlLnN0eWxlO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50cy4gSUU5IGFuZCBJRTEwIG5lZWQgbW91c2VvdmVyIGFuZCBtb3VzZW91dCB0byBmdW5jaXRvbiAoIzY2NykuXG5cdFx0XHRhZGRFdmVudChsYWJlbC5lbGVtZW50LCBpc0lFID8gJ21vdXNlb3ZlcicgOiAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGN1clN0YXRlICE9PSAzKSB7XG5cdFx0XHRcdFx0bGFiZWwuYXR0cihob3ZlclN0YXRlKVxuXHRcdFx0XHRcdFx0LmNzcyhob3ZlclN0eWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRhZGRFdmVudChsYWJlbC5lbGVtZW50LCBpc0lFID8gJ21vdXNlb3V0JyA6ICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoY3VyU3RhdGUgIT09IDMpIHtcblx0XHRcdFx0XHRzdGF0ZU9wdGlvbnMgPSBbbm9ybWFsU3RhdGUsIGhvdmVyU3RhdGUsIHByZXNzZWRTdGF0ZV1bY3VyU3RhdGVdO1xuXHRcdFx0XHRcdHN0YXRlU3R5bGUgPSBbbm9ybWFsU3R5bGUsIGhvdmVyU3R5bGUsIHByZXNzZWRTdHlsZV1bY3VyU3RhdGVdO1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIoc3RhdGVPcHRpb25zKVxuXHRcdFx0XHRcdFx0LmNzcyhzdGF0ZVN0eWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGxhYmVsLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG5cdFx0XHRcdGxhYmVsLnN0YXRlID0gY3VyU3RhdGUgPSBzdGF0ZTtcblx0XHRcdFx0aWYgKCFzdGF0ZSkge1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIobm9ybWFsU3RhdGUpXG5cdFx0XHRcdFx0XHQuY3NzKG5vcm1hbFN0eWxlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gMikge1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIocHJlc3NlZFN0YXRlKVxuXHRcdFx0XHRcdFx0LmNzcyhwcmVzc2VkU3R5bGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSAzKSB7XG5cdFx0XHRcdFx0bGFiZWwuYXR0cihkaXNhYmxlZFN0YXRlKVxuXHRcdFx0XHRcdFx0LmNzcyhkaXNhYmxlZFN0eWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIGxhYmVsXG5cdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKGN1clN0YXRlICE9PSAzKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKGxhYmVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hdHRyKG5vcm1hbFN0YXRlKVxuXHRcdFx0XHQuY3NzKGV4dGVuZCh7IGN1cnNvcjogJ2RlZmF1bHQnIH0sIG5vcm1hbFN0eWxlKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1ha2UgYSBzdHJhaWdodCBsaW5lIGNyaXNwZXIgYnkgbm90IHNwaWxsaW5nIG91dCB0byBuZWlnaGJvdXIgcGl4ZWxzXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICovXG5cdFx0Y3Jpc3BMaW5lOiBmdW5jdGlvbiAocG9pbnRzLCB3aWR0aCkge1xuXHRcdFx0Ly8gcG9pbnRzIGZvcm1hdDogW00sIDAsIDAsIEwsIDEwMCwgMF1cblx0XHRcdC8vIG5vcm1hbGl6ZSB0byBhIGNyaXNwIGxpbmVcblx0XHRcdGlmIChwb2ludHNbMV0gPT09IHBvaW50c1s0XSkge1xuXHRcdFx0XHQvLyBTdWJzdHJhY3QgZHVlIHRvICMxMTI5LiBOb3cgYm90dG9tIGFuZCBsZWZ0IGF4aXMgZ3JpZGxpbmVzIGJlaGF2ZSB0aGUgc2FtZS5cblx0XHRcdFx0cG9pbnRzWzFdID0gcG9pbnRzWzRdID0gbWF0aFJvdW5kKHBvaW50c1sxXSkgLSAod2lkdGggJSAyIC8gMik7XG5cdFx0XHR9XG5cdFx0XHRpZiAocG9pbnRzWzJdID09PSBwb2ludHNbNV0pIHtcblx0XHRcdFx0cG9pbnRzWzJdID0gcG9pbnRzWzVdID0gbWF0aFJvdW5kKHBvaW50c1syXSkgKyAod2lkdGggJSAyIC8gMik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgYSBwYXRoXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gcGF0aCBBbiBTVkcgcGF0aCBpbiBhcnJheSBmb3JtXG5cdFx0ICovXG5cdFx0cGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRcdHZhciBhdHRyID0ge1xuXHRcdFx0XHRmaWxsOiBOT05FXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGlzQXJyYXkocGF0aCkpIHtcblx0XHRcdFx0YXR0ci5kID0gcGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaXNPYmplY3QocGF0aCkpIHsgLy8gYXR0cmlidXRlc1xuXHRcdFx0XHRleHRlbmQoYXR0ciwgcGF0aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KCdwYXRoJykuYXR0cihhdHRyKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyBhbmQgcmV0dXJuIGFuIFNWRyBjaXJjbGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJhZGl1c1xuXHRcdCAqL1xuXHRcdGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHIpIHtcblx0XHRcdHZhciBhdHRyID0gaXNPYmplY3QoeCkgP1xuXHRcdFx0XHR4IDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHg6IHgsXG5cdFx0XHRcdFx0eTogeSxcblx0XHRcdFx0XHRyOiByXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXBwZXIgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScpO1xuXG5cdFx0XHR3cmFwcGVyLnhTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnY3gnLCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci55U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2N5JywgdmFsdWUpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiB3cmFwcGVyLmF0dHIoYXR0cik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgYW5kIHJldHVybiBhbiBhcmNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSByIFJhZGl1c1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclIgSW5uZXIgcmFkaXVzIGxpa2UgdXNlZCBpbiBkb251dCBjaGFydHNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnRpbmcgYW5nbGVcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZGluZyBhbmdsZVxuXHRcdCAqL1xuXHRcdGFyYzogZnVuY3Rpb24gKHgsIHksIHIsIGlubmVyUiwgc3RhcnQsIGVuZCkge1xuXHRcdFx0dmFyIGFyYztcblxuXHRcdFx0aWYgKGlzT2JqZWN0KHgpKSB7XG5cdFx0XHRcdHkgPSB4Lnk7XG5cdFx0XHRcdHIgPSB4LnI7XG5cdFx0XHRcdGlubmVyUiA9IHguaW5uZXJSO1xuXHRcdFx0XHRzdGFydCA9IHguc3RhcnQ7XG5cdFx0XHRcdGVuZCA9IHguZW5kO1xuXHRcdFx0XHR4ID0geC54O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcmNzIGFyZSBkZWZpbmVkIGFzIHN5bWJvbHMgZm9yIHRoZSBhYmlsaXR5IHRvIHNldFxuXHRcdFx0Ly8gYXR0cmlidXRlcyBpbiBhdHRyIGFuZCBhbmltYXRlXG5cdFx0XHRhcmMgPSB0aGlzLnN5bWJvbCgnYXJjJywgeCB8fCAwLCB5IHx8IDAsIHIgfHwgMCwgciB8fCAwLCB7XG5cdFx0XHRcdGlubmVyUjogaW5uZXJSIHx8IDAsXG5cdFx0XHRcdHN0YXJ0OiBzdGFydCB8fCAwLFxuXHRcdFx0XHRlbmQ6IGVuZCB8fCAwXG5cdFx0XHR9KTtcblx0XHRcdGFyYy5yID0gcjsgLy8gIzk1OVxuXHRcdFx0cmV0dXJuIGFyYztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyBhbmQgcmV0dXJuIGEgcmVjdGFuZ2xlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRvcCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gciBCb3JkZXIgY29ybmVyIHJhZGl1c1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdHJva2VXaWR0aCBBIHN0cm9rZSB3aWR0aCBjYW4gYmUgc3VwcGxpZWQgdG8gYWxsb3cgY3Jpc3AgZHJhd2luZ1xuXHRcdCAqL1xuXHRcdHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByLCBzdHJva2VXaWR0aCkge1xuXG5cdFx0XHRyID0gaXNPYmplY3QoeCkgPyB4LnIgOiByO1xuXG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgncmVjdCcpLFxuXHRcdFx0XHRhdHRyaWJzID0gaXNPYmplY3QoeCkgPyB4IDogeCA9PT0gVU5ERUZJTkVEID8ge30gOiB7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdHdpZHRoOiBtYXRoTWF4KHdpZHRoLCAwKSxcblx0XHRcdFx0XHRoZWlnaHQ6IG1hdGhNYXgoaGVpZ2h0LCAwKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRpZiAoc3Ryb2tlV2lkdGggIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRhdHRyaWJzLnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdGF0dHJpYnMgPSB3cmFwcGVyLmNyaXNwKGF0dHJpYnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocikge1xuXHRcdFx0XHRhdHRyaWJzLnIgPSByO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwcGVyLnJTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0YXR0cih0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0XHRyeDogdmFsdWUsXG5cdFx0XHRcdFx0cnk6IHZhbHVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHdyYXBwZXIuYXR0cihhdHRyaWJzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVzaXplIHRoZSBib3ggYW5kIHJlLWFsaWduIGFsbCBhbGlnbmVkIGVsZW1lbnRzXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGhlaWdodFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZVxuXHRcdCAqXG5cdFx0ICovXG5cdFx0c2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGFuaW1hdGUpIHtcblx0XHRcdHZhciByZW5kZXJlciA9IHRoaXMsXG5cdFx0XHRcdGFsaWduZWRPYmplY3RzID0gcmVuZGVyZXIuYWxpZ25lZE9iamVjdHMsXG5cdFx0XHRcdGkgPSBhbGlnbmVkT2JqZWN0cy5sZW5ndGg7XG5cblx0XHRcdHJlbmRlcmVyLndpZHRoID0gd2lkdGg7XG5cdFx0XHRyZW5kZXJlci5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRcdHJlbmRlcmVyLmJveFdyYXBwZXJbcGljayhhbmltYXRlLCB0cnVlKSA/ICdhbmltYXRlJyA6ICdhdHRyJ10oe1xuXHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHR9KTtcblxuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRhbGlnbmVkT2JqZWN0c1tpXS5hbGlnbigpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBncm91cFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBncm91cCB3aWxsIGJlIGdpdmVuIGEgY2xhc3MgbmFtZSBvZiAnaGlnaGNoYXJ0cy17bmFtZX0nLlxuXHRcdCAqXHQgVGhpcyBjYW4gYmUgdXNlZCBmb3Igc3R5bGluZyBhbmQgc2NyaXB0aW5nLlxuXHRcdCAqL1xuXHRcdGc6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZycpO1xuXHRcdFx0cmV0dXJuIGRlZmluZWQobmFtZSkgPyBlbGVtLmF0dHIoeyAnY2xhc3MnOiBQUkVGSVggKyBuYW1lIH0pIDogZWxlbTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGlzcGxheSBhbiBpbWFnZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuXHRcdCAqL1xuXHRcdGltYWdlOiBmdW5jdGlvbiAoc3JjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0XHR2YXIgYXR0cmlicyA9IHtcblx0XHRcdFx0XHRwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBOT05FXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVsZW1XcmFwcGVyO1xuXG5cdFx0XHQvLyBvcHRpb25hbCBwcm9wZXJ0aWVzXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0ZXh0ZW5kKGF0dHJpYnMsIHtcblx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtV3JhcHBlciA9IHRoaXMuY3JlYXRlRWxlbWVudCgnaW1hZ2UnKS5hdHRyKGF0dHJpYnMpO1xuXG5cdFx0XHQvLyBzZXQgdGhlIGhyZWYgaW4gdGhlIHhsaW5rIG5hbWVzcGFjZVxuXHRcdFx0aWYgKGVsZW1XcmFwcGVyLmVsZW1lbnQuc2V0QXR0cmlidXRlTlMpIHtcblx0XHRcdFx0ZWxlbVdyYXBwZXIuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cdFx0XHRcdFx0J2hyZWYnLCBzcmMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY291bGQgYmUgZXhwb3J0aW5nIGluIElFXG5cdFx0XHRcdC8vIHVzaW5nIGhyZWYgdGhyb3dzIFwibm90IHN1cHBvcnRlZFwiIGluIGllNyBhbmQgdW5kZXIsIHJlcXVyaWVzIHJlZ2V4IHNoaW0gdG8gZml4IGxhdGVyXG5cdFx0XHRcdGVsZW1XcmFwcGVyLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdoYy1zdmctaHJlZicsIHNyYyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWxlbVdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgYSBzeW1ib2wgb3V0IG9mIHByZS1kZWZpbmVkIHNoYXBlIHBhdGhzIGZyb20gdGhlIG5hbWVzcGFjZSAnc3ltYm9sJyBvYmplY3QuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHhcblx0XHQgKiBAcGFyYW0ge09iamVjdH0geVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSByYWRpdXNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuXG5cdFx0XHR2YXIgb2JqLFxuXG5cdFx0XHRcdC8vIGdldCB0aGUgc3ltYm9sIGRlZmluaXRpb24gZnVuY3Rpb25cblx0XHRcdFx0c3ltYm9sRm4gPSB0aGlzLnN5bWJvbHNbc3ltYm9sXSxcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGVyZSdzIGEgcGF0aCBkZWZpbmVkIGZvciB0aGlzIHN5bWJvbFxuXHRcdFx0XHRwYXRoID0gc3ltYm9sRm4gJiYgc3ltYm9sRm4oXG5cdFx0XHRcdFx0bWF0aFJvdW5kKHgpLFxuXHRcdFx0XHRcdG1hdGhSb3VuZCh5KSxcblx0XHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQsXG5cdFx0XHRcdFx0b3B0aW9uc1xuXHRcdFx0XHQpLFxuXG5cdFx0XHRcdGltYWdlRWxlbWVudCxcblx0XHRcdFx0aW1hZ2VSZWdleCA9IC9edXJsXFwoKC4qPylcXCkkLyxcblx0XHRcdFx0aW1hZ2VTcmMsXG5cdFx0XHRcdGltYWdlU2l6ZSxcblx0XHRcdFx0Y2VudGVySW1hZ2U7XG5cblx0XHRcdGlmIChwYXRoKSB7XG5cblx0XHRcdFx0b2JqID0gdGhpcy5wYXRoKHBhdGgpO1xuXHRcdFx0XHQvLyBleHBhbmRvIHByb3BlcnRpZXMgZm9yIHVzZSBpbiBhbmltYXRlIGFuZCBhdHRyXG5cdFx0XHRcdGV4dGVuZChvYmosIHtcblx0XHRcdFx0XHRzeW1ib2xOYW1lOiBzeW1ib2wsXG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdFx0XHRleHRlbmQob2JqLCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdC8vIGltYWdlIHN5bWJvbHNcblx0XHRcdH0gZWxzZSBpZiAoaW1hZ2VSZWdleC50ZXN0KHN5bWJvbCkpIHtcblxuXHRcdFx0XHQvLyBPbiBpbWFnZSBsb2FkLCBzZXQgdGhlIHNpemUgYW5kIHBvc2l0aW9uXG5cdFx0XHRcdGNlbnRlckltYWdlID0gZnVuY3Rpb24gKGltZywgc2l6ZSkge1xuXHRcdFx0XHRcdGlmIChpbWcuZWxlbWVudCkgeyAvLyBpdCBtYXkgYmUgZGVzdHJveWVkIGluIHRoZSBtZWFudGltZSAoIzEzOTApXG5cdFx0XHRcdFx0XHRpbWcuYXR0cih7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBzaXplWzBdLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHNpemVbMV1cblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWltZy5hbGlnbkJ5VHJhbnNsYXRlKSB7IC8vICMxODVcblx0XHRcdFx0XHRcdFx0aW1nLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoKHdpZHRoIC0gc2l6ZVswXSkgLyAyKSwgLy8gIzEzNzhcblx0XHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoKGhlaWdodCAtIHNpemVbMV0pIC8gMilcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aW1hZ2VTcmMgPSBzeW1ib2wubWF0Y2goaW1hZ2VSZWdleClbMV07XG5cdFx0XHRcdGltYWdlU2l6ZSA9IHN5bWJvbFNpemVzW2ltYWdlU3JjXSB8fCAob3B0aW9ucyAmJiBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0ICYmIFtvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodF0pO1xuXG5cdFx0XHRcdC8vIElyZWF0ZSB0aGUgaW1hZ2Ugc3luY2hyb25vdXNseSwgYWRkIGF0dHJpYnMgYXN5bmNcblx0XHRcdFx0b2JqID0gdGhpcy5pbWFnZShpbWFnZVNyYylcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdFx0eTogeVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRvYmouaXNJbWcgPSB0cnVlO1xuXG5cdFx0XHRcdGlmIChpbWFnZVNpemUpIHtcblx0XHRcdFx0XHRjZW50ZXJJbWFnZShvYmosIGltYWdlU2l6ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBpbWFnZSB0byBiZSAwIHNpemUgc28gZXhwb3J0IHdpbGwgc3RpbGwgZnVuY3Rpb24gaWYgdGhlcmUncyBubyBjYWNoZWQgc2l6ZXMuXG5cdFx0XHRcdFx0b2JqLmF0dHIoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgZHVtbXkgSmF2YVNjcmlwdCBpbWFnZSB0byBnZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQuIER1ZSB0byBhIGJ1ZyBpbiBJRSA8IDgsXG5cdFx0XHRcdFx0Ly8gdGhlIGNyZWF0ZWQgZWxlbWVudCBtdXN0IGJlIGFzc2lnbmVkIHRvIGEgdmFyaWFibGUgaW4gb3JkZXIgdG8gbG9hZCAoIzI5MikuXG5cdFx0XHRcdFx0aW1hZ2VFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgnaW1nJywge1xuXHRcdFx0XHRcdFx0b25sb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdGNlbnRlckltYWdlKG9iaiwgc3ltYm9sU2l6ZXNbaW1hZ2VTcmNdID0gW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0c3JjOiBpbWFnZVNyY1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGV4dGVuZGFibGUgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgZm9yIGRlZmluaW5nIHN5bWJvbCBwYXRocy5cblx0XHQgKi9cblx0XHRzeW1ib2xzOiB7XG5cdFx0XHQnY2lyY2xlJzogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHRcdFx0dmFyIGNwdyA9IDAuMTY2ICogdztcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRNLCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdFx0J0MnLCB4ICsgdyArIGNwdywgeSwgeCArIHcgKyBjcHcsIHkgKyBoLCB4ICsgdyAvIDIsIHkgKyBoLFxuXHRcdFx0XHRcdCdDJywgeCAtIGNwdywgeSArIGgsIHggLSBjcHcsIHksIHggKyB3IC8gMiwgeSxcblx0XHRcdFx0XHQnWidcblx0XHRcdFx0XTtcblx0XHRcdH0sXG5cblx0XHRcdCdzcXVhcmUnOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdE0sIHgsIHksXG5cdFx0XHRcdFx0TCwgeCArIHcsIHksXG5cdFx0XHRcdFx0eCArIHcsIHkgKyBoLFxuXHRcdFx0XHRcdHgsIHkgKyBoLFxuXHRcdFx0XHRcdCdaJ1xuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblxuXHRcdFx0J3RyaWFuZ2xlJzogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRNLCB4ICsgdyAvIDIsIHksXG5cdFx0XHRcdFx0TCwgeCArIHcsIHkgKyBoLFxuXHRcdFx0XHRcdHgsIHkgKyBoLFxuXHRcdFx0XHRcdCdaJ1xuXHRcdFx0XHRdO1xuXHRcdFx0fSxcblxuXHRcdFx0J3RyaWFuZ2xlLWRvd24nOiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdE0sIHgsIHksXG5cdFx0XHRcdFx0TCwgeCArIHcsIHksXG5cdFx0XHRcdFx0eCArIHcgLyAyLCB5ICsgaCxcblx0XHRcdFx0XHQnWidcblx0XHRcdFx0XTtcblx0XHRcdH0sXG5cdFx0XHQnZGlhbW9uZCc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0TSwgeCArIHcgLyAyLCB5LFxuXHRcdFx0XHRcdEwsIHggKyB3LCB5ICsgaCAvIDIsXG5cdFx0XHRcdFx0eCArIHcgLyAyLCB5ICsgaCxcblx0XHRcdFx0XHR4LCB5ICsgaCAvIDIsXG5cdFx0XHRcdFx0J1onXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0J2FyYyc6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQsXG5cdFx0XHRcdFx0cmFkaXVzID0gb3B0aW9ucy5yIHx8IHcgfHwgaCxcblx0XHRcdFx0XHRlbmQgPSBvcHRpb25zLmVuZCAtIDAuMDAxLCAvLyB0byBwcmV2ZW50IGNvcyBhbmQgc2luIG9mIHN0YXJ0IGFuZCBlbmQgZnJvbSBiZWNvbWluZyBlcXVhbCBvbiAzNjAgYXJjcyAocmVsYXRlZDogIzE1NjEpXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXMgPSBvcHRpb25zLmlubmVyUixcblx0XHRcdFx0XHRvcGVuID0gb3B0aW9ucy5vcGVuLFxuXHRcdFx0XHRcdGNvc1N0YXJ0ID0gbWF0aENvcyhzdGFydCksXG5cdFx0XHRcdFx0c2luU3RhcnQgPSBtYXRoU2luKHN0YXJ0KSxcblx0XHRcdFx0XHRjb3NFbmQgPSBtYXRoQ29zKGVuZCksXG5cdFx0XHRcdFx0c2luRW5kID0gbWF0aFNpbihlbmQpLFxuXHRcdFx0XHRcdGxvbmdBcmMgPSBvcHRpb25zLmVuZCAtIHN0YXJ0IDwgbWF0aFBJID8gMCA6IDE7XG5cblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdHggKyByYWRpdXMgKiBjb3NTdGFydCxcblx0XHRcdFx0XHR5ICsgcmFkaXVzICogc2luU3RhcnQsXG5cdFx0XHRcdFx0J0EnLCAvLyBhcmNUb1xuXHRcdFx0XHRcdHJhZGl1cywgLy8geCByYWRpdXNcblx0XHRcdFx0XHRyYWRpdXMsIC8vIHkgcmFkaXVzXG5cdFx0XHRcdFx0MCwgLy8gc2xhbnRpbmdcblx0XHRcdFx0XHRsb25nQXJjLCAvLyBsb25nIG9yIHNob3J0IGFyY1xuXHRcdFx0XHRcdDEsIC8vIGNsb2Nrd2lzZVxuXHRcdFx0XHRcdHggKyByYWRpdXMgKiBjb3NFbmQsXG5cdFx0XHRcdFx0eSArIHJhZGl1cyAqIHNpbkVuZCxcblx0XHRcdFx0XHRvcGVuID8gTSA6IEwsXG5cdFx0XHRcdFx0eCArIGlubmVyUmFkaXVzICogY29zRW5kLFxuXHRcdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpbkVuZCxcblx0XHRcdFx0XHQnQScsIC8vIGFyY1RvXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXMsIC8vIHggcmFkaXVzXG5cdFx0XHRcdFx0aW5uZXJSYWRpdXMsIC8vIHkgcmFkaXVzXG5cdFx0XHRcdFx0MCwgLy8gc2xhbnRpbmdcblx0XHRcdFx0XHRsb25nQXJjLCAvLyBsb25nIG9yIHNob3J0IGFyY1xuXHRcdFx0XHRcdDAsIC8vIGNsb2Nrd2lzZVxuXHRcdFx0XHRcdHggKyBpbm5lclJhZGl1cyAqIGNvc1N0YXJ0LFxuXHRcdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpblN0YXJ0LFxuXG5cdFx0XHRcdFx0b3BlbiA/ICcnIDogJ1onIC8vIGNsb3NlXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENhbGxvdXQgc2hhcGUgdXNlZCBmb3IgZGVmYXVsdCB0b29sdGlwcywgYWxzbyB1c2VkIGZvciByb3VuZGVkIHJlY3RhbmdsZXMgaW4gVk1MXG5cdFx0XHQgKi9cblx0XHRcdGNhbGxvdXQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBhcnJvd0xlbmd0aCA9IDYsXG5cdFx0XHRcdFx0aGFsZkRpc3RhbmNlID0gNixcblx0XHRcdFx0XHRyID0gbWF0aE1pbigob3B0aW9ucyAmJiBvcHRpb25zLnIpIHx8IDAsIHcsIGgpLFxuXHRcdFx0XHRcdHNhZmVEaXN0YW5jZSA9IHIgKyBoYWxmRGlzdGFuY2UsXG5cdFx0XHRcdFx0YW5jaG9yWCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbmNob3JYLFxuXHRcdFx0XHRcdGFuY2hvclkgPSBvcHRpb25zICYmIG9wdGlvbnMuYW5jaG9yWSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdG5vcm1hbGl6ZXIgPSBtYXRoUm91bmQob3B0aW9ucy5zdHJva2VXaWR0aCB8fCAwKSAlIDIgLyAyOyAvLyBtYXRoUm91bmQgYmVjYXVzZSBzdHJva2VXaWR0aCBjYW4gc29tZXRpbWVzIGhhdmUgcm91bmRvZmYgZXJyb3JzO1xuXG5cdFx0XHRcdHggKz0gbm9ybWFsaXplcjtcblx0XHRcdFx0eSArPSBub3JtYWxpemVyO1xuXHRcdFx0XHRwYXRoID0gW1xuXHRcdFx0XHRcdCdNJywgeCArIHIsIHksIFxuXHRcdFx0XHRcdCdMJywgeCArIHcgLSByLCB5LCAvLyB0b3Agc2lkZVxuXHRcdFx0XHRcdCdDJywgeCArIHcsIHksIHggKyB3LCB5LCB4ICsgdywgeSArIHIsIC8vIHRvcC1yaWdodCBjb3JuZXJcblx0XHRcdFx0XHQnTCcsIHggKyB3LCB5ICsgaCAtIHIsIC8vIHJpZ2h0IHNpZGVcblx0XHRcdFx0XHQnQycsIHggKyB3LCB5ICsgaCwgeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoLCAvLyBib3R0b20tcmlnaHQgY29ybmVyXG5cdFx0XHRcdFx0J0wnLCB4ICsgciwgeSArIGgsIC8vIGJvdHRvbSBzaWRlXG5cdFx0XHRcdFx0J0MnLCB4LCB5ICsgaCwgeCwgeSArIGgsIHgsIHkgKyBoIC0gciwgLy8gYm90dG9tLWxlZnQgY29ybmVyXG5cdFx0XHRcdFx0J0wnLCB4LCB5ICsgciwgLy8gbGVmdCBzaWRlXG5cdFx0XHRcdFx0J0MnLCB4LCB5LCB4LCB5LCB4ICsgciwgeSAvLyB0b3AtcmlnaHQgY29ybmVyXG5cdFx0XHRcdF07XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYW5jaG9yWCAmJiBhbmNob3JYID4gdyAmJiBhbmNob3JZID4geSArIHNhZmVEaXN0YW5jZSAmJiBhbmNob3JZIDwgeSArIGggLSBzYWZlRGlzdGFuY2UpIHsgLy8gcmVwbGFjZSByaWdodCBzaWRlXG5cdFx0XHRcdFx0cGF0aC5zcGxpY2UoMTMsIDMsXG5cdFx0XHRcdFx0XHQnTCcsIHggKyB3LCBhbmNob3JZIC0gaGFsZkRpc3RhbmNlLCBcblx0XHRcdFx0XHRcdHggKyB3ICsgYXJyb3dMZW5ndGgsIGFuY2hvclksXG5cdFx0XHRcdFx0XHR4ICsgdywgYW5jaG9yWSArIGhhbGZEaXN0YW5jZSxcblx0XHRcdFx0XHRcdHggKyB3LCB5ICsgaCAtIHJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFuY2hvclggJiYgYW5jaG9yWCA8IDAgJiYgYW5jaG9yWSA+IHkgKyBzYWZlRGlzdGFuY2UgJiYgYW5jaG9yWSA8IHkgKyBoIC0gc2FmZURpc3RhbmNlKSB7IC8vIHJlcGxhY2UgbGVmdCBzaWRlXG5cdFx0XHRcdFx0cGF0aC5zcGxpY2UoMzMsIDMsIFxuXHRcdFx0XHRcdFx0J0wnLCB4LCBhbmNob3JZICsgaGFsZkRpc3RhbmNlLCBcblx0XHRcdFx0XHRcdHggLSBhcnJvd0xlbmd0aCwgYW5jaG9yWSxcblx0XHRcdFx0XHRcdHgsIGFuY2hvclkgLSBoYWxmRGlzdGFuY2UsXG5cdFx0XHRcdFx0XHR4LCB5ICsgclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYW5jaG9yWSAmJiBhbmNob3JZID4gaCAmJiBhbmNob3JYID4geCArIHNhZmVEaXN0YW5jZSAmJiBhbmNob3JYIDwgeCArIHcgLSBzYWZlRGlzdGFuY2UpIHsgLy8gcmVwbGFjZSBib3R0b21cblx0XHRcdFx0XHRwYXRoLnNwbGljZSgyMywgMyxcblx0XHRcdFx0XHRcdCdMJywgYW5jaG9yWCArIGhhbGZEaXN0YW5jZSwgeSArIGgsXG5cdFx0XHRcdFx0XHRhbmNob3JYLCB5ICsgaCArIGFycm93TGVuZ3RoLFxuXHRcdFx0XHRcdFx0YW5jaG9yWCAtIGhhbGZEaXN0YW5jZSwgeSArIGgsXG5cdFx0XHRcdFx0XHR4ICsgciwgeSArIGhcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFuY2hvclkgJiYgYW5jaG9yWSA8IDAgJiYgYW5jaG9yWCA+IHggKyBzYWZlRGlzdGFuY2UgJiYgYW5jaG9yWCA8IHggKyB3IC0gc2FmZURpc3RhbmNlKSB7IC8vIHJlcGxhY2UgdG9wXG5cdFx0XHRcdFx0cGF0aC5zcGxpY2UoMywgMyxcblx0XHRcdFx0XHRcdCdMJywgYW5jaG9yWCAtIGhhbGZEaXN0YW5jZSwgeSxcblx0XHRcdFx0XHRcdGFuY2hvclgsIHkgLSBhcnJvd0xlbmd0aCxcblx0XHRcdFx0XHRcdGFuY2hvclggKyBoYWxmRGlzdGFuY2UsIHksXG5cdFx0XHRcdFx0XHR3IC0gciwgeVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlZmluZSBhIGNsaXBwaW5nIHJlY3RhbmdsZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICovXG5cdFx0Y2xpcFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0XHR2YXIgd3JhcHBlcixcblx0XHRcdFx0aWQgPSBQUkVGSVggKyBpZENvdW50ZXIrKyxcblxuXHRcdFx0XHRjbGlwUGF0aCA9IHRoaXMuY3JlYXRlRWxlbWVudCgnY2xpcFBhdGgnKS5hdHRyKHtcblx0XHRcdFx0XHRpZDogaWRcblx0XHRcdFx0fSkuYWRkKHRoaXMuZGVmcyk7XG5cblx0XHRcdHdyYXBwZXIgPSB0aGlzLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgMCkuYWRkKGNsaXBQYXRoKTtcblx0XHRcdHdyYXBwZXIuaWQgPSBpZDtcblx0XHRcdHdyYXBwZXIuY2xpcFBhdGggPSBjbGlwUGF0aDtcblx0XHRcdHdyYXBwZXIuY291bnQgPSAwO1xuXG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9LFxuXG5cblx0XHRcblxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIHRleHQgdG8gdGhlIFNWRyBvYmplY3Rcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRvcCBwb3NpdGlvblxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlSFRNTCBVc2UgSFRNTCB0byByZW5kZXIgdGhlIHRleHRcblx0XHQgKi9cblx0XHR0ZXh0OiBmdW5jdGlvbiAoc3RyLCB4LCB5LCB1c2VIVE1MKSB7XG5cblx0XHRcdC8vIGRlY2xhcmUgdmFyaWFibGVzXG5cdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0XHRmYWtlU1ZHID0gdXNlQ2FuVkcgfHwgKCFoYXNTVkcgJiYgcmVuZGVyZXIuZm9yRXhwb3J0KSxcblx0XHRcdFx0d3JhcHBlcixcblx0XHRcdFx0YXR0ciA9IHt9O1xuXG5cdFx0XHRpZiAodXNlSFRNTCAmJiAhcmVuZGVyZXIuZm9yRXhwb3J0KSB7XG5cdFx0XHRcdHJldHVybiByZW5kZXJlci5odG1sKHN0ciwgeCwgeSk7XG5cdFx0XHR9XG5cblx0XHRcdGF0dHIueCA9IE1hdGgucm91bmQoeCB8fCAwKTsgLy8gWCBpcyBhbHdheXMgbmVlZGVkIGZvciBsaW5lLXdyYXAgbG9naWNcblx0XHRcdGlmICh5KSB7XG5cdFx0XHRcdGF0dHIueSA9IE1hdGgucm91bmQoeSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3RyIHx8IHN0ciA9PT0gMCkge1xuXHRcdFx0XHRhdHRyLnRleHQgPSBzdHI7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXBwZXIgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KCd0ZXh0Jylcblx0XHRcdFx0LmF0dHIoYXR0cik7XG5cblx0XHRcdC8vIFByZXZlbnQgd3JhcHBpbmcgZnJvbSBjcmVhdGluZyBmYWxzZSBvZmZzZXRXaWR0aHMgaW4gZXhwb3J0IGluIGxlZ2FjeSBJRSAoIzEwNzksICMxMDYzKVxuXHRcdFx0aWYgKGZha2VTVkcpIHtcblx0XHRcdFx0d3JhcHBlci5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF1c2VIVE1MKSB7XG5cdFx0XHRcdHdyYXBwZXIueFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0dmFyIHRzcGFucyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RzcGFuJyksXG5cdFx0XHRcdFx0XHR0c3Bhbixcblx0XHRcdFx0XHRcdHBhcmVudFZhbCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGtleSksXG5cdFx0XHRcdFx0XHRpO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0c3BhbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHRzcGFuID0gdHNwYW5zW2ldO1xuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHggdmFsdWVzIGFyZSBlcXVhbCwgdGhlIHRzcGFuIHJlcHJlc2VudHMgYSBsaW5lYnJlYWtcblx0XHRcdFx0XHRcdGlmICh0c3Bhbi5nZXRBdHRyaWJ1dGUoa2V5KSA9PT0gcGFyZW50VmFsKSB7XG5cdFx0XHRcdFx0XHRcdHRzcGFuLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVdGlsaXR5IHRvIHJldHVybiB0aGUgYmFzZWxpbmUgb2Zmc2V0IGFuZCB0b3RhbCBsaW5lIGhlaWdodCBmcm9tIHRoZSBmb250IHNpemVcblx0XHQgKi9cblx0XHRmb250TWV0cmljczogZnVuY3Rpb24gKGZvbnRTaXplLCBlbGVtKSB7XG5cdFx0XHRmb250U2l6ZSA9IGZvbnRTaXplIHx8IHRoaXMuc3R5bGUuZm9udFNpemU7XG5cdFx0XHRpZiAoZWxlbSAmJiB3aW4uZ2V0Q29tcHV0ZWRTdHlsZSkge1xuXHRcdFx0XHRlbGVtID0gZWxlbS5lbGVtZW50IHx8IGVsZW07IC8vIFNWR0VsZW1lbnRcblx0XHRcdFx0Zm9udFNpemUgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBcIlwiKS5mb250U2l6ZTtcblx0XHRcdH1cblx0XHRcdGZvbnRTaXplID0gL3B4Ly50ZXN0KGZvbnRTaXplKSA/IHBJbnQoZm9udFNpemUpIDogL2VtLy50ZXN0KGZvbnRTaXplKSA/IHBhcnNlRmxvYXQoZm9udFNpemUpICogMTIgOiAxMjtcblxuXHRcdFx0Ly8gRW1waXJpY2FsIHZhbHVlcyBmb3VuZCBieSBjb21wYXJpbmcgZm9udCBzaXplIGFuZCBib3VuZGluZyBib3ggaGVpZ2h0LlxuXHRcdFx0Ly8gQXBwbGllcyB0byB0aGUgZGVmYXVsdCBmb250IGZhbWlseS4gaHR0cDovL2pzZmlkZGxlLm5ldC9oaWdoY2hhcnRzLzd4dm43L1xuXHRcdFx0dmFyIGxpbmVIZWlnaHQgPSBmb250U2l6ZSA8IDI0ID8gZm9udFNpemUgKyAzIDogbWF0aFJvdW5kKGZvbnRTaXplICogMS4yKSxcblx0XHRcdFx0YmFzZWxpbmUgPSBtYXRoUm91bmQobGluZUhlaWdodCAqIDAuOCk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGg6IGxpbmVIZWlnaHQsXG5cdFx0XHRcdGI6IGJhc2VsaW5lLFxuXHRcdFx0XHRmOiBmb250U2l6ZVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ29ycmVjdCBYIGFuZCBZIHBvc2l0aW9uaW5nIG9mIGEgbGFiZWwgZm9yIHJvdGF0aW9uICgjMTc2NClcblx0XHQgKi9cblx0XHRyb3RDb3JyOiBmdW5jdGlvbiAoYmFzZWxpbmUsIHJvdGF0aW9uLCBhbHRlclkpIHtcblx0XHRcdHZhciB5ID0gYmFzZWxpbmU7XG5cdFx0XHRpZiAocm90YXRpb24gJiYgYWx0ZXJZKSB7XG5cdFx0XHRcdHkgPSBtYXRoTWF4KHkgKiBtYXRoQ29zKHJvdGF0aW9uICogZGVnMnJhZCksIDQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogKC1iYXNlbGluZSAvIDMpICogbWF0aFNpbihyb3RhdGlvbiAqIGRlZzJyYWQpLFxuXHRcdFx0XHR5OiB5XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGQgYSBsYWJlbCwgYSB0ZXh0IGl0ZW0gdGhhdCBjYW4gaG9sZCBhIGNvbG9yZWQgb3IgZ3JhZGllbnQgYmFja2dyb3VuZFxuXHRcdCAqIGFzIHdlbGwgYXMgYSBib3JkZXIgYW5kIHNoYWRvdy5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzaGFwZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmNob3JYIEluIGNhc2UgdGhlIHNoYXBlIGhhcyBhIHBvaW50ZXIsIGxpa2UgYSBmbGFnLCB0aGlzIGlzIHRoZVxuXHRcdCAqXHRjb29yZGluYXRlcyBpdCBzaG91bGQgYmUgcGlubmVkIHRvXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuY2hvcllcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJhc2VsaW5lIFdoZXRoZXIgdG8gcG9zaXRpb24gdGhlIGxhYmVsIHJlbGF0aXZlIHRvIHRoZSB0ZXh0IGJhc2VsaW5lLFxuXHRcdCAqXHRsaWtlIHJlbmRlcmVyLnRleHQsIG9yIHRvIHRoZSB1cHBlciBib3JkZXIgb2YgdGhlIHJlY3RhbmdsZS5cblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIG5hbWUgZm9yIHRoZSBncm91cFxuXHRcdCAqL1xuXHRcdGxhYmVsOiBmdW5jdGlvbiAoc3RyLCB4LCB5LCBzaGFwZSwgYW5jaG9yWCwgYW5jaG9yWSwgdXNlSFRNTCwgYmFzZWxpbmUsIGNsYXNzTmFtZSkge1xuXG5cdFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLFxuXHRcdFx0XHR3cmFwcGVyID0gcmVuZGVyZXIuZyhjbGFzc05hbWUpLFxuXHRcdFx0XHR0ZXh0ID0gcmVuZGVyZXIudGV4dCgnJywgMCwgMCwgdXNlSFRNTClcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHR6SW5kZXg6IDFcblx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHQvLy5hZGQod3JhcHBlciksXG5cdFx0XHRcdGJveCxcblx0XHRcdFx0YkJveCxcblx0XHRcdFx0YWxpZ25GYWN0b3IgPSAwLFxuXHRcdFx0XHRwYWRkaW5nID0gMyxcblx0XHRcdFx0cGFkZGluZ0xlZnQgPSAwLFxuXHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0aGVpZ2h0LFxuXHRcdFx0XHR3cmFwcGVyWCxcblx0XHRcdFx0d3JhcHBlclksXG5cdFx0XHRcdGNyaXNwQWRqdXN0ID0gMCxcblx0XHRcdFx0ZGVmZXJyZWRBdHRyID0ge30sXG5cdFx0XHRcdGJhc2VsaW5lT2Zmc2V0LFxuXHRcdFx0XHRuZWVkc0JveDtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIGZ1bmN0aW9uIHJ1bnMgYWZ0ZXIgdGhlIGxhYmVsIGlzIGFkZGVkIHRvIHRoZSBET00gKHdoZW4gdGhlIGJvdW5kaW5nIGJveCBpc1xuXHRcdFx0ICogYXZhaWxhYmxlKSwgYW5kIGFmdGVyIHRoZSB0ZXh0IG9mIHRoZSBsYWJlbCBpcyB1cGRhdGVkIHRvIGRldGVjdCB0aGUgbmV3IGJvdW5kaW5nXG5cdFx0XHQgKiBib3ggYW5kIHJlZmxlY3QgaXQgaW4gdGhlIGJvcmRlciBib3guXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHVwZGF0ZUJveFNpemUoKSB7XG5cdFx0XHRcdHZhciBib3hYLFxuXHRcdFx0XHRcdGJveFksXG5cdFx0XHRcdFx0c3R5bGUgPSB0ZXh0LmVsZW1lbnQuc3R5bGU7XG5cblx0XHRcdFx0YkJveCA9ICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IHdyYXBwZXIuc3R5bGVzLnRleHRBbGlnbikgJiYgZGVmaW5lZCh0ZXh0LnRleHRTdHIpICYmIFxuXHRcdFx0XHRcdHRleHQuZ2V0QkJveCgpOyAvLyMzMjk1ICYmIDM1MTQgYm94IGZhaWx1cmUgd2hlbiBzdHJpbmcgZXF1YWxzIDBcblx0XHRcdFx0d3JhcHBlci53aWR0aCA9ICh3aWR0aCB8fCBiQm94LndpZHRoIHx8IDApICsgMiAqIHBhZGRpbmcgKyBwYWRkaW5nTGVmdDtcblx0XHRcdFx0d3JhcHBlci5oZWlnaHQgPSAoaGVpZ2h0IHx8IGJCb3guaGVpZ2h0IHx8IDApICsgMiAqIHBhZGRpbmc7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBsYWJlbC1zY29wZWQgeSBvZmZzZXRcblx0XHRcdFx0YmFzZWxpbmVPZmZzZXQgPSBwYWRkaW5nICsgcmVuZGVyZXIuZm9udE1ldHJpY3Moc3R5bGUgJiYgc3R5bGUuZm9udFNpemUsIHRleHQpLmI7XG5cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuZWVkc0JveCkge1xuXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIHRoZSBib3JkZXIgYm94IGlmIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnRcblx0XHRcdFx0XHRpZiAoIWJveCkge1xuXHRcdFx0XHRcdFx0Ym94WCA9IG1hdGhSb3VuZCgtYWxpZ25GYWN0b3IgKiBwYWRkaW5nKTtcblx0XHRcdFx0XHRcdGJveFkgPSBiYXNlbGluZSA/IC1iYXNlbGluZU9mZnNldCA6IDA7XG5cblx0XHRcdFx0XHRcdHdyYXBwZXIuYm94ID0gYm94ID0gc2hhcGUgP1xuXHRcdFx0XHRcdFx0XHRyZW5kZXJlci5zeW1ib2woc2hhcGUsIGJveFgsIGJveFksIHdyYXBwZXIud2lkdGgsIHdyYXBwZXIuaGVpZ2h0LCBkZWZlcnJlZEF0dHIpIDpcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIucmVjdChib3hYLCBib3hZLCB3cmFwcGVyLndpZHRoLCB3cmFwcGVyLmhlaWdodCwgMCwgZGVmZXJyZWRBdHRyW1NUUk9LRV9XSURUSF0pO1xuXHRcdFx0XHRcdFx0Ym94LmF0dHIoJ2ZpbGwnLCBOT05FKS5hZGQod3JhcHBlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gYXBwbHkgdGhlIGJveCBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0aWYgKCFib3guaXNJbWcpIHsgLy8gIzE2MzBcblx0XHRcdFx0XHRcdGJveC5hdHRyKGV4dGVuZCh7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBtYXRoUm91bmQod3JhcHBlci53aWR0aCksXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogbWF0aFJvdW5kKHdyYXBwZXIuaGVpZ2h0KVxuXHRcdFx0XHRcdFx0fSwgZGVmZXJyZWRBdHRyKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZmVycmVkQXR0ciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGlzIGZ1bmN0aW9uIHJ1bnMgYWZ0ZXIgc2V0dGluZyB0ZXh0IG9yIHBhZGRpbmcsIGJ1dCBvbmx5IGlmIHBhZGRpbmcgaXMgY2hhbmdlZFxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGVUZXh0UGFkZGluZygpIHtcblx0XHRcdFx0dmFyIHN0eWxlcyA9IHdyYXBwZXIuc3R5bGVzLFxuXHRcdFx0XHRcdHRleHRBbGlnbiA9IHN0eWxlcyAmJiBzdHlsZXMudGV4dEFsaWduLFxuXHRcdFx0XHRcdHggPSBwYWRkaW5nTGVmdCArIHBhZGRpbmcgKiAoMSAtIGFsaWduRmFjdG9yKSxcblx0XHRcdFx0XHR5O1xuXG5cdFx0XHRcdC8vIGRldGVybWluIHkgYmFzZWQgb24gdGhlIGJhc2VsaW5lXG5cdFx0XHRcdHkgPSBiYXNlbGluZSA/IDAgOiBiYXNlbGluZU9mZnNldDtcblxuXHRcdFx0XHQvLyBjb21wZW5zYXRlIGZvciBhbGlnbm1lbnRcblx0XHRcdFx0aWYgKGRlZmluZWQod2lkdGgpICYmIGJCb3ggJiYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgfHwgdGV4dEFsaWduID09PSAncmlnaHQnKSkge1xuXHRcdFx0XHRcdHggKz0geyBjZW50ZXI6IDAuNSwgcmlnaHQ6IDEgfVt0ZXh0QWxpZ25dICogKHdpZHRoIC0gYkJveC53aWR0aCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1cGRhdGUgaWYgYW55dGhpbmcgY2hhbmdlZFxuXHRcdFx0XHRpZiAoeCAhPT0gdGV4dC54IHx8IHkgIT09IHRleHQueSkge1xuXHRcdFx0XHRcdHRleHQuYXR0cigneCcsIHgpO1xuXHRcdFx0XHRcdGlmICh5ICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdC8vIEFzIGEgd29ya2Fyb3VuZCBmb3IgIzM2NDksIHVzZSB0cmFuc2xhdGlvbiBpbnN0ZWFkIG9mIHkgYXR0cmlidXRlLiAjMzY0OVxuXHRcdFx0XHRcdFx0Ly8gaXMgYSByZW5kZXJpbmcgYnVnIGluIFdlYktpdCBmb3IgUmV0aW5hIChNYWMsIGlPUywgUGhhbnRvbUpTKSB0aGF0IFxuXHRcdFx0XHRcdFx0Ly8gcmVzdWx0cyBpbiBkdXBsaWNhdGVkIHRleHQgd2hlbiBhbiB5IGF0dHJpYnV0ZSBpcyB1c2VkIGluIGNvbWJpbmF0aW9uIFxuXHRcdFx0XHRcdFx0Ly8gd2l0aCBhIENTUyB0ZXh0LXN0eWxlLlxuXHRcdFx0XHRcdFx0dGV4dC5hdHRyKHRleHQuZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NQQU4nID8gJ3knIDogJ3RyYW5zbGF0ZVknLCB5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgY3VycmVudCB2YWx1ZXNcblx0XHRcdFx0dGV4dC54ID0geDtcblx0XHRcdFx0dGV4dC55ID0geTtcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXQgYSBib3ggYXR0cmlidXRlLCBvciBkZWZlciBpdCBpZiB0aGUgYm94IGlzIG5vdCB5ZXQgY3JlYXRlZFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGtleVxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIGJveEF0dHIoa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAoYm94KSB7XG5cdFx0XHRcdFx0Ym94LmF0dHIoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWRBdHRyW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFmdGVyIHRoZSB0ZXh0IGVsZW1lbnQgaXMgYWRkZWQsIGdldCB0aGUgZGVzaXJlZCBzaXplIG9mIHRoZSBib3JkZXIgYm94XG5cdFx0XHQgKiBhbmQgYWRkIGl0IGJlZm9yZSB0aGUgdGV4dCBpbiB0aGUgRE9NLlxuXHRcdFx0ICovXG5cdFx0XHR3cmFwcGVyLm9uQWRkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0ZXh0LmFkZCh3cmFwcGVyKTtcblx0XHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0XHR0ZXh0OiAoc3RyIHx8IHN0ciA9PT0gMCkgPyBzdHIgOiAnJywgLy8gYWxpZ25tZW50IGlzIGF2YWlsYWJsZSBub3cgLy8gIzMyOTU6IDAgbm90IHJlbmRlcmVkIGlmIGdpdmVuIGFzIGEgdmFsdWVcblx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdHk6IHlcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGJveCAmJiBkZWZpbmVkKGFuY2hvclgpKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0XHRcdGFuY2hvclg6IGFuY2hvclgsXG5cdFx0XHRcdFx0XHRhbmNob3JZOiBhbmNob3JZXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8qXG5cdFx0XHQgKiBBZGQgc3BlY2lmaWMgYXR0cmlidXRlIHNldHRlcnMuXG5cdFx0XHQgKi9cblxuXHRcdFx0Ly8gb25seSBjaGFuZ2UgbG9jYWwgdmFyaWFibGVzXG5cdFx0XHR3cmFwcGVyLndpZHRoU2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHdpZHRoID0gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5oZWlnaHRTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0aGVpZ2h0ID0gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5wYWRkaW5nU2V0dGVyID0gIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAoZGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IHBhZGRpbmcpIHtcblx0XHRcdFx0XHRwYWRkaW5nID0gd3JhcHBlci5wYWRkaW5nID0gdmFsdWU7XG5cdFx0XHRcdFx0dXBkYXRlVGV4dFBhZGRpbmcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIucGFkZGluZ0xlZnRTZXR0ZXIgPSAgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChkZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZSAhPT0gcGFkZGluZ0xlZnQpIHtcblx0XHRcdFx0XHRwYWRkaW5nTGVmdCA9IHZhbHVlO1xuXHRcdFx0XHRcdHVwZGF0ZVRleHRQYWRkaW5nKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblxuXHRcdFx0Ly8gY2hhbmdlIGxvY2FsIHZhcmlhYmxlIGFuZCBwcmV2ZW50IHNldHRpbmcgYXR0cmlidXRlIG9uIHRoZSBncm91cFxuXHRcdFx0d3JhcHBlci5hbGlnblNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRhbGlnbkZhY3RvciA9IHsgbGVmdDogMCwgY2VudGVyOiAwLjUsIHJpZ2h0OiAxIH1bdmFsdWVdO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gYXBwbHkgdGhlc2UgdG8gdGhlIGJveCBhbmQgdGhlIHRleHQgYWxpa2Vcblx0XHRcdHdyYXBwZXIudGV4dFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUgIT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdHRleHQudGV4dFNldHRlcih2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dXBkYXRlQm94U2l6ZSgpO1xuXHRcdFx0XHR1cGRhdGVUZXh0UGFkZGluZygpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gYXBwbHkgdGhlc2UgdG8gdGhlIGJveCBidXQgbm90IHRvIHRoZSB0ZXh0XG5cdFx0XHR3cmFwcGVyWydzdHJva2Utd2lkdGhTZXR0ZXInXSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdG5lZWRzQm94ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjcmlzcEFkanVzdCA9IHZhbHVlICUgMiAvIDI7XG5cdFx0XHRcdGJveEF0dHIoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci5zdHJva2VTZXR0ZXIgPSB3cmFwcGVyLmZpbGxTZXR0ZXIgPSB3cmFwcGVyLnJTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRpZiAoa2V5ID09PSAnZmlsbCcgJiYgdmFsdWUpIHtcblx0XHRcdFx0XHRuZWVkc0JveCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ym94QXR0cihrZXksIHZhbHVlKTtcblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLmFuY2hvclhTZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRhbmNob3JYID0gdmFsdWU7XG5cdFx0XHRcdGJveEF0dHIoa2V5LCB2YWx1ZSArIGNyaXNwQWRqdXN0IC0gd3JhcHBlclgpO1xuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIuYW5jaG9yWVNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGFuY2hvclkgPSB2YWx1ZTtcblx0XHRcdFx0Ym94QXR0cihrZXksIHZhbHVlIC0gd3JhcHBlclkpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gcmVuYW1lIGF0dHJpYnV0ZXNcblx0XHRcdHdyYXBwZXIueFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHR3cmFwcGVyLnggPSB2YWx1ZTsgLy8gZm9yIGFuaW1hdGlvbiBnZXR0ZXJcblx0XHRcdFx0aWYgKGFsaWduRmFjdG9yKSB7XG5cdFx0XHRcdFx0dmFsdWUgLT0gYWxpZ25GYWN0b3IgKiAoKHdpZHRoIHx8IGJCb3gud2lkdGgpICsgcGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d3JhcHBlclggPSBtYXRoUm91bmQodmFsdWUpO1xuXHRcdFx0XHR3cmFwcGVyLmF0dHIoJ3RyYW5zbGF0ZVgnLCB3cmFwcGVyWCk7XG5cdFx0XHR9O1xuXHRcdFx0d3JhcHBlci55U2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHdyYXBwZXJZID0gd3JhcHBlci55ID0gbWF0aFJvdW5kKHZhbHVlKTtcblx0XHRcdFx0d3JhcHBlci5hdHRyKCd0cmFuc2xhdGVZJywgd3JhcHBlclkpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gUmVkaXJlY3QgY2VydGFpbiBtZXRob2RzIHRvIGVpdGhlciB0aGUgYm94IG9yIHRoZSB0ZXh0XG5cdFx0XHR2YXIgYmFzZUNzcyA9IHdyYXBwZXIuY3NzO1xuXHRcdFx0cmV0dXJuIGV4dGVuZCh3cmFwcGVyLCB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBQaWNrIHVwIHNvbWUgcHJvcGVydGllcyBhbmQgYXBwbHkgdGhlbSB0byB0aGUgdGV4dCBpbnN0ZWFkIG9mIHRoZSB3cmFwcGVyXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRjc3M6IGZ1bmN0aW9uIChzdHlsZXMpIHtcblx0XHRcdFx0XHRpZiAoc3R5bGVzKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGV4dFN0eWxlcyA9IHt9O1xuXHRcdFx0XHRcdFx0c3R5bGVzID0gbWVyZ2Uoc3R5bGVzKTsgLy8gY3JlYXRlIGEgY29weSB0byBhdm9pZCBhbHRlcmluZyB0aGUgb3JpZ2luYWwgb2JqZWN0ICgjNTM3KVxuXHRcdFx0XHRcdFx0ZWFjaCh3cmFwcGVyLnRleHRQcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdFx0XHRcdFx0aWYgKHN0eWxlc1twcm9wXSAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGV4dFN0eWxlc1twcm9wXSA9IHN0eWxlc1twcm9wXTtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgc3R5bGVzW3Byb3BdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHRleHQuY3NzKHRleHRTdHlsZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gYmFzZUNzcy5jYWxsKHdyYXBwZXIsIHN0eWxlcyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBSZXR1cm4gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgYm94LCBub3QgdGhlIGdyb3VwXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRnZXRCQm94OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHdpZHRoOiBiQm94LndpZHRoICsgMiAqIHBhZGRpbmcsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGJCb3guaGVpZ2h0ICsgMiAqIHBhZGRpbmcsXG5cdFx0XHRcdFx0XHR4OiBiQm94LnggLSBwYWRkaW5nLFxuXHRcdFx0XHRcdFx0eTogYkJveC55IC0gcGFkZGluZ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBcHBseSB0aGUgc2hhZG93IHRvIHRoZSBib3hcblx0XHRcdFx0ICovXG5cdFx0XHRcdHNoYWRvdzogZnVuY3Rpb24gKGIpIHtcblx0XHRcdFx0XHRpZiAoYm94KSB7XG5cdFx0XHRcdFx0XHRib3guc2hhZG93KGIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIERlc3Ryb3kgYW5kIHJlbGVhc2UgbWVtb3J5LlxuXHRcdFx0XHQgKi9cblx0XHRcdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0Ly8gQWRkZWQgYnkgYnV0dG9uIGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdFx0cmVtb3ZlRXZlbnQod3JhcHBlci5lbGVtZW50LCAnbW91c2VlbnRlcicpO1xuXHRcdFx0XHRcdHJlbW92ZUV2ZW50KHdyYXBwZXIuZWxlbWVudCwgJ21vdXNlbGVhdmUnKTtcblxuXHRcdFx0XHRcdGlmICh0ZXh0KSB7XG5cdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChib3gpIHtcblx0XHRcdFx0XHRcdGJveCA9IGJveC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENhbGwgYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBkZXN0cm95IHRoZSByZXN0XG5cdFx0XHRcdFx0U1ZHRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHdyYXBwZXIpO1xuXG5cdFx0XHRcdFx0Ly8gUmVsZWFzZSBsb2NhbCBwb2ludGVycyAoIzEyOTgpXG5cdFx0XHRcdFx0d3JhcHBlciA9IHJlbmRlcmVyID0gdXBkYXRlQm94U2l6ZSA9IHVwZGF0ZVRleHRQYWRkaW5nID0gYm94QXR0ciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTsgLy8gZW5kIFNWR1JlbmRlcmVyXG5cblxuXHQvLyBnZW5lcmFsIHJlbmRlcmVyXG5cdFJlbmRlcmVyID0gU1ZHUmVuZGVyZXI7XG5cdC8vIGV4dGVuZCBTdmdFbGVtZW50IGZvciB1c2VIVE1MIG9wdGlvblxuXHRleHRlbmQoU1ZHRWxlbWVudC5wcm90b3R5cGUsIHtcblx0XHQvKipcblx0XHQgKiBBcHBseSBDU1MgdG8gSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB1c2VkIGluIHRleHQgd2l0aGluIFNWRyByZW5kZXJpbmcgYW5kXG5cdFx0ICogYnkgdGhlIFZNTCByZW5kZXJlclxuXHRcdCAqL1xuXHRcdGh0bWxDc3M6IGZ1bmN0aW9uIChzdHlsZXMpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0ZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0dGV4dFdpZHRoID0gc3R5bGVzICYmIGVsZW1lbnQudGFnTmFtZSA9PT0gJ1NQQU4nICYmIHN0eWxlcy53aWR0aDtcblxuXHRcdFx0aWYgKHRleHRXaWR0aCkge1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzLndpZHRoO1xuXHRcdFx0XHR3cmFwcGVyLnRleHRXaWR0aCA9IHRleHRXaWR0aDtcblx0XHRcdFx0d3JhcHBlci51cGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZXMgJiYgc3R5bGVzLnRleHRPdmVyZmxvdyA9PT0gJ2VsbGlwc2lzJykge1xuXHRcdFx0XHRzdHlsZXMud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuXHRcdFx0XHRzdHlsZXMub3ZlcmZsb3cgPSAnaGlkZGVuJztcblx0XHRcdH1cblx0XHRcdHdyYXBwZXIuc3R5bGVzID0gZXh0ZW5kKHdyYXBwZXIuc3R5bGVzLCBzdHlsZXMpO1xuXHRcdFx0Y3NzKHdyYXBwZXIuZWxlbWVudCwgc3R5bGVzKTtcblxuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFZNTCBhbmQgdXNlSFRNTCBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIHRoZSBib3VuZGluZyBib3ggYmFzZWQgb24gb2Zmc2V0c1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVmcmVzaCBXaGV0aGVyIHRvIGZvcmNlIGEgZnJlc2ggdmFsdWUgZnJvbSB0aGUgRE9NIG9yIHRvXG5cdFx0ICogdXNlIHRoZSBjYWNoZWQgdmFsdWVcblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gQSBoYXNoIGNvbnRhaW5pbmcgdmFsdWVzIGZvciB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0ICovXG5cblx0XHRodG1sR2V0QkJveDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50O1xuXG5cdFx0XHQvLyBmYWtpbmcgZ2V0QkJveCBpbiBleHBvcnRlZCBTVkcgaW4gbGVnYWN5IElFXG5cdFx0XHQvLyBmYWtpbmcgZ2V0QkJveCBpbiBleHBvcnRlZCBTVkcgaW4gbGVnYWN5IElFIChpcyB0aGlzIGEgZHVwbGljYXRlIG9mIHRoZSBmaXggZm9yICMxMDc5Pylcblx0XHRcdGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAndGV4dCcpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IEFCU09MVVRFO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiBlbGVtZW50Lm9mZnNldExlZnQsXG5cdFx0XHRcdHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuXHRcdFx0XHR3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodFxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVk1MIG92ZXJyaWRlIHByaXZhdGUgbWV0aG9kIHRvIHVwZGF0ZSBlbGVtZW50cyBiYXNlZCBvbiBpbnRlcm5hbFxuXHRcdCAqIHByb3BlcnRpZXMgYmFzZWQgb24gU1ZHIHRyYW5zZm9ybVxuXHRcdCAqL1xuXHRcdGh0bWxVcGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIGFsaWduaW5nIG5vbiBhZGRlZCBlbGVtZW50cyBpcyBleHBlbnNpdmVcblx0XHRcdGlmICghdGhpcy5hZGRlZCkge1xuXHRcdFx0XHR0aGlzLmFsaWduT25BZGQgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0cmVuZGVyZXIgPSB3cmFwcGVyLnJlbmRlcmVyLFxuXHRcdFx0XHRlbGVtID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0XHR0cmFuc2xhdGVYID0gd3JhcHBlci50cmFuc2xhdGVYIHx8IDAsXG5cdFx0XHRcdHRyYW5zbGF0ZVkgPSB3cmFwcGVyLnRyYW5zbGF0ZVkgfHwgMCxcblx0XHRcdFx0eCA9IHdyYXBwZXIueCB8fCAwLFxuXHRcdFx0XHR5ID0gd3JhcHBlci55IHx8IDAsXG5cdFx0XHRcdGFsaWduID0gd3JhcHBlci50ZXh0QWxpZ24gfHwgJ2xlZnQnLFxuXHRcdFx0XHRhbGlnbkNvcnJlY3Rpb24gPSB7IGxlZnQ6IDAsIGNlbnRlcjogMC41LCByaWdodDogMSB9W2FsaWduXSxcblx0XHRcdFx0c2hhZG93cyA9IHdyYXBwZXIuc2hhZG93cyxcblx0XHRcdFx0c3R5bGVzID0gd3JhcHBlci5zdHlsZXM7XG5cblx0XHRcdC8vIGFwcGx5IHRyYW5zbGF0ZVxuXHRcdFx0Y3NzKGVsZW0sIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogdHJhbnNsYXRlWCxcblx0XHRcdFx0bWFyZ2luVG9wOiB0cmFuc2xhdGVZXG5cdFx0XHR9KTtcblx0XHRcdGlmIChzaGFkb3dzKSB7IC8vIHVzZWQgaW4gbGFiZWxzL3Rvb2x0aXBcblx0XHRcdFx0ZWFjaChzaGFkb3dzLCBmdW5jdGlvbiAoc2hhZG93KSB7XG5cdFx0XHRcdFx0Y3NzKHNoYWRvdywge1xuXHRcdFx0XHRcdFx0bWFyZ2luTGVmdDogdHJhbnNsYXRlWCArIDEsXG5cdFx0XHRcdFx0XHRtYXJnaW5Ub3A6IHRyYW5zbGF0ZVkgKyAxXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhcHBseSBpbnZlcnNpb25cblx0XHRcdGlmICh3cmFwcGVyLmludmVydGVkKSB7IC8vIHdyYXBwZXIgaXMgYSBncm91cFxuXHRcdFx0XHRlYWNoKGVsZW0uY2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRcdFx0cmVuZGVyZXIuaW52ZXJ0Q2hpbGQoY2hpbGQsIGVsZW0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGVsZW0udGFnTmFtZSA9PT0gJ1NQQU4nKSB7XG5cblx0XHRcdFx0dmFyIHdpZHRoLFxuXHRcdFx0XHRcdHJvdGF0aW9uID0gd3JhcHBlci5yb3RhdGlvbixcblx0XHRcdFx0XHRiYXNlbGluZSxcblx0XHRcdFx0XHR0ZXh0V2lkdGggPSBwSW50KHdyYXBwZXIudGV4dFdpZHRoKSxcblx0XHRcdFx0XHRjdXJyZW50VGV4dFRyYW5zZm9ybSA9IFtyb3RhdGlvbiwgYWxpZ24sIGVsZW0uaW5uZXJIVE1MLCB3cmFwcGVyLnRleHRXaWR0aF0uam9pbignLCcpO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VGV4dFRyYW5zZm9ybSAhPT0gd3JhcHBlci5jVFQpIHsgLy8gZG8gdGhlIGNhbGN1bGF0aW9ucyBhbmQgRE9NIGFjY2VzcyBvbmx5IGlmIHByb3BlcnRpZXMgY2hhbmdlZFxuXG5cblx0XHRcdFx0XHRiYXNlbGluZSA9IHJlbmRlcmVyLmZvbnRNZXRyaWNzKGVsZW0uc3R5bGUuZm9udFNpemUpLmI7XG5cblx0XHRcdFx0XHQvLyBSZW5kZXJlciBzcGVjaWZpYyBoYW5kbGluZyBvZiBzcGFuIHJvdGF0aW9uXG5cdFx0XHRcdFx0aWYgKGRlZmluZWQocm90YXRpb24pKSB7XG5cdFx0XHRcdFx0XHR3cmFwcGVyLnNldFNwYW5Sb3RhdGlvbihyb3RhdGlvbiwgYWxpZ25Db3JyZWN0aW9uLCBiYXNlbGluZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0d2lkdGggPSBwaWNrKHdyYXBwZXIuZWxlbVdpZHRoLCBlbGVtLm9mZnNldFdpZHRoKTtcblxuXHRcdFx0XHRcdC8vIFVwZGF0ZSB0ZXh0V2lkdGhcblx0XHRcdFx0XHRpZiAod2lkdGggPiB0ZXh0V2lkdGggJiYgL1sgXFwtXS8udGVzdChlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0KSkgeyAvLyAjOTgzLCAjMTI1NFxuXHRcdFx0XHRcdFx0Y3NzKGVsZW0sIHtcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHRleHRXaWR0aCArIFBYLFxuXHRcdFx0XHRcdFx0XHRkaXNwbGF5OiAnYmxvY2snLFxuXHRcdFx0XHRcdFx0XHR3aGl0ZVNwYWNlOiAoc3R5bGVzICYmIHN0eWxlcy53aGl0ZVNwYWNlKSB8fCAnbm9ybWFsJyAvLyAjMzMzMVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR3aWR0aCA9IHRleHRXaWR0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3cmFwcGVyLmdldFNwYW5Db3JyZWN0aW9uKHdpZHRoLCBiYXNlbGluZSwgYWxpZ25Db3JyZWN0aW9uLCByb3RhdGlvbiwgYWxpZ24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYXBwbHkgcG9zaXRpb24gd2l0aCBjb3JyZWN0aW9uXG5cdFx0XHRcdGNzcyhlbGVtLCB7XG5cdFx0XHRcdFx0bGVmdDogKHggKyAod3JhcHBlci54Q29yciB8fCAwKSkgKyBQWCxcblx0XHRcdFx0XHR0b3A6ICh5ICsgKHdyYXBwZXIueUNvcnIgfHwgMCkpICsgUFhcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gZm9yY2UgcmVmbG93IGluIHdlYmtpdCB0byBhcHBseSB0aGUgbGVmdCBhbmQgdG9wIG9uIHVzZUhUTUwgZWxlbWVudCAoIzEyNDkpXG5cdFx0XHRcdGlmIChpc1dlYktpdCkge1xuXHRcdFx0XHRcdGJhc2VsaW5lID0gZWxlbS5vZmZzZXRIZWlnaHQ7IC8vIGFzc2lnbmVkIHRvIGJhc2VsaW5lIGZvciBKU0xpbnQgcHVycG9zZVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVjb3JkIGN1cnJlbnQgdGV4dCB0cmFuc2Zvcm1cblx0XHRcdFx0d3JhcHBlci5jVFQgPSBjdXJyZW50VGV4dFRyYW5zZm9ybTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSByb3RhdGlvbiBvZiBhbiBpbmRpdmlkdWFsIEhUTUwgc3BhblxuXHRcdCAqL1xuXHRcdHNldFNwYW5Sb3RhdGlvbjogZnVuY3Rpb24gKHJvdGF0aW9uLCBhbGlnbkNvcnJlY3Rpb24sIGJhc2VsaW5lKSB7XG5cdFx0XHR2YXIgcm90YXRpb25TdHlsZSA9IHt9LFxuXHRcdFx0XHRjc3NUcmFuc2Zvcm1LZXkgPSBpc0lFID8gJy1tcy10cmFuc2Zvcm0nIDogaXNXZWJLaXQgPyAnLXdlYmtpdC10cmFuc2Zvcm0nIDogaXNGaXJlZm94ID8gJ01velRyYW5zZm9ybScgOiBpc09wZXJhID8gJy1vLXRyYW5zZm9ybScgOiAnJztcblxuXHRcdFx0cm90YXRpb25TdHlsZVtjc3NUcmFuc2Zvcm1LZXldID0gcm90YXRpb25TdHlsZS50cmFuc2Zvcm0gPSAncm90YXRlKCcgKyByb3RhdGlvbiArICdkZWcpJztcblx0XHRcdHJvdGF0aW9uU3R5bGVbY3NzVHJhbnNmb3JtS2V5ICsgKGlzRmlyZWZveCA/ICdPcmlnaW4nIDogJy1vcmlnaW4nKV0gPSByb3RhdGlvblN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IChhbGlnbkNvcnJlY3Rpb24gKiAxMDApICsgJyUgJyArIGJhc2VsaW5lICsgJ3B4Jztcblx0XHRcdGNzcyh0aGlzLmVsZW1lbnQsIHJvdGF0aW9uU3R5bGUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGNvcnJlY3Rpb24gaW4gWCBhbmQgWSBwb3NpdGlvbmluZyBhcyB0aGUgZWxlbWVudCBpcyByb3RhdGVkLlxuXHRcdCAqL1xuXHRcdGdldFNwYW5Db3JyZWN0aW9uOiBmdW5jdGlvbiAod2lkdGgsIGJhc2VsaW5lLCBhbGlnbkNvcnJlY3Rpb24pIHtcblx0XHRcdHRoaXMueENvcnIgPSAtd2lkdGggKiBhbGlnbkNvcnJlY3Rpb247XG5cdFx0XHR0aGlzLnlDb3JyID0gLWJhc2VsaW5lO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gRXh0ZW5kIFN2Z1JlbmRlcmVyIGZvciB1c2VIVE1MIG9wdGlvbi5cblx0ZXh0ZW5kKFNWR1JlbmRlcmVyLnByb3RvdHlwZSwge1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBIVE1MIHRleHQgbm9kZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBWTUwgcmVuZGVyZXIgYXMgd2VsbCBhcyB0aGUgU1ZHXG5cdFx0ICogcmVuZGVyZXIgdGhyb3VnaCB0aGUgdXNlSFRNTCBvcHRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqL1xuXHRcdGh0bWw6IGZ1bmN0aW9uIChzdHIsIHgsIHkpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcy5jcmVhdGVFbGVtZW50KCdzcGFuJyksXG5cdFx0XHRcdGVsZW1lbnQgPSB3cmFwcGVyLmVsZW1lbnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gd3JhcHBlci5yZW5kZXJlcjtcblxuXHRcdFx0Ly8gVGV4dCBzZXR0ZXJcblx0XHRcdHdyYXBwZXIudGV4dFNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUgIT09IGVsZW1lbnQuaW5uZXJIVE1MKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuYkJveDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtZW50LmlubmVySFRNTCA9IHRoaXMudGV4dFN0ciA9IHZhbHVlO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVmFyaW91cyBzZXR0ZXJzIHdoaWNoIHJlbHkgb24gdXBkYXRlIHRyYW5zZm9ybVxuXHRcdFx0d3JhcHBlci54U2V0dGVyID0gd3JhcHBlci55U2V0dGVyID0gd3JhcHBlci5hbGlnblNldHRlciA9IHdyYXBwZXIucm90YXRpb25TZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRpZiAoa2V5ID09PSAnYWxpZ24nKSB7XG5cdFx0XHRcdFx0a2V5ID0gJ3RleHRBbGlnbic7IC8vIERvIG5vdCBvdmVyd3JpdGUgdGhlIFNWR0VsZW1lbnQuYWxpZ24gbWV0aG9kLiBTYW1lIGFzIFZNTC5cblx0XHRcdFx0fVxuXHRcdFx0XHR3cmFwcGVyW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0d3JhcHBlci5odG1sVXBkYXRlVHJhbnNmb3JtKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBTZXQgdGhlIGRlZmF1bHQgYXR0cmlidXRlc1xuXHRcdFx0d3JhcHBlci5hdHRyKHtcblx0XHRcdFx0XHR0ZXh0OiBzdHIsXG5cdFx0XHRcdFx0eDogbWF0aFJvdW5kKHgpLFxuXHRcdFx0XHRcdHk6IG1hdGhSb3VuZCh5KVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogQUJTT0xVVEUsXG5cdFx0XHRcdFx0Zm9udEZhbWlseTogdGhpcy5zdHlsZS5mb250RmFtaWx5LFxuXHRcdFx0XHRcdGZvbnRTaXplOiB0aGlzLnN0eWxlLmZvbnRTaXplXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBLZWVwIHRoZSB3aGl0ZVNwYWNlIHN0eWxlIG91dHNpZGUgdGhlIHdyYXBwZXIuc3R5bGVzIGNvbGxlY3Rpb25cblx0XHRcdGVsZW1lbnQuc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuXG5cdFx0XHQvLyBVc2UgdGhlIEhUTUwgc3BlY2lmaWMgLmNzcyBtZXRob2Rcblx0XHRcdHdyYXBwZXIuY3NzID0gd3JhcHBlci5odG1sQ3NzO1xuXG5cdFx0XHQvLyBUaGlzIGlzIHNwZWNpZmljIGZvciBIVE1MIHdpdGhpbiBTVkdcblx0XHRcdGlmIChyZW5kZXJlci5pc1NWRykge1xuXHRcdFx0XHR3cmFwcGVyLmFkZCA9IGZ1bmN0aW9uIChzdmdHcm91cFdyYXBwZXIpIHtcblxuXHRcdFx0XHRcdHZhciBodG1sR3JvdXAsXG5cdFx0XHRcdFx0XHRjb250YWluZXIgPSByZW5kZXJlci5ib3gucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdHBhcmVudEdyb3VwLFxuXHRcdFx0XHRcdFx0cGFyZW50cyA9IFtdO1xuXG5cdFx0XHRcdFx0dGhpcy5wYXJlbnRHcm91cCA9IHN2Z0dyb3VwV3JhcHBlcjtcblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBhIG1vY2sgZ3JvdXAgdG8gaG9sZCB0aGUgSFRNTCBlbGVtZW50c1xuXHRcdFx0XHRcdGlmIChzdmdHcm91cFdyYXBwZXIpIHtcblx0XHRcdFx0XHRcdGh0bWxHcm91cCA9IHN2Z0dyb3VwV3JhcHBlci5kaXY7XG5cdFx0XHRcdFx0XHRpZiAoIWh0bWxHcm91cCkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlYWQgdGhlIHBhcmVudCBjaGFpbiBpbnRvIGFuIGFycmF5IGFuZCByZWFkIGZyb20gdG9wIGRvd25cblx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXAgPSBzdmdHcm91cFdyYXBwZXI7XG5cdFx0XHRcdFx0XHRcdHdoaWxlIChwYXJlbnRHcm91cCkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50cy5wdXNoKHBhcmVudEdyb3VwKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE1vdmUgdXAgdG8gdGhlIG5leHQgcGFyZW50IGdyb3VwXG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXAgPSBwYXJlbnRHcm91cC5wYXJlbnRHcm91cDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIEVuc3VyZSBkeW5hbWljYWxseSB1cGRhdGluZyBwb3NpdGlvbiB3aGVuIGFueSBwYXJlbnQgaXMgdHJhbnNsYXRlZFxuXHRcdFx0XHRcdFx0XHRlYWNoKHBhcmVudHMucmV2ZXJzZSgpLCBmdW5jdGlvbiAocGFyZW50R3JvdXApIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaHRtbEdyb3VwU3R5bGU7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBIVE1MIGRpdiBhbmQgYXBwZW5kIGl0IHRvIHRoZSBwYXJlbnQgZGl2IHRvIGVtdWxhdGVcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgU1ZHIGdyb3VwIHN0cnVjdHVyZVxuXHRcdFx0XHRcdFx0XHRcdGh0bWxHcm91cCA9IHBhcmVudEdyb3VwLmRpdiA9IHBhcmVudEdyb3VwLmRpdiB8fCBjcmVhdGVFbGVtZW50KERJViwge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lOiBhdHRyKHBhcmVudEdyb3VwLmVsZW1lbnQsICdjbGFzcycpXG5cdFx0XHRcdFx0XHRcdFx0fSwge1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb246IEFCU09MVVRFLFxuXHRcdFx0XHRcdFx0XHRcdFx0bGVmdDogKHBhcmVudEdyb3VwLnRyYW5zbGF0ZVggfHwgMCkgKyBQWCxcblx0XHRcdFx0XHRcdFx0XHRcdHRvcDogKHBhcmVudEdyb3VwLnRyYW5zbGF0ZVkgfHwgMCkgKyBQWFxuXHRcdFx0XHRcdFx0XHRcdH0sIGh0bWxHcm91cCB8fCBjb250YWluZXIpOyAvLyB0aGUgdG9wIGdyb3VwIGlzIGFwcGVuZGVkIHRvIGNvbnRhaW5lclxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU2hvcnRjdXRcblx0XHRcdFx0XHRcdFx0XHRodG1sR3JvdXBTdHlsZSA9IGh0bWxHcm91cC5zdHlsZTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFNldCBsaXN0ZW5lcnMgdG8gdXBkYXRlIHRoZSBIVE1MIGRpdidzIHBvc2l0aW9uIHdoZW5ldmVyIHRoZSBTVkcgZ3JvdXBcblx0XHRcdFx0XHRcdFx0XHQvLyBwb3NpdGlvbiBpcyBjaGFuZ2VkXG5cdFx0XHRcdFx0XHRcdFx0ZXh0ZW5kKHBhcmVudEdyb3VwLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2xhdGVYU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRodG1sR3JvdXBTdHlsZS5sZWZ0ID0gdmFsdWUgKyBQWDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXBba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnRHcm91cC5kb1RyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNsYXRlWVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aHRtbEdyb3VwU3R5bGUudG9wID0gdmFsdWUgKyBQWDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50R3JvdXBba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnRHcm91cC5kb1RyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dmlzaWJpbGl0eVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aHRtbEdyb3VwU3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRodG1sR3JvdXAgPSBjb250YWluZXI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aHRtbEdyb3VwLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0Ly8gU2hhcmVkIHdpdGggVk1MOlxuXHRcdFx0XHRcdHdyYXBwZXIuYWRkZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGlmICh3cmFwcGVyLmFsaWduT25BZGQpIHtcblx0XHRcdFx0XHRcdHdyYXBwZXIuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fVxuXHR9KTtcblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICogU1RBUlQgT0YgSU5URVJORVQgRVhQTE9SRVIgPD0gOCBTUEVDSUZJQyBDT0RFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqIEZvciBhcHBsaWNhdGlvbnMgYW5kIHdlYnNpdGVzIHRoYXQgZG9uJ3QgbmVlZCBJRSBzdXBwb3J0LCBsaWtlIHBsYXRmb3JtICAgICpcblx0ICogdGFyZ2V0ZWQgbW9iaWxlIGFwcHMgYW5kIHdlYiBhcHBzLCB0aGlzIGNvZGUgY2FuIGJlIHJlbW92ZWQuICAgICAgICAgICAgICAgKlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHR2YXIgVk1MUmVuZGVyZXIsIFZNTEVsZW1lbnQ7XG5cdGlmICghaGFzU1ZHICYmICF1c2VDYW5WRykge1xuXG5cdC8qKlxuXHQgKiBUaGUgVk1MIGVsZW1lbnQgd3JhcHBlci5cblx0ICovXG5cdFZNTEVsZW1lbnQgPSB7XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIGEgbmV3IFZNTCBlbGVtZW50IHdyYXBwZXIuIEl0IGJ1aWxkcyB0aGUgbWFya3VwIGFzIGEgc3RyaW5nXG5cdFx0ICogdG8gbWluaW1pemUgRE9NIHRyYWZmaWMuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHJlbmRlcmVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVOYW1lXG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKHJlbmRlcmVyLCBub2RlTmFtZSkge1xuXHRcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLFxuXHRcdFx0XHRtYXJrdXAgPSAgWyc8Jywgbm9kZU5hbWUsICcgZmlsbGVkPVwiZlwiIHN0cm9rZWQ9XCJmXCInXSxcblx0XHRcdFx0c3R5bGUgPSBbJ3Bvc2l0aW9uOiAnLCBBQlNPTFVURSwgJzsnXSxcblx0XHRcdFx0aXNEaXYgPSBub2RlTmFtZSA9PT0gRElWO1xuXG5cdFx0XHQvLyBkaXZzIGFuZCBzaGFwZXMgbmVlZCBzaXplXG5cdFx0XHRpZiAobm9kZU5hbWUgPT09ICdzaGFwZScgfHwgaXNEaXYpIHtcblx0XHRcdFx0c3R5bGUucHVzaCgnbGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4OycpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGUucHVzaCgndmlzaWJpbGl0eTogJywgaXNEaXYgPyBISURERU4gOiBWSVNJQkxFKTtcblxuXHRcdFx0bWFya3VwLnB1c2goJyBzdHlsZT1cIicsIHN0eWxlLmpvaW4oJycpLCAnXCIvPicpO1xuXG5cdFx0XHQvLyBjcmVhdGUgZWxlbWVudCB3aXRoIGRlZmF1bHQgYXR0cmlidXRlcyBhbmQgc3R5bGVcblx0XHRcdGlmIChub2RlTmFtZSkge1xuXHRcdFx0XHRtYXJrdXAgPSBpc0RpdiB8fCBub2RlTmFtZSA9PT0gJ3NwYW4nIHx8IG5vZGVOYW1lID09PSAnaW1nJyA/XG5cdFx0XHRcdFx0bWFya3VwLmpvaW4oJycpXG5cdFx0XHRcdFx0OiByZW5kZXJlci5wcmVwVk1MKG1hcmt1cCk7XG5cdFx0XHRcdHdyYXBwZXIuZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQobWFya3VwKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcHBlci5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBZGQgdGhlIG5vZGUgdG8gdGhlIGdpdmVuIHBhcmVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcblx0XHQgKi9cblx0XHRhZGQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcblx0XHRcdHZhciB3cmFwcGVyID0gdGhpcyxcblx0XHRcdFx0cmVuZGVyZXIgPSB3cmFwcGVyLnJlbmRlcmVyLFxuXHRcdFx0XHRlbGVtZW50ID0gd3JhcHBlci5lbGVtZW50LFxuXHRcdFx0XHRib3ggPSByZW5kZXJlci5ib3gsXG5cdFx0XHRcdGludmVydGVkID0gcGFyZW50ICYmIHBhcmVudC5pbnZlcnRlZCxcblxuXHRcdFx0XHQvLyBnZXQgdGhlIHBhcmVudCBub2RlXG5cdFx0XHRcdHBhcmVudE5vZGUgPSBwYXJlbnQgP1xuXHRcdFx0XHRcdHBhcmVudC5lbGVtZW50IHx8IHBhcmVudCA6XG5cdFx0XHRcdFx0Ym94O1xuXG5cblx0XHRcdC8vIGlmIHRoZSBwYXJlbnQgZ3JvdXAgaXMgaW52ZXJ0ZWQsIGFwcGx5IGludmVyc2lvbiBvbiBhbGwgY2hpbGRyZW5cblx0XHRcdGlmIChpbnZlcnRlZCkgeyAvLyBvbmx5IG9uIGdyb3Vwc1xuXHRcdFx0XHRyZW5kZXJlci5pbnZlcnRDaGlsZChlbGVtZW50LCBwYXJlbnROb2RlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwZW5kIGl0XG5cdFx0XHRwYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG5cdFx0XHQvLyBhbGlnbiB0ZXh0IGFmdGVyIGFkZGluZyB0byBiZSBhYmxlIHRvIHJlYWQgb2Zmc2V0XG5cdFx0XHR3cmFwcGVyLmFkZGVkID0gdHJ1ZTtcblx0XHRcdGlmICh3cmFwcGVyLmFsaWduT25BZGQgJiYgIXdyYXBwZXIuZGVmZXJVcGRhdGVUcmFuc2Zvcm0pIHtcblx0XHRcdFx0d3JhcHBlci51cGRhdGVUcmFuc2Zvcm0oKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZmlyZSBhbiBldmVudCBmb3IgaW50ZXJuYWwgaG9va3Ncblx0XHRcdGlmICh3cmFwcGVyLm9uQWRkKSB7XG5cdFx0XHRcdHdyYXBwZXIub25BZGQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFZNTCBhbHdheXMgdXNlcyBodG1sVXBkYXRlVHJhbnNmb3JtXG5cdFx0ICovXG5cdFx0dXBkYXRlVHJhbnNmb3JtOiBTVkdFbGVtZW50LnByb3RvdHlwZS5odG1sVXBkYXRlVHJhbnNmb3JtLFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSByb3RhdGlvbiBvZiBhIHNwYW4gd2l0aCBvbGRJRSdzIGZpbHRlclxuXHRcdCAqL1xuXHRcdHNldFNwYW5Sb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gQWRqdXN0IGZvciBhbGlnbm1lbnQgYW5kIHJvdGF0aW9uLiBSb3RhdGlvbiBvZiB1c2VIVE1MIGNvbnRlbnQgaXMgbm90IHlldCBpbXBsZW1lbnRlZFxuXHRcdFx0Ly8gYnV0IGl0IGNhbiBwcm9iYWJseSBiZSBpbXBsZW1lbnRlZCBmb3IgRmlyZWZveCAzLjUrIG9uIHVzZXIgcmVxdWVzdC4gRkYzLjUrXG5cdFx0XHQvLyBoYXMgc3VwcG9ydCBmb3IgQ1NTMyB0cmFuc2Zvcm0uIFRoZSBnZXRCQm94IG1ldGhvZCBhbHNvIG5lZWRzIHRvIGJlIHVwZGF0ZWRcblx0XHRcdC8vIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSByb3RhdGlvbiwgbGlrZSBpdCBjdXJyZW50bHkgZG9lcyBmb3IgU1ZHLlxuXHRcdFx0Ly8gVGVzdCBjYXNlOiBodHRwOi8vanNmaWRkbGUubmV0L2hpZ2hjaGFydHMvWWJ0NDQvXG5cblx0XHRcdHZhciByb3RhdGlvbiA9IHRoaXMucm90YXRpb24sXG5cdFx0XHRcdGNvc3RoZXRhID0gbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpLFxuXHRcdFx0XHRzaW50aGV0YSA9IG1hdGhTaW4ocm90YXRpb24gKiBkZWcycmFkKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0Y3NzKHRoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRmaWx0ZXI6IHJvdGF0aW9uID8gWydwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0nLCBjb3N0aGV0YSxcblx0XHRcdFx0XHQnLCBNMTI9JywgLXNpbnRoZXRhLCAnLCBNMjE9Jywgc2ludGhldGEsICcsIE0yMj0nLCBjb3N0aGV0YSxcblx0XHRcdFx0XHQnLCBzaXppbmdNZXRob2Q9XFwnYXV0byBleHBhbmRcXCcpJ10uam9pbignJykgOiBOT05FXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBwb3NpdGlvbmluZyBjb3JyZWN0aW9uIGZvciB0aGUgc3BhbiBhZnRlciByb3RhdGluZy4gXG5cdFx0ICovXG5cdFx0Z2V0U3BhbkNvcnJlY3Rpb246IGZ1bmN0aW9uICh3aWR0aCwgYmFzZWxpbmUsIGFsaWduQ29ycmVjdGlvbiwgcm90YXRpb24sIGFsaWduKSB7XG5cblx0XHRcdHZhciBjb3N0aGV0YSA9IHJvdGF0aW9uID8gbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpIDogMSxcblx0XHRcdFx0c2ludGhldGEgPSByb3RhdGlvbiA/IG1hdGhTaW4ocm90YXRpb24gKiBkZWcycmFkKSA6IDAsXG5cdFx0XHRcdGhlaWdodCA9IHBpY2sodGhpcy5lbGVtSGVpZ2h0LCB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0KSxcblx0XHRcdFx0cXVhZCxcblx0XHRcdFx0bm9uTGVmdCA9IGFsaWduICYmIGFsaWduICE9PSAnbGVmdCc7XG5cblx0XHRcdC8vIGNvcnJlY3QgeCBhbmQgeVxuXHRcdFx0dGhpcy54Q29yciA9IGNvc3RoZXRhIDwgMCAmJiAtd2lkdGg7XG5cdFx0XHR0aGlzLnlDb3JyID0gc2ludGhldGEgPCAwICYmIC1oZWlnaHQ7XG5cblx0XHRcdC8vIGNvcnJlY3QgZm9yIGJhc2VsaW5lIGFuZCBjb3JuZXJzIHNwaWxsaW5nIG91dCBhZnRlciByb3RhdGlvblxuXHRcdFx0cXVhZCA9IGNvc3RoZXRhICogc2ludGhldGEgPCAwO1xuXHRcdFx0dGhpcy54Q29yciArPSBzaW50aGV0YSAqIGJhc2VsaW5lICogKHF1YWQgPyAxIC0gYWxpZ25Db3JyZWN0aW9uIDogYWxpZ25Db3JyZWN0aW9uKTtcblx0XHRcdHRoaXMueUNvcnIgLT0gY29zdGhldGEgKiBiYXNlbGluZSAqIChyb3RhdGlvbiA/IChxdWFkID8gYWxpZ25Db3JyZWN0aW9uIDogMSAtIGFsaWduQ29ycmVjdGlvbikgOiAxKTtcblx0XHRcdC8vIGNvcnJlY3QgZm9yIHRoZSBsZW5ndGgvaGVpZ2h0IG9mIHRoZSB0ZXh0XG5cdFx0XHRpZiAobm9uTGVmdCkge1xuXHRcdFx0XHR0aGlzLnhDb3JyIC09IHdpZHRoICogYWxpZ25Db3JyZWN0aW9uICogKGNvc3RoZXRhIDwgMCA/IC0xIDogMSk7XG5cdFx0XHRcdGlmIChyb3RhdGlvbikge1xuXHRcdFx0XHRcdHRoaXMueUNvcnIgLT0gaGVpZ2h0ICogYWxpZ25Db3JyZWN0aW9uICogKHNpbnRoZXRhIDwgMCA/IC0xIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3NzKHRoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRcdHRleHRBbGlnbjogYWxpZ25cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIGEgc3Vic2V0IG9mIGFuIFNWRyBwYXRoIGRlZmluaXRpb24gdG8gaXRzIFZNTCBjb3VudGVycGFydC4gVGFrZXMgYW4gYXJyYXlcblx0XHQgKiBhcyB0aGUgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuXHRcdCAqL1xuXHRcdHBhdGhUb1ZNTDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQvLyBjb252ZXJ0IHBhdGhzXG5cdFx0XHR2YXIgaSA9IHZhbHVlLmxlbmd0aCxcblx0XHRcdFx0cGF0aCA9IFtdO1xuXG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cblx0XHRcdFx0Ly8gTXVsdGlwbHkgYnkgMTAgdG8gYWxsb3cgc3VicGl4ZWwgcHJlY2lzaW9uLlxuXHRcdFx0XHQvLyBTdWJzdHJhY3RpbmcgaGFsZiBhIHBpeGVsIHNlZW1zIHRvIG1ha2UgdGhlIGNvb3JkaW5hdGVzXG5cdFx0XHRcdC8vIGFsaWduIHdpdGggU1ZHLCBidXQgdGhpcyBoYXNuJ3QgYmVlbiB0ZXN0ZWQgdGhvcm91Z2hseVxuXHRcdFx0XHRpZiAoaXNOdW1iZXIodmFsdWVbaV0pKSB7XG5cdFx0XHRcdFx0cGF0aFtpXSA9IG1hdGhSb3VuZCh2YWx1ZVtpXSAqIDEwKSAtIDU7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWVbaV0gPT09ICdaJykgeyAvLyBjbG9zZSB0aGUgcGF0aFxuXHRcdFx0XHRcdHBhdGhbaV0gPSAneCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGF0aFtpXSA9IHZhbHVlW2ldO1xuXG5cdFx0XHRcdFx0Ly8gV2hlbiB0aGUgc3RhcnQgWCBhbmQgZW5kIFggY29vcmRpbmF0ZXMgb2YgYW4gYXJjIGFyZSB0b28gY2xvc2UsXG5cdFx0XHRcdFx0Ly8gdGhleSBhcmUgcm91bmRlZCB0byB0aGUgc2FtZSB2YWx1ZSBhYm92ZS4gSW4gdGhpcyBjYXNlLCBzdWJzdHJhY3Qgb3IgXG5cdFx0XHRcdFx0Ly8gYWRkIDEgZnJvbSB0aGUgZW5kIFggYW5kIFkgcG9zaXRpb25zLiAjMTg2LCAjNzYwLCAjMTM3MSwgIzE0MTAuXG5cdFx0XHRcdFx0aWYgKHZhbHVlLmlzQXJjICYmICh2YWx1ZVtpXSA9PT0gJ3dhJyB8fCB2YWx1ZVtpXSA9PT0gJ2F0JykpIHtcblx0XHRcdFx0XHRcdC8vIFN0YXJ0IGFuZCBlbmQgWFxuXHRcdFx0XHRcdFx0aWYgKHBhdGhbaSArIDVdID09PSBwYXRoW2kgKyA3XSkge1xuXHRcdFx0XHRcdFx0XHRwYXRoW2kgKyA3XSArPSB2YWx1ZVtpICsgN10gPiB2YWx1ZVtpICsgNV0gPyAxIDogLTE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBTdGFydCBhbmQgZW5kIFlcblx0XHRcdFx0XHRcdGlmIChwYXRoW2kgKyA2XSA9PT0gcGF0aFtpICsgOF0pIHtcblx0XHRcdFx0XHRcdFx0cGF0aFtpICsgOF0gKz0gdmFsdWVbaSArIDhdID4gdmFsdWVbaSArIDZdID8gMSA6IC0xO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRcblx0XHRcdC8vIExvb3AgdXAgYWdhaW4gdG8gaGFuZGxlIHBhdGggc2hvcnRjdXRzICgjMjEzMilcblx0XHRcdC8qd2hpbGUgKGkrKyA8IHBhdGgubGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChwYXRoW2ldID09PSAnSCcpIHsgLy8gaG9yaXpvbnRhbCBsaW5lIHRvXG5cdFx0XHRcdFx0cGF0aFtpXSA9ICdMJztcblx0XHRcdFx0XHRwYXRoLnNwbGljZShpICsgMiwgMCwgcGF0aFtpIC0gMV0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICdWJykgeyAvLyB2ZXJ0aWNhbCBsaW5lIHRvXG5cdFx0XHRcdFx0cGF0aFtpXSA9ICdMJztcblx0XHRcdFx0XHRwYXRoLnNwbGljZShpICsgMSwgMCwgcGF0aFtpIC0gMl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9Ki9cblx0XHRcdHJldHVybiBwYXRoLmpvaW4oJyAnKSB8fCAneCc7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgZWxlbWVudCdzIGNsaXBwaW5nIHRvIGEgcHJlZGVmaW5lZCByZWN0YW5nbGVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGNsaXAgcmVjdGFuZ2xlXG5cdFx0ICovXG5cdFx0Y2xpcDogZnVuY3Rpb24gKGNsaXBSZWN0KSB7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMsXG5cdFx0XHRcdGNsaXBNZW1iZXJzLFxuXHRcdFx0XHRjc3NSZXQ7XG5cblx0XHRcdGlmIChjbGlwUmVjdCkge1xuXHRcdFx0XHRjbGlwTWVtYmVycyA9IGNsaXBSZWN0Lm1lbWJlcnM7XG5cdFx0XHRcdGVyYXNlKGNsaXBNZW1iZXJzLCB3cmFwcGVyKTsgLy8gRW5zdXJlIHVuaXF1ZSBsaXN0IG9mIGVsZW1lbnRzICgjMTI1OClcblx0XHRcdFx0Y2xpcE1lbWJlcnMucHVzaCh3cmFwcGVyKTtcblx0XHRcdFx0d3JhcHBlci5kZXN0cm95Q2xpcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRlcmFzZShjbGlwTWVtYmVycywgd3JhcHBlcik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGNzc1JldCA9IGNsaXBSZWN0LmdldENTUyh3cmFwcGVyKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHdyYXBwZXIuZGVzdHJveUNsaXApIHtcblx0XHRcdFx0XHR3cmFwcGVyLmRlc3Ryb3lDbGlwKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3NzUmV0ID0geyBjbGlwOiBkb2NNb2RlOCA/ICdpbmhlcml0JyA6ICdyZWN0KGF1dG8pJyB9OyAvLyAjMTIxNFxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gd3JhcHBlci5jc3MoY3NzUmV0KTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgc3R5bGVzIGZvciB0aGUgZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcblx0XHQgKi9cblx0XHRjc3M6IFNWR0VsZW1lbnQucHJvdG90eXBlLmh0bWxDc3MsXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIGEgY2hpbGQgZWl0aGVyIGJ5IHJlbW92ZUNoaWxkIG9yIG1vdmUgdG8gZ2FyYmFnZUJpbi5cblx0XHQgKiBJc3N1ZSA0OTA7IGluIFZNTCByZW1vdmVDaGlsZCByZXN1bHRzIGluIE9ycGhhbmVkIG5vZGVzIGFjY29yZGluZyB0byBzSUV2ZSwgZGlzY2FyZEVsZW1lbnQgZG9lcyBub3QuXG5cdFx0ICovXG5cdFx0c2FmZVJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0Ly8gZGlzY2FyZEVsZW1lbnQgd2lsbCBkZXRhY2ggdGhlIG5vZGUgZnJvbSBpdHMgcGFyZW50IGJlZm9yZSBhdHRhY2hpbmcgaXRcblx0XHRcdC8vIHRvIHRoZSBnYXJiYWdlIGJpbi4gVGhlcmVmb3JlIGl0IGlzIGltcG9ydGFudCB0aGF0IHRoZSBub2RlIGlzIGF0dGFjaGVkIGFuZCBoYXZlIHBhcmVudC5cblx0XHRcdGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcblx0XHRcdFx0ZGlzY2FyZEVsZW1lbnQoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZCBlbGVtZW50LmRlc3Ryb3kgYnkgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgY2xpcCBtZW1iZXJzIGFycmF5XG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuZGVzdHJveUNsaXApIHtcblx0XHRcdFx0dGhpcy5kZXN0cm95Q2xpcCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gU1ZHRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyLiBWTUwgb3ZlcnJpZGUgZm9yIG5vcm1hbGl6aW5nIGV2ZW50IHBhcmFtZXRlcnMuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcblx0XHQgKi9cblx0XHRvbjogZnVuY3Rpb24gKGV2ZW50VHlwZSwgaGFuZGxlcikge1xuXHRcdFx0Ly8gc2ltcGxlc3QgcG9zc2libGUgZXZlbnQgbW9kZWwgZm9yIGludGVybmFsIHVzZVxuXHRcdFx0dGhpcy5lbGVtZW50WydvbicgKyBldmVudFR5cGVdID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgZXZ0ID0gd2luLmV2ZW50O1xuXHRcdFx0XHRldnQudGFyZ2V0ID0gZXZ0LnNyY0VsZW1lbnQ7XG5cdFx0XHRcdGhhbmRsZXIoZXZ0KTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW4gc3RhY2tlZCBjb2x1bW5zLCBjdXQgb2ZmIHRoZSBzaGFkb3dzIHNvIHRoYXQgdGhleSBkb24ndCBvdmVybGFwXG5cdFx0ICovXG5cdFx0Y3V0T2ZmUGF0aDogZnVuY3Rpb24gKHBhdGgsIGxlbmd0aCkge1xuXG5cdFx0XHR2YXIgbGVuO1xuXG5cdFx0XHRwYXRoID0gcGF0aC5zcGxpdCgvWyAsXS8pO1xuXHRcdFx0bGVuID0gcGF0aC5sZW5ndGg7XG5cblx0XHRcdGlmIChsZW4gPT09IDkgfHwgbGVuID09PSAxMSkge1xuXHRcdFx0XHRwYXRoW2xlbiAtIDRdID0gcGF0aFtsZW4gLSAyXSA9IHBJbnQocGF0aFtsZW4gLSAyXSkgLSAxMCAqIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXRoLmpvaW4oJyAnKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQXBwbHkgYSBkcm9wIHNoYWRvdyBieSBjb3B5aW5nIGVsZW1lbnRzIGFuZCBnaXZpbmcgdGhlbSBkaWZmZXJlbnQgc3Ryb2tlc1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IHNoYWRvd09wdGlvbnNcblx0XHQgKi9cblx0XHRzaGFkb3c6IGZ1bmN0aW9uIChzaGFkb3dPcHRpb25zLCBncm91cCwgY3V0T2ZmKSB7XG5cdFx0XHR2YXIgc2hhZG93cyA9IFtdLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0XHRyZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG5cdFx0XHRcdHNoYWRvdyxcblx0XHRcdFx0ZWxlbVN0eWxlID0gZWxlbWVudC5zdHlsZSxcblx0XHRcdFx0bWFya3VwLFxuXHRcdFx0XHRwYXRoID0gZWxlbWVudC5wYXRoLFxuXHRcdFx0XHRzdHJva2VXaWR0aCxcblx0XHRcdFx0bW9kaWZpZWRQYXRoLFxuXHRcdFx0XHRzaGFkb3dXaWR0aCxcblx0XHRcdFx0c2hhZG93RWxlbWVudE9wYWNpdHk7XG5cblx0XHRcdC8vIHNvbWUgdGltZXMgZW1wdHkgcGF0aHMgYXJlIG5vdCBzdHJpbmdzXG5cdFx0XHRpZiAocGF0aCAmJiB0eXBlb2YgcGF0aC52YWx1ZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cGF0aCA9ICd4Jztcblx0XHRcdH1cblx0XHRcdG1vZGlmaWVkUGF0aCA9IHBhdGg7XG5cblx0XHRcdGlmIChzaGFkb3dPcHRpb25zKSB7XG5cdFx0XHRcdHNoYWRvd1dpZHRoID0gcGljayhzaGFkb3dPcHRpb25zLndpZHRoLCAzKTtcblx0XHRcdFx0c2hhZG93RWxlbWVudE9wYWNpdHkgPSAoc2hhZG93T3B0aW9ucy5vcGFjaXR5IHx8IDAuMTUpIC8gc2hhZG93V2lkdGg7XG5cdFx0XHRcdGZvciAoaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG5cblx0XHRcdFx0XHRzdHJva2VXaWR0aCA9IChzaGFkb3dXaWR0aCAqIDIpICsgMSAtICgyICogaSk7XG5cblx0XHRcdFx0XHQvLyBDdXQgb2ZmIHNoYWRvd3MgZm9yIHN0YWNrZWQgY29sdW1uIGl0ZW1zXG5cdFx0XHRcdFx0aWYgKGN1dE9mZikge1xuXHRcdFx0XHRcdFx0bW9kaWZpZWRQYXRoID0gdGhpcy5jdXRPZmZQYXRoKHBhdGgudmFsdWUsIHN0cm9rZVdpZHRoICsgMC41KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtYXJrdXAgPSBbJzxzaGFwZSBpc1NoYWRvdz1cInRydWVcIiBzdHJva2V3ZWlnaHQ9XCInLCBzdHJva2VXaWR0aCxcblx0XHRcdFx0XHRcdCdcIiBmaWxsZWQ9XCJmYWxzZVwiIHBhdGg9XCInLCBtb2RpZmllZFBhdGgsXG5cdFx0XHRcdFx0XHQnXCIgY29vcmRzaXplPVwiMTAgMTBcIiBzdHlsZT1cIicsIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCwgJ1wiIC8+J107XG5cblx0XHRcdFx0XHRzaGFkb3cgPSBjcmVhdGVFbGVtZW50KHJlbmRlcmVyLnByZXBWTUwobWFya3VwKSxcblx0XHRcdFx0XHRcdG51bGwsIHtcblx0XHRcdFx0XHRcdFx0bGVmdDogcEludChlbGVtU3R5bGUubGVmdCkgKyBwaWNrKHNoYWRvd09wdGlvbnMub2Zmc2V0WCwgMSksXG5cdFx0XHRcdFx0XHRcdHRvcDogcEludChlbGVtU3R5bGUudG9wKSArIHBpY2soc2hhZG93T3B0aW9ucy5vZmZzZXRZLCAxKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0aWYgKGN1dE9mZikge1xuXHRcdFx0XHRcdFx0c2hhZG93LmN1dE9mZiA9IHN0cm9rZVdpZHRoICsgMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBhcHBseSB0aGUgb3BhY2l0eVxuXHRcdFx0XHRcdG1hcmt1cCA9IFsnPHN0cm9rZSBjb2xvcj1cIicsIHNoYWRvd09wdGlvbnMuY29sb3IgfHwgJ2JsYWNrJywgJ1wiIG9wYWNpdHk9XCInLCBzaGFkb3dFbGVtZW50T3BhY2l0eSAqIGksICdcIi8+J107XG5cdFx0XHRcdFx0Y3JlYXRlRWxlbWVudChyZW5kZXJlci5wcmVwVk1MKG1hcmt1cCksIG51bGwsIG51bGwsIHNoYWRvdyk7XG5cblxuXHRcdFx0XHRcdC8vIGluc2VydCBpdFxuXHRcdFx0XHRcdGlmIChncm91cCkge1xuXHRcdFx0XHRcdFx0Z3JvdXAuZWxlbWVudC5hcHBlbmRDaGlsZChzaGFkb3cpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNoYWRvdywgZWxlbWVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcmVjb3JkIGl0XG5cdFx0XHRcdFx0c2hhZG93cy5wdXNoKHNoYWRvdyk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc2hhZG93cyA9IHNoYWRvd3M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdHVwZGF0ZVNoYWRvd3M6IG5vb3AsIC8vIFVzZWQgaW4gU1ZHIG9ubHlcblxuXHRcdHNldEF0dHI6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoZG9jTW9kZTgpIHsgLy8gSUU4IHNldEF0dHJpYnV0ZSBidWdcblx0XHRcdFx0dGhpcy5lbGVtZW50W2tleV0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjbGFzc1NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQvLyBJRTggU3RhbmRhcmRzIG1vZGUgaGFzIHByb2JsZW1zIHJldHJpZXZpbmcgdGhlIGNsYXNzTmFtZSB1bmxlc3Mgc2V0IGxpa2UgdGhpc1xuXHRcdFx0dGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHZhbHVlO1xuXHRcdH0sXG5cdFx0ZGFzaHN0eWxlU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0dmFyIHN0cm9rZUVsZW0gPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHJva2UnKVswXSB8fFxuXHRcdFx0XHRjcmVhdGVFbGVtZW50KHRoaXMucmVuZGVyZXIucHJlcFZNTChbJzxzdHJva2UvPiddKSwgbnVsbCwgbnVsbCwgZWxlbWVudCk7XG5cdFx0XHRzdHJva2VFbGVtW2tleV0gPSB2YWx1ZSB8fCAnc29saWQnO1xuXHRcdFx0dGhpc1trZXldID0gdmFsdWU7IC8qIGJlY2F1c2UgY2hhbmdpbmcgc3Ryb2tlLXdpZHRoIHdpbGwgY2hhbmdlIHRoZSBkYXNoIGxlbmd0aFxuXHRcdFx0XHRhbmQgY2F1c2UgYW4gZXBpbGVwdGljIGVmZmVjdCAqL1xuXHRcdH0sXG5cdFx0ZFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRzaGFkb3dzID0gdGhpcy5zaGFkb3dzO1xuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBbXTtcblx0XHRcdHRoaXMuZCA9IHZhbHVlLmpvaW4gJiYgdmFsdWUuam9pbignICcpOyAvLyB1c2VkIGluIGdldHRlciBmb3IgYW5pbWF0aW9uXG5cblx0XHRcdGVsZW1lbnQucGF0aCA9IHZhbHVlID0gdGhpcy5wYXRoVG9WTUwodmFsdWUpO1xuXG5cdFx0XHQvLyB1cGRhdGUgc2hhZG93c1xuXHRcdFx0aWYgKHNoYWRvd3MpIHtcblx0XHRcdFx0aSA9IHNoYWRvd3MubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0c2hhZG93c1tpXS5wYXRoID0gc2hhZG93c1tpXS5jdXRPZmYgPyB0aGlzLmN1dE9mZlBhdGgodmFsdWUsIHNoYWRvd3NbaV0uY3V0T2ZmKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldEF0dHIoa2V5LCB2YWx1ZSk7XG5cdFx0fSxcblx0XHRmaWxsU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblx0XHRcdGlmIChub2RlTmFtZSA9PT0gJ1NQQU4nKSB7IC8vIHRleHQgY29sb3Jcblx0XHRcdFx0ZWxlbWVudC5zdHlsZS5jb2xvciA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmIChub2RlTmFtZSAhPT0gJ0lNRycpIHsgLy8gIzEzMzZcblx0XHRcdFx0ZWxlbWVudC5maWxsZWQgPSB2YWx1ZSAhPT0gTk9ORTtcblx0XHRcdFx0dGhpcy5zZXRBdHRyKCdmaWxsY29sb3InLCB0aGlzLnJlbmRlcmVyLmNvbG9yKHZhbHVlLCBlbGVtZW50LCBrZXksIHRoaXMpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9wYWNpdHlTZXR0ZXI6IG5vb3AsIC8vIERvbid0IGJvdGhlciAtIGFuaW1hdGlvbiBpcyB0b28gc2xvdyBhbmQgZmlsdGVycyBpbnRyb2R1Y2UgYXJ0aWZhY3RzXG5cdFx0cm90YXRpb25TZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXHRcdFx0dGhpc1trZXldID0gc3R5bGVba2V5XSA9IHZhbHVlOyAvLyBzdHlsZSBpcyBmb3IgIzE4NzNcblxuXHRcdFx0Ly8gQ29ycmVjdGlvbiBmb3IgdGhlIDF4MSBzaXplIG9mIHRoZSBzaGFwZSBjb250YWluZXIuIFVzZWQgaW4gZ2F1Z2UgbmVlZGxlcy5cblx0XHRcdHN0eWxlLmxlZnQgPSAtbWF0aFJvdW5kKG1hdGhTaW4odmFsdWUgKiBkZWcycmFkKSArIDEpICsgUFg7XG5cdFx0XHRzdHlsZS50b3AgPSBtYXRoUm91bmQobWF0aENvcyh2YWx1ZSAqIGRlZzJyYWQpKSArIFBYO1xuXHRcdH0sXG5cdFx0c3Ryb2tlU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSwgZWxlbWVudCkge1xuXHRcdFx0dGhpcy5zZXRBdHRyKCdzdHJva2Vjb2xvcicsIHRoaXMucmVuZGVyZXIuY29sb3IodmFsdWUsIGVsZW1lbnQsIGtleSkpO1xuXHRcdH0sXG5cdFx0J3N0cm9rZS13aWR0aFNldHRlcic6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHRlbGVtZW50LnN0cm9rZWQgPSAhIXZhbHVlOyAvLyBWTUwgXCJzdHJva2VkXCIgYXR0cmlidXRlXG5cdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTsgLy8gdXNlZCBpbiBnZXR0ZXIsIGlzc3VlICMxMTNcblx0XHRcdGlmIChpc051bWJlcih2YWx1ZSkpIHtcblx0XHRcdFx0dmFsdWUgKz0gUFg7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldEF0dHIoJ3N0cm9rZXdlaWdodCcsIHZhbHVlKTtcblx0XHR9LFxuXHRcdHRpdGxlU2V0dGVyOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0dGhpcy5zZXRBdHRyKGtleSwgdmFsdWUpO1xuXHRcdH0sXG5cdFx0dmlzaWJpbGl0eVNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblxuXHRcdFx0Ly8gSGFuZGxlIGluaGVyaXRlZCB2aXNpYmlsaXR5XG5cdFx0XHRpZiAodmFsdWUgPT09ICdpbmhlcml0Jykge1xuXHRcdFx0XHR2YWx1ZSA9IFZJU0lCTEU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIExldCB0aGUgc2hhZG93IGZvbGxvdyB0aGUgbWFpbiBlbGVtZW50XG5cdFx0XHRpZiAodGhpcy5zaGFkb3dzKSB7XG5cdFx0XHRcdGVhY2godGhpcy5zaGFkb3dzLCBmdW5jdGlvbiAoc2hhZG93KSB7XG5cdFx0XHRcdFx0c2hhZG93LnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluc3RlYWQgb2YgdG9nZ2xpbmcgdGhlIHZpc2liaWxpdHkgQ1NTIHByb3BlcnR5LCBtb3ZlIHRoZSBkaXYgb3V0IG9mIHRoZSB2aWV3cG9ydC5cblx0XHRcdC8vIFRoaXMgd29ya3MgYXJvdW5kICM2MSBhbmQgIzU4NlxuXHRcdFx0aWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdESVYnKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUgPT09IEhJRERFTiA/ICctOTk5ZW0nIDogMDtcblxuXHRcdFx0XHQvLyBJbiBvcmRlciB0byByZWRyYXcsIElFNyBuZWVkcyB0aGUgZGl2IHRvIGJlIHZpc2libGUgd2hlbiB0dWNrZWQgYXdheVxuXHRcdFx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3cG9ydC4gU28gdGhlIHZpc2liaWxpdHkgaXMgYWN0dWFsbHkgb3Bwb3NpdGUgb2Zcblx0XHRcdFx0Ly8gdGhlIGV4cGVjdGVkIHZhbHVlLiBUaGlzIGFwcGxpZXMgdG8gdGhlIHRvb2x0aXAgb25seS5cblx0XHRcdFx0aWYgKCFkb2NNb2RlOCkge1xuXHRcdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5XSA9IHZhbHVlID8gVklTSUJMRSA6IEhJRERFTjtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkgPSAndG9wJztcblx0XHRcdH1cblx0XHRcdGVsZW1lbnQuc3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdH0sXG5cdFx0eFNldHRlcjogZnVuY3Rpb24gKHZhbHVlLCBrZXksIGVsZW1lbnQpIHtcblx0XHRcdHRoaXNba2V5XSA9IHZhbHVlOyAvLyB1c2VkIGluIGdldHRlclxuXG5cdFx0XHRpZiAoa2V5ID09PSAneCcpIHtcblx0XHRcdFx0a2V5ID0gJ2xlZnQnO1xuXHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICd5Jykge1xuXHRcdFx0XHRrZXkgPSAndG9wJztcblx0XHRcdH0vKiBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSBtYXRoTWF4KDAsIHZhbHVlKTsgLy8gZG9uJ3Qgc2V0IHdpZHRoIG9yIGhlaWdodCBiZWxvdyB6ZXJvICgjMzExKVxuXHRcdFx0fSovXG5cblx0XHRcdC8vIGNsaXBwaW5nIHJlY3RhbmdsZSBzcGVjaWFsXG5cdFx0XHRpZiAodGhpcy51cGRhdGVDbGlwcGluZykge1xuXHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTsgLy8gdGhlIGtleSBpcyBub3cgJ2xlZnQnIG9yICd0b3AnIGZvciAneCcgYW5kICd5J1xuXHRcdFx0XHR0aGlzLnVwZGF0ZUNsaXBwaW5nKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBub3JtYWxcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR6SW5kZXhTZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBlbGVtZW50KSB7XG5cdFx0XHRlbGVtZW50LnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHR9XG5cdH07XG5cdEhpZ2hjaGFydHMuVk1MRWxlbWVudCA9IFZNTEVsZW1lbnQgPSBleHRlbmRDbGFzcyhTVkdFbGVtZW50LCBWTUxFbGVtZW50KTtcblxuXHQvLyBTb21lIHNoYXJlZCBzZXR0ZXJzXG5cdFZNTEVsZW1lbnQucHJvdG90eXBlLnlTZXR0ZXIgPVxuXHRcdFZNTEVsZW1lbnQucHJvdG90eXBlLndpZHRoU2V0dGVyID0gXG5cdFx0Vk1MRWxlbWVudC5wcm90b3R5cGUuaGVpZ2h0U2V0dGVyID0gXG5cdFx0Vk1MRWxlbWVudC5wcm90b3R5cGUueFNldHRlcjtcblxuXG5cdC8qKlxuXHQgKiBUaGUgVk1MIHJlbmRlcmVyXG5cdCAqL1xuXHR2YXIgVk1MUmVuZGVyZXJFeHRlbnNpb24gPSB7IC8vIGluaGVyaXQgU1ZHUmVuZGVyZXJcblxuXHRcdEVsZW1lbnQ6IFZNTEVsZW1lbnQsXG5cdFx0aXNJRTg6IHVzZXJBZ2VudC5pbmRleE9mKCdNU0lFIDguMCcpID4gLTEsXG5cblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIFZNTFJlbmRlcmVyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lclxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoY29udGFpbmVyLCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSkge1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdFx0Ym94V3JhcHBlcixcblx0XHRcdFx0Ym94LFxuXHRcdFx0XHRjc3M7XG5cblx0XHRcdHJlbmRlcmVyLmFsaWduZWRPYmplY3RzID0gW107XG5cblx0XHRcdGJveFdyYXBwZXIgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KERJVilcblx0XHRcdFx0LmNzcyhleHRlbmQodGhpcy5nZXRTdHlsZShzdHlsZSksIHsgcG9zaXRpb246IFJFTEFUSVZFfSkpO1xuXHRcdFx0Ym94ID0gYm94V3JhcHBlci5lbGVtZW50O1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGJveFdyYXBwZXIuZWxlbWVudCk7XG5cblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdGhlIGNvbnRhaW5pbmcgYm94XG5cdFx0XHRyZW5kZXJlci5pc1ZNTCA9IHRydWU7XG5cdFx0XHRyZW5kZXJlci5ib3ggPSBib3g7XG5cdFx0XHRyZW5kZXJlci5ib3hXcmFwcGVyID0gYm94V3JhcHBlcjtcblx0XHRcdHJlbmRlcmVyLmNhY2hlID0ge307XG5cblxuXHRcdFx0cmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBmYWxzZSk7XG5cblx0XHRcdC8vIFRoZSBvbmx5IHdheSB0byBtYWtlIElFNiBhbmQgSUU3IHByaW50IGlzIHRvIHVzZSBhIGdsb2JhbCBuYW1lc3BhY2UuIEhvd2V2ZXIsXG5cdFx0XHQvLyB3aXRoIElFOCB0aGUgb25seSB3YXkgdG8gbWFrZSB0aGUgZHluYW1pYyBzaGFwZXMgdmlzaWJsZSBpbiBzY3JlZW4gYW5kIHByaW50IG1vZGVcblx0XHRcdC8vIHNlZW1zIHRvIGJlIHRvIGFkZCB0aGUgeG1sbnMgYXR0cmlidXRlIGFuZCB0aGUgYmVoYXZpb3VyIHN0eWxlIGlubGluZS5cblx0XHRcdGlmICghZG9jLm5hbWVzcGFjZXMuaGN2KSB7XG5cblx0XHRcdFx0ZG9jLm5hbWVzcGFjZXMuYWRkKCdoY3YnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblxuXHRcdFx0XHQvLyBTZXR1cCBkZWZhdWx0IENTUyAoIzIxNTMsICMyMzY4LCAjMjM4NClcblx0XHRcdFx0Y3NzID0gJ2hjdlxcXFw6ZmlsbCwgaGN2XFxcXDpwYXRoLCBoY3ZcXFxcOnNoYXBlLCBoY3ZcXFxcOnN0cm9rZScgK1xuXHRcdFx0XHRcdCd7IGJlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH0gJztcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRkb2MuY3JlYXRlU3R5bGVTaGVldCgpLmNzc1RleHQgPSBjc3M7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRkb2Muc3R5bGVTaGVldHNbMF0uY3NzVGV4dCArPSBjc3M7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIERldGVjdCB3aGV0aGVyIHRoZSByZW5kZXJlciBpcyBoaWRkZW4uIFRoaXMgaGFwcGVucyB3aGVuIG9uZSBvZiB0aGUgcGFyZW50IGVsZW1lbnRzXG5cdFx0ICogaGFzIGRpc3BsYXk6IG5vbmVcblx0XHQgKi9cblx0XHRpc0hpZGRlbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLmJveC5vZmZzZXRXaWR0aDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVmaW5lIGEgY2xpcHBpbmcgcmVjdGFuZ2xlLiBJbiBWTUwgaXQgaXMgYWNjb21wbGlzaGVkIGJ5IHN0b3JpbmcgdGhlIHZhbHVlc1xuXHRcdCAqIGZvciBzZXR0aW5nIHRoZSBDU1Mgc3R5bGUgdG8gYWxsIGFzc29jaWF0ZWQgbWVtYmVycy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICovXG5cdFx0Y2xpcFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cblx0XHRcdC8vIGNyZWF0ZSBhIGR1bW15IGVsZW1lbnRcblx0XHRcdHZhciBjbGlwUmVjdCA9IHRoaXMuY3JlYXRlRWxlbWVudCgpLFxuXHRcdFx0XHRpc09iaiA9IGlzT2JqZWN0KHgpO1xuXG5cdFx0XHQvLyBtaW1pYyBhIHJlY3RhbmdsZSB3aXRoIGl0cyBzdHlsZSBvYmplY3QgZm9yIGF1dG9tYXRpYyB1cGRhdGluZyBpbiBhdHRyXG5cdFx0XHRyZXR1cm4gZXh0ZW5kKGNsaXBSZWN0LCB7XG5cdFx0XHRcdG1lbWJlcnM6IFtdLFxuXHRcdFx0XHRjb3VudDogMCxcblx0XHRcdFx0bGVmdDogKGlzT2JqID8geC54IDogeCkgKyAxLFxuXHRcdFx0XHR0b3A6IChpc09iaiA/IHgueSA6IHkpICsgMSxcblx0XHRcdFx0d2lkdGg6IChpc09iaiA/IHgud2lkdGggOiB3aWR0aCkgLSAxLFxuXHRcdFx0XHRoZWlnaHQ6IChpc09iaiA/IHguaGVpZ2h0IDogaGVpZ2h0KSAtIDEsXG5cdFx0XHRcdGdldENTUzogZnVuY3Rpb24gKHdyYXBwZXIpIHtcblx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IHdyYXBwZXIuZWxlbWVudCxcblx0XHRcdFx0XHRcdG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZSxcblx0XHRcdFx0XHRcdGlzU2hhcGUgPSBub2RlTmFtZSA9PT0gJ3NoYXBlJyxcblx0XHRcdFx0XHRcdGludmVydGVkID0gd3JhcHBlci5pbnZlcnRlZCxcblx0XHRcdFx0XHRcdHJlY3QgPSB0aGlzLFxuXHRcdFx0XHRcdFx0dG9wID0gcmVjdC50b3AgLSAoaXNTaGFwZSA/IGVsZW1lbnQub2Zmc2V0VG9wIDogMCksXG5cdFx0XHRcdFx0XHRsZWZ0ID0gcmVjdC5sZWZ0LFxuXHRcdFx0XHRcdFx0cmlnaHQgPSBsZWZ0ICsgcmVjdC53aWR0aCxcblx0XHRcdFx0XHRcdGJvdHRvbSA9IHRvcCArIHJlY3QuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0cmV0ID0ge1xuXHRcdFx0XHRcdFx0XHRjbGlwOiAncmVjdCgnICtcblx0XHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoaW52ZXJ0ZWQgPyBsZWZ0IDogdG9wKSArICdweCwnICtcblx0XHRcdFx0XHRcdFx0XHRtYXRoUm91bmQoaW52ZXJ0ZWQgPyBib3R0b20gOiByaWdodCkgKyAncHgsJyArXG5cdFx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKGludmVydGVkID8gcmlnaHQgOiBib3R0b20pICsgJ3B4LCcgK1xuXHRcdFx0XHRcdFx0XHRcdG1hdGhSb3VuZChpbnZlcnRlZCA/IHRvcCA6IGxlZnQpICsgJ3B4KSdcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBpc3N1ZSA3NCB3b3JrYXJvdW5kXG5cdFx0XHRcdFx0aWYgKCFpbnZlcnRlZCAmJiBkb2NNb2RlOCAmJiBub2RlTmFtZSA9PT0gJ0RJVicpIHtcblx0XHRcdFx0XHRcdGV4dGVuZChyZXQsIHtcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHJpZ2h0ICsgUFgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogYm90dG9tICsgUFhcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIHVzZWQgaW4gYXR0ciBhbmQgYW5pbWF0aW9uIHRvIHVwZGF0ZSB0aGUgY2xpcHBpbmcgb2YgYWxsIG1lbWJlcnNcblx0XHRcdFx0dXBkYXRlQ2xpcHBpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRlYWNoKGNsaXBSZWN0Lm1lbWJlcnMsIGZ1bmN0aW9uIChtZW1iZXIpIHtcblx0XHRcdFx0XHRcdGlmIChtZW1iZXIuZWxlbWVudCkgeyAvLyBEZWxldGVkIHNlcmllcywgbGlrZSBpbiBzdG9jay9tZW1iZXJzL3Nlcmllcy1yZW1vdmUgZGVtby4gU2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBtZW1iZXJzLCBidXQgdGhpcyB3aWxsIGRvLlxuXHRcdFx0XHRcdFx0XHRtZW1iZXIuY3NzKGNsaXBSZWN0LmdldENTUyhtZW1iZXIpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBUYWtlIGEgY29sb3IgYW5kIHJldHVybiBpdCBpZiBpdCdzIGEgc3RyaW5nLCBtYWtlIGl0IGEgZ3JhZGllbnQgaWYgaXQncyBhXG5cdFx0ICogZ3JhZGllbnQgY29uZmlndXJhdGlvbiBvYmplY3QsIGFuZCBhcHBseSBvcGFjaXR5LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGNvbG9yIFRoZSBjb2xvciBvciBjb25maWcgb2JqZWN0XG5cdFx0ICovXG5cdFx0Y29sb3I6IGZ1bmN0aW9uIChjb2xvciwgZWxlbSwgcHJvcCwgd3JhcHBlcikge1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdGhpcyxcblx0XHRcdFx0Y29sb3JPYmplY3QsXG5cdFx0XHRcdHJlZ2V4UmdiYSA9IC9ecmdiYS8sXG5cdFx0XHRcdG1hcmt1cCxcblx0XHRcdFx0ZmlsbFR5cGUsXG5cdFx0XHRcdHJldCA9IE5PTkU7XG5cblx0XHRcdC8vIENoZWNrIGZvciBsaW5lYXIgb3IgcmFkaWFsIGdyYWRpZW50XG5cdFx0XHRpZiAoY29sb3IgJiYgY29sb3IubGluZWFyR3JhZGllbnQpIHtcblx0XHRcdFx0ZmlsbFR5cGUgPSAnZ3JhZGllbnQnO1xuXHRcdFx0fSBlbHNlIGlmIChjb2xvciAmJiBjb2xvci5yYWRpYWxHcmFkaWVudCkge1xuXHRcdFx0XHRmaWxsVHlwZSA9ICdwYXR0ZXJuJztcblx0XHRcdH1cblxuXG5cdFx0XHRpZiAoZmlsbFR5cGUpIHtcblxuXHRcdFx0XHR2YXIgc3RvcENvbG9yLFxuXHRcdFx0XHRcdHN0b3BPcGFjaXR5LFxuXHRcdFx0XHRcdGdyYWRpZW50ID0gY29sb3IubGluZWFyR3JhZGllbnQgfHwgY29sb3IucmFkaWFsR3JhZGllbnQsXG5cdFx0XHRcdFx0eDEsXG5cdFx0XHRcdFx0eTEsXG5cdFx0XHRcdFx0eDIsXG5cdFx0XHRcdFx0eTIsXG5cdFx0XHRcdFx0b3BhY2l0eTEsXG5cdFx0XHRcdFx0b3BhY2l0eTIsXG5cdFx0XHRcdFx0Y29sb3IxLFxuXHRcdFx0XHRcdGNvbG9yMixcblx0XHRcdFx0XHRmaWxsQXR0ciA9ICcnLFxuXHRcdFx0XHRcdHN0b3BzID0gY29sb3Iuc3RvcHMsXG5cdFx0XHRcdFx0Zmlyc3RTdG9wLFxuXHRcdFx0XHRcdGxhc3RTdG9wLFxuXHRcdFx0XHRcdGNvbG9ycyA9IFtdLFxuXHRcdFx0XHRcdGFkZEZpbGxOb2RlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Ly8gQWRkIHRoZSBmaWxsIHN1Ym5vZGUuIFdoZW4gY29sb3JzIGF0dHJpYnV0ZSBpcyB1c2VkLCB0aGUgbWVhbmluZ3Mgb2Ygb3BhY2l0eSBhbmQgbzpvcGFjaXR5MlxuXHRcdFx0XHRcdFx0Ly8gYXJlIHJldmVyc2VkLlxuXHRcdFx0XHRcdFx0bWFya3VwID0gWyc8ZmlsbCBjb2xvcnM9XCInICsgY29sb3JzLmpvaW4oJywnKSArICdcIiBvcGFjaXR5PVwiJywgb3BhY2l0eTIsICdcIiBvOm9wYWNpdHkyPVwiJywgb3BhY2l0eTEsXG5cdFx0XHRcdFx0XHRcdCdcIiB0eXBlPVwiJywgZmlsbFR5cGUsICdcIiAnLCBmaWxsQXR0ciwgJ2ZvY3VzPVwiMTAwJVwiIG1ldGhvZD1cImFueVwiIC8+J107XG5cdFx0XHRcdFx0XHRjcmVhdGVFbGVtZW50KHJlbmRlcmVyLnByZXBWTUwobWFya3VwKSwgbnVsbCwgbnVsbCwgZWxlbSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBFeHRlbmQgZnJvbSAwIHRvIDFcblx0XHRcdFx0Zmlyc3RTdG9wID0gc3RvcHNbMF07XG5cdFx0XHRcdGxhc3RTdG9wID0gc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGlmIChmaXJzdFN0b3BbMF0gPiAwKSB7XG5cdFx0XHRcdFx0c3RvcHMudW5zaGlmdChbXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0Zmlyc3RTdG9wWzFdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxhc3RTdG9wWzBdIDwgMSkge1xuXHRcdFx0XHRcdHN0b3BzLnB1c2goW1xuXHRcdFx0XHRcdFx0MSxcblx0XHRcdFx0XHRcdGxhc3RTdG9wWzFdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb21wdXRlIHRoZSBzdG9wc1xuXHRcdFx0XHRlYWNoKHN0b3BzLCBmdW5jdGlvbiAoc3RvcCwgaSkge1xuXHRcdFx0XHRcdGlmIChyZWdleFJnYmEudGVzdChzdG9wWzFdKSkge1xuXHRcdFx0XHRcdFx0Y29sb3JPYmplY3QgPSBDb2xvcihzdG9wWzFdKTtcblx0XHRcdFx0XHRcdHN0b3BDb2xvciA9IGNvbG9yT2JqZWN0LmdldCgncmdiJyk7XG5cdFx0XHRcdFx0XHRzdG9wT3BhY2l0eSA9IGNvbG9yT2JqZWN0LmdldCgnYScpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdG9wQ29sb3IgPSBzdG9wWzFdO1xuXHRcdFx0XHRcdFx0c3RvcE9wYWNpdHkgPSAxO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEJ1aWxkIHRoZSBjb2xvciBhdHRyaWJ1dGVcblx0XHRcdFx0XHRjb2xvcnMucHVzaCgoc3RvcFswXSAqIDEwMCkgKyAnJSAnICsgc3RvcENvbG9yKTtcblxuXHRcdFx0XHRcdC8vIE9ubHkgc3RhcnQgYW5kIGVuZCBvcGFjaXRpZXMgYXJlIGFsbG93ZWQsIHNvIHdlIHVzZSB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0XG5cdFx0XHRcdFx0aWYgKCFpKSB7XG5cdFx0XHRcdFx0XHRvcGFjaXR5MSA9IHN0b3BPcGFjaXR5O1xuXHRcdFx0XHRcdFx0Y29sb3IyID0gc3RvcENvbG9yO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvcGFjaXR5MiA9IHN0b3BPcGFjaXR5O1xuXHRcdFx0XHRcdFx0Y29sb3IxID0gc3RvcENvbG9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgdGhlIGdyYWRpZW50IHRvIGZpbGxzIG9ubHkuXG5cdFx0XHRcdGlmIChwcm9wID09PSAnZmlsbCcpIHtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBsaW5lYXIgZ3JhZGllbnQgYW5nbGVcblx0XHRcdFx0XHRpZiAoZmlsbFR5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0XHRcdHgxID0gZ3JhZGllbnQueDEgfHwgZ3JhZGllbnRbMF0gfHwgMDtcblx0XHRcdFx0XHRcdHkxID0gZ3JhZGllbnQueTEgfHwgZ3JhZGllbnRbMV0gfHwgMDtcblx0XHRcdFx0XHRcdHgyID0gZ3JhZGllbnQueDIgfHwgZ3JhZGllbnRbMl0gfHwgMDtcblx0XHRcdFx0XHRcdHkyID0gZ3JhZGllbnQueTIgfHwgZ3JhZGllbnRbM10gfHwgMDtcblx0XHRcdFx0XHRcdGZpbGxBdHRyID0gJ2FuZ2xlPVwiJyArICg5MCAgLSBtYXRoLmF0YW4oXG5cdFx0XHRcdFx0XHRcdCh5MiAtIHkxKSAvIC8vIHkgdmVjdG9yXG5cdFx0XHRcdFx0XHRcdCh4MiAtIHgxKSAvLyB4IHZlY3RvclxuXHRcdFx0XHRcdFx0XHQpICogMTgwIC8gbWF0aFBJKSArICdcIic7XG5cblx0XHRcdFx0XHRcdGFkZEZpbGxOb2RlKCk7XG5cblx0XHRcdFx0XHQvLyBSYWRpYWwgKGNpcmN1bGFyKSBncmFkaWVudFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZhciByID0gZ3JhZGllbnQucixcblx0XHRcdFx0XHRcdFx0c2l6ZXggPSByICogMixcblx0XHRcdFx0XHRcdFx0c2l6ZXkgPSByICogMixcblx0XHRcdFx0XHRcdFx0Y3ggPSBncmFkaWVudC5jeCxcblx0XHRcdFx0XHRcdFx0Y3kgPSBncmFkaWVudC5jeSxcblx0XHRcdFx0XHRcdFx0cmFkaWFsUmVmZXJlbmNlID0gZWxlbS5yYWRpYWxSZWZlcmVuY2UsXG5cdFx0XHRcdFx0XHRcdGJCb3gsXG5cdFx0XHRcdFx0XHRcdGFwcGx5UmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJhZGlhbFJlZmVyZW5jZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YkJveCA9IHdyYXBwZXIuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3ggKz0gKHJhZGlhbFJlZmVyZW5jZVswXSAtIGJCb3gueCkgLyBiQm94LndpZHRoIC0gMC41O1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3kgKz0gKHJhZGlhbFJlZmVyZW5jZVsxXSAtIGJCb3gueSkgLyBiQm94LmhlaWdodCAtIDAuNTtcblx0XHRcdFx0XHRcdFx0XHRcdHNpemV4ICo9IHJhZGlhbFJlZmVyZW5jZVsyXSAvIGJCb3gud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRzaXpleSAqPSByYWRpYWxSZWZlcmVuY2VbMl0gLyBiQm94LmhlaWdodDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZmlsbEF0dHIgPSAnc3JjPVwiJyArIGRlZmF1bHRPcHRpb25zLmdsb2JhbC5WTUxSYWRpYWxHcmFkaWVudFVSTCArICdcIiAnICtcblx0XHRcdFx0XHRcdFx0XHRcdCdzaXplPVwiJyArIHNpemV4ICsgJywnICsgc2l6ZXkgKyAnXCIgJyArXG5cdFx0XHRcdFx0XHRcdFx0XHQnb3JpZ2luPVwiMC41LDAuNVwiICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J3Bvc2l0aW9uPVwiJyArIGN4ICsgJywnICsgY3kgKyAnXCIgJyArXG5cdFx0XHRcdFx0XHRcdFx0XHQnY29sb3IyPVwiJyArIGNvbG9yMiArICdcIiAnO1xuXG5cdFx0XHRcdFx0XHRcdFx0YWRkRmlsbE5vZGUoKTtcblx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Ly8gQXBwbHkgcmFkaWFsIGdyYWRpZW50XG5cdFx0XHRcdFx0XHRpZiAod3JhcHBlci5hZGRlZCkge1xuXHRcdFx0XHRcdFx0XHRhcHBseVJhZGlhbEdyYWRpZW50KCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGtub3cgdGhlIGJvdW5kaW5nIGJveCB0byBnZXQgdGhlIHNpemUgYW5kIHBvc2l0aW9uIHJpZ2h0XG5cdFx0XHRcdFx0XHRcdHdyYXBwZXIub25BZGQgPSBhcHBseVJhZGlhbEdyYWRpZW50O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBUaGUgZmlsbCBlbGVtZW50J3MgY29sb3IgYXR0cmlidXRlIGlzIGJyb2tlbiBpbiBJRTggc3RhbmRhcmRzIG1vZGUsIHNvIHdlXG5cdFx0XHRcdFx0XHQvLyBuZWVkIHRvIHNldCB0aGUgcGFyZW50IHNoYXBlJ3MgZmlsbGNvbG9yIGF0dHJpYnV0ZSBpbnN0ZWFkLlxuXHRcdFx0XHRcdFx0cmV0ID0gY29sb3IxO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHcmFkaWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIFZNTCBzdHJva2UsIHJldHVybiB0aGUgZmlyc3QgY29sb3IuICM3MjIuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0ID0gc3RvcENvbG9yO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBjb2xvciBpcyBhbiByZ2JhIGNvbG9yLCBzcGxpdCBpdCBhbmQgYWRkIGEgZmlsbCBub2RlXG5cdFx0XHQvLyB0byBob2xkIHRoZSBvcGFjaXR5IGNvbXBvbmVudFxuXHRcdFx0fSBlbHNlIGlmIChyZWdleFJnYmEudGVzdChjb2xvcikgJiYgZWxlbS50YWdOYW1lICE9PSAnSU1HJykge1xuXG5cdFx0XHRcdGNvbG9yT2JqZWN0ID0gQ29sb3IoY29sb3IpO1xuXG5cdFx0XHRcdG1hcmt1cCA9IFsnPCcsIHByb3AsICcgb3BhY2l0eT1cIicsIGNvbG9yT2JqZWN0LmdldCgnYScpLCAnXCIvPiddO1xuXHRcdFx0XHRjcmVhdGVFbGVtZW50KHRoaXMucHJlcFZNTChtYXJrdXApLCBudWxsLCBudWxsLCBlbGVtKTtcblxuXHRcdFx0XHRyZXQgPSBjb2xvck9iamVjdC5nZXQoJ3JnYicpO1xuXG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwcm9wTm9kZXMgPSBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKHByb3ApOyAvLyAnc3Ryb2tlJyBvciAnZmlsbCcgbm9kZVxuXHRcdFx0XHRpZiAocHJvcE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHByb3BOb2Rlc1swXS5vcGFjaXR5ID0gMTtcblx0XHRcdFx0XHRwcm9wTm9kZXNbMF0udHlwZSA9ICdzb2xpZCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0ID0gY29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRha2UgYSBWTUwgc3RyaW5nIGFuZCBwcmVwYXJlIGl0IGZvciBlaXRoZXIgSUU4IG9yIElFNi9JRTcuXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbWFya3VwIEEgc3RyaW5nIGFycmF5IG9mIHRoZSBWTUwgbWFya3VwIHRvIHByZXBhcmVcblx0XHQgKi9cblx0XHRwcmVwVk1MOiBmdW5jdGlvbiAobWFya3VwKSB7XG5cdFx0XHR2YXIgdm1sU3R5bGUgPSAnZGlzcGxheTppbmxpbmUtYmxvY2s7YmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCk7Jyxcblx0XHRcdFx0aXNJRTggPSB0aGlzLmlzSUU4O1xuXG5cdFx0XHRtYXJrdXAgPSBtYXJrdXAuam9pbignJyk7XG5cblx0XHRcdGlmIChpc0lFOCkgeyAvLyBhZGQgeG1sbnMgYW5kIHN0eWxlIGlubGluZVxuXHRcdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZSgnLz4nLCAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIiAvPicpO1xuXHRcdFx0XHRpZiAobWFya3VwLmluZGV4T2YoJ3N0eWxlPVwiJykgPT09IC0xKSB7XG5cdFx0XHRcdFx0bWFya3VwID0gbWFya3VwLnJlcGxhY2UoJy8+JywgJyBzdHlsZT1cIicgKyB2bWxTdHlsZSArICdcIiAvPicpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1hcmt1cCA9IG1hcmt1cC5yZXBsYWNlKCdzdHlsZT1cIicsICdzdHlsZT1cIicgKyB2bWxTdHlsZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHsgLy8gYWRkIG5hbWVzcGFjZVxuXHRcdFx0XHRtYXJrdXAgPSBtYXJrdXAucmVwbGFjZSgnPCcsICc8aGN2OicpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWFya3VwO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgcm90YXRlZCBhbmQgYWxpZ25lZCB0ZXh0XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0XHQgKi9cblx0XHR0ZXh0OiBTVkdSZW5kZXJlci5wcm90b3R5cGUuaHRtbCxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgcGF0aCBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHtBcnJheX0gcGF0aFxuXHRcdCAqL1xuXHRcdHBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0XHR2YXIgYXR0ciA9IHtcblx0XHRcdFx0Ly8gc3VicGl4ZWwgcHJlY2lzaW9uIGRvd24gdG8gMC4xICh3aWR0aCBhbmQgaGVpZ2h0ID0gMXB4KVxuXHRcdFx0XHRjb29yZHNpemU6ICcxMCAxMCdcblx0XHRcdH07XG5cdFx0XHRpZiAoaXNBcnJheShwYXRoKSkge1xuXHRcdFx0XHRhdHRyLmQgPSBwYXRoO1xuXHRcdFx0fSBlbHNlIGlmIChpc09iamVjdChwYXRoKSkgeyAvLyBhdHRyaWJ1dGVzXG5cdFx0XHRcdGV4dGVuZChhdHRyLCBwYXRoKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSB0aGUgc2hhcGVcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3NoYXBlJykuYXR0cihhdHRyKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGFuZCByZXR1cm4gYSBjaXJjbGUgZWxlbWVudC4gSW4gVk1MIGNpcmNsZXMgYXJlIGltcGxlbWVudGVkIGFzXG5cdFx0ICogc2hhcGVzLCB3aGljaCBpcyBmYXN0ZXIgdGhhbiB2Om92YWxcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHJcblx0XHQgKi9cblx0XHRjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCByKSB7XG5cdFx0XHR2YXIgY2lyY2xlID0gdGhpcy5zeW1ib2woJ2NpcmNsZScpO1xuXHRcdFx0aWYgKGlzT2JqZWN0KHgpKSB7XG5cdFx0XHRcdHIgPSB4LnI7XG5cdFx0XHRcdHkgPSB4Lnk7XG5cdFx0XHRcdHggPSB4Lng7XG5cdFx0XHR9XG5cdFx0XHRjaXJjbGUuaXNDaXJjbGUgPSB0cnVlOyAvLyBDYXVzZXMgeCBhbmQgeSB0byBtZWFuIGNlbnRlciAoIzE2ODIpXG5cdFx0XHRjaXJjbGUuciA9IHI7XG5cdFx0XHRyZXR1cm4gY2lyY2xlLmF0dHIoeyB4OiB4LCB5OiB5IH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBncm91cCB1c2luZyBhbiBvdXRlciBkaXYgYW5kIGFuIGlubmVyIHY6Z3JvdXAgdG8gYWxsb3cgcm90YXRpbmdcblx0XHQgKiBhbmQgZmxpcHBpbmcuIEEgc2ltcGxlIHY6Z3JvdXAgd291bGQgaGF2ZSBwcm9ibGVtcyB3aXRoIHBvc2l0aW9uaW5nXG5cdFx0ICogY2hpbGQgSFRNTCBlbGVtZW50cyBhbmQgQ1NTIGNsaXAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZ3JvdXBcblx0XHQgKi9cblx0XHRnOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0dmFyIHdyYXBwZXIsXG5cdFx0XHRcdGF0dHJpYnM7XG5cblx0XHRcdC8vIHNldCB0aGUgY2xhc3MgbmFtZVxuXHRcdFx0aWYgKG5hbWUpIHtcblx0XHRcdFx0YXR0cmlicyA9IHsgJ2NsYXNzTmFtZSc6IFBSRUZJWCArIG5hbWUsICdjbGFzcyc6IFBSRUZJWCArIG5hbWUgfTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhlIGRpdiB0byBob2xkIEhUTUwgYW5kIGNsaXBwaW5nXG5cdFx0XHR3cmFwcGVyID0gdGhpcy5jcmVhdGVFbGVtZW50KERJVikuYXR0cihhdHRyaWJzKTtcblxuXHRcdFx0cmV0dXJuIHdyYXBwZXI7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFZNTCBvdmVycmlkZSB0byBjcmVhdGUgYSByZWd1bGFyIEhUTUwgaW1hZ2Vcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcblx0XHQgKi9cblx0XHRpbWFnZTogZnVuY3Rpb24gKHNyYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0dmFyIG9iaiA9IHRoaXMuY3JlYXRlRWxlbWVudCgnaW1nJylcblx0XHRcdFx0LmF0dHIoeyBzcmM6IHNyYyB9KTtcblxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdG9iai5hdHRyKHtcblx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRm9yIHJlY3RhbmdsZXMsIFZNTCB1c2VzIGEgc2hhcGUgZm9yIHJlY3QgdG8gb3ZlcmNvbWUgYnVncyBhbmQgcm90YXRpb24gcHJvYmxlbXNcblx0XHQgKi9cblx0XHRjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAobm9kZU5hbWUpIHtcblx0XHRcdHJldHVybiBub2RlTmFtZSA9PT0gJ3JlY3QnID8gdGhpcy5zeW1ib2wobm9kZU5hbWUpIDogU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBub2RlTmFtZSk7XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW4gdGhlIFZNTCByZW5kZXJlciwgZWFjaCBjaGlsZCBvZiBhbiBpbnZlcnRlZCBkaXYgKGdyb3VwKSBpcyBpbnZlcnRlZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmVudE5vZGVcblx0XHQgKi9cblx0XHRpbnZlcnRDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudE5vZGUpIHtcblx0XHRcdHZhciByZW4gPSB0aGlzLFxuXHRcdFx0XHRwYXJlbnRTdHlsZSA9IHBhcmVudE5vZGUuc3R5bGUsXG5cdFx0XHRcdGltZ1N0eWxlID0gZWxlbWVudC50YWdOYW1lID09PSAnSU1HJyAmJiBlbGVtZW50LnN0eWxlOyAvLyAjMTExMVxuXG5cdFx0XHRjc3MoZWxlbWVudCwge1xuXHRcdFx0XHRmbGlwOiAneCcsXG5cdFx0XHRcdGxlZnQ6IHBJbnQocGFyZW50U3R5bGUud2lkdGgpIC0gKGltZ1N0eWxlID8gcEludChpbWdTdHlsZS50b3ApIDogMSksXG5cdFx0XHRcdHRvcDogcEludChwYXJlbnRTdHlsZS5oZWlnaHQpIC0gKGltZ1N0eWxlID8gcEludChpbWdTdHlsZS5sZWZ0KSA6IDEpLFxuXHRcdFx0XHRyb3RhdGlvbjogLTkwXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUmVjdXJzaXZlbHkgaW52ZXJ0IGNoaWxkIGVsZW1lbnRzLCBuZWVkZWQgZm9yIG5lc3RlZCBjb21wb3NpdGUgc2hhcGVzIGxpa2UgYm94IHBsb3RzIGFuZCBlcnJvciBiYXJzLiAjMTY4MCwgIzE4MDYuXG5cdFx0XHRlYWNoKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRcdHJlbi5pbnZlcnRDaGlsZChjaGlsZCwgZWxlbWVudCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU3ltYm9sIGRlZmluaXRpb25zIHRoYXQgb3ZlcnJpZGUgdGhlIHBhcmVudCBTVkcgcmVuZGVyZXIncyBzeW1ib2xzXG5cdFx0ICpcblx0XHQgKi9cblx0XHRzeW1ib2xzOiB7XG5cdFx0XHQvLyBWTUwgc3BlY2lmaWMgYXJjIGZ1bmN0aW9uXG5cdFx0XHRhcmM6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG5cdFx0XHRcdHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQsXG5cdFx0XHRcdFx0ZW5kID0gb3B0aW9ucy5lbmQsXG5cdFx0XHRcdFx0cmFkaXVzID0gb3B0aW9ucy5yIHx8IHcgfHwgaCxcblx0XHRcdFx0XHRpbm5lclJhZGl1cyA9IG9wdGlvbnMuaW5uZXJSLFxuXHRcdFx0XHRcdGNvc1N0YXJ0ID0gbWF0aENvcyhzdGFydCksXG5cdFx0XHRcdFx0c2luU3RhcnQgPSBtYXRoU2luKHN0YXJ0KSxcblx0XHRcdFx0XHRjb3NFbmQgPSBtYXRoQ29zKGVuZCksXG5cdFx0XHRcdFx0c2luRW5kID0gbWF0aFNpbihlbmQpLFxuXHRcdFx0XHRcdHJldDtcblxuXHRcdFx0XHRpZiAoZW5kIC0gc3RhcnQgPT09IDApIHsgLy8gbm8gYW5nbGUsIGRvbid0IHNob3cgaXQuXG5cdFx0XHRcdFx0cmV0dXJuIFsneCddO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gW1xuXHRcdFx0XHRcdCd3YScsIC8vIGNsb2Nrd2lzZSBhcmMgdG9cblx0XHRcdFx0XHR4IC0gcmFkaXVzLCAvLyBsZWZ0XG5cdFx0XHRcdFx0eSAtIHJhZGl1cywgLy8gdG9wXG5cdFx0XHRcdFx0eCArIHJhZGl1cywgLy8gcmlnaHRcblx0XHRcdFx0XHR5ICsgcmFkaXVzLCAvLyBib3R0b21cblx0XHRcdFx0XHR4ICsgcmFkaXVzICogY29zU3RhcnQsIC8vIHN0YXJ0IHhcblx0XHRcdFx0XHR5ICsgcmFkaXVzICogc2luU3RhcnQsIC8vIHN0YXJ0IHlcblx0XHRcdFx0XHR4ICsgcmFkaXVzICogY29zRW5kLCAvLyBlbmQgeFxuXHRcdFx0XHRcdHkgKyByYWRpdXMgKiBzaW5FbmQgIC8vIGVuZCB5XG5cdFx0XHRcdF07XG5cblx0XHRcdFx0aWYgKG9wdGlvbnMub3BlbiAmJiAhaW5uZXJSYWRpdXMpIHtcblx0XHRcdFx0XHRyZXQucHVzaChcblx0XHRcdFx0XHRcdCdlJyxcblx0XHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0XHR4LC8vIC0gaW5uZXJSYWRpdXMsXG5cdFx0XHRcdFx0XHR5Ly8gLSBpbm5lclJhZGl1c1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQucHVzaChcblx0XHRcdFx0XHQnYXQnLCAvLyBhbnRpIGNsb2Nrd2lzZSBhcmMgdG9cblx0XHRcdFx0XHR4IC0gaW5uZXJSYWRpdXMsIC8vIGxlZnRcblx0XHRcdFx0XHR5IC0gaW5uZXJSYWRpdXMsIC8vIHRvcFxuXHRcdFx0XHRcdHggKyBpbm5lclJhZGl1cywgLy8gcmlnaHRcblx0XHRcdFx0XHR5ICsgaW5uZXJSYWRpdXMsIC8vIGJvdHRvbVxuXHRcdFx0XHRcdHggKyBpbm5lclJhZGl1cyAqIGNvc0VuZCwgLy8gc3RhcnQgeFxuXHRcdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpbkVuZCwgLy8gc3RhcnQgeVxuXHRcdFx0XHRcdHggKyBpbm5lclJhZGl1cyAqIGNvc1N0YXJ0LCAvLyBlbmQgeFxuXHRcdFx0XHRcdHkgKyBpbm5lclJhZGl1cyAqIHNpblN0YXJ0LCAvLyBlbmQgeVxuXHRcdFx0XHRcdCd4JywgLy8gZmluaXNoIHBhdGhcblx0XHRcdFx0XHQnZScgLy8gY2xvc2Vcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRyZXQuaXNBcmMgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9LFxuXHRcdFx0Ly8gQWRkIGNpcmNsZSBzeW1ib2wgcGF0aC4gVGhpcyBwZXJmb3JtcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIHY6b3ZhbC5cblx0XHRcdGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHdyYXBwZXIpIHtcblxuXHRcdFx0XHRpZiAod3JhcHBlcikge1xuXHRcdFx0XHRcdHcgPSBoID0gMiAqIHdyYXBwZXIucjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENlbnRlciBjb3JyZWN0aW9uLCAjMTY4MlxuXHRcdFx0XHRpZiAod3JhcHBlciAmJiB3cmFwcGVyLmlzQ2lyY2xlKSB7XG5cdFx0XHRcdFx0eCAtPSB3IC8gMjtcblx0XHRcdFx0XHR5IC09IGggLyAyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIHRoZSBwYXRoXG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0J3dhJywgLy8gY2xvY2t3aXNlYXJjdG9cblx0XHRcdFx0XHR4LCAvLyBsZWZ0XG5cdFx0XHRcdFx0eSwgLy8gdG9wXG5cdFx0XHRcdFx0eCArIHcsIC8vIHJpZ2h0XG5cdFx0XHRcdFx0eSArIGgsIC8vIGJvdHRvbVxuXHRcdFx0XHRcdHggKyB3LCAvLyBzdGFydCB4XG5cdFx0XHRcdFx0eSArIGggLyAyLCAgICAgLy8gc3RhcnQgeVxuXHRcdFx0XHRcdHggKyB3LCAvLyBlbmQgeFxuXHRcdFx0XHRcdHkgKyBoIC8gMiwgICAgIC8vIGVuZCB5XG5cdFx0XHRcdFx0Ly8neCcsIC8vIGZpbmlzaCBwYXRoXG5cdFx0XHRcdFx0J2UnIC8vIGNsb3NlXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGQgcmVjdGFuZ2xlIHN5bWJvbCBwYXRoIHdoaWNoIGVhc2VzIHJvdGF0aW9uIGFuZCBvbWl0cyBhcmNzaXplIHByb2JsZW1zXG5cdFx0XHQgKiBjb21wYXJlZCB0byB0aGUgYnVpbHQtaW4gVk1MIHJvdW5kcmVjdCBzaGFwZS4gV2hlbiBib3JkZXJzIGFyZSBub3Qgcm91bmRlZCxcblx0XHRcdCAqIHVzZSB0aGUgc2ltcGxlciBzcXVhcmUgcGF0aCwgZWxzZSB1c2UgdGhlIGNhbGxvdXQgcGF0aCB3aXRob3V0IHRoZSBhcnJvdy5cblx0XHRcdCAqL1xuXHRcdFx0cmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIG9wdGlvbnMpIHtcblx0XHRcdFx0cmV0dXJuIFNWR1JlbmRlcmVyLnByb3RvdHlwZS5zeW1ib2xzW1xuXHRcdFx0XHRcdCFkZWZpbmVkKG9wdGlvbnMpIHx8ICFvcHRpb25zLnIgPyAnc3F1YXJlJyA6ICdjYWxsb3V0J1xuXHRcdFx0XHRdLmNhbGwoMCwgeCwgeSwgdywgaCwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRIaWdoY2hhcnRzLlZNTFJlbmRlcmVyID0gVk1MUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cdFZNTFJlbmRlcmVyLnByb3RvdHlwZSA9IG1lcmdlKFNWR1JlbmRlcmVyLnByb3RvdHlwZSwgVk1MUmVuZGVyZXJFeHRlbnNpb24pO1xuXG5cdFx0Ly8gZ2VuZXJhbCByZW5kZXJlclxuXHRcdFJlbmRlcmVyID0gVk1MUmVuZGVyZXI7XG5cdH1cblxuXHQvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIHdpdGggZXhwb3J0aW5nIGluIG9sZCBJRSwgd2hlbiBlbXVsYXRpbmcgU1ZHIChzZWUgIzIzMTQpXG5cdFNWR1JlbmRlcmVyLnByb3RvdHlwZS5tZWFzdXJlU3BhbldpZHRoID0gZnVuY3Rpb24gKHRleHQsIHN0eWxlcykge1xuXHRcdHZhciBtZWFzdXJpbmdTcGFuID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSxcblx0XHRcdG9mZnNldFdpZHRoLFxuXHRcdHRleHROb2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpO1xuXG5cdFx0bWVhc3VyaW5nU3Bhbi5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG5cdFx0Y3NzKG1lYXN1cmluZ1NwYW4sIHN0eWxlcyk7XG5cdFx0dGhpcy5ib3guYXBwZW5kQ2hpbGQobWVhc3VyaW5nU3Bhbik7XG5cdFx0b2Zmc2V0V2lkdGggPSBtZWFzdXJpbmdTcGFuLm9mZnNldFdpZHRoO1xuXHRcdGRpc2NhcmRFbGVtZW50KG1lYXN1cmluZ1NwYW4pOyAvLyAjMjQ2M1xuXHRcdHJldHVybiBvZmZzZXRXaWR0aDtcblx0fTtcblxuXG5cdC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiBFTkQgT0YgSU5URVJORVQgRVhQTE9SRVIgPD0gOCBTUEVDSUZJQyBDT0RFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICogU1RBUlQgT0YgQU5EUk9JRCA8IDMgU1BFQ0lGSUMgQ09ERS4gVEhJUyBDQU4gQkUgUkVNT1ZFRCBJRiBZT1UnUkUgTk9UICAgICAgKlxuXHQgKiBUQVJHRVRJTkcgVEhBVCBTWVNURU0uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHR2YXIgQ2FuVkdSZW5kZXJlcixcblx0XHRDYW5WR0NvbnRyb2xsZXI7XG5cblx0aWYgKHVzZUNhblZHKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIENhblZHUmVuZGVyZXIgaXMgZW1wdHkgZnJvbSBzdGFydCB0byBrZWVwIHRoZSBzb3VyY2UgZm9vdHByaW50IHNtYWxsLlxuXHRcdCAqIFdoZW4gcmVxdWVzdGVkLCB0aGUgQ2FuVkdDb250cm9sbGVyIGRvd25sb2FkcyB0aGUgcmVzdCBvZiB0aGUgc291cmNlIHBhY2thZ2VkXG5cdFx0ICogdG9nZXRoZXIgd2l0aCB0aGUgY2FudmcgbGlicmFyeS5cblx0XHQgKi9cblx0XHRIaWdoY2hhcnRzLkNhblZHUmVuZGVyZXIgPSBDYW5WR1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gT3ZlcnJpZGUgdGhlIGdsb2JhbCBTVkcgbmFtZXNwYWNlIHRvIGZha2UgU1ZHL0hUTUwgdGhhdCBhY2NlcHRzIENTU1xuXHRcdFx0U1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBTdGFydCB3aXRoIGFuIGVtcHR5IHN5bWJvbHMgb2JqZWN0LiBUaGlzIGlzIG5lZWRlZCB3aGVuIGV4cG9ydGluZyBpcyB1c2VkIChleHBvcnRpbmcuc3JjLmpzIHdpbGwgYWRkIGEgZmV3IHN5bWJvbHMpLCBidXQgXG5cdFx0ICogdGhlIGltcGxlbWVudGF0aW9uIGZyb20gU3ZnUmVuZGVyZXIgd2lsbCBub3QgYmUgbWVyZ2VkIGluIHVudGlsIGZpcnN0IHJlbmRlci5cblx0XHQgKi9cblx0XHRDYW5WR1JlbmRlcmVyLnByb3RvdHlwZS5zeW1ib2xzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVzIG9uIGRlbWFuZCBkb3dubG9hZCBvZiBjYW52ZyByZW5kZXJpbmcgc3VwcG9ydC5cblx0XHQgKi9cblx0XHRDYW5WR0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gTGlzdCBvZiByZW5kZXJlcmluZyBjYWxsc1xuXHRcdFx0dmFyIGRlZmVycmVkUmVuZGVyQ2FsbHMgPSBbXTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGVuIGRvd25sb2FkZWQsIHdlIGFyZSByZWFkeSB0byBkcmF3IGRlZmVycmVkIGNoYXJ0cy5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gZHJhd0RlZmVycmVkKCkge1xuXHRcdFx0XHR2YXIgY2FsbExlbmd0aCA9IGRlZmVycmVkUmVuZGVyQ2FsbHMubGVuZ3RoLFxuXHRcdFx0XHRcdGNhbGxJbmRleDtcblxuXHRcdFx0XHQvLyBEcmF3IGFsbCBwZW5kaW5nIHJlbmRlciBjYWxsc1xuXHRcdFx0XHRmb3IgKGNhbGxJbmRleCA9IDA7IGNhbGxJbmRleCA8IGNhbGxMZW5ndGg7IGNhbGxJbmRleCsrKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWRSZW5kZXJDYWxsc1tjYWxsSW5kZXhdKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ2xlYXIgdGhlIGxpc3Rcblx0XHRcdFx0ZGVmZXJyZWRSZW5kZXJDYWxscyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwdXNoOiBmdW5jdGlvbiAoZnVuYywgc2NyaXB0TG9jYXRpb24pIHtcblx0XHRcdFx0XHQvLyBPbmx5IGdldCB0aGUgc2NyaXB0IG9uY2Vcblx0XHRcdFx0XHRpZiAoZGVmZXJyZWRSZW5kZXJDYWxscy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdGdldFNjcmlwdChzY3JpcHRMb2NhdGlvbiwgZHJhd0RlZmVycmVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gUmVnaXN0ZXIgcmVuZGVyIGNhbGxcblx0XHRcdFx0XHRkZWZlcnJlZFJlbmRlckNhbGxzLnB1c2goZnVuYyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSgpKTtcblxuXHRcdFJlbmRlcmVyID0gQ2FuVkdSZW5kZXJlcjtcblx0fSAvLyBlbmQgQ2FuVkdSZW5kZXJlclxuXG5cdC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgKiBFTkQgT0YgQU5EUk9JRCA8IDMgU1BFQ0lGSUMgQ09ERSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdC8qKlxuXHQgKiBUaGUgVGljayBjbGFzc1xuXHQgKi9cblx0ZnVuY3Rpb24gVGljayhheGlzLCBwb3MsIHR5cGUsIG5vTGFiZWwpIHtcblx0XHR0aGlzLmF4aXMgPSBheGlzO1xuXHRcdHRoaXMucG9zID0gcG9zO1xuXHRcdHRoaXMudHlwZSA9IHR5cGUgfHwgJyc7XG5cdFx0dGhpcy5pc05ldyA9IHRydWU7XG5cblx0XHRpZiAoIXR5cGUgJiYgIW5vTGFiZWwpIHtcblx0XHRcdHRoaXMuYWRkTGFiZWwoKTtcblx0XHR9XG5cdH1cblxuXHRUaWNrLnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiBXcml0ZSB0aGUgdGljayBsYWJlbFxuXHRcdCAqL1xuXHRcdGFkZExhYmVsOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdGljayA9IHRoaXMsXG5cdFx0XHRcdGF4aXMgPSB0aWNrLmF4aXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdFx0Y2F0ZWdvcmllcyA9IGF4aXMuY2F0ZWdvcmllcyxcblx0XHRcdFx0bmFtZXMgPSBheGlzLm5hbWVzLFxuXHRcdFx0XHRwb3MgPSB0aWNrLnBvcyxcblx0XHRcdFx0bGFiZWxPcHRpb25zID0gb3B0aW9ucy5sYWJlbHMsXG5cdFx0XHRcdHN0cixcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IGF4aXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0aXNGaXJzdCA9IHBvcyA9PT0gdGlja1Bvc2l0aW9uc1swXSxcblx0XHRcdFx0aXNMYXN0ID0gcG9zID09PSB0aWNrUG9zaXRpb25zW3RpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMV0sXG5cdFx0XHRcdHZhbHVlID0gY2F0ZWdvcmllcyA/XG5cdFx0XHRcdFx0cGljayhjYXRlZ29yaWVzW3Bvc10sIG5hbWVzW3Bvc10sIHBvcykgOlxuXHRcdFx0XHRcdHBvcyxcblx0XHRcdFx0bGFiZWwgPSB0aWNrLmxhYmVsLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25JbmZvID0gdGlja1Bvc2l0aW9ucy5pbmZvLFxuXHRcdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0O1xuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGV0aW1lIGxhYmVsIGZvcm1hdC4gSWYgYSBoaWdoZXIgcmFuayBpcyBzZXQgZm9yIHRoaXMgcG9zaXRpb24sIHVzZSB0aGF0LiBJZiBub3QsXG5cdFx0XHQvLyB1c2UgdGhlIGdlbmVyYWwgZm9ybWF0LlxuXHRcdFx0aWYgKGF4aXMuaXNEYXRldGltZUF4aXMgJiYgdGlja1Bvc2l0aW9uSW5mbykge1xuXHRcdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0ID0gb3B0aW9ucy5kYXRlVGltZUxhYmVsRm9ybWF0c1t0aWNrUG9zaXRpb25JbmZvLmhpZ2hlclJhbmtzW3Bvc10gfHwgdGlja1Bvc2l0aW9uSW5mby51bml0TmFtZV07XG5cdFx0XHR9XG5cdFx0XHQvLyBzZXQgcHJvcGVydGllcyBmb3IgYWNjZXNzIGluIHJlbmRlciBtZXRob2Rcblx0XHRcdHRpY2suaXNGaXJzdCA9IGlzRmlyc3Q7XG5cdFx0XHR0aWNrLmlzTGFzdCA9IGlzTGFzdDtcblxuXHRcdFx0Ly8gZ2V0IHRoZSBzdHJpbmdcblx0XHRcdHN0ciA9IGF4aXMubGFiZWxGb3JtYXR0ZXIuY2FsbCh7XG5cdFx0XHRcdGF4aXM6IGF4aXMsXG5cdFx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdFx0aXNGaXJzdDogaXNGaXJzdCxcblx0XHRcdFx0aXNMYXN0OiBpc0xhc3QsXG5cdFx0XHRcdGRhdGVUaW1lTGFiZWxGb3JtYXQ6IGRhdGVUaW1lTGFiZWxGb3JtYXQsXG5cdFx0XHRcdHZhbHVlOiBheGlzLmlzTG9nID8gY29ycmVjdEZsb2F0KGxpbjJsb2codmFsdWUpKSA6IHZhbHVlXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcHJlcGFyZSBDU1Ncblx0XHRcdC8vY3NzID0gd2lkdGggJiYgeyB3aWR0aDogbWF0aE1heCgxLCBtYXRoUm91bmQod2lkdGggLSAyICogKGxhYmVsT3B0aW9ucy5wYWRkaW5nIHx8IDEwKSkpICsgUFggfTtcblx0XHRcdFxuXHRcdFx0Ly8gZmlyc3QgY2FsbFxuXHRcdFx0aWYgKCFkZWZpbmVkKGxhYmVsKSkge1xuXG5cdFx0XHRcdHRpY2subGFiZWwgPSBsYWJlbCA9XG5cdFx0XHRcdFx0ZGVmaW5lZChzdHIpICYmIGxhYmVsT3B0aW9ucy5lbmFibGVkID9cblx0XHRcdFx0XHRcdGNoYXJ0LnJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0XHRcdFx0c3RyLFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbE9wdGlvbnMudXNlSFRNTFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdC8vLmF0dHIoYXR0cilcblx0XHRcdFx0XHRcdFx0Ly8gd2l0aG91dCBwb3NpdGlvbiBhYnNvbHV0ZSwgSUUgZXhwb3J0IHNvbWV0aW1lcyBpcyB3cm9uZ1xuXHRcdFx0XHRcdFx0XHQuY3NzKG1lcmdlKGxhYmVsT3B0aW9ucy5zdHlsZSkpXG5cdFx0XHRcdFx0XHRcdC5hZGQoYXhpcy5sYWJlbEdyb3VwKSA6XG5cdFx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHR0aWNrLmxhYmVsTGVuZ3RoID0gbGFiZWwgJiYgbGFiZWwuZ2V0QkJveCgpLndpZHRoOyAvLyBVbi1yb3RhdGVkIGxlbmd0aFxuXHRcdFx0XHR0aWNrLnJvdGF0aW9uID0gMDsgLy8gQmFzZSB2YWx1ZSB0byBkZXRlY3QgY2hhbmdlIGZvciBuZXcgY2FsbHMgdG8gZ2V0QkJveFxuXG5cdFx0XHQvLyB1cGRhdGVcblx0XHRcdH0gZWxzZSBpZiAobGFiZWwpIHtcblx0XHRcdFx0bGFiZWwuYXR0cih7IHRleHQ6IHN0ciB9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBvZmZzZXQgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBsYWJlbFxuXHRcdCAqL1xuXHRcdGdldExhYmVsU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubGFiZWwgP1xuXHRcdFx0XHR0aGlzLmxhYmVsLmdldEJCb3goKVt0aGlzLmF4aXMuaG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCddIDpcblx0XHRcdFx0MDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlIHRoZSBsYWJlbCBvdmVyZmxvdyBieSBhZGp1c3RpbmcgdGhlIGxhYmVscyB0byB0aGUgbGVmdCBhbmQgcmlnaHQgZWRnZSwgb3Jcblx0XHQgKiBoaWRlIHRoZW0gaWYgdGhleSBjb2xsaWRlIGludG8gdGhlIG5laWdoYm91ciBsYWJlbC5cblx0XHQgKi9cblx0XHRoYW5kbGVPdmVyZmxvdzogZnVuY3Rpb24gKHh5KSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdFx0cHhQb3MgPSB4eS54LFxuXHRcdFx0XHRjaGFydFdpZHRoID0gYXhpcy5jaGFydC5jaGFydFdpZHRoLFxuXHRcdFx0XHRzcGFjaW5nID0gYXhpcy5jaGFydC5zcGFjaW5nLFxuXHRcdFx0XHRsZWZ0Qm91bmQgPSBwaWNrKGF4aXMubGFiZWxMZWZ0LCBzcGFjaW5nWzNdKSxcblx0XHRcdFx0cmlnaHRCb3VuZCA9IHBpY2soYXhpcy5sYWJlbFJpZ2h0LCBjaGFydFdpZHRoIC0gc3BhY2luZ1sxXSksXG5cdFx0XHRcdGxhYmVsID0gdGhpcy5sYWJlbCxcblx0XHRcdFx0cm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuXHRcdFx0XHRmYWN0b3IgPSB7IGxlZnQ6IDAsIGNlbnRlcjogMC41LCByaWdodDogMSB9W2F4aXMubGFiZWxBbGlnbl0sXG5cdFx0XHRcdGxhYmVsV2lkdGggPSBsYWJlbC5nZXRCQm94KCkud2lkdGgsXG5cdFx0XHRcdHNsb3RXaWR0aCA9IGF4aXMuc2xvdFdpZHRoLFxuXHRcdFx0XHRsZWZ0UG9zLFxuXHRcdFx0XHRyaWdodFBvcyxcblx0XHRcdFx0dGV4dFdpZHRoO1xuXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgbGFiZWwgb3ZlcnNob290cyB0aGUgY2hhcnQgc3BhY2luZyBib3guIElmIGl0IGRvZXMsIG1vdmUgaXQuXG5cdFx0XHQvLyBJZiBpdCBub3cgb3ZlcnNob290cyB0aGUgc2xvdFdpZHRoLCBhZGQgZWxsaXBzaXMuXG5cdFx0XHRpZiAoIXJvdGF0aW9uKSB7XG5cdFx0XHRcdGxlZnRQb3MgPSBweFBvcyAtIGZhY3RvciAqIGxhYmVsV2lkdGg7XG5cdFx0XHRcdHJpZ2h0UG9zID0gcHhQb3MgKyBmYWN0b3IgKiBsYWJlbFdpZHRoO1xuXG5cdFx0XHRcdGlmIChsZWZ0UG9zIDwgbGVmdEJvdW5kKSB7XG5cdFx0XHRcdFx0c2xvdFdpZHRoIC09IGxlZnRCb3VuZCAtIGxlZnRQb3M7XG5cdFx0XHRcdFx0eHkueCA9IGxlZnRCb3VuZDtcblx0XHRcdFx0XHRsYWJlbC5hdHRyKHsgYWxpZ246ICdsZWZ0JyB9KTtcdFx0XHRcdFxuXHRcdFx0XHR9IGVsc2UgaWYgKHJpZ2h0UG9zID4gcmlnaHRCb3VuZCkge1xuXHRcdFx0XHRcdHNsb3RXaWR0aCAtPSByaWdodFBvcyAtIHJpZ2h0Qm91bmQ7XG5cdFx0XHRcdFx0eHkueCA9IHJpZ2h0Qm91bmQ7XG5cdFx0XHRcdFx0bGFiZWwuYXR0cih7IGFsaWduOiAncmlnaHQnIH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxhYmVsV2lkdGggPiBzbG90V2lkdGgpIHtcblx0XHRcdFx0XHR0ZXh0V2lkdGggPSBzbG90V2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdFxuXG5cdFx0XHQvLyBBZGQgZWxsaXBzaXMgdG8gcHJldmVudCByb3RhdGVkIGxhYmVscyB0byBiZSBjbGlwcGVkIGFnYWluc3QgdGhlIGVkZ2Ugb2YgdGhlIGNoYXJ0XG5cdFx0XHR9IGVsc2UgaWYgKHJvdGF0aW9uIDwgMCAmJiBweFBvcyAtIGZhY3RvciAqIGxhYmVsV2lkdGggPCBsZWZ0Qm91bmQpIHtcblx0XHRcdFx0dGV4dFdpZHRoID0gbWF0aFJvdW5kKHB4UG9zIC8gbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpIC0gbGVmdEJvdW5kKTtcblx0XHRcdH0gZWxzZSBpZiAocm90YXRpb24gPiAwICYmIHB4UG9zICsgZmFjdG9yICogbGFiZWxXaWR0aCA+IHJpZ2h0Qm91bmQpIHtcblx0XHRcdFx0dGV4dFdpZHRoID0gbWF0aFJvdW5kKChjaGFydFdpZHRoIC0gcHhQb3MpIC8gbWF0aENvcyhyb3RhdGlvbiAqIGRlZzJyYWQpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRleHRXaWR0aCkge1xuXHRcdFx0XHRsYWJlbC5jc3Moe1xuXHRcdFx0XHRcdHdpZHRoOiB0ZXh0V2lkdGgsXG5cdFx0XHRcdFx0dGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHggYW5kIHkgcG9zaXRpb24gZm9yIHRpY2tzIGFuZCBsYWJlbHNcblx0XHQgKi9cblx0XHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKGhvcml6LCBwb3MsIHRpY2ttYXJrT2Zmc2V0LCBvbGQpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcy5heGlzLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRcdGNIZWlnaHQgPSAob2xkICYmIGNoYXJ0Lm9sZENoYXJ0SGVpZ2h0KSB8fCBjaGFydC5jaGFydEhlaWdodDtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogaG9yaXogP1xuXHRcdFx0XHRcdGF4aXMudHJhbnNsYXRlKHBvcyArIHRpY2ttYXJrT2Zmc2V0LCBudWxsLCBudWxsLCBvbGQpICsgYXhpcy50cmFuc0IgOlxuXHRcdFx0XHRcdGF4aXMubGVmdCArIGF4aXMub2Zmc2V0ICsgKGF4aXMub3Bwb3NpdGUgPyAoKG9sZCAmJiBjaGFydC5vbGRDaGFydFdpZHRoKSB8fCBjaGFydC5jaGFydFdpZHRoKSAtIGF4aXMucmlnaHQgLSBheGlzLmxlZnQgOiAwKSxcblxuXHRcdFx0XHR5OiBob3JpeiA/XG5cdFx0XHRcdFx0Y0hlaWdodCAtIGF4aXMuYm90dG9tICsgYXhpcy5vZmZzZXQgLSAoYXhpcy5vcHBvc2l0ZSA/IGF4aXMuaGVpZ2h0IDogMCkgOlxuXHRcdFx0XHRcdGNIZWlnaHQgLSBheGlzLnRyYW5zbGF0ZShwb3MgKyB0aWNrbWFya09mZnNldCwgbnVsbCwgbnVsbCwgb2xkKSAtIGF4aXMudHJhbnNCXG5cdFx0XHR9O1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgeCwgeSBwb3NpdGlvbiBvZiB0aGUgdGljayBsYWJlbFxuXHRcdCAqL1xuXHRcdGdldExhYmVsUG9zaXRpb246IGZ1bmN0aW9uICh4LCB5LCBsYWJlbCwgaG9yaXosIGxhYmVsT3B0aW9ucywgdGlja21hcmtPZmZzZXQsIGluZGV4LCBzdGVwKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdFx0dHJhbnNBID0gYXhpcy50cmFuc0EsXG5cdFx0XHRcdHJldmVyc2VkID0gYXhpcy5yZXZlcnNlZCxcblx0XHRcdFx0c3RhZ2dlckxpbmVzID0gYXhpcy5zdGFnZ2VyTGluZXMsXG5cdFx0XHRcdHJvdENvcnIgPSBheGlzLnRpY2tSb3RDb3JyIHx8IHsgeDogMCwgeTogMCB9LFxuXHRcdFx0XHR5T2Zmc2V0ID0gcGljayhsYWJlbE9wdGlvbnMueSwgcm90Q29yci55ICsgKGF4aXMuc2lkZSA9PT0gMiA/IDggOiAtKGxhYmVsLmdldEJCb3goKS5oZWlnaHQgLyAyKSkpLFxuXHRcdFx0XHRsaW5lO1xuXG5cdFx0XHR4ID0geCArIGxhYmVsT3B0aW9ucy54ICsgcm90Q29yci54IC0gKHRpY2ttYXJrT2Zmc2V0ICYmIGhvcml6ID9cblx0XHRcdFx0dGlja21hcmtPZmZzZXQgKiB0cmFuc0EgKiAocmV2ZXJzZWQgPyAtMSA6IDEpIDogMCk7XG5cdFx0XHR5ID0geSArIHlPZmZzZXQgLSAodGlja21hcmtPZmZzZXQgJiYgIWhvcml6ID9cblx0XHRcdFx0dGlja21hcmtPZmZzZXQgKiB0cmFuc0EgKiAocmV2ZXJzZWQgPyAxIDogLTEpIDogMCk7XG5cblx0XHRcdC8vIENvcnJlY3QgZm9yIHN0YWdnZXJlZCBsYWJlbHNcblx0XHRcdGlmIChzdGFnZ2VyTGluZXMpIHtcblx0XHRcdFx0bGluZSA9IChpbmRleCAvIChzdGVwIHx8IDEpICUgc3RhZ2dlckxpbmVzKTtcblx0XHRcdFx0eSArPSBsaW5lICogKGF4aXMubGFiZWxPZmZzZXQgLyBzdGFnZ2VyTGluZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4OiB4LFxuXHRcdFx0XHR5OiBtYXRoUm91bmQoeSlcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZGlibGUgbWV0aG9kIHRvIHJldHVybiB0aGUgcGF0aCBvZiB0aGUgbWFya2VyXG5cdFx0ICovXG5cdFx0Z2V0TWFya1BhdGg6IGZ1bmN0aW9uICh4LCB5LCB0aWNrTGVuZ3RoLCB0aWNrV2lkdGgsIGhvcml6LCByZW5kZXJlcikge1xuXHRcdFx0cmV0dXJuIHJlbmRlcmVyLmNyaXNwTGluZShbXG5cdFx0XHRcdFx0TSxcblx0XHRcdFx0XHR4LFxuXHRcdFx0XHRcdHksXG5cdFx0XHRcdFx0TCxcblx0XHRcdFx0XHR4ICsgKGhvcml6ID8gMCA6IC10aWNrTGVuZ3RoKSxcblx0XHRcdFx0XHR5ICsgKGhvcml6ID8gdGlja0xlbmd0aCA6IDApXG5cdFx0XHRcdF0sIHRpY2tXaWR0aCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFB1dCBldmVyeXRoaW5nIGluIHBsYWNlXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gaW5kZXgge051bWJlcn1cblx0XHQgKiBAcGFyYW0gb2xkIHtCb29sZWFufSBVc2Ugb2xkIGNvb3JkaW5hdGVzIHRvIHByZXBhcmUgYW4gYW5pbWF0aW9uIGludG8gbmV3IHBvc2l0aW9uXG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoaW5kZXgsIG9sZCwgb3BhY2l0eSkge1xuXHRcdFx0dmFyIHRpY2sgPSB0aGlzLFxuXHRcdFx0XHRheGlzID0gdGljay5heGlzLFxuXHRcdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0dHlwZSA9IHRpY2sudHlwZSxcblx0XHRcdFx0bGFiZWwgPSB0aWNrLmxhYmVsLFxuXHRcdFx0XHRwb3MgPSB0aWNrLnBvcyxcblx0XHRcdFx0bGFiZWxPcHRpb25zID0gb3B0aW9ucy5sYWJlbHMsXG5cdFx0XHRcdGdyaWRMaW5lID0gdGljay5ncmlkTGluZSxcblx0XHRcdFx0Z3JpZFByZWZpeCA9IHR5cGUgPyB0eXBlICsgJ0dyaWQnIDogJ2dyaWQnLFxuXHRcdFx0XHR0aWNrUHJlZml4ID0gdHlwZSA/IHR5cGUgKyAnVGljaycgOiAndGljaycsXG5cdFx0XHRcdGdyaWRMaW5lV2lkdGggPSBvcHRpb25zW2dyaWRQcmVmaXggKyAnTGluZVdpZHRoJ10sXG5cdFx0XHRcdGdyaWRMaW5lQ29sb3IgPSBvcHRpb25zW2dyaWRQcmVmaXggKyAnTGluZUNvbG9yJ10sXG5cdFx0XHRcdGRhc2hTdHlsZSA9IG9wdGlvbnNbZ3JpZFByZWZpeCArICdMaW5lRGFzaFN0eWxlJ10sXG5cdFx0XHRcdHRpY2tMZW5ndGggPSBvcHRpb25zW3RpY2tQcmVmaXggKyAnTGVuZ3RoJ10sXG5cdFx0XHRcdHRpY2tXaWR0aCA9IG9wdGlvbnNbdGlja1ByZWZpeCArICdXaWR0aCddIHx8IDAsXG5cdFx0XHRcdHRpY2tDb2xvciA9IG9wdGlvbnNbdGlja1ByZWZpeCArICdDb2xvciddLFxuXHRcdFx0XHR0aWNrUG9zaXRpb24gPSBvcHRpb25zW3RpY2tQcmVmaXggKyAnUG9zaXRpb24nXSxcblx0XHRcdFx0Z3JpZExpbmVQYXRoLFxuXHRcdFx0XHRtYXJrID0gdGljay5tYXJrLFxuXHRcdFx0XHRtYXJrUGF0aCxcblx0XHRcdFx0c3RlcCA9IC8qYXhpcy5sYWJlbFN0ZXAgfHwgKi9sYWJlbE9wdGlvbnMuc3RlcCxcblx0XHRcdFx0YXR0cmlicyxcblx0XHRcdFx0c2hvdyA9IHRydWUsXG5cdFx0XHRcdHRpY2ttYXJrT2Zmc2V0ID0gYXhpcy50aWNrbWFya09mZnNldCxcblx0XHRcdFx0eHkgPSB0aWNrLmdldFBvc2l0aW9uKGhvcml6LCBwb3MsIHRpY2ttYXJrT2Zmc2V0LCBvbGQpLFxuXHRcdFx0XHR4ID0geHkueCxcblx0XHRcdFx0eSA9IHh5LnksXG5cdFx0XHRcdHJldmVyc2VDcmlzcCA9ICgoaG9yaXogJiYgeCA9PT0gYXhpcy5wb3MgKyBheGlzLmxlbikgfHwgKCFob3JpeiAmJiB5ID09PSBheGlzLnBvcykpID8gLTEgOiAxOyAvLyAjMTQ4MCwgIzE2ODdcblxuXHRcdFx0b3BhY2l0eSA9IHBpY2sob3BhY2l0eSwgMSk7XG5cdFx0XHR0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSBncmlkIGxpbmVcblx0XHRcdGlmIChncmlkTGluZVdpZHRoKSB7XG5cdFx0XHRcdGdyaWRMaW5lUGF0aCA9IGF4aXMuZ2V0UGxvdExpbmVQYXRoKHBvcyArIHRpY2ttYXJrT2Zmc2V0LCBncmlkTGluZVdpZHRoICogcmV2ZXJzZUNyaXNwLCBvbGQsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChncmlkTGluZSA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0YXR0cmlicyA9IHtcblx0XHRcdFx0XHRcdHN0cm9rZTogZ3JpZExpbmVDb2xvcixcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBncmlkTGluZVdpZHRoXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiAoZGFzaFN0eWxlKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzLmRhc2hzdHlsZSA9IGRhc2hTdHlsZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCF0eXBlKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzLnpJbmRleCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChvbGQpIHtcblx0XHRcdFx0XHRcdGF0dHJpYnMub3BhY2l0eSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpY2suZ3JpZExpbmUgPSBncmlkTGluZSA9XG5cdFx0XHRcdFx0XHRncmlkTGluZVdpZHRoID9cblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIucGF0aChncmlkTGluZVBhdGgpXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoYXR0cmlicykuYWRkKGF4aXMuZ3JpZEdyb3VwKSA6XG5cdFx0XHRcdFx0XHRcdG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgcGFyYW1ldGVyICdvbGQnIGlzIHNldCwgdGhlIGN1cnJlbnQgY2FsbCB3aWxsIGJlIGZvbGxvd2VkXG5cdFx0XHRcdC8vIGJ5IGFub3RoZXIgY2FsbCwgdGhlcmVmb3JlIGRvIG5vdCBkbyBhbnkgYW5pbWF0aW9ucyB0aGlzIHRpbWVcblx0XHRcdFx0aWYgKCFvbGQgJiYgZ3JpZExpbmUgJiYgZ3JpZExpbmVQYXRoKSB7XG5cdFx0XHRcdFx0Z3JpZExpbmVbdGljay5pc05ldyA/ICdhdHRyJyA6ICdhbmltYXRlJ10oe1xuXHRcdFx0XHRcdFx0ZDogZ3JpZExpbmVQYXRoLFxuXHRcdFx0XHRcdFx0b3BhY2l0eTogb3BhY2l0eVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSB0aGUgdGljayBtYXJrXG5cdFx0XHRpZiAodGlja1dpZHRoICYmIHRpY2tMZW5ndGgpIHtcblxuXHRcdFx0XHQvLyBuZWdhdGUgdGhlIGxlbmd0aFxuXHRcdFx0XHRpZiAodGlja1Bvc2l0aW9uID09PSAnaW5zaWRlJykge1xuXHRcdFx0XHRcdHRpY2tMZW5ndGggPSAtdGlja0xlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYXhpcy5vcHBvc2l0ZSkge1xuXHRcdFx0XHRcdHRpY2tMZW5ndGggPSAtdGlja0xlbmd0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hcmtQYXRoID0gdGljay5nZXRNYXJrUGF0aCh4LCB5LCB0aWNrTGVuZ3RoLCB0aWNrV2lkdGggKiByZXZlcnNlQ3Jpc3AsIGhvcml6LCByZW5kZXJlcik7XG5cdFx0XHRcdGlmIChtYXJrKSB7IC8vIHVwZGF0aW5nXG5cdFx0XHRcdFx0bWFyay5hbmltYXRlKHtcblx0XHRcdFx0XHRcdGQ6IG1hcmtQYXRoLFxuXHRcdFx0XHRcdFx0b3BhY2l0eTogb3BhY2l0eVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBmaXJzdCB0aW1lXG5cdFx0XHRcdFx0dGljay5tYXJrID0gcmVuZGVyZXIucGF0aChcblx0XHRcdFx0XHRcdG1hcmtQYXRoXG5cdFx0XHRcdFx0KS5hdHRyKHtcblx0XHRcdFx0XHRcdHN0cm9rZTogdGlja0NvbG9yLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IHRpY2tXaWR0aCxcblx0XHRcdFx0XHRcdG9wYWNpdHk6IG9wYWNpdHlcblx0XHRcdFx0XHR9KS5hZGQoYXhpcy5heGlzR3JvdXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRoZSBsYWJlbCBpcyBjcmVhdGVkIG9uIGluaXQgLSBub3cgbW92ZSBpdCBpbnRvIHBsYWNlXG5cdFx0XHRpZiAobGFiZWwgJiYgIWlzTmFOKHgpKSB7XG5cdFx0XHRcdGxhYmVsLnh5ID0geHkgPSB0aWNrLmdldExhYmVsUG9zaXRpb24oeCwgeSwgbGFiZWwsIGhvcml6LCBsYWJlbE9wdGlvbnMsIHRpY2ttYXJrT2Zmc2V0LCBpbmRleCwgc3RlcCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgc2hvdyBmaXJzdCBhbmQgc2hvdyBsYXN0LiBJZiB0aGUgdGljayBpcyBib3RoIGZpcnN0IGFuZCBsYXN0LCBpdCBpc1xuXHRcdFx0XHQvLyBhIHNpbmdsZSBjZW50ZXJlZCB0aWNrLCBpbiB3aGljaCBjYXNlIHdlIHNob3cgdGhlIGxhYmVsIGFueXdheSAoIzIxMDApLlxuXHRcdFx0XHRpZiAoKHRpY2suaXNGaXJzdCAmJiAhdGljay5pc0xhc3QgJiYgIXBpY2sob3B0aW9ucy5zaG93Rmlyc3RMYWJlbCwgMSkpIHx8XG5cdFx0XHRcdFx0XHQodGljay5pc0xhc3QgJiYgIXRpY2suaXNGaXJzdCAmJiAhcGljayhvcHRpb25zLnNob3dMYXN0TGFiZWwsIDEpKSkge1xuXHRcdFx0XHRcdHNob3cgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbGFiZWwgb3ZlcmZsb3cgYW5kIHNob3cgb3IgaGlkZSBhY2NvcmRpbmdseVxuXHRcdFx0XHR9IGVsc2UgaWYgKGhvcml6ICYmICFheGlzLmlzUmFkaWFsICYmICFsYWJlbE9wdGlvbnMuc3RlcCAmJiAhbGFiZWxPcHRpb25zLnJvdGF0aW9uICYmICFvbGQgJiYgb3BhY2l0eSAhPT0gMCkge1xuXHRcdFx0XHRcdHRpY2suaGFuZGxlT3ZlcmZsb3coeHkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYXBwbHkgc3RlcFxuXHRcdFx0XHRpZiAoc3RlcCAmJiBpbmRleCAlIHN0ZXApIHtcblx0XHRcdFx0XHQvLyBzaG93IHRob3NlIGluZGljZXMgZGl2aWRhYmxlIGJ5IHN0ZXBcblx0XHRcdFx0XHRzaG93ID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIG5ldyBwb3NpdGlvbiwgYW5kIHNob3cgb3IgaGlkZVxuXHRcdFx0XHRpZiAoc2hvdyAmJiAhaXNOYU4oeHkueSkpIHtcblx0XHRcdFx0XHR4eS5vcGFjaXR5ID0gb3BhY2l0eTtcblx0XHRcdFx0XHRsYWJlbFt0aWNrLmlzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXSh4eSk7XG5cdFx0XHRcdFx0dGljay5pc05ldyA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIoJ3knLCAtOTk5OSk7IC8vICMxMzM4XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJ1Y3RvciBmb3IgdGhlIHRpY2sgcHJvdG90eXBlXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXModGhpcywgdGhpcy5heGlzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBvYmplY3Qgd3JhcHBlciBmb3IgcGxvdCBsaW5lcyBhbmQgcGxvdCBiYW5kc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0SGlnaGNoYXJ0cy5QbG90TGluZU9yQmFuZCA9IGZ1bmN0aW9uIChheGlzLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5heGlzID0gYXhpcztcblxuXHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0dGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG5cdFx0fVxuXHR9O1xuXG5cdEhpZ2hjaGFydHMuUGxvdExpbmVPckJhbmQucHJvdG90eXBlID0ge1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciB0aGUgcGxvdCBsaW5lIG9yIHBsb3QgYmFuZC4gSWYgaXQgaXMgYWxyZWFkeSBleGlzdGluZyxcblx0XHQgKiBtb3ZlIGl0LlxuXHRcdCAqL1xuXHRcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBsb3RMaW5lID0gdGhpcyxcblx0XHRcdFx0YXhpcyA9IHBsb3RMaW5lLmF4aXMsXG5cdFx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0b3B0aW9ucyA9IHBsb3RMaW5lLm9wdGlvbnMsXG5cdFx0XHRcdG9wdGlvbnNMYWJlbCA9IG9wdGlvbnMubGFiZWwsXG5cdFx0XHRcdGxhYmVsID0gcGxvdExpbmUubGFiZWwsXG5cdFx0XHRcdHdpZHRoID0gb3B0aW9ucy53aWR0aCxcblx0XHRcdFx0dG8gPSBvcHRpb25zLnRvLFxuXHRcdFx0XHRmcm9tID0gb3B0aW9ucy5mcm9tLFxuXHRcdFx0XHRpc0JhbmQgPSBkZWZpbmVkKGZyb20pICYmIGRlZmluZWQodG8pLFxuXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnMudmFsdWUsXG5cdFx0XHRcdGRhc2hTdHlsZSA9IG9wdGlvbnMuZGFzaFN0eWxlLFxuXHRcdFx0XHRzdmdFbGVtID0gcGxvdExpbmUuc3ZnRWxlbSxcblx0XHRcdFx0cGF0aCA9IFtdLFxuXHRcdFx0XHRhZGRFdmVudCxcblx0XHRcdFx0ZXZlbnRUeXBlLFxuXHRcdFx0XHR4cyxcblx0XHRcdFx0eXMsXG5cdFx0XHRcdHgsXG5cdFx0XHRcdHksXG5cdFx0XHRcdGNvbG9yID0gb3B0aW9ucy5jb2xvcixcblx0XHRcdFx0ekluZGV4ID0gb3B0aW9ucy56SW5kZXgsXG5cdFx0XHRcdGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzLFxuXHRcdFx0XHRhdHRyaWJzID0ge30sXG5cdFx0XHRcdHJlbmRlcmVyID0gYXhpcy5jaGFydC5yZW5kZXJlcjtcblxuXHRcdFx0Ly8gbG9nYXJpdGhtaWMgY29udmVyc2lvblxuXHRcdFx0aWYgKGF4aXMuaXNMb2cpIHtcblx0XHRcdFx0ZnJvbSA9IGxvZzJsaW4oZnJvbSk7XG5cdFx0XHRcdHRvID0gbG9nMmxpbih0byk7XG5cdFx0XHRcdHZhbHVlID0gbG9nMmxpbih2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBsb3QgbGluZVxuXHRcdFx0aWYgKHdpZHRoKSB7XG5cdFx0XHRcdHBhdGggPSBheGlzLmdldFBsb3RMaW5lUGF0aCh2YWx1ZSwgd2lkdGgpO1xuXHRcdFx0XHRhdHRyaWJzID0ge1xuXHRcdFx0XHRcdHN0cm9rZTogY29sb3IsXG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IHdpZHRoXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChkYXNoU3R5bGUpIHtcblx0XHRcdFx0XHRhdHRyaWJzLmRhc2hzdHlsZSA9IGRhc2hTdHlsZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChpc0JhbmQpIHsgLy8gcGxvdCBiYW5kXG5cblx0XHRcdFx0cGF0aCA9IGF4aXMuZ2V0UGxvdEJhbmRQYXRoKGZyb20sIHRvLCBvcHRpb25zKTtcblx0XHRcdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRcdFx0YXR0cmlicy5maWxsID0gY29sb3I7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcblx0XHRcdFx0XHRhdHRyaWJzLnN0cm9rZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cdFx0XHRcdFx0YXR0cmlic1snc3Ryb2tlLXdpZHRoJ10gPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyB6SW5kZXhcblx0XHRcdGlmIChkZWZpbmVkKHpJbmRleCkpIHtcblx0XHRcdFx0YXR0cmlicy56SW5kZXggPSB6SW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbW1vbiBmb3IgbGluZXMgYW5kIGJhbmRzXG5cdFx0XHRpZiAoc3ZnRWxlbSkge1xuXHRcdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRcdHN2Z0VsZW0uYW5pbWF0ZSh7XG5cdFx0XHRcdFx0XHRkOiBwYXRoXG5cdFx0XHRcdFx0fSwgbnVsbCwgc3ZnRWxlbS5vbkdldFBhdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN2Z0VsZW0uaGlkZSgpO1xuXHRcdFx0XHRcdHN2Z0VsZW0ub25HZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0c3ZnRWxlbS5zaG93KCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRcdHBsb3RMaW5lLmxhYmVsID0gbGFiZWwgPSBsYWJlbC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHBhdGggJiYgcGF0aC5sZW5ndGgpIHtcblx0XHRcdFx0cGxvdExpbmUuc3ZnRWxlbSA9IHN2Z0VsZW0gPSByZW5kZXJlci5wYXRoKHBhdGgpXG5cdFx0XHRcdFx0LmF0dHIoYXR0cmlicykuYWRkKCk7XG5cblx0XHRcdFx0Ly8gZXZlbnRzXG5cdFx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0XHRhZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcblx0XHRcdFx0XHRcdHN2Z0VsZW0ub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRldmVudHNbZXZlbnRUeXBlXS5hcHBseShwbG90TGluZSwgW2VdKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Zm9yIChldmVudFR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdFx0XHRhZGRFdmVudChldmVudFR5cGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0aGUgcGxvdCBiYW5kL2xpbmUgbGFiZWxcblx0XHRcdGlmIChvcHRpb25zTGFiZWwgJiYgZGVmaW5lZChvcHRpb25zTGFiZWwudGV4dCkgJiYgcGF0aCAmJiBwYXRoLmxlbmd0aCAmJiBheGlzLndpZHRoID4gMCAmJiBheGlzLmhlaWdodCA+IDApIHtcblx0XHRcdFx0Ly8gYXBwbHkgZGVmYXVsdHNcblx0XHRcdFx0b3B0aW9uc0xhYmVsID0gbWVyZ2Uoe1xuXHRcdFx0XHRcdGFsaWduOiBob3JpeiAmJiBpc0JhbmQgJiYgJ2NlbnRlcicsXG5cdFx0XHRcdFx0eDogaG9yaXogPyAhaXNCYW5kICYmIDQgOiAxMCxcblx0XHRcdFx0XHR2ZXJ0aWNhbEFsaWduIDogIWhvcml6ICYmIGlzQmFuZCAmJiAnbWlkZGxlJyxcblx0XHRcdFx0XHR5OiBob3JpeiA/IGlzQmFuZCA/IDE2IDogMTAgOiBpc0JhbmQgPyA2IDogLTQsXG5cdFx0XHRcdFx0cm90YXRpb246IGhvcml6ICYmICFpc0JhbmQgJiYgOTBcblx0XHRcdFx0fSwgb3B0aW9uc0xhYmVsKTtcblxuXHRcdFx0XHQvLyBhZGQgdGhlIFNWRyBlbGVtZW50XG5cdFx0XHRcdGlmICghbGFiZWwpIHtcblx0XHRcdFx0XHRhdHRyaWJzID0ge1xuXHRcdFx0XHRcdFx0YWxpZ246IG9wdGlvbnNMYWJlbC50ZXh0QWxpZ24gfHwgb3B0aW9uc0xhYmVsLmFsaWduLFxuXHRcdFx0XHRcdFx0cm90YXRpb246IG9wdGlvbnNMYWJlbC5yb3RhdGlvblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKGRlZmluZWQoekluZGV4KSkge1xuXHRcdFx0XHRcdFx0YXR0cmlicy56SW5kZXggPSB6SW5kZXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBsb3RMaW5lLmxhYmVsID0gbGFiZWwgPSByZW5kZXJlci50ZXh0KFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zTGFiZWwudGV4dCxcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0b3B0aW9uc0xhYmVsLnVzZUhUTUxcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hdHRyKGF0dHJpYnMpXG5cdFx0XHRcdFx0XHQuY3NzKG9wdGlvbnNMYWJlbC5zdHlsZSlcblx0XHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGdldCB0aGUgYm91bmRpbmcgYm94IGFuZCBhbGlnbiB0aGUgbGFiZWxcblx0XHRcdFx0Ly8gIzMwMDAgY2hhbmdlZCB0byBiZXR0ZXIgaGFuZGxlIGNob2ljZSBiZXR3ZWVuIHBsb3RiYW5kIG9yIHBsb3RsaW5lXG5cdFx0XHRcdHhzID0gW3BhdGhbMV0sIHBhdGhbNF0sIChpc0JhbmQgPyBwYXRoWzZdIDogcGF0aFsxXSldO1xuXHRcdFx0XHR5cyA9IFtwYXRoWzJdLCBwYXRoWzVdLCAoaXNCYW5kID8gcGF0aFs3XSA6IHBhdGhbMl0pXTtcblx0XHRcdFx0eCA9IGFycmF5TWluKHhzKTtcblx0XHRcdFx0eSA9IGFycmF5TWluKHlzKTtcblxuXHRcdFx0XHRsYWJlbC5hbGlnbihvcHRpb25zTGFiZWwsIGZhbHNlLCB7XG5cdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdHdpZHRoOiBhcnJheU1heCh4cykgLSB4LFxuXHRcdFx0XHRcdGhlaWdodDogYXJyYXlNYXgoeXMpIC0geVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0bGFiZWwuc2hvdygpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKGxhYmVsKSB7IC8vIG1vdmUgb3V0IG9mIHNpZ2h0XG5cdFx0XHRcdGxhYmVsLmhpZGUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hhaW5hYmxlXG5cdFx0XHRyZXR1cm4gcGxvdExpbmU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSB0aGUgcGxvdCBsaW5lIG9yIGJhbmRcblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyByZW1vdmUgaXQgZnJvbSB0aGUgbG9va3VwXG5cdFx0XHRlcmFzZSh0aGlzLmF4aXMucGxvdExpbmVzQW5kQmFuZHMsIHRoaXMpO1xuXHRcdFx0XG5cdFx0XHRkZWxldGUgdGhpcy5heGlzO1xuXHRcdFx0ZGVzdHJveU9iamVjdFByb3BlcnRpZXModGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBPYmplY3Qgd2l0aCBtZW1iZXJzIGZvciBleHRlbmRpbmcgdGhlIEF4aXMgcHJvdG90eXBlXG5cdCAqL1xuXG5cdEF4aXNQbG90TGluZU9yQmFuZEV4dGVuc2lvbiA9IHtcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSB0aGUgcGF0aCBmb3IgYSBwbG90IGJhbmRcblx0XHQgKi8gXG5cdFx0Z2V0UGxvdEJhbmRQYXRoOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcblx0XHRcdHZhciB0b1BhdGggPSB0aGlzLmdldFBsb3RMaW5lUGF0aCh0bywgbnVsbCwgbnVsbCwgdHJ1ZSksXG5cdFx0XHRcdHBhdGggPSB0aGlzLmdldFBsb3RMaW5lUGF0aChmcm9tLCBudWxsLCBudWxsLCB0cnVlKTtcblxuXHRcdFx0aWYgKHBhdGggJiYgdG9QYXRoICYmIHBhdGgudG9TdHJpbmcoKSAhPT0gdG9QYXRoLnRvU3RyaW5nKCkpIHsgLy8gIzM4MzZcblx0XHRcdFx0cGF0aC5wdXNoKFxuXHRcdFx0XHRcdHRvUGF0aFs0XSxcblx0XHRcdFx0XHR0b1BhdGhbNV0sXG5cdFx0XHRcdFx0dG9QYXRoWzFdLFxuXHRcdFx0XHRcdHRvUGF0aFsyXVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHsgLy8gb3V0c2lkZSB0aGUgYXhpcyBhcmVhXG5cdFx0XHRcdHBhdGggPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9LFxuXG5cdFx0YWRkUGxvdEJhbmQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShvcHRpb25zLCAncGxvdEJhbmRzJyk7XG5cdFx0fSxcblx0XHRcblx0XHRhZGRQbG90TGluZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZFBsb3RCYW5kT3JMaW5lKG9wdGlvbnMsICdwbG90TGluZXMnKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgcGxvdCBiYW5kIG9yIHBsb3QgbGluZSBhZnRlciByZW5kZXIgdGltZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gVGhlIHBsb3RCYW5kIG9yIHBsb3RMaW5lIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdFx0ICovXG5cdFx0YWRkUGxvdEJhbmRPckxpbmU6IGZ1bmN0aW9uIChvcHRpb25zLCBjb2xsKSB7XG5cdFx0XHR2YXIgb2JqID0gbmV3IEhpZ2hjaGFydHMuUGxvdExpbmVPckJhbmQodGhpcywgb3B0aW9ucykucmVuZGVyKCksXG5cdFx0XHRcdHVzZXJPcHRpb25zID0gdGhpcy51c2VyT3B0aW9ucztcblxuXHRcdFx0aWYgKG9iaikgeyAvLyAjMjE4OVxuXHRcdFx0XHQvLyBBZGQgaXQgdG8gdGhlIHVzZXIgb3B0aW9ucyBmb3IgZXhwb3J0aW5nIGFuZCBBeGlzLnVwZGF0ZVxuXHRcdFx0XHRpZiAoY29sbCkge1xuXHRcdFx0XHRcdHVzZXJPcHRpb25zW2NvbGxdID0gdXNlck9wdGlvbnNbY29sbF0gfHwgW107XG5cdFx0XHRcdFx0dXNlck9wdGlvbnNbY29sbF0ucHVzaChvcHRpb25zKTsgXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wbG90TGluZXNBbmRCYW5kcy5wdXNoKG9iaik7IFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgYSBwbG90IGJhbmQgb3IgcGxvdCBsaW5lIGZyb20gdGhlIGNoYXJ0IGJ5IGlkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGlkXG5cdFx0ICovXG5cdFx0cmVtb3ZlUGxvdEJhbmRPckxpbmU6IGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0dmFyIHBsb3RMaW5lc0FuZEJhbmRzID0gdGhpcy5wbG90TGluZXNBbmRCYW5kcyxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dXNlck9wdGlvbnMgPSB0aGlzLnVzZXJPcHRpb25zLFxuXHRcdFx0XHRpID0gcGxvdExpbmVzQW5kQmFuZHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRpZiAocGxvdExpbmVzQW5kQmFuZHNbaV0uaWQgPT09IGlkKSB7XG5cdFx0XHRcdFx0cGxvdExpbmVzQW5kQmFuZHNbaV0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlYWNoKFtvcHRpb25zLnBsb3RMaW5lcyB8fCBbXSwgdXNlck9wdGlvbnMucGxvdExpbmVzIHx8IFtdLCBvcHRpb25zLnBsb3RCYW5kcyB8fCBbXSwgdXNlck9wdGlvbnMucGxvdEJhbmRzIHx8IFtdXSwgZnVuY3Rpb24gKGFycikge1xuXHRcdFx0XHRpID0gYXJyLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGlmIChhcnJbaV0uaWQgPT09IGlkKSB7XG5cdFx0XHRcdFx0XHRlcmFzZShhcnIsIGFycltpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBheGlzIG9iamVjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICovXG5cdHZhciBBeGlzID0gSGlnaGNoYXJ0cy5BeGlzID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdEF4aXMucHJvdG90eXBlID0ge1xuXG5cdFx0LyoqXG5cdFx0ICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgWCBheGlzIC0gdGhlIFkgYXhpcyBoYXMgZXh0ZW5kZWQgZGVmYXVsdHNcblx0XHQgKi9cblx0XHRkZWZhdWx0T3B0aW9uczoge1xuXHRcdFx0Ly8gYWxsb3dEZWNpbWFsczogbnVsbCxcblx0XHRcdC8vIGFsdGVybmF0ZUdyaWRDb2xvcjogbnVsbCxcblx0XHRcdC8vIGNhdGVnb3JpZXM6IFtdLFxuXHRcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdHM6IHtcblx0XHRcdFx0bWlsbGlzZWNvbmQ6ICclSDolTTolUy4lTCcsXG5cdFx0XHRcdHNlY29uZDogJyVIOiVNOiVTJyxcblx0XHRcdFx0bWludXRlOiAnJUg6JU0nLFxuXHRcdFx0XHRob3VyOiAnJUg6JU0nLFxuXHRcdFx0XHRkYXk6ICclZS4gJWInLFxuXHRcdFx0XHR3ZWVrOiAnJWUuICViJyxcblx0XHRcdFx0bW9udGg6ICclYiBcXCcleScsXG5cdFx0XHRcdHllYXI6ICclWSdcblx0XHRcdH0sXG5cdFx0XHRlbmRPblRpY2s6IGZhbHNlLFxuXHRcdFx0Z3JpZExpbmVDb2xvcjogJyNEOEQ4RDgnLFxuXHRcdFx0Ly8gZ3JpZExpbmVEYXNoU3R5bGU6ICdzb2xpZCcsXG5cdFx0XHQvLyBncmlkTGluZVdpZHRoOiAwLFxuXHRcdFx0Ly8gcmV2ZXJzZWQ6IGZhbHNlLFxuXG5cdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0Ly8gcm90YXRpb246IDAsXG5cdFx0XHRcdC8vIGFsaWduOiAnY2VudGVyJyxcblx0XHRcdFx0Ly8gc3RlcDogbnVsbCxcblx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRjb2xvcjogJyM2MDYwNjAnLFxuXHRcdFx0XHRcdGN1cnNvcjogJ2RlZmF1bHQnLFxuXHRcdFx0XHRcdGZvbnRTaXplOiAnMTFweCdcblx0XHRcdFx0fSxcblx0XHRcdFx0eDogMCxcblx0XHRcdFx0eTogMTVcblx0XHRcdFx0Lypmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdFx0fSwqL1xuXHRcdFx0fSxcblx0XHRcdGxpbmVDb2xvcjogJyNDMEQwRTAnLFxuXHRcdFx0bGluZVdpZHRoOiAxLFxuXHRcdFx0Ly9saW5rZWRUbzogbnVsbCxcblx0XHRcdC8vbWF4OiB1bmRlZmluZWQsXG5cdFx0XHQvL21pbjogdW5kZWZpbmVkLFxuXHRcdFx0bWluUGFkZGluZzogMC4wMSxcblx0XHRcdG1heFBhZGRpbmc6IDAuMDEsXG5cdFx0XHQvL21pblJhbmdlOiBudWxsLFxuXHRcdFx0bWlub3JHcmlkTGluZUNvbG9yOiAnI0UwRTBFMCcsXG5cdFx0XHQvLyBtaW5vckdyaWRMaW5lRGFzaFN0eWxlOiBudWxsLFxuXHRcdFx0bWlub3JHcmlkTGluZVdpZHRoOiAxLFxuXHRcdFx0bWlub3JUaWNrQ29sb3I6ICcjQTBBMEEwJyxcblx0XHRcdC8vbWlub3JUaWNrSW50ZXJ2YWw6IG51bGwsXG5cdFx0XHRtaW5vclRpY2tMZW5ndGg6IDIsXG5cdFx0XHRtaW5vclRpY2tQb3NpdGlvbjogJ291dHNpZGUnLCAvLyBpbnNpZGUgb3Igb3V0c2lkZVxuXHRcdFx0Ly9taW5vclRpY2tXaWR0aDogMCxcblx0XHRcdC8vb3Bwb3NpdGU6IGZhbHNlLFxuXHRcdFx0Ly9vZmZzZXQ6IDAsXG5cdFx0XHQvL3Bsb3RCYW5kczogW3tcblx0XHRcdC8vXHRldmVudHM6IHt9LFxuXHRcdFx0Ly9cdHpJbmRleDogMSxcblx0XHRcdC8vXHRsYWJlbHM6IHsgYWxpZ24sIHgsIHZlcnRpY2FsQWxpZ24sIHksIHN0eWxlLCByb3RhdGlvbiwgdGV4dEFsaWduIH1cblx0XHRcdC8vfV0sXG5cdFx0XHQvL3Bsb3RMaW5lczogW3tcblx0XHRcdC8vXHRldmVudHM6IHt9XG5cdFx0XHQvLyAgZGFzaFN0eWxlOiB7fVxuXHRcdFx0Ly9cdHpJbmRleDpcblx0XHRcdC8vXHRsYWJlbHM6IHsgYWxpZ24sIHgsIHZlcnRpY2FsQWxpZ24sIHksIHN0eWxlLCByb3RhdGlvbiwgdGV4dEFsaWduIH1cblx0XHRcdC8vfV0sXG5cdFx0XHQvL3JldmVyc2VkOiBmYWxzZSxcblx0XHRcdC8vIHNob3dGaXJzdExhYmVsOiB0cnVlLFxuXHRcdFx0Ly8gc2hvd0xhc3RMYWJlbDogdHJ1ZSxcblx0XHRcdHN0YXJ0T2ZXZWVrOiAxLFxuXHRcdFx0c3RhcnRPblRpY2s6IGZhbHNlLFxuXHRcdFx0dGlja0NvbG9yOiAnI0MwRDBFMCcsXG5cdFx0XHQvL3RpY2tJbnRlcnZhbDogbnVsbCxcblx0XHRcdHRpY2tMZW5ndGg6IDEwLFxuXHRcdFx0dGlja21hcmtQbGFjZW1lbnQ6ICdiZXR3ZWVuJywgLy8gb24gb3IgYmV0d2VlblxuXHRcdFx0dGlja1BpeGVsSW50ZXJ2YWw6IDEwMCxcblx0XHRcdHRpY2tQb3NpdGlvbjogJ291dHNpZGUnLFxuXHRcdFx0dGlja1dpZHRoOiAxLFxuXHRcdFx0dGl0bGU6IHtcblx0XHRcdFx0Ly90ZXh0OiBudWxsLFxuXHRcdFx0XHRhbGlnbjogJ21pZGRsZScsIC8vIGxvdywgbWlkZGxlIG9yIGhpZ2hcblx0XHRcdFx0Ly9tYXJnaW46IDAgZm9yIGhvcml6b250YWwsIDEwIGZvciB2ZXJ0aWNhbCBheGVzLFxuXHRcdFx0XHQvL3JvdGF0aW9uOiAwLFxuXHRcdFx0XHQvL3NpZGU6ICdvdXRzaWRlJyxcblx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRjb2xvcjogJyM3MDcwNzAnXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly94OiAwLFxuXHRcdFx0XHQvL3k6IDBcblx0XHRcdH0sXG5cdFx0XHR0eXBlOiAnbGluZWFyJyAvLyBsaW5lYXIsIGxvZ2FyaXRobWljIG9yIGRhdGV0aW1lXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgb3B0aW9ucyBzZXQgZXh0ZW5kcyB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIFkgYXhlc1xuXHRcdCAqL1xuXHRcdGRlZmF1bHRZQXhpc09wdGlvbnM6IHtcblx0XHRcdGVuZE9uVGljazogdHJ1ZSxcblx0XHRcdGdyaWRMaW5lV2lkdGg6IDEsXG5cdFx0XHR0aWNrUGl4ZWxJbnRlcnZhbDogNzIsXG5cdFx0XHRzaG93TGFzdExhYmVsOiB0cnVlLFxuXHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdHg6IC04LFxuXHRcdFx0XHR5OiAzXG5cdFx0XHR9LFxuXHRcdFx0bGluZVdpZHRoOiAwLFxuXHRcdFx0bWF4UGFkZGluZzogMC4wNSxcblx0XHRcdG1pblBhZGRpbmc6IDAuMDUsXG5cdFx0XHRzdGFydE9uVGljazogdHJ1ZSxcblx0XHRcdHRpY2tXaWR0aDogMCxcblx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdHJvdGF0aW9uOiAyNzAsXG5cdFx0XHRcdHRleHQ6ICdWYWx1ZXMnXG5cdFx0XHR9LFxuXHRcdFx0c3RhY2tMYWJlbHM6IHtcblx0XHRcdFx0ZW5hYmxlZDogZmFsc2UsXG5cdFx0XHRcdC8vYWxpZ246IGR5bmFtaWMsXG5cdFx0XHRcdC8veTogZHluYW1pYyxcblx0XHRcdFx0Ly94OiBkeW5hbWljLFxuXHRcdFx0XHQvL3ZlcnRpY2FsQWxpZ246IGR5bmFtaWMsXG5cdFx0XHRcdC8vdGV4dEFsaWduOiBkeW5hbWljLFxuXHRcdFx0XHQvL3JvdGF0aW9uOiAwLFxuXHRcdFx0XHRmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gSGlnaGNoYXJ0cy5udW1iZXJGb3JtYXQodGhpcy50b3RhbCwgLTEpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzdHlsZTogbWVyZ2UoZGVmYXVsdFBsb3RPcHRpb25zLmxpbmUuZGF0YUxhYmVscy5zdHlsZSwgeyBjb2xvcjogJyMwMDAwMDAnIH0pXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZXNlIG9wdGlvbnMgZXh0ZW5kIHRoZSBkZWZhdWx0T3B0aW9ucyBmb3IgbGVmdCBheGVzXG5cdFx0ICovXG5cdFx0ZGVmYXVsdExlZnRBeGlzT3B0aW9uczoge1xuXHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdHg6IC0xNSxcblx0XHRcdFx0eTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdHJvdGF0aW9uOiAyNzBcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlc2Ugb3B0aW9ucyBleHRlbmQgdGhlIGRlZmF1bHRPcHRpb25zIGZvciByaWdodCBheGVzXG5cdFx0ICovXG5cdFx0ZGVmYXVsdFJpZ2h0QXhpc09wdGlvbnM6IHtcblx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHR4OiAxNSxcblx0XHRcdFx0eTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdHJvdGF0aW9uOiA5MFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGVzZSBvcHRpb25zIGV4dGVuZCB0aGUgZGVmYXVsdE9wdGlvbnMgZm9yIGJvdHRvbSBheGVzXG5cdFx0ICovXG5cdFx0ZGVmYXVsdEJvdHRvbUF4aXNPcHRpb25zOiB7XG5cdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0YXV0b1JvdGF0aW9uOiBbLTQ1XSxcblx0XHRcdFx0eDogMCxcblx0XHRcdFx0eTogbnVsbCAvLyBiYXNlZCBvbiBmb250IHNpemVcblx0XHRcdFx0Ly8gb3ZlcmZsb3c6IHVuZGVmaW5lZCxcblx0XHRcdFx0Ly8gc3RhZ2dlckxpbmVzOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0dGl0bGU6IHtcblx0XHRcdFx0cm90YXRpb246IDBcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFRoZXNlIG9wdGlvbnMgZXh0ZW5kIHRoZSBkZWZhdWx0T3B0aW9ucyBmb3IgdG9wIGF4ZXNcblx0XHQgKi9cblx0XHRkZWZhdWx0VG9wQXhpc09wdGlvbnM6IHtcblx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRhdXRvUm90YXRpb246IFstNDVdLFxuXHRcdFx0XHR4OiAwLFxuXHRcdFx0XHR5OiAtMTVcblx0XHRcdFx0Ly8gb3ZlcmZsb3c6IHVuZGVmaW5lZFxuXHRcdFx0XHQvLyBzdGFnZ2VyTGluZXM6IG51bGxcblx0XHRcdH0sXG5cdFx0XHR0aXRsZToge1xuXHRcdFx0XHRyb3RhdGlvbjogMFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBheGlzXG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKGNoYXJ0LCB1c2VyT3B0aW9ucykge1xuXG5cblx0XHRcdHZhciBpc1hBeGlzID0gdXNlck9wdGlvbnMuaXNYLFxuXHRcdFx0XHRheGlzID0gdGhpcztcblxuXHRcdFx0Ly8gRmxhZywgaXMgdGhlIGF4aXMgaG9yaXpvbnRhbFxuXHRcdFx0YXhpcy5ob3JpeiA9IGNoYXJ0LmludmVydGVkID8gIWlzWEF4aXMgOiBpc1hBeGlzO1xuXG5cdFx0XHQvLyBGbGFnLCBpc1hBeGlzXG5cdFx0XHRheGlzLmlzWEF4aXMgPSBpc1hBeGlzO1xuXHRcdFx0YXhpcy5jb2xsID0gaXNYQXhpcyA/ICd4QXhpcycgOiAneUF4aXMnO1xuXG5cdFx0XHRheGlzLm9wcG9zaXRlID0gdXNlck9wdGlvbnMub3Bwb3NpdGU7IC8vIG5lZWRlZCBpbiBzZXRPcHRpb25zXG5cdFx0XHRheGlzLnNpZGUgPSB1c2VyT3B0aW9ucy5zaWRlIHx8IChheGlzLmhvcml6ID9cblx0XHRcdFx0XHQoYXhpcy5vcHBvc2l0ZSA/IDAgOiAyKSA6IC8vIHRvcCA6IGJvdHRvbVxuXHRcdFx0XHRcdChheGlzLm9wcG9zaXRlID8gMSA6IDMpKTsgIC8vIHJpZ2h0IDogbGVmdFxuXG5cdFx0XHRheGlzLnNldE9wdGlvbnModXNlck9wdGlvbnMpO1xuXG5cblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR0eXBlID0gb3B0aW9ucy50eXBlLFxuXHRcdFx0XHRpc0RhdGV0aW1lQXhpcyA9IHR5cGUgPT09ICdkYXRldGltZSc7XG5cblx0XHRcdGF4aXMubGFiZWxGb3JtYXR0ZXIgPSBvcHRpb25zLmxhYmVscy5mb3JtYXR0ZXIgfHwgYXhpcy5kZWZhdWx0TGFiZWxGb3JtYXR0ZXI7IC8vIGNhbiBiZSBvdmVyd3JpdHRlbiBieSBkeW5hbWljIGZvcm1hdFxuXG5cblx0XHRcdC8vIEZsYWcsIHN0YWdnZXIgbGluZXMgb3Igbm90XG5cdFx0XHRheGlzLnVzZXJPcHRpb25zID0gdXNlck9wdGlvbnM7XG5cblx0XHRcdC8vYXhpcy5heGlzVGl0bGVNYXJnaW4gPSBVTkRFRklORUQsLy8gPSBvcHRpb25zLnRpdGxlLm1hcmdpbixcblx0XHRcdGF4aXMubWluUGl4ZWxQYWRkaW5nID0gMDtcblx0XHRcdC8vYXhpcy5pZ25vcmVNaW5QYWRkaW5nID0gVU5ERUZJTkVEOyAvLyBjYW4gYmUgc2V0IHRvIHRydWUgYnkgYSBjb2x1bW4gb3IgYmFyIHNlcmllc1xuXHRcdFx0Ly9heGlzLmlnbm9yZU1heFBhZGRpbmcgPSBVTkRFRklORUQ7XG5cblx0XHRcdGF4aXMuY2hhcnQgPSBjaGFydDtcblx0XHRcdGF4aXMucmV2ZXJzZWQgPSBvcHRpb25zLnJldmVyc2VkO1xuXHRcdFx0YXhpcy56b29tRW5hYmxlZCA9IG9wdGlvbnMuem9vbUVuYWJsZWQgIT09IGZhbHNlO1xuXG5cdFx0XHQvLyBJbml0aWFsIGNhdGVnb3JpZXNcblx0XHRcdGF4aXMuY2F0ZWdvcmllcyA9IG9wdGlvbnMuY2F0ZWdvcmllcyB8fCB0eXBlID09PSAnY2F0ZWdvcnknO1xuXHRcdFx0YXhpcy5uYW1lcyA9IGF4aXMubmFtZXMgfHwgW107IC8vIFByZXNlcnZlIG9uIHVwZGF0ZSAoIzM4MzApXG5cblx0XHRcdC8vIEVsZW1lbnRzXG5cdFx0XHQvL2F4aXMuYXhpc0dyb3VwID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLmdyaWRHcm91cCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5heGlzVGl0bGUgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMuYXhpc0xpbmUgPSBVTkRFRklORUQ7XG5cblx0XHRcdC8vIFNob3J0aGFuZCB0eXBlc1xuXHRcdFx0YXhpcy5pc0xvZyA9IHR5cGUgPT09ICdsb2dhcml0aG1pYyc7XG5cdFx0XHRheGlzLmlzRGF0ZXRpbWVBeGlzID0gaXNEYXRldGltZUF4aXM7XG5cblx0XHRcdC8vIEZsYWcsIGlmIGF4aXMgaXMgbGlua2VkIHRvIGFub3RoZXIgYXhpc1xuXHRcdFx0YXhpcy5pc0xpbmtlZCA9IGRlZmluZWQob3B0aW9ucy5saW5rZWRUbyk7XG5cdFx0XHQvLyBMaW5rZWQgYXhpcy5cblx0XHRcdC8vYXhpcy5saW5rZWRQYXJlbnQgPSBVTkRFRklORUQ7XG5cblx0XHRcdC8vIFRpY2sgcG9zaXRpb25zXG5cdFx0XHQvL2F4aXMudGlja1Bvc2l0aW9ucyA9IFVOREVGSU5FRDsgLy8gYXJyYXkgY29udGFpbmluZyBwcmVkZWZpbmVkIHBvc2l0aW9uc1xuXHRcdFx0Ly8gVGljayBpbnRlcnZhbHNcblx0XHRcdC8vYXhpcy50aWNrSW50ZXJ2YWwgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMubWlub3JUaWNrSW50ZXJ2YWwgPSBVTkRFRklORUQ7XG5cblx0XHRcdFxuXHRcdFx0Ly8gTWFqb3IgdGlja3Ncblx0XHRcdGF4aXMudGlja3MgPSB7fTtcblx0XHRcdGF4aXMubGFiZWxFZGdlID0gW107XG5cdFx0XHQvLyBNaW5vciB0aWNrc1xuXHRcdFx0YXhpcy5taW5vclRpY2tzID0ge307XG5cblx0XHRcdC8vIExpc3Qgb2YgcGxvdExpbmVzL0JhbmRzXG5cdFx0XHRheGlzLnBsb3RMaW5lc0FuZEJhbmRzID0gW107XG5cblx0XHRcdC8vIEFsdGVybmF0ZSBiYW5kc1xuXHRcdFx0YXhpcy5hbHRlcm5hdGVCYW5kcyA9IHt9O1xuXG5cdFx0XHQvLyBBeGlzIG1ldHJpY3Ncblx0XHRcdC8vYXhpcy5sZWZ0ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLnRvcCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy53aWR0aCA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5oZWlnaHQgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMuYm90dG9tID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLnJpZ2h0ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLnRyYW5zQSA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy50cmFuc0IgPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMub2xkVHJhbnNBID0gVU5ERUZJTkVEO1xuXHRcdFx0YXhpcy5sZW4gPSAwO1xuXHRcdFx0Ly9heGlzLm9sZE1pbiA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5vbGRNYXggPSBVTkRFRklORUQ7XG5cdFx0XHQvL2F4aXMub2xkVXNlck1pbiA9IFVOREVGSU5FRDtcblx0XHRcdC8vYXhpcy5vbGRVc2VyTWF4ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly9heGlzLm9sZEF4aXNMZW5ndGggPSBVTkRFRklORUQ7XG5cdFx0XHRheGlzLm1pblJhbmdlID0gYXhpcy51c2VyTWluUmFuZ2UgPSBvcHRpb25zLm1pblJhbmdlIHx8IG9wdGlvbnMubWF4Wm9vbTtcblx0XHRcdGF4aXMucmFuZ2UgPSBvcHRpb25zLnJhbmdlO1xuXHRcdFx0YXhpcy5vZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuXG5cblx0XHRcdC8vIERpY3Rpb25hcnkgZm9yIHN0YWNrc1xuXHRcdFx0YXhpcy5zdGFja3MgPSB7fTtcblx0XHRcdGF4aXMub2xkU3RhY2tzID0ge307XG5cdFx0XHRcblx0XHRcdC8vIE1pbiBhbmQgbWF4IGluIHRoZSBkYXRhXG5cdFx0XHQvL2F4aXMuZGF0YU1pbiA9IFVOREVGSU5FRCxcblx0XHRcdC8vYXhpcy5kYXRhTWF4ID0gVU5ERUZJTkVELFxuXG5cdFx0XHQvLyBUaGUgYXhpcyByYW5nZVxuXHRcdFx0YXhpcy5tYXggPSBudWxsO1xuXHRcdFx0YXhpcy5taW4gPSBudWxsO1xuXG5cdFx0XHQvLyBVc2VyIHNldCBtaW4gYW5kIG1heFxuXHRcdFx0Ly9heGlzLnVzZXJNaW4gPSBVTkRFRklORUQsXG5cdFx0XHQvL2F4aXMudXNlck1heCA9IFVOREVGSU5FRCxcblxuXHRcdFx0Ly8gQ3Jvc3NoYWlyIG9wdGlvbnNcblx0XHRcdGF4aXMuY3Jvc3NoYWlyID0gcGljayhvcHRpb25zLmNyb3NzaGFpciwgc3BsYXQoY2hhcnQub3B0aW9ucy50b29sdGlwLmNyb3NzaGFpcnMpW2lzWEF4aXMgPyAwIDogMV0sIGZhbHNlKTtcblx0XHRcdC8vIFJ1biBBeGlzXG5cblx0XHRcdHZhciBldmVudFR5cGUsXG5cdFx0XHRcdGV2ZW50cyA9IGF4aXMub3B0aW9ucy5ldmVudHM7XG5cblx0XHRcdC8vIFJlZ2lzdGVyXG5cdFx0XHRpZiAoaW5BcnJheShheGlzLCBjaGFydC5heGVzKSA9PT0gLTEpIHsgLy8gZG9uJ3QgYWRkIGl0IGFnYWluIG9uIEF4aXMudXBkYXRlKClcblx0XHRcdFx0aWYgKGlzWEF4aXMgJiYgIXRoaXMuaXNDb2xvckF4aXMpIHsgLy8gIzI3MTNcblx0XHRcdFx0XHRjaGFydC5heGVzLnNwbGljZShjaGFydC54QXhpcy5sZW5ndGgsIDAsIGF4aXMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoYXJ0LmF4ZXMucHVzaChheGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNoYXJ0W2F4aXMuY29sbF0ucHVzaChheGlzKTtcblx0XHRcdH1cblxuXHRcdFx0YXhpcy5zZXJpZXMgPSBheGlzLnNlcmllcyB8fCBbXTsgLy8gcG9wdWxhdGVkIGJ5IFNlcmllc1xuXG5cdFx0XHQvLyBpbnZlcnRlZCBjaGFydHMgaGF2ZSByZXZlcnNlZCB4QXhlcyBhcyBkZWZhdWx0XG5cdFx0XHRpZiAoY2hhcnQuaW52ZXJ0ZWQgJiYgaXNYQXhpcyAmJiBheGlzLnJldmVyc2VkID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0YXhpcy5yZXZlcnNlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGF4aXMucmVtb3ZlUGxvdEJhbmQgPSBheGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lO1xuXHRcdFx0YXhpcy5yZW1vdmVQbG90TGluZSA9IGF4aXMucmVtb3ZlUGxvdEJhbmRPckxpbmU7XG5cblxuXHRcdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG5cdFx0XHRmb3IgKGV2ZW50VHlwZSBpbiBldmVudHMpIHtcblx0XHRcdFx0YWRkRXZlbnQoYXhpcywgZXZlbnRUeXBlLCBldmVudHNbZXZlbnRUeXBlXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGV4dGVuZCBsb2dhcml0aG1pYyBheGlzXG5cdFx0XHRpZiAoYXhpcy5pc0xvZykge1xuXHRcdFx0XHRheGlzLnZhbDJsaW4gPSBsb2cybGluO1xuXHRcdFx0XHRheGlzLmxpbjJ2YWwgPSBsaW4ybG9nO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBNZXJnZSBhbmQgc2V0IG9wdGlvbnNcblx0XHQgKi9cblx0XHRzZXRPcHRpb25zOiBmdW5jdGlvbiAodXNlck9wdGlvbnMpIHtcblx0XHRcdHRoaXMub3B0aW9ucyA9IG1lcmdlKFxuXHRcdFx0XHR0aGlzLmRlZmF1bHRPcHRpb25zLFxuXHRcdFx0XHR0aGlzLmlzWEF4aXMgPyB7fSA6IHRoaXMuZGVmYXVsdFlBeGlzT3B0aW9ucyxcblx0XHRcdFx0W3RoaXMuZGVmYXVsdFRvcEF4aXNPcHRpb25zLCB0aGlzLmRlZmF1bHRSaWdodEF4aXNPcHRpb25zLFxuXHRcdFx0XHRcdHRoaXMuZGVmYXVsdEJvdHRvbUF4aXNPcHRpb25zLCB0aGlzLmRlZmF1bHRMZWZ0QXhpc09wdGlvbnNdW3RoaXMuc2lkZV0sXG5cdFx0XHRcdG1lcmdlKFxuXHRcdFx0XHRcdGRlZmF1bHRPcHRpb25zW3RoaXMuY29sbF0sIC8vIGlmIHNldCBpbiBzZXRPcHRpb25zICgjMTA1Mylcblx0XHRcdFx0XHR1c2VyT3B0aW9uc1xuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZGVmYXVsdCBsYWJlbCBmb3JtYXR0ZXIuIFRoZSBjb250ZXh0IGlzIGEgc3BlY2lhbCBjb25maWcgb2JqZWN0IGZvciB0aGUgbGFiZWwuXG5cdFx0ICovXG5cdFx0ZGVmYXVsdExhYmVsRm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMuYXhpcyxcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZhbHVlLFxuXHRcdFx0XHRjYXRlZ29yaWVzID0gYXhpcy5jYXRlZ29yaWVzLFxuXHRcdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0ID0gdGhpcy5kYXRlVGltZUxhYmVsRm9ybWF0LFxuXHRcdFx0XHRudW1lcmljU3ltYm9scyA9IGRlZmF1bHRPcHRpb25zLmxhbmcubnVtZXJpY1N5bWJvbHMsXG5cdFx0XHRcdGkgPSBudW1lcmljU3ltYm9scyAmJiBudW1lcmljU3ltYm9scy5sZW5ndGgsXG5cdFx0XHRcdG11bHRpLFxuXHRcdFx0XHRyZXQsXG5cdFx0XHRcdGZvcm1hdE9wdGlvbiA9IGF4aXMub3B0aW9ucy5sYWJlbHMuZm9ybWF0LFxuXG5cdFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGUgc2FtZSBzeW1ib2wgaXMgYWRkZWQgZm9yIGFsbCBsYWJlbHMgb24gYSBsaW5lYXIgYXhpc1xuXHRcdFx0XHRudW1lcmljU3ltYm9sRGV0ZWN0b3IgPSBheGlzLmlzTG9nID8gdmFsdWUgOiBheGlzLnRpY2tJbnRlcnZhbDtcblxuXHRcdFx0aWYgKGZvcm1hdE9wdGlvbikge1xuXHRcdFx0XHRyZXQgPSBmb3JtYXQoZm9ybWF0T3B0aW9uLCB0aGlzKTtcblxuXHRcdFx0fSBlbHNlIGlmIChjYXRlZ29yaWVzKSB7XG5cdFx0XHRcdHJldCA9IHZhbHVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKGRhdGVUaW1lTGFiZWxGb3JtYXQpIHsgLy8gZGF0ZXRpbWUgYXhpc1xuXHRcdFx0XHRyZXQgPSBkYXRlRm9ybWF0KGRhdGVUaW1lTGFiZWxGb3JtYXQsIHZhbHVlKTtcblxuXHRcdFx0fSBlbHNlIGlmIChpICYmIG51bWVyaWNTeW1ib2xEZXRlY3RvciA+PSAxMDAwKSB7XG5cdFx0XHRcdC8vIERlY2lkZSB3aGV0aGVyIHdlIHNob3VsZCBhZGQgYSBudW1lcmljIHN5bWJvbCBsaWtlIGsgKHRob3VzYW5kcykgb3IgTSAobWlsbGlvbnMpLlxuXHRcdFx0XHQvLyBJZiB3ZSBhcmUgdG8gZW5hYmxlIHRoaXMgaW4gdG9vbHRpcCBvciBvdGhlciBwbGFjZXMgYXMgd2VsbCwgd2UgY2FuIG1vdmUgdGhpc1xuXHRcdFx0XHQvLyBsb2dpYyB0byB0aGUgbnVtYmVyRm9ybWF0dGVyIGFuZCBlbmFibGUgaXQgYnkgYSBwYXJhbWV0ZXIuXG5cdFx0XHRcdHdoaWxlIChpLS0gJiYgcmV0ID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRtdWx0aSA9IE1hdGgucG93KDEwMDAsIGkgKyAxKTtcblx0XHRcdFx0XHRpZiAobnVtZXJpY1N5bWJvbERldGVjdG9yID49IG11bHRpICYmIG51bWVyaWNTeW1ib2xzW2ldICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXQgPSBIaWdoY2hhcnRzLm51bWJlckZvcm1hdCh2YWx1ZSAvIG11bHRpLCAtMSkgKyBudW1lcmljU3ltYm9sc1tpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHJldCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdGlmIChtYXRoQWJzKHZhbHVlKSA+PSAxMDAwMCkgeyAvLyBhZGQgdGhvdXNhbmRzIHNlcGFyYXRvcnNcblx0XHRcdFx0XHRyZXQgPSBIaWdoY2hhcnRzLm51bWJlckZvcm1hdCh2YWx1ZSwgMCk7XG5cblx0XHRcdFx0fSBlbHNlIHsgLy8gc21hbGwgbnVtYmVyc1xuXHRcdFx0XHRcdHJldCA9IEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KHZhbHVlLCAtMSwgVU5ERUZJTkVELCAnJyk7IC8vICMyNDY2XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGZvciB0aGUgc2VyaWVzIG9mIGVhY2ggYXhpc1xuXHRcdCAqL1xuXHRcdGdldFNlcmllc0V4dHJlbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydDtcblxuXHRcdFx0YXhpcy5oYXNWaXNpYmxlU2VyaWVzID0gZmFsc2U7XG5cblx0XHRcdC8vIFJlc2V0IHByb3BlcnRpZXMgaW4gY2FzZSB3ZSdyZSByZWRyYXdpbmcgKCMzMzUzKVxuXHRcdFx0YXhpcy5kYXRhTWluID0gYXhpcy5kYXRhTWF4ID0gYXhpcy5pZ25vcmVNaW5QYWRkaW5nID0gYXhpcy5pZ25vcmVNYXhQYWRkaW5nID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKGF4aXMuYnVpbGRTdGFja3MpIHtcblx0XHRcdFx0YXhpcy5idWlsZFN0YWNrcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29wIHRocm91Z2ggdGhpcyBheGlzJyBzZXJpZXNcblx0XHRcdGVhY2goYXhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblxuXHRcdFx0XHRpZiAoc2VyaWVzLnZpc2libGUgfHwgIWNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSB7XG5cblx0XHRcdFx0XHR2YXIgc2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRcdFx0eERhdGEsXG5cdFx0XHRcdFx0XHR0aHJlc2hvbGQgPSBzZXJpZXNPcHRpb25zLnRocmVzaG9sZCxcblx0XHRcdFx0XHRcdHNlcmllc0RhdGFNaW4sXG5cdFx0XHRcdFx0XHRzZXJpZXNEYXRhTWF4O1xuXG5cdFx0XHRcdFx0YXhpcy5oYXNWaXNpYmxlU2VyaWVzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIFZhbGlkYXRlIHRocmVzaG9sZCBpbiBsb2dhcml0aG1pYyBheGVzXG5cdFx0XHRcdFx0aWYgKGF4aXMuaXNMb2cgJiYgdGhyZXNob2xkIDw9IDApIHtcblx0XHRcdFx0XHRcdHRocmVzaG9sZCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gR2V0IGRhdGFNaW4gYW5kIGRhdGFNYXggZm9yIFggYXhlc1xuXHRcdFx0XHRcdGlmIChheGlzLmlzWEF4aXMpIHtcblx0XHRcdFx0XHRcdHhEYXRhID0gc2VyaWVzLnhEYXRhO1xuXHRcdFx0XHRcdFx0aWYgKHhEYXRhLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNaW4gPSBtYXRoTWluKHBpY2soYXhpcy5kYXRhTWluLCB4RGF0YVswXSksIGFycmF5TWluKHhEYXRhKSk7XG5cdFx0XHRcdFx0XHRcdGF4aXMuZGF0YU1heCA9IG1hdGhNYXgocGljayhheGlzLmRhdGFNYXgsIHhEYXRhWzBdKSwgYXJyYXlNYXgoeERhdGEpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCBkYXRhTWluIGFuZCBkYXRhTWF4IGZvciBZIGF4ZXMsIGFzIHdlbGwgYXMgaGFuZGxlIHN0YWNraW5nIGFuZCBwcm9jZXNzZWQgZGF0YVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGlzIHBhcnRpY3VsYXIgc2VyaWVzIGV4dHJlbWVzXG5cdFx0XHRcdFx0XHRzZXJpZXMuZ2V0RXh0cmVtZXMoKTtcblx0XHRcdFx0XHRcdHNlcmllc0RhdGFNYXggPSBzZXJpZXMuZGF0YU1heDtcblx0XHRcdFx0XHRcdHNlcmllc0RhdGFNaW4gPSBzZXJpZXMuZGF0YU1pbjtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBkYXRhTWluIGFuZCBkYXRhTWF4IHNvIGZhci4gSWYgcGVyY2VudGFnZSBpcyB1c2VkLCB0aGUgbWluIGFuZCBtYXggYXJlXG5cdFx0XHRcdFx0XHQvLyBhbHdheXMgMCBhbmQgMTAwLiBJZiBzZXJpZXNEYXRhTWluIGFuZCBzZXJpZXNEYXRhTWF4IGlzIG51bGwsIHRoZW4gc2VyaWVzXG5cdFx0XHRcdFx0XHQvLyBkb2Vzbid0IGhhdmUgYWN0aXZlIHkgZGF0YSwgd2UgY29udGludWUgd2l0aCBudWxsc1xuXHRcdFx0XHRcdFx0aWYgKGRlZmluZWQoc2VyaWVzRGF0YU1pbikgJiYgZGVmaW5lZChzZXJpZXNEYXRhTWF4KSkge1xuXHRcdFx0XHRcdFx0XHRheGlzLmRhdGFNaW4gPSBtYXRoTWluKHBpY2soYXhpcy5kYXRhTWluLCBzZXJpZXNEYXRhTWluKSwgc2VyaWVzRGF0YU1pbik7XG5cdFx0XHRcdFx0XHRcdGF4aXMuZGF0YU1heCA9IG1hdGhNYXgocGljayhheGlzLmRhdGFNYXgsIHNlcmllc0RhdGFNYXgpLCBzZXJpZXNEYXRhTWF4KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQWRqdXN0IHRvIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0aWYgKGRlZmluZWQodGhyZXNob2xkKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYXhpcy5kYXRhTWluID49IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0XHRcdGF4aXMuZGF0YU1pbiA9IHRocmVzaG9sZDtcblx0XHRcdFx0XHRcdFx0XHRheGlzLmlnbm9yZU1pblBhZGRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGF4aXMuZGF0YU1heCA8IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0XHRcdGF4aXMuZGF0YU1heCA9IHRocmVzaG9sZDtcblx0XHRcdFx0XHRcdFx0XHRheGlzLmlnbm9yZU1heFBhZGRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNsYXRlIGZyb20gYXhpcyB2YWx1ZSB0byBwaXhlbCBwb3NpdGlvbiBvbiB0aGUgY2hhcnQsIG9yIGJhY2tcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKHZhbCwgYmFja3dhcmRzLCBjdnNDb29yZCwgb2xkLCBoYW5kbGVMb2csIHBvaW50UGxhY2VtZW50KSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdHNpZ24gPSAxLFxuXHRcdFx0XHRjdnNPZmZzZXQgPSAwLFxuXHRcdFx0XHRsb2NhbEEgPSBvbGQgPyBheGlzLm9sZFRyYW5zQSA6IGF4aXMudHJhbnNBLFxuXHRcdFx0XHRsb2NhbE1pbiA9IG9sZCA/IGF4aXMub2xkTWluIDogYXhpcy5taW4sXG5cdFx0XHRcdHJldHVyblZhbHVlLFxuXHRcdFx0XHRtaW5QaXhlbFBhZGRpbmcgPSBheGlzLm1pblBpeGVsUGFkZGluZyxcblx0XHRcdFx0ZG9Qb3N0VHJhbnNsYXRlID0gKGF4aXMuZG9Qb3N0VHJhbnNsYXRlIHx8IChheGlzLmlzTG9nICYmIGhhbmRsZUxvZykpICYmIGF4aXMubGluMnZhbDtcblxuXHRcdFx0aWYgKCFsb2NhbEEpIHtcblx0XHRcdFx0bG9jYWxBID0gYXhpcy50cmFuc0E7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluIHZlcnRpY2FsIGF4ZXMsIHRoZSBjYW52YXMgY29vcmRpbmF0ZXMgc3RhcnQgZnJvbSAwIGF0IHRoZSB0b3AgbGlrZSBpblxuXHRcdFx0Ly8gU1ZHLlxuXHRcdFx0aWYgKGN2c0Nvb3JkKSB7XG5cdFx0XHRcdHNpZ24gKj0gLTE7IC8vIGNhbnZhcyBjb29yZGluYXRlcyBpbnZlcnRzIHRoZSB2YWx1ZVxuXHRcdFx0XHRjdnNPZmZzZXQgPSBheGlzLmxlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHJldmVyc2VkIGF4aXNcblx0XHRcdGlmIChheGlzLnJldmVyc2VkKSB7XG5cdFx0XHRcdHNpZ24gKj0gLTE7XG5cdFx0XHRcdGN2c09mZnNldCAtPSBzaWduICogKGF4aXMuc2VjdG9yIHx8IGF4aXMubGVuKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRnJvbSBwaXhlbHMgdG8gdmFsdWVcblx0XHRcdGlmIChiYWNrd2FyZHMpIHsgLy8gcmV2ZXJzZSB0cmFuc2xhdGlvblxuXG5cdFx0XHRcdHZhbCA9IHZhbCAqIHNpZ24gKyBjdnNPZmZzZXQ7XG5cdFx0XHRcdHZhbCAtPSBtaW5QaXhlbFBhZGRpbmc7XG5cdFx0XHRcdHJldHVyblZhbHVlID0gdmFsIC8gbG9jYWxBICsgbG9jYWxNaW47IC8vIGZyb20gY2hhcnQgcGl4ZWwgdG8gdmFsdWVcblx0XHRcdFx0aWYgKGRvUG9zdFRyYW5zbGF0ZSkgeyAvLyBsb2cgYW5kIG9yZGluYWwgYXhlc1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gYXhpcy5saW4ydmFsKHJldHVyblZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBGcm9tIHZhbHVlIHRvIHBpeGVsc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGRvUG9zdFRyYW5zbGF0ZSkgeyAvLyBsb2cgYW5kIG9yZGluYWwgYXhlc1xuXHRcdFx0XHRcdHZhbCA9IGF4aXMudmFsMmxpbih2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwb2ludFBsYWNlbWVudCA9PT0gJ2JldHdlZW4nKSB7XG5cdFx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPSAwLjU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSBzaWduICogKHZhbCAtIGxvY2FsTWluKSAqIGxvY2FsQSArIGN2c09mZnNldCArIChzaWduICogbWluUGl4ZWxQYWRkaW5nKSArXG5cdFx0XHRcdFx0KGlzTnVtYmVyKHBvaW50UGxhY2VtZW50KSA/IGxvY2FsQSAqIHBvaW50UGxhY2VtZW50ICogYXhpcy5wb2ludFJhbmdlIDogMCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXRpbGl0eSBtZXRob2QgdG8gdHJhbnNsYXRlIGFuIGF4aXMgdmFsdWUgdG8gcGl4ZWwgcG9zaXRpb24uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgaW4gdGVybXMgb2YgYXhpcyB1bml0c1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFuZUNvb3JkaW5hdGVzIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBjaGFydFxuXHRcdCAqICAgICAgICBvciBqdXN0IHRoZSBheGlzL3BhbmUgaXRzZWxmLlxuXHRcdCAqL1xuXHRcdHRvUGl4ZWxzOiBmdW5jdGlvbiAodmFsdWUsIHBhbmVDb29yZGluYXRlcykge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlKHZhbHVlLCBmYWxzZSwgIXRoaXMuaG9yaXosIG51bGwsIHRydWUpICsgKHBhbmVDb29yZGluYXRlcyA/IDAgOiB0aGlzLnBvcyk7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0ICogVXRpbGl0eSBtZXRob2QgdG8gdHJhbnNsYXRlIGEgcGl4ZWwgcG9zaXRpb24gaW4gdG8gYW4gYXhpcyB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbCBUaGUgcGl4ZWwgdmFsdWUgY29vcmRpbmF0ZVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFuZUNvb3JkaWFudGVzIFdoZXRoZXIgdGhlIGlucHV0IHBpeGVsIGlzIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBvciBqdXN0IHRoZVxuXHRcdCAqICAgICAgICBheGlzL3BhbmUgaXRzZWxmLlxuXHRcdCAqL1xuXHRcdHRvVmFsdWU6IGZ1bmN0aW9uIChwaXhlbCwgcGFuZUNvb3JkaW5hdGVzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGUocGl4ZWwgLSAocGFuZUNvb3JkaW5hdGVzID8gMCA6IHRoaXMucG9zKSwgdHJ1ZSwgIXRoaXMuaG9yaXosIG51bGwsIHRydWUpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgdGhlIHBhdGggZm9yIGEgcGxvdCBsaW5lIHRoYXQgZ29lcyBmcm9tIHRoZSBnaXZlbiB2YWx1ZSBvblxuXHRcdCAqIHRoaXMgYXhpcywgYWNyb3NzIHRoZSBwbG90IHRvIHRoZSBvcHBvc2l0ZSBzaWRlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVXaWR0aCBVc2VkIGZvciBjYWxjdWxhdGlvbiBjcmlzcCBsaW5lXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJdIG9sZCBVc2Ugb2xkIGNvb3JkaW5hdGVzIChmb3IgcmVzaXppbmcgYW5kIHJlc2NhbGluZylcblx0XHQgKi9cblx0XHRnZXRQbG90TGluZVBhdGg6IGZ1bmN0aW9uICh2YWx1ZSwgbGluZVdpZHRoLCBvbGQsIGZvcmNlLCB0cmFuc2xhdGVkVmFsdWUpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRheGlzTGVmdCA9IGF4aXMubGVmdCxcblx0XHRcdFx0YXhpc1RvcCA9IGF4aXMudG9wLFxuXHRcdFx0XHR4MSxcblx0XHRcdFx0eTEsXG5cdFx0XHRcdHgyLFxuXHRcdFx0XHR5Mixcblx0XHRcdFx0Y0hlaWdodCA9IChvbGQgJiYgY2hhcnQub2xkQ2hhcnRIZWlnaHQpIHx8IGNoYXJ0LmNoYXJ0SGVpZ2h0LFxuXHRcdFx0XHRjV2lkdGggPSAob2xkICYmIGNoYXJ0Lm9sZENoYXJ0V2lkdGgpIHx8IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRcdHNraXAsXG5cdFx0XHRcdHRyYW5zQiA9IGF4aXMudHJhbnNCLFxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQ2hlY2sgaWYgeCBpcyBiZXR3ZWVuIGEgYW5kIGIuIElmIG5vdCwgZWl0aGVyIG1vdmUgdG8gYS9iIG9yIHNraXAsIFxuXHRcdFx0XHQgKiBkZXBlbmRpbmcgb24gdGhlIGZvcmNlIHBhcmFtZXRlci5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGJldHdlZW4gPSBmdW5jdGlvbiAoeCwgYSwgYikge1xuXHRcdFx0XHRcdGlmICh4IDwgYSB8fCB4ID4gYikge1xuXHRcdFx0XHRcdFx0aWYgKGZvcmNlKSB7XG5cdFx0XHRcdFx0XHRcdHggPSBtYXRoTWluKG1hdGhNYXgoYSwgeCksIGIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB4O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR0cmFuc2xhdGVkVmFsdWUgPSBwaWNrKHRyYW5zbGF0ZWRWYWx1ZSwgYXhpcy50cmFuc2xhdGUodmFsdWUsIG51bGwsIG51bGwsIG9sZCkpO1xuXHRcdFx0eDEgPSB4MiA9IG1hdGhSb3VuZCh0cmFuc2xhdGVkVmFsdWUgKyB0cmFuc0IpO1xuXHRcdFx0eTEgPSB5MiA9IG1hdGhSb3VuZChjSGVpZ2h0IC0gdHJhbnNsYXRlZFZhbHVlIC0gdHJhbnNCKTtcblxuXHRcdFx0aWYgKGlzTmFOKHRyYW5zbGF0ZWRWYWx1ZSkpIHsgLy8gbm8gbWluIG9yIG1heFxuXHRcdFx0XHRza2lwID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIGlmIChheGlzLmhvcml6KSB7XG5cdFx0XHRcdHkxID0gYXhpc1RvcDtcblx0XHRcdFx0eTIgPSBjSGVpZ2h0IC0gYXhpcy5ib3R0b207XG5cdFx0XHRcdHgxID0geDIgPSBiZXR3ZWVuKHgxLCBheGlzTGVmdCwgYXhpc0xlZnQgKyBheGlzLndpZHRoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgxID0gYXhpc0xlZnQ7XG5cdFx0XHRcdHgyID0gY1dpZHRoIC0gYXhpcy5yaWdodDtcblx0XHRcdFx0eTEgPSB5MiA9IGJldHdlZW4oeTEsIGF4aXNUb3AsIGF4aXNUb3AgKyBheGlzLmhlaWdodCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2tpcCAmJiAhZm9yY2UgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0Y2hhcnQucmVuZGVyZXIuY3Jpc3BMaW5lKFtNLCB4MSwgeTEsIEwsIHgyLCB5Ml0sIGxpbmVXaWR0aCB8fCAxKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyBvZiBhIGxpbmVhciBheGlzIHRvIHJvdW5kIHZhbHVlcyBsaWtlIHdob2xlIHRlbnMgb3IgZXZlcnkgZml2ZS5cblx0XHQgKi9cblx0XHRnZXRMaW5lYXJUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAodGlja0ludGVydmFsLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIHBvcyxcblx0XHRcdFx0bGFzdFBvcyxcblx0XHRcdFx0cm91bmRlZE1pbiA9IGNvcnJlY3RGbG9hdChtYXRoRmxvb3IobWluIC8gdGlja0ludGVydmFsKSAqIHRpY2tJbnRlcnZhbCksXG5cdFx0XHRcdHJvdW5kZWRNYXggPSBjb3JyZWN0RmxvYXQobWF0aENlaWwobWF4IC8gdGlja0ludGVydmFsKSAqIHRpY2tJbnRlcnZhbCksXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSBbXTtcblxuXHRcdFx0Ly8gRm9yIHNpbmdsZSBwb2ludHMsIGFkZCBhIHRpY2sgcmVnYXJkbGVzcyBvZiB0aGUgcmVsYXRpdmUgcG9zaXRpb24gKCMyNjYyKVxuXHRcdFx0aWYgKG1pbiA9PT0gbWF4ICYmIGlzTnVtYmVyKG1pbikpIHtcblx0XHRcdFx0cmV0dXJuIFttaW5dO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQb3B1bGF0ZSB0aGUgaW50ZXJtZWRpYXRlIHZhbHVlc1xuXHRcdFx0cG9zID0gcm91bmRlZE1pbjtcblx0XHRcdHdoaWxlIChwb3MgPD0gcm91bmRlZE1heCkge1xuXG5cdFx0XHRcdC8vIFBsYWNlIHRoZSB0aWNrIG9uIHRoZSByb3VuZGVkIHZhbHVlXG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaChwb3MpO1xuXG5cdFx0XHRcdC8vIEFsd2F5cyBhZGQgdGhlIHJhdyB0aWNrSW50ZXJ2YWwsIG5vdCB0aGUgY29ycmVjdGVkIG9uZS5cblx0XHRcdFx0cG9zID0gY29ycmVjdEZsb2F0KHBvcyArIHRpY2tJbnRlcnZhbCk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGludGVydmFsIGlzIG5vdCBiaWcgZW5vdWdoIGluIHRoZSBjdXJyZW50IG1pbiAtIG1heCByYW5nZSB0byBhY3R1YWxseSBpbmNyZWFzZVxuXHRcdFx0XHQvLyB0aGUgbG9vcCB2YXJpYWJsZSwgd2UgbmVlZCB0byBicmVhayBvdXQgdG8gcHJldmVudCBlbmRsZXNzIGxvb3AuIElzc3VlICM2MTlcblx0XHRcdFx0aWYgKHBvcyA9PT0gbGFzdFBvcykge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjb3JkIHRoZSBsYXN0IHZhbHVlXG5cdFx0XHRcdGxhc3RQb3MgPSBwb3M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGlja1Bvc2l0aW9ucztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSBtaW5vciB0aWNrIHBvc2l0aW9ucy4gRm9yIGxvZ2FyaXRobWljIGF4ZXMsIHJldXNlIHRoZSBzYW1lIGxvZ2ljXG5cdFx0ICogYXMgZm9yIG1ham9yIHRpY2tzLlxuXHRcdCAqL1xuXHRcdGdldE1pbm9yVGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zID0gYXhpcy50aWNrUG9zaXRpb25zLFxuXHRcdFx0XHRtaW5vclRpY2tJbnRlcnZhbCA9IGF4aXMubWlub3JUaWNrSW50ZXJ2YWwsXG5cdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IFtdLFxuXHRcdFx0XHRwb3MsXG5cdFx0XHRcdGksXG5cdFx0XHRcdG1pbiA9IGF4aXMubWluLFxuXHRcdFx0XHRtYXggPSBheGlzLm1heCxcblx0XHRcdFx0cmFuZ2UgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGxlbjtcblxuXHRcdFx0Ly8gSWYgbWlub3IgdGlja3MgZ2V0IHRvbyBkZW5zZSwgdGhleSBhcmUgaGFyZCB0byByZWFkLCBhbmQgbWF5IGNhdXNlIGxvbmcgcnVubmluZyBzY3JpcHQuIFNvIHdlIGRvbid0IGRyYXcgdGhlbS5cblx0XHRcdGlmIChyYW5nZSAmJiByYW5nZSAvIG1pbm9yVGlja0ludGVydmFsIDwgYXhpcy5sZW4gLyAzKSB7IC8vICMzODc1XG5cblx0XHRcdFx0aWYgKGF4aXMuaXNMb2cpIHtcblx0XHRcdFx0XHRsZW4gPSB0aWNrUG9zaXRpb25zLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IG1pbm9yVGlja1Bvc2l0aW9ucy5jb25jYXQoXG5cdFx0XHRcdFx0XHRcdGF4aXMuZ2V0TG9nVGlja1Bvc2l0aW9ucyhtaW5vclRpY2tJbnRlcnZhbCwgdGlja1Bvc2l0aW9uc1tpIC0gMV0sIHRpY2tQb3NpdGlvbnNbaV0sIHRydWUpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChheGlzLmlzRGF0ZXRpbWVBeGlzICYmIG9wdGlvbnMubWlub3JUaWNrSW50ZXJ2YWwgPT09ICdhdXRvJykgeyAvLyAjMTMxNFxuXHRcdFx0XHRcdG1pbm9yVGlja1Bvc2l0aW9ucyA9IG1pbm9yVGlja1Bvc2l0aW9ucy5jb25jYXQoXG5cdFx0XHRcdFx0XHRheGlzLmdldFRpbWVUaWNrcyhcblx0XHRcdFx0XHRcdFx0YXhpcy5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKG1pbm9yVGlja0ludGVydmFsKSxcblx0XHRcdFx0XHRcdFx0bWluLFxuXHRcdFx0XHRcdFx0XHRtYXgsXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuc3RhcnRPZldlZWtcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAocG9zID0gbWluICsgKHRpY2tQb3NpdGlvbnNbMF0gLSBtaW4pICUgbWlub3JUaWNrSW50ZXJ2YWw7IHBvcyA8PSBtYXg7IHBvcyArPSBtaW5vclRpY2tJbnRlcnZhbCkge1xuXHRcdFx0XHRcdFx0bWlub3JUaWNrUG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YXhpcy50cmltVGlja3MobWlub3JUaWNrUG9zaXRpb25zKTsgLy8gIzM2NTIgIzM3NDNcblx0XHRcdHJldHVybiBtaW5vclRpY2tQb3NpdGlvbnM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkanVzdCB0aGUgbWluIGFuZCBtYXggZm9yIHRoZSBtaW5pbXVtIHJhbmdlLiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgc2VyaWVzIGRhdGEgaXNcblx0XHQgKiBub3QgeWV0IHByb2Nlc3NlZCwgc28gd2UgZG9uJ3QgaGF2ZSBpbmZvcm1hdGlvbiBvbiBkYXRhIGNyb3BwaW5nIGFuZCBncm91cGluZywgb3Jcblx0XHQgKiB1cGRhdGVkIGF4aXMucG9pbnRSYW5nZSBvciBzZXJpZXMucG9pbnRSYW5nZS4gVGhlIGRhdGEgY2FuJ3QgYmUgcHJvY2Vzc2VkIHVudGlsXG5cdFx0ICogd2UgaGF2ZSBmaW5hbGx5IGVzdGFibGlzaGVkIG1pbiBhbmQgbWF4LlxuXHRcdCAqL1xuXHRcdGFkanVzdEZvck1pblJhbmdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRcdG1pbiA9IGF4aXMubWluLFxuXHRcdFx0XHRtYXggPSBheGlzLm1heCxcblx0XHRcdFx0em9vbU9mZnNldCxcblx0XHRcdFx0c3BhY2VBdmFpbGFibGUgPSBheGlzLmRhdGFNYXggLSBheGlzLmRhdGFNaW4gPj0gYXhpcy5taW5SYW5nZSxcblx0XHRcdFx0Y2xvc2VzdERhdGFSYW5nZSxcblx0XHRcdFx0aSxcblx0XHRcdFx0ZGlzdGFuY2UsXG5cdFx0XHRcdHhEYXRhLFxuXHRcdFx0XHRsb29wTGVuZ3RoLFxuXHRcdFx0XHRtaW5BcmdzLFxuXHRcdFx0XHRtYXhBcmdzO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGF1dG9tYXRpYyBtaW5pbXVtIHJhbmdlIGJhc2VkIG9uIHRoZSBjbG9zZXN0IHBvaW50IGRpc3RhbmNlXG5cdFx0XHRpZiAoYXhpcy5pc1hBeGlzICYmIGF4aXMubWluUmFuZ2UgPT09IFVOREVGSU5FRCAmJiAhYXhpcy5pc0xvZykge1xuXG5cdFx0XHRcdGlmIChkZWZpbmVkKG9wdGlvbnMubWluKSB8fCBkZWZpbmVkKG9wdGlvbnMubWF4KSkge1xuXHRcdFx0XHRcdGF4aXMubWluUmFuZ2UgPSBudWxsOyAvLyBkb24ndCBkbyB0aGlzIGFnYWluXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiByYXcgZGF0YSBwb2ludHMsIGFzIG9wcG9zZWQgdG9cblx0XHRcdFx0XHQvLyBjbG9zZXN0UG9pbnRSYW5nZSB0aGF0IGFwcGxpZXMgdG8gcHJvY2Vzc2VkIHBvaW50cyAoY3JvcHBlZCBhbmQgZ3JvdXBlZClcblx0XHRcdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdFx0XHR4RGF0YSA9IHNlcmllcy54RGF0YTtcblx0XHRcdFx0XHRcdGxvb3BMZW5ndGggPSBzZXJpZXMueEluY3JlbWVudCA/IDEgOiB4RGF0YS5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gbG9vcExlbmd0aDsgaSA+IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZSA9IHhEYXRhW2ldIC0geERhdGFbaSAtIDFdO1xuXHRcdFx0XHRcdFx0XHRpZiAoY2xvc2VzdERhdGFSYW5nZSA9PT0gVU5ERUZJTkVEIHx8IGRpc3RhbmNlIDwgY2xvc2VzdERhdGFSYW5nZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REYXRhUmFuZ2UgPSBkaXN0YW5jZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGF4aXMubWluUmFuZ2UgPSBtYXRoTWluKGNsb3Nlc3REYXRhUmFuZ2UgKiA1LCBheGlzLmRhdGFNYXggLSBheGlzLmRhdGFNaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIG1pblJhbmdlIGlzIGV4Y2VlZGVkLCBhZGp1c3Rcblx0XHRcdGlmIChtYXggLSBtaW4gPCBheGlzLm1pblJhbmdlKSB7XG5cdFx0XHRcdHZhciBtaW5SYW5nZSA9IGF4aXMubWluUmFuZ2U7XG5cdFx0XHRcdHpvb21PZmZzZXQgPSAobWluUmFuZ2UgLSBtYXggKyBtaW4pIC8gMjtcblxuXHRcdFx0XHQvLyBpZiBtaW4gYW5kIG1heCBvcHRpb25zIGhhdmUgYmVlbiBzZXQsIGRvbid0IGdvIGJleW9uZCBpdFxuXHRcdFx0XHRtaW5BcmdzID0gW21pbiAtIHpvb21PZmZzZXQsIHBpY2sob3B0aW9ucy5taW4sIG1pbiAtIHpvb21PZmZzZXQpXTtcblx0XHRcdFx0aWYgKHNwYWNlQXZhaWxhYmxlKSB7IC8vIGlmIHNwYWNlIGlzIGF2YWlsYWJsZSwgc3RheSB3aXRoaW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0XHRtaW5BcmdzWzJdID0gYXhpcy5kYXRhTWluO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1pbiA9IGFycmF5TWF4KG1pbkFyZ3MpO1xuXG5cdFx0XHRcdG1heEFyZ3MgPSBbbWluICsgbWluUmFuZ2UsIHBpY2sob3B0aW9ucy5tYXgsIG1pbiArIG1pblJhbmdlKV07XG5cdFx0XHRcdGlmIChzcGFjZUF2YWlsYWJsZSkgeyAvLyBpZiBzcGFjZSBpcyBhdmFpbGFiZSwgc3RheSB3aXRoaW4gdGhlIGRhdGEgcmFuZ2Vcblx0XHRcdFx0XHRtYXhBcmdzWzJdID0gYXhpcy5kYXRhTWF4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF4ID0gYXJyYXlNaW4obWF4QXJncyk7XG5cblx0XHRcdFx0Ly8gbm93IGlmIHRoZSBtYXggaXMgYWRqdXN0ZWQsIGFkanVzdCB0aGUgbWluIGJhY2tcblx0XHRcdFx0aWYgKG1heCAtIG1pbiA8IG1pblJhbmdlKSB7XG5cdFx0XHRcdFx0bWluQXJnc1swXSA9IG1heCAtIG1pblJhbmdlO1xuXHRcdFx0XHRcdG1pbkFyZ3NbMV0gPSBwaWNrKG9wdGlvbnMubWluLCBtYXggLSBtaW5SYW5nZSk7XG5cdFx0XHRcdFx0bWluID0gYXJyYXlNYXgobWluQXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVjb3JkIG1vZGlmaWVkIGV4dHJlbWVzXG5cdFx0XHRheGlzLm1pbiA9IG1pbjtcblx0XHRcdGF4aXMubWF4ID0gbWF4O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdHJhbnNsYXRpb24gaW5mb3JtYXRpb25cblx0XHQgKi9cblx0XHRzZXRBeGlzVHJhbnNsYXRpb246IGZ1bmN0aW9uIChzYXZlT2xkKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdHJhbmdlID0gYXhpcy5tYXggLSBheGlzLm1pbixcblx0XHRcdFx0cG9pbnRSYW5nZSA9IGF4aXMuYXhpc1BvaW50UmFuZ2UgfHwgMCxcblx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRcdG1pblBvaW50T2Zmc2V0ID0gMCxcblx0XHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcgPSAwLFxuXHRcdFx0XHRsaW5rZWRQYXJlbnQgPSBheGlzLmxpbmtlZFBhcmVudCxcblx0XHRcdFx0b3JkaW5hbENvcnJlY3Rpb24sXG5cdFx0XHRcdGhhc0NhdGVnb3JpZXMgPSAhIWF4aXMuY2F0ZWdvcmllcyxcblx0XHRcdFx0dHJhbnNBID0gYXhpcy50cmFuc0EsXG5cdFx0XHRcdGlzWEF4aXMgPSBheGlzLmlzWEF4aXM7XG5cblx0XHRcdC8vIEFkanVzdCB0cmFuc2xhdGlvbiBmb3IgcGFkZGluZy4gWSBheGlzIHdpdGggY2F0ZWdvcmllcyBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHNhbWUgKCMxNzg0KS5cblx0XHRcdGlmIChpc1hBeGlzIHx8IGhhc0NhdGVnb3JpZXMgfHwgcG9pbnRSYW5nZSkge1xuXHRcdFx0XHRpZiAobGlua2VkUGFyZW50KSB7XG5cdFx0XHRcdFx0bWluUG9pbnRPZmZzZXQgPSBsaW5rZWRQYXJlbnQubWluUG9pbnRPZmZzZXQ7XG5cdFx0XHRcdFx0cG9pbnRSYW5nZVBhZGRpbmcgPSBsaW5rZWRQYXJlbnQucG9pbnRSYW5nZVBhZGRpbmc7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2VyaWVzUG9pbnRSYW5nZSA9IGhhc0NhdGVnb3JpZXMgPyAxIDogKGlzWEF4aXMgPyBzZXJpZXMucG9pbnRSYW5nZSA6IChheGlzLmF4aXNQb2ludFJhbmdlIHx8IDApKSwgLy8gIzI4MDZcblx0XHRcdFx0XHRcdFx0cG9pbnRQbGFjZW1lbnQgPSBzZXJpZXMub3B0aW9ucy5wb2ludFBsYWNlbWVudCxcblx0XHRcdFx0XHRcdFx0c2VyaWVzQ2xvc2VzdFBvaW50UmFuZ2UgPSBzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2U7XG5cblx0XHRcdFx0XHRcdGlmIChzZXJpZXNQb2ludFJhbmdlID4gcmFuZ2UpIHsgLy8gIzE0NDZcblx0XHRcdFx0XHRcdFx0c2VyaWVzUG9pbnRSYW5nZSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwb2ludFJhbmdlID0gbWF0aE1heChwb2ludFJhbmdlLCBzZXJpZXNQb2ludFJhbmdlKTtcblxuXHRcdFx0XHRcdFx0aWYgKCFheGlzLnNpbmdsZSkge1xuXHRcdFx0XHRcdFx0XHQvLyBtaW5Qb2ludE9mZnNldCBpcyB0aGUgdmFsdWUgcGFkZGluZyB0byB0aGUgbGVmdCBvZiB0aGUgYXhpcyBpbiBvcmRlciB0byBtYWtlXG5cdFx0XHRcdFx0XHRcdC8vIHJvb20gZm9yIHBvaW50cyB3aXRoIGEgcG9pbnRSYW5nZSwgdHlwaWNhbGx5IGNvbHVtbnMuIFdoZW4gdGhlIHBvaW50UGxhY2VtZW50IG9wdGlvblxuXHRcdFx0XHRcdFx0XHQvLyBpcyAnYmV0d2Vlbicgb3IgJ29uJywgdGhpcyBwYWRkaW5nIGRvZXMgbm90IGFwcGx5LlxuXHRcdFx0XHRcdFx0XHRtaW5Qb2ludE9mZnNldCA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHRcdFx0bWluUG9pbnRPZmZzZXQsXG5cdFx0XHRcdFx0XHRcdFx0aXNTdHJpbmcocG9pbnRQbGFjZW1lbnQpID8gMCA6IHNlcmllc1BvaW50UmFuZ2UgLyAyXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRGV0ZXJtaW5lIHRoZSB0b3RhbCBwYWRkaW5nIG5lZWRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBheGlzIHRvIG1ha2Ugcm9vbSBmb3IgdGhlXG5cdFx0XHRcdFx0XHRcdC8vIHBvaW50UmFuZ2UuIElmIHRoZSBzZXJpZXMnIHBvaW50UGxhY2VtZW50IGlzICdvbicsIG5vIHBhZGRpbmcgaXMgYWRkZWQuXG5cdFx0XHRcdFx0XHRcdHBvaW50UmFuZ2VQYWRkaW5nID0gbWF0aE1heChcblx0XHRcdFx0XHRcdFx0XHRwb2ludFJhbmdlUGFkZGluZyxcblx0XHRcdFx0XHRcdFx0XHRwb2ludFBsYWNlbWVudCA9PT0gJ29uJyA/IDAgOiBzZXJpZXNQb2ludFJhbmdlXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFNldCB0aGUgY2xvc2VzdFBvaW50UmFuZ2Vcblx0XHRcdFx0XHRcdGlmICghc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCAmJiBkZWZpbmVkKHNlcmllc0Nsb3Nlc3RQb2ludFJhbmdlKSkge1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0UG9pbnRSYW5nZSA9IGRlZmluZWQoY2xvc2VzdFBvaW50UmFuZ2UpID9cblx0XHRcdFx0XHRcdFx0XHRtYXRoTWluKGNsb3Nlc3RQb2ludFJhbmdlLCBzZXJpZXNDbG9zZXN0UG9pbnRSYW5nZSkgOlxuXHRcdFx0XHRcdFx0XHRcdHNlcmllc0Nsb3Nlc3RQb2ludFJhbmdlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjb3JkIG1pblBvaW50T2Zmc2V0IGFuZCBwb2ludFJhbmdlUGFkZGluZ1xuXHRcdFx0XHRvcmRpbmFsQ29ycmVjdGlvbiA9IGF4aXMub3JkaW5hbFNsb3BlICYmIGNsb3Nlc3RQb2ludFJhbmdlID8gYXhpcy5vcmRpbmFsU2xvcGUgLyBjbG9zZXN0UG9pbnRSYW5nZSA6IDE7IC8vICM5ODgsICMxODUzXG5cdFx0XHRcdGF4aXMubWluUG9pbnRPZmZzZXQgPSBtaW5Qb2ludE9mZnNldCA9IG1pblBvaW50T2Zmc2V0ICogb3JkaW5hbENvcnJlY3Rpb247XG5cdFx0XHRcdGF4aXMucG9pbnRSYW5nZVBhZGRpbmcgPSBwb2ludFJhbmdlUGFkZGluZyA9IHBvaW50UmFuZ2VQYWRkaW5nICogb3JkaW5hbENvcnJlY3Rpb247XG5cblx0XHRcdFx0Ly8gcG9pbnRSYW5nZSBtZWFucyB0aGUgd2lkdGggcmVzZXJ2ZWQgZm9yIGVhY2ggcG9pbnQsIGxpa2UgaW4gYSBjb2x1bW4gY2hhcnRcblx0XHRcdFx0YXhpcy5wb2ludFJhbmdlID0gbWF0aE1pbihwb2ludFJhbmdlLCByYW5nZSk7XG5cblx0XHRcdFx0Ly8gY2xvc2VzdFBvaW50UmFuZ2UgbWVhbnMgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMuIEluIGNvbHVtbnNcblx0XHRcdFx0Ly8gaXQgaXMgbW9zdGx5IGVxdWFsIHRvIHBvaW50UmFuZ2UsIGJ1dCBpbiBsaW5lcyBwb2ludFJhbmdlIGlzIDAgd2hpbGUgY2xvc2VzdFBvaW50UmFuZ2Vcblx0XHRcdFx0Ly8gaXMgc29tZSBvdGhlciB2YWx1ZVxuXHRcdFx0XHRpZiAoaXNYQXhpcykge1xuXHRcdFx0XHRcdGF4aXMuY2xvc2VzdFBvaW50UmFuZ2UgPSBjbG9zZXN0UG9pbnRSYW5nZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWNvbmRhcnkgdmFsdWVzXG5cdFx0XHRpZiAoc2F2ZU9sZCkge1xuXHRcdFx0XHRheGlzLm9sZFRyYW5zQSA9IHRyYW5zQTtcblx0XHRcdH1cblx0XHRcdGF4aXMudHJhbnNsYXRpb25TbG9wZSA9IGF4aXMudHJhbnNBID0gdHJhbnNBID0gYXhpcy5sZW4gLyAoKHJhbmdlICsgcG9pbnRSYW5nZVBhZGRpbmcpIHx8IDEpO1xuXHRcdFx0YXhpcy50cmFuc0IgPSBheGlzLmhvcml6ID8gYXhpcy5sZWZ0IDogYXhpcy5ib3R0b207IC8vIHRyYW5zbGF0aW9uIGFkZGVuZFxuXHRcdFx0YXhpcy5taW5QaXhlbFBhZGRpbmcgPSB0cmFuc0EgKiBtaW5Qb2ludE9mZnNldDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyB0byByb3VuZCB2YWx1ZXMgYW5kIG9wdGlvbmFsbHkgZXh0ZW5kIHRoZSBleHRyZW1lc1xuXHRcdCAqIHRvIHRoZSBuZWFyZXN0IHRpY2tcblx0XHQgKi9cblx0XHRzZXRUaWNrSW50ZXJ2YWw6IGZ1bmN0aW9uIChzZWNvbmRQYXNzKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdFx0aXNMb2cgPSBheGlzLmlzTG9nLFxuXHRcdFx0XHRpc0RhdGV0aW1lQXhpcyA9IGF4aXMuaXNEYXRldGltZUF4aXMsXG5cdFx0XHRcdGlzWEF4aXMgPSBheGlzLmlzWEF4aXMsXG5cdFx0XHRcdGlzTGlua2VkID0gYXhpcy5pc0xpbmtlZCxcblx0XHRcdFx0bWF4UGFkZGluZyA9IG9wdGlvbnMubWF4UGFkZGluZyxcblx0XHRcdFx0bWluUGFkZGluZyA9IG9wdGlvbnMubWluUGFkZGluZyxcblx0XHRcdFx0bGVuZ3RoLFxuXHRcdFx0XHRsaW5rZWRQYXJlbnRFeHRyZW1lcyxcblx0XHRcdFx0dGlja0ludGVydmFsT3B0aW9uID0gb3B0aW9ucy50aWNrSW50ZXJ2YWwsXG5cdFx0XHRcdG1pblRpY2tJbnRlcnZhbCxcblx0XHRcdFx0dGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gPSBvcHRpb25zLnRpY2tQaXhlbEludGVydmFsLFxuXHRcdFx0XHRjYXRlZ29yaWVzID0gYXhpcy5jYXRlZ29yaWVzO1xuXG5cdFx0XHRpZiAoIWlzRGF0ZXRpbWVBeGlzICYmICFjYXRlZ29yaWVzICYmICFpc0xpbmtlZCkge1xuXHRcdFx0XHR0aGlzLmdldFRpY2tBbW91bnQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbGlua2VkIGF4aXMgZ2V0cyB0aGUgZXh0cmVtZXMgZnJvbSB0aGUgcGFyZW50IGF4aXNcblx0XHRcdGlmIChpc0xpbmtlZCkge1xuXHRcdFx0XHRheGlzLmxpbmtlZFBhcmVudCA9IGNoYXJ0W2F4aXMuY29sbF1bb3B0aW9ucy5saW5rZWRUb107XG5cdFx0XHRcdGxpbmtlZFBhcmVudEV4dHJlbWVzID0gYXhpcy5saW5rZWRQYXJlbnQuZ2V0RXh0cmVtZXMoKTtcblx0XHRcdFx0YXhpcy5taW4gPSBwaWNrKGxpbmtlZFBhcmVudEV4dHJlbWVzLm1pbiwgbGlua2VkUGFyZW50RXh0cmVtZXMuZGF0YU1pbik7XG5cdFx0XHRcdGF4aXMubWF4ID0gcGljayhsaW5rZWRQYXJlbnRFeHRyZW1lcy5tYXgsIGxpbmtlZFBhcmVudEV4dHJlbWVzLmRhdGFNYXgpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy50eXBlICE9PSBheGlzLmxpbmtlZFBhcmVudC5vcHRpb25zLnR5cGUpIHtcblx0XHRcdFx0XHRlcnJvcigxMSwgMSk7IC8vIENhbid0IGxpbmsgYXhlcyBvZiBkaWZmZXJlbnQgdHlwZVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgeyAvLyBpbml0aWFsIG1pbiBhbmQgbWF4IGZyb20gdGhlIGV4dHJlbWUgZGF0YSB2YWx1ZXNcblx0XHRcdFx0YXhpcy5taW4gPSBwaWNrKGF4aXMudXNlck1pbiwgb3B0aW9ucy5taW4sIGF4aXMuZGF0YU1pbik7XG5cdFx0XHRcdGF4aXMubWF4ID0gcGljayhheGlzLnVzZXJNYXgsIG9wdGlvbnMubWF4LCBheGlzLmRhdGFNYXgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNMb2cpIHtcblx0XHRcdFx0aWYgKCFzZWNvbmRQYXNzICYmIG1hdGhNaW4oYXhpcy5taW4sIHBpY2soYXhpcy5kYXRhTWluLCBheGlzLm1pbikpIDw9IDApIHsgLy8gIzk3OFxuXHRcdFx0XHRcdGVycm9yKDEwLCAxKTsgLy8gQ2FuJ3QgcGxvdCBuZWdhdGl2ZSB2YWx1ZXMgb24gbG9nIGF4aXNcblx0XHRcdFx0fVxuXHRcdFx0XHRheGlzLm1pbiA9IGNvcnJlY3RGbG9hdChsb2cybGluKGF4aXMubWluKSk7IC8vIGNvcnJlY3RGbG9hdCBjdXJlcyAjOTM0XG5cdFx0XHRcdGF4aXMubWF4ID0gY29ycmVjdEZsb2F0KGxvZzJsaW4oYXhpcy5tYXgpKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaGFuZGxlIHpvb21lZCByYW5nZVxuXHRcdFx0aWYgKGF4aXMucmFuZ2UgJiYgZGVmaW5lZChheGlzLm1heCkpIHtcblx0XHRcdFx0YXhpcy51c2VyTWluID0gYXhpcy5taW4gPSBtYXRoTWF4KGF4aXMubWluLCBheGlzLm1heCAtIGF4aXMucmFuZ2UpOyAvLyAjNjE4XG5cdFx0XHRcdGF4aXMudXNlck1heCA9IGF4aXMubWF4O1xuXG5cdFx0XHRcdGF4aXMucmFuZ2UgPSBudWxsOyAgLy8gZG9uJ3QgdXNlIGl0IHdoZW4gcnVubmluZyBzZXRFeHRyZW1lc1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIGZvciBhZGp1c3RpbmcgdGhpcy5taW4gYW5kIHRoaXMubWF4LiBVc2VkIGJ5IGJ1YmJsZSBzZXJpZXMuXG5cdFx0XHRpZiAoYXhpcy5iZWZvcmVQYWRkaW5nKSB7XG5cdFx0XHRcdGF4aXMuYmVmb3JlUGFkZGluZygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGp1c3QgbWluIGFuZCBtYXggZm9yIHRoZSBtaW5pbXVtIHJhbmdlXG5cdFx0XHRheGlzLmFkanVzdEZvck1pblJhbmdlKCk7XG5cblx0XHRcdC8vIFBhZCB0aGUgdmFsdWVzIHRvIGdldCBjbGVhciBvZiB0aGUgY2hhcnQncyBlZGdlcy4gVG8gYXZvaWQgdGlja0ludGVydmFsIHRha2luZyB0aGUgcGFkZGluZ1xuXHRcdFx0Ly8gaW50byBhY2NvdW50LCB3ZSBkbyB0aGlzIGFmdGVyIGNvbXB1dGluZyB0aWNrIGludGVydmFsICgjMTMzNykuXG5cdFx0XHRpZiAoIWNhdGVnb3JpZXMgJiYgIWF4aXMuYXhpc1BvaW50UmFuZ2UgJiYgIWF4aXMudXNlUGVyY2VudGFnZSAmJiAhaXNMaW5rZWQgJiYgZGVmaW5lZChheGlzLm1pbikgJiYgZGVmaW5lZChheGlzLm1heCkpIHtcblx0XHRcdFx0bGVuZ3RoID0gYXhpcy5tYXggLSBheGlzLm1pbjtcblx0XHRcdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0XHRcdGlmICghZGVmaW5lZChvcHRpb25zLm1pbikgJiYgIWRlZmluZWQoYXhpcy51c2VyTWluKSAmJiBtaW5QYWRkaW5nICYmIChheGlzLmRhdGFNaW4gPCAwIHx8ICFheGlzLmlnbm9yZU1pblBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0XHRheGlzLm1pbiAtPSBsZW5ndGggKiBtaW5QYWRkaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIWRlZmluZWQob3B0aW9ucy5tYXgpICYmICFkZWZpbmVkKGF4aXMudXNlck1heCkgICYmIG1heFBhZGRpbmcgJiYgKGF4aXMuZGF0YU1heCA+IDAgfHwgIWF4aXMuaWdub3JlTWF4UGFkZGluZykpIHtcblx0XHRcdFx0XHRcdGF4aXMubWF4ICs9IGxlbmd0aCAqIG1heFBhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXkgd2l0aGluIGZsb29yIGFuZCBjZWlsaW5nXG5cdFx0XHRpZiAoaXNOdW1iZXIob3B0aW9ucy5mbG9vcikpIHtcblx0XHRcdFx0YXhpcy5taW4gPSBtYXRoTWF4KGF4aXMubWluLCBvcHRpb25zLmZsb29yKTtcblx0XHRcdH1cblx0XHRcdGlmIChpc051bWJlcihvcHRpb25zLmNlaWxpbmcpKSB7XG5cdFx0XHRcdGF4aXMubWF4ID0gbWF0aE1pbihheGlzLm1heCwgb3B0aW9ucy5jZWlsaW5nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2V0IHRpY2tJbnRlcnZhbFxuXHRcdFx0aWYgKGF4aXMubWluID09PSBheGlzLm1heCB8fCBheGlzLm1pbiA9PT0gdW5kZWZpbmVkIHx8IGF4aXMubWF4ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChpc0xpbmtlZCAmJiAhdGlja0ludGVydmFsT3B0aW9uICYmXG5cdFx0XHRcdFx0dGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gPT09IGF4aXMubGlua2VkUGFyZW50Lm9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWwpIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBheGlzLmxpbmtlZFBhcmVudC50aWNrSW50ZXJ2YWw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IHBpY2soXG5cdFx0XHRcdFx0dGlja0ludGVydmFsT3B0aW9uLFxuXHRcdFx0XHRcdHRoaXMudGlja0Ftb3VudCA/ICgoYXhpcy5tYXggLSBheGlzLm1pbikgLyBtYXRoTWF4KHRoaXMudGlja0Ftb3VudCAtIDEsIDEpKSA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRjYXRlZ29yaWVzID8gLy8gZm9yIGNhdGVnb3JpZWQgYXhpcywgMSBpcyBkZWZhdWx0LCBmb3IgbGluZWFyIGF4aXMgdXNlIHRpY2tQaXhcblx0XHRcdFx0XHRcdDEgOlxuXHRcdFx0XHRcdFx0Ly8gZG9uJ3QgbGV0IGl0IGJlIG1vcmUgdGhhbiB0aGUgZGF0YSByYW5nZVxuXHRcdFx0XHRcdFx0KGF4aXMubWF4IC0gYXhpcy5taW4pICogdGlja1BpeGVsSW50ZXJ2YWxPcHRpb24gLyBtYXRoTWF4KGF4aXMubGVuLCB0aWNrUGl4ZWxJbnRlcnZhbE9wdGlvbilcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm93IHdlJ3JlIGZpbmlzaGVkIGRldGVjdGluZyBtaW4gYW5kIG1heCwgY3JvcCBhbmQgZ3JvdXAgc2VyaWVzIGRhdGEuIFRoaXNcblx0XHRcdC8vIGlzIGluIHR1cm4gbmVlZGVkIGluIG9yZGVyIHRvIGZpbmQgdGljayBwb3NpdGlvbnMgaW4gb3JkaW5hbCBheGVzLlxuXHRcdFx0aWYgKGlzWEF4aXMgJiYgIXNlY29uZFBhc3MpIHtcblx0XHRcdFx0ZWFjaChheGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRcdHNlcmllcy5wcm9jZXNzRGF0YShheGlzLm1pbiAhPT0gYXhpcy5vbGRNaW4gfHwgYXhpcy5tYXggIT09IGF4aXMub2xkTWF4KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCB0aGUgdHJhbnNsYXRpb24gZmFjdG9yIHVzZWQgaW4gdHJhbnNsYXRlIGZ1bmN0aW9uXG5cdFx0XHRheGlzLnNldEF4aXNUcmFuc2xhdGlvbih0cnVlKTtcblxuXHRcdFx0Ly8gaG9vayBmb3Igb3JkaW5hbCBheGVzIGFuZCByYWRpYWwgYXhlc1xuXHRcdFx0aWYgKGF4aXMuYmVmb3JlU2V0VGlja1Bvc2l0aW9ucykge1xuXHRcdFx0XHRheGlzLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaG9vayBmb3IgZXh0ZW5zaW9ucywgdXNlZCBpbiBIaWdoc3RvY2sgb3JkaW5hbCBheGVzXG5cdFx0XHRpZiAoYXhpcy5wb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbCkge1xuXHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IGF4aXMucG9zdFByb2Nlc3NUaWNrSW50ZXJ2YWwoYXhpcy50aWNrSW50ZXJ2YWwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbiBjb2x1bW4tbGlrZSBjaGFydHMsIGRvbid0IGNyYW1wIGluIG1vcmUgdGlja3MgdGhhbiB0aGVyZSBhcmUgcG9pbnRzICgjMTk0Mylcblx0XHRcdGlmIChheGlzLnBvaW50UmFuZ2UpIHtcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBtYXRoTWF4KGF4aXMucG9pbnRSYW5nZSwgYXhpcy50aWNrSW50ZXJ2YWwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCZWZvcmUgbm9ybWFsaXppbmcgdGhlIHRpY2sgaW50ZXJ2YWwsIGhhbmRsZSBtaW5pbXVtIHRpY2sgaW50ZXJ2YWwuIFRoaXMgYXBwbGllcyBvbmx5IGlmIHRpY2tJbnRlcnZhbCBpcyBub3QgZGVmaW5lZC5cblx0XHRcdG1pblRpY2tJbnRlcnZhbCA9IHBpY2sob3B0aW9ucy5taW5UaWNrSW50ZXJ2YWwsIGF4aXMuaXNEYXRldGltZUF4aXMgJiYgYXhpcy5jbG9zZXN0UG9pbnRSYW5nZSk7XG5cdFx0XHRpZiAoIXRpY2tJbnRlcnZhbE9wdGlvbiAmJiBheGlzLnRpY2tJbnRlcnZhbCA8IG1pblRpY2tJbnRlcnZhbCkge1xuXHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IG1pblRpY2tJbnRlcnZhbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZm9yIGxpbmVhciBheGVzLCBnZXQgbWFnbml0dWRlIGFuZCBub3JtYWxpemUgdGhlIGludGVydmFsXG5cdFx0XHRpZiAoIWlzRGF0ZXRpbWVBeGlzICYmICFpc0xvZykgeyAvLyBsaW5lYXJcblx0XHRcdFx0aWYgKCF0aWNrSW50ZXJ2YWxPcHRpb24pIHtcblx0XHRcdFx0XHRheGlzLnRpY2tJbnRlcnZhbCA9IG5vcm1hbGl6ZVRpY2tJbnRlcnZhbChcblx0XHRcdFx0XHRcdGF4aXMudGlja0ludGVydmFsLCBcblx0XHRcdFx0XHRcdG51bGwsIFxuXHRcdFx0XHRcdFx0Z2V0TWFnbml0dWRlKGF4aXMudGlja0ludGVydmFsKSwgXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgdGljayBpbnRlcnZhbCBpcyBiZXR3ZWVuIDAuNSBhbmQgNSBhbmQgdGhlIGF4aXMgbWF4IGlzIGluIHRoZSBvcmRlciBvZlxuXHRcdFx0XHRcdFx0Ly8gdGhvdXNhbmRzLCBjaGFuY2VzIGFyZSB3ZSBhcmUgZGVhbGluZyB3aXRoIHllYXJzLiBEb24ndCBhbGxvdyBkZWNpbWFscy4gIzMzNjMuXG5cdFx0XHRcdFx0XHRwaWNrKG9wdGlvbnMuYWxsb3dEZWNpbWFscywgIShheGlzLnRpY2tJbnRlcnZhbCA+IDAuNSAmJiBheGlzLnRpY2tJbnRlcnZhbCA8IDUgJiYgYXhpcy5tYXggPiAxMDAwICYmIGF4aXMubWF4IDwgOTk5OSkpLFxuXHRcdFx0XHRcdFx0ISF0aGlzLnRpY2tBbW91bnRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByZXZlbnQgdGlja3MgZnJvbSBnZXR0aW5nIHNvIGNsb3NlIHRoYXQgd2UgY2FuJ3QgZHJhdyB0aGUgbGFiZWxzXG5cdFx0XHRpZiAoIXRoaXMudGlja0Ftb3VudCAmJiB0aGlzLmxlbikgeyAvLyBDb2xvciBheGlzIHdpdGggZGlzYWJsZWQgbGVnZW5kIGhhcyBubyBsZW5ndGhcblx0XHRcdFx0YXhpcy50aWNrSW50ZXJ2YWwgPSBheGlzLnVuc3F1aXNoKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBOb3cgd2UgaGF2ZSBjb21wdXRlZCB0aGUgbm9ybWFsaXplZCB0aWNrSW50ZXJ2YWwsIGdldCB0aGUgdGljayBwb3NpdGlvbnNcblx0XHQgKi9cblx0XHRzZXRUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zT3B0aW9uID0gb3B0aW9ucy50aWNrUG9zaXRpb25zLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25lciA9IG9wdGlvbnMudGlja1Bvc2l0aW9uZXIsXG5cdFx0XHRcdHN0YXJ0T25UaWNrID0gb3B0aW9ucy5zdGFydE9uVGljayxcblx0XHRcdFx0ZW5kT25UaWNrID0gb3B0aW9ucy5lbmRPblRpY2ssXG5cdFx0XHRcdHNpbmdsZTtcblxuXHRcdFx0Ly8gU2V0IHRoZSB0aWNrbWFya09mZnNldFxuXHRcdFx0dGhpcy50aWNrbWFya09mZnNldCA9ICh0aGlzLmNhdGVnb3JpZXMgJiYgb3B0aW9ucy50aWNrbWFya1BsYWNlbWVudCA9PT0gJ2JldHdlZW4nICYmIFxuXHRcdFx0XHR0aGlzLnRpY2tJbnRlcnZhbCA9PT0gMSkgPyAwLjUgOiAwOyAvLyAjMzIwMlxuXG5cblx0XHRcdC8vIGdldCBtaW5vclRpY2tJbnRlcnZhbFxuXHRcdFx0dGhpcy5taW5vclRpY2tJbnRlcnZhbCA9IG9wdGlvbnMubWlub3JUaWNrSW50ZXJ2YWwgPT09ICdhdXRvJyAmJiB0aGlzLnRpY2tJbnRlcnZhbCA/XG5cdFx0XHRcdHRoaXMudGlja0ludGVydmFsIC8gNSA6IG9wdGlvbnMubWlub3JUaWNrSW50ZXJ2YWw7XG5cblx0XHRcdC8vIEZpbmQgdGhlIHRpY2sgcG9zaXRpb25zXG5cdFx0XHR0aGlzLnRpY2tQb3NpdGlvbnMgPSB0aWNrUG9zaXRpb25zID0gb3B0aW9ucy50aWNrUG9zaXRpb25zICYmIG9wdGlvbnMudGlja1Bvc2l0aW9ucy5zbGljZSgpOyAvLyBXb3JrIG9uIGEgY29weSAoIzE1NjUpXG5cdFx0XHRpZiAoIXRpY2tQb3NpdGlvbnMpIHtcblxuXHRcdFx0XHRpZiAodGhpcy5pc0RhdGV0aW1lQXhpcykge1xuXHRcdFx0XHRcdHRpY2tQb3NpdGlvbnMgPSB0aGlzLmdldFRpbWVUaWNrcyhcblx0XHRcdFx0XHRcdHRoaXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCh0aGlzLnRpY2tJbnRlcnZhbCwgb3B0aW9ucy51bml0cyksXG5cdFx0XHRcdFx0XHR0aGlzLm1pbixcblx0XHRcdFx0XHRcdHRoaXMubWF4LFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdGFydE9mV2Vlayxcblx0XHRcdFx0XHRcdHRoaXMub3JkaW5hbFBvc2l0aW9ucyxcblx0XHRcdFx0XHRcdHRoaXMuY2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzTG9nKSB7XG5cdFx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IHRoaXMuZ2V0TG9nVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCwgdGhpcy5taW4sIHRoaXMubWF4KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aWNrUG9zaXRpb25zID0gdGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50aWNrUG9zaXRpb25zID0gdGlja1Bvc2l0aW9ucztcblxuXHRcdFx0XHQvLyBSdW4gdGhlIHRpY2sgcG9zaXRpb25lciBjYWxsYmFjaywgdGhhdCBhbGxvd3MgbW9kaWZ5aW5nIGF1dG8gdGljayBwb3NpdGlvbnMuXG5cdFx0XHRcdGlmICh0aWNrUG9zaXRpb25lcikge1xuXHRcdFx0XHRcdHRpY2tQb3NpdGlvbmVyID0gdGlja1Bvc2l0aW9uZXIuYXBwbHkodGhpcywgW3RoaXMubWluLCB0aGlzLm1heF0pO1xuXHRcdFx0XHRcdGlmICh0aWNrUG9zaXRpb25lcikge1xuXHRcdFx0XHRcdFx0dGhpcy50aWNrUG9zaXRpb25zID0gdGlja1Bvc2l0aW9ucyA9IHRpY2tQb3NpdGlvbmVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5pc0xpbmtlZCkge1xuXG5cdFx0XHRcdC8vIHJlc2V0IG1pbi9tYXggb3IgcmVtb3ZlIGV4dHJlbWVzIGJhc2VkIG9uIHN0YXJ0L2VuZCBvbiB0aWNrXG5cdFx0XHRcdHRoaXMudHJpbVRpY2tzKHRpY2tQb3NpdGlvbnMsIHN0YXJ0T25UaWNrLCBlbmRPblRpY2spO1xuXG5cdFx0XHRcdC8vIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgcG9pbnQsIG9yIGFsbCBwb2ludHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBvbiB0aGlzIGF4aXMsIHRoZW4gbWluXG5cdFx0XHRcdC8vIGFuZCBtYXggYXJlIGVxdWFsIGFuZCB0aWNrUG9zaXRpb25zLmxlbmd0aCBpcyAwIG9yIDEuIEluIHRoaXMgY2FzZSwgYWRkIHNvbWUgcGFkZGluZ1xuXHRcdFx0XHQvLyBpbiBvcmRlciB0byBjZW50ZXIgdGhlIHBvaW50LCBidXQgbGVhdmUgaXQgd2l0aCBvbmUgdGljay4gIzEzMzcuXG5cdFx0XHRcdGlmICh0aGlzLm1pbiA9PT0gdGhpcy5tYXggJiYgZGVmaW5lZCh0aGlzLm1pbikgJiYgIXRoaXMudGlja0Ftb3VudCkge1xuXHRcdFx0XHRcdC8vIFN1YnN0cmFjdCBoYWxmIGEgdW5pdCAoIzI2MTksICMyODQ2LCAjMjUxNSwgIzMzOTApXG5cdFx0XHRcdFx0c2luZ2xlID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLm1pbiAtPSAwLjU7XG5cdFx0XHRcdFx0dGhpcy5tYXggKz0gMC41O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2luZ2xlID0gc2luZ2xlO1xuXG5cdFx0XHRcdGlmICghdGlja1Bvc2l0aW9uc09wdGlvbiAmJiAhdGlja1Bvc2l0aW9uZXIpIHtcblx0XHRcdFx0XHR0aGlzLmFkanVzdFRpY2tBbW91bnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGUgc3RhcnRPblRpY2sgYW5kIGVuZE9uVGljayBieSBlaXRoZXIgYWRhcHRpbmcgdG8gcGFkZGluZyBtaW4vbWF4IG9yIHJvdW5kZWQgbWluL21heFxuXHRcdCAqL1xuXHRcdHRyaW1UaWNrczogZnVuY3Rpb24gKHRpY2tQb3NpdGlvbnMsIHN0YXJ0T25UaWNrLCBlbmRPblRpY2spIHtcblx0XHRcdHZhciByb3VuZGVkTWluID0gdGlja1Bvc2l0aW9uc1swXSxcblx0XHRcdFx0cm91bmRlZE1heCA9IHRpY2tQb3NpdGlvbnNbdGlja1Bvc2l0aW9ucy5sZW5ndGggLSAxXSxcblx0XHRcdFx0bWluUG9pbnRPZmZzZXQgPSB0aGlzLm1pblBvaW50T2Zmc2V0IHx8IDA7XG5cdFx0XHRcdFxuXHRcdFx0aWYgKHN0YXJ0T25UaWNrKSB7XG5cdFx0XHRcdHRoaXMubWluID0gcm91bmRlZE1pbjtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5taW4gLSBtaW5Qb2ludE9mZnNldCA+IHJvdW5kZWRNaW4pIHtcblx0XHRcdFx0dGlja1Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZW5kT25UaWNrKSB7XG5cdFx0XHRcdHRoaXMubWF4ID0gcm91bmRlZE1heDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5tYXggKyBtaW5Qb2ludE9mZnNldCA8IHJvdW5kZWRNYXgpIHtcblx0XHRcdFx0dGlja1Bvc2l0aW9ucy5wb3AoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm8gdGljayBhcmUgbGVmdCwgc2V0IG9uZSB0aWNrIGluIHRoZSBtaWRkbGUgKCMzMTk1KSBcblx0XHRcdGlmICh0aWNrUG9zaXRpb25zLmxlbmd0aCA9PT0gMCAmJiBkZWZpbmVkKHJvdW5kZWRNaW4pKSB7XG5cdFx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaCgocm91bmRlZE1heCArIHJvdW5kZWRNaW4pIC8gMik7XG5cdFx0XHR9XHRcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIG1heCB0aWNrcyBvZiBlaXRoZXIgdGhlIHggYW5kIHkgYXhpcyBjb2xsZWN0aW9uXG5cdFx0ICovXG5cdFx0Z2V0VGlja0Ftb3VudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG90aGVycyA9IHt9LCAvLyBXaGV0aGVyIHRoZXJlIGlzIGFub3RoZXIgYXhpcyB0byBwYWlyIHdpdGggdGhpcyBvbmVcblx0XHRcdFx0aGFzT3RoZXIsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHRpY2tBbW91bnQgPSBvcHRpb25zLnRpY2tBbW91bnQsXG5cdFx0XHRcdHRpY2tQaXhlbEludGVydmFsID0gb3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbDtcblxuXHRcdFx0aWYgKCFkZWZpbmVkKG9wdGlvbnMudGlja0ludGVydmFsKSAmJiB0aGlzLmxlbiA8IHRpY2tQaXhlbEludGVydmFsICYmICF0aGlzLmlzUmFkaWFsICYmXG5cdFx0XHRcdFx0IXRoaXMuaXNMb2cgJiYgb3B0aW9ucy5zdGFydE9uVGljayAmJiBvcHRpb25zLmVuZE9uVGljaykge1xuXHRcdFx0XHR0aWNrQW1vdW50ID0gMjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aWNrQW1vdW50ICYmIHRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5hbGlnblRpY2tzICE9PSBmYWxzZSAmJiBvcHRpb25zLmFsaWduVGlja3MgIT09IGZhbHNlKSB7XG5cdFx0XHRcdC8vIENoZWNrIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBheGVzIGluIHRoZSBzYW1lIHBhbmVcblx0XHRcdFx0ZWFjaCh0aGlzLmNoYXJ0W3RoaXMuY29sbF0sIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0dmFyIG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRcdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdFx0XHRrZXkgPSBbaG9yaXogPyBvcHRpb25zLmxlZnQgOiBvcHRpb25zLnRvcCwgaG9yaXogPyBvcHRpb25zLndpZHRoIDogb3B0aW9ucy5oZWlnaHQsIG9wdGlvbnMucGFuZV0uam9pbignLCcpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChvdGhlcnNba2V5XSkge1xuXHRcdFx0XHRcdFx0aGFzT3RoZXIgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvdGhlcnNba2V5XSA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoaGFzT3RoZXIpIHtcblx0XHRcdFx0XHQvLyBBZGQgMSBiZWNhdXNlIDQgdGljayBpbnRlcnZhbHMgcmVxdWlyZSA1IHRpY2tzIChpbmNsdWRpbmcgZmlyc3QgYW5kIGxhc3QpXG5cdFx0XHRcdFx0dGlja0Ftb3VudCA9IG1hdGhDZWlsKHRoaXMubGVuIC8gdGlja1BpeGVsSW50ZXJ2YWwpICsgMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgdGljayBhbW91bnRzIG9mIDIgYW5kIDMsIGNvbXB1dGUgZml2ZSB0aWNrcyBhbmQgcmVtb3ZlIHRoZSBpbnRlcm1lZGlhdGUgb25lcy4gVGhpc1xuXHRcdFx0Ly8gcHJldmVudHMgdGhlIGF4aXMgZnJvbSBhZGRpbmcgdGlja3MgdGhhdCBhcmUgdG9vIGZhciBhd2F5IGZyb20gdGhlIGRhdGEgZXh0cmVtZXMuXG5cdFx0XHRpZiAodGlja0Ftb3VudCA8IDQpIHtcblx0XHRcdFx0dGhpcy5maW5hbFRpY2tBbXQgPSB0aWNrQW1vdW50O1xuXHRcdFx0XHR0aWNrQW1vdW50ID0gNTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy50aWNrQW1vdW50ID0gdGlja0Ftb3VudDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiB1c2luZyBtdWx0aXBsZSBheGVzLCBhZGp1c3QgdGhlIG51bWJlciBvZiB0aWNrcyB0byBtYXRjaCB0aGUgaGlnaGVzdFxuXHRcdCAqIG51bWJlciBvZiB0aWNrcyBpbiB0aGF0IGdyb3VwXG5cdFx0ICovXG5cdFx0YWRqdXN0VGlja0Ftb3VudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRpY2tJbnRlcnZhbCA9IHRoaXMudGlja0ludGVydmFsLFxuXHRcdFx0XHR0aWNrUG9zaXRpb25zID0gdGhpcy50aWNrUG9zaXRpb25zLFxuXHRcdFx0XHR0aWNrQW1vdW50ID0gdGhpcy50aWNrQW1vdW50LFxuXHRcdFx0XHRmaW5hbFRpY2tBbXQgPSB0aGlzLmZpbmFsVGlja0FtdCxcblx0XHRcdFx0Y3VycmVudFRpY2tBbW91bnQgPSB0aWNrUG9zaXRpb25zICYmIHRpY2tQb3NpdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRsZW47XG5cblx0XHRcdGlmIChjdXJyZW50VGlja0Ftb3VudCA8IHRpY2tBbW91bnQpIHsgLy8gVE9ETzogQ2hlY2sgIzM0MTFcblx0XHRcdFx0d2hpbGUgKHRpY2tQb3NpdGlvbnMubGVuZ3RoIDwgdGlja0Ftb3VudCkge1xuXHRcdFx0XHRcdHRpY2tQb3NpdGlvbnMucHVzaChjb3JyZWN0RmxvYXQoXG5cdFx0XHRcdFx0XHR0aWNrUG9zaXRpb25zW3RpY2tQb3NpdGlvbnMubGVuZ3RoIC0gMV0gKyB0aWNrSW50ZXJ2YWxcblx0XHRcdFx0XHQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnRyYW5zQSAqPSAoY3VycmVudFRpY2tBbW91bnQgLSAxKSAvICh0aWNrQW1vdW50IC0gMSk7XG5cdFx0XHRcdHRoaXMubWF4ID0gdGlja1Bvc2l0aW9uc1t0aWNrUG9zaXRpb25zLmxlbmd0aCAtIDFdO1xuXG5cdFx0XHQvLyBXZSBoYXZlIHRvbyBtYW55IHRpY2tzLCBydW4gc2Vjb25kIHBhc3MgdG8gdHJ5IHRvIHJlZHVjZSB0aWNrc1xuXHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VGlja0Ftb3VudCA+IHRpY2tBbW91bnQpIHtcblx0XHRcdFx0dGhpcy50aWNrSW50ZXJ2YWwgKj0gMjtcblx0XHRcdFx0dGhpcy5zZXRUaWNrUG9zaXRpb25zKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBmaW5hbFRpY2tBbXQgcHJvcGVydHkgaXMgc2V0IGluIGdldFRpY2tBbW91bnRcblx0XHRcdGlmIChkZWZpbmVkKGZpbmFsVGlja0FtdCkpIHtcblx0XHRcdFx0aSA9IGxlbiA9IHRpY2tQb3NpdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0KGZpbmFsVGlja0FtdCA9PT0gMyAmJiBpICUgMiA9PT0gMSkgfHwgLy8gUmVtb3ZlIGV2ZXJ5IG90aGVyIHRpY2tcblx0XHRcdFx0XHRcdChmaW5hbFRpY2tBbXQgPD0gMiAmJiBpID4gMCAmJiBpIDwgbGVuIC0gMSkgLy8gUmVtb3ZlIGFsbCBidXQgZmlyc3QgYW5kIGxhc3Rcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHRpY2tQb3NpdGlvbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cdFxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZmluYWxUaWNrQW10ID0gVU5ERUZJTkVEO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHNjYWxlIGJhc2VkIG9uIGRhdGEgbWluIGFuZCBtYXgsIHVzZXIgc2V0IG1pbiBhbmQgbWF4IG9yIG9wdGlvbnNcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHNldFNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdHN0YWNrcyA9IGF4aXMuc3RhY2tzLFxuXHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRpc0RpcnR5RGF0YSxcblx0XHRcdFx0aXNEaXJ0eUF4aXNMZW5ndGg7XG5cblx0XHRcdGF4aXMub2xkTWluID0gYXhpcy5taW47XG5cdFx0XHRheGlzLm9sZE1heCA9IGF4aXMubWF4O1xuXHRcdFx0YXhpcy5vbGRBeGlzTGVuZ3RoID0gYXhpcy5sZW47XG5cblx0XHRcdC8vIHNldCB0aGUgbmV3IGF4aXNMZW5ndGhcblx0XHRcdGF4aXMuc2V0QXhpc1NpemUoKTtcblx0XHRcdC8vYXhpc0xlbmd0aCA9IGhvcml6ID8gYXhpc1dpZHRoIDogYXhpc0hlaWdodDtcblx0XHRcdGlzRGlydHlBeGlzTGVuZ3RoID0gYXhpcy5sZW4gIT09IGF4aXMub2xkQXhpc0xlbmd0aDtcblxuXHRcdFx0Ly8gaXMgdGhlcmUgbmV3IGRhdGE/XG5cdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdGlmIChzZXJpZXMuaXNEaXJ0eURhdGEgfHwgc2VyaWVzLmlzRGlydHkgfHxcblx0XHRcdFx0XHRcdHNlcmllcy54QXhpcy5pc0RpcnR5KSB7IC8vIHdoZW4geCBheGlzIGlzIGRpcnR5LCB3ZSBuZWVkIG5ldyBkYXRhIGV4dHJlbWVzIGZvciB5IGFzIHdlbGxcblx0XHRcdFx0XHRpc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBkbyB3ZSByZWFsbHkgbmVlZCB0byBnbyB0aHJvdWdoIGFsbCB0aGlzP1xuXHRcdFx0aWYgKGlzRGlydHlBeGlzTGVuZ3RoIHx8IGlzRGlydHlEYXRhIHx8IGF4aXMuaXNMaW5rZWQgfHwgYXhpcy5mb3JjZVJlZHJhdyB8fFxuXHRcdFx0XHRheGlzLnVzZXJNaW4gIT09IGF4aXMub2xkVXNlck1pbiB8fCBheGlzLnVzZXJNYXggIT09IGF4aXMub2xkVXNlck1heCkge1xuXG5cdFx0XHRcdC8vIHJlc2V0IHN0YWNrc1xuXHRcdFx0XHRpZiAoIWF4aXMuaXNYQXhpcykge1xuXHRcdFx0XHRcdGZvciAodHlwZSBpbiBzdGFja3MpIHtcblx0XHRcdFx0XHRcdGZvciAoaSBpbiBzdGFja3NbdHlwZV0pIHtcblx0XHRcdFx0XHRcdFx0c3RhY2tzW3R5cGVdW2ldLnRvdGFsID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0c3RhY2tzW3R5cGVdW2ldLmN1bSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXhpcy5mb3JjZVJlZHJhdyA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIGdldCBkYXRhIGV4dHJlbWVzIGlmIG5lZWRlZFxuXHRcdFx0XHRheGlzLmdldFNlcmllc0V4dHJlbWVzKCk7XG5cblx0XHRcdFx0Ly8gZ2V0IGZpeGVkIHBvc2l0aW9ucyBiYXNlZCBvbiB0aWNrSW50ZXJ2YWxcblx0XHRcdFx0YXhpcy5zZXRUaWNrSW50ZXJ2YWwoKTtcblxuXHRcdFx0XHQvLyByZWNvcmQgb2xkIHZhbHVlcyB0byBkZWNpZGUgd2hldGhlciBhIHJlc2NhbGUgaXMgbmVjZXNzYXJ5IGxhdGVyIG9uICgjNTQwKVxuXHRcdFx0XHRheGlzLm9sZFVzZXJNaW4gPSBheGlzLnVzZXJNaW47XG5cdFx0XHRcdGF4aXMub2xkVXNlck1heCA9IGF4aXMudXNlck1heDtcblxuXHRcdFx0XHQvLyBNYXJrIGFzIGRpcnR5IGlmIGl0IGlzIG5vdCBhbHJlYWR5IHNldCB0byBkaXJ0eSBhbmQgZXh0cmVtZXMgaGF2ZSBjaGFuZ2VkLiAjNTk1LlxuXHRcdFx0XHRpZiAoIWF4aXMuaXNEaXJ0eSkge1xuXHRcdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IGlzRGlydHlBeGlzTGVuZ3RoIHx8IGF4aXMubWluICE9PSBheGlzLm9sZE1pbiB8fCBheGlzLm1heCAhPT0gYXhpcy5vbGRNYXg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIWF4aXMuaXNYQXhpcykge1xuXHRcdFx0XHRpZiAoYXhpcy5vbGRTdGFja3MpIHtcblx0XHRcdFx0XHRzdGFja3MgPSBheGlzLnN0YWNrcyA9IGF4aXMub2xkU3RhY2tzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzZXQgc3RhY2tzXG5cdFx0XHRcdGZvciAodHlwZSBpbiBzdGFja3MpIHtcblx0XHRcdFx0XHRmb3IgKGkgaW4gc3RhY2tzW3R5cGVdKSB7XG5cdFx0XHRcdFx0XHRzdGFja3NbdHlwZV1baV0uY3VtID0gc3RhY2tzW3R5cGVdW2ldLnRvdGFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGV4dHJlbWVzIGFuZCBvcHRpb25hbGx5IHJlZHJhd1xuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBuZXdNaW5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gbmV3TWF4XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXdcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBhbmltYXRpb24gV2hldGhlciB0byBhcHBseSBhbmltYXRpb24sIGFuZCBvcHRpb25hbGx5IGFuaW1hdGlvblxuXHRcdCAqICAgIGNvbmZpZ3VyYXRpb25cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRBcmd1bWVudHNcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHNldEV4dHJlbWVzOiBmdW5jdGlvbiAobmV3TWluLCBuZXdNYXgsIHJlZHJhdywgYW5pbWF0aW9uLCBldmVudEFyZ3VtZW50cykge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQ7XG5cblx0XHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTsgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuXG5cdFx0XHRlYWNoKGF4aXMuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdFx0ZGVsZXRlIHNlcmllLmtkVHJlZTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGFyZ3VtZW50cyB3aXRoIG1pbiBhbmQgbWF4XG5cdFx0XHRldmVudEFyZ3VtZW50cyA9IGV4dGVuZChldmVudEFyZ3VtZW50cywge1xuXHRcdFx0XHRtaW46IG5ld01pbixcblx0XHRcdFx0bWF4OiBuZXdNYXhcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBGaXJlIHRoZSBldmVudFxuXHRcdFx0ZmlyZUV2ZW50KGF4aXMsICdzZXRFeHRyZW1lcycsIGV2ZW50QXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7IC8vIHRoZSBkZWZhdWx0IGV2ZW50IGhhbmRsZXJcblxuXHRcdFx0XHRheGlzLnVzZXJNaW4gPSBuZXdNaW47XG5cdFx0XHRcdGF4aXMudXNlck1heCA9IG5ld01heDtcblx0XHRcdFx0YXhpcy5ldmVudEFyZ3MgPSBldmVudEFyZ3VtZW50cztcblxuXHRcdFx0XHQvLyBNYXJrIGZvciBydW5uaW5nIGFmdGVyU2V0RXh0cmVtZXNcblx0XHRcdFx0YXhpcy5pc0RpcnR5RXh0cmVtZXMgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBPdmVycmlkYWJsZSBtZXRob2QgZm9yIHpvb21pbmcgY2hhcnQuIFB1bGxlZCBvdXQgaW4gYSBzZXBhcmF0ZSBtZXRob2QgdG8gYWxsb3cgb3ZlcnJpZGluZ1xuXHRcdCAqIGluIHN0b2NrIGNoYXJ0cy5cblx0XHQgKi9cblx0XHR6b29tOiBmdW5jdGlvbiAobmV3TWluLCBuZXdNYXgpIHtcblx0XHRcdHZhciBkYXRhTWluID0gdGhpcy5kYXRhTWluLFxuXHRcdFx0XHRkYXRhTWF4ID0gdGhpcy5kYXRhTWF4LFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0XHQvLyBQcmV2ZW50IHBpbmNoIHpvb21pbmcgb3V0IG9mIHJhbmdlLiBDaGVjayBmb3IgZGVmaW5lZCBpcyBmb3IgIzE5NDYuICMxNzM0LlxuXHRcdFx0aWYgKCF0aGlzLmFsbG93Wm9vbU91dHNpZGUpIHtcblx0XHRcdFx0aWYgKGRlZmluZWQoZGF0YU1pbikgJiYgbmV3TWluIDw9IG1hdGhNaW4oZGF0YU1pbiwgcGljayhvcHRpb25zLm1pbiwgZGF0YU1pbikpKSB7XG5cdFx0XHRcdFx0bmV3TWluID0gVU5ERUZJTkVEO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkZWZpbmVkKGRhdGFNYXgpICYmIG5ld01heCA+PSBtYXRoTWF4KGRhdGFNYXgsIHBpY2sob3B0aW9ucy5tYXgsIGRhdGFNYXgpKSkge1xuXHRcdFx0XHRcdG5ld01heCA9IFVOREVGSU5FRDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbiBmdWxsIHZpZXcsIGRpc3BsYXlpbmcgdGhlIHJlc2V0IHpvb20gYnV0dG9uIGlzIG5vdCByZXF1aXJlZFxuXHRcdFx0dGhpcy5kaXNwbGF5QnRuID0gbmV3TWluICE9PSBVTkRFRklORUQgfHwgbmV3TWF4ICE9PSBVTkRFRklORUQ7XG5cblx0XHRcdC8vIERvIGl0XG5cdFx0XHR0aGlzLnNldEV4dHJlbWVzKFxuXHRcdFx0XHRuZXdNaW4sXG5cdFx0XHRcdG5ld01heCxcblx0XHRcdFx0ZmFsc2UsXG5cdFx0XHRcdFVOREVGSU5FRCxcblx0XHRcdFx0eyB0cmlnZ2VyOiAnem9vbScgfVxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgdGhlIGF4aXMgbWV0cmljc1xuXHRcdCAqL1xuXHRcdHNldEF4aXNTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRvZmZzZXRMZWZ0ID0gb3B0aW9ucy5vZmZzZXRMZWZ0IHx8IDAsXG5cdFx0XHRcdG9mZnNldFJpZ2h0ID0gb3B0aW9ucy5vZmZzZXRSaWdodCB8fCAwLFxuXHRcdFx0XHRob3JpeiA9IHRoaXMuaG9yaXosXG5cdFx0XHRcdHdpZHRoID0gcGljayhvcHRpb25zLndpZHRoLCBjaGFydC5wbG90V2lkdGggLSBvZmZzZXRMZWZ0ICsgb2Zmc2V0UmlnaHQpLFxuXHRcdFx0XHRoZWlnaHQgPSBwaWNrKG9wdGlvbnMuaGVpZ2h0LCBjaGFydC5wbG90SGVpZ2h0KSxcblx0XHRcdFx0dG9wID0gcGljayhvcHRpb25zLnRvcCwgY2hhcnQucGxvdFRvcCksXG5cdFx0XHRcdGxlZnQgPSBwaWNrKG9wdGlvbnMubGVmdCwgY2hhcnQucGxvdExlZnQgKyBvZmZzZXRMZWZ0KSxcblx0XHRcdFx0cGVyY2VudFJlZ2V4ID0gLyUkLztcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHBlcmNlbnRhZ2UgYmFzZWQgaW5wdXQgdmFsdWVzXG5cdFx0XHRpZiAocGVyY2VudFJlZ2V4LnRlc3QoaGVpZ2h0KSkge1xuXHRcdFx0XHRoZWlnaHQgPSBwYXJzZUZsb2F0KGhlaWdodCkgLyAxMDAgKiBjaGFydC5wbG90SGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBlcmNlbnRSZWdleC50ZXN0KHRvcCkpIHtcblx0XHRcdFx0dG9wID0gcGFyc2VGbG9hdCh0b3ApIC8gMTAwICogY2hhcnQucGxvdEhlaWdodCArIGNoYXJ0LnBsb3RUb3A7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEV4cG9zZSBiYXNpYyB2YWx1ZXMgdG8gdXNlIGluIFNlcmllcyBvYmplY3QgYW5kIG5hdmlnYXRvclxuXHRcdFx0dGhpcy5sZWZ0ID0gbGVmdDtcblx0XHRcdHRoaXMudG9wID0gdG9wO1xuXHRcdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHR0aGlzLmJvdHRvbSA9IGNoYXJ0LmNoYXJ0SGVpZ2h0IC0gaGVpZ2h0IC0gdG9wO1xuXHRcdFx0dGhpcy5yaWdodCA9IGNoYXJ0LmNoYXJ0V2lkdGggLSB3aWR0aCAtIGxlZnQ7XG5cblx0XHRcdC8vIERpcmVjdGlvbiBhZ25vc3RpYyBwcm9wZXJ0aWVzXG5cdFx0XHR0aGlzLmxlbiA9IG1hdGhNYXgoaG9yaXogPyB3aWR0aCA6IGhlaWdodCwgMCk7IC8vIG1hdGhNYXggZml4ZXMgIzkwNVxuXHRcdFx0dGhpcy5wb3MgPSBob3JpeiA/IGxlZnQgOiB0b3A7IC8vIGRpc3RhbmNlIGZyb20gU1ZHIG9yaWdpblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGFjdHVhbCBheGlzIGV4dHJlbWVzXG5cdFx0ICovXG5cdFx0Z2V0RXh0cmVtZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdFx0aXNMb2cgPSBheGlzLmlzTG9nO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtaW46IGlzTG9nID8gY29ycmVjdEZsb2F0KGxpbjJsb2coYXhpcy5taW4pKSA6IGF4aXMubWluLFxuXHRcdFx0XHRtYXg6IGlzTG9nID8gY29ycmVjdEZsb2F0KGxpbjJsb2coYXhpcy5tYXgpKSA6IGF4aXMubWF4LFxuXHRcdFx0XHRkYXRhTWluOiBheGlzLmRhdGFNaW4sXG5cdFx0XHRcdGRhdGFNYXg6IGF4aXMuZGF0YU1heCxcblx0XHRcdFx0dXNlck1pbjogYXhpcy51c2VyTWluLFxuXHRcdFx0XHR1c2VyTWF4OiBheGlzLnVzZXJNYXhcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgemVybyBwbGFuZSBlaXRoZXIgYmFzZWQgb24gemVybyBvciBvbiB0aGUgbWluIG9yIG1heCB2YWx1ZS5cblx0XHQgKiBVc2VkIGluIGJhciBhbmQgYXJlYSBwbG90c1xuXHRcdCAqL1xuXHRcdGdldFRocmVzaG9sZDogZnVuY3Rpb24gKHRocmVzaG9sZCkge1xuXHRcdFx0dmFyIGF4aXMgPSB0aGlzLFxuXHRcdFx0XHRpc0xvZyA9IGF4aXMuaXNMb2c7XG5cblx0XHRcdHZhciByZWFsTWluID0gaXNMb2cgPyBsaW4ybG9nKGF4aXMubWluKSA6IGF4aXMubWluLFxuXHRcdFx0XHRyZWFsTWF4ID0gaXNMb2cgPyBsaW4ybG9nKGF4aXMubWF4KSA6IGF4aXMubWF4O1xuXG5cdFx0XHRpZiAocmVhbE1pbiA+IHRocmVzaG9sZCB8fCB0aHJlc2hvbGQgPT09IG51bGwpIHtcblx0XHRcdFx0dGhyZXNob2xkID0gcmVhbE1pbjtcblx0XHRcdH0gZWxzZSBpZiAocmVhbE1heCA8IHRocmVzaG9sZCkge1xuXHRcdFx0XHR0aHJlc2hvbGQgPSByZWFsTWF4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXhpcy50cmFuc2xhdGUodGhyZXNob2xkLCAwLCAxLCAwLCAxKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ29tcHV0ZSBhdXRvIGFsaWdubWVudCBmb3IgdGhlIGF4aXMgbGFiZWwgYmFzZWQgb24gd2hpY2ggc2lkZSB0aGUgYXhpcyBpcyBvblxuXHRcdCAqIGFuZCB0aGUgZ2l2ZW4gcm90YXRpb24gZm9yIHRoZSBsYWJlbFxuXHRcdCAqL1xuXHRcdGF1dG9MYWJlbEFsaWduOiBmdW5jdGlvbiAocm90YXRpb24pIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdGFuZ2xlID0gKHBpY2socm90YXRpb24sIDApIC0gKHRoaXMuc2lkZSAqIDkwKSArIDcyMCkgJSAzNjA7XG5cblx0XHRcdGlmIChhbmdsZSA+IDE1ICYmIGFuZ2xlIDwgMTY1KSB7XG5cdFx0XHRcdHJldCA9ICdyaWdodCc7XG5cdFx0XHR9IGVsc2UgaWYgKGFuZ2xlID4gMTk1ICYmIGFuZ2xlIDwgMzQ1KSB7XG5cdFx0XHRcdHJldCA9ICdsZWZ0Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldCA9ICdjZW50ZXInO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUHJldmVudCB0aGUgdGlja3MgZnJvbSBnZXR0aW5nIHNvIGNsb3NlIHdlIGNhbid0IGRyYXcgdGhlIGxhYmVscy4gT24gYSBob3Jpem9udGFsXG5cdFx0ICogYXhpcywgdGhpcyBpcyBoYW5kbGVkIGJ5IHJvdGF0aW5nIHRoZSBsYWJlbHMsIHJlbW92aW5nIHRpY2tzIGFuZCBhZGRpbmcgZWxsaXBzaXMuIFxuXHRcdCAqIE9uIGEgdmVydGljYWwgYXhpcyByZW1vdmUgdGlja3MgYW5kIGFkZCBlbGxpcHNpcy5cblx0XHQgKi9cblx0XHR1bnNxdWlzaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0dGlja3MgPSB0aGlzLnRpY2tzLFxuXHRcdFx0XHRsYWJlbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubGFiZWxzLFxuXHRcdFx0XHRob3JpeiA9IHRoaXMuaG9yaXosXG5cdFx0XHRcdHRpY2tJbnRlcnZhbCA9IHRoaXMudGlja0ludGVydmFsLFxuXHRcdFx0XHRuZXdUaWNrSW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWwsXG5cdFx0XHRcdHNsb3RTaXplID0gdGhpcy5sZW4gLyAoKCh0aGlzLmNhdGVnb3JpZXMgPyAxIDogMCkgKyB0aGlzLm1heCAtIHRoaXMubWluKSAvIHRpY2tJbnRlcnZhbCksXG5cdFx0XHRcdHJvdGF0aW9uLFxuXHRcdFx0XHRyb3RhdGlvbk9wdGlvbiA9IGxhYmVsT3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdFx0bGFiZWxNZXRyaWNzID0gY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3MobGFiZWxPcHRpb25zLnN0eWxlLmZvbnRTaXplLCB0aWNrc1swXSAmJiB0aWNrc1swXS5sYWJlbCksXG5cdFx0XHRcdHN0ZXAsXG5cdFx0XHRcdGJlc3RTY29yZSA9IE51bWJlci5NQVhfVkFMVUUsXG5cdFx0XHRcdGF1dG9Sb3RhdGlvbixcblx0XHRcdFx0Ly8gUmV0dXJuIHRoZSBtdWx0aXBsZSBvZiB0aWNrSW50ZXJ2YWwgdGhhdCBpcyBuZWVkZWQgdG8gYXZvaWQgY29sbGlzaW9uXG5cdFx0XHRcdGdldFN0ZXAgPSBmdW5jdGlvbiAoc3BhY2VOZWVkZWQpIHtcblx0XHRcdFx0XHR2YXIgc3RlcCA9IHNwYWNlTmVlZGVkIC8gKHNsb3RTaXplIHx8IDEpO1xuXHRcdFx0XHRcdHN0ZXAgPSBzdGVwID4gMSA/IG1hdGhDZWlsKHN0ZXApIDogMTtcblx0XHRcdFx0XHRyZXR1cm4gc3RlcCAqIHRpY2tJbnRlcnZhbDtcblx0XHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0aWYgKGhvcml6KSB7XG5cdFx0XHRcdGF1dG9Sb3RhdGlvbiA9IGRlZmluZWQocm90YXRpb25PcHRpb24pID8gXG5cdFx0XHRcdFx0W3JvdGF0aW9uT3B0aW9uXSA6XG5cdFx0XHRcdFx0c2xvdFNpemUgPCA4MCAmJiAhbGFiZWxPcHRpb25zLnN0YWdnZXJMaW5lcyAmJiAhbGFiZWxPcHRpb25zLnN0ZXAgJiYgbGFiZWxPcHRpb25zLmF1dG9Sb3RhdGlvbjtcblxuXHRcdFx0XHRpZiAoYXV0b1JvdGF0aW9uKSB7XG5cblx0XHRcdFx0XHQvLyBMb29wIG92ZXIgdGhlIGdpdmVuIGF1dG9Sb3RhdGlvbiBvcHRpb25zLCBhbmQgZGV0ZXJtaW5lIHdoaWNoIGdpdmVzIHRoZSBiZXN0IHNjb3JlLiBUaGUgXG5cdFx0XHRcdFx0Ly8gYmVzdCBzY29yZSBpcyB0aGF0IHdpdGggdGhlIGxvd2VzdCBudW1iZXIgb2Ygc3RlcHMgYW5kIGEgcm90YXRpb24gY2xvc2VzdCB0byBob3Jpem9udGFsLlxuXHRcdFx0XHRcdGVhY2goYXV0b1JvdGF0aW9uLCBmdW5jdGlvbiAocm90KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2NvcmU7XG5cblx0XHRcdFx0XHRcdGlmIChyb3QgPT09IHJvdGF0aW9uT3B0aW9uIHx8IChyb3QgJiYgcm90ID49IC05MCAmJiByb3QgPD0gOTApKSB7IC8vICMzODkxXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0c3RlcCA9IGdldFN0ZXAobWF0aEFicyhsYWJlbE1ldHJpY3MuaCAvIG1hdGhTaW4oZGVnMnJhZCAqIHJvdCkpKTtcblxuXHRcdFx0XHRcdFx0XHRzY29yZSA9IHN0ZXAgKyBtYXRoQWJzKHJvdCAvIDM2MCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHNjb3JlIDwgYmVzdFNjb3JlKSB7XG5cdFx0XHRcdFx0XHRcdFx0YmVzdFNjb3JlID0gc2NvcmU7XG5cdFx0XHRcdFx0XHRcdFx0cm90YXRpb24gPSByb3Q7XG5cdFx0XHRcdFx0XHRcdFx0bmV3VGlja0ludGVydmFsID0gc3RlcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1RpY2tJbnRlcnZhbCA9IGdldFN0ZXAobGFiZWxNZXRyaWNzLmgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmF1dG9Sb3RhdGlvbiA9IGF1dG9Sb3RhdGlvbjtcblx0XHRcdHRoaXMubGFiZWxSb3RhdGlvbiA9IHJvdGF0aW9uO1xuXG5cdFx0XHRyZXR1cm4gbmV3VGlja0ludGVydmFsO1xuXHRcdH0sXG5cblx0XHRyZW5kZXJVbnNxdWlzaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IHRoaXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0dGlja3MgPSB0aGlzLnRpY2tzLFxuXHRcdFx0XHRsYWJlbE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMubGFiZWxzLFxuXHRcdFx0XHRob3JpeiA9IHRoaXMuaG9yaXosXG5cdFx0XHRcdG1hcmdpbiA9IGNoYXJ0Lm1hcmdpbixcblx0XHRcdFx0c2xvdFdpZHRoID0gdGhpcy5zbG90V2lkdGggPSAoaG9yaXogJiYgIWxhYmVsT3B0aW9ucy5zdGVwICYmICFsYWJlbE9wdGlvbnMucm90YXRpb24gJiZcblx0XHRcdFx0XHQoKHRoaXMuc3RhZ2dlckxpbmVzIHx8IDEpICogY2hhcnQucGxvdFdpZHRoKSAvIHRpY2tQb3NpdGlvbnMubGVuZ3RoKSB8fFxuXHRcdFx0XHRcdCghaG9yaXogJiYgKChtYXJnaW5bM10gJiYgKG1hcmdpblszXSAtIGNoYXJ0LnNwYWNpbmdbM10pKSB8fCBjaGFydC5jaGFydFdpZHRoICogMC4zMykpLCAvLyAjMTU4MCwgIzE5MzEsXG5cdFx0XHRcdGlubmVyV2lkdGggPSBtYXRoTWF4KDEsIG1hdGhSb3VuZChzbG90V2lkdGggLSAyICogKGxhYmVsT3B0aW9ucy5wYWRkaW5nIHx8IDUpKSksXG5cdFx0XHRcdGF0dHIgPSB7fSxcblx0XHRcdFx0bGFiZWxNZXRyaWNzID0gcmVuZGVyZXIuZm9udE1ldHJpY3MobGFiZWxPcHRpb25zLnN0eWxlLmZvbnRTaXplLCB0aWNrc1swXSAmJiB0aWNrc1swXS5sYWJlbCksXG5cdFx0XHRcdGNzcyxcblx0XHRcdFx0bGFiZWxMZW5ndGggPSAwLFxuXHRcdFx0XHRsYWJlbCxcblx0XHRcdFx0aSxcblx0XHRcdFx0cG9zO1xuXG5cdFx0XHQvLyBTZXQgcm90YXRpb24gb3B0aW9uIHVubGVzcyBpdCBpcyBcImF1dG9cIiwgbGlrZSBpbiBnYXVnZXNcblx0XHRcdGlmICghaXNTdHJpbmcobGFiZWxPcHRpb25zLnJvdGF0aW9uKSkge1xuXHRcdFx0XHRhdHRyLnJvdGF0aW9uID0gbGFiZWxPcHRpb25zLnJvdGF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBIYW5kbGUgYXV0byByb3RhdGlvbiBvbiBob3Jpem9udGFsIGF4aXNcblx0XHRcdGlmICh0aGlzLmF1dG9Sb3RhdGlvbikge1xuXG5cdFx0XHRcdC8vIEdldCB0aGUgbG9uZ2VzdCBsYWJlbCBsZW5ndGhcblx0XHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAodGljaykge1xuXHRcdFx0XHRcdHRpY2sgPSB0aWNrc1t0aWNrXTtcblx0XHRcdFx0XHRpZiAodGljayAmJiB0aWNrLmxhYmVsTGVuZ3RoID4gbGFiZWxMZW5ndGgpIHtcblx0XHRcdFx0XHRcdGxhYmVsTGVuZ3RoID0gdGljay5sYWJlbExlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQXBwbHkgcm90YXRpb24gb25seSBpZiB0aGUgbGFiZWwgaXMgdG9vIHdpZGUgZm9yIHRoZSBzbG90LCBhbmRcblx0XHRcdFx0Ly8gdGhlIGxhYmVsIGlzIHdpZGVyIHRoYW4gaXRzIGhlaWdodC5cblx0XHRcdFx0aWYgKGxhYmVsTGVuZ3RoID4gaW5uZXJXaWR0aCAmJiBsYWJlbExlbmd0aCA+IGxhYmVsTWV0cmljcy5oKSB7XG5cdFx0XHRcdFx0YXR0ci5yb3RhdGlvbiA9IHRoaXMubGFiZWxSb3RhdGlvbjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmxhYmVsUm90YXRpb24gPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSB3b3JkLXdyYXAgb3IgZWxsaXBzaXMgb24gdmVydGljYWwgYXhpc1xuXHRcdFx0fSBlbHNlIGlmIChzbG90V2lkdGgpIHtcblx0XHRcdFx0Ly8gRm9yIHdvcmQtd3JhcCBvciBlbGxpcHNpc1xuXHRcdFx0XHRjc3MgPSB7IHdpZHRoOiBpbm5lcldpZHRoICsgUFgsIHRleHRPdmVyZmxvdzogJ2NsaXAnIH07XG5cblx0XHRcdFx0Ly8gT24gdmVydGljYWwgYXhpcywgb25seSBhbGxvdyB3b3JkIHdyYXAgaWYgdGhlcmUgaXMgcm9vbSBmb3IgbW9yZSBsaW5lcy5cblx0XHRcdFx0aSA9IHRpY2tQb3NpdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIWhvcml6ICYmIGktLSkge1xuXHRcdFx0XHRcdHBvcyA9IHRpY2tQb3NpdGlvbnNbaV07XG5cdFx0XHRcdFx0bGFiZWwgPSB0aWNrc1twb3NdLmxhYmVsO1xuXHRcdFx0XHRcdGlmIChsYWJlbCkge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubGVuIC8gdGlja1Bvc2l0aW9ucy5sZW5ndGggLSA0IDwgbGFiZWwuZ2V0QkJveCgpLmhlaWdodCkge1xuXHRcdFx0XHRcdFx0XHRsYWJlbC5zcGVjQ3NzID0geyB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycgfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBBZGQgZWxsaXBzaXMgaWYgdGhlIGxhYmVsIGxlbmd0aCBpcyBzaWduaWZpY2FudGx5IGxvbmdlciB0aGFuIGlkZWFsXG5cdFx0XHRpZiAoYXR0ci5yb3RhdGlvbikge1xuXHRcdFx0XHRjc3MgPSB7IFxuXHRcdFx0XHRcdHdpZHRoOiAobGFiZWxMZW5ndGggPiBjaGFydC5jaGFydEhlaWdodCAqIDAuNSA/IGNoYXJ0LmNoYXJ0SGVpZ2h0ICogMC4zMyA6IGNoYXJ0LmNoYXJ0SGVpZ2h0KSArIFBYLFxuXHRcdFx0XHRcdHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGV4cGxpY2l0IG9yIGF1dG9tYXRpYyBsYWJlbCBhbGlnbm1lbnRcblx0XHRcdHRoaXMubGFiZWxBbGlnbiA9IGF0dHIuYWxpZ24gPSBsYWJlbE9wdGlvbnMuYWxpZ24gfHwgdGhpcy5hdXRvTGFiZWxBbGlnbih0aGlzLmxhYmVsUm90YXRpb24pO1xuXG5cdFx0XHQvLyBBcHBseSBnZW5lcmFsIGFuZCBzcGVjaWZpYyBDU1Ncblx0XHRcdGVhY2godGlja1Bvc2l0aW9ucywgZnVuY3Rpb24gKHBvcykge1xuXHRcdFx0XHR2YXIgdGljayA9IHRpY2tzW3Bvc10sXG5cdFx0XHRcdFx0bGFiZWwgPSB0aWNrICYmIHRpY2subGFiZWw7XG5cdFx0XHRcdGlmIChsYWJlbCkge1xuXHRcdFx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0XHRcdGxhYmVsLmNzcyhtZXJnZShjc3MsIGxhYmVsLnNwZWNDc3MpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVsZXRlIGxhYmVsLnNwZWNDc3M7XG5cdFx0XHRcdFx0bGFiZWwuYXR0cihhdHRyKTtcblx0XHRcdFx0XHR0aWNrLnJvdGF0aW9uID0gYXR0ci5yb3RhdGlvbjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFRPRE86IFdoeSBub3QgcGFydCBvZiBnZXRMYWJlbFBvc2l0aW9uP1xuXHRcdFx0dGhpcy50aWNrUm90Q29yciA9IHJlbmRlcmVyLnJvdENvcnIobGFiZWxNZXRyaWNzLmIsIHRoaXMubGFiZWxSb3RhdGlvbiB8fCAwLCB0aGlzLnNpZGUgPT09IDIpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgdGhlIHRpY2sgbGFiZWxzIHRvIGEgcHJlbGltaW5hcnkgcG9zaXRpb24gdG8gZ2V0IHRoZWlyIHNpemVzXG5cdFx0ICovXG5cdFx0Z2V0T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0b3B0aW9ucyA9IGF4aXMub3B0aW9ucyxcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IGF4aXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0dGlja3MgPSBheGlzLnRpY2tzLFxuXHRcdFx0XHRob3JpeiA9IGF4aXMuaG9yaXosXG5cdFx0XHRcdHNpZGUgPSBheGlzLnNpZGUsXG5cdFx0XHRcdGludmVydGVkU2lkZSA9IGNoYXJ0LmludmVydGVkID8gWzEsIDAsIDMsIDJdW3NpZGVdIDogc2lkZSxcblx0XHRcdFx0aGFzRGF0YSxcblx0XHRcdFx0c2hvd0F4aXMsXG5cdFx0XHRcdHRpdGxlT2Zmc2V0ID0gMCxcblx0XHRcdFx0dGl0bGVPZmZzZXRPcHRpb24sXG5cdFx0XHRcdHRpdGxlTWFyZ2luID0gMCxcblx0XHRcdFx0YXhpc1RpdGxlT3B0aW9ucyA9IG9wdGlvbnMudGl0bGUsXG5cdFx0XHRcdGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWxzLFxuXHRcdFx0XHRsYWJlbE9mZnNldCA9IDAsIC8vIHJlc2V0XG5cdFx0XHRcdGxhYmVsT2Zmc2V0UGFkZGVkLFxuXHRcdFx0XHRheGlzT2Zmc2V0ID0gY2hhcnQuYXhpc09mZnNldCxcblx0XHRcdFx0Y2xpcE9mZnNldCA9IGNoYXJ0LmNsaXBPZmZzZXQsXG5cdFx0XHRcdGRpcmVjdGlvbkZhY3RvciA9IFstMSwgMSwgMSwgLTFdW3NpZGVdLFxuXHRcdFx0XHRuLFxuXHRcdFx0XHRsaW5lSGVpZ2h0Q29ycmVjdGlvbjtcblxuXHRcdFx0Ly8gRm9yIHJldXNlIGluIEF4aXMucmVuZGVyXG5cdFx0XHRheGlzLmhhc0RhdGEgPSBoYXNEYXRhID0gKGF4aXMuaGFzVmlzaWJsZVNlcmllcyB8fCAoZGVmaW5lZChheGlzLm1pbikgJiYgZGVmaW5lZChheGlzLm1heCkgJiYgISF0aWNrUG9zaXRpb25zKSk7XG5cdFx0XHRheGlzLnNob3dBeGlzID0gc2hvd0F4aXMgPSBoYXNEYXRhIHx8IHBpY2sob3B0aW9ucy5zaG93RW1wdHksIHRydWUpO1xuXG5cdFx0XHQvLyBTZXQvcmVzZXQgc3RhZ2dlckxpbmVzXG5cdFx0XHRheGlzLnN0YWdnZXJMaW5lcyA9IGF4aXMuaG9yaXogJiYgbGFiZWxPcHRpb25zLnN0YWdnZXJMaW5lcztcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBheGlzR3JvdXAgYW5kIGdyaWRHcm91cCBlbGVtZW50cyBvbiBmaXJzdCBpdGVyYXRpb25cblx0XHRcdGlmICghYXhpcy5heGlzR3JvdXApIHtcblx0XHRcdFx0YXhpcy5ncmlkR3JvdXAgPSByZW5kZXJlci5nKCdncmlkJylcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogb3B0aW9ucy5ncmlkWkluZGV4IHx8IDEgfSlcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdGF4aXMuYXhpc0dyb3VwID0gcmVuZGVyZXIuZygnYXhpcycpXG5cdFx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IG9wdGlvbnMuekluZGV4IHx8IDIgfSlcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdGF4aXMubGFiZWxHcm91cCA9IHJlbmRlcmVyLmcoJ2F4aXMtbGFiZWxzJylcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogbGFiZWxPcHRpb25zLnpJbmRleCB8fCA3IH0pXG5cdFx0XHRcdFx0LmFkZENsYXNzKFBSRUZJWCArIGF4aXMuY29sbC50b0xvd2VyQ2FzZSgpICsgJy1sYWJlbHMnKVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhhc0RhdGEgfHwgYXhpcy5pc0xpbmtlZCkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gR2VuZXJhdGUgdGlja3Ncblx0XHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zKSB7XG5cdFx0XHRcdFx0aWYgKCF0aWNrc1twb3NdKSB7XG5cdFx0XHRcdFx0XHR0aWNrc1twb3NdID0gbmV3IFRpY2soYXhpcywgcG9zKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGlja3NbcG9zXS5hZGRMYWJlbCgpOyAvLyB1cGRhdGUgbGFiZWxzIGRlcGVuZGluZyBvbiB0aWNrIGludGVydmFsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRheGlzLnJlbmRlclVuc3F1aXNoKCk7XG5cblx0XHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zKSB7XG5cdFx0XHRcdFx0Ly8gbGVmdCBzaWRlIG11c3QgYmUgYWxpZ246IHJpZ2h0IGFuZCByaWdodCBzaWRlIG11c3QgaGF2ZSBhbGlnbjogbGVmdCBmb3IgbGFiZWxzXG5cdFx0XHRcdFx0aWYgKHNpZGUgPT09IDAgfHwgc2lkZSA9PT0gMiB8fCB7IDE6ICdsZWZ0JywgMzogJ3JpZ2h0JyB9W3NpZGVdID09PSBheGlzLmxhYmVsQWxpZ24pIHtcblxuXHRcdFx0XHRcdFx0Ly8gZ2V0IHRoZSBoaWdoZXN0IG9mZnNldFxuXHRcdFx0XHRcdFx0bGFiZWxPZmZzZXQgPSBtYXRoTWF4KFxuXHRcdFx0XHRcdFx0XHR0aWNrc1twb3NdLmdldExhYmVsU2l6ZSgpLFxuXHRcdFx0XHRcdFx0XHRsYWJlbE9mZnNldFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChheGlzLnN0YWdnZXJMaW5lcykge1xuXHRcdFx0XHRcdGxhYmVsT2Zmc2V0ICo9IGF4aXMuc3RhZ2dlckxpbmVzO1xuXHRcdFx0XHRcdGF4aXMubGFiZWxPZmZzZXQgPSBsYWJlbE9mZnNldDtcblx0XHRcdFx0fVxuXG5cblx0XHRcdH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSBkYXRhXG5cdFx0XHRcdGZvciAobiBpbiB0aWNrcykge1xuXHRcdFx0XHRcdHRpY2tzW25dLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRkZWxldGUgdGlja3Nbbl07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGF4aXNUaXRsZU9wdGlvbnMgJiYgYXhpc1RpdGxlT3B0aW9ucy50ZXh0ICYmIGF4aXNUaXRsZU9wdGlvbnMuZW5hYmxlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0aWYgKCFheGlzLmF4aXNUaXRsZSkge1xuXHRcdFx0XHRcdGF4aXMuYXhpc1RpdGxlID0gcmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRcdGF4aXNUaXRsZU9wdGlvbnMudGV4dCxcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0YXhpc1RpdGxlT3B0aW9ucy51c2VIVE1MXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdHpJbmRleDogNyxcblx0XHRcdFx0XHRcdHJvdGF0aW9uOiBheGlzVGl0bGVPcHRpb25zLnJvdGF0aW9uIHx8IDAsXG5cdFx0XHRcdFx0XHRhbGlnbjpcblx0XHRcdFx0XHRcdFx0YXhpc1RpdGxlT3B0aW9ucy50ZXh0QWxpZ24gfHxcblx0XHRcdFx0XHRcdFx0eyBsb3c6ICdsZWZ0JywgbWlkZGxlOiAnY2VudGVyJywgaGlnaDogJ3JpZ2h0JyB9W2F4aXNUaXRsZU9wdGlvbnMuYWxpZ25dXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYWRkQ2xhc3MoUFJFRklYICsgdGhpcy5jb2xsLnRvTG93ZXJDYXNlKCkgKyAnLXRpdGxlJylcblx0XHRcdFx0XHQuY3NzKGF4aXNUaXRsZU9wdGlvbnMuc3R5bGUpXG5cdFx0XHRcdFx0LmFkZChheGlzLmF4aXNHcm91cCk7XG5cdFx0XHRcdFx0YXhpcy5heGlzVGl0bGUuaXNOZXcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHNob3dBeGlzKSB7XG5cdFx0XHRcdFx0dGl0bGVPZmZzZXQgPSBheGlzLmF4aXNUaXRsZS5nZXRCQm94KClbaG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCddO1xuXHRcdFx0XHRcdHRpdGxlT2Zmc2V0T3B0aW9uID0gYXhpc1RpdGxlT3B0aW9ucy5vZmZzZXQ7XG5cdFx0XHRcdFx0dGl0bGVNYXJnaW4gPSBkZWZpbmVkKHRpdGxlT2Zmc2V0T3B0aW9uKSA/IDAgOiBwaWNrKGF4aXNUaXRsZU9wdGlvbnMubWFyZ2luLCBob3JpeiA/IDUgOiAxMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBoaWRlIG9yIHNob3cgdGhlIHRpdGxlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHNob3dFbXB0eSBpcyBzZXRcblx0XHRcdFx0YXhpcy5heGlzVGl0bGVbc2hvd0F4aXMgPyAnc2hvdycgOiAnaGlkZSddKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhhbmRsZSBhdXRvbWF0aWMgb3IgdXNlciBzZXQgb2Zmc2V0XG5cdFx0XHRheGlzLm9mZnNldCA9IGRpcmVjdGlvbkZhY3RvciAqIHBpY2sob3B0aW9ucy5vZmZzZXQsIGF4aXNPZmZzZXRbc2lkZV0pO1xuXG5cdFx0XHRheGlzLnRpY2tSb3RDb3JyID0gYXhpcy50aWNrUm90Q29yciB8fCB7IHg6IDAsIHk6IDAgfTsgLy8gcG9sYXJcblx0XHRcdGxpbmVIZWlnaHRDb3JyZWN0aW9uID0gc2lkZSA9PT0gMiA/IGF4aXMudGlja1JvdENvcnIueSA6IDA7XG5cdFx0XHRsYWJlbE9mZnNldFBhZGRlZCA9IGxhYmVsT2Zmc2V0ICsgdGl0bGVNYXJnaW4gK1xuXHRcdFx0XHQobGFiZWxPZmZzZXQgJiYgKGRpcmVjdGlvbkZhY3RvciAqIChob3JpeiA/IHBpY2sobGFiZWxPcHRpb25zLnksIGF4aXMudGlja1JvdENvcnIueSArIDgpIDogbGFiZWxPcHRpb25zLngpIC0gbGluZUhlaWdodENvcnJlY3Rpb24pKTtcblx0XHRcdGF4aXMuYXhpc1RpdGxlTWFyZ2luID0gcGljayh0aXRsZU9mZnNldE9wdGlvbiwgbGFiZWxPZmZzZXRQYWRkZWQpO1xuXG5cdFx0XHRheGlzT2Zmc2V0W3NpZGVdID0gbWF0aE1heChcblx0XHRcdFx0YXhpc09mZnNldFtzaWRlXSxcblx0XHRcdFx0YXhpcy5heGlzVGl0bGVNYXJnaW4gKyB0aXRsZU9mZnNldCArIGRpcmVjdGlvbkZhY3RvciAqIGF4aXMub2Zmc2V0LFxuXHRcdFx0XHRsYWJlbE9mZnNldFBhZGRlZCAvLyAjMzAyN1xuXHRcdFx0KTtcblx0XHRcdGNsaXBPZmZzZXRbaW52ZXJ0ZWRTaWRlXSA9IG1hdGhNYXgoY2xpcE9mZnNldFtpbnZlcnRlZFNpZGVdLCBtYXRoRmxvb3Iob3B0aW9ucy5saW5lV2lkdGggLyAyKSAqIDIpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHBhdGggZm9yIHRoZSBheGlzIGxpbmVcblx0XHQgKi9cblx0XHRnZXRMaW5lUGF0aDogZnVuY3Rpb24gKGxpbmVXaWR0aCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0b3Bwb3NpdGUgPSB0aGlzLm9wcG9zaXRlLFxuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCxcblx0XHRcdFx0aG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0XHRsaW5lTGVmdCA9IHRoaXMubGVmdCArIChvcHBvc2l0ZSA/IHRoaXMud2lkdGggOiAwKSArIG9mZnNldCxcblx0XHRcdFx0bGluZVRvcCA9IGNoYXJ0LmNoYXJ0SGVpZ2h0IC0gdGhpcy5ib3R0b20gLSAob3Bwb3NpdGUgPyB0aGlzLmhlaWdodCA6IDApICsgb2Zmc2V0O1xuXG5cdFx0XHRpZiAob3Bwb3NpdGUpIHtcblx0XHRcdFx0bGluZVdpZHRoICo9IC0xOyAvLyBjcmlzcGlmeSB0aGUgb3RoZXIgd2F5IC0gIzE0ODAsICMxNjg3XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaGFydC5yZW5kZXJlci5jcmlzcExpbmUoW1xuXHRcdFx0XHRcdE0sXG5cdFx0XHRcdFx0aG9yaXogP1xuXHRcdFx0XHRcdFx0dGhpcy5sZWZ0IDpcblx0XHRcdFx0XHRcdGxpbmVMZWZ0LFxuXHRcdFx0XHRcdGhvcml6ID9cblx0XHRcdFx0XHRcdGxpbmVUb3AgOlxuXHRcdFx0XHRcdFx0dGhpcy50b3AsXG5cdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRob3JpeiA/XG5cdFx0XHRcdFx0XHRjaGFydC5jaGFydFdpZHRoIC0gdGhpcy5yaWdodCA6XG5cdFx0XHRcdFx0XHRsaW5lTGVmdCxcblx0XHRcdFx0XHRob3JpeiA/XG5cdFx0XHRcdFx0XHRsaW5lVG9wIDpcblx0XHRcdFx0XHRcdGNoYXJ0LmNoYXJ0SGVpZ2h0IC0gdGhpcy5ib3R0b21cblx0XHRcdFx0XSwgbGluZVdpZHRoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gdGhlIHRpdGxlXG5cdFx0ICovXG5cdFx0Z2V0VGl0bGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gY29tcHV0ZSBhbmNob3IgcG9pbnRzIGZvciBlYWNoIG9mIHRoZSB0aXRsZSBhbGlnbiBvcHRpb25zXG5cdFx0XHR2YXIgaG9yaXogPSB0aGlzLmhvcml6LFxuXHRcdFx0XHRheGlzTGVmdCA9IHRoaXMubGVmdCxcblx0XHRcdFx0YXhpc1RvcCA9IHRoaXMudG9wLFxuXHRcdFx0XHRheGlzTGVuZ3RoID0gdGhpcy5sZW4sXG5cdFx0XHRcdGF4aXNUaXRsZU9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudGl0bGUsXG5cdFx0XHRcdG1hcmdpbiA9IGhvcml6ID8gYXhpc0xlZnQgOiBheGlzVG9wLFxuXHRcdFx0XHRvcHBvc2l0ZSA9IHRoaXMub3Bwb3NpdGUsXG5cdFx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0LFxuXHRcdFx0XHRmb250U2l6ZSA9IHBJbnQoYXhpc1RpdGxlT3B0aW9ucy5zdHlsZS5mb250U2l6ZSB8fCAxMiksXG5cblx0XHRcdFx0Ly8gdGhlIHBvc2l0aW9uIGluIHRoZSBsZW5ndGggZGlyZWN0aW9uIG9mIHRoZSBheGlzXG5cdFx0XHRcdGFsb25nQXhpcyA9IHtcblx0XHRcdFx0XHRsb3c6IG1hcmdpbiArIChob3JpeiA/IDAgOiBheGlzTGVuZ3RoKSxcblx0XHRcdFx0XHRtaWRkbGU6IG1hcmdpbiArIGF4aXNMZW5ndGggLyAyLFxuXHRcdFx0XHRcdGhpZ2g6IG1hcmdpbiArIChob3JpeiA/IGF4aXNMZW5ndGggOiAwKVxuXHRcdFx0XHR9W2F4aXNUaXRsZU9wdGlvbnMuYWxpZ25dLFxuXG5cdFx0XHRcdC8vIHRoZSBwb3NpdGlvbiBpbiB0aGUgcGVycGVuZGljdWxhciBkaXJlY3Rpb24gb2YgdGhlIGF4aXNcblx0XHRcdFx0b2ZmQXhpcyA9IChob3JpeiA/IGF4aXNUb3AgKyB0aGlzLmhlaWdodCA6IGF4aXNMZWZ0KSArXG5cdFx0XHRcdFx0KGhvcml6ID8gMSA6IC0xKSAqIC8vIGhvcml6b250YWwgYXhpcyByZXZlcnNlcyB0aGUgbWFyZ2luXG5cdFx0XHRcdFx0KG9wcG9zaXRlID8gLTEgOiAxKSAqIC8vIHNvIGRvZXMgb3Bwb3NpdGUgYXhlc1xuXHRcdFx0XHRcdHRoaXMuYXhpc1RpdGxlTWFyZ2luICtcblx0XHRcdFx0XHQodGhpcy5zaWRlID09PSAyID8gZm9udFNpemUgOiAwKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogaG9yaXogP1xuXHRcdFx0XHRcdGFsb25nQXhpcyA6XG5cdFx0XHRcdFx0b2ZmQXhpcyArIChvcHBvc2l0ZSA/IHRoaXMud2lkdGggOiAwKSArIG9mZnNldCArXG5cdFx0XHRcdFx0XHQoYXhpc1RpdGxlT3B0aW9ucy54IHx8IDApLCAvLyB4XG5cdFx0XHRcdHk6IGhvcml6ID9cblx0XHRcdFx0XHRvZmZBeGlzIC0gKG9wcG9zaXRlID8gdGhpcy5oZWlnaHQgOiAwKSArIG9mZnNldCA6XG5cdFx0XHRcdFx0YWxvbmdBeGlzICsgKGF4aXNUaXRsZU9wdGlvbnMueSB8fCAwKSAvLyB5XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgdGhlIGF4aXNcblx0XHQgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBheGlzLmNoYXJ0LFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRvcHRpb25zID0gYXhpcy5vcHRpb25zLFxuXHRcdFx0XHRpc0xvZyA9IGF4aXMuaXNMb2csXG5cdFx0XHRcdGlzTGlua2VkID0gYXhpcy5pc0xpbmtlZCxcblx0XHRcdFx0dGlja1Bvc2l0aW9ucyA9IGF4aXMudGlja1Bvc2l0aW9ucyxcblx0XHRcdFx0YXhpc1RpdGxlID0gYXhpcy5heGlzVGl0bGUsXHRcdFx0XG5cdFx0XHRcdHRpY2tzID0gYXhpcy50aWNrcyxcblx0XHRcdFx0bWlub3JUaWNrcyA9IGF4aXMubWlub3JUaWNrcyxcblx0XHRcdFx0YWx0ZXJuYXRlQmFuZHMgPSBheGlzLmFsdGVybmF0ZUJhbmRzLFxuXHRcdFx0XHRzdGFja0xhYmVsT3B0aW9ucyA9IG9wdGlvbnMuc3RhY2tMYWJlbHMsXG5cdFx0XHRcdGFsdGVybmF0ZUdyaWRDb2xvciA9IG9wdGlvbnMuYWx0ZXJuYXRlR3JpZENvbG9yLFxuXHRcdFx0XHR0aWNrbWFya09mZnNldCA9IGF4aXMudGlja21hcmtPZmZzZXQsXG5cdFx0XHRcdGxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoLFxuXHRcdFx0XHRsaW5lUGF0aCxcblx0XHRcdFx0aGFzUmVuZGVyZWQgPSBjaGFydC5oYXNSZW5kZXJlZCxcblx0XHRcdFx0c2xpZGVJblRpY2tzID0gaGFzUmVuZGVyZWQgJiYgZGVmaW5lZChheGlzLm9sZE1pbikgJiYgIWlzTmFOKGF4aXMub2xkTWluKSxcblx0XHRcdFx0aGFzRGF0YSA9IGF4aXMuaGFzRGF0YSxcblx0XHRcdFx0c2hvd0F4aXMgPSBheGlzLnNob3dBeGlzLFxuXHRcdFx0XHRmcm9tLFxuXHRcdFx0XHR0bztcblxuXHRcdFx0Ly8gUmVzZXRcblx0XHRcdGF4aXMubGFiZWxFZGdlLmxlbmd0aCA9IDA7XG5cdFx0XHQvL2F4aXMuanVzdGlmeVRvUGxvdCA9IG92ZXJmbG93ID09PSAnanVzdGlmeSc7XG5cdFx0XHRheGlzLm92ZXJsYXAgPSBmYWxzZTtcblxuXHRcdFx0Ly8gTWFyayBhbGwgZWxlbWVudHMgaW5BY3RpdmUgYmVmb3JlIHdlIGdvIG92ZXIgYW5kIG1hcmsgdGhlIGFjdGl2ZSBvbmVzXG5cdFx0XHRlYWNoKFt0aWNrcywgbWlub3JUaWNrcywgYWx0ZXJuYXRlQmFuZHNdLCBmdW5jdGlvbiAoY29sbCkge1xuXHRcdFx0XHR2YXIgcG9zO1xuXHRcdFx0XHRmb3IgKHBvcyBpbiBjb2xsKSB7XG5cdFx0XHRcdFx0Y29sbFtwb3NdLmlzQWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VyaWVzIGhhcyBkYXRhIGRyYXcgdGhlIHRpY2tzLiBFbHNlIG9ubHkgdGhlIGxpbmUgYW5kIHRpdGxlXG5cdFx0XHRpZiAoaGFzRGF0YSB8fCBpc0xpbmtlZCkge1xuXG5cdFx0XHRcdC8vIG1pbm9yIHRpY2tzXG5cdFx0XHRcdGlmIChheGlzLm1pbm9yVGlja0ludGVydmFsICYmICFheGlzLmNhdGVnb3JpZXMpIHtcblx0XHRcdFx0XHRlYWNoKGF4aXMuZ2V0TWlub3JUaWNrUG9zaXRpb25zKCksIGZ1bmN0aW9uIChwb3MpIHtcblx0XHRcdFx0XHRcdGlmICghbWlub3JUaWNrc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRcdG1pbm9yVGlja3NbcG9zXSA9IG5ldyBUaWNrKGF4aXMsIHBvcywgJ21pbm9yJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHJlbmRlciBuZXcgdGlja3MgaW4gb2xkIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRpZiAoc2xpZGVJblRpY2tzICYmIG1pbm9yVGlja3NbcG9zXS5pc05ldykge1xuXHRcdFx0XHRcdFx0XHRtaW5vclRpY2tzW3Bvc10ucmVuZGVyKG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtaW5vclRpY2tzW3Bvc10ucmVuZGVyKG51bGwsIGZhbHNlLCAxKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1ham9yIHRpY2tzLiBQdWxsIG91dCB0aGUgZmlyc3QgaXRlbSBhbmQgcmVuZGVyIGl0IGxhc3Qgc28gdGhhdFxuXHRcdFx0XHQvLyB3ZSBjYW4gZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbmVpZ2hib3VyIGxhYmVsLiAjODA4LlxuXHRcdFx0XHRpZiAodGlja1Bvc2l0aW9ucy5sZW5ndGgpIHsgLy8gIzEzMDBcblx0XHRcdFx0XHRlYWNoKHRpY2tQb3NpdGlvbnMsIGZ1bmN0aW9uIChwb3MsIGkpIHtcblxuXHRcdFx0XHRcdFx0Ly8gbGlua2VkIGF4ZXMgbmVlZCBhbiBleHRyYSBjaGVjayB0byBmaW5kIG91dCBpZlxuXHRcdFx0XHRcdFx0aWYgKCFpc0xpbmtlZCB8fCAocG9zID49IGF4aXMubWluICYmIHBvcyA8PSBheGlzLm1heCkpIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIXRpY2tzW3Bvc10pIHtcblx0XHRcdFx0XHRcdFx0XHR0aWNrc1twb3NdID0gbmV3IFRpY2soYXhpcywgcG9zKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHJlbmRlciBuZXcgdGlja3MgaW4gb2xkIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRcdGlmIChzbGlkZUluVGlja3MgJiYgdGlja3NbcG9zXS5pc05ldykge1xuXHRcdFx0XHRcdFx0XHRcdHRpY2tzW3Bvc10ucmVuZGVyKGksIHRydWUsIDAuMSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR0aWNrc1twb3NdLnJlbmRlcihpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdC8vIEluIGEgY2F0ZWdvcml6ZWQgYXhpcywgdGhlIHRpY2sgbWFya3MgYXJlIGRpc3BsYXllZCBiZXR3ZWVuIGxhYmVscy4gU29cblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGFkZCBhIHRpY2sgbWFyayBhbmQgZ3JpZCBsaW5lIGF0IHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIFggYXhpcy5cblx0XHRcdFx0XHRpZiAodGlja21hcmtPZmZzZXQgJiYgKGF4aXMubWluID09PSAwIHx8IGF4aXMuc2luZ2xlKSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0aWNrc1stMV0pIHtcblx0XHRcdFx0XHRcdFx0dGlja3NbLTFdID0gbmV3IFRpY2soYXhpcywgLTEsIG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGlja3NbLTFdLnJlbmRlcigtMSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhbHRlcm5hdGUgZ3JpZCBjb2xvclxuXHRcdFx0XHRpZiAoYWx0ZXJuYXRlR3JpZENvbG9yKSB7XG5cdFx0XHRcdFx0ZWFjaCh0aWNrUG9zaXRpb25zLCBmdW5jdGlvbiAocG9zLCBpKSB7XG5cdFx0XHRcdFx0XHRpZiAoaSAlIDIgPT09IDAgJiYgcG9zIDwgYXhpcy5tYXgpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFhbHRlcm5hdGVCYW5kc1twb3NdKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlQmFuZHNbcG9zXSA9IG5ldyBIaWdoY2hhcnRzLlBsb3RMaW5lT3JCYW5kKGF4aXMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZyb20gPSBwb3MgKyB0aWNrbWFya09mZnNldDsgLy8gIzk0OVxuXHRcdFx0XHRcdFx0XHR0byA9IHRpY2tQb3NpdGlvbnNbaSArIDFdICE9PSBVTkRFRklORUQgPyB0aWNrUG9zaXRpb25zW2kgKyAxXSArIHRpY2ttYXJrT2Zmc2V0IDogYXhpcy5tYXg7XG5cdFx0XHRcdFx0XHRcdGFsdGVybmF0ZUJhbmRzW3Bvc10ub3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdFx0XHRmcm9tOiBpc0xvZyA/IGxpbjJsb2coZnJvbSkgOiBmcm9tLFxuXHRcdFx0XHRcdFx0XHRcdHRvOiBpc0xvZyA/IGxpbjJsb2codG8pIDogdG8sXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3I6IGFsdGVybmF0ZUdyaWRDb2xvclxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRhbHRlcm5hdGVCYW5kc1twb3NdLnJlbmRlcigpO1xuXHRcdFx0XHRcdFx0XHRhbHRlcm5hdGVCYW5kc1twb3NdLmlzQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGN1c3RvbSBwbG90IGxpbmVzIGFuZCBiYW5kc1xuXHRcdFx0XHRpZiAoIWF4aXMuX2FkZGVkUGxvdExCKSB7IC8vIG9ubHkgZmlyc3QgdGltZVxuXHRcdFx0XHRcdGVhY2goKG9wdGlvbnMucGxvdExpbmVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5wbG90QmFuZHMgfHwgW10pLCBmdW5jdGlvbiAocGxvdExpbmVPcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRheGlzLmFkZFBsb3RCYW5kT3JMaW5lKHBsb3RMaW5lT3B0aW9ucyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YXhpcy5fYWRkZWRQbG90TEIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gLy8gZW5kIGlmIGhhc0RhdGFcblxuXHRcdFx0Ly8gUmVtb3ZlIGluYWN0aXZlIHRpY2tzXG5cdFx0XHRlYWNoKFt0aWNrcywgbWlub3JUaWNrcywgYWx0ZXJuYXRlQmFuZHNdLCBmdW5jdGlvbiAoY29sbCkge1xuXHRcdFx0XHR2YXIgcG9zLFxuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0Zm9yRGVzdHJ1Y3Rpb24gPSBbXSxcblx0XHRcdFx0XHRkZWxheSA9IGdsb2JhbEFuaW1hdGlvbiA/IGdsb2JhbEFuaW1hdGlvbi5kdXJhdGlvbiB8fCA1MDAgOiAwLFxuXHRcdFx0XHRcdGRlc3Ryb3lJbmFjdGl2ZUl0ZW1zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aSA9IGZvckRlc3RydWN0aW9uLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdFx0Ly8gV2hlbiByZXNpemluZyByYXBpZGx5LCB0aGUgc2FtZSBpdGVtcyBtYXkgYmUgZGVzdHJveWVkIGluIGRpZmZlcmVudCB0aW1lb3V0cyxcblx0XHRcdFx0XHRcdFx0Ly8gb3IgdGhlIG1heSBiZSByZWFjdGl2YXRlZFxuXHRcdFx0XHRcdFx0XHRpZiAoY29sbFtmb3JEZXN0cnVjdGlvbltpXV0gJiYgIWNvbGxbZm9yRGVzdHJ1Y3Rpb25baV1dLmlzQWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29sbFtmb3JEZXN0cnVjdGlvbltpXV0uZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBjb2xsW2ZvckRlc3RydWN0aW9uW2ldXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRmb3IgKHBvcyBpbiBjb2xsKSB7XG5cblx0XHRcdFx0XHRpZiAoIWNvbGxbcG9zXS5pc0FjdGl2ZSkge1xuXHRcdFx0XHRcdFx0Ly8gUmVuZGVyIHRvIHplcm8gb3BhY2l0eVxuXHRcdFx0XHRcdFx0Y29sbFtwb3NdLnJlbmRlcihwb3MsIGZhbHNlLCAwKTtcblx0XHRcdFx0XHRcdGNvbGxbcG9zXS5pc0FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Zm9yRGVzdHJ1Y3Rpb24ucHVzaChwb3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdoZW4gdGhlIG9iamVjdHMgYXJlIGZpbmlzaGVkIGZhZGluZyBvdXQsIGRlc3Ryb3kgdGhlbVxuXHRcdFx0XHRpZiAoY29sbCA9PT0gYWx0ZXJuYXRlQmFuZHMgfHwgIWNoYXJ0Lmhhc1JlbmRlcmVkIHx8ICFkZWxheSkge1xuXHRcdFx0XHRcdGRlc3Ryb3lJbmFjdGl2ZUl0ZW1zKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGVsYXkpIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGRlc3Ryb3lJbmFjdGl2ZUl0ZW1zLCBkZWxheSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBTdGF0aWMgaXRlbXMuIEFzIHRoZSBheGlzIGdyb3VwIGlzIGNsZWFyZWQgb24gc3Vic2VxdWVudCBjYWxsc1xuXHRcdFx0Ly8gdG8gcmVuZGVyLCB0aGVzZSBpdGVtcyBhcmUgYWRkZWQgb3V0c2lkZSB0aGUgZ3JvdXAuXG5cdFx0XHQvLyBheGlzIGxpbmVcblx0XHRcdGlmIChsaW5lV2lkdGgpIHtcblx0XHRcdFx0bGluZVBhdGggPSBheGlzLmdldExpbmVQYXRoKGxpbmVXaWR0aCk7XG5cdFx0XHRcdGlmICghYXhpcy5heGlzTGluZSkge1xuXHRcdFx0XHRcdGF4aXMuYXhpc0xpbmUgPSByZW5kZXJlci5wYXRoKGxpbmVQYXRoKVxuXHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRzdHJva2U6IG9wdGlvbnMubGluZUNvbG9yLFxuXHRcdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogbGluZVdpZHRoLFxuXHRcdFx0XHRcdFx0XHR6SW5kZXg6IDdcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuYWRkKGF4aXMuYXhpc0dyb3VwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRheGlzLmF4aXNMaW5lLmFuaW1hdGUoeyBkOiBsaW5lUGF0aCB9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNob3cgb3IgaGlkZSB0aGUgbGluZSBkZXBlbmRpbmcgb24gb3B0aW9ucy5zaG93RW1wdHlcblx0XHRcdFx0YXhpcy5heGlzTGluZVtzaG93QXhpcyA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGF4aXNUaXRsZSAmJiBzaG93QXhpcykge1xuXG5cdFx0XHRcdGF4aXNUaXRsZVtheGlzVGl0bGUuaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKFxuXHRcdFx0XHRcdGF4aXMuZ2V0VGl0bGVQb3NpdGlvbigpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGF4aXNUaXRsZS5pc05ldyA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFja2VkIHRvdGFsczpcblx0XHRcdGlmIChzdGFja0xhYmVsT3B0aW9ucyAmJiBzdGFja0xhYmVsT3B0aW9ucy5lbmFibGVkKSB7XG5cdFx0XHRcdGF4aXMucmVuZGVyU3RhY2tUb3RhbHMoKTtcblx0XHRcdH1cblx0XHRcdC8vIEVuZCBzdGFja2VkIHRvdGFsc1xuXG5cdFx0XHRheGlzLmlzRGlydHkgPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVkcmF3IHRoZSBheGlzIHRvIHJlZmxlY3QgY2hhbmdlcyBpbiB0aGUgZGF0YSBvciBheGlzIGV4dHJlbWVzXG5cdFx0ICovXG5cdFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcblx0XHRcdC8vIHJlbmRlciB0aGUgYXhpc1xuXHRcdFx0dGhpcy5yZW5kZXIoKTtcblxuXHRcdFx0Ly8gbW92ZSBwbG90IGxpbmVzIGFuZCBiYW5kc1xuXHRcdFx0ZWFjaCh0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLCBmdW5jdGlvbiAocGxvdExpbmUpIHtcblx0XHRcdFx0cGxvdExpbmUucmVuZGVyKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gbWFyayBhc3NvY2lhdGVkIHNlcmllcyBhcyBkaXJ0eSBhbmQgcmVhZHkgZm9yIHJlZHJhd1xuXHRcdFx0ZWFjaCh0aGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHR9KTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95cyBhbiBBeGlzIGluc3RhbmNlLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIChrZWVwRXZlbnRzKSB7XG5cdFx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRcdHN0YWNrcyA9IGF4aXMuc3RhY2tzLFxuXHRcdFx0XHRzdGFja0tleSxcblx0XHRcdFx0cGxvdExpbmVzQW5kQmFuZHMgPSBheGlzLnBsb3RMaW5lc0FuZEJhbmRzLFxuXHRcdFx0XHRpO1xuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIGV2ZW50c1xuXHRcdFx0aWYgKCFrZWVwRXZlbnRzKSB7XG5cdFx0XHRcdHJlbW92ZUV2ZW50KGF4aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXN0cm95IGVhY2ggc3RhY2sgdG90YWxcblx0XHRcdGZvciAoc3RhY2tLZXkgaW4gc3RhY2tzKSB7XG5cdFx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHN0YWNrc1tzdGFja0tleV0pO1xuXG5cdFx0XHRcdHN0YWNrc1tzdGFja0tleV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXN0cm95IGNvbGxlY3Rpb25zXG5cdFx0XHRlYWNoKFtheGlzLnRpY2tzLCBheGlzLm1pbm9yVGlja3MsIGF4aXMuYWx0ZXJuYXRlQmFuZHNdLCBmdW5jdGlvbiAoY29sbCkge1xuXHRcdFx0XHRkZXN0cm95T2JqZWN0UHJvcGVydGllcyhjb2xsKTtcblx0XHRcdH0pO1xuXHRcdFx0aSA9IHBsb3RMaW5lc0FuZEJhbmRzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHsgLy8gIzE5NzVcblx0XHRcdFx0cGxvdExpbmVzQW5kQmFuZHNbaV0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXN0cm95IGxvY2FsIHZhcmlhYmxlc1xuXHRcdFx0ZWFjaChbJ3N0YWNrVG90YWxHcm91cCcsICdheGlzTGluZScsICdheGlzVGl0bGUnLCAnYXhpc0dyb3VwJywgJ2Nyb3NzJywgJ2dyaWRHcm91cCcsICdsYWJlbEdyb3VwJ10sIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdGlmIChheGlzW3Byb3BdKSB7XG5cdFx0XHRcdFx0YXhpc1twcm9wXSA9IGF4aXNbcHJvcF0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRGVzdHJveSBjcm9zc2hhaXJcblx0XHRcdGlmICh0aGlzLmNyb3NzKSB7XG5cdFx0XHRcdHRoaXMuY3Jvc3MuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSBjcm9zc2hhaXJcblx0XHQgKi9cblx0XHRkcmF3Q3Jvc3NoYWlyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHsgLy8gZG9jczogTWlzc2luZyBkb2NzIGZvciBBeGlzLmNyb3NzaGFpci4gQWxzbyBmb3IgcHJvcGVydGllcy5cblxuXHRcdFx0dmFyIHBhdGgsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLmNyb3NzaGFpcixcblx0XHRcdFx0YW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24sXG5cdFx0XHRcdHBvcyxcblx0XHRcdFx0YXR0cmlicyxcblx0XHRcdFx0Y2F0ZWdvcml6ZWQ7XG5cdFx0XHRcblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gRGlzYWJsZWQgaW4gb3B0aW9uc1xuXHRcdFx0XHQhdGhpcy5jcm9zc2hhaXIgfHwgXG5cdFx0XHRcdC8vIFNuYXBcblx0XHRcdFx0KChkZWZpbmVkKHBvaW50KSB8fCAhcGljayh0aGlzLmNyb3NzaGFpci5zbmFwLCB0cnVlKSkgPT09IGZhbHNlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuaGlkZUNyb3NzaGFpcigpO1xuXHRcdFx0XG5cdFx0XHR9IGVsc2Uge1x0XHRcdFxuXG5cdFx0XHRcdC8vIEdldCB0aGUgcGF0aFxuXHRcdFx0XHRpZiAoIXBpY2sob3B0aW9ucy5zbmFwLCB0cnVlKSkge1xuXHRcdFx0XHRcdHBvcyA9ICh0aGlzLmhvcml6ID8gZS5jaGFydFggLSB0aGlzLnBvcyA6IHRoaXMubGVuIC0gZS5jaGFydFkgKyB0aGlzLnBvcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGVmaW5lZChwb2ludCkpIHtcblx0XHRcdFx0XHQvKmpzbGludCBlcWVxOiB0cnVlKi9cblx0XHRcdFx0XHRwb3MgPSB0aGlzLmlzWEF4aXMgPyBwb2ludC5wbG90WCA6IHRoaXMubGVuIC0gcG9pbnQucGxvdFk7IC8vICMzODM0XG5cdFx0XHRcdFx0Lypqc2xpbnQgZXFlcTogZmFsc2UqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuaXNSYWRpYWwpIHtcblx0XHRcdFx0XHRwYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgodGhpcy5pc1hBeGlzID8gcG9pbnQueCA6IHBpY2socG9pbnQuc3RhY2tZLCBwb2ludC55KSkgfHwgbnVsbDsgLy8gIzMxODlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXRoID0gdGhpcy5nZXRQbG90TGluZVBhdGgobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgcG9zKSB8fCBudWxsOyAvLyAjMzE4OVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBhdGggPT09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLmhpZGVDcm9zc2hhaXIoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEcmF3IHRoZSBjcm9zc1xuXHRcdFx0XHRpZiAodGhpcy5jcm9zcykge1xuXHRcdFx0XHRcdHRoaXMuY3Jvc3Ncblx0XHRcdFx0XHRcdC5hdHRyKHsgdmlzaWJpbGl0eTogVklTSUJMRSB9KVthbmltYXRpb24gPyAnYW5pbWF0ZScgOiAnYXR0ciddKHsgZDogcGF0aCB9LCBhbmltYXRpb24pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhdGVnb3JpemVkID0gdGhpcy5jYXRlZ29yaWVzICYmICF0aGlzLmlzUmFkaWFsO1xuXHRcdFx0XHRcdGF0dHJpYnMgPSB7XG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogb3B0aW9ucy53aWR0aCB8fCAoY2F0ZWdvcml6ZWQgPyB0aGlzLnRyYW5zQSA6IDEpLFxuXHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmNvbG9yIHx8IChjYXRlZ29yaXplZCA/ICdyZ2JhKDE1NSwyMDAsMjU1LDAuMiknIDogJyNDMEMwQzAnKSxcblx0XHRcdFx0XHRcdHpJbmRleDogb3B0aW9ucy56SW5kZXggfHwgMlxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuZGFzaFN0eWxlKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzLmRhc2hzdHlsZSA9IG9wdGlvbnMuZGFzaFN0eWxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmNyb3NzID0gdGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKHBhdGgpLmF0dHIoYXR0cmlicykuYWRkKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqXHRIaWRlIHRoZSBjcm9zc2hhaXIuXG5cdFx0ICovXG5cdFx0aGlkZUNyb3NzaGFpcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuY3Jvc3MpIHtcblx0XHRcdFx0dGhpcy5jcm9zcy5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9OyAvLyBlbmQgQXhpc1xuXG5cdGV4dGVuZChBeGlzLnByb3RvdHlwZSwgQXhpc1Bsb3RMaW5lT3JCYW5kRXh0ZW5zaW9uKTtcblxuXHQvKipcblx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyB0byBhIHRpbWUgdW5pdCB0aGF0IG1ha2VzIHNlbnNlLCBmb3IgZXhhbXBsZVxuXHQgKiBvbiB0aGUgZmlyc3Qgb2YgZWFjaCBtb250aCBvciBvbiBldmVyeSBNb25kYXkuIFJldHVybiBhbiBhcnJheVxuXHQgKiB3aXRoIHRoZSB0aW1lIHBvc2l0aW9ucy4gVXNlZCBpbiBkYXRldGltZSBheGVzIGFzIHdlbGwgYXMgZm9yIGdyb3VwaW5nXG5cdCAqIGRhdGEgb24gYSBkYXRldGltZSBheGlzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbm9ybWFsaXplZEludGVydmFsIFRoZSBpbnRlcnZhbCBpbiBheGlzIHZhbHVlcyAobXMpIGFuZCB0aGUgY291bnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBUaGUgbWluaW11bSBpbiBheGlzIHZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4IFRoZSBtYXhpbXVtIGluIGF4aXMgdmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydE9mV2Vla1xuXHQgKi9cblx0QXhpcy5wcm90b3R5cGUuZ2V0VGltZVRpY2tzID0gZnVuY3Rpb24gKG5vcm1hbGl6ZWRJbnRlcnZhbCwgbWluLCBtYXgsIHN0YXJ0T2ZXZWVrKSB7XG5cdFx0dmFyIHRpY2tQb3NpdGlvbnMgPSBbXSxcblx0XHRcdGksXG5cdFx0XHRoaWdoZXJSYW5rcyA9IHt9LFxuXHRcdFx0dXNlVVRDID0gZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLnVzZVVUQyxcblx0XHRcdG1pblllYXIsIC8vIHVzZWQgaW4gbW9udGhzIGFuZCB5ZWFycyBhcyBhIGJhc2lzIGZvciBEYXRlLlVUQygpXG5cdFx0XHRtaW5EYXRlID0gbmV3IERhdGUobWluIC0gZ2V0VFpPZmZzZXQobWluKSksXG5cdFx0XHRpbnRlcnZhbCA9IG5vcm1hbGl6ZWRJbnRlcnZhbC51bml0UmFuZ2UsXG5cdFx0XHRjb3VudCA9IG5vcm1hbGl6ZWRJbnRlcnZhbC5jb3VudDtcblxuXHRcdGlmIChkZWZpbmVkKG1pbikpIHsgLy8gIzEzMDBcblx0XHRcdG1pbkRhdGUuc2V0TWlsbGlzZWNvbmRzKGludGVydmFsID49IHRpbWVVbml0cy5zZWNvbmQgPyAwIDpcblx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAvIGNvdW50KSk7IC8vICMzNjUyLCAjMzY1NFxuXG5cdFx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzLnNlY29uZCkgeyAvLyBzZWNvbmRcblx0XHRcdFx0bWluRGF0ZS5zZXRTZWNvbmRzKGludGVydmFsID49IHRpbWVVbml0cy5taW51dGUgPyAwIDpcblx0XHRcdFx0XHRjb3VudCAqIG1hdGhGbG9vcihtaW5EYXRlLmdldFNlY29uZHMoKSAvIGNvdW50KSk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzLm1pbnV0ZSkgeyAvLyBtaW51dGVcblx0XHRcdFx0bWluRGF0ZVtzZXRNaW51dGVzXShpbnRlcnZhbCA+PSB0aW1lVW5pdHMuaG91ciA/IDAgOlxuXHRcdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGVbZ2V0TWludXRlc10oKSAvIGNvdW50KSk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzLmhvdXIpIHsgLy8gaG91clxuXHRcdFx0XHRtaW5EYXRlW3NldEhvdXJzXShpbnRlcnZhbCA+PSB0aW1lVW5pdHMuZGF5ID8gMCA6XG5cdFx0XHRcdFx0Y291bnQgKiBtYXRoRmxvb3IobWluRGF0ZVtnZXRIb3Vyc10oKSAvIGNvdW50KSk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRpZiAoaW50ZXJ2YWwgPj0gdGltZVVuaXRzLmRheSkgeyAvLyBkYXlcblx0XHRcdFx0bWluRGF0ZVtzZXREYXRlXShpbnRlcnZhbCA+PSB0aW1lVW5pdHMubW9udGggPyAxIDpcblx0XHRcdFx0XHRjb3VudCAqIG1hdGhGbG9vcihtaW5EYXRlW2dldERhdGVdKCkgLyBjb3VudCkpO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0aWYgKGludGVydmFsID49IHRpbWVVbml0cy5tb250aCkgeyAvLyBtb250aFxuXHRcdFx0XHRtaW5EYXRlW3NldE1vbnRoXShpbnRlcnZhbCA+PSB0aW1lVW5pdHMueWVhciA/IDAgOlxuXHRcdFx0XHRcdGNvdW50ICogbWF0aEZsb29yKG1pbkRhdGVbZ2V0TW9udGhdKCkgLyBjb3VudCkpO1xuXHRcdFx0XHRtaW5ZZWFyID0gbWluRGF0ZVtnZXRGdWxsWWVhcl0oKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdGlmIChpbnRlcnZhbCA+PSB0aW1lVW5pdHMueWVhcikgeyAvLyB5ZWFyXG5cdFx0XHRcdG1pblllYXIgLT0gbWluWWVhciAlIGNvdW50O1xuXHRcdFx0XHRtaW5EYXRlW3NldEZ1bGxZZWFyXShtaW5ZZWFyKTtcblx0XHRcdH1cblx0XHRcblx0XHRcdC8vIHdlZWsgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBydW5zIG91dHNpZGUgdGhlIGhpZXJhcmNoeVxuXHRcdFx0aWYgKGludGVydmFsID09PSB0aW1lVW5pdHMud2Vlaykge1xuXHRcdFx0XHQvLyBnZXQgc3RhcnQgb2YgY3VycmVudCB3ZWVrLCBpbmRlcGVuZGVudCBvZiBjb3VudFxuXHRcdFx0XHRtaW5EYXRlW3NldERhdGVdKG1pbkRhdGVbZ2V0RGF0ZV0oKSAtIG1pbkRhdGVbZ2V0RGF5XSgpICtcblx0XHRcdFx0XHRwaWNrKHN0YXJ0T2ZXZWVrLCAxKSk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XG5cdFx0XHQvLyBnZXQgdGljayBwb3NpdGlvbnNcblx0XHRcdGkgPSAxO1xuXHRcdFx0aWYgKHRpbWV6b25lT2Zmc2V0IHx8IGdldFRpbWV6b25lT2Zmc2V0KSB7XG5cdFx0XHRcdG1pbkRhdGUgPSBtaW5EYXRlLmdldFRpbWUoKTtcblx0XHRcdFx0bWluRGF0ZSA9IG5ldyBEYXRlKG1pbkRhdGUgKyBnZXRUWk9mZnNldChtaW5EYXRlKSk7XG5cdFx0XHR9XG5cdFx0XHRtaW5ZZWFyID0gbWluRGF0ZVtnZXRGdWxsWWVhcl0oKTtcblx0XHRcdHZhciB0aW1lID0gbWluRGF0ZS5nZXRUaW1lKCksXG5cdFx0XHRcdG1pbk1vbnRoID0gbWluRGF0ZVtnZXRNb250aF0oKSxcblx0XHRcdFx0bWluRGF0ZURhdGUgPSBtaW5EYXRlW2dldERhdGVdKCksXG5cdFx0XHRcdGxvY2FsVGltZXpvbmVPZmZzZXQgPSAodGltZVVuaXRzLmRheSArIFxuXHRcdFx0XHRcdFx0KHVzZVVUQyA/IGdldFRaT2Zmc2V0KG1pbkRhdGUpIDogbWluRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwKVxuXHRcdFx0XHRcdCkgJSB0aW1lVW5pdHMuZGF5OyAvLyAjOTUwLCAjMzM1OVxuXHRcdFxuXHRcdFx0Ly8gaXRlcmF0ZSBhbmQgYWRkIHRpY2sgcG9zaXRpb25zIGF0IGFwcHJvcHJpYXRlIHZhbHVlc1xuXHRcdFx0d2hpbGUgKHRpbWUgPCBtYXgpIHtcblx0XHRcdFx0dGlja1Bvc2l0aW9ucy5wdXNoKHRpbWUpO1xuXHRcdFxuXHRcdFx0XHQvLyBpZiB0aGUgaW50ZXJ2YWwgaXMgeWVhcnMsIHVzZSBEYXRlLlVUQyB0byBpbmNyZWFzZSB5ZWFyc1xuXHRcdFx0XHRpZiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0cy55ZWFyKSB7XG5cdFx0XHRcdFx0dGltZSA9IG1ha2VUaW1lKG1pblllYXIgKyBpICogY291bnQsIDApO1xuXHRcdFxuXHRcdFx0XHQvLyBpZiB0aGUgaW50ZXJ2YWwgaXMgbW9udGhzLCB1c2UgRGF0ZS5VVEMgdG8gaW5jcmVhc2UgbW9udGhzXG5cdFx0XHRcdH0gZWxzZSBpZiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0cy5tb250aCkge1xuXHRcdFx0XHRcdHRpbWUgPSBtYWtlVGltZShtaW5ZZWFyLCBtaW5Nb250aCArIGkgKiBjb3VudCk7XG5cdFx0XG5cdFx0XHRcdC8vIGlmIHdlJ3JlIHVzaW5nIGdsb2JhbCB0aW1lLCB0aGUgaW50ZXJ2YWwgaXMgbm90IGZpeGVkIGFzIGl0IGp1bXBzXG5cdFx0XHRcdC8vIG9uZSBob3VyIGF0IHRoZSBEU1QgY3Jvc3NvdmVyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIXVzZVVUQyAmJiAoaW50ZXJ2YWwgPT09IHRpbWVVbml0cy5kYXkgfHwgaW50ZXJ2YWwgPT09IHRpbWVVbml0cy53ZWVrKSkge1xuXHRcdFx0XHRcdHRpbWUgPSBtYWtlVGltZShtaW5ZZWFyLCBtaW5Nb250aCwgbWluRGF0ZURhdGUgK1xuXHRcdFx0XHRcdFx0aSAqIGNvdW50ICogKGludGVydmFsID09PSB0aW1lVW5pdHMuZGF5ID8gMSA6IDcpKTtcblx0XHRcblx0XHRcdFx0Ly8gZWxzZSwgdGhlIGludGVydmFsIGlzIGZpeGVkIGFuZCB3ZSB1c2Ugc2ltcGxlIGFkZGl0aW9uXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGltZSArPSBpbnRlcnZhbCAqIGNvdW50O1xuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblx0XHRcblx0XHRcdC8vIHB1c2ggdGhlIGxhc3QgdGltZVxuXHRcdFx0dGlja1Bvc2l0aW9ucy5wdXNoKHRpbWUpO1xuXG5cblx0XHRcdC8vIG1hcmsgbmV3IGRheXMgaWYgdGhlIHRpbWUgaXMgZGl2aWRpYmxlIGJ5IGRheSAoIzE2NDksICMxNzYwKVxuXHRcdFx0ZWFjaChncmVwKHRpY2tQb3NpdGlvbnMsIGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0XHRcdHJldHVybiBpbnRlcnZhbCA8PSB0aW1lVW5pdHMuaG91ciAmJiB0aW1lICUgdGltZVVuaXRzLmRheSA9PT0gbG9jYWxUaW1lem9uZU9mZnNldDtcblx0XHRcdH0pLCBmdW5jdGlvbiAodGltZSkge1xuXHRcdFx0XHRoaWdoZXJSYW5rc1t0aW1lXSA9ICdkYXknO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cblx0XHQvLyByZWNvcmQgaW5mb3JtYXRpb24gb24gdGhlIGNob3NlbiB1bml0IC0gZm9yIGR5bmFtaWMgbGFiZWwgZm9ybWF0dGVyXG5cdFx0dGlja1Bvc2l0aW9ucy5pbmZvID0gZXh0ZW5kKG5vcm1hbGl6ZWRJbnRlcnZhbCwge1xuXHRcdFx0aGlnaGVyUmFua3M6IGhpZ2hlclJhbmtzLFxuXHRcdFx0dG90YWxSYW5nZTogaW50ZXJ2YWwgKiBjb3VudFxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRpY2tQb3NpdGlvbnM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhIG5vcm1hbGl6ZWQgdGljayBpbnRlcnZhbCBmb3IgZGF0ZXMuIFJldHVybnMgYSBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoXG5cdCAqIHVuaXQgcmFuZ2UgKGludGVydmFsKSwgY291bnQgYW5kIG5hbWUuIFVzZWQgdG8gcHJlcGFyZSBkYXRhIGZvciBnZXRUaW1lVGlja3MuIFxuXHQgKiBQcmV2aW91c2x5IHRoaXMgbG9naWMgd2FzIHBhcnQgb2YgZ2V0VGltZVRpY2tzLCBidXQgYXMgZ2V0VGltZVRpY2tzIG5vdyBydW5zXG5cdCAqIG9mIHNlZ21lbnRzIGluIHN0b2NrIGNoYXJ0cywgdGhlIG5vcm1hbGl6aW5nIGxvZ2ljIHdhcyBleHRyYWN0ZWQgaW4gb3JkZXIgdG8gXG5cdCAqIHByZXZlbnQgaXQgZm9yIHJ1bm5pbmcgb3ZlciBhZ2FpbiBmb3IgZWFjaCBzZWdtZW50IGhhdmluZyB0aGUgc2FtZSBpbnRlcnZhbC4gXG5cdCAqICM2NjIsICM2OTcuXG5cdCAqL1xuXHRBeGlzLnByb3RvdHlwZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsID0gZnVuY3Rpb24gKHRpY2tJbnRlcnZhbCwgdW5pdHNPcHRpb24pIHtcblx0XHR2YXIgdW5pdHMgPSB1bml0c09wdGlvbiB8fCBbW1xuXHRcdFx0XHRcdCdtaWxsaXNlY29uZCcsIC8vIHVuaXQgbmFtZVxuXHRcdFx0XHRcdFsxLCAyLCA1LCAxMCwgMjAsIDI1LCA1MCwgMTAwLCAyMDAsIDUwMF0gLy8gYWxsb3dlZCBtdWx0aXBsZXNcblx0XHRcdFx0XSwgW1xuXHRcdFx0XHRcdCdzZWNvbmQnLFxuXHRcdFx0XHRcdFsxLCAyLCA1LCAxMCwgMTUsIDMwXVxuXHRcdFx0XHRdLCBbXG5cdFx0XHRcdFx0J21pbnV0ZScsXG5cdFx0XHRcdFx0WzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdFx0XHRcdF0sIFtcblx0XHRcdFx0XHQnaG91cicsXG5cdFx0XHRcdFx0WzEsIDIsIDMsIDQsIDYsIDgsIDEyXVxuXHRcdFx0XHRdLCBbXG5cdFx0XHRcdFx0J2RheScsXG5cdFx0XHRcdFx0WzEsIDJdXG5cdFx0XHRcdF0sIFtcblx0XHRcdFx0XHQnd2VlaycsXG5cdFx0XHRcdFx0WzEsIDJdXG5cdFx0XHRcdF0sIFtcblx0XHRcdFx0XHQnbW9udGgnLFxuXHRcdFx0XHRcdFsxLCAyLCAzLCA0LCA2XVxuXHRcdFx0XHRdLCBbXG5cdFx0XHRcdFx0J3llYXInLFxuXHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XV0sXG5cdFx0XHR1bml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV0sIC8vIGRlZmF1bHQgdW5pdCBpcyB5ZWFyc1xuXHRcdFx0aW50ZXJ2YWwgPSB0aW1lVW5pdHNbdW5pdFswXV0sXG5cdFx0XHRtdWx0aXBsZXMgPSB1bml0WzFdLFxuXHRcdFx0Y291bnQsXG5cdFx0XHRpO1xuXHRcdFx0XG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHRoZSB1bml0cyB0byBmaW5kIHRoZSBvbmUgdGhhdCBiZXN0IGZpdHMgdGhlIHRpY2tJbnRlcnZhbFxuXHRcdGZvciAoaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dW5pdCA9IHVuaXRzW2ldO1xuXHRcdFx0aW50ZXJ2YWwgPSB0aW1lVW5pdHNbdW5pdFswXV07XG5cdFx0XHRtdWx0aXBsZXMgPSB1bml0WzFdO1xuXG5cblx0XHRcdGlmICh1bml0c1tpICsgMV0pIHtcblx0XHRcdFx0Ly8gbGVzc1RoYW4gaXMgaW4gdGhlIG1pZGRsZSBiZXR3ZWVuIHRoZSBoaWdoZXN0IG11bHRpcGxlIGFuZCB0aGUgbmV4dCB1bml0LlxuXHRcdFx0XHR2YXIgbGVzc1RoYW4gPSAoaW50ZXJ2YWwgKiBtdWx0aXBsZXNbbXVsdGlwbGVzLmxlbmd0aCAtIDFdICtcblx0XHRcdFx0XHRcdFx0dGltZVVuaXRzW3VuaXRzW2kgKyAxXVswXV0pIC8gMjtcblxuXHRcdFx0XHQvLyBicmVhayBhbmQga2VlcCB0aGUgY3VycmVudCB1bml0XG5cdFx0XHRcdGlmICh0aWNrSW50ZXJ2YWwgPD0gbGVzc1RoYW4pIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHByZXZlbnQgMi41IHllYXJzIGludGVydmFscywgdGhvdWdoIDI1LCAyNTAgZXRjLiBhcmUgYWxsb3dlZFxuXHRcdGlmIChpbnRlcnZhbCA9PT0gdGltZVVuaXRzLnllYXIgJiYgdGlja0ludGVydmFsIDwgNSAqIGludGVydmFsKSB7XG5cdFx0XHRtdWx0aXBsZXMgPSBbMSwgMiwgNV07XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IHRoZSBjb3VudFxuXHRcdGNvdW50ID0gbm9ybWFsaXplVGlja0ludGVydmFsKFxuXHRcdFx0dGlja0ludGVydmFsIC8gaW50ZXJ2YWwsIFxuXHRcdFx0bXVsdGlwbGVzLFxuXHRcdFx0dW5pdFswXSA9PT0gJ3llYXInID8gbWF0aE1heChnZXRNYWduaXR1ZGUodGlja0ludGVydmFsIC8gaW50ZXJ2YWwpLCAxKSA6IDEgLy8gIzE5MTMsICMyMzYwXG5cdFx0KTtcblx0XHRcblx0XHRyZXR1cm4ge1xuXHRcdFx0dW5pdFJhbmdlOiBpbnRlcnZhbCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdHVuaXROYW1lOiB1bml0WzBdXG5cdFx0fTtcblx0fTsvKipcblx0ICogTWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBBeGlzIHByb3RvdHlwZVxuXHQgKi9cblxuXHQvKipcblx0ICogU2V0IHRoZSB0aWNrIHBvc2l0aW9ucyBvZiBhIGxvZ2FyaXRobWljIGF4aXNcblx0ICovXG5cdEF4aXMucHJvdG90eXBlLmdldExvZ1RpY2tQb3NpdGlvbnMgPSBmdW5jdGlvbiAoaW50ZXJ2YWwsIG1pbiwgbWF4LCBtaW5vcikge1xuXHRcdHZhciBheGlzID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSBheGlzLm9wdGlvbnMsXG5cdFx0XHRheGlzTGVuZ3RoID0gYXhpcy5sZW4sXG5cdFx0XHQvLyBTaW5jZSB3ZSB1c2UgdGhpcyBtZXRob2QgZm9yIGJvdGggbWFqb3IgYW5kIG1pbm9yIHRpY2tzLFxuXHRcdFx0Ly8gdXNlIGEgbG9jYWwgdmFyaWFibGUgYW5kIHJldHVybiB0aGUgcmVzdWx0XG5cdFx0XHRwb3NpdGlvbnMgPSBbXTsgXG5cdFx0XG5cdFx0Ly8gUmVzZXRcblx0XHRpZiAoIW1pbm9yKSB7XG5cdFx0XHRheGlzLl9taW5vckF1dG9JbnRlcnZhbCA9IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEZpcnN0IGNhc2U6IEFsbCB0aWNrcyBmYWxsIG9uIHdob2xlIGxvZ2FyaXRobXM6IDEsIDEwLCAxMDAgZXRjLlxuXHRcdGlmIChpbnRlcnZhbCA+PSAwLjUpIHtcblx0XHRcdGludGVydmFsID0gbWF0aFJvdW5kKGludGVydmFsKTtcblx0XHRcdHBvc2l0aW9ucyA9IGF4aXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhpbnRlcnZhbCwgbWluLCBtYXgpO1xuXHRcdFx0XG5cdFx0Ly8gU2Vjb25kIGNhc2U6IFdlIG5lZWQgaW50ZXJtZWRpYXJ5IHRpY2tzLiBGb3IgZXhhbXBsZSBcblx0XHQvLyAxLCAyLCA0LCA2LCA4LCAxMCwgMjAsIDQwIGV0Yy4gXG5cdFx0fSBlbHNlIGlmIChpbnRlcnZhbCA+PSAwLjA4KSB7XG5cdFx0XHR2YXIgcm91bmRlZE1pbiA9IG1hdGhGbG9vcihtaW4pLFxuXHRcdFx0XHRpbnRlcm1lZGlhdGUsXG5cdFx0XHRcdGksXG5cdFx0XHRcdGosXG5cdFx0XHRcdGxlbixcblx0XHRcdFx0cG9zLFxuXHRcdFx0XHRsYXN0UG9zLFxuXHRcdFx0XHRicmVhazI7XG5cdFx0XHRcdFxuXHRcdFx0aWYgKGludGVydmFsID4gMC4zKSB7XG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IFsxLCAyLCA0XTtcblx0XHRcdH0gZWxzZSBpZiAoaW50ZXJ2YWwgPiAwLjE1KSB7IC8vIDAuMiBlcXVhbHMgZml2ZSBtaW5vciB0aWNrcyBwZXIgMSwgMTAsIDEwMCBldGNcblx0XHRcdFx0aW50ZXJtZWRpYXRlID0gWzEsIDIsIDQsIDYsIDhdO1xuXHRcdFx0fSBlbHNlIHsgLy8gMC4xIGVxdWFscyB0ZW4gbWlub3IgdGlja3MgcGVyIDEsIDEwLCAxMDAgZXRjXG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Zm9yIChpID0gcm91bmRlZE1pbjsgaSA8IG1heCArIDEgJiYgIWJyZWFrMjsgaSsrKSB7XG5cdFx0XHRcdGxlbiA9IGludGVybWVkaWF0ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsZW4gJiYgIWJyZWFrMjsgaisrKSB7XG5cdFx0XHRcdFx0cG9zID0gbG9nMmxpbihsaW4ybG9nKGkpICogaW50ZXJtZWRpYXRlW2pdKTtcblx0XHRcdFx0XHRpZiAocG9zID4gbWluICYmICghbWlub3IgfHwgbGFzdFBvcyA8PSBtYXgpICYmIGxhc3RQb3MgIT09IFVOREVGSU5FRCkgeyAvLyAjMTY3MCwgbGFzdFBvcyBpcyAjMzExM1xuXHRcdFx0XHRcdFx0cG9zaXRpb25zLnB1c2gobGFzdFBvcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChsYXN0UG9zID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRicmVhazIgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYXN0UG9zID0gcG9zO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHQvLyBUaGlyZCBjYXNlOiBXZSBhcmUgc28gZGVlcCBpbiBiZXR3ZWVuIHdob2xlIGxvZ2FyaXRobWljIHZhbHVlcyB0aGF0XG5cdFx0Ly8gd2UgbWlnaHQgYXMgd2VsbCBoYW5kbGUgdGhlIHRpY2sgcG9zaXRpb25zIGxpa2UgYSBsaW5lYXIgYXhpcy4gRm9yXG5cdFx0Ly8gZXhhbXBsZSAxLjAxLCAxLjAyLCAxLjAzLCAxLjA0LlxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcmVhbE1pbiA9IGxpbjJsb2cobWluKSxcblx0XHRcdFx0cmVhbE1heCA9IGxpbjJsb2cobWF4KSxcblx0XHRcdFx0dGlja0ludGVydmFsT3B0aW9uID0gb3B0aW9uc1ttaW5vciA/ICdtaW5vclRpY2tJbnRlcnZhbCcgOiAndGlja0ludGVydmFsJ10sXG5cdFx0XHRcdGZpbHRlcmVkVGlja0ludGVydmFsT3B0aW9uID0gdGlja0ludGVydmFsT3B0aW9uID09PSAnYXV0bycgPyBudWxsIDogdGlja0ludGVydmFsT3B0aW9uLFxuXHRcdFx0XHR0aWNrUGl4ZWxJbnRlcnZhbE9wdGlvbiA9IG9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWwgLyAobWlub3IgPyA1IDogMSksXG5cdFx0XHRcdHRvdGFsUGl4ZWxMZW5ndGggPSBtaW5vciA/IGF4aXNMZW5ndGggLyBheGlzLnRpY2tQb3NpdGlvbnMubGVuZ3RoIDogYXhpc0xlbmd0aDtcblx0XHRcdFxuXHRcdFx0aW50ZXJ2YWwgPSBwaWNrKFxuXHRcdFx0XHRmaWx0ZXJlZFRpY2tJbnRlcnZhbE9wdGlvbixcblx0XHRcdFx0YXhpcy5fbWlub3JBdXRvSW50ZXJ2YWwsXG5cdFx0XHRcdChyZWFsTWF4IC0gcmVhbE1pbikgKiB0aWNrUGl4ZWxJbnRlcnZhbE9wdGlvbiAvICh0b3RhbFBpeGVsTGVuZ3RoIHx8IDEpXG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHRpbnRlcnZhbCA9IG5vcm1hbGl6ZVRpY2tJbnRlcnZhbChcblx0XHRcdFx0aW50ZXJ2YWwsIFxuXHRcdFx0XHRudWxsLCBcblx0XHRcdFx0Z2V0TWFnbml0dWRlKGludGVydmFsKVxuXHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0cG9zaXRpb25zID0gbWFwKGF4aXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhcblx0XHRcdFx0aW50ZXJ2YWwsIFxuXHRcdFx0XHRyZWFsTWluLFxuXHRcdFx0XHRyZWFsTWF4XHRcblx0XHRcdCksIGxvZzJsaW4pO1xuXHRcdFx0XG5cdFx0XHRpZiAoIW1pbm9yKSB7XG5cdFx0XHRcdGF4aXMuX21pbm9yQXV0b0ludGVydmFsID0gaW50ZXJ2YWwgLyA1O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBTZXQgdGhlIGF4aXMtbGV2ZWwgdGlja0ludGVydmFsIHZhcmlhYmxlIFxuXHRcdGlmICghbWlub3IpIHtcblx0XHRcdGF4aXMudGlja0ludGVydmFsID0gaW50ZXJ2YWw7XG5cdFx0fVxuXHRcdHJldHVybiBwb3NpdGlvbnM7XG5cdH07LyoqXG5cdCAqIFRoZSB0b29sdGlwIG9iamVjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gY2hhcnQgVGhlIGNoYXJ0IGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRvb2x0aXAgb3B0aW9uc1xuXHQgKi9cblx0dmFyIFRvb2x0aXAgPSBIaWdoY2hhcnRzLlRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0VG9vbHRpcC5wcm90b3R5cGUgPSB7XG5cblx0XHRpbml0OiBmdW5jdGlvbiAoY2hhcnQsIG9wdGlvbnMpIHtcblxuXHRcdFx0dmFyIGJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdFx0c3R5bGUgPSBvcHRpb25zLnN0eWxlLFxuXHRcdFx0XHRwYWRkaW5nID0gcEludChzdHlsZS5wYWRkaW5nKTtcblxuXHRcdFx0Ly8gU2F2ZSB0aGUgY2hhcnQgYW5kIG9wdGlvbnNcblx0XHRcdHRoaXMuY2hhcnQgPSBjaGFydDtcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgc2VyaWVzXG5cdFx0XHQvL3RoaXMuY3VycmVudFNlcmllcyA9IFVOREVGSU5FRDtcblxuXHRcdFx0Ly8gTGlzdCBvZiBjcm9zc2hhaXJzXG5cdFx0XHR0aGlzLmNyb3NzaGFpcnMgPSBbXTtcblxuXHRcdFx0Ly8gQ3VycmVudCB2YWx1ZXMgb2YgeCBhbmQgeSB3aGVuIGFuaW1hdGluZ1xuXHRcdFx0dGhpcy5ub3cgPSB7IHg6IDAsIHk6IDAgfTtcblxuXHRcdFx0Ly8gVGhlIHRvb2x0aXAgaXMgaW5pdGlhbGx5IGhpZGRlblxuXHRcdFx0dGhpcy5pc0hpZGRlbiA9IHRydWU7XG5cblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSBsYWJlbFx0XHRcblx0XHRcdHRoaXMubGFiZWwgPSBjaGFydC5yZW5kZXJlci5sYWJlbCgnJywgMCwgMCwgb3B0aW9ucy5zaGFwZSB8fCAnY2FsbG91dCcsIG51bGwsIG51bGwsIG9wdGlvbnMudXNlSFRNTCwgbnVsbCwgJ3Rvb2x0aXAnKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0cGFkZGluZzogcGFkZGluZyxcblx0XHRcdFx0XHRmaWxsOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0cjogb3B0aW9ucy5ib3JkZXJSYWRpdXMsXG5cdFx0XHRcdFx0ekluZGV4OiA4XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jc3Moc3R5bGUpXG5cdFx0XHRcdC5jc3MoeyBwYWRkaW5nOiAwIH0pIC8vIFJlbW92ZSBpdCBmcm9tIFZNTCwgdGhlIHBhZGRpbmcgaXMgYXBwbGllZCBhcyBhbiBhdHRyaWJ1dGUgaW5zdGVhZCAoIzExMTcpXG5cdFx0XHRcdC5hZGQoKVxuXHRcdFx0XHQuYXR0cih7IHk6IC05OTk5IH0pOyAvLyAjMjMwMSwgIzI2NTdcblxuXHRcdFx0Ly8gV2hlbiB1c2luZyBjYW5WRyB0aGUgc2hhZG93IHNob3dzIHVwIGFzIGEgZ3JheSBjaXJjbGVcblx0XHRcdC8vIGV2ZW4gaWYgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxuXHRcdFx0aWYgKCF1c2VDYW5WRykge1xuXHRcdFx0XHR0aGlzLmxhYmVsLnNoYWRvdyhvcHRpb25zLnNoYWRvdyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1YmxpYyBwcm9wZXJ0eSBmb3IgZ2V0dGluZyB0aGUgc2hhcmVkIHN0YXRlLlxuXHRcdFx0dGhpcy5zaGFyZWQgPSBvcHRpb25zLnNoYXJlZDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSB0aGUgdG9vbHRpcCBhbmQgaXRzIGVsZW1lbnRzLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIERlc3Ryb3kgYW5kIGNsZWFyIGxvY2FsIHZhcmlhYmxlc1xuXHRcdFx0aWYgKHRoaXMubGFiZWwpIHtcblx0XHRcdFx0dGhpcy5sYWJlbCA9IHRoaXMubGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZSBhIHNvZnQgbW92ZW1lbnQgZm9yIHRoZSB0b29sdGlwXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRtb3ZlOiBmdW5jdGlvbiAoeCwgeSwgYW5jaG9yWCwgYW5jaG9yWSkge1xuXHRcdFx0dmFyIHRvb2x0aXAgPSB0aGlzLFxuXHRcdFx0XHRub3cgPSB0b29sdGlwLm5vdyxcblx0XHRcdFx0YW5pbWF0ZSA9IHRvb2x0aXAub3B0aW9ucy5hbmltYXRpb24gIT09IGZhbHNlICYmICF0b29sdGlwLmlzSGlkZGVuICYmIFxuXHRcdFx0XHRcdC8vIFdoZW4gd2UgZ2V0IGNsb3NlIHRvIHRoZSB0YXJnZXQgcG9zaXRpb24sIGFib3J0IGFuaW1hdGlvbiBhbmQgbGFuZCBvbiB0aGUgcmlnaHQgcGxhY2UgKCMzMDU2KVxuXHRcdFx0XHRcdChtYXRoQWJzKHggLSBub3cueCkgPiAxIHx8IG1hdGhBYnMoeSAtIG5vdy55KSA+IDEpLFxuXHRcdFx0XHRza2lwQW5jaG9yID0gdG9vbHRpcC5mb2xsb3dQb2ludGVyIHx8IHRvb2x0aXAubGVuID4gMTtcblxuXHRcdFx0Ly8gR2V0IGludGVybWVkaWF0ZSB2YWx1ZXMgZm9yIGFuaW1hdGlvblxuXHRcdFx0ZXh0ZW5kKG5vdywge1xuXHRcdFx0XHR4OiBhbmltYXRlID8gKDIgKiBub3cueCArIHgpIC8gMyA6IHgsXG5cdFx0XHRcdHk6IGFuaW1hdGUgPyAobm93LnkgKyB5KSAvIDIgOiB5LFxuXHRcdFx0XHRhbmNob3JYOiBza2lwQW5jaG9yID8gVU5ERUZJTkVEIDogYW5pbWF0ZSA/ICgyICogbm93LmFuY2hvclggKyBhbmNob3JYKSAvIDMgOiBhbmNob3JYLFxuXHRcdFx0XHRhbmNob3JZOiBza2lwQW5jaG9yID8gVU5ERUZJTkVEIDogYW5pbWF0ZSA/IChub3cuYW5jaG9yWSArIGFuY2hvclkpIC8gMiA6IGFuY2hvcllcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBNb3ZlIHRvIHRoZSBpbnRlcm1lZGlhdGUgdmFsdWVcblx0XHRcdHRvb2x0aXAubGFiZWwuYXR0cihub3cpO1xuXG5cdFx0XHRcblx0XHRcdC8vIFJ1biBvbiBuZXh0IHRpY2sgb2YgdGhlIG1vdXNlIHRyYWNrZXJcblx0XHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XHRcblx0XHRcdFx0Ly8gTmV2ZXIgYWxsb3cgdHdvIHRpbWVvdXRzXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFNldCB0aGUgZml4ZWQgaW50ZXJ2YWwgdGlja2luZyBmb3IgdGhlIHNtb290aCB0b29sdGlwXG5cdFx0XHRcdHRoaXMudG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvLyBUaGUgaW50ZXJ2YWwgZnVuY3Rpb24gbWF5IHN0aWxsIGJlIHJ1bm5pbmcgZHVyaW5nIGRlc3Ryb3ksIHNvIGNoZWNrIHRoYXQgdGhlIGNoYXJ0IGlzIHJlYWxseSB0aGVyZSBiZWZvcmUgY2FsbGluZy5cblx0XHRcdFx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0XHRcdFx0dG9vbHRpcC5tb3ZlKHgsIHksIGFuY2hvclgsIGFuY2hvclkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgMzIpO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlkZSB0aGUgdG9vbHRpcFxuXHRcdCAqL1xuXHRcdGhpZGU6IGZ1bmN0aW9uIChkZWxheSkge1xuXHRcdFx0dmFyIHRvb2x0aXAgPSB0aGlzLFxuXHRcdFx0XHRob3ZlclBvaW50cztcblx0XHRcdFxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTsgLy8gZGlzYWxsb3cgZHVwbGljYXRlIHRpbWVycyAoIzE3MjgsICMxNzY2KVxuXHRcdFx0aWYgKCF0aGlzLmlzSGlkZGVuKSB7XG5cdFx0XHRcdGhvdmVyUG9pbnRzID0gdGhpcy5jaGFydC5ob3ZlclBvaW50cztcblxuXHRcdFx0XHR0aGlzLmhpZGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRvb2x0aXAubGFiZWwuZmFkZU91dCgpO1xuXHRcdFx0XHRcdHRvb2x0aXAuaXNIaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9LCBwaWNrKGRlbGF5LCB0aGlzLm9wdGlvbnMuaGlkZURlbGF5LCA1MDApKTtcblxuXHRcdFx0XHQvLyBoaWRlIHByZXZpb3VzIGhvdmVyUG9pbnRzIGFuZCBzZXQgbmV3XG5cdFx0XHRcdGlmIChob3ZlclBvaW50cykge1xuXHRcdFx0XHRcdGVhY2goaG92ZXJQb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdFx0cG9pbnQuc2V0U3RhdGUoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuY2hhcnQuaG92ZXJQb2ludHMgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmNoYXJ0LmhvdmVyU2VyaWVzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKiBcblx0XHQgKiBFeHRlbmRhYmxlIG1ldGhvZCB0byBnZXQgdGhlIGFuY2hvciBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcFxuXHRcdCAqIGZyb20gYSBwb2ludCBvciBzZXQgb2YgcG9pbnRzXG5cdFx0ICovXG5cdFx0Z2V0QW5jaG9yOiBmdW5jdGlvbiAocG9pbnRzLCBtb3VzZUV2ZW50KSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRcdHBsb3RUb3AgPSBjaGFydC5wbG90VG9wLFxuXHRcdFx0XHRwbG90TGVmdCA9IGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0XHRwbG90WCA9IDAsXG5cdFx0XHRcdHBsb3RZID0gMCxcblx0XHRcdFx0eUF4aXMsXG5cdFx0XHRcdHhBeGlzO1xuXHRcdFx0XG5cdFx0XHRwb2ludHMgPSBzcGxhdChwb2ludHMpO1xuXHRcdFx0XG5cdFx0XHQvLyBQaWUgdXNlcyBhIHNwZWNpYWwgdG9vbHRpcFBvc1xuXHRcdFx0cmV0ID0gcG9pbnRzWzBdLnRvb2x0aXBQb3M7XG5cdFx0XHRcblx0XHRcdC8vIFdoZW4gdG9vbHRpcCBmb2xsb3dzIG1vdXNlLCByZWxhdGUgdGhlIHBvc2l0aW9uIHRvIHRoZSBtb3VzZVxuXHRcdFx0aWYgKHRoaXMuZm9sbG93UG9pbnRlciAmJiBtb3VzZUV2ZW50KSB7XG5cdFx0XHRcdGlmIChtb3VzZUV2ZW50LmNoYXJ0WCA9PT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0bW91c2VFdmVudCA9IGNoYXJ0LnBvaW50ZXIubm9ybWFsaXplKG1vdXNlRXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldCA9IFtcblx0XHRcdFx0XHRtb3VzZUV2ZW50LmNoYXJ0WCAtIGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0XHRcdG1vdXNlRXZlbnQuY2hhcnRZIC0gcGxvdFRvcFxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gV2hlbiBzaGFyZWQsIHVzZSB0aGUgYXZlcmFnZSBwb3NpdGlvblxuXHRcdFx0aWYgKCFyZXQpIHtcblx0XHRcdFx0ZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdHlBeGlzID0gcG9pbnQuc2VyaWVzLnlBeGlzO1xuXHRcdFx0XHRcdHhBeGlzID0gcG9pbnQuc2VyaWVzLnhBeGlzO1xuXHRcdFx0XHRcdHBsb3RYICs9IHBvaW50LnBsb3RYICArICghaW52ZXJ0ZWQgJiYgeEF4aXMgPyB4QXhpcy5sZWZ0IC0gcGxvdExlZnQgOiAwKTsgXG5cdFx0XHRcdFx0cGxvdFkgKz0gKHBvaW50LnBsb3RMb3cgPyAocG9pbnQucGxvdExvdyArIHBvaW50LnBsb3RIaWdoKSAvIDIgOiBwb2ludC5wbG90WSkgK1xuXHRcdFx0XHRcdFx0KCFpbnZlcnRlZCAmJiB5QXhpcyA/IHlBeGlzLnRvcCAtIHBsb3RUb3AgOiAwKTsgLy8gIzExNTFcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRwbG90WCAvPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRwbG90WSAvPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0ID0gW1xuXHRcdFx0XHRcdGludmVydGVkID8gY2hhcnQucGxvdFdpZHRoIC0gcGxvdFkgOiBwbG90WCxcblx0XHRcdFx0XHR0aGlzLnNoYXJlZCAmJiAhaW52ZXJ0ZWQgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgbW91c2VFdmVudCA/IFxuXHRcdFx0XHRcdFx0bW91c2VFdmVudC5jaGFydFkgLSBwbG90VG9wIDogLy8gcGxhY2Ugc2hhcmVkIHRvb2x0aXAgbmV4dCB0byB0aGUgbW91c2UgKCM0MjQpXG5cdFx0XHRcdFx0XHRpbnZlcnRlZCA/IGNoYXJ0LnBsb3RIZWlnaHQgLSBwbG90WCA6IHBsb3RZXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXAocmV0LCBtYXRoUm91bmQpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUGxhY2UgdGhlIHRvb2x0aXAgaW4gYSBjaGFydCB3aXRob3V0IHNwaWxsaW5nIG92ZXJcblx0XHQgKiBhbmQgbm90IGNvdmVyaW5nIHRoZSBwb2ludCBpdCBzZWxmLlxuXHRcdCAqL1xuXHRcdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoYm94V2lkdGgsIGJveEhlaWdodCwgcG9pbnQpIHtcblx0XHRcdFxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0ZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlLFxuXHRcdFx0XHRyZXQgPSB7fSxcblx0XHRcdFx0aCA9IHBvaW50LmgsXG5cdFx0XHRcdHN3YXBwZWQsXG5cdFx0XHRcdGZpcnN0ID0gWyd5JywgY2hhcnQuY2hhcnRIZWlnaHQsIGJveEhlaWdodCwgcG9pbnQucGxvdFkgKyBjaGFydC5wbG90VG9wXSxcblx0XHRcdFx0c2Vjb25kID0gWyd4JywgY2hhcnQuY2hhcnRXaWR0aCwgYm94V2lkdGgsIHBvaW50LnBsb3RYICsgY2hhcnQucGxvdExlZnRdLFxuXHRcdFx0XHQvLyBUaGUgZmFyIHNpZGUgaXMgcmlnaHQgb3IgYm90dG9tXG5cdFx0XHRcdHByZWZlckZhclNpZGUgPSBwaWNrKHBvaW50LnR0QmVsb3csIChjaGFydC5pbnZlcnRlZCAmJiAhcG9pbnQubmVnYXRpdmUpIHx8ICghY2hhcnQuaW52ZXJ0ZWQgJiYgcG9pbnQubmVnYXRpdmUpKSxcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEhhbmRsZSB0aGUgcHJlZmVycmVkIGRpbWVuc2lvbi4gV2hlbiB0aGUgcHJlZmVycmVkIGRpbWVuc2lvbiBpcyB0b29sdGlwXG5cdFx0XHRcdCAqIG9uIHRvcCBvciBib3R0b20gb2YgdGhlIHBvaW50LCBpdCB3aWxsIGxvb2sgZm9yIHNwYWNlIHRoZXJlLlxuXHRcdFx0XHQgKi9cblx0XHRcdFx0Zmlyc3REaW1lbnNpb24gPSBmdW5jdGlvbiAoZGltLCBvdXRlclNpemUsIGlubmVyU2l6ZSwgcG9pbnQpIHtcblx0XHRcdFx0XHR2YXIgcm9vbUxlZnQgPSBpbm5lclNpemUgPCBwb2ludCAtIGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0cm9vbVJpZ2h0ID0gcG9pbnQgKyBkaXN0YW5jZSArIGlubmVyU2l6ZSA8IG91dGVyU2l6ZSxcblx0XHRcdFx0XHRcdGFsaWduZWRMZWZ0ID0gcG9pbnQgLSBkaXN0YW5jZSAtIGlubmVyU2l6ZSxcblx0XHRcdFx0XHRcdGFsaWduZWRSaWdodCA9IHBvaW50ICsgZGlzdGFuY2U7XG5cblx0XHRcdFx0XHRpZiAocHJlZmVyRmFyU2lkZSAmJiByb29tUmlnaHQpIHtcblx0XHRcdFx0XHRcdHJldFtkaW1dID0gYWxpZ25lZFJpZ2h0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXByZWZlckZhclNpZGUgJiYgcm9vbUxlZnQpIHtcblx0XHRcdFx0XHRcdHJldFtkaW1dID0gYWxpZ25lZExlZnQ7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyb29tTGVmdCkge1xuXHRcdFx0XHRcdFx0cmV0W2RpbV0gPSBhbGlnbmVkTGVmdCAtIGggPCAwID8gYWxpZ25lZExlZnQgOiBhbGlnbmVkTGVmdCAtIGg7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyb29tUmlnaHQpIHtcblx0XHRcdFx0XHRcdHJldFtkaW1dID0gYWxpZ25lZFJpZ2h0ICsgaCArIGlubmVyU2l6ZSA+IG91dGVyU2l6ZSA/IGFsaWduZWRSaWdodCA6IGFsaWduZWRSaWdodCArIGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBIYW5kbGUgdGhlIHNlY29uZGFyeSBkaW1lbnNpb24uIElmIHRoZSBwcmVmZXJyZWQgZGltZW5zaW9uIGlzIHRvb2x0aXBcblx0XHRcdFx0ICogb24gdG9wIG9yIGJvdHRvbSBvZiB0aGUgcG9pbnQsIHRoZSBzZWNvbmQgZGltZW5zaW9uIGlzIHRvIGFsaWduIHRoZSB0b29sdGlwXG5cdFx0XHRcdCAqIGFib3ZlIHRoZSBwb2ludCwgdHJ5aW5nIHRvIGFsaWduIGNlbnRlciBidXQgYWxsb3dpbmcgbGVmdCBvciByaWdodFxuXHRcdFx0XHQgKiBhbGlnbiB3aXRoaW4gdGhlIGNoYXJ0IGJveC5cblx0XHRcdFx0ICovXG5cdFx0XHRcdHNlY29uZERpbWVuc2lvbiA9IGZ1bmN0aW9uIChkaW0sIG91dGVyU2l6ZSwgaW5uZXJTaXplLCBwb2ludCkge1xuXHRcdFx0XHRcdC8vIFRvbyBjbG9zZSB0byB0aGUgZWRnZSwgcmV0dXJuIGZhbHNlIGFuZCBzd2FwIGRpbWVuc2lvbnNcblx0XHRcdFx0XHRpZiAocG9pbnQgPCBkaXN0YW5jZSB8fCBwb2ludCA+IG91dGVyU2l6ZSAtIGRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQWxpZ24gbGVmdC90b3Bcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvaW50IDwgaW5uZXJTaXplIC8gMikge1xuXHRcdFx0XHRcdFx0cmV0W2RpbV0gPSAxO1xuXHRcdFx0XHRcdC8vIEFsaWduIHJpZ2h0L2JvdHRvbVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG9pbnQgPiBvdXRlclNpemUgLSBpbm5lclNpemUgLyAyKSB7XG5cdFx0XHRcdFx0XHRyZXRbZGltXSA9IG91dGVyU2l6ZSAtIGlubmVyU2l6ZSAtIDI7XG5cdFx0XHRcdFx0Ly8gQWxpZ24gY2VudGVyXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldFtkaW1dID0gcG9pbnQgLSBpbm5lclNpemUgLyAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIFN3YXAgdGhlIGRpbWVuc2lvbnMgXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRzd2FwID0gZnVuY3Rpb24gKGNvdW50KSB7XG5cdFx0XHRcdFx0dmFyIHRlbXAgPSBmaXJzdDtcblx0XHRcdFx0XHRmaXJzdCA9IHNlY29uZDtcblx0XHRcdFx0XHRzZWNvbmQgPSB0ZW1wO1xuXHRcdFx0XHRcdHN3YXBwZWQgPSBjb3VudDtcblx0XHRcdFx0fSxcblx0XHRcdFx0cnVuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChmaXJzdERpbWVuc2lvbi5hcHBseSgwLCBmaXJzdCkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2Vjb25kRGltZW5zaW9uLmFwcGx5KDAsIHNlY29uZCkgPT09IGZhbHNlICYmICFzd2FwcGVkKSB7XG5cdFx0XHRcdFx0XHRcdHN3YXAodHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHJ1bigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXN3YXBwZWQpIHtcblx0XHRcdFx0XHRcdHN3YXAodHJ1ZSk7XG5cdFx0XHRcdFx0XHRydW4oKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0LnggPSByZXQueSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBVbmRlciB0aGVzZSBjb25kaXRpb25zLCBwcmVmZXIgdGhlIHRvb2x0aXAgb24gdGhlIHNpZGUgb2YgdGhlIHBvaW50XG5cdFx0XHRpZiAoY2hhcnQuaW52ZXJ0ZWQgfHwgdGhpcy5sZW4gPiAxKSB7XG5cdFx0XHRcdHN3YXAoKTtcblx0XHRcdH1cblx0XHRcdHJ1bigpO1xuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbiBjYXNlIG5vIHVzZXIgZGVmaW5lZCBmb3JtYXR0ZXIgaXMgZ2l2ZW4sIHRoaXMgd2lsbCBiZSB1c2VkLiBOb3RlIHRoYXQgdGhlIGNvbnRleHRcblx0XHQgKiBoZXJlIGlzIGFuIG9iamVjdCBob2xkaW5nIHBvaW50LCBzZXJpZXMsIHgsIHkgZXRjLlxuXHRcdCAqL1xuXHRcdGRlZmF1bHRGb3JtYXR0ZXI6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSB0aGlzLnBvaW50cyB8fCBzcGxhdCh0aGlzKSxcblx0XHRcdFx0cztcblxuXHRcdFx0Ly8gYnVpbGQgdGhlIGhlYWRlclxuXHRcdFx0cyA9IFt0b29sdGlwLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoaXRlbXNbMF0pXTsgLy8jMzM5NzogYWJzdHJhY3Rpb24gdG8gZW5hYmxlIGZvcm1hdHRpbmcgb2YgZm9vdGVyIGFuZCBoZWFkZXJcblxuXHRcdFx0Ly8gYnVpbGQgdGhlIHZhbHVlc1xuXHRcdFx0cyA9IHMuY29uY2F0KHRvb2x0aXAuYm9keUZvcm1hdHRlcihpdGVtcykpO1xuXG5cdFx0XHQvLyBmb290ZXJcblx0XHRcdHMucHVzaCh0b29sdGlwLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoaXRlbXNbMF0sIHRydWUpKTsgLy8jMzM5NzogYWJzdHJhY3Rpb24gdG8gZW5hYmxlIGZvcm1hdHRpbmcgb2YgZm9vdGVyIGFuZCBoZWFkZXJcblxuXHRcdFx0cmV0dXJuIHMuam9pbignJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZnJlc2ggdGhlIHRvb2x0aXAncyB0ZXh0IGFuZCBwb3NpdGlvbi5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRcblx0XHQgKi9cblx0XHRyZWZyZXNoOiBmdW5jdGlvbiAocG9pbnQsIG1vdXNlRXZlbnQpIHtcblx0XHRcdHZhciB0b29sdGlwID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSB0b29sdGlwLmNoYXJ0LFxuXHRcdFx0XHRsYWJlbCA9IHRvb2x0aXAubGFiZWwsXG5cdFx0XHRcdG9wdGlvbnMgPSB0b29sdGlwLm9wdGlvbnMsXG5cdFx0XHRcdHgsXG5cdFx0XHRcdHksXG5cdFx0XHRcdGFuY2hvcixcblx0XHRcdFx0dGV4dENvbmZpZyA9IHt9LFxuXHRcdFx0XHR0ZXh0LFxuXHRcdFx0XHRwb2ludENvbmZpZyA9IFtdLFxuXHRcdFx0XHRmb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCB0b29sdGlwLmRlZmF1bHRGb3JtYXR0ZXIsXG5cdFx0XHRcdGhvdmVyUG9pbnRzID0gY2hhcnQuaG92ZXJQb2ludHMsXG5cdFx0XHRcdGJvcmRlckNvbG9yLFxuXHRcdFx0XHRzaGFyZWQgPSB0b29sdGlwLnNoYXJlZCxcblx0XHRcdFx0Y3VycmVudFNlcmllcztcblx0XHRcdFx0XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuXHRcdFx0XG5cdFx0XHQvLyBnZXQgdGhlIHJlZmVyZW5jZSBwb2ludCBjb29yZGluYXRlcyAocGllIGNoYXJ0cyB1c2UgdG9vbHRpcFBvcylcblx0XHRcdHRvb2x0aXAuZm9sbG93UG9pbnRlciA9IHNwbGF0KHBvaW50KVswXS5zZXJpZXMudG9vbHRpcE9wdGlvbnMuZm9sbG93UG9pbnRlcjtcblx0XHRcdGFuY2hvciA9IHRvb2x0aXAuZ2V0QW5jaG9yKHBvaW50LCBtb3VzZUV2ZW50KTtcblx0XHRcdHggPSBhbmNob3JbMF07XG5cdFx0XHR5ID0gYW5jaG9yWzFdO1xuXG5cdFx0XHQvLyBzaGFyZWQgdG9vbHRpcCwgYXJyYXkgaXMgc2VudCBvdmVyXG5cdFx0XHRpZiAoc2hhcmVkICYmICEocG9pbnQuc2VyaWVzICYmIHBvaW50LnNlcmllcy5ub1NoYXJlZFRvb2x0aXApKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBoaWRlIHByZXZpb3VzIGhvdmVyUG9pbnRzIGFuZCBzZXQgbmV3XG5cdFx0XHRcdFxuXHRcdFx0XHRjaGFydC5ob3ZlclBvaW50cyA9IHBvaW50O1xuXHRcdFx0XHRpZiAoaG92ZXJQb2ludHMpIHtcblx0XHRcdFx0XHRlYWNoKGhvdmVyUG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRcdHBvaW50LnNldFN0YXRlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlYWNoKHBvaW50LCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRcdGl0ZW0uc2V0U3RhdGUoSE9WRVJfU1RBVEUpO1xuXG5cdFx0XHRcdFx0cG9pbnRDb25maWcucHVzaChpdGVtLmdldExhYmVsQ29uZmlnKCkpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0ZXh0Q29uZmlnID0ge1xuXHRcdFx0XHRcdHg6IHBvaW50WzBdLmNhdGVnb3J5LFxuXHRcdFx0XHRcdHk6IHBvaW50WzBdLnlcblx0XHRcdFx0fTtcblx0XHRcdFx0dGV4dENvbmZpZy5wb2ludHMgPSBwb2ludENvbmZpZztcblx0XHRcdFx0dGhpcy5sZW4gPSBwb2ludENvbmZpZy5sZW5ndGg7XG5cdFx0XHRcdHBvaW50ID0gcG9pbnRbMF07XG5cblx0XHRcdC8vIHNpbmdsZSBwb2ludCB0b29sdGlwXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0ZXh0Q29uZmlnID0gcG9pbnQuZ2V0TGFiZWxDb25maWcoKTtcblx0XHRcdH1cblx0XHRcdHRleHQgPSBmb3JtYXR0ZXIuY2FsbCh0ZXh0Q29uZmlnLCB0b29sdGlwKTtcblxuXHRcdFx0Ly8gcmVnaXN0ZXIgdGhlIGN1cnJlbnQgc2VyaWVzXG5cdFx0XHRjdXJyZW50U2VyaWVzID0gcG9pbnQuc2VyaWVzO1xuXHRcdFx0dGhpcy5kaXN0YW5jZSA9IHBpY2soY3VycmVudFNlcmllcy50b29sdGlwT3B0aW9ucy5kaXN0YW5jZSwgMTYpO1xuXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGlubmVyIEhUTUxcblx0XHRcdGlmICh0ZXh0ID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gc2hvdyBpdFxuXHRcdFx0XHRpZiAodG9vbHRpcC5pc0hpZGRlbikge1xuXHRcdFx0XHRcdHN0b3AobGFiZWwpO1xuXHRcdFx0XHRcdGxhYmVsLmF0dHIoJ29wYWNpdHknLCAxKS5zaG93KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1cGRhdGUgdGV4dFxuXHRcdFx0XHRsYWJlbC5hdHRyKHtcblx0XHRcdFx0XHR0ZXh0OiB0ZXh0XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIHNldCB0aGUgc3Ryb2tlIGNvbG9yIG9mIHRoZSBib3hcblx0XHRcdFx0Ym9yZGVyQ29sb3IgPSBvcHRpb25zLmJvcmRlckNvbG9yIHx8IHBvaW50LmNvbG9yIHx8IGN1cnJlbnRTZXJpZXMuY29sb3IgfHwgJyM2MDYwNjAnO1xuXHRcdFx0XHRsYWJlbC5hdHRyKHtcblx0XHRcdFx0XHRzdHJva2U6IGJvcmRlckNvbG9yXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0b29sdGlwLnVwZGF0ZVBvc2l0aW9uKHsgXG5cdFx0XHRcdFx0cGxvdFg6IHgsIFxuXHRcdFx0XHRcdHBsb3RZOiB5LCBcblx0XHRcdFx0XHRuZWdhdGl2ZTogcG9pbnQubmVnYXRpdmUsIFxuXHRcdFx0XHRcdHR0QmVsb3c6IHBvaW50LnR0QmVsb3csIFxuXHRcdFx0XHRcdGg6IChwb2ludC5zaGFwZUFyZ3MgJiYgcG9pbnQuc2hhcGVBcmdzLmhlaWdodCkgfHwgMFxuXHRcdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0XHR0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICd0b29sdGlwUmVmcmVzaCcsIHtcblx0XHRcdFx0XHR0ZXh0OiB0ZXh0LFxuXHRcdFx0XHRcdHg6IHggKyBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0XHR5OiB5ICsgY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogYm9yZGVyQ29sb3Jcblx0XHRcdFx0fSk7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBGaW5kIHRoZSBuZXcgcG9zaXRpb24gYW5kIHBlcmZvcm0gdGhlIG1vdmVcblx0XHQgKi9cblx0XHR1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRsYWJlbCA9IHRoaXMubGFiZWwsIFxuXHRcdFx0XHRwb3MgPSAodGhpcy5vcHRpb25zLnBvc2l0aW9uZXIgfHwgdGhpcy5nZXRQb3NpdGlvbikuY2FsbChcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdGxhYmVsLndpZHRoLFxuXHRcdFx0XHRcdGxhYmVsLmhlaWdodCxcblx0XHRcdFx0XHRwb2ludFxuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBkbyB0aGUgbW92ZVxuXHRcdFx0dGhpcy5tb3ZlKFxuXHRcdFx0XHRtYXRoUm91bmQocG9zLngpLCBcblx0XHRcdFx0bWF0aFJvdW5kKHBvcy55KSwgXG5cdFx0XHRcdHBvaW50LnBsb3RYICsgY2hhcnQucGxvdExlZnQsIFxuXHRcdFx0XHRwb2ludC5wbG90WSArIGNoYXJ0LnBsb3RUb3Bcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKiBcblx0XHQgKiBHZXQgdGhlIGJlc3QgWCBkYXRlIGZvcm1hdCBiYXNlZCBvbiB0aGUgY2xvc2VzdCBwb2ludCByYW5nZSBvbiB0aGUgYXhpcy5cblx0XHQgKi9cblx0XHRnZXRYRGF0ZUZvcm1hdDogZnVuY3Rpb24gKHBvaW50LCBvcHRpb25zLCB4QXhpcykge1xuXHRcdFx0dmFyIHhEYXRlRm9ybWF0LFxuXHRcdFx0XHRkYXRlVGltZUxhYmVsRm9ybWF0cyA9IG9wdGlvbnMuZGF0ZVRpbWVMYWJlbEZvcm1hdHMsXG5cdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlID0geEF4aXMgJiYgeEF4aXMuY2xvc2VzdFBvaW50UmFuZ2UsXG5cdFx0XHRcdG4sXG5cdFx0XHRcdGJsYW5rID0gJzAxLTAxIDAwOjAwOjAwLjAwMCcsXG5cdFx0XHRcdHN0cnBvcyA9IHtcblx0XHRcdFx0XHRtaWxsaXNlY29uZDogMTUsXG5cdFx0XHRcdFx0c2Vjb25kOiAxMixcblx0XHRcdFx0XHRtaW51dGU6IDksXG5cdFx0XHRcdFx0aG91cjogNixcblx0XHRcdFx0XHRkYXk6IDNcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGF0ZSxcblx0XHRcdFx0bGFzdE47XG5cblx0XHRcdGlmIChjbG9zZXN0UG9pbnRSYW5nZSkge1xuXHRcdFx0XHRkYXRlID0gZGF0ZUZvcm1hdCgnJW0tJWQgJUg6JU06JVMuJUwnLCBwb2ludC54KTtcblx0XHRcdFx0Zm9yIChuIGluIHRpbWVVbml0cykge1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJhbmdlIGlzIGV4YWN0bHkgb25lIHdlZWsgYW5kIHdlJ3JlIGxvb2tpbmcgYXQgYSBTdW5kYXkvTW9uZGF5LCBnbyBmb3IgdGhlIHdlZWsgZm9ybWF0XG5cdFx0XHRcdFx0aWYgKGNsb3Nlc3RQb2ludFJhbmdlID09PSB0aW1lVW5pdHMud2VlayAmJiArZGF0ZUZvcm1hdCgnJXcnLCBwb2ludC54KSA9PT0geEF4aXMub3B0aW9ucy5zdGFydE9mV2VlayAmJiBcblx0XHRcdFx0XHRcdFx0ZGF0ZS5zdWJzdHIoNikgPT09IGJsYW5rLnN1YnN0cig2KSkge1xuXHRcdFx0XHRcdFx0biA9ICd3ZWVrJztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Ly8gVGhlIGZpcnN0IGZvcm1hdCB0aGF0IGlzIHRvbyBncmVhdCBmb3IgdGhlIHJhbmdlXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aW1lVW5pdHNbbl0gPiBjbG9zZXN0UG9pbnRSYW5nZSkge1xuXHRcdFx0XHRcdFx0biA9IGxhc3ROO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHBvaW50IGlzIHBsYWNlZCBldmVyeSBkYXkgYXQgMjM6NTksIHdlIG5lZWQgdG8gc2hvd1xuXHRcdFx0XHRcdC8vIHRoZSBtaW51dGVzIGFzIHdlbGwuICMyNjM3LlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RycG9zW25dICYmIGRhdGUuc3Vic3RyKHN0cnBvc1tuXSkgIT09IGJsYW5rLnN1YnN0cihzdHJwb3Nbbl0pKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBXZWVrcyBhcmUgb3V0c2lkZSB0aGUgaGllcmFyY2h5LCBvbmx5IGFwcGx5IHRoZW0gb24gTW9uZGF5cy9TdW5kYXlzIGxpa2UgaW4gdGhlIGZpcnN0IGNvbmRpdGlvblxuXHRcdFx0XHRcdGlmIChuICE9PSAnd2VlaycpIHtcblx0XHRcdFx0XHRcdGxhc3ROID0gbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChuKSB7XG5cdFx0XHRcdFx0eERhdGVGb3JtYXQgPSBkYXRlVGltZUxhYmVsRm9ybWF0c1tuXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eERhdGVGb3JtYXQgPSBkYXRlVGltZUxhYmVsRm9ybWF0cy5kYXk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB4RGF0ZUZvcm1hdCB8fCBkYXRlVGltZUxhYmVsRm9ybWF0cy55ZWFyOyAvLyAjMjU0NiwgMjU4MVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGb3JtYXQgdGhlIGZvb3Rlci9oZWFkZXIgb2YgdGhlIHRvb2x0aXBcblx0XHQgKiAjMzM5NzogYWJzdHJhY3Rpb24gdG8gZW5hYmxlIGZvcm1hdHRpbmcgb2YgZm9vdGVyIGFuZCBoZWFkZXJcblx0XHQgKi9cblx0XHR0b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyOiBmdW5jdGlvbiAocG9pbnQsIGlzRm9vdGVyKSB7XG5cdFx0XHR2YXIgZm9vdE9ySGVhZCA9IGlzRm9vdGVyID8gJ2Zvb3RlcicgOiAnaGVhZGVyJyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHR0b29sdGlwT3B0aW9ucyA9IHNlcmllcy50b29sdGlwT3B0aW9ucyxcblx0XHRcdFx0eERhdGVGb3JtYXQgPSB0b29sdGlwT3B0aW9ucy54RGF0ZUZvcm1hdCxcblx0XHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHRcdGlzRGF0ZVRpbWUgPSB4QXhpcyAmJiB4QXhpcy5vcHRpb25zLnR5cGUgPT09ICdkYXRldGltZScgJiYgaXNOdW1iZXIocG9pbnQua2V5KSxcblx0XHRcdFx0Zm9ybWF0U3RyaW5nID0gdG9vbHRpcE9wdGlvbnNbZm9vdE9ySGVhZCsnRm9ybWF0J107XG5cblx0XHRcdC8vIEd1ZXNzIHRoZSBiZXN0IGRhdGUgZm9ybWF0IGJhc2VkIG9uIHRoZSBjbG9zZXN0IHBvaW50IGRpc3RhbmNlICgjNTY4LCAjMzQxOClcblx0XHRcdGlmIChpc0RhdGVUaW1lICYmICF4RGF0ZUZvcm1hdCkge1xuXHRcdFx0XHR4RGF0ZUZvcm1hdCA9IHRoaXMuZ2V0WERhdGVGb3JtYXQocG9pbnQsIHRvb2x0aXBPcHRpb25zLCB4QXhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluc2VydCB0aGUgZm9vdGVyIGRhdGUgZm9ybWF0IGlmIGFueVxuXHRcdFx0aWYgKGlzRGF0ZVRpbWUgJiYgeERhdGVGb3JtYXQpIHtcblx0XHRcdFx0Zm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnJlcGxhY2UoJ3twb2ludC5rZXl9JywgJ3twb2ludC5rZXk6JyArIHhEYXRlRm9ybWF0ICsgJ30nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZvcm1hdChmb3JtYXRTdHJpbmcsIHtcblx0XHRcdFx0cG9pbnQ6IHBvaW50LFxuXHRcdFx0XHRzZXJpZXM6IHNlcmllc1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHQgICAgICogQnVpbGQgdGhlIGJvZHkgKGxpbmVzKSBvZiB0aGUgdG9vbHRpcCBieSBpdGVyYXRpbmcgb3ZlciB0aGUgaXRlbXMgYW5kIHJldHVybmluZyBvbmUgZW50cnkgZm9yIGVhY2ggaXRlbSxcblx0ICAgICAqIGFic3RyYWN0aW5nIHRoaXMgZnVuY3Rpb25hbGl0eSBhbGxvd3MgdG8gZWFzaWx5IG92ZXJ3cml0ZSBhbmQgZXh0ZW5kIGl0LiBcblx0XHQgKi9cblx0XHRib2R5Rm9ybWF0dGVyOiBmdW5jdGlvbiAoaXRlbXMpIHtcblx0ICAgICAgICByZXR1cm4gbWFwKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgICB2YXIgdG9vbHRpcE9wdGlvbnMgPSBpdGVtLnNlcmllcy50b29sdGlwT3B0aW9ucztcblx0ICAgICAgICAgICAgcmV0dXJuICh0b29sdGlwT3B0aW9ucy5wb2ludEZvcm1hdHRlciB8fCBpdGVtLnBvaW50LnRvb2x0aXBGb3JtYXR0ZXIpLmNhbGwoaXRlbS5wb2ludCwgdG9vbHRpcE9wdGlvbnMucG9pbnRGb3JtYXQpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgXG5cdH07XG5cblx0dmFyIGhvdmVyQ2hhcnRJbmRleDtcblxuXHQvLyBHbG9iYWwgZmxhZyBmb3IgdG91Y2ggc3VwcG9ydFxuXHRoYXNUb3VjaCA9IGRvYy5kb2N1bWVudEVsZW1lbnQub250b3VjaHN0YXJ0ICE9PSBVTkRFRklORUQ7XG5cblx0LyoqXG5cdCAqIFRoZSBtb3VzZSB0cmFja2VyIG9iamVjdC4gQWxsIG1ldGhvZHMgc3RhcnRpbmcgd2l0aCBcIm9uXCIgYXJlIHByaW1hcnkgRE9NIGV2ZW50IGhhbmRsZXJzLiBcblx0ICogU3Vic2VxdWVudCBtZXRob2RzIHNob3VsZCBiZSBuYW1lZCBkaWZmZXJlbnRseSBmcm9tIHdoYXQgdGhleSBhcmUgZG9pbmcuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjaGFydCBUaGUgQ2hhcnQgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIHJvb3Qgb3B0aW9ucyBvYmplY3Rcblx0ICovXG5cdHZhciBQb2ludGVyID0gSGlnaGNoYXJ0cy5Qb2ludGVyID0gZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0dGhpcy5pbml0KGNoYXJ0LCBvcHRpb25zKTtcblx0fTtcblxuXHRQb2ludGVyLnByb3RvdHlwZSA9IHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIFBvaW50ZXJcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoY2hhcnQsIG9wdGlvbnMpIHtcblx0XHRcdFxuXHRcdFx0dmFyIGNoYXJ0T3B0aW9ucyA9IG9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdGNoYXJ0RXZlbnRzID0gY2hhcnRPcHRpb25zLmV2ZW50cyxcblx0XHRcdFx0em9vbVR5cGUgPSB1c2VDYW5WRyA/ICcnIDogY2hhcnRPcHRpb25zLnpvb21UeXBlLFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHR6b29tWCxcblx0XHRcdFx0em9vbVk7XG5cblx0XHRcdC8vIFN0b3JlIHJlZmVyZW5jZXNcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHR0aGlzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XHRcblx0XHRcdC8vIFpvb20gc3RhdHVzXG5cdFx0XHR0aGlzLnpvb21YID0gem9vbVggPSAveC8udGVzdCh6b29tVHlwZSk7XG5cdFx0XHR0aGlzLnpvb21ZID0gem9vbVkgPSAveS8udGVzdCh6b29tVHlwZSk7XG5cdFx0XHR0aGlzLnpvb21Ib3IgPSAoem9vbVggJiYgIWludmVydGVkKSB8fCAoem9vbVkgJiYgaW52ZXJ0ZWQpO1xuXHRcdFx0dGhpcy56b29tVmVydCA9ICh6b29tWSAmJiAhaW52ZXJ0ZWQpIHx8ICh6b29tWCAmJiBpbnZlcnRlZCk7XG5cdFx0XHR0aGlzLmhhc1pvb20gPSB6b29tWCB8fCB6b29tWTtcblxuXHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBoYW5kbGUgY2xpY2sgb24gYSB0b3VjaCBkZXZpY2U/XG5cdFx0XHR0aGlzLnJ1bkNoYXJ0Q2xpY2sgPSBjaGFydEV2ZW50cyAmJiAhIWNoYXJ0RXZlbnRzLmNsaWNrO1xuXG5cdFx0XHR0aGlzLnBpbmNoRG93biA9IFtdO1xuXHRcdFx0dGhpcy5sYXN0VmFsaWRUb3VjaCA9IHt9O1xuXG5cdFx0XHRpZiAoSGlnaGNoYXJ0cy5Ub29sdGlwICYmIG9wdGlvbnMudG9vbHRpcC5lbmFibGVkKSB7XG5cdFx0XHRcdGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcChjaGFydCwgb3B0aW9ucy50b29sdGlwKTtcblx0XHRcdFx0dGhpcy5mb2xsb3dUb3VjaE1vdmUgPSBwaWNrKG9wdGlvbnMudG9vbHRpcC5mb2xsb3dUb3VjaE1vdmUsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldERPTUV2ZW50cygpO1xuXHRcdH0sIFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIGNyb3NzYnJvd3NlciBzdXBwb3J0IGZvciBjaGFydFggYW5kIGNoYXJ0WVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3QgaW4gc3RhbmRhcmQgYnJvd3NlcnNcblx0XHQgKi9cblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uIChlLCBjaGFydFBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgY2hhcnRYLFxuXHRcdFx0XHRjaGFydFksXG5cdFx0XHRcdGVQb3M7XG5cblx0XHRcdC8vIGNvbW1vbiBJRSBub3JtYWxpemluZ1xuXHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG5cdFx0XHQvLyBGcmFtZXdvcmsgc3BlY2lmaWMgbm9ybWFsaXppbmcgKCMxMTY1KVxuXHRcdFx0ZSA9IHdhc2hNb3VzZUV2ZW50KGUpO1xuXG5cdFx0XHQvLyBNb3JlIElFIG5vcm1hbGl6aW5nLCBuZWVkcyB0byBnbyBhZnRlciB3YXNoTW91c2VFdmVudFxuXHRcdFx0aWYgKCFlLnRhcmdldCkge1xuXHRcdFx0XHRlLnRhcmdldCA9IGUuc3JjRWxlbWVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gaU9TICgjMjc1Nylcblx0XHRcdGVQb3MgPSBlLnRvdWNoZXMgPyAgKGUudG91Y2hlcy5sZW5ndGggPyBlLnRvdWNoZXMuaXRlbSgwKSA6IGUuY2hhbmdlZFRvdWNoZXNbMF0pIDogZTtcblxuXHRcdFx0Ly8gR2V0IG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRpZiAoIWNoYXJ0UG9zaXRpb24pIHtcblx0XHRcdFx0dGhpcy5jaGFydFBvc2l0aW9uID0gY2hhcnRQb3NpdGlvbiA9IG9mZnNldCh0aGlzLmNoYXJ0LmNvbnRhaW5lcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoYXJ0WCBhbmQgY2hhcnRZXG5cdFx0XHRpZiAoZVBvcy5wYWdlWCA9PT0gVU5ERUZJTkVEKSB7IC8vIElFIDwgOS4gIzg4Ni5cblx0XHRcdFx0Y2hhcnRYID0gbWF0aE1heChlLngsIGUuY2xpZW50WCAtIGNoYXJ0UG9zaXRpb24ubGVmdCk7IC8vICMyMDA1LCAjMjEyOTogdGhlIHNlY29uZCBjYXNlIGlzIFxuXHRcdFx0XHRcdC8vIGZvciBJRTEwIHF1aXJrcyBtb2RlIHdpdGhpbiBmcmFtZXNldHNcblx0XHRcdFx0Y2hhcnRZID0gZS55O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhcnRYID0gZVBvcy5wYWdlWCAtIGNoYXJ0UG9zaXRpb24ubGVmdDtcblx0XHRcdFx0Y2hhcnRZID0gZVBvcy5wYWdlWSAtIGNoYXJ0UG9zaXRpb24udG9wO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXh0ZW5kKGUsIHtcblx0XHRcdFx0Y2hhcnRYOiBtYXRoUm91bmQoY2hhcnRYKSxcblx0XHRcdFx0Y2hhcnRZOiBtYXRoUm91bmQoY2hhcnRZKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgY2xpY2sgcG9zaXRpb24gaW4gdGVybXMgb2YgYXhpcyB2YWx1ZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZSBBIHBvaW50ZXIgZXZlbnRcblx0XHQgKi9cblx0XHRnZXRDb29yZGluYXRlczogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjb29yZGluYXRlcyA9IHtcblx0XHRcdFx0XHR4QXhpczogW10sXG5cdFx0XHRcdFx0eUF4aXM6IFtdXG5cdFx0XHRcdH07XG5cblx0XHRcdGVhY2godGhpcy5jaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRjb29yZGluYXRlc1theGlzLmlzWEF4aXMgPyAneEF4aXMnIDogJ3lBeGlzJ10ucHVzaCh7XG5cdFx0XHRcdFx0YXhpczogYXhpcyxcblx0XHRcdFx0XHR2YWx1ZTogYXhpcy50b1ZhbHVlKGVbYXhpcy5ob3JpeiA/ICdjaGFydFgnIDogJ2NoYXJ0WSddKVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGNvb3JkaW5hdGVzO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogV2l0aCBsaW5lIHR5cGUgY2hhcnRzIHdpdGggYSBzaW5nbGUgdHJhY2tlciwgZ2V0IHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBtb3VzZS5cblx0XHQgKiBSdW4gUG9pbnQub25Nb3VzZU92ZXIgYW5kIGRpc3BsYXkgdG9vbHRpcCBmb3IgdGhlIHBvaW50IG9yIHBvaW50cy5cblx0XHQgKi9cblx0XHRydW5Qb2ludEFjdGlvbnM6IGZ1bmN0aW9uIChlKSB7XG5cblx0XHRcdHZhciBwb2ludGVyID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBwb2ludGVyLmNoYXJ0LFxuXHRcdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXMsXG5cdFx0XHRcdHRvb2x0aXAgPSBjaGFydC50b29sdGlwLFxuXHRcdFx0XHRzaGFyZWQgPSB0b29sdGlwID8gdG9vbHRpcC5zaGFyZWQgOiBmYWxzZSxcblx0XHRcdFx0Zm9sbG93UG9pbnRlcixcblx0XHRcdFx0Ly9wb2ludCxcblx0XHRcdFx0Ly9wb2ludHMsXG5cdFx0XHRcdGhvdmVyUG9pbnQgPSBjaGFydC5ob3ZlclBvaW50LFxuXHRcdFx0XHRob3ZlclNlcmllcyA9IGNoYXJ0LmhvdmVyU2VyaWVzLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHQvL2osXG5cdFx0XHRcdGRpc3RhbmNlID0gY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdFx0cmRpc3RhbmNlID0gY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdFx0YW5jaG9yLFxuXHRcdFx0XHRub1NoYXJlZFRvb2x0aXAsXG5cdFx0XHRcdGtkcG9pbnRzID0gW10sXG5cdFx0XHRcdGtkcG9pbnQsXG5cdFx0XHRcdGtkcG9pbnRUO1xuXG5cdFx0XHQvLyBGb3IgaG92ZXJpbmcgb3ZlciB0aGUgZW1wdHkgcGFydHMgb2YgdGhlIHBsb3QgYXJlYSAoaG92ZXJTZXJpZXMgaXMgdW5kZWZpbmVkKS4gXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBvbmUgc2VyaWVzIHdpdGggcG9pbnQgdHJhY2tpbmcgKGNvbWJvIGNoYXJ0KSwgZG9uJ3QgZ28gdG8gbmVhcmVzdCBuZWlnaGJvdXIuXG5cdFx0XHRpZiAoIXNoYXJlZCAmJiAhaG92ZXJTZXJpZXMpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChzZXJpZXNbaV0uZGlyZWN0VG91Y2ggfHwgIXNlcmllc1tpXS5vcHRpb25zLnN0aWNreVRyYWNraW5nKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMgPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHNoYXJlZCB0b29sdGlwIG9yIGNhc2VzIHdoZXJlIGEgc2VyaWVzIGlzIG5vdCB5ZXQgaG92ZXJlZFxuXHRcdFx0aWYgKCEoaG92ZXJTZXJpZXMgJiYgaG92ZXJTZXJpZXMubm9TaGFyZWRUb29sdGlwKSAmJiAoc2hhcmVkIHx8ICFob3ZlclNlcmllcykpIHsgLy8gIzM4MjEgXG5cdFx0XHRcdC8vIEZpbmQgbmVhcmVzdCBwb2ludHMgb24gYWxsIHNlcmllc1xuXHRcdFx0XHRlYWNoKHNlcmllcywgZnVuY3Rpb24gKHMpIHtcblx0XHRcdFx0XHQvLyBTa2lwIGhpZGRlbiBzZXJpZXNcblx0XHRcdFx0XHRub1NoYXJlZFRvb2x0aXAgPSBzLm5vU2hhcmVkVG9vbHRpcCAmJiBzaGFyZWQ7XG5cdFx0XHRcdFx0aWYgKHMudmlzaWJsZSAmJiAhbm9TaGFyZWRUb29sdGlwICYmIHBpY2socy5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcsIHRydWUpKSB7IC8vICMzODIxXG5cdFx0XHRcdFx0XHRrZHBvaW50VCA9IHMuc2VhcmNoUG9pbnQoZSk7IC8vICMzODI4XG5cdFx0XHRcdFx0XHRpZiAoa2Rwb2ludFQpIHtcblx0XHRcdFx0XHRcdFx0a2Rwb2ludHMucHVzaChrZHBvaW50VCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gRmluZCBhYnNvbHV0ZSBuZWFyZXN0IHBvaW50XG5cdFx0XHRcdGVhY2goa2Rwb2ludHMsIGZ1bmN0aW9uIChwKSB7XG5cdFx0XHRcdFx0aWYgKHAgJiYgZGVmaW5lZChwLnBsb3RYKSAmJiBkZWZpbmVkKHAucGxvdFkpKSB7XG5cdFx0XHRcdFx0XHRpZiAoKHAuZGlzdC5kaXN0WCA8IGRpc3RhbmNlKSB8fCAoKHAuZGlzdC5kaXN0WCA9PT0gZGlzdGFuY2UgfHwgcC5zZXJpZXMua2REaW1lbnNpb25zID4gMSkgJiYgcC5kaXN0LmRpc3RSIDwgcmRpc3RhbmNlKSkge1xuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZSA9IHAuZGlzdC5kaXN0WDtcblx0XHRcdFx0XHRcdFx0cmRpc3RhbmNlID0gcC5kaXN0LmRpc3RSO1xuXHRcdFx0XHRcdFx0XHRrZHBvaW50ID0gcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1x0XG5cblx0XHRcdC8vIEhhbmRsZSBub24tc2hhcmVkIHRvb2x0aXBzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiBpdCBoYXMgYSBob3ZlclBvaW50IGFuZCB0aGF0IHNlcmllcyByZXF1aXJlcyBkaXJlY3QgdG91Y2ggKGxpa2UgY29sdW1ucyksIHVzZSB0aGUgaG92ZXJQb2ludCAoIzM4OTkpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHNlYXJjaCB0aGUgay1kIHRyZWUgKGxpa2Ugc2NhdHRlcikuXG5cdFx0XHRcdGtkcG9pbnQgPSAoaG92ZXJTZXJpZXMuZGlyZWN0VG91Y2ggJiYgaG92ZXJQb2ludCkgfHwgKGhvdmVyU2VyaWVzICYmIGhvdmVyU2VyaWVzLnNlYXJjaFBvaW50KGUpKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVmcmVzaCB0b29sdGlwIGZvciBrZHBvaW50IGlmIG5ldyBob3ZlciBwb2ludCBvciB0b29sdGlwIHdhcyBoaWRkZW4gLy8gIzM5MjZcblx0XHRcdGlmIChrZHBvaW50ICYmIChrZHBvaW50ICE9PSBob3ZlclBvaW50IHx8ICh0b29sdGlwICYmIHRvb2x0aXAuaXNIaWRkZW4pKSkge1xuXHRcdFx0XHQvLyBEcmF3IHRvb2x0aXAgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdGlmIChzaGFyZWQgJiYgIWtkcG9pbnQuc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkge1xuXHRcdFx0XHRcdGkgPSBrZHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdFx0aWYgKGtkcG9pbnRzW2ldLmNsaWVudFggIT09IGtkcG9pbnQuY2xpZW50WCB8fCAoa2Rwb2ludHNbaV0uc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCB8fCBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdFx0a2Rwb2ludHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoa2Rwb2ludHMubGVuZ3RoICYmIHRvb2x0aXApIHtcblx0XHRcdFx0XHRcdHRvb2x0aXAucmVmcmVzaChrZHBvaW50cywgZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZG8gbW91c2VvdmVyIG9uIGFsbCBwb2ludHMgZXhjZXB0IHRoZSBjbG9zZXN0XG5cdFx0XHRcdFx0ZWFjaChrZHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0XHRpZiAocG9pbnQgIT09IGtkcG9pbnQpIHsgXG5cdFx0XHRcdFx0XHRcdHBvaW50Lm9uTW91c2VPdmVyKGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1x0XHRcdFx0XG5cdFx0XHRcdFx0a2Rwb2ludC5vbk1vdXNlT3ZlcihlKTsgLy8gIzM5MTkgZG8gbW91c2VvdmVyIG9uIHRoZSBjbG9zZXN0IHBvaW50IGxhc3QgdG8gZW5zdXJlIGl0IGlzIHRoZSBob3ZlcnBvaW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRvb2x0aXApIHsgXG5cdFx0XHRcdFx0XHR0b29sdGlwLnJlZnJlc2goa2Rwb2ludCwgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGtkcG9pbnQub25Nb3VzZU92ZXIoZSk7IFxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFVwZGF0ZSBwb3NpdGlvbnMgKHJlZ2FyZGxlc3Mgb2Yga2Rwb2ludCBvciBob3ZlclBvaW50KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9sbG93UG9pbnRlciA9IGhvdmVyU2VyaWVzICYmIGhvdmVyU2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7XG5cdFx0XHRcdGlmICh0b29sdGlwICYmIGZvbGxvd1BvaW50ZXIgJiYgIXRvb2x0aXAuaXNIaWRkZW4pIHtcblx0XHRcdFx0XHRhbmNob3IgPSB0b29sdGlwLmdldEFuY2hvcihbe31dLCBlKTtcblx0XHRcdFx0XHR0b29sdGlwLnVwZGF0ZVBvc2l0aW9uKHsgcGxvdFg6IGFuY2hvclswXSwgcGxvdFk6IGFuY2hvclsxXSB9KTtcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8gcGljayB1cCB0aGUgdG9vbHRpcCBcblx0XHRcdGlmICh0b29sdGlwICYmICFwb2ludGVyLl9vbkRvY3VtZW50TW91c2VNb3ZlKSB7XG5cdFx0XHRcdHBvaW50ZXIuX29uRG9jdW1lbnRNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGlmIChjaGFydHNbaG92ZXJDaGFydEluZGV4XSkge1xuXHRcdFx0XHRcdFx0Y2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0ucG9pbnRlci5vbkRvY3VtZW50TW91c2VNb3ZlKGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0YWRkRXZlbnQoZG9jLCAnbW91c2Vtb3ZlJywgcG9pbnRlci5fb25Eb2N1bWVudE1vdXNlTW92ZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIENyb3NzaGFpclxuXHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRheGlzLmRyYXdDcm9zc2hhaXIoZSwgcGljayhrZHBvaW50LCBob3ZlclBvaW50KSk7XG5cdFx0XHR9KTtcdFxuXHRcdFx0XHRcdFxuXHRcdH0sXG5cblxuXG5cdFx0LyoqXG5cdFx0ICogUmVzZXQgdGhlIHRyYWNraW5nIGJ5IGhpZGluZyB0aGUgdG9vbHRpcCwgdGhlIGhvdmVyIHNlcmllcyBzdGF0ZSBhbmQgdGhlIGhvdmVyIHBvaW50XG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIGFsbG93TW92ZSB7Qm9vbGVhbn0gSW5zdGVhZCBvZiBkZXN0cm95aW5nIHRoZSB0b29sdGlwIGFsdG9nZXRoZXIsIGFsbG93IG1vdmluZyBpdCBpZiBwb3NzaWJsZVxuXHRcdCAqL1xuXHRcdHJlc2V0OiBmdW5jdGlvbiAoYWxsb3dNb3ZlLCBkZWxheSkge1xuXHRcdFx0dmFyIHBvaW50ZXIgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHBvaW50ZXIuY2hhcnQsXG5cdFx0XHRcdGhvdmVyU2VyaWVzID0gY2hhcnQuaG92ZXJTZXJpZXMsXG5cdFx0XHRcdGhvdmVyUG9pbnQgPSBjaGFydC5ob3ZlclBvaW50LFxuXHRcdFx0XHR0b29sdGlwID0gY2hhcnQudG9vbHRpcCxcblx0XHRcdFx0dG9vbHRpcFBvaW50cyA9IHRvb2x0aXAgJiYgdG9vbHRpcC5zaGFyZWQgPyBjaGFydC5ob3ZlclBvaW50cyA6IGhvdmVyUG9pbnQ7XG5cdFx0XHRcdFxuXHRcdFx0Ly8gTmFycm93IGluIGFsbG93TW92ZVxuXHRcdFx0YWxsb3dNb3ZlID0gYWxsb3dNb3ZlICYmIHRvb2x0aXAgJiYgdG9vbHRpcFBvaW50cztcblx0XHRcdFx0XG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgcG9pbnRzIGhhdmUgbW92ZWQgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCAjMTAwM1x0XHRcblx0XHRcdGlmIChhbGxvd01vdmUgICYmIHNwbGF0KHRvb2x0aXBQb2ludHMpWzBdLnBsb3RYID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0YWxsb3dNb3ZlID0gZmFsc2U7XG5cdFx0XHR9XHRcblx0XHRcdC8vIEp1c3QgbW92ZSB0aGUgdG9vbHRpcCwgIzM0OVxuXHRcdFx0aWYgKGFsbG93TW92ZSkge1xuXHRcdFx0XHR0b29sdGlwLnJlZnJlc2godG9vbHRpcFBvaW50cyk7XG5cdFx0XHRcdGlmIChob3ZlclBvaW50KSB7IC8vICMyNTAwXG5cdFx0XHRcdFx0aG92ZXJQb2ludC5zZXRTdGF0ZShob3ZlclBvaW50LnN0YXRlLCB0cnVlKTtcblx0XHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0XHRpZiAocGljayhheGlzLm9wdGlvbnMuY3Jvc3NoYWlyICYmIGF4aXMub3B0aW9ucy5jcm9zc2hhaXIuc25hcCwgdHJ1ZSkpIHtcblx0XHRcdFx0XHRcdFx0YXhpcy5kcmF3Q3Jvc3NoYWlyKG51bGwsIGFsbG93TW92ZSk7XG5cdFx0XHRcdFx0XHR9ICBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YXhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gRnVsbCByZXNldFxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoaG92ZXJQb2ludCkge1xuXHRcdFx0XHRcdGhvdmVyUG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGhvdmVyU2VyaWVzKSB7XG5cdFx0XHRcdFx0aG92ZXJTZXJpZXMub25Nb3VzZU91dCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdFx0XHR0b29sdGlwLmhpZGUoZGVsYXkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBvaW50ZXIuX29uRG9jdW1lbnRNb3VzZU1vdmUpIHtcblx0XHRcdFx0XHRyZW1vdmVFdmVudChkb2MsICdtb3VzZW1vdmUnLCBwb2ludGVyLl9vbkRvY3VtZW50TW91c2VNb3ZlKTtcblx0XHRcdFx0XHRwb2ludGVyLl9vbkRvY3VtZW50TW91c2VNb3ZlID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlbW92ZSBjcm9zc2hhaXJzXG5cdFx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRheGlzLmhpZGVDcm9zc2hhaXIoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRwb2ludGVyLmhvdmVyWCA9IG51bGw7XG5cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2NhbGUgc2VyaWVzIGdyb3VwcyB0byBhIGNlcnRhaW4gc2NhbGUgYW5kIHRyYW5zbGF0aW9uXG5cdFx0ICovXG5cdFx0c2NhbGVHcm91cHM6IGZ1bmN0aW9uIChhdHRyaWJzLCBjbGlwKSB7XG5cblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHNlcmllc0F0dHJpYnM7XG5cblx0XHRcdC8vIFNjYWxlIGVhY2ggc2VyaWVzXG5cdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRzZXJpZXNBdHRyaWJzID0gYXR0cmlicyB8fCBzZXJpZXMuZ2V0UGxvdEJveCgpOyAvLyAjMTcwMVxuXHRcdFx0XHRpZiAoc2VyaWVzLnhBeGlzICYmIHNlcmllcy54QXhpcy56b29tRW5hYmxlZCkge1xuXHRcdFx0XHRcdHNlcmllcy5ncm91cC5hdHRyKHNlcmllc0F0dHJpYnMpO1xuXHRcdFx0XHRcdGlmIChzZXJpZXMubWFya2VyR3JvdXApIHtcblx0XHRcdFx0XHRcdHNlcmllcy5tYXJrZXJHcm91cC5hdHRyKHNlcmllc0F0dHJpYnMpO1xuXHRcdFx0XHRcdFx0c2VyaWVzLm1hcmtlckdyb3VwLmNsaXAoY2xpcCA/IGNoYXJ0LmNsaXBSZWN0IDogbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZXJpZXMuZGF0YUxhYmVsc0dyb3VwKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMuZGF0YUxhYmVsc0dyb3VwLmF0dHIoc2VyaWVzQXR0cmlicyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gQ2xpcFxuXHRcdFx0Y2hhcnQuY2xpcFJlY3QuYXR0cihjbGlwIHx8IGNoYXJ0LmNsaXBCb3gpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTdGFydCBhIGRyYWcgb3BlcmF0aW9uXG5cdFx0ICovXG5cdFx0ZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdFx0Ly8gUmVjb3JkIHRoZSBzdGFydCBwb3NpdGlvblxuXHRcdFx0Y2hhcnQubW91c2VJc0Rvd24gPSBlLnR5cGU7XG5cdFx0XHRjaGFydC5jYW5jZWxDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2hhcnQubW91c2VEb3duWCA9IHRoaXMubW91c2VEb3duWCA9IGUuY2hhcnRYO1xuXHRcdFx0Y2hhcnQubW91c2VEb3duWSA9IHRoaXMubW91c2VEb3duWSA9IGUuY2hhcnRZO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQZXJmb3JtIGEgZHJhZyBvcGVyYXRpb24gaW4gcmVzcG9uc2UgdG8gYSBtb3VzZW1vdmUgZXZlbnQgd2hpbGUgdGhlIG1vdXNlIGlzIGRvd25cblx0XHQgKi9cblx0XHRkcmFnOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRjaGFydE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmNoYXJ0LFxuXHRcdFx0XHRjaGFydFggPSBlLmNoYXJ0WCxcblx0XHRcdFx0Y2hhcnRZID0gZS5jaGFydFksXG5cdFx0XHRcdHpvb21Ib3IgPSB0aGlzLnpvb21Ib3IsXG5cdFx0XHRcdHpvb21WZXJ0ID0gdGhpcy56b29tVmVydCxcblx0XHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdHBsb3RXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aCxcblx0XHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQsXG5cdFx0XHRcdGNsaWNrZWRJbnNpZGUsXG5cdFx0XHRcdHNpemUsXG5cdFx0XHRcdG1vdXNlRG93blggPSB0aGlzLm1vdXNlRG93blgsXG5cdFx0XHRcdG1vdXNlRG93blkgPSB0aGlzLm1vdXNlRG93blksXG5cdFx0XHRcdHBhbktleSA9IGNoYXJ0T3B0aW9ucy5wYW5LZXkgJiYgZVtjaGFydE9wdGlvbnMucGFuS2V5ICsgJ0tleSddO1xuXG5cdFx0XHQvLyBJZiB0aGUgbW91c2UgaXMgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBhZGp1c3QgdG8gY29vb3JkaW5hdGVzXG5cdFx0XHQvLyBpbnNpZGUgdG8gcHJldmVudCB0aGUgc2VsZWN0aW9uIG1hcmtlciBmcm9tIGdvaW5nIG91dHNpZGVcblx0XHRcdGlmIChjaGFydFggPCBwbG90TGVmdCkge1xuXHRcdFx0XHRjaGFydFggPSBwbG90TGVmdDtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcnRYID4gcGxvdExlZnQgKyBwbG90V2lkdGgpIHtcblx0XHRcdFx0Y2hhcnRYID0gcGxvdExlZnQgKyBwbG90V2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaGFydFkgPCBwbG90VG9wKSB7XG5cdFx0XHRcdGNoYXJ0WSA9IHBsb3RUb3A7XG5cdFx0XHR9IGVsc2UgaWYgKGNoYXJ0WSA+IHBsb3RUb3AgKyBwbG90SGVpZ2h0KSB7XG5cdFx0XHRcdGNoYXJ0WSA9IHBsb3RUb3AgKyBwbG90SGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBkZXRlcm1pbmUgaWYgdGhlIG1vdXNlIGhhcyBtb3ZlZCBtb3JlIHRoYW4gMTBweFxuXHRcdFx0dGhpcy5oYXNEcmFnZ2VkID0gTWF0aC5zcXJ0KFxuXHRcdFx0XHRNYXRoLnBvdyhtb3VzZURvd25YIC0gY2hhcnRYLCAyKSArXG5cdFx0XHRcdE1hdGgucG93KG1vdXNlRG93blkgLSBjaGFydFksIDIpXG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5oYXNEcmFnZ2VkID4gMTApIHtcblx0XHRcdFx0Y2xpY2tlZEluc2lkZSA9IGNoYXJ0LmlzSW5zaWRlUGxvdChtb3VzZURvd25YIC0gcGxvdExlZnQsIG1vdXNlRG93blkgLSBwbG90VG9wKTtcblxuXHRcdFx0XHQvLyBtYWtlIGEgc2VsZWN0aW9uXG5cdFx0XHRcdGlmIChjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMgJiYgKHRoaXMuem9vbVggfHwgdGhpcy56b29tWSkgJiYgY2xpY2tlZEluc2lkZSAmJiAhcGFuS2V5KSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3Rpb25NYXJrZXIgPSBjaGFydC5yZW5kZXJlci5yZWN0KFxuXHRcdFx0XHRcdFx0XHRwbG90TGVmdCxcblx0XHRcdFx0XHRcdFx0cGxvdFRvcCxcblx0XHRcdFx0XHRcdFx0em9vbUhvciA/IDEgOiBwbG90V2lkdGgsXG5cdFx0XHRcdFx0XHRcdHpvb21WZXJ0ID8gMSA6IHBsb3RIZWlnaHQsXG5cdFx0XHRcdFx0XHRcdDBcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0ZmlsbDogY2hhcnRPcHRpb25zLnNlbGVjdGlvbk1hcmtlckZpbGwgfHwgJ3JnYmEoNjksMTE0LDE2NywwLjI1KScsXG5cdFx0XHRcdFx0XHRcdHpJbmRleDogN1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhZGp1c3QgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gbWFya2VyXG5cdFx0XHRcdGlmICh0aGlzLnNlbGVjdGlvbk1hcmtlciAmJiB6b29tSG9yKSB7XG5cdFx0XHRcdFx0c2l6ZSA9IGNoYXJ0WCAtIG1vdXNlRG93blg7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3Rpb25NYXJrZXIuYXR0cih7XG5cdFx0XHRcdFx0XHR3aWR0aDogbWF0aEFicyhzaXplKSxcblx0XHRcdFx0XHRcdHg6IChzaXplID4gMCA/IDAgOiBzaXplKSArIG1vdXNlRG93blhcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhZGp1c3QgdGhlIGhlaWdodCBvZiB0aGUgc2VsZWN0aW9uIG1hcmtlclxuXHRcdFx0XHRpZiAodGhpcy5zZWxlY3Rpb25NYXJrZXIgJiYgem9vbVZlcnQpIHtcblx0XHRcdFx0XHRzaXplID0gY2hhcnRZIC0gbW91c2VEb3duWTtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGlvbk1hcmtlci5hdHRyKHtcblx0XHRcdFx0XHRcdGhlaWdodDogbWF0aEFicyhzaXplKSxcblx0XHRcdFx0XHRcdHk6IChzaXplID4gMCA/IDAgOiBzaXplKSArIG1vdXNlRG93bllcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhbm5pbmdcblx0XHRcdFx0aWYgKGNsaWNrZWRJbnNpZGUgJiYgIXRoaXMuc2VsZWN0aW9uTWFya2VyICYmIGNoYXJ0T3B0aW9ucy5wYW5uaW5nKSB7XG5cdFx0XHRcdFx0Y2hhcnQucGFuKGUsIGNoYXJ0T3B0aW9ucy5wYW5uaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBPbiBtb3VzZSB1cCBvciB0b3VjaCBlbmQgYWNyb3NzIHRoZSBlbnRpcmUgZG9jdW1lbnQsIGRyb3AgdGhlIHNlbGVjdGlvbi5cblx0XHQgKi9cblx0XHRkcm9wOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHBvaW50ZXIgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdGhhc1BpbmNoZWQgPSB0aGlzLmhhc1BpbmNoZWQ7XG5cblx0XHRcdGlmICh0aGlzLnNlbGVjdGlvbk1hcmtlcikge1xuXHRcdFx0XHR2YXIgc2VsZWN0aW9uRGF0YSA9IHtcblx0XHRcdFx0XHRcdHhBeGlzOiBbXSxcblx0XHRcdFx0XHRcdHlBeGlzOiBbXSxcblx0XHRcdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IGUub3JpZ2luYWxFdmVudCB8fCBlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzZWxlY3Rpb25Cb3ggPSB0aGlzLnNlbGVjdGlvbk1hcmtlcixcblx0XHRcdFx0XHRzZWxlY3Rpb25MZWZ0ID0gc2VsZWN0aW9uQm94LmF0dHIgPyBzZWxlY3Rpb25Cb3guYXR0cigneCcpIDogc2VsZWN0aW9uQm94LngsXG5cdFx0XHRcdFx0c2VsZWN0aW9uVG9wID0gc2VsZWN0aW9uQm94LmF0dHIgPyBzZWxlY3Rpb25Cb3guYXR0cigneScpIDogc2VsZWN0aW9uQm94LnksXG5cdFx0XHRcdFx0c2VsZWN0aW9uV2lkdGggPSBzZWxlY3Rpb25Cb3guYXR0ciA/IHNlbGVjdGlvbkJveC5hdHRyKCd3aWR0aCcpIDogc2VsZWN0aW9uQm94LndpZHRoLFxuXHRcdFx0XHRcdHNlbGVjdGlvbkhlaWdodCA9IHNlbGVjdGlvbkJveC5hdHRyID8gc2VsZWN0aW9uQm94LmF0dHIoJ2hlaWdodCcpIDogc2VsZWN0aW9uQm94LmhlaWdodCxcblx0XHRcdFx0XHRydW5ab29tO1xuXG5cdFx0XHRcdC8vIGEgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGVcblx0XHRcdFx0aWYgKHRoaXMuaGFzRHJhZ2dlZCB8fCBoYXNQaW5jaGVkKSB7XG5cblx0XHRcdFx0XHQvLyByZWNvcmQgZWFjaCBheGlzJyBtaW4gYW5kIG1heFxuXHRcdFx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRcdGlmIChheGlzLnpvb21FbmFibGVkICYmIGRlZmluZWQoYXhpcy5taW4pICYmIChoYXNQaW5jaGVkIHx8IHBvaW50ZXJbeyB4QXhpczogJ3pvb21YJywgeUF4aXM6ICd6b29tWScgfVtheGlzLmNvbGxdXSkpIHsgLy8gIzg1OSwgIzM1Njlcblx0XHRcdFx0XHRcdFx0dmFyIGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0XHRcdFx0XHRtaW5QaXhlbFBhZGRpbmcgPSBlLnR5cGUgPT09ICd0b3VjaGVuZCcgPyBheGlzLm1pblBpeGVsUGFkZGluZzogMCwgLy8gIzEyMDcsICMzMDc1XG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uTWluID0gYXhpcy50b1ZhbHVlKChob3JpeiA/IHNlbGVjdGlvbkxlZnQgOiBzZWxlY3Rpb25Ub3ApICsgbWluUGl4ZWxQYWRkaW5nKSxcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25NYXggPSBheGlzLnRvVmFsdWUoKGhvcml6ID8gc2VsZWN0aW9uTGVmdCArIHNlbGVjdGlvbldpZHRoIDogc2VsZWN0aW9uVG9wICsgc2VsZWN0aW9uSGVpZ2h0KSAtIG1pblBpeGVsUGFkZGluZyk7XG5cblx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YVtheGlzLmNvbGxdLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdGF4aXM6IGF4aXMsXG5cdFx0XHRcdFx0XHRcdFx0bWluOiBtYXRoTWluKHNlbGVjdGlvbk1pbiwgc2VsZWN0aW9uTWF4KSwgLy8gZm9yIHJldmVyc2VkIGF4ZXNcblx0XHRcdFx0XHRcdFx0XHRtYXg6IG1hdGhNYXgoc2VsZWN0aW9uTWluLCBzZWxlY3Rpb25NYXgpXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRydW5ab29tID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAocnVuWm9vbSkge1xuXHRcdFx0XHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnc2VsZWN0aW9uJywgc2VsZWN0aW9uRGF0YSwgZnVuY3Rpb24gKGFyZ3MpIHsgXG5cdFx0XHRcdFx0XHRcdGNoYXJ0Lnpvb20oZXh0ZW5kKGFyZ3MsIGhhc1BpbmNoZWQgPyB7IGFuaW1hdGlvbjogZmFsc2UgfSA6IG51bGwpKTsgXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNlbGVjdGlvbk1hcmtlciA9IHRoaXMuc2VsZWN0aW9uTWFya2VyLmRlc3Ryb3koKTtcblxuXHRcdFx0XHQvLyBSZXNldCBzY2FsaW5nIHByZXZpZXdcblx0XHRcdFx0aWYgKGhhc1BpbmNoZWQpIHtcblx0XHRcdFx0XHR0aGlzLnNjYWxlR3JvdXBzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzZXQgYWxsXG5cdFx0XHRpZiAoY2hhcnQpIHsgLy8gaXQgbWF5IGJlIGRlc3Ryb3llZCBvbiBtb3VzZSB1cCAtICM4Nzdcblx0XHRcdFx0Y3NzKGNoYXJ0LmNvbnRhaW5lciwgeyBjdXJzb3I6IGNoYXJ0Ll9jdXJzb3IgfSk7XG5cdFx0XHRcdGNoYXJ0LmNhbmNlbENsaWNrID0gdGhpcy5oYXNEcmFnZ2VkID4gMTA7IC8vICMzNzBcblx0XHRcdFx0Y2hhcnQubW91c2VJc0Rvd24gPSB0aGlzLmhhc0RyYWdnZWQgPSB0aGlzLmhhc1BpbmNoZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5waW5jaERvd24gPSBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25Db250YWluZXJNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cblx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcblxuXHRcdFx0Ly8gaXNzdWUgIzI5NSwgZHJhZ2dpbmcgbm90IGFsd2F5cyB3b3JraW5nIGluIEZpcmVmb3hcblx0XHRcdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5kcmFnU3RhcnQoZSk7XG5cdFx0fSxcblxuXHRcdFxuXG5cdFx0b25Eb2N1bWVudE1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0pIHtcblx0XHRcdFx0Y2hhcnRzW2hvdmVyQ2hhcnRJbmRleF0ucG9pbnRlci5kcm9wKGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWFsIGhhbmRsZXIgZm9yIG1vdXNlIG1vdmUgdGhhdCB3aWxsIGhpZGUgdGhlIHRvb2x0aXAgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBwbG90YXJlYS5cblx0XHQgKiBJc3N1ZSAjMTQ5IHdvcmthcm91bmQuIFRoZSBtb3VzZWxlYXZlIGV2ZW50IGRvZXMgbm90IGFsd2F5cyBmaXJlLiBcblx0XHQgKi9cblx0XHRvbkRvY3VtZW50TW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0Y2hhcnRQb3NpdGlvbiA9IHRoaXMuY2hhcnRQb3NpdGlvbjtcblxuXHRcdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUsIGNoYXJ0UG9zaXRpb24pO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBvdXRzaWRlLCBoaWRlIHRoZSB0b29sdGlwXG5cdFx0XHRpZiAoY2hhcnRQb3NpdGlvbiAmJiAhdGhpcy5pbkNsYXNzKGUudGFyZ2V0LCAnaGlnaGNoYXJ0cy10cmFja2VyJykgJiZcblx0XHRcdFx0XHQhY2hhcnQuaXNJbnNpZGVQbG90KGUuY2hhcnRYIC0gY2hhcnQucGxvdExlZnQsIGUuY2hhcnRZIC0gY2hhcnQucGxvdFRvcCkpIHtcblx0XHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBXaGVuIG1vdXNlIGxlYXZlcyB0aGUgY29udGFpbmVyLCBoaWRlIHRoZSB0b29sdGlwLlxuXHRcdCAqL1xuXHRcdG9uQ29udGFpbmVyTW91c2VMZWF2ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gY2hhcnRzW2hvdmVyQ2hhcnRJbmRleF07XG5cdFx0XHRpZiAoY2hhcnQpIHtcblx0XHRcdFx0Y2hhcnQucG9pbnRlci5yZXNldCgpO1xuXHRcdFx0XHRjaGFydC5wb2ludGVyLmNoYXJ0UG9zaXRpb24gPSBudWxsOyAvLyBhbHNvIHJlc2V0IHRoZSBjaGFydCBwb3NpdGlvbiwgdXNlZCBpbiAjMTQ5IGZpeFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBUaGUgbW91c2Vtb3ZlLCB0b3VjaG1vdmUgYW5kIHRvdWNoc3RhcnQgZXZlbnQgaGFuZGxlclxuXHRcdG9uQ29udGFpbmVyTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXG5cdFx0XHRob3ZlckNoYXJ0SW5kZXggPSBjaGFydC5pbmRleDtcblxuXHRcdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUpO1x0XHRcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTsgLy8gIzIyNTEsICMzMjI0XG5cdFx0XHRcblx0XHRcdGlmIChjaGFydC5tb3VzZUlzRG93biA9PT0gJ21vdXNlZG93bicpIHtcblx0XHRcdFx0dGhpcy5kcmFnKGUpO1xuXHRcdFx0fSBcblx0XHRcdFxuXHRcdFx0Ly8gU2hvdyB0aGUgdG9vbHRpcCBhbmQgcnVuIG1vdXNlIG92ZXIgZXZlbnRzICgjOTc3KVxuXHRcdFx0aWYgKCh0aGlzLmluQ2xhc3MoZS50YXJnZXQsICdoaWdoY2hhcnRzLXRyYWNrZXInKSB8fCBcblx0XHRcdFx0XHRjaGFydC5pc0luc2lkZVBsb3QoZS5jaGFydFggLSBjaGFydC5wbG90TGVmdCwgZS5jaGFydFkgLSBjaGFydC5wbG90VG9wKSkgJiYgIWNoYXJ0Lm9wZW5NZW51KSB7XG5cdFx0XHRcdHRoaXMucnVuUG9pbnRBY3Rpb25zKGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVdGlsaXR5IHRvIGRldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgaGFzLCBvciBoYXMgYSBwYXJlbnQgd2l0aCwgYSBzcGVjaWZpY1xuXHRcdCAqIGNsYXNzIG5hbWUuIFVzZWQgb24gZGV0ZWN0aW9uIG9mIHRyYWNrZXIgb2JqZWN0cyBhbmQgb24gZGVjaWRpbmcgd2hldGhlclxuXHRcdCAqIGhvdmVyaW5nIHRoZSB0b29sdGlwIHNob3VsZCBjYXVzZSB0aGUgYWN0aXZlIHNlcmllcyB0byBtb3VzZSBvdXQuXG5cdFx0ICovXG5cdFx0aW5DbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRcdFx0dmFyIGVsZW1DbGFzc05hbWU7XG5cdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRlbGVtQ2xhc3NOYW1lID0gYXR0cihlbGVtZW50LCAnY2xhc3MnKTtcblx0XHRcdFx0aWYgKGVsZW1DbGFzc05hbWUpIHtcblx0XHRcdFx0XHRpZiAoZWxlbUNsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1DbGFzc05hbWUuaW5kZXhPZihQUkVGSVggKyAnY29udGFpbmVyJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XHRcdFxuXHRcdH0sXG5cblx0XHRvblRyYWNrZXJNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLmNoYXJ0LmhvdmVyU2VyaWVzLFxuXHRcdFx0XHRyZWxhdGVkVGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0IHx8IGUudG9FbGVtZW50LFxuXHRcdFx0XHRyZWxhdGVkU2VyaWVzID0gcmVsYXRlZFRhcmdldCAmJiByZWxhdGVkVGFyZ2V0LnBvaW50ICYmIHJlbGF0ZWRUYXJnZXQucG9pbnQuc2VyaWVzOyAvLyAjMjQ5OVxuXHRcdFx0XG5cdFx0XHRpZiAoc2VyaWVzICYmICFzZXJpZXMub3B0aW9ucy5zdGlja3lUcmFja2luZyAmJiAhdGhpcy5pbkNsYXNzKHJlbGF0ZWRUYXJnZXQsIFBSRUZJWCArICd0b29sdGlwJykgJiZcblx0XHRcdFx0XHRyZWxhdGVkU2VyaWVzICE9PSBzZXJpZXMpIHtcblx0XHRcdFx0c2VyaWVzLm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25Db250YWluZXJDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdGhvdmVyUG9pbnQgPSBjaGFydC5ob3ZlclBvaW50LCBcblx0XHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3A7XG5cdFx0XHRcblx0XHRcdGUgPSB0aGlzLm5vcm1hbGl6ZShlKTtcblx0XHRcdGUub3JpZ2luYWxFdmVudCA9IGU7IC8vICMzOTEzXG5cdFx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7IC8vIElFIHNwZWNpZmljXG5cblx0XHRcdGlmICghY2hhcnQuY2FuY2VsQ2xpY2spIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIE9uIHRyYWNrZXIgY2xpY2ssIGZpcmUgdGhlIHNlcmllcyBhbmQgcG9pbnQgZXZlbnRzLiAjNzgzLCAjMTU4M1xuXHRcdFx0XHRpZiAoaG92ZXJQb2ludCAmJiB0aGlzLmluQ2xhc3MoZS50YXJnZXQsIFBSRUZJWCArICd0cmFja2VyJykpIHtcblxuXHRcdFx0XHRcdC8vIHRoZSBzZXJpZXMgY2xpY2sgZXZlbnRcblx0XHRcdFx0XHRmaXJlRXZlbnQoaG92ZXJQb2ludC5zZXJpZXMsICdjbGljaycsIGV4dGVuZChlLCB7XG5cdFx0XHRcdFx0XHRwb2ludDogaG92ZXJQb2ludFxuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHRcdC8vIHRoZSBwb2ludCBjbGljayBldmVudFxuXHRcdFx0XHRcdGlmIChjaGFydC5ob3ZlclBvaW50KSB7IC8vIGl0IG1heSBiZSBkZXN0cm95ZWQgKCMxODQ0KVxuXHRcdFx0XHRcdFx0aG92ZXJQb2ludC5maXJlUG9pbnRFdmVudCgnY2xpY2snLCBlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2hlbiBjbGlja2luZyBvdXRzaWRlIGEgdHJhY2tlciwgZmlyZSBhIGNoYXJ0IGV2ZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXh0ZW5kKGUsIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoZSkpO1xuXG5cdFx0XHRcdFx0Ly8gZmlyZSBhIGNsaWNrIGV2ZW50IGluIHRoZSBjaGFydFxuXHRcdFx0XHRcdGlmIChjaGFydC5pc0luc2lkZVBsb3QoZS5jaGFydFggLSBwbG90TGVmdCwgZS5jaGFydFkgLSBwbG90VG9wKSkge1xuXHRcdFx0XHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnY2xpY2snLCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgSlMgRE9NIGV2ZW50cyBvbiB0aGUgY29udGFpbmVyIGFuZCBkb2N1bWVudC4gVGhpcyBtZXRob2Qgc2hvdWxkIGNvbnRhaW5cblx0XHQgKiBhIG9uZS10by1vbmUgYXNzaWdubWVudCBiZXR3ZWVuIG1ldGhvZHMgYW5kIHRoZWlyIGhhbmRsZXJzLiBBbnkgYWR2YW5jZWQgbG9naWMgc2hvdWxkXG5cdFx0ICogYmUgbW92ZWQgdG8gdGhlIGhhbmRsZXIgcmVmbGVjdGluZyB0aGUgZXZlbnQncyBuYW1lLlxuXHRcdCAqL1xuXHRcdHNldERPTUV2ZW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcG9pbnRlciA9IHRoaXMsXG5cdFx0XHRcdGNvbnRhaW5lciA9IHBvaW50ZXIuY2hhcnQuY29udGFpbmVyO1xuXG5cdFx0XHRjb250YWluZXIub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyTW91c2VEb3duKGUpO1xuXHRcdFx0fTtcblx0XHRcdGNvbnRhaW5lci5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHBvaW50ZXIub25Db250YWluZXJNb3VzZU1vdmUoZSk7XG5cdFx0XHR9O1xuXHRcdFx0Y29udGFpbmVyLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyQ2xpY2soZSk7XG5cdFx0XHR9O1xuXHRcdFx0YWRkRXZlbnQoY29udGFpbmVyLCAnbW91c2VsZWF2ZScsIHBvaW50ZXIub25Db250YWluZXJNb3VzZUxlYXZlKTtcblx0XHRcdGlmIChjaGFydENvdW50ID09PSAxKSB7XG5cdFx0XHRcdGFkZEV2ZW50KGRvYywgJ21vdXNldXAnLCBwb2ludGVyLm9uRG9jdW1lbnRNb3VzZVVwKTtcblx0XHRcdH1cblx0XHRcdGlmIChoYXNUb3VjaCkge1xuXHRcdFx0XHRjb250YWluZXIub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyVG91Y2hTdGFydChlKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Y29udGFpbmVyLm9udG91Y2htb3ZlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRwb2ludGVyLm9uQ29udGFpbmVyVG91Y2hNb3ZlKGUpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoY2hhcnRDb3VudCA9PT0gMSkge1xuXHRcdFx0XHRcdGFkZEV2ZW50KGRvYywgJ3RvdWNoZW5kJywgcG9pbnRlci5vbkRvY3VtZW50VG91Y2hFbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveXMgdGhlIFBvaW50ZXIgb2JqZWN0IGFuZCBkaXNjb25uZWN0cyBET00gZXZlbnRzLlxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRyZW1vdmVFdmVudCh0aGlzLmNoYXJ0LmNvbnRhaW5lciwgJ21vdXNlbGVhdmUnLCB0aGlzLm9uQ29udGFpbmVyTW91c2VMZWF2ZSk7XG5cdFx0XHRpZiAoIWNoYXJ0Q291bnQpIHtcblx0XHRcdFx0cmVtb3ZlRXZlbnQoZG9jLCAnbW91c2V1cCcsIHRoaXMub25Eb2N1bWVudE1vdXNlVXApO1xuXHRcdFx0XHRyZW1vdmVFdmVudChkb2MsICd0b3VjaGVuZCcsIHRoaXMub25Eb2N1bWVudFRvdWNoRW5kKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbWVtb3J5IGFuZCBDUFUgbGVha1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLnRvb2x0aXBUaW1lb3V0KTtcblxuXHRcdFx0Zm9yIChwcm9wIGluIHRoaXMpIHtcblx0XHRcdFx0dGhpc1twcm9wXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblx0LyogU3VwcG9ydCBmb3IgdG91Y2ggZGV2aWNlcyAqL1xuXHRleHRlbmQoSGlnaGNoYXJ0cy5Qb2ludGVyLnByb3RvdHlwZSwge1xuXG5cdFx0LyoqXG5cdFx0ICogUnVuIHRyYW5zbGF0aW9uIG9wZXJhdGlvbnNcblx0XHQgKi9cblx0XHRwaW5jaFRyYW5zbGF0ZTogZnVuY3Rpb24gKHBpbmNoRG93biwgdG91Y2hlcywgdHJhbnNmb3JtLCBzZWxlY3Rpb25NYXJrZXIsIGNsaXAsIGxhc3RWYWxpZFRvdWNoKSB7XG5cdFx0XHRpZiAodGhpcy56b29tSG9yIHx8IHRoaXMucGluY2hIb3IpIHtcblx0XHRcdFx0dGhpcy5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbih0cnVlLCBwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy56b29tVmVydCB8fCB0aGlzLnBpbmNoVmVydCkge1xuXHRcdFx0XHR0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKGZhbHNlLCBwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJ1biB0cmFuc2xhdGlvbiBvcGVyYXRpb25zIGZvciBlYWNoIGRpcmVjdGlvbiAoaG9yaXpvbnRhbCBhbmQgdmVydGljYWwpIGluZGVwZW5kZW50bHlcblx0XHQgKi9cblx0XHRwaW5jaFRyYW5zbGF0ZURpcmVjdGlvbjogZnVuY3Rpb24gKGhvcml6LCBwaW5jaERvd24sIHRvdWNoZXMsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTWFya2VyLCBjbGlwLCBsYXN0VmFsaWRUb3VjaCwgZm9yY2VkU2NhbGUpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHh5ID0gaG9yaXogPyAneCcgOiAneScsXG5cdFx0XHRcdFhZID0gaG9yaXogPyAnWCcgOiAnWScsXG5cdFx0XHRcdHNDaGFydFhZID0gJ2NoYXJ0JyArIFhZLFxuXHRcdFx0XHR3aCA9IGhvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnLFxuXHRcdFx0XHRwbG90TGVmdFRvcCA9IGNoYXJ0WydwbG90JyArIChob3JpeiA/ICdMZWZ0JyA6ICdUb3AnKV0sXG5cdFx0XHRcdHNlbGVjdGlvbldILFxuXHRcdFx0XHRzZWxlY3Rpb25YWSxcblx0XHRcdFx0Y2xpcFhZLFxuXHRcdFx0XHRzY2FsZSA9IGZvcmNlZFNjYWxlIHx8IDEsXG5cdFx0XHRcdGludmVydGVkID0gY2hhcnQuaW52ZXJ0ZWQsXG5cdFx0XHRcdGJvdW5kcyA9IGNoYXJ0LmJvdW5kc1tob3JpeiA/ICdoJyA6ICd2J10sXG5cdFx0XHRcdHNpbmdsZVRvdWNoID0gcGluY2hEb3duLmxlbmd0aCA9PT0gMSxcblx0XHRcdFx0dG91Y2gwU3RhcnQgPSBwaW5jaERvd25bMF1bc0NoYXJ0WFldLFxuXHRcdFx0XHR0b3VjaDBOb3cgPSB0b3VjaGVzWzBdW3NDaGFydFhZXSxcblx0XHRcdFx0dG91Y2gxU3RhcnQgPSAhc2luZ2xlVG91Y2ggJiYgcGluY2hEb3duWzFdW3NDaGFydFhZXSxcblx0XHRcdFx0dG91Y2gxTm93ID0gIXNpbmdsZVRvdWNoICYmIHRvdWNoZXNbMV1bc0NoYXJ0WFldLFxuXHRcdFx0XHRvdXRPZkJvdW5kcyxcblx0XHRcdFx0dHJhbnNmb3JtU2NhbGUsXG5cdFx0XHRcdHNjYWxlS2V5LFxuXHRcdFx0XHRzZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoIXNpbmdsZVRvdWNoICYmIG1hdGhBYnModG91Y2gwU3RhcnQgLSB0b3VjaDFTdGFydCkgPiAyMCkgeyAvLyBEb24ndCB6b29tIGlmIGZpbmdlcnMgYXJlIHRvbyBjbG9zZSBvbiB0aGlzIGF4aXNcblx0XHRcdFx0XHRcdHNjYWxlID0gZm9yY2VkU2NhbGUgfHwgbWF0aEFicyh0b3VjaDBOb3cgLSB0b3VjaDFOb3cpIC8gbWF0aEFicyh0b3VjaDBTdGFydCAtIHRvdWNoMVN0YXJ0KTsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNsaXBYWSA9ICgocGxvdExlZnRUb3AgLSB0b3VjaDBOb3cpIC8gc2NhbGUpICsgdG91Y2gwU3RhcnQ7XG5cdFx0XHRcdFx0c2VsZWN0aW9uV0ggPSBjaGFydFsncGxvdCcgKyAoaG9yaXogPyAnV2lkdGgnIDogJ0hlaWdodCcpXSAvIHNjYWxlO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBTZXQgdGhlIHNjYWxlLCBmaXJzdCBwYXNzXG5cdFx0XHRzZXRTY2FsZSgpO1xuXG5cdFx0XHRzZWxlY3Rpb25YWSA9IGNsaXBYWTsgLy8gdGhlIGNsaXAgcG9zaXRpb24gKHggb3IgeSkgaXMgYWx0ZXJlZCBpZiBvdXQgb2YgYm91bmRzLCB0aGUgc2VsZWN0aW9uIHBvc2l0aW9uIGlzIG5vdFxuXG5cdFx0XHQvLyBPdXQgb2YgYm91bmRzXG5cdFx0XHRpZiAoc2VsZWN0aW9uWFkgPCBib3VuZHMubWluKSB7XG5cdFx0XHRcdHNlbGVjdGlvblhZID0gYm91bmRzLm1pbjtcblx0XHRcdFx0b3V0T2ZCb3VuZHMgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChzZWxlY3Rpb25YWSArIHNlbGVjdGlvbldIID4gYm91bmRzLm1heCkge1xuXHRcdFx0XHRzZWxlY3Rpb25YWSA9IGJvdW5kcy5tYXggLSBzZWxlY3Rpb25XSDtcblx0XHRcdFx0b3V0T2ZCb3VuZHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBJcyB0aGUgY2hhcnQgZHJhZ2dlZCBvZmYgaXRzIGJvdW5kcywgZGV0ZXJtaW5lZCBieSBkYXRhTWluIGFuZCBkYXRhTWF4P1xuXHRcdFx0aWYgKG91dE9mQm91bmRzKSB7XG5cblx0XHRcdFx0Ly8gTW9kaWZ5IHRoZSB0b3VjaE5vdyBwb3NpdGlvbiBpbiBvcmRlciB0byBjcmVhdGUgYW4gZWxhc3RpYyBkcmFnIG1vdmVtZW50LiBUaGlzIGluZGljYXRlc1xuXHRcdFx0XHQvLyB0byB0aGUgdXNlciB0aGF0IHRoZSBjaGFydCBpcyByZXNwb25zaXZlIGJ1dCBjYW4ndCBiZSBkcmFnZ2VkIGZ1cnRoZXIuXG5cdFx0XHRcdHRvdWNoME5vdyAtPSAwLjggKiAodG91Y2gwTm93IC0gbGFzdFZhbGlkVG91Y2hbeHldWzBdKTtcblx0XHRcdFx0aWYgKCFzaW5nbGVUb3VjaCkge1xuXHRcdFx0XHRcdHRvdWNoMU5vdyAtPSAwLjggKiAodG91Y2gxTm93IC0gbGFzdFZhbGlkVG91Y2hbeHldWzFdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCB0aGUgc2NhbGUsIHNlY29uZCBwYXNzIHRvIGFkYXB0IHRvIHRoZSBtb2RpZmllZCB0b3VjaE5vdyBwb3NpdGlvbnNcblx0XHRcdFx0c2V0U2NhbGUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGFzdFZhbGlkVG91Y2hbeHldID0gW3RvdWNoME5vdywgdG91Y2gxTm93XTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGdlb21ldHJ5IGZvciBjbGlwcGluZywgc2VsZWN0aW9uIGFuZCB0cmFuc2Zvcm1hdGlvblxuXHRcdFx0aWYgKCFpbnZlcnRlZCkgeyAvLyBUT0RPOiBpbXBsZW1lbnQgY2xpcHBpbmcgZm9yIGludmVydGVkIGNoYXJ0c1xuXHRcdFx0XHRjbGlwW3h5XSA9IGNsaXBYWSAtIHBsb3RMZWZ0VG9wO1xuXHRcdFx0XHRjbGlwW3doXSA9IHNlbGVjdGlvbldIO1xuXHRcdFx0fVxuXHRcdFx0c2NhbGVLZXkgPSBpbnZlcnRlZCA/IChob3JpeiA/ICdzY2FsZVknIDogJ3NjYWxlWCcpIDogJ3NjYWxlJyArIFhZO1xuXHRcdFx0dHJhbnNmb3JtU2NhbGUgPSBpbnZlcnRlZCA/IDEgLyBzY2FsZSA6IHNjYWxlO1xuXG5cdFx0XHRzZWxlY3Rpb25NYXJrZXJbd2hdID0gc2VsZWN0aW9uV0g7XG5cdFx0XHRzZWxlY3Rpb25NYXJrZXJbeHldID0gc2VsZWN0aW9uWFk7XG5cdFx0XHR0cmFuc2Zvcm1bc2NhbGVLZXldID0gc2NhbGU7XG5cdFx0XHR0cmFuc2Zvcm1bJ3RyYW5zbGF0ZScgKyBYWV0gPSAodHJhbnNmb3JtU2NhbGUgKiBwbG90TGVmdFRvcCkgKyAodG91Y2gwTm93IC0gKHRyYW5zZm9ybVNjYWxlICogdG91Y2gwU3RhcnQpKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZSB0b3VjaCBldmVudHMgd2l0aCB0d28gdG91Y2hlc1xuXHRcdCAqL1xuXHRcdHBpbmNoOiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VsZi5jaGFydCxcblx0XHRcdFx0cGluY2hEb3duID0gc2VsZi5waW5jaERvd24sXG5cdFx0XHRcdHRvdWNoZXMgPSBlLnRvdWNoZXMsXG5cdFx0XHRcdHRvdWNoZXNMZW5ndGggPSB0b3VjaGVzLmxlbmd0aCxcblx0XHRcdFx0bGFzdFZhbGlkVG91Y2ggPSBzZWxmLmxhc3RWYWxpZFRvdWNoLFxuXHRcdFx0XHRoYXNab29tID0gc2VsZi5oYXNab29tLFxuXHRcdFx0XHRzZWxlY3Rpb25NYXJrZXIgPSBzZWxmLnNlbGVjdGlvbk1hcmtlcixcblx0XHRcdFx0dHJhbnNmb3JtID0ge30sXG5cdFx0XHRcdGZpcmVDbGlja0V2ZW50ID0gdG91Y2hlc0xlbmd0aCA9PT0gMSAmJiAoKHNlbGYuaW5DbGFzcyhlLnRhcmdldCwgUFJFRklYICsgJ3RyYWNrZXInKSAmJiBcblx0XHRcdFx0XHRjaGFydC5ydW5UcmFja2VyQ2xpY2spIHx8IHNlbGYucnVuQ2hhcnRDbGljayksXG5cdFx0XHRcdGNsaXAgPSB7fTtcblxuXHRcdFx0Ly8gT24gdG91Y2ggZGV2aWNlcywgb25seSBwcm9jZWVkIHRvIHRyaWdnZXIgY2xpY2sgaWYgYSBoYW5kbGVyIGlzIGRlZmluZWRcblx0XHRcdGlmIChoYXNab29tICYmICFmaXJlQ2xpY2tFdmVudCkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIE5vcm1hbGl6ZSBlYWNoIHRvdWNoXG5cdFx0XHRtYXAodG91Y2hlcywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYubm9ybWFsaXplKGUpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIFJlZ2lzdGVyIHRoZSB0b3VjaCBzdGFydCBwb3NpdGlvblxuXHRcdFx0aWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0XHRcdGVhY2godG91Y2hlcywgZnVuY3Rpb24gKGUsIGkpIHtcblx0XHRcdFx0XHRwaW5jaERvd25baV0gPSB7IGNoYXJ0WDogZS5jaGFydFgsIGNoYXJ0WTogZS5jaGFydFkgfTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGxhc3RWYWxpZFRvdWNoLnggPSBbcGluY2hEb3duWzBdLmNoYXJ0WCwgcGluY2hEb3duWzFdICYmIHBpbmNoRG93blsxXS5jaGFydFhdO1xuXHRcdFx0XHRsYXN0VmFsaWRUb3VjaC55ID0gW3BpbmNoRG93blswXS5jaGFydFksIHBpbmNoRG93blsxXSAmJiBwaW5jaERvd25bMV0uY2hhcnRZXTtcblxuXHRcdFx0XHQvLyBJZGVudGlmeSB0aGUgZGF0YSBib3VuZHMgaW4gcGl4ZWxzXG5cdFx0XHRcdGVhY2goY2hhcnQuYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRpZiAoYXhpcy56b29tRW5hYmxlZCkge1xuXHRcdFx0XHRcdFx0dmFyIGJvdW5kcyA9IGNoYXJ0LmJvdW5kc1theGlzLmhvcml6ID8gJ2gnIDogJ3YnXSxcblx0XHRcdFx0XHRcdFx0bWluUGl4ZWxQYWRkaW5nID0gYXhpcy5taW5QaXhlbFBhZGRpbmcsXG5cdFx0XHRcdFx0XHRcdG1pbiA9IGF4aXMudG9QaXhlbHMocGljayhheGlzLm9wdGlvbnMubWluLCBheGlzLmRhdGFNaW4pKSxcblx0XHRcdFx0XHRcdFx0bWF4ID0gYXhpcy50b1BpeGVscyhwaWNrKGF4aXMub3B0aW9ucy5tYXgsIGF4aXMuZGF0YU1heCkpLFxuXHRcdFx0XHRcdFx0XHRhYnNNaW4gPSBtYXRoTWluKG1pbiwgbWF4KSxcblx0XHRcdFx0XHRcdFx0YWJzTWF4ID0gbWF0aE1heChtaW4sIG1heCk7XG5cblx0XHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBib3VuZHMgZm9yIHVzZSBpbiB0aGUgdG91Y2htb3ZlIGhhbmRsZXJcblx0XHRcdFx0XHRcdGJvdW5kcy5taW4gPSBtYXRoTWluKGF4aXMucG9zLCBhYnNNaW4gLSBtaW5QaXhlbFBhZGRpbmcpO1xuXHRcdFx0XHRcdFx0Ym91bmRzLm1heCA9IG1hdGhNYXgoYXhpcy5wb3MgKyBheGlzLmxlbiwgYWJzTWF4ICsgbWluUGl4ZWxQYWRkaW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzZWxmLnJlcyA9IHRydWU7IC8vIHJlc2V0IG9uIG5leHQgbW92ZVxuXHRcdFx0XG5cdFx0XHQvLyBFdmVudCB0eXBlIGlzIHRvdWNobW92ZSwgaGFuZGxlIHBhbm5pbmcgYW5kIHBpbmNoaW5nXG5cdFx0XHR9IGVsc2UgaWYgKHBpbmNoRG93bi5sZW5ndGgpIHsgLy8gY2FuIGJlIDAgd2hlbiByZWxlYXNpbmcsIGlmIHRvdWNoZW5kIGZpcmVzIGZpcnN0XG5cdFx0XHRcdFxuXG5cdFx0XHRcdC8vIFNldCB0aGUgbWFya2VyXG5cdFx0XHRcdGlmICghc2VsZWN0aW9uTWFya2VyKSB7XG5cdFx0XHRcdFx0c2VsZi5zZWxlY3Rpb25NYXJrZXIgPSBzZWxlY3Rpb25NYXJrZXIgPSBleHRlbmQoe1xuXHRcdFx0XHRcdFx0ZGVzdHJveTogbm9vcFxuXHRcdFx0XHRcdH0sIGNoYXJ0LnBsb3RCb3gpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRzZWxmLnBpbmNoVHJhbnNsYXRlKHBpbmNoRG93biwgdG91Y2hlcywgdHJhbnNmb3JtLCBzZWxlY3Rpb25NYXJrZXIsIGNsaXAsIGxhc3RWYWxpZFRvdWNoKTtcblxuXHRcdFx0XHRzZWxmLmhhc1BpbmNoZWQgPSBoYXNab29tO1xuXG5cdFx0XHRcdC8vIFNjYWxlIGFuZCB0cmFuc2xhdGUgdGhlIGdyb3VwcyB0byBwcm92aWRlIHZpc3VhbCBmZWVkYmFjayBkdXJpbmcgcGluY2hpbmdcblx0XHRcdFx0c2VsZi5zY2FsZUdyb3Vwcyh0cmFuc2Zvcm0sIGNsaXApO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gT3B0aW9uYWxseSBtb3ZlIHRoZSB0b29sdGlwIG9uIHRvdWNobW92ZVxuXHRcdFx0XHRpZiAoIWhhc1pvb20gJiYgc2VsZi5mb2xsb3dUb3VjaE1vdmUgJiYgdG91Y2hlc0xlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdHRoaXMucnVuUG9pbnRBY3Rpb25zKHNlbGYubm9ybWFsaXplKGUpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLnJlcykge1xuXHRcdFx0XHRcdHNlbGYucmVzID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5yZXNldChmYWxzZSwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25Db250YWluZXJUb3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblxuXHRcdFx0aG92ZXJDaGFydEluZGV4ID0gY2hhcnQuaW5kZXg7XG5cblx0XHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG5cblx0XHRcdFx0ZSA9IHRoaXMubm9ybWFsaXplKGUpO1xuXG5cdFx0XHRcdGlmIChjaGFydC5pc0luc2lkZVBsb3QoZS5jaGFydFggLSBjaGFydC5wbG90TGVmdCwgZS5jaGFydFkgLSBjaGFydC5wbG90VG9wKSAmJiAhY2hhcnQub3Blbk1lbnUpIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBtb3VzZSBldmVudHMgYW5kIGRpc3BsYXkgdG9vbHRpcCBldGNcblx0XHRcdFx0XHR0aGlzLnJ1blBvaW50QWN0aW9ucyhlKTtcblxuXHRcdFx0XHRcdHRoaXMucGluY2goZSk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBIaWRlIHRoZSB0b29sdGlwIG9uIHRvdWNoaW5nIG91dHNpZGUgdGhlIHBsb3QgYXJlYSAoIzEyMDMpXG5cdFx0XHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0XHR0aGlzLnBpbmNoKGUpO1xuXHRcdFx0fSAgIFxuXHRcdH0sXG5cblx0XHRvbkNvbnRhaW5lclRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxIHx8IGUudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0dGhpcy5waW5jaChlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25Eb2N1bWVudFRvdWNoRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdKSB7XG5cdFx0XHRcdGNoYXJ0c1tob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXIuZHJvcChlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fSk7XG5cdGlmICh3aW4uUG9pbnRlckV2ZW50IHx8IHdpbi5NU1BvaW50ZXJFdmVudCkge1xuXHRcdFxuXHRcdC8vIFRoZSB0b3VjaGVzIG9iamVjdCBrZWVwcyB0cmFjayBvZiB0aGUgcG9pbnRzIGJlaW5nIHRvdWNoZWQgYXQgYWxsIHRpbWVzXG5cdFx0dmFyIHRvdWNoZXMgPSB7fSxcblx0XHRcdGhhc1BvaW50ZXJFdmVudCA9ICEhd2luLlBvaW50ZXJFdmVudCxcblx0XHRcdGdldFdlYmtpdFRvdWNoZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBrZXksIGZha2UgPSBbXTtcblx0XHRcdFx0ZmFrZS5pdGVtID0gZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXNbaV07IH07XG5cdFx0XHRcdGZvciAoa2V5IGluIHRvdWNoZXMpIHtcblx0XHRcdFx0XHRpZiAodG91Y2hlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRmYWtlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRwYWdlWDogdG91Y2hlc1trZXldLnBhZ2VYLFxuXHRcdFx0XHRcdFx0XHRwYWdlWTogdG91Y2hlc1trZXldLnBhZ2VZLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQ6IHRvdWNoZXNba2V5XS50YXJnZXRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFrZTtcblx0XHRcdH0sXG5cdFx0XHR0cmFuc2xhdGVNU1BvaW50ZXIgPSBmdW5jdGlvbiAoZSwgbWV0aG9kLCB3a3R5cGUsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBwO1xuXHRcdFx0XHRlID0gZS5vcmlnaW5hbEV2ZW50IHx8IGU7XG5cdFx0XHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyB8fCBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSAmJiBjaGFydHNbaG92ZXJDaGFydEluZGV4XSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGUpO1xuXHRcdFx0XHRcdHAgPSBjaGFydHNbaG92ZXJDaGFydEluZGV4XS5wb2ludGVyO1xuXHRcdFx0XHRcdHBbbWV0aG9kXSh7XG5cdFx0XHRcdFx0XHR0eXBlOiB3a3R5cGUsXG5cdFx0XHRcdFx0XHR0YXJnZXQ6IGUuY3VycmVudFRhcmdldCxcblx0XHRcdFx0XHRcdHByZXZlbnREZWZhdWx0OiBub29wLFxuXHRcdFx0XHRcdFx0dG91Y2hlczogZ2V0V2Via2l0VG91Y2hlcygpXG5cdFx0XHRcdFx0fSk7XHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZCB0aGUgUG9pbnRlciBwcm90b3R5cGUgd2l0aCBtZXRob2RzIGZvciBlYWNoIGV2ZW50IGhhbmRsZXIgYW5kIG1vcmVcblx0XHQgKi9cblx0XHRleHRlbmQoUG9pbnRlci5wcm90b3R5cGUsIHtcblx0XHRcdG9uQ29udGFpbmVyUG9pbnRlckRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHRyYW5zbGF0ZU1TUG9pbnRlcihlLCAnb25Db250YWluZXJUb3VjaFN0YXJ0JywgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdHRvdWNoZXNbZS5wb2ludGVySWRdID0geyBwYWdlWDogZS5wYWdlWCwgcGFnZVk6IGUucGFnZVksIHRhcmdldDogZS5jdXJyZW50VGFyZ2V0IH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdG9uQ29udGFpbmVyUG9pbnRlck1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHRyYW5zbGF0ZU1TUG9pbnRlcihlLCAnb25Db250YWluZXJUb3VjaE1vdmUnLCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHR0b3VjaGVzW2UucG9pbnRlcklkXSA9IHsgcGFnZVg6IGUucGFnZVgsIHBhZ2VZOiBlLnBhZ2VZIH07XG5cdFx0XHRcdFx0aWYgKCF0b3VjaGVzW2UucG9pbnRlcklkXS50YXJnZXQpIHtcblx0XHRcdFx0XHRcdHRvdWNoZXNbZS5wb2ludGVySWRdLnRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdG9uRG9jdW1lbnRQb2ludGVyVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHRyYW5zbGF0ZU1TUG9pbnRlcihlLCAnb25Db250YWluZXJUb3VjaEVuZCcsICd0b3VjaGVuZCcsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRvdWNoZXNbZS5wb2ludGVySWRdO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkIG9yIHJlbW92ZSB0aGUgTVMgUG9pbnRlciBzcGVjaWZpYyBldmVudHNcblx0XHRcdCAqL1xuXHRcdFx0YmF0Y2hNU0V2ZW50czogZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHRcdGZuKHRoaXMuY2hhcnQuY29udGFpbmVyLCBoYXNQb2ludGVyRXZlbnQgPyAncG9pbnRlcmRvd24nIDogJ01TUG9pbnRlckRvd24nLCB0aGlzLm9uQ29udGFpbmVyUG9pbnRlckRvd24pO1xuXHRcdFx0XHRmbih0aGlzLmNoYXJ0LmNvbnRhaW5lciwgaGFzUG9pbnRlckV2ZW50ID8gJ3BvaW50ZXJtb3ZlJyA6ICdNU1BvaW50ZXJNb3ZlJywgdGhpcy5vbkNvbnRhaW5lclBvaW50ZXJNb3ZlKTtcblx0XHRcdFx0Zm4oZG9jLCBoYXNQb2ludGVyRXZlbnQgPyAncG9pbnRlcnVwJyA6ICdNU1BvaW50ZXJVcCcsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBEaXNhYmxlIGRlZmF1bHQgSUUgYWN0aW9ucyBmb3IgcGluY2ggYW5kIHN1Y2ggb24gY2hhcnQgZWxlbWVudFxuXHRcdHdyYXAoUG9pbnRlci5wcm90b3R5cGUsICdpbml0JywgZnVuY3Rpb24gKHByb2NlZWQsIGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0XHRwcm9jZWVkLmNhbGwodGhpcywgY2hhcnQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHRoaXMuaGFzWm9vbSB8fCB0aGlzLmZvbGxvd1RvdWNoTW92ZSkge1xuXHRcdFx0XHRjc3MoY2hhcnQuY29udGFpbmVyLCB7XG5cdFx0XHRcdFx0Jy1tcy10b3VjaC1hY3Rpb24nOiBOT05FLFxuXHRcdFx0XHRcdCd0b3VjaC1hY3Rpb24nOiBOT05FXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQWRkIElFIHNwZWNpZmljIHRvdWNoIGV2ZW50cyB0byBjaGFydFxuXHRcdHdyYXAoUG9pbnRlci5wcm90b3R5cGUsICdzZXRET01FdmVudHMnLCBmdW5jdGlvbiAocHJvY2VlZCkge1xuXHRcdFx0cHJvY2VlZC5hcHBseSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLmhhc1pvb20gfHwgdGhpcy5mb2xsb3dUb3VjaE1vdmUpIHtcblx0XHRcdFx0dGhpcy5iYXRjaE1TRXZlbnRzKGFkZEV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQvLyBEZXN0cm95IE1TIGV2ZW50cyBhbHNvXG5cdFx0d3JhcChQb2ludGVyLnByb3RvdHlwZSwgJ2Rlc3Ryb3knLCBmdW5jdGlvbiAocHJvY2VlZCkge1xuXHRcdFx0dGhpcy5iYXRjaE1TRXZlbnRzKHJlbW92ZUV2ZW50KTtcblx0XHRcdHByb2NlZWQuY2FsbCh0aGlzKTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0ICogVGhlIG92ZXJ2aWV3IG9mIHRoZSBjaGFydCdzIHNlcmllc1xuXHQgKi9cblx0dmFyIExlZ2VuZCA9IEhpZ2hjaGFydHMuTGVnZW5kID0gZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0dGhpcy5pbml0KGNoYXJ0LCBvcHRpb25zKTtcblx0fTtcblxuXHRMZWdlbmQucHJvdG90eXBlID0ge1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIGxlZ2VuZFxuXHRcdCAqL1xuXHRcdGluaXQ6IGZ1bmN0aW9uIChjaGFydCwgb3B0aW9ucykge1xuXHRcdFx0XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0aXRlbVN0eWxlID0gb3B0aW9ucy5pdGVtU3R5bGUsXG5cdFx0XHRcdHBhZGRpbmcsXG5cdFx0XHRcdGl0ZW1NYXJnaW5Ub3AgPSBvcHRpb25zLml0ZW1NYXJnaW5Ub3AgfHwgMDtcblx0XHRcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHRcdGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcblx0XHRcdGxlZ2VuZC5pdGVtU3R5bGUgPSBpdGVtU3R5bGU7XG5cdFx0XHRsZWdlbmQuaXRlbUhpZGRlblN0eWxlID0gbWVyZ2UoaXRlbVN0eWxlLCBvcHRpb25zLml0ZW1IaWRkZW5TdHlsZSk7XG5cdFx0XHRsZWdlbmQuaXRlbU1hcmdpblRvcCA9IGl0ZW1NYXJnaW5Ub3A7XG5cdFx0XHRsZWdlbmQucGFkZGluZyA9IHBhZGRpbmcgPSBwaWNrKG9wdGlvbnMucGFkZGluZywgOCk7XG5cdFx0XHRsZWdlbmQuaW5pdGlhbEl0ZW1YID0gcGFkZGluZztcblx0XHRcdGxlZ2VuZC5pbml0aWFsSXRlbVkgPSBwYWRkaW5nIC0gNTsgLy8gNSBpcyB0aGUgbnVtYmVyIG9mIHBpeGVscyBhYm92ZSB0aGUgdGV4dFxuXHRcdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IDA7XG5cdFx0XHRsZWdlbmQuY2hhcnQgPSBjaGFydDtcblx0XHRcdGxlZ2VuZC5pdGVtSGVpZ2h0ID0gMDtcblx0XHRcdGxlZ2VuZC5zeW1ib2xXaWR0aCA9IHBpY2sob3B0aW9ucy5zeW1ib2xXaWR0aCwgMTYpO1xuXHRcdFx0bGVnZW5kLnBhZ2VzID0gW107XG5cblxuXHRcdFx0Ly8gUmVuZGVyIGl0XG5cdFx0XHRsZWdlbmQucmVuZGVyKCk7XG5cblx0XHRcdC8vIG1vdmUgY2hlY2tib3hlc1xuXHRcdFx0YWRkRXZlbnQobGVnZW5kLmNoYXJ0LCAnZW5kUmVzaXplJywgZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0bGVnZW5kLnBvc2l0aW9uQ2hlY2tib3hlcygpO1xuXHRcdFx0fSk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBjb2xvcnMgZm9yIHRoZSBsZWdlbmQgaXRlbVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgU2VyaWVzIG9yIFBvaW50IGluc3RhbmNlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHZpc2libGUgRGltbWVkIG9yIGNvbG9yZWRcblx0XHQgKi9cblx0XHRjb2xvcml6ZUl0ZW06IGZ1bmN0aW9uIChpdGVtLCB2aXNpYmxlKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGxlZ2VuZC5vcHRpb25zLFxuXHRcdFx0XHRsZWdlbmRJdGVtID0gaXRlbS5sZWdlbmRJdGVtLFxuXHRcdFx0XHRsZWdlbmRMaW5lID0gaXRlbS5sZWdlbmRMaW5lLFxuXHRcdFx0XHRsZWdlbmRTeW1ib2wgPSBpdGVtLmxlZ2VuZFN5bWJvbCxcblx0XHRcdFx0aGlkZGVuQ29sb3IgPSBsZWdlbmQuaXRlbUhpZGRlblN0eWxlLmNvbG9yLFxuXHRcdFx0XHR0ZXh0Q29sb3IgPSB2aXNpYmxlID8gb3B0aW9ucy5pdGVtU3R5bGUuY29sb3IgOiBoaWRkZW5Db2xvcixcblx0XHRcdFx0c3ltYm9sQ29sb3IgPSB2aXNpYmxlID8gKGl0ZW0ubGVnZW5kQ29sb3IgfHwgaXRlbS5jb2xvciB8fCAnI0NDQycpIDogaGlkZGVuQ29sb3IsXG5cdFx0XHRcdG1hcmtlck9wdGlvbnMgPSBpdGVtLm9wdGlvbnMgJiYgaXRlbS5vcHRpb25zLm1hcmtlcixcblx0XHRcdFx0c3ltYm9sQXR0ciA9IHsgZmlsbDogc3ltYm9sQ29sb3IgfSxcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHR2YWw7XG5cdFx0XHRcblx0XHRcdGlmIChsZWdlbmRJdGVtKSB7XG5cdFx0XHRcdGxlZ2VuZEl0ZW0uY3NzKHsgZmlsbDogdGV4dENvbG9yLCBjb2xvcjogdGV4dENvbG9yIH0pOyAvLyBjb2xvciBmb3IgIzE1NTMsIG9sZElFXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVnZW5kTGluZSkge1xuXHRcdFx0XHRsZWdlbmRMaW5lLmF0dHIoeyBzdHJva2U6IHN5bWJvbENvbG9yIH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAobGVnZW5kU3ltYm9sKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBcHBseSBtYXJrZXIgb3B0aW9uc1xuXHRcdFx0XHRpZiAobWFya2VyT3B0aW9ucyAmJiBsZWdlbmRTeW1ib2wuaXNNYXJrZXIpIHsgLy8gIzU4NVxuXHRcdFx0XHRcdHN5bWJvbEF0dHIuc3Ryb2tlID0gc3ltYm9sQ29sb3I7XG5cdFx0XHRcdFx0bWFya2VyT3B0aW9ucyA9IGl0ZW0uY29udmVydEF0dHJpYnMobWFya2VyT3B0aW9ucyk7XG5cdFx0XHRcdFx0Zm9yIChrZXkgaW4gbWFya2VyT3B0aW9ucykge1xuXHRcdFx0XHRcdFx0dmFsID0gbWFya2VyT3B0aW9uc1trZXldO1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gVU5ERUZJTkVEKSB7XG5cdFx0XHRcdFx0XHRcdHN5bWJvbEF0dHJba2V5XSA9IHZhbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZWdlbmRTeW1ib2wuYXR0cihzeW1ib2xBdHRyKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gdGhlIGxlZ2VuZCBpdGVtXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gQSBTZXJpZXMgb3IgUG9pbnQgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRwb3NpdGlvbkl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGxlZ2VuZC5vcHRpb25zLFxuXHRcdFx0XHRzeW1ib2xQYWRkaW5nID0gb3B0aW9ucy5zeW1ib2xQYWRkaW5nLFxuXHRcdFx0XHRsdHIgPSAhb3B0aW9ucy5ydGwsXG5cdFx0XHRcdGxlZ2VuZEl0ZW1Qb3MgPSBpdGVtLl9sZWdlbmRJdGVtUG9zLFxuXHRcdFx0XHRpdGVtWCA9IGxlZ2VuZEl0ZW1Qb3NbMF0sXG5cdFx0XHRcdGl0ZW1ZID0gbGVnZW5kSXRlbVBvc1sxXSxcblx0XHRcdFx0Y2hlY2tib3ggPSBpdGVtLmNoZWNrYm94O1xuXG5cdFx0XHRpZiAoaXRlbS5sZWdlbmRHcm91cCkge1xuXHRcdFx0XHRpdGVtLmxlZ2VuZEdyb3VwLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRsdHIgPyBpdGVtWCA6IGxlZ2VuZC5sZWdlbmRXaWR0aCAtIGl0ZW1YIC0gMiAqIHN5bWJvbFBhZGRpbmcgLSA0LFxuXHRcdFx0XHRcdGl0ZW1ZXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaGVja2JveCkge1xuXHRcdFx0XHRjaGVja2JveC54ID0gaXRlbVg7XG5cdFx0XHRcdGNoZWNrYm94LnkgPSBpdGVtWTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBhIHNpbmdsZSBsZWdlbmQgaXRlbVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBzZXJpZXMgb3IgcG9pbnRcblx0XHQgKi9cblx0XHRkZXN0cm95SXRlbTogZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjaGVja2JveCA9IGl0ZW0uY2hlY2tib3g7XG5cblx0XHRcdC8vIGRlc3Ryb3kgU1ZHIGVsZW1lbnRzXG5cdFx0XHRlYWNoKFsnbGVnZW5kSXRlbScsICdsZWdlbmRMaW5lJywgJ2xlZ2VuZFN5bWJvbCcsICdsZWdlbmRHcm91cCddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmIChpdGVtW2tleV0pIHtcblx0XHRcdFx0XHRpdGVtW2tleV0gPSBpdGVtW2tleV0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGNoZWNrYm94KSB7XG5cdFx0XHRcdGRpc2NhcmRFbGVtZW50KGl0ZW0uY2hlY2tib3gpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95IGFsbCBpdGVtcy5cblx0XHQgKi9cblx0XHRjbGVhckl0ZW1zOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcztcblx0XHRcdGVhY2gobGVnZW5kLmdldEFsbEl0ZW1zKCksIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRcdGxlZ2VuZC5kZXN0cm95SXRlbShpdGVtKTsgXG5cdFx0XHR9KTtcdFx0XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3lzIHRoZSBsZWdlbmQuXG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXMsXG5cdFx0XHRcdGxlZ2VuZEdyb3VwID0gbGVnZW5kLmdyb3VwLFxuXHRcdFx0XHRib3ggPSBsZWdlbmQuYm94O1xuXG5cdFx0XHRpZiAoYm94KSB7XG5cdFx0XHRcdGxlZ2VuZC5ib3ggPSBib3guZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGVnZW5kR3JvdXApIHtcblx0XHRcdFx0bGVnZW5kLmdyb3VwID0gbGVnZW5kR3JvdXAuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiB0aGUgY2hlY2tib3hlcyBhZnRlciB0aGUgd2lkdGggaXMgZGV0ZXJtaW5lZFxuXHRcdCAqL1xuXHRcdHBvc2l0aW9uQ2hlY2tib3hlczogZnVuY3Rpb24gKHNjcm9sbE9mZnNldCkge1xuXHRcdFx0dmFyIGFsaWduQXR0ciA9IHRoaXMuZ3JvdXAuYWxpZ25BdHRyLFxuXHRcdFx0XHR0cmFuc2xhdGVZLFxuXHRcdFx0XHRjbGlwSGVpZ2h0ID0gdGhpcy5jbGlwSGVpZ2h0IHx8IHRoaXMubGVnZW5kSGVpZ2h0O1xuXG5cdFx0XHRpZiAoYWxpZ25BdHRyKSB7XG5cdFx0XHRcdHRyYW5zbGF0ZVkgPSBhbGlnbkF0dHIudHJhbnNsYXRlWTtcblx0XHRcdFx0ZWFjaCh0aGlzLmFsbEl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0XHRcdHZhciBjaGVja2JveCA9IGl0ZW0uY2hlY2tib3gsXG5cdFx0XHRcdFx0XHR0b3A7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGNoZWNrYm94KSB7XG5cdFx0XHRcdFx0XHR0b3AgPSAodHJhbnNsYXRlWSArIGNoZWNrYm94LnkgKyAoc2Nyb2xsT2Zmc2V0IHx8IDApICsgMyk7XG5cdFx0XHRcdFx0XHRjc3MoY2hlY2tib3gsIHtcblx0XHRcdFx0XHRcdFx0bGVmdDogKGFsaWduQXR0ci50cmFuc2xhdGVYICsgaXRlbS5jaGVja2JveE9mZnNldCArIGNoZWNrYm94LnggLSAyMCkgKyBQWCxcblx0XHRcdFx0XHRcdFx0dG9wOiB0b3AgKyBQWCxcblx0XHRcdFx0XHRcdFx0ZGlzcGxheTogdG9wID4gdHJhbnNsYXRlWSAtIDYgJiYgdG9wIDwgdHJhbnNsYXRlWSArIGNsaXBIZWlnaHQgLSA2ID8gJycgOiBOT05FXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIHRoZSBsZWdlbmQgdGl0bGUgb24gdG9wIG9mIHRoZSBsZWdlbmRcblx0XHQgKi9cblx0XHRyZW5kZXJUaXRsZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcsXG5cdFx0XHRcdHRpdGxlT3B0aW9ucyA9IG9wdGlvbnMudGl0bGUsXG5cdFx0XHRcdHRpdGxlSGVpZ2h0ID0gMCxcblx0XHRcdFx0YkJveDtcblx0XHRcdFxuXHRcdFx0aWYgKHRpdGxlT3B0aW9ucy50ZXh0KSB7XG5cdFx0XHRcdGlmICghdGhpcy50aXRsZSkge1xuXHRcdFx0XHRcdHRoaXMudGl0bGUgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLmxhYmVsKHRpdGxlT3B0aW9ucy50ZXh0LCBwYWRkaW5nIC0gMywgcGFkZGluZyAtIDQsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICdsZWdlbmQtdGl0bGUnKVxuXHRcdFx0XHRcdFx0LmF0dHIoeyB6SW5kZXg6IDEgfSlcblx0XHRcdFx0XHRcdC5jc3ModGl0bGVPcHRpb25zLnN0eWxlKVxuXHRcdFx0XHRcdFx0LmFkZCh0aGlzLmdyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRiQm94ID0gdGhpcy50aXRsZS5nZXRCQm94KCk7XG5cdFx0XHRcdHRpdGxlSGVpZ2h0ID0gYkJveC5oZWlnaHQ7XG5cdFx0XHRcdHRoaXMub2Zmc2V0V2lkdGggPSBiQm94LndpZHRoOyAvLyAjMTcxN1xuXHRcdFx0XHR0aGlzLmNvbnRlbnRHcm91cC5hdHRyKHsgdHJhbnNsYXRlWTogdGl0bGVIZWlnaHQgfSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRpdGxlSGVpZ2h0ID0gdGl0bGVIZWlnaHQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciBhIHNpbmdsZSBzcGVjaWZpYyBsZWdlbmQgaXRlbVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgc2VyaWVzIG9yIHBvaW50XG5cdFx0ICovXG5cdFx0cmVuZGVySXRlbTogZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IGxlZ2VuZC5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0b3B0aW9ucyA9IGxlZ2VuZC5vcHRpb25zLFxuXHRcdFx0XHRob3Jpem9udGFsID0gb3B0aW9ucy5sYXlvdXQgPT09ICdob3Jpem9udGFsJyxcblx0XHRcdFx0c3ltYm9sV2lkdGggPSBsZWdlbmQuc3ltYm9sV2lkdGgsXG5cdFx0XHRcdHN5bWJvbFBhZGRpbmcgPSBvcHRpb25zLnN5bWJvbFBhZGRpbmcsXG5cdFx0XHRcdGl0ZW1TdHlsZSA9IGxlZ2VuZC5pdGVtU3R5bGUsXG5cdFx0XHRcdGl0ZW1IaWRkZW5TdHlsZSA9IGxlZ2VuZC5pdGVtSGlkZGVuU3R5bGUsXG5cdFx0XHRcdHBhZGRpbmcgPSBsZWdlbmQucGFkZGluZyxcblx0XHRcdFx0aXRlbURpc3RhbmNlID0gaG9yaXpvbnRhbCA/IHBpY2sob3B0aW9ucy5pdGVtRGlzdGFuY2UsIDIwKSA6IDAsXG5cdFx0XHRcdGx0ciA9ICFvcHRpb25zLnJ0bCxcblx0XHRcdFx0aXRlbUhlaWdodCxcblx0XHRcdFx0d2lkdGhPcHRpb24gPSBvcHRpb25zLndpZHRoLFxuXHRcdFx0XHRpdGVtTWFyZ2luQm90dG9tID0gb3B0aW9ucy5pdGVtTWFyZ2luQm90dG9tIHx8IDAsXG5cdFx0XHRcdGl0ZW1NYXJnaW5Ub3AgPSBsZWdlbmQuaXRlbU1hcmdpblRvcCxcblx0XHRcdFx0aW5pdGlhbEl0ZW1YID0gbGVnZW5kLmluaXRpYWxJdGVtWCxcblx0XHRcdFx0YkJveCxcblx0XHRcdFx0aXRlbVdpZHRoLFxuXHRcdFx0XHRsaSA9IGl0ZW0ubGVnZW5kSXRlbSxcblx0XHRcdFx0c2VyaWVzID0gaXRlbS5zZXJpZXMgJiYgaXRlbS5zZXJpZXMuZHJhd0xlZ2VuZFN5bWJvbCA/IGl0ZW0uc2VyaWVzIDogaXRlbSxcblx0XHRcdFx0c2VyaWVzT3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRzaG93Q2hlY2tib3ggPSBsZWdlbmQuY3JlYXRlQ2hlY2tib3hGb3JJdGVtICYmIHNlcmllc09wdGlvbnMgJiYgc2VyaWVzT3B0aW9ucy5zaG93Q2hlY2tib3gsXG5cdFx0XHRcdHVzZUhUTUwgPSBvcHRpb25zLnVzZUhUTUw7XG5cblx0XHRcdGlmICghbGkpIHsgLy8gZ2VuZXJhdGUgaXQgb25jZSwgbGF0ZXIgbW92ZSBpdFxuXG5cdFx0XHRcdC8vIEdlbmVyYXRlIHRoZSBncm91cCBib3hcblx0XHRcdFx0Ly8gQSBncm91cCB0byBob2xkIHRoZSBzeW1ib2wgYW5kIHRleHQuIFRleHQgaXMgdG8gYmUgYXBwZW5kZWQgaW4gTGVnZW5kIGNsYXNzLlxuXHRcdFx0XHRpdGVtLmxlZ2VuZEdyb3VwID0gcmVuZGVyZXIuZygnbGVnZW5kLWl0ZW0nKVxuXHRcdFx0XHRcdC5hdHRyKHsgekluZGV4OiAxIH0pXG5cdFx0XHRcdFx0LmFkZChsZWdlbmQuc2Nyb2xsR3JvdXApO1xuXG5cdFx0XHRcdC8vIEdlbmVyYXRlIHRoZSBsaXN0IGl0ZW0gdGV4dCBhbmQgYWRkIGl0IHRvIHRoZSBncm91cFxuXHRcdFx0XHRpdGVtLmxlZ2VuZEl0ZW0gPSBsaSA9IHJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0XHRvcHRpb25zLmxhYmVsRm9ybWF0ID8gZm9ybWF0KG9wdGlvbnMubGFiZWxGb3JtYXQsIGl0ZW0pIDogb3B0aW9ucy5sYWJlbEZvcm1hdHRlci5jYWxsKGl0ZW0pLFxuXHRcdFx0XHRcdFx0bHRyID8gc3ltYm9sV2lkdGggKyBzeW1ib2xQYWRkaW5nIDogLXN5bWJvbFBhZGRpbmcsXG5cdFx0XHRcdFx0XHRsZWdlbmQuYmFzZWxpbmUgfHwgMCxcblx0XHRcdFx0XHRcdHVzZUhUTUxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmNzcyhtZXJnZShpdGVtLnZpc2libGUgPyBpdGVtU3R5bGUgOiBpdGVtSGlkZGVuU3R5bGUpKSAvLyBtZXJnZSB0byBwcmV2ZW50IG1vZGlmeWluZyBvcmlnaW5hbCAoIzEwMjEpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0YWxpZ246IGx0ciA/ICdsZWZ0JyA6ICdyaWdodCcsXG5cdFx0XHRcdFx0XHR6SW5kZXg6IDJcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoaXRlbS5sZWdlbmRHcm91cCk7XG5cblx0XHRcdFx0Ly8gR2V0IHRoZSBiYXNlbGluZSBmb3IgdGhlIGZpcnN0IGl0ZW0gLSB0aGUgZm9udCBzaXplIGlzIGVxdWFsIGZvciBhbGxcblx0XHRcdFx0aWYgKCFsZWdlbmQuYmFzZWxpbmUpIHtcblx0XHRcdFx0XHRsZWdlbmQuYmFzZWxpbmUgPSByZW5kZXJlci5mb250TWV0cmljcyhpdGVtU3R5bGUuZm9udFNpemUsIGxpKS5mICsgMyArIGl0ZW1NYXJnaW5Ub3A7XG5cdFx0XHRcdFx0bGkuYXR0cigneScsIGxlZ2VuZC5iYXNlbGluZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEcmF3IHRoZSBsZWdlbmQgc3ltYm9sIGluc2lkZSB0aGUgZ3JvdXAgYm94XG5cdFx0XHRcdHNlcmllcy5kcmF3TGVnZW5kU3ltYm9sKGxlZ2VuZCwgaXRlbSk7XG5cblx0XHRcdFx0aWYgKGxlZ2VuZC5zZXRJdGVtRXZlbnRzKSB7XG5cdFx0XHRcdFx0bGVnZW5kLnNldEl0ZW1FdmVudHMoaXRlbSwgbGksIHVzZUhUTUwsIGl0ZW1TdHlsZSwgaXRlbUhpZGRlblN0eWxlKTtcblx0XHRcdFx0fVx0XHRcdFxuXG5cdFx0XHRcdC8vIENvbG9yaXplIHRoZSBpdGVtc1xuXHRcdFx0XHRsZWdlbmQuY29sb3JpemVJdGVtKGl0ZW0sIGl0ZW0udmlzaWJsZSk7XG5cblx0XHRcdFx0Ly8gYWRkIHRoZSBIVE1MIGNoZWNrYm94IG9uIHRvcFxuXHRcdFx0XHRpZiAoc2hvd0NoZWNrYm94KSB7XG5cdFx0XHRcdFx0bGVnZW5kLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbShpdGVtKTtcdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIGZvciB0aGUgbmV4dCBsaW5lXG5cdFx0XHRiQm94ID0gbGkuZ2V0QkJveCgpO1xuXG5cdFx0XHRpdGVtV2lkdGggPSBpdGVtLmNoZWNrYm94T2Zmc2V0ID0gXG5cdFx0XHRcdG9wdGlvbnMuaXRlbVdpZHRoIHx8IFxuXHRcdFx0XHRpdGVtLmxlZ2VuZEl0ZW1XaWR0aCB8fCBcblx0XHRcdFx0c3ltYm9sV2lkdGggKyBzeW1ib2xQYWRkaW5nICsgYkJveC53aWR0aCArIGl0ZW1EaXN0YW5jZSArIChzaG93Q2hlY2tib3ggPyAyMCA6IDApO1xuXHRcdFx0bGVnZW5kLml0ZW1IZWlnaHQgPSBpdGVtSGVpZ2h0ID0gbWF0aFJvdW5kKGl0ZW0ubGVnZW5kSXRlbUhlaWdodCB8fCBiQm94LmhlaWdodCk7XG5cblx0XHRcdC8vIGlmIHRoZSBpdGVtIGV4Y2VlZHMgdGhlIHdpZHRoLCBzdGFydCBhIG5ldyBsaW5lXG5cdFx0XHRpZiAoaG9yaXpvbnRhbCAmJiBsZWdlbmQuaXRlbVggLSBpbml0aWFsSXRlbVggKyBpdGVtV2lkdGggPlxuXHRcdFx0XHRcdCh3aWR0aE9wdGlvbiB8fCAoY2hhcnQuY2hhcnRXaWR0aCAtIDIgKiBwYWRkaW5nIC0gaW5pdGlhbEl0ZW1YIC0gb3B0aW9ucy54KSkpIHtcblx0XHRcdFx0bGVnZW5kLml0ZW1YID0gaW5pdGlhbEl0ZW1YO1xuXHRcdFx0XHRsZWdlbmQuaXRlbVkgKz0gaXRlbU1hcmdpblRvcCArIGxlZ2VuZC5sYXN0TGluZUhlaWdodCArIGl0ZW1NYXJnaW5Cb3R0b207XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBpdGVtIGV4Y2VlZHMgdGhlIGhlaWdodCwgc3RhcnQgYSBuZXcgY29sdW1uXG5cdFx0XHQvKmlmICghaG9yaXpvbnRhbCAmJiBsZWdlbmQuaXRlbVkgKyBvcHRpb25zLnkgKyBpdGVtSGVpZ2h0ID4gY2hhcnQuY2hhcnRIZWlnaHQgLSBzcGFjaW5nVG9wIC0gc3BhY2luZ0JvdHRvbSkge1xuXHRcdFx0XHRsZWdlbmQuaXRlbVkgPSBsZWdlbmQuaW5pdGlhbEl0ZW1ZO1xuXHRcdFx0XHRsZWdlbmQuaXRlbVggKz0gbGVnZW5kLm1heEl0ZW1XaWR0aDtcblx0XHRcdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IDA7XG5cdFx0XHR9Ki9cblxuXHRcdFx0Ly8gU2V0IHRoZSBlZGdlIHBvc2l0aW9uc1xuXHRcdFx0bGVnZW5kLm1heEl0ZW1XaWR0aCA9IG1hdGhNYXgobGVnZW5kLm1heEl0ZW1XaWR0aCwgaXRlbVdpZHRoKTtcblx0XHRcdGxlZ2VuZC5sYXN0SXRlbVkgPSBpdGVtTWFyZ2luVG9wICsgbGVnZW5kLml0ZW1ZICsgaXRlbU1hcmdpbkJvdHRvbTtcblx0XHRcdGxlZ2VuZC5sYXN0TGluZUhlaWdodCA9IG1hdGhNYXgoaXRlbUhlaWdodCwgbGVnZW5kLmxhc3RMaW5lSGVpZ2h0KTsgLy8gIzkxNVxuXG5cdFx0XHQvLyBjYWNoZSB0aGUgcG9zaXRpb24gb2YgdGhlIG5ld2x5IGdlbmVyYXRlZCBvciByZW9yZGVyZWQgaXRlbXNcblx0XHRcdGl0ZW0uX2xlZ2VuZEl0ZW1Qb3MgPSBbbGVnZW5kLml0ZW1YLCBsZWdlbmQuaXRlbVldO1xuXG5cdFx0XHQvLyBhZHZhbmNlXG5cdFx0XHRpZiAoaG9yaXpvbnRhbCkge1xuXHRcdFx0XHRsZWdlbmQuaXRlbVggKz0gaXRlbVdpZHRoO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZWdlbmQuaXRlbVkgKz0gaXRlbU1hcmdpblRvcCArIGl0ZW1IZWlnaHQgKyBpdGVtTWFyZ2luQm90dG9tO1xuXHRcdFx0XHRsZWdlbmQubGFzdExpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0aGUgd2lkdGggb2YgdGhlIHdpZGVzdCBpdGVtXG5cdFx0XHRsZWdlbmQub2Zmc2V0V2lkdGggPSB3aWR0aE9wdGlvbiB8fCBtYXRoTWF4KFxuXHRcdFx0XHQoaG9yaXpvbnRhbCA/IGxlZ2VuZC5pdGVtWCAtIGluaXRpYWxJdGVtWCAtIGl0ZW1EaXN0YW5jZSA6IGl0ZW1XaWR0aCkgKyBwYWRkaW5nLFxuXHRcdFx0XHRsZWdlbmQub2Zmc2V0V2lkdGhcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhbGwgaXRlbXMsIHdoaWNoIGlzIG9uZSBpdGVtIHBlciBzZXJpZXMgZm9yIG5vcm1hbCBzZXJpZXMgYW5kIG9uZSBpdGVtIHBlciBwb2ludFxuXHRcdCAqIGZvciBwaWUgc2VyaWVzLlxuXHRcdCAqL1xuXHRcdGdldEFsbEl0ZW1zOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYWxsSXRlbXMgPSBbXTtcblx0XHRcdGVhY2godGhpcy5jaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXMpIHtcblx0XHRcdFx0dmFyIHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucztcblxuXHRcdFx0XHQvLyBIYW5kbGUgc2hvd0luTGVnZW5kLiBJZiB0aGUgc2VyaWVzIGlzIGxpbmtlZCB0byBhbm90aGVyIHNlcmllcywgZGVmYXVsdHMgdG8gZmFsc2UuXG5cdFx0XHRcdGlmICghcGljayhzZXJpZXNPcHRpb25zLnNob3dJbkxlZ2VuZCwgIWRlZmluZWQoc2VyaWVzT3B0aW9ucy5saW5rZWRUbykgPyBVTkRFRklORUQgOiBmYWxzZSwgdHJ1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1c2UgcG9pbnRzIG9yIHNlcmllcyBmb3IgdGhlIGxlZ2VuZCBpdGVtIGRlcGVuZGluZyBvbiBsZWdlbmRUeXBlXG5cdFx0XHRcdGFsbEl0ZW1zID0gYWxsSXRlbXMuY29uY2F0KFxuXHRcdFx0XHRcdFx0c2VyaWVzLmxlZ2VuZEl0ZW1zIHx8XG5cdFx0XHRcdFx0XHQoc2VyaWVzT3B0aW9ucy5sZWdlbmRUeXBlID09PSAncG9pbnQnID9cblx0XHRcdFx0XHRcdFx0XHRzZXJpZXMuZGF0YSA6XG5cdFx0XHRcdFx0XHRcdFx0c2VyaWVzKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gYWxsSXRlbXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkanVzdCB0aGUgY2hhcnQgbWFyZ2lucyBieSByZXNlcnZpbmcgc3BhY2UgZm9yIHRoZSBsZWdlbmQgb24gb25seSBvbmUgc2lkZVxuXHRcdCAqIG9mIHRoZSBjaGFydC4gSWYgdGhlIHBvc2l0aW9uIGlzIHNldCB0byBhIGNvcm5lciwgdG9wIG9yIGJvdHRvbSBpcyByZXNlcnZlZFxuXHRcdCAqIGZvciBob3Jpem9udGFsIGxlZ2VuZHMgYW5kIGxlZnQgb3IgcmlnaHQgZm9yIHZlcnRpY2FsIG9uZXMuXG5cdFx0ICovXG5cdFx0YWRqdXN0TWFyZ2luczogZnVuY3Rpb24gKG1hcmdpbiwgc3BhY2luZykge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCwgXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdC8vIFVzZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGVhY2ggYWxpZ25tZW50IG9wdGlvbiBpbiBvcmRlciB0byBkZXRlY3QgdGhlIHNpZGUgXG5cdFx0XHRcdGFsaWdubWVudCA9IG9wdGlvbnMuYWxpZ25bMF0gKyBvcHRpb25zLnZlcnRpY2FsQWxpZ25bMF0gKyBvcHRpb25zLmxheW91dFswXTtcblx0XHRcdFx0XG5cdFx0XHRpZiAodGhpcy5kaXNwbGF5ICYmICFvcHRpb25zLmZsb2F0aW5nKSB7XG5cblx0XHRcdFx0ZWFjaChbXG5cdFx0XHRcdFx0LyhsdGh8Y3R8cnRoKS8sXG5cdFx0XHRcdFx0LyhydHZ8cm18cmJ2KS8sXG5cdFx0XHRcdFx0LyhyYmh8Y2J8bGJoKS8sXG5cdFx0XHRcdFx0LyhsYnZ8bG18bHR2KS9cblx0XHRcdFx0XSwgZnVuY3Rpb24gKGFsaWdubWVudHMsIHNpZGUpIHtcblx0XHRcdFx0XHRpZiAoYWxpZ25tZW50cy50ZXN0KGFsaWdubWVudCkgJiYgIWRlZmluZWQobWFyZ2luW3NpZGVdKSkge1xuXHRcdFx0XHRcdFx0Ly8gTm93IHdlIGhhdmUgZGV0ZWN0ZWQgb24gd2hpY2ggc2lkZSBvZiB0aGUgY2hhcnQgd2Ugc2hvdWxkIHJlc2VydmUgc3BhY2UgZm9yIHRoZSBsZWdlbmRcblx0XHRcdFx0XHRcdGNoYXJ0W21hcmdpbk5hbWVzW3NpZGVdXSA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0XHRcdGNoYXJ0W21hcmdpbk5hbWVzW3NpZGVdXSxcblx0XHRcdFx0XHRcdFx0Y2hhcnQubGVnZW5kWyhzaWRlICsgMSkgJSAyID8gJ2xlZ2VuZEhlaWdodCcgOiAnbGVnZW5kV2lkdGgnXSArIFxuXHRcdFx0XHRcdFx0XHRcdFsxLCAtMSwgLTEsIDFdW3NpZGVdICogb3B0aW9uc1soc2lkZSAlIDIpID8gJ3gnIDogJ3knXSArIFxuXHRcdFx0XHRcdFx0XHRcdHBpY2sob3B0aW9ucy5tYXJnaW4sIDEyKSArXG5cdFx0XHRcdFx0XHRcdFx0c3BhY2luZ1tzaWRlXVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgdGhlIGxlZ2VuZC4gVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBib3RoIGJlZm9yZSBhbmQgYWZ0ZXJcblx0XHQgKiBjaGFydC5yZW5kZXIuIElmIGNhbGxlZCBhZnRlciwgaXQgd2lsbCBvbmx5IHJlYXJyYW5nZSBpdGVtcyBpbnN0ZWFkXG5cdFx0ICogb2YgY3JlYXRpbmcgbmV3IG9uZXMuXG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBsZWdlbmQuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdGxlZ2VuZEdyb3VwID0gbGVnZW5kLmdyb3VwLFxuXHRcdFx0XHRhbGxJdGVtcyxcblx0XHRcdFx0ZGlzcGxheSxcblx0XHRcdFx0bGVnZW5kV2lkdGgsXG5cdFx0XHRcdGxlZ2VuZEhlaWdodCxcblx0XHRcdFx0Ym94ID0gbGVnZW5kLmJveCxcblx0XHRcdFx0b3B0aW9ucyA9IGxlZ2VuZC5vcHRpb25zLFxuXHRcdFx0XHRwYWRkaW5nID0gbGVnZW5kLnBhZGRpbmcsXG5cdFx0XHRcdGxlZ2VuZEJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdFx0bGVnZW5kQmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG5cblx0XHRcdGxlZ2VuZC5pdGVtWCA9IGxlZ2VuZC5pbml0aWFsSXRlbVg7XG5cdFx0XHRsZWdlbmQuaXRlbVkgPSBsZWdlbmQuaW5pdGlhbEl0ZW1ZO1xuXHRcdFx0bGVnZW5kLm9mZnNldFdpZHRoID0gMDtcblx0XHRcdGxlZ2VuZC5sYXN0SXRlbVkgPSAwO1xuXG5cdFx0XHRpZiAoIWxlZ2VuZEdyb3VwKSB7XG5cdFx0XHRcdGxlZ2VuZC5ncm91cCA9IGxlZ2VuZEdyb3VwID0gcmVuZGVyZXIuZygnbGVnZW5kJylcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogNyB9KSBcblx0XHRcdFx0XHQuYWRkKCk7XG5cdFx0XHRcdGxlZ2VuZC5jb250ZW50R3JvdXAgPSByZW5kZXJlci5nKClcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogMSB9KSAvLyBhYm92ZSBiYWNrZ3JvdW5kXG5cdFx0XHRcdFx0LmFkZChsZWdlbmRHcm91cCk7XG5cdFx0XHRcdGxlZ2VuZC5zY3JvbGxHcm91cCA9IHJlbmRlcmVyLmcoKVxuXHRcdFx0XHRcdC5hZGQobGVnZW5kLmNvbnRlbnRHcm91cCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGxlZ2VuZC5yZW5kZXJUaXRsZSgpO1xuXG5cdFx0XHQvLyBhZGQgZWFjaCBzZXJpZXMgb3IgcG9pbnRcblx0XHRcdGFsbEl0ZW1zID0gbGVnZW5kLmdldEFsbEl0ZW1zKCk7XG5cblx0XHRcdC8vIHNvcnQgYnkgbGVnZW5kSW5kZXhcblx0XHRcdHN0YWJsZVNvcnQoYWxsSXRlbXMsIGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdHJldHVybiAoKGEub3B0aW9ucyAmJiBhLm9wdGlvbnMubGVnZW5kSW5kZXgpIHx8IDApIC0gKChiLm9wdGlvbnMgJiYgYi5vcHRpb25zLmxlZ2VuZEluZGV4KSB8fCAwKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyByZXZlcnNlZCBsZWdlbmRcblx0XHRcdGlmIChvcHRpb25zLnJldmVyc2VkKSB7XG5cdFx0XHRcdGFsbEl0ZW1zLnJldmVyc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0bGVnZW5kLmFsbEl0ZW1zID0gYWxsSXRlbXM7XG5cdFx0XHRsZWdlbmQuZGlzcGxheSA9IGRpc3BsYXkgPSAhIWFsbEl0ZW1zLmxlbmd0aDtcblxuXHRcdFx0Ly8gcmVuZGVyIHRoZSBpdGVtc1xuXHRcdFx0bGVnZW5kLmxhc3RMaW5lSGVpZ2h0ID0gMDtcblx0XHRcdGVhY2goYWxsSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRcdGxlZ2VuZC5yZW5kZXJJdGVtKGl0ZW0pOyBcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBHZXQgdGhlIGJveFxuXHRcdFx0bGVnZW5kV2lkdGggPSAob3B0aW9ucy53aWR0aCB8fCBsZWdlbmQub2Zmc2V0V2lkdGgpICsgcGFkZGluZztcblx0XHRcdGxlZ2VuZEhlaWdodCA9IGxlZ2VuZC5sYXN0SXRlbVkgKyBsZWdlbmQubGFzdExpbmVIZWlnaHQgKyBsZWdlbmQudGl0bGVIZWlnaHQ7XG5cdFx0XHRsZWdlbmRIZWlnaHQgPSBsZWdlbmQuaGFuZGxlT3ZlcmZsb3cobGVnZW5kSGVpZ2h0KTtcblx0XHRcdGxlZ2VuZEhlaWdodCArPSBwYWRkaW5nO1xuXG5cdFx0XHQvLyBEcmF3IHRoZSBib3JkZXIgYW5kL29yIGJhY2tncm91bmRcblx0XHRcdGlmIChsZWdlbmRCb3JkZXJXaWR0aCB8fCBsZWdlbmRCYWNrZ3JvdW5kQ29sb3IpIHtcblxuXHRcdFx0XHRpZiAoIWJveCkge1xuXHRcdFx0XHRcdGxlZ2VuZC5ib3ggPSBib3ggPSByZW5kZXJlci5yZWN0KFxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRsZWdlbmRXaWR0aCxcblx0XHRcdFx0XHRcdGxlZ2VuZEhlaWdodCxcblx0XHRcdFx0XHRcdG9wdGlvbnMuYm9yZGVyUmFkaXVzLFxuXHRcdFx0XHRcdFx0bGVnZW5kQm9yZGVyV2lkdGggfHwgMFxuXHRcdFx0XHRcdCkuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogbGVnZW5kQm9yZGVyV2lkdGggfHwgMCxcblx0XHRcdFx0XHRcdGZpbGw6IGxlZ2VuZEJhY2tncm91bmRDb2xvciB8fCBOT05FXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuYWRkKGxlZ2VuZEdyb3VwKVxuXHRcdFx0XHRcdC5zaGFkb3cob3B0aW9ucy5zaGFkb3cpO1xuXHRcdFx0XHRcdGJveC5pc05ldyA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmIChsZWdlbmRXaWR0aCA+IDAgJiYgbGVnZW5kSGVpZ2h0ID4gMCkge1xuXHRcdFx0XHRcdGJveFtib3guaXNOZXcgPyAnYXR0cicgOiAnYW5pbWF0ZSddKFxuXHRcdFx0XHRcdFx0Ym94LmNyaXNwKHsgd2lkdGg6IGxlZ2VuZFdpZHRoLCBoZWlnaHQ6IGxlZ2VuZEhlaWdodCB9KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0Ym94LmlzTmV3ID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBoaWRlIHRoZSBib3JkZXIgaWYgbm8gaXRlbXNcblx0XHRcdFx0Ym94W2Rpc3BsYXkgPyAnc2hvdycgOiAnaGlkZSddKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGxlZ2VuZC5sZWdlbmRXaWR0aCA9IGxlZ2VuZFdpZHRoO1xuXHRcdFx0bGVnZW5kLmxlZ2VuZEhlaWdodCA9IGxlZ2VuZEhlaWdodDtcblxuXHRcdFx0Ly8gTm93IHRoYXQgdGhlIGxlZ2VuZCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlc3RhYmxpc2hlZCwgcHV0IHRoZSBpdGVtcyBpbiB0aGUgXG5cdFx0XHQvLyBmaW5hbCBwb3NpdGlvblxuXHRcdFx0ZWFjaChhbGxJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0bGVnZW5kLnBvc2l0aW9uSXRlbShpdGVtKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyAxLnggY29tcGF0aWJpbGl0eTogcG9zaXRpb25pbmcgYmFzZWQgb24gc3R5bGVcblx0XHRcdC8qdmFyIHByb3BzID0gWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcblx0XHRcdFx0cHJvcCxcblx0XHRcdFx0aSA9IDQ7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHByb3AgPSBwcm9wc1tpXTtcblx0XHRcdFx0aWYgKG9wdGlvbnMuc3R5bGVbcHJvcF0gJiYgb3B0aW9ucy5zdHlsZVtwcm9wXSAhPT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0b3B0aW9uc1tpIDwgMiA/ICdhbGlnbicgOiAndmVydGljYWxBbGlnbiddID0gcHJvcDtcblx0XHRcdFx0XHRvcHRpb25zW2kgPCAyID8gJ3gnIDogJ3knXSA9IHBJbnQob3B0aW9ucy5zdHlsZVtwcm9wXSkgKiAoaSAlIDIgPyAtMSA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9Ki9cblxuXHRcdFx0aWYgKGRpc3BsYXkpIHtcblx0XHRcdFx0bGVnZW5kR3JvdXAuYWxpZ24oZXh0ZW5kKHtcblx0XHRcdFx0XHR3aWR0aDogbGVnZW5kV2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBsZWdlbmRIZWlnaHRcblx0XHRcdFx0fSwgb3B0aW9ucyksIHRydWUsICdzcGFjaW5nQm94Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghY2hhcnQuaXNSZXNpemluZykge1xuXHRcdFx0XHR0aGlzLnBvc2l0aW9uQ2hlY2tib3hlcygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2V0IHVwIHRoZSBvdmVyZmxvdyBoYW5kbGluZyBieSBhZGRpbmcgbmF2aWdhdGlvbiB3aXRoIHVwIGFuZCBkb3duIGFycm93cyBiZWxvdyB0aGVcblx0XHQgKiBsZWdlbmQuXG5cdFx0ICovXG5cdFx0aGFuZGxlT3ZlcmZsb3c6IGZ1bmN0aW9uIChsZWdlbmRIZWlnaHQpIHtcblx0XHRcdHZhciBsZWdlbmQgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdG9wdGlvbnNZID0gb3B0aW9ucy55LFxuXHRcdFx0XHRhbGlnblRvcCA9IG9wdGlvbnMudmVydGljYWxBbGlnbiA9PT0gJ3RvcCcsXG5cdFx0XHRcdHNwYWNlSGVpZ2h0ID0gY2hhcnQuc3BhY2luZ0JveC5oZWlnaHQgKyAoYWxpZ25Ub3AgPyAtb3B0aW9uc1kgOiBvcHRpb25zWSkgLSB0aGlzLnBhZGRpbmcsXG5cdFx0XHRcdG1heEhlaWdodCA9IG9wdGlvbnMubWF4SGVpZ2h0LFxuXHRcdFx0XHRjbGlwSGVpZ2h0LFxuXHRcdFx0XHRjbGlwUmVjdCA9IHRoaXMuY2xpcFJlY3QsXG5cdFx0XHRcdG5hdk9wdGlvbnMgPSBvcHRpb25zLm5hdmlnYXRpb24sXG5cdFx0XHRcdGFuaW1hdGlvbiA9IHBpY2sobmF2T3B0aW9ucy5hbmltYXRpb24sIHRydWUpLFxuXHRcdFx0XHRhcnJvd1NpemUgPSBuYXZPcHRpb25zLmFycm93U2l6ZSB8fCAxMixcblx0XHRcdFx0bmF2ID0gdGhpcy5uYXYsXG5cdFx0XHRcdHBhZ2VzID0gdGhpcy5wYWdlcyxcblx0XHRcdFx0bGFzdFksXG5cdFx0XHRcdGFsbEl0ZW1zID0gdGhpcy5hbGxJdGVtcztcblx0XHRcdFx0XG5cdFx0XHQvLyBBZGp1c3QgdGhlIGhlaWdodFxuXHRcdFx0aWYgKG9wdGlvbnMubGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcblx0XHRcdFx0c3BhY2VIZWlnaHQgLz0gMjtcblx0XHRcdH1cblx0XHRcdGlmIChtYXhIZWlnaHQpIHtcblx0XHRcdFx0c3BhY2VIZWlnaHQgPSBtYXRoTWluKHNwYWNlSGVpZ2h0LCBtYXhIZWlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBSZXNldCB0aGUgbGVnZW5kIGhlaWdodCBhbmQgYWRqdXN0IHRoZSBjbGlwcGluZyByZWN0YW5nbGVcblx0XHRcdHBhZ2VzLmxlbmd0aCA9IDA7XG5cdFx0XHRpZiAobGVnZW5kSGVpZ2h0ID4gc3BhY2VIZWlnaHQgJiYgIW9wdGlvbnMudXNlSFRNTCkge1xuXG5cdFx0XHRcdHRoaXMuY2xpcEhlaWdodCA9IGNsaXBIZWlnaHQgPSBtYXRoTWF4KHNwYWNlSGVpZ2h0IC0gMjAgLSB0aGlzLnRpdGxlSGVpZ2h0IC0gdGhpcy5wYWRkaW5nLCAwKTtcblx0XHRcdFx0dGhpcy5jdXJyZW50UGFnZSA9IHBpY2sodGhpcy5jdXJyZW50UGFnZSwgMSk7XG5cdFx0XHRcdHRoaXMuZnVsbEhlaWdodCA9IGxlZ2VuZEhlaWdodDtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEZpbGwgcGFnZXMgd2l0aCBZIHBvc2l0aW9ucyBzbyB0aGF0IHRoZSB0b3Agb2YgZWFjaCBhIGxlZ2VuZCBpdGVtIGRlZmluZXNcblx0XHRcdFx0Ly8gdGhlIHNjcm9sbCB0b3AgZm9yIGVhY2ggcGFnZSAoIzIwOTgpXG5cdFx0XHRcdGVhY2goYWxsSXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG5cdFx0XHRcdFx0dmFyIHkgPSBpdGVtLl9sZWdlbmRJdGVtUG9zWzFdLFxuXHRcdFx0XHRcdFx0aCA9IG1hdGhSb3VuZChpdGVtLmxlZ2VuZEl0ZW0uZ2V0QkJveCgpLmhlaWdodCksXG5cdFx0XHRcdFx0XHRsZW4gPSBwYWdlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCFsZW4gfHwgKHkgLSBwYWdlc1tsZW4gLSAxXSA+IGNsaXBIZWlnaHQgJiYgKGxhc3RZIHx8IHkpICE9PSBwYWdlc1tsZW4gLSAxXSkpIHtcblx0XHRcdFx0XHRcdHBhZ2VzLnB1c2gobGFzdFkgfHwgeSk7XG5cdFx0XHRcdFx0XHRsZW4rKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGkgPT09IGFsbEl0ZW1zLmxlbmd0aCAtIDEgJiYgeSArIGggLSBwYWdlc1tsZW4gLSAxXSA+IGNsaXBIZWlnaHQpIHtcblx0XHRcdFx0XHRcdHBhZ2VzLnB1c2goeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh5ICE9PSBsYXN0WSkge1xuXHRcdFx0XHRcdFx0bGFzdFkgPSB5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gT25seSBhcHBseSBjbGlwcGluZyBpZiBuZWVkZWQuIENsaXBwaW5nIGNhdXNlcyBibHVycmVkIGxlZ2VuZCBpbiBQREYgZXhwb3J0ICgjMTc4Nylcblx0XHRcdFx0aWYgKCFjbGlwUmVjdCkge1xuXHRcdFx0XHRcdGNsaXBSZWN0ID0gbGVnZW5kLmNsaXBSZWN0ID0gcmVuZGVyZXIuY2xpcFJlY3QoMCwgdGhpcy5wYWRkaW5nLCA5OTk5LCAwKTtcblx0XHRcdFx0XHRsZWdlbmQuY29udGVudEdyb3VwLmNsaXAoY2xpcFJlY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNsaXBSZWN0LmF0dHIoe1xuXHRcdFx0XHRcdGhlaWdodDogY2xpcEhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFkZCBuYXZpZ2F0aW9uIGVsZW1lbnRzXG5cdFx0XHRcdGlmICghbmF2KSB7XG5cdFx0XHRcdFx0dGhpcy5uYXYgPSBuYXYgPSByZW5kZXJlci5nKCkuYXR0cih7IHpJbmRleDogMSB9KS5hZGQodGhpcy5ncm91cCk7XG5cdFx0XHRcdFx0dGhpcy51cCA9IHJlbmRlcmVyLnN5bWJvbCgndHJpYW5nbGUnLCAwLCAwLCBhcnJvd1NpemUsIGFycm93U2l6ZSlcblx0XHRcdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdGxlZ2VuZC5zY3JvbGwoLTEsIGFuaW1hdGlvbik7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmFkZChuYXYpO1xuXHRcdFx0XHRcdHRoaXMucGFnZXIgPSByZW5kZXJlci50ZXh0KCcnLCAxNSwgMTApXG5cdFx0XHRcdFx0XHQuY3NzKG5hdk9wdGlvbnMuc3R5bGUpXG5cdFx0XHRcdFx0XHQuYWRkKG5hdik7XG5cdFx0XHRcdFx0dGhpcy5kb3duID0gcmVuZGVyZXIuc3ltYm9sKCd0cmlhbmdsZS1kb3duJywgMCwgMCwgYXJyb3dTaXplLCBhcnJvd1NpemUpXG5cdFx0XHRcdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRsZWdlbmQuc2Nyb2xsKDEsIGFuaW1hdGlvbik7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmFkZChuYXYpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBTZXQgaW5pdGlhbCBwb3NpdGlvblxuXHRcdFx0XHRsZWdlbmQuc2Nyb2xsKDApO1xuXHRcdFx0XHRcblx0XHRcdFx0bGVnZW5kSGVpZ2h0ID0gc3BhY2VIZWlnaHQ7XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmIChuYXYpIHtcblx0XHRcdFx0Y2xpcFJlY3QuYXR0cih7XG5cdFx0XHRcdFx0aGVpZ2h0OiBjaGFydC5jaGFydEhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0bmF2LmhpZGUoKTtcblx0XHRcdFx0dGhpcy5zY3JvbGxHcm91cC5hdHRyKHtcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiAxXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLmNsaXBIZWlnaHQgPSAwOyAvLyAjMTM3OVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gbGVnZW5kSGVpZ2h0O1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2Nyb2xsIHRoZSBsZWdlbmQgYnkgYSBudW1iZXIgb2YgcGFnZXNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gc2Nyb2xsQnlcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0c2Nyb2xsOiBmdW5jdGlvbiAoc2Nyb2xsQnksIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIHBhZ2VzID0gdGhpcy5wYWdlcyxcblx0XHRcdFx0cGFnZUNvdW50ID0gcGFnZXMubGVuZ3RoLFxuXHRcdFx0XHRjdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2UgKyBzY3JvbGxCeSxcblx0XHRcdFx0Y2xpcEhlaWdodCA9IHRoaXMuY2xpcEhlaWdodCxcblx0XHRcdFx0bmF2T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uLFxuXHRcdFx0XHRhY3RpdmVDb2xvciA9IG5hdk9wdGlvbnMuYWN0aXZlQ29sb3IsXG5cdFx0XHRcdGluYWN0aXZlQ29sb3IgPSBuYXZPcHRpb25zLmluYWN0aXZlQ29sb3IsXG5cdFx0XHRcdHBhZ2VyID0gdGhpcy5wYWdlcixcblx0XHRcdFx0cGFkZGluZyA9IHRoaXMucGFkZGluZyxcblx0XHRcdFx0c2Nyb2xsT2Zmc2V0O1xuXHRcdFx0XG5cdFx0XHQvLyBXaGVuIHJlc2l6aW5nIHdoaWxlIGxvb2tpbmcgYXQgdGhlIGxhc3QgcGFnZVxuXHRcdFx0aWYgKGN1cnJlbnRQYWdlID4gcGFnZUNvdW50KSB7XG5cdFx0XHRcdGN1cnJlbnRQYWdlID0gcGFnZUNvdW50O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoY3VycmVudFBhZ2UgPiAwKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYW5pbWF0aW9uICE9PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCB0aGlzLmNoYXJ0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5uYXYuYXR0cih7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWDogcGFkZGluZyxcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiBjbGlwSGVpZ2h0ICsgdGhpcy5wYWRkaW5nICsgNyArIHRoaXMudGl0bGVIZWlnaHQsXG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogVklTSUJMRVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy51cC5hdHRyKHtcblx0XHRcdFx0XHRcdGZpbGw6IGN1cnJlbnRQYWdlID09PSAxID8gaW5hY3RpdmVDb2xvciA6IGFjdGl2ZUNvbG9yXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRcdGN1cnNvcjogY3VycmVudFBhZ2UgPT09IDEgPyAnZGVmYXVsdCcgOiAncG9pbnRlcidcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0cGFnZXIuYXR0cih7XG5cdFx0XHRcdFx0dGV4dDogY3VycmVudFBhZ2UgKyAnLycgKyBwYWdlQ291bnRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuZG93bi5hdHRyKHtcblx0XHRcdFx0XHRcdHg6IDE4ICsgdGhpcy5wYWdlci5nZXRCQm94KCkud2lkdGgsIC8vIGFkanVzdCB0byB0ZXh0IHdpZHRoXG5cdFx0XHRcdFx0XHRmaWxsOiBjdXJyZW50UGFnZSA9PT0gcGFnZUNvdW50ID8gaW5hY3RpdmVDb2xvciA6IGFjdGl2ZUNvbG9yXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRcdGN1cnNvcjogY3VycmVudFBhZ2UgPT09IHBhZ2VDb3VudCA/ICdkZWZhdWx0JyA6ICdwb2ludGVyJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0c2Nyb2xsT2Zmc2V0ID0gLXBhZ2VzW2N1cnJlbnRQYWdlIC0gMV0gKyB0aGlzLmluaXRpYWxJdGVtWTtcblxuXHRcdFx0XHR0aGlzLnNjcm9sbEdyb3VwLmFuaW1hdGUoe1xuXHRcdFx0XHRcdHRyYW5zbGF0ZVk6IHNjcm9sbE9mZnNldFxuXHRcdFx0XHR9KTtcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBjdXJyZW50UGFnZTtcblx0XHRcdFx0dGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoc2Nyb2xsT2Zmc2V0KTtcblx0XHRcdH1cblx0XHRcdFx0XG5cdFx0fVxuXHRcdFxuXHR9O1xuXG5cdC8qXG5cdCAqIExlZ2VuZFN5bWJvbE1peGluXG5cdCAqLyBcblxuXHR2YXIgTGVnZW5kU3ltYm9sTWl4aW4gPSBIaWdoY2hhcnRzLkxlZ2VuZFN5bWJvbE1peGluID0ge1xuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBzZXJpZXMnIHN5bWJvbCBpbiB0aGUgbGVnZW5kXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGxlZ2VuZCBUaGUgbGVnZW5kIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBzZXJpZXMgKHRoaXMpIG9yIHBvaW50XG5cdFx0ICovXG5cdFx0ZHJhd1JlY3RhbmdsZTogZnVuY3Rpb24gKGxlZ2VuZCwgaXRlbSkge1xuXHRcdFx0dmFyIHN5bWJvbEhlaWdodCA9IGxlZ2VuZC5vcHRpb25zLnN5bWJvbEhlaWdodCB8fCAxMjtcblx0XHRcdFxuXHRcdFx0aXRlbS5sZWdlbmRTeW1ib2wgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLnJlY3QoXG5cdFx0XHRcdDAsXG5cdFx0XHRcdGxlZ2VuZC5iYXNlbGluZSAtIDUgLSAoc3ltYm9sSGVpZ2h0IC8gMiksXG5cdFx0XHRcdGxlZ2VuZC5zeW1ib2xXaWR0aCxcblx0XHRcdFx0c3ltYm9sSGVpZ2h0LFxuXHRcdFx0XHRsZWdlbmQub3B0aW9ucy5zeW1ib2xSYWRpdXMgfHwgMFxuXHRcdFx0KS5hdHRyKHtcblx0XHRcdFx0ekluZGV4OiAzXG5cdFx0XHR9KS5hZGQoaXRlbS5sZWdlbmRHcm91cCk7XHRcdFxuXHRcdFx0XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgc2VyaWVzJyBzeW1ib2wgaW4gdGhlIGxlZ2VuZC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRhYmxlIHRvIGNyZWF0ZSBjdXN0b20gXG5cdFx0ICogc3ltYm9scyB0aHJvdWdoIEhpZ2hjaGFydHMuc2VyaWVzVHlwZXNbdHlwZV0ucHJvdG90eXBlLmRyYXdMZWdlbmRTeW1ib2xzLlxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBsZWdlbmQgVGhlIGxlZ2VuZCBvYmplY3Rcblx0XHQgKi9cblx0XHRkcmF3TGluZU1hcmtlcjogZnVuY3Rpb24gKGxlZ2VuZCkge1xuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0bWFya2VyT3B0aW9ucyA9IG9wdGlvbnMubWFya2VyLFxuXHRcdFx0XHRyYWRpdXMsXG5cdFx0XHRcdGxlZ2VuZE9wdGlvbnMgPSBsZWdlbmQub3B0aW9ucyxcblx0XHRcdFx0bGVnZW5kU3ltYm9sLFxuXHRcdFx0XHRzeW1ib2xXaWR0aCA9IGxlZ2VuZC5zeW1ib2xXaWR0aCxcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRsZWdlbmRJdGVtR3JvdXAgPSB0aGlzLmxlZ2VuZEdyb3VwLFxuXHRcdFx0XHR2ZXJ0aWNhbENlbnRlciA9IGxlZ2VuZC5iYXNlbGluZSAtIG1hdGhSb3VuZChyZW5kZXJlci5mb250TWV0cmljcyhsZWdlbmRPcHRpb25zLml0ZW1TdHlsZS5mb250U2l6ZSwgdGhpcy5sZWdlbmRJdGVtKS5iICogMC4zKSxcblx0XHRcdFx0YXR0cjtcblxuXHRcdFx0Ly8gRHJhdyB0aGUgbGluZVxuXHRcdFx0aWYgKG9wdGlvbnMubGluZVdpZHRoKSB7XG5cdFx0XHRcdGF0dHIgPSB7XG5cdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IG9wdGlvbnMubGluZVdpZHRoXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChvcHRpb25zLmRhc2hTdHlsZSkge1xuXHRcdFx0XHRcdGF0dHIuZGFzaHN0eWxlID0gb3B0aW9ucy5kYXNoU3R5bGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5sZWdlbmRMaW5lID0gcmVuZGVyZXIucGF0aChbXG5cdFx0XHRcdFx0TSxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdHZlcnRpY2FsQ2VudGVyLFxuXHRcdFx0XHRcdEwsXG5cdFx0XHRcdFx0c3ltYm9sV2lkdGgsXG5cdFx0XHRcdFx0dmVydGljYWxDZW50ZXJcblx0XHRcdFx0XSlcblx0XHRcdFx0LmF0dHIoYXR0cilcblx0XHRcdFx0LmFkZChsZWdlbmRJdGVtR3JvdXApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBEcmF3IHRoZSBtYXJrZXJcblx0XHRcdGlmIChtYXJrZXJPcHRpb25zICYmIG1hcmtlck9wdGlvbnMuZW5hYmxlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0cmFkaXVzID0gbWFya2VyT3B0aW9ucy5yYWRpdXM7XG5cdFx0XHRcdHRoaXMubGVnZW5kU3ltYm9sID0gbGVnZW5kU3ltYm9sID0gcmVuZGVyZXIuc3ltYm9sKFxuXHRcdFx0XHRcdHRoaXMuc3ltYm9sLFxuXHRcdFx0XHRcdChzeW1ib2xXaWR0aCAvIDIpIC0gcmFkaXVzLFxuXHRcdFx0XHRcdHZlcnRpY2FsQ2VudGVyIC0gcmFkaXVzLFxuXHRcdFx0XHRcdDIgKiByYWRpdXMsXG5cdFx0XHRcdFx0MiAqIHJhZGl1c1xuXHRcdFx0XHQpXG5cdFx0XHRcdC5hZGQobGVnZW5kSXRlbUdyb3VwKTtcblx0XHRcdFx0bGVnZW5kU3ltYm9sLmlzTWFya2VyID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gV29ya2Fyb3VuZCBmb3IgIzIwMzAsIGhvcml6b250YWwgbGVnZW5kIGl0ZW1zIG5vdCBkaXNwbGF5aW5nIGluIElFMTEgUHJldmlldyxcblx0Ly8gYW5kIGZvciAjMjU4MCwgYSBzaW1pbGFyIGRyYXdpbmcgZmxhdyBpbiBGaXJlZm94IDI2LlxuXHQvLyBUT0RPOiBFeHBsb3JlIGlmIHRoZXJlJ3MgYSBnZW5lcmFsIGNhdXNlIGZvciB0aGlzLiBUaGUgcHJvYmxlbSBtYXkgYmUgcmVsYXRlZCBcblx0Ly8gdG8gbmVzdGVkIGdyb3VwIGVsZW1lbnRzLCBhcyB0aGUgbGVnZW5kIGl0ZW0gdGV4dHMgYXJlIHdpdGhpbiA0IGdyb3VwIGVsZW1lbnRzLlxuXHRpZiAoL1RyaWRlbnRcXC83XFwuMC8udGVzdCh1c2VyQWdlbnQpIHx8IGlzRmlyZWZveCkge1xuXHRcdHdyYXAoTGVnZW5kLnByb3RvdHlwZSwgJ3Bvc2l0aW9uSXRlbScsIGZ1bmN0aW9uIChwcm9jZWVkLCBpdGVtKSB7XG5cdFx0XHR2YXIgbGVnZW5kID0gdGhpcyxcblx0XHRcdFx0cnVuUG9zaXRpb25JdGVtID0gZnVuY3Rpb24gKCkgeyAvLyBJZiBjaGFydCBkZXN0cm95ZWQgaW4gc3luYywgdGhpcyBpcyB1bmRlZmluZWQgKCMyMDMwKVxuXHRcdFx0XHRcdGlmIChpdGVtLl9sZWdlbmRJdGVtUG9zKSB7XG5cdFx0XHRcdFx0XHRwcm9jZWVkLmNhbGwobGVnZW5kLCBpdGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdC8vIERvIGl0IG5vdywgZm9yIGV4cG9ydCBhbmQgdG8gZ2V0IGNoZWNrYm94IHBsYWNlbWVudFxuXHRcdFx0cnVuUG9zaXRpb25JdGVtKCk7XG5cdFx0XHRcblx0XHRcdC8vIERvIGl0IGFmdGVyIHRvIHdvcmsgYXJvdW5kIHRoZSBjb3JlIGlzc3VlXG5cdFx0XHRzZXRUaW1lb3V0KHJ1blBvc2l0aW9uSXRlbSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCAqIFRoZSBjaGFydCBjbGFzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgY2hhcnQgaGFzIGxvYWRlZFxuXHQgKi9cblx0dmFyIENoYXJ0ID0gSGlnaGNoYXJ0cy5DaGFydCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHRDaGFydC5wcm90b3R5cGUgPSB7XG5cblx0XHQvKipcblx0XHQgKiBIb29rIGZvciBtb2R1bGVzXG5cdFx0ICovXG5cdFx0Y2FsbGJhY2tzOiBbXSxcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIGNoYXJ0XG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKHVzZXJPcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdFx0XHQvLyBIYW5kbGUgcmVndWxhciBvcHRpb25zXG5cdFx0XHR2YXIgb3B0aW9ucyxcblx0XHRcdFx0c2VyaWVzT3B0aW9ucyA9IHVzZXJPcHRpb25zLnNlcmllczsgLy8gc2tpcCBtZXJnaW5nIGRhdGEgcG9pbnRzIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG5cblx0XHRcdHVzZXJPcHRpb25zLnNlcmllcyA9IG51bGw7XG5cdFx0XHRvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKTsgLy8gZG8gdGhlIG1lcmdlXG5cdFx0XHRvcHRpb25zLnNlcmllcyA9IHVzZXJPcHRpb25zLnNlcmllcyA9IHNlcmllc09wdGlvbnM7IC8vIHNldCBiYWNrIHRoZSBzZXJpZXMgZGF0YVxuXHRcdFx0dGhpcy51c2VyT3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuXG5cdFx0XHR2YXIgb3B0aW9uc0NoYXJ0ID0gb3B0aW9ucy5jaGFydDtcblx0XHRcdFxuXHRcdFx0Ly8gQ3JlYXRlIG1hcmdpbiAmIHNwYWNpbmcgYXJyYXlcblx0XHRcdHRoaXMubWFyZ2luID0gdGhpcy5zcGxhc2hBcnJheSgnbWFyZ2luJywgb3B0aW9uc0NoYXJ0KTtcblx0XHRcdHRoaXMuc3BhY2luZyA9IHRoaXMuc3BsYXNoQXJyYXkoJ3NwYWNpbmcnLCBvcHRpb25zQ2hhcnQpO1xuXG5cdFx0XHR2YXIgY2hhcnRFdmVudHMgPSBvcHRpb25zQ2hhcnQuZXZlbnRzO1xuXG5cdFx0XHQvL3RoaXMucnVuQ2hhcnRDbGljayA9IGNoYXJ0RXZlbnRzICYmICEhY2hhcnRFdmVudHMuY2xpY2s7XG5cdFx0XHR0aGlzLmJvdW5kcyA9IHsgaDoge30sIHY6IHt9IH07IC8vIFBpeGVsIGRhdGEgYm91bmRzIGZvciB0b3VjaCB6b29tXG5cblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMuaXNSZXNpemluZyA9IDA7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0Ly9jaGFydFRpdGxlT3B0aW9ucyA9IFVOREVGSU5FRDtcblx0XHRcdC8vY2hhcnRTdWJ0aXRsZU9wdGlvbnMgPSBVTkRFRklORUQ7XG5cblx0XHRcdHRoaXMuYXhlcyA9IFtdO1xuXHRcdFx0dGhpcy5zZXJpZXMgPSBbXTtcblx0XHRcdHRoaXMuaGFzQ2FydGVzaWFuU2VyaWVzID0gb3B0aW9uc0NoYXJ0LnNob3dBeGVzO1xuXHRcdFx0Ly90aGlzLmF4aXNPZmZzZXQgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMubWF4VGlja3MgPSBVTkRFRklORUQ7IC8vIGhhbmRsZSB0aGUgZ3JlYXRlc3QgYW1vdW50IG9mIHRpY2tzIG9uIGdyb3VwZWQgYXhlc1xuXHRcdFx0Ly90aGlzLmludmVydGVkID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLmxvYWRpbmdTaG93biA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5jb250YWluZXIgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMuY2hhcnRXaWR0aCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5jaGFydEhlaWdodCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5tYXJnaW5SaWdodCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5tYXJnaW5Cb3R0b20gPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMuY29udGFpbmVyV2lkdGggPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMuY29udGFpbmVySGVpZ2h0ID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLm9sZENoYXJ0V2lkdGggPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMub2xkQ2hhcnRIZWlnaHQgPSBVTkRFRklORUQ7XG5cblx0XHRcdC8vdGhpcy5yZW5kZXJUbyA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5yZW5kZXJUb0Nsb25lID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvL3RoaXMuc3BhY2luZ0JveCA9IFVOREVGSU5FRFxuXG5cdFx0XHQvL3RoaXMubGVnZW5kID0gVU5ERUZJTkVEO1xuXG5cdFx0XHQvLyBFbGVtZW50c1xuXHRcdFx0Ly90aGlzLmNoYXJ0QmFja2dyb3VuZCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5wbG90QmFja2dyb3VuZCA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5wbG90QkdJbWFnZSA9IFVOREVGSU5FRDtcblx0XHRcdC8vdGhpcy5wbG90Qm9yZGVyID0gVU5ERUZJTkVEO1xuXHRcdFx0Ly90aGlzLmxvYWRpbmdEaXYgPSBVTkRFRklORUQ7XG5cdFx0XHQvL3RoaXMubG9hZGluZ1NwYW4gPSBVTkRFRklORUQ7XG5cblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGV2ZW50VHlwZTtcblxuXHRcdFx0Ly8gQWRkIHRoZSBjaGFydCB0byB0aGUgZ2xvYmFsIGxvb2t1cFxuXHRcdFx0Y2hhcnQuaW5kZXggPSBjaGFydHMubGVuZ3RoO1xuXHRcdFx0Y2hhcnRzLnB1c2goY2hhcnQpO1xuXHRcdFx0Y2hhcnRDb3VudCsrO1xuXG5cdFx0XHQvLyBTZXQgdXAgYXV0byByZXNpemVcblx0XHRcdGlmIChvcHRpb25zQ2hhcnQucmVmbG93ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRhZGRFdmVudChjaGFydCwgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Y2hhcnQuaW5pdFJlZmxvdygpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhcnQgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmIChjaGFydEV2ZW50cykge1xuXHRcdFx0XHRmb3IgKGV2ZW50VHlwZSBpbiBjaGFydEV2ZW50cykge1xuXHRcdFx0XHRcdGFkZEV2ZW50KGNoYXJ0LCBldmVudFR5cGUsIGNoYXJ0RXZlbnRzW2V2ZW50VHlwZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnhBeGlzID0gW107XG5cdFx0XHRjaGFydC55QXhpcyA9IFtdO1xuXG5cdFx0XHQvLyBFeHBvc2UgbWV0aG9kcyBhbmQgdmFyaWFibGVzXG5cdFx0XHRjaGFydC5hbmltYXRpb24gPSB1c2VDYW5WRyA/IGZhbHNlIDogcGljayhvcHRpb25zQ2hhcnQuYW5pbWF0aW9uLCB0cnVlKTtcblx0XHRcdGNoYXJ0LnBvaW50Q291bnQgPSBjaGFydC5jb2xvckNvdW50ZXIgPSBjaGFydC5zeW1ib2xDb3VudGVyID0gMDtcblxuXHRcdFx0Y2hhcnQuZmlyc3RSZW5kZXIoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSBhbiBpbmRpdmlkdWFsIHNlcmllcywgY2FsbGVkIGludGVybmFsbHkgYmVmb3JlIHJlbmRlciB0aW1lXG5cdFx0ICovXG5cdFx0aW5pdFNlcmllczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgb3B0aW9uc0NoYXJ0LnR5cGUgfHwgb3B0aW9uc0NoYXJ0LmRlZmF1bHRTZXJpZXNUeXBlLFxuXHRcdFx0XHRzZXJpZXMsXG5cdFx0XHRcdGNvbnN0ciA9IHNlcmllc1R5cGVzW3R5cGVdO1xuXG5cdFx0XHQvLyBObyBzdWNoIHNlcmllcyB0eXBlXG5cdFx0XHRpZiAoIWNvbnN0cikge1xuXHRcdFx0XHRlcnJvcigxNywgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcyA9IG5ldyBjb25zdHIoKTtcblx0XHRcdHNlcmllcy5pbml0KHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHNlcmllcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHBvaW50IGlzIHdpdGhpbiB0aGUgcGxvdCBhcmVhXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGxvdFggUGl4ZWwgeCByZWxhdGl2ZSB0byB0aGUgcGxvdCBhcmVhXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBsb3RZIFBpeGVsIHkgcmVsYXRpdmUgdG8gdGhlIHBsb3QgYXJlYVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0ZWQgV2hldGhlciB0aGUgY2hhcnQgaXMgaW52ZXJ0ZWRcblx0XHQgKi9cblx0XHRpc0luc2lkZVBsb3Q6IGZ1bmN0aW9uIChwbG90WCwgcGxvdFksIGludmVydGVkKSB7XG5cdFx0XHR2YXIgeCA9IGludmVydGVkID8gcGxvdFkgOiBwbG90WCxcblx0XHRcdFx0eSA9IGludmVydGVkID8gcGxvdFggOiBwbG90WTtcblx0XHRcdFx0XG5cdFx0XHRyZXR1cm4geCA+PSAwICYmXG5cdFx0XHRcdHggPD0gdGhpcy5wbG90V2lkdGggJiZcblx0XHRcdFx0eSA+PSAwICYmXG5cdFx0XHRcdHkgPD0gdGhpcy5wbG90SGVpZ2h0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZWRyYXcgbGVnZW5kLCBheGVzIG9yIHNlcmllcyBiYXNlZCBvbiB1cGRhdGVkIGRhdGFcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdFx0ICogICAgY29uZmlndXJhdGlvblxuXHRcdCAqL1xuXHRcdHJlZHJhdzogZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0YXhlcyA9IGNoYXJ0LmF4ZXMsXG5cdFx0XHRcdHNlcmllcyA9IGNoYXJ0LnNlcmllcyxcblx0XHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRcdGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCxcblx0XHRcdFx0cmVkcmF3TGVnZW5kID0gY2hhcnQuaXNEaXJ0eUxlZ2VuZCxcblx0XHRcdFx0aGFzU3RhY2tlZFNlcmllcyxcblx0XHRcdFx0aGFzRGlydHlTdGFja3MsXG5cdFx0XHRcdGhhc0NhcnRlc2lhblNlcmllcyA9IGNoYXJ0Lmhhc0NhcnRlc2lhblNlcmllcyxcblx0XHRcdFx0aXNEaXJ0eUJveCA9IGNoYXJ0LmlzRGlydHlCb3gsIC8vIHRvZG86IGNoZWNrIGlmIGl0IGhhcyBhY3R1YWxseSBjaGFuZ2VkP1xuXHRcdFx0XHRzZXJpZXNMZW5ndGggPSBzZXJpZXMubGVuZ3RoLFxuXHRcdFx0XHRpID0gc2VyaWVzTGVuZ3RoLFxuXHRcdFx0XHRzZXJpZSxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0aXNIaWRkZW5DaGFydCA9IHJlbmRlcmVyLmlzSGlkZGVuKCksXG5cdFx0XHRcdGFmdGVyUmVkcmF3ID0gW107XG5cdFx0XHRcdFxuXHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoaXNIaWRkZW5DaGFydCkge1xuXHRcdFx0XHRjaGFydC5jbG9uZVJlbmRlclRvKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkanVzdCB0aXRsZSBsYXlvdXQgKHJlZmxvdyBtdWx0aWxpbmUgdGV4dClcblx0XHRcdGNoYXJ0LmxheU91dFRpdGxlcygpO1xuXG5cdFx0XHQvLyBsaW5rIHN0YWNrZWQgc2VyaWVzXG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHNlcmllID0gc2VyaWVzW2ldO1xuXG5cdFx0XHRcdGlmIChzZXJpZS5vcHRpb25zLnN0YWNraW5nKSB7XG5cdFx0XHRcdFx0aGFzU3RhY2tlZFNlcmllcyA9IHRydWU7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHNlcmllLmlzRGlydHkpIHtcblx0XHRcdFx0XHRcdGhhc0RpcnR5U3RhY2tzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0RpcnR5U3RhY2tzKSB7IC8vIG1hcmsgb3RoZXJzIGFzIGRpcnR5XG5cdFx0XHRcdGkgPSBzZXJpZXNMZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRzZXJpZSA9IHNlcmllc1tpXTtcblx0XHRcdFx0XHRpZiAoc2VyaWUub3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0XHRcdFx0c2VyaWUuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGhhbmRsZSB1cGRhdGVkIGRhdGEgaW4gdGhlIHNlcmllc1xuXHRcdFx0ZWFjaChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRpZiAoc2VyaWUuaXNEaXJ0eSkgeyAvLyBwcmVwYXJlIHRoZSBkYXRhIHNvIGF4aXMgY2FuIHJlYWQgaXRcblx0XHRcdFx0XHRpZiAoc2VyaWUub3B0aW9ucy5sZWdlbmRUeXBlID09PSAncG9pbnQnKSB7XG5cdFx0XHRcdFx0XHRyZWRyYXdMZWdlbmQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGhhbmRsZSBhZGRlZCBvciByZW1vdmVkIHNlcmllc1xuXHRcdFx0aWYgKHJlZHJhd0xlZ2VuZCAmJiBsZWdlbmQub3B0aW9ucy5lbmFibGVkKSB7IC8vIHNlcmllcyBvciBwaWUgcG9pbnRzIGFyZSBhZGRlZCBvciByZW1vdmVkXG5cdFx0XHRcdC8vIGRyYXcgbGVnZW5kIGdyYXBoaWNzXG5cdFx0XHRcdGxlZ2VuZC5yZW5kZXIoKTtcblxuXHRcdFx0XHRjaGFydC5pc0RpcnR5TGVnZW5kID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlc2V0IHN0YWNrc1xuXHRcdFx0aWYgKGhhc1N0YWNrZWRTZXJpZXMpIHtcblx0XHRcdFx0Y2hhcnQuZ2V0U3RhY2tzKCk7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKGhhc0NhcnRlc2lhblNlcmllcykge1xuXHRcdFx0XHRpZiAoIWNoYXJ0LmlzUmVzaXppbmcpIHtcblxuXHRcdFx0XHRcdC8vIHJlc2V0IG1heFRpY2tzXG5cdFx0XHRcdFx0Y2hhcnQubWF4VGlja3MgPSBudWxsO1xuXG5cdFx0XHRcdFx0Ly8gc2V0IGF4ZXMgc2NhbGVzXG5cdFx0XHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdFx0YXhpcy5zZXRTY2FsZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LmdldE1hcmdpbnMoKTsgLy8gIzMwOThcblxuXHRcdFx0aWYgKGhhc0NhcnRlc2lhblNlcmllcykge1xuXHRcdFx0XHQvLyBJZiBvbmUgYXhpcyBpcyBkaXJ0eSwgYWxsIGF4ZXMgbXVzdCBiZSByZWRyYXduICgjNzkyLCAjMjE2OSlcblx0XHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGlmIChheGlzLmlzRGlydHkpIHtcblx0XHRcdFx0XHRcdGlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gcmVkcmF3IGF4ZXNcblx0XHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEZpcmUgJ2FmdGVyU2V0RXh0cmVtZXMnIG9ubHkgaWYgZXh0cmVtZXMgYXJlIHNldFxuXHRcdFx0XHRcdGlmIChheGlzLmlzRGlydHlFeHRyZW1lcykgeyAvLyAjODIxXG5cdFx0XHRcdFx0XHRheGlzLmlzRGlydHlFeHRyZW1lcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YWZ0ZXJSZWRyYXcucHVzaChmdW5jdGlvbiAoKSB7IC8vIHByZXZlbnQgYSByZWN1cnNpdmUgY2FsbCB0byBjaGFydC5yZWRyYXcoKSAoIzExMTkpXG5cdFx0XHRcdFx0XHRcdGZpcmVFdmVudChheGlzLCAnYWZ0ZXJTZXRFeHRyZW1lcycsIGV4dGVuZChheGlzLmV2ZW50QXJncywgYXhpcy5nZXRFeHRyZW1lcygpKSk7IC8vICM3NDcsICM3NTFcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGF4aXMuZXZlbnRBcmdzO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChpc0RpcnR5Qm94IHx8IGhhc1N0YWNrZWRTZXJpZXMpIHtcblx0XHRcdFx0XHRcdGF4aXMucmVkcmF3KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gdGhlIHBsb3QgYXJlYXMgc2l6ZSBoYXMgY2hhbmdlZFxuXHRcdFx0aWYgKGlzRGlydHlCb3gpIHtcblx0XHRcdFx0Y2hhcnQuZHJhd0NoYXJ0Qm94KCk7XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gcmVkcmF3IGFmZmVjdGVkIHNlcmllc1xuXHRcdFx0ZWFjaChzZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRpZiAoc2VyaWUuaXNEaXJ0eSAmJiBzZXJpZS52aXNpYmxlICYmXG5cdFx0XHRcdFx0XHQoIXNlcmllLmlzQ2FydGVzaWFuIHx8IHNlcmllLnhBeGlzKSkgeyAvLyBpc3N1ZSAjMTUzXG5cdFx0XHRcdFx0c2VyaWUucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBtb3ZlIHRvb2x0aXAgb3IgcmVzZXRcblx0XHRcdGlmIChwb2ludGVyKSB7XG5cdFx0XHRcdHBvaW50ZXIucmVzZXQodHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZHJhdyBpZiBjYW52YXNcblx0XHRcdHJlbmRlcmVyLmRyYXcoKTtcblxuXHRcdFx0Ly8gZmlyZSB0aGUgZXZlbnRcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ3JlZHJhdycpOyAvLyBqUXVlcnkgYnJlYWtzIHRoaXMgd2hlbiBjYWxsaW5nIGl0IGZyb20gYWRkRXZlbnQuIE92ZXJ3cml0ZXMgY2hhcnQucmVkcmF3XG5cdFx0XHRcblx0XHRcdGlmIChpc0hpZGRlbkNoYXJ0KSB7XG5cdFx0XHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8odHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEZpcmUgY2FsbGJhY2tzIHRoYXQgYXJlIHB1dCBvbiBob2xkIHVudGlsIGFmdGVyIHRoZSByZWRyYXdcblx0XHRcdGVhY2goYWZ0ZXJSZWRyYXcsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGFuIGF4aXMsIHNlcmllcyBvciBwb2ludCBvYmplY3QgYnkgaWQuXG5cdFx0ICogQHBhcmFtIGlkIHtTdHJpbmd9IFRoZSBpZCBhcyBnaXZlbiBpbiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zXG5cdFx0ICovXG5cdFx0Z2V0OiBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXM7XG5cblx0XHRcdHZhciBpLFxuXHRcdFx0XHRqLFxuXHRcdFx0XHRwb2ludHM7XG5cblx0XHRcdC8vIHNlYXJjaCBheGVzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXhlc1tpXS5vcHRpb25zLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHJldHVybiBheGVzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNlYXJjaCBzZXJpZXNcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHNlcmllc1tpXS5vcHRpb25zLmlkID09PSBpZCkge1xuXHRcdFx0XHRcdHJldHVybiBzZXJpZXNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2VhcmNoIHBvaW50c1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXNbaV0ucG9pbnRzIHx8IFtdO1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKHBvaW50c1tqXS5pZCA9PT0gaWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwb2ludHNbal07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIHRoZSBBeGlzIGluc3RhbmNlcyBiYXNlZCBvbiB0aGUgY29uZmlnIG9wdGlvbnNcblx0XHQgKi9cblx0XHRnZXRBeGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR4QXhpc09wdGlvbnMgPSBvcHRpb25zLnhBeGlzID0gc3BsYXQob3B0aW9ucy54QXhpcyB8fCB7fSksXG5cdFx0XHRcdHlBeGlzT3B0aW9ucyA9IG9wdGlvbnMueUF4aXMgPSBzcGxhdChvcHRpb25zLnlBeGlzIHx8IHt9KSxcblx0XHRcdFx0b3B0aW9uc0FycmF5LFxuXHRcdFx0XHRheGlzO1xuXG5cdFx0XHQvLyBtYWtlIHN1cmUgdGhlIG9wdGlvbnMgYXJlIGFycmF5cyBhbmQgYWRkIHNvbWUgbWVtYmVyc1xuXHRcdFx0ZWFjaCh4QXhpc09wdGlvbnMsIGZ1bmN0aW9uIChheGlzLCBpKSB7XG5cdFx0XHRcdGF4aXMuaW5kZXggPSBpO1xuXHRcdFx0XHRheGlzLmlzWCA9IHRydWU7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZWFjaCh5QXhpc09wdGlvbnMsIGZ1bmN0aW9uIChheGlzLCBpKSB7XG5cdFx0XHRcdGF4aXMuaW5kZXggPSBpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGNvbmNhdGVuYXRlIGFsbCBheGlzIG9wdGlvbnMgaW50byBvbmUgYXJyYXlcblx0XHRcdG9wdGlvbnNBcnJheSA9IHhBeGlzT3B0aW9ucy5jb25jYXQoeUF4aXNPcHRpb25zKTtcblxuXHRcdFx0ZWFjaChvcHRpb25zQXJyYXksIGZ1bmN0aW9uIChheGlzT3B0aW9ucykge1xuXHRcdFx0XHRheGlzID0gbmV3IEF4aXMoY2hhcnQsIGF4aXNPcHRpb25zKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvaW50cyBmcm9tIGFsbCBzZXJpZXNcblx0XHQgKi9cblx0XHRnZXRTZWxlY3RlZFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBvaW50cyA9IFtdO1xuXHRcdFx0ZWFjaCh0aGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRcdHBvaW50cyA9IHBvaW50cy5jb25jYXQoZ3JlcChzZXJpZS5wb2ludHMgfHwgW10sIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdHJldHVybiBwb2ludC5zZWxlY3RlZDtcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzZXJpZXNcblx0XHQgKi9cblx0XHRnZXRTZWxlY3RlZFNlcmllczogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdyZXAodGhpcy5zZXJpZXMsIGZ1bmN0aW9uIChzZXJpZSkge1xuXHRcdFx0XHRyZXR1cm4gc2VyaWUuc2VsZWN0ZWQ7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdGUgc3RhY2tzIGZvciBlYWNoIHNlcmllcyBhbmQgY2FsY3VsYXRlIHN0YWNrcyB0b3RhbCB2YWx1ZXNcblx0XHQgKi9cblx0XHRnZXRTdGFja3M6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXM7XG5cblx0XHRcdC8vIHJlc2V0IHN0YWNrcyBmb3IgZWFjaCB5QXhpc1xuXHRcdFx0ZWFjaChjaGFydC55QXhpcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0aWYgKGF4aXMuc3RhY2tzICYmIGF4aXMuaGFzVmlzaWJsZVNlcmllcykge1xuXHRcdFx0XHRcdGF4aXMub2xkU3RhY2tzID0gYXhpcy5zdGFja3M7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuc3RhY2tpbmcgJiYgKHNlcmllcy52aXNpYmxlID09PSB0cnVlIHx8IGNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzID09PSBmYWxzZSkpIHtcblx0XHRcdFx0XHRzZXJpZXMuc3RhY2tLZXkgPSBzZXJpZXMudHlwZSArIHBpY2soc2VyaWVzLm9wdGlvbnMuc3RhY2ssICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcdFxuXG5cdFx0LyoqXG5cdFx0ICogU2hvdyB0aGUgdGl0bGUgYW5kIHN1YnRpdGxlIG9mIHRoZSBjaGFydFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHRpdGxlT3B0aW9ucyB7T2JqZWN0fSBOZXcgdGl0bGUgb3B0aW9uc1xuXHRcdCAqIEBwYXJhbSBzdWJ0aXRsZU9wdGlvbnMge09iamVjdH0gTmV3IHN1YnRpdGxlIG9wdGlvbnNcblx0XHQgKlxuXHRcdCAqL1xuXHRcdHNldFRpdGxlOiBmdW5jdGlvbiAodGl0bGVPcHRpb25zLCBzdWJ0aXRsZU9wdGlvbnMsIHJlZHJhdykge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0VGl0bGVPcHRpb25zLFxuXHRcdFx0XHRjaGFydFN1YnRpdGxlT3B0aW9ucztcblxuXHRcdFx0Y2hhcnRUaXRsZU9wdGlvbnMgPSBvcHRpb25zLnRpdGxlID0gbWVyZ2Uob3B0aW9ucy50aXRsZSwgdGl0bGVPcHRpb25zKTtcblx0XHRcdGNoYXJ0U3VidGl0bGVPcHRpb25zID0gb3B0aW9ucy5zdWJ0aXRsZSA9IG1lcmdlKG9wdGlvbnMuc3VidGl0bGUsIHN1YnRpdGxlT3B0aW9ucyk7XG5cblx0XHRcdC8vIGFkZCB0aXRsZSBhbmQgc3VidGl0bGVcblx0XHRcdGVhY2goW1xuXHRcdFx0XHRbJ3RpdGxlJywgdGl0bGVPcHRpb25zLCBjaGFydFRpdGxlT3B0aW9uc10sXG5cdFx0XHRcdFsnc3VidGl0bGUnLCBzdWJ0aXRsZU9wdGlvbnMsIGNoYXJ0U3VidGl0bGVPcHRpb25zXVxuXHRcdFx0XSwgZnVuY3Rpb24gKGFycikge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGFyclswXSxcblx0XHRcdFx0XHR0aXRsZSA9IGNoYXJ0W25hbWVdLFxuXHRcdFx0XHRcdHRpdGxlT3B0aW9ucyA9IGFyclsxXSxcblx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucyA9IGFyclsyXTtcblxuXHRcdFx0XHRpZiAodGl0bGUgJiYgdGl0bGVPcHRpb25zKSB7XG5cdFx0XHRcdFx0Y2hhcnRbbmFtZV0gPSB0aXRsZSA9IHRpdGxlLmRlc3Ryb3koKTsgLy8gcmVtb3ZlIG9sZFxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoY2hhcnRUaXRsZU9wdGlvbnMgJiYgY2hhcnRUaXRsZU9wdGlvbnMudGV4dCAmJiAhdGl0bGUpIHtcblx0XHRcdFx0XHRjaGFydFtuYW1lXSA9IGNoYXJ0LnJlbmRlcmVyLnRleHQoXG5cdFx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucy50ZXh0LFxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRjaGFydFRpdGxlT3B0aW9ucy51c2VIVE1MXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdGFsaWduOiBjaGFydFRpdGxlT3B0aW9ucy5hbGlnbixcblx0XHRcdFx0XHRcdCdjbGFzcyc6IFBSRUZJWCArIG5hbWUsXG5cdFx0XHRcdFx0XHR6SW5kZXg6IGNoYXJ0VGl0bGVPcHRpb25zLnpJbmRleCB8fCA0XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuY3NzKGNoYXJ0VGl0bGVPcHRpb25zLnN0eWxlKVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fVx0XG5cdFx0XHR9KTtcblx0XHRcdGNoYXJ0LmxheU91dFRpdGxlcyhyZWRyYXcpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMYXkgb3V0IHRoZSBjaGFydCB0aXRsZXMgYW5kIGNhY2hlIHRoZSBmdWxsIG9mZnNldCBoZWlnaHQgZm9yIHVzZSBpbiBnZXRNYXJnaW5zXG5cdFx0ICovXG5cdFx0bGF5T3V0VGl0bGVzOiBmdW5jdGlvbiAocmVkcmF3KSB7XG5cdFx0XHR2YXIgdGl0bGVPZmZzZXQgPSAwLFxuXHRcdFx0XHR0aXRsZSA9IHRoaXMudGl0bGUsXG5cdFx0XHRcdHN1YnRpdGxlID0gdGhpcy5zdWJ0aXRsZSxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dGl0bGVPcHRpb25zID0gb3B0aW9ucy50aXRsZSxcblx0XHRcdFx0c3VidGl0bGVPcHRpb25zID0gb3B0aW9ucy5zdWJ0aXRsZSxcblx0XHRcdFx0cmVxdWlyZXNEaXJ0eUJveCxcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuXHRcdFx0XHRhdXRvV2lkdGggPSB0aGlzLnNwYWNpbmdCb3gud2lkdGggLSA0NDsgLy8gNDQgbWFrZXMgcm9vbSBmb3IgZGVmYXVsdCBjb250ZXh0IGJ1dHRvblxuXG5cdFx0XHRpZiAodGl0bGUpIHtcblx0XHRcdFx0dGl0bGVcblx0XHRcdFx0XHQuY3NzKHsgd2lkdGg6ICh0aXRsZU9wdGlvbnMud2lkdGggfHwgYXV0b1dpZHRoKSArIFBYIH0pXG5cdFx0XHRcdFx0LmFsaWduKGV4dGVuZCh7IFxuXHRcdFx0XHRcdFx0eTogcmVuZGVyZXIuZm9udE1ldHJpY3ModGl0bGVPcHRpb25zLnN0eWxlLmZvbnRTaXplLCB0aXRsZSkuYiAtIDNcblx0XHRcdFx0XHR9LCB0aXRsZU9wdGlvbnMpLCBmYWxzZSwgJ3NwYWNpbmdCb3gnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmICghdGl0bGVPcHRpb25zLmZsb2F0aW5nICYmICF0aXRsZU9wdGlvbnMudmVydGljYWxBbGlnbikge1xuXHRcdFx0XHRcdHRpdGxlT2Zmc2V0ID0gdGl0bGUuZ2V0QkJveCgpLmhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHN1YnRpdGxlKSB7XG5cdFx0XHRcdHN1YnRpdGxlXG5cdFx0XHRcdFx0LmNzcyh7IHdpZHRoOiAoc3VidGl0bGVPcHRpb25zLndpZHRoIHx8IGF1dG9XaWR0aCkgKyBQWCB9KVxuXHRcdFx0XHRcdC5hbGlnbihleHRlbmQoeyBcblx0XHRcdFx0XHRcdHk6IHRpdGxlT2Zmc2V0ICsgKHRpdGxlT3B0aW9ucy5tYXJnaW4gLSAxMykgKyByZW5kZXJlci5mb250TWV0cmljcyh0aXRsZU9wdGlvbnMuc3R5bGUuZm9udFNpemUsIHN1YnRpdGxlKS5iIFxuXHRcdFx0XHRcdH0sIHN1YnRpdGxlT3B0aW9ucyksIGZhbHNlLCAnc3BhY2luZ0JveCcpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKCFzdWJ0aXRsZU9wdGlvbnMuZmxvYXRpbmcgJiYgIXN1YnRpdGxlT3B0aW9ucy52ZXJ0aWNhbEFsaWduKSB7XG5cdFx0XHRcdFx0dGl0bGVPZmZzZXQgPSBtYXRoQ2VpbCh0aXRsZU9mZnNldCArIHN1YnRpdGxlLmdldEJCb3goKS5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJlcXVpcmVzRGlydHlCb3ggPSB0aGlzLnRpdGxlT2Zmc2V0ICE9PSB0aXRsZU9mZnNldDtcdFx0XHRcdFxuXHRcdFx0dGhpcy50aXRsZU9mZnNldCA9IHRpdGxlT2Zmc2V0OyAvLyB1c2VkIGluIGdldE1hcmdpbnNcblxuXHRcdFx0aWYgKCF0aGlzLmlzRGlydHlCb3ggJiYgcmVxdWlyZXNEaXJ0eUJveCkge1xuXHRcdFx0XHR0aGlzLmlzRGlydHlCb3ggPSByZXF1aXJlc0RpcnR5Qm94O1xuXHRcdFx0XHQvLyBSZWRyYXcgaWYgbmVjZXNzYXJ5ICgjMjcxOSwgIzI3NDQpXHRcdFxuXHRcdFx0XHRpZiAodGhpcy5oYXNSZW5kZXJlZCAmJiBwaWNrKHJlZHJhdywgdHJ1ZSkgJiYgdGhpcy5pc0RpcnR5Qm94KSB7XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgY2hhcnQgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gb3B0aW9ucyBhbmQgY29udGFpbmVyIHNpemVcblx0XHQgKi9cblx0XHRnZXRDaGFydFNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnNDaGFydCA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQsXG5cdFx0XHRcdHdpZHRoT3B0aW9uID0gb3B0aW9uc0NoYXJ0LndpZHRoLFxuXHRcdFx0XHRoZWlnaHRPcHRpb24gPSBvcHRpb25zQ2hhcnQuaGVpZ2h0LFxuXHRcdFx0XHRyZW5kZXJUbyA9IGNoYXJ0LnJlbmRlclRvQ2xvbmUgfHwgY2hhcnQucmVuZGVyVG87XG5cblx0XHRcdC8vIGdldCBpbm5lciB3aWR0aCBhbmQgaGVpZ2h0IGZyb20galF1ZXJ5ICgjODI0KVxuXHRcdFx0aWYgKCFkZWZpbmVkKHdpZHRoT3B0aW9uKSkge1xuXHRcdFx0XHRjaGFydC5jb250YWluZXJXaWR0aCA9IGFkYXB0ZXJSdW4ocmVuZGVyVG8sICd3aWR0aCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFkZWZpbmVkKGhlaWdodE9wdGlvbikpIHtcblx0XHRcdFx0Y2hhcnQuY29udGFpbmVySGVpZ2h0ID0gYWRhcHRlclJ1bihyZW5kZXJUbywgJ2hlaWdodCcpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjaGFydC5jaGFydFdpZHRoID0gbWF0aE1heCgwLCB3aWR0aE9wdGlvbiB8fCBjaGFydC5jb250YWluZXJXaWR0aCB8fCA2MDApOyAvLyAjMTM5MywgMTQ2MFxuXHRcdFx0Y2hhcnQuY2hhcnRIZWlnaHQgPSBtYXRoTWF4KDAsIHBpY2soaGVpZ2h0T3B0aW9uLFxuXHRcdFx0XHQvLyB0aGUgb2Zmc2V0SGVpZ2h0IG9mIGFuIGVtcHR5IGNvbnRhaW5lciBpcyAwIGluIHN0YW5kYXJkIGJyb3dzZXJzLCBidXQgMTkgaW4gSUU3OlxuXHRcdFx0XHRjaGFydC5jb250YWluZXJIZWlnaHQgPiAxOSA/IGNoYXJ0LmNvbnRhaW5lckhlaWdodCA6IDQwMCkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgY2hhcnQncyByZW5kZXJUbyBkaXYgYW5kIHBsYWNlIGl0IG91dHNpZGUgdGhlIHZpZXdwb3J0IHRvIGFsbG93XG5cdFx0ICogc2l6ZSBjb21wdXRhdGlvbiBvbiBjaGFydC5yZW5kZXIgYW5kIGNoYXJ0LnJlZHJhd1xuXHRcdCAqL1xuXHRcdGNsb25lUmVuZGVyVG86IGZ1bmN0aW9uIChyZXZlcnQpIHtcblx0XHRcdHZhciBjbG9uZSA9IHRoaXMucmVuZGVyVG9DbG9uZSxcblx0XHRcdFx0Y29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG5cdFx0XHRcblx0XHRcdC8vIERlc3Ryb3kgdGhlIGNsb25lIGFuZCBicmluZyB0aGUgY29udGFpbmVyIGJhY2sgdG8gdGhlIHJlYWwgcmVuZGVyVG8gZGl2XG5cdFx0XHRpZiAocmV2ZXJ0KSB7XG5cdFx0XHRcdGlmIChjbG9uZSkge1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyVG8uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0XHRcdFx0XHRkaXNjYXJkRWxlbWVudChjbG9uZSk7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMucmVuZGVyVG9DbG9uZTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBTZXQgdXAgdGhlIGNsb25lXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5wYXJlbnROb2RlID09PSB0aGlzLnJlbmRlclRvKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJUby5yZW1vdmVDaGlsZChjb250YWluZXIpOyAvLyBkbyBub3QgY2xvbmUgdGhpc1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVuZGVyVG9DbG9uZSA9IGNsb25lID0gdGhpcy5yZW5kZXJUby5jbG9uZU5vZGUoMCk7XG5cdFx0XHRcdGNzcyhjbG9uZSwge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBBQlNPTFVURSxcblx0XHRcdFx0XHR0b3A6ICctOTk5OXB4Jyxcblx0XHRcdFx0XHRkaXNwbGF5OiAnYmxvY2snIC8vICM4MzNcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eSkgeyAvLyAjMjYzMVxuXHRcdFx0XHRcdGNsb25lLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ2Jsb2NrJywgJ2ltcG9ydGFudCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvYy5ib2R5LmFwcGVuZENoaWxkKGNsb25lKTtcblx0XHRcdFx0aWYgKGNvbnRhaW5lcikge1xuXHRcdFx0XHRcdGNsb25lLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBjb250YWluaW5nIGVsZW1lbnQsIGRldGVybWluZSB0aGUgc2l6ZSBhbmQgY3JlYXRlIHRoZSBpbm5lciBjb250YWluZXJcblx0XHQgKiBkaXYgdG8gaG9sZCB0aGUgY2hhcnRcblx0XHQgKi9cblx0XHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGNvbnRhaW5lcixcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0Y2hhcnRXaWR0aCxcblx0XHRcdFx0Y2hhcnRIZWlnaHQsXG5cdFx0XHRcdHJlbmRlclRvLFxuXHRcdFx0XHRpbmRleEF0dHJOYW1lID0gJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcsXG5cdFx0XHRcdG9sZENoYXJ0SW5kZXgsXG5cdFx0XHRcdGNvbnRhaW5lcklkO1xuXG5cdFx0XHRjaGFydC5yZW5kZXJUbyA9IHJlbmRlclRvID0gb3B0aW9uc0NoYXJ0LnJlbmRlclRvO1xuXHRcdFx0Y29udGFpbmVySWQgPSBQUkVGSVggKyBpZENvdW50ZXIrKztcblxuXHRcdFx0aWYgKGlzU3RyaW5nKHJlbmRlclRvKSkge1xuXHRcdFx0XHRjaGFydC5yZW5kZXJUbyA9IHJlbmRlclRvID0gZG9jLmdldEVsZW1lbnRCeUlkKHJlbmRlclRvKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gRGlzcGxheSBhbiBlcnJvciBpZiB0aGUgcmVuZGVyVG8gaXMgd3Jvbmdcblx0XHRcdGlmICghcmVuZGVyVG8pIHtcblx0XHRcdFx0ZXJyb3IoMTMsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIGFscmVhZHkgaG9sZHMgYSBjaGFydCwgZGVzdHJveSBpdC4gVGhlIGNoZWNrIGZvciBoYXNSZW5kZXJlZCBpcyB0aGVyZVxuXHRcdFx0Ly8gYmVjYXVzZSB3ZWIgcGFnZXMgdGhhdCBhcmUgc2F2ZWQgdG8gZGlzayBmcm9tIHRoZSBicm93c2VyLCB3aWxsIHByZXNlcnZlIHRoZSBkYXRhLWhpZ2hjaGFydHMtY2hhcnRcblx0XHRcdC8vIGF0dHJpYnV0ZSBhbmQgdGhlIFNWRyBjb250ZW50cywgYnV0IG5vdCBhbiBpbnRlcmFjdGl2ZSBjaGFydC4gU28gaW4gdGhpcyBjYXNlLFxuXHRcdFx0Ly8gY2hhcnRzW29sZENoYXJ0SW5kZXhdIHdpbGwgcG9pbnQgdG8gdGhlIHdyb25nIGNoYXJ0IGlmIGFueSAoIzI2MDkpLlxuXHRcdFx0b2xkQ2hhcnRJbmRleCA9IHBJbnQoYXR0cihyZW5kZXJUbywgaW5kZXhBdHRyTmFtZSkpO1xuXHRcdFx0aWYgKCFpc05hTihvbGRDaGFydEluZGV4KSAmJiBjaGFydHNbb2xkQ2hhcnRJbmRleF0gJiYgY2hhcnRzW29sZENoYXJ0SW5kZXhdLmhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdGNoYXJ0c1tvbGRDaGFydEluZGV4XS5kZXN0cm95KCk7XG5cdFx0XHR9XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBNYWtlIGEgcmVmZXJlbmNlIHRvIHRoZSBjaGFydCBmcm9tIHRoZSBkaXZcblx0XHRcdGF0dHIocmVuZGVyVG8sIGluZGV4QXR0ck5hbWUsIGNoYXJ0LmluZGV4KTtcblxuXHRcdFx0Ly8gcmVtb3ZlIHByZXZpb3VzIGNoYXJ0XG5cdFx0XHRyZW5kZXJUby5pbm5lckhUTUwgPSAnJztcblxuXHRcdFx0Ly8gSWYgdGhlIGNvbnRhaW5lciBkb2Vzbid0IGhhdmUgYW4gb2Zmc2V0V2lkdGgsIGl0IGhhcyBvciBpcyBhIGNoaWxkIG9mIGEgbm9kZVxuXHRcdFx0Ly8gdGhhdCBoYXMgZGlzcGxheTpub25lLiBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IG1vdmUgaXQgb3V0IHRvIGEgdmlzaWJsZVxuXHRcdFx0Ly8gc3RhdGUgdG8gZGV0ZXJtaW5lIHRoZSBzaXplLCBlbHNlIHRoZSBsZWdlbmQgYW5kIHRvb2x0aXBzIHdvbid0IHJlbmRlclxuXHRcdFx0Ly8gcHJvcGVybHkuIFRoZSBhbGxvd0Nsb25lIG9wdGlvbiBpcyB1c2VkIGluIHNwYXJrbGluZXMgYXMgYSBtaWNybyBvcHRpbWl6YXRpb24sXG5cdFx0XHQvLyBzYXZpbmcgYWJvdXQgMS0yIG1zIGVhY2ggY2hhcnQuXG5cdFx0XHRpZiAoIW9wdGlvbnNDaGFydC5za2lwQ2xvbmUgJiYgIXJlbmRlclRvLm9mZnNldFdpZHRoKSB7XG5cdFx0XHRcdGNoYXJ0LmNsb25lUmVuZGVyVG8oKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0XHRjaGFydC5nZXRDaGFydFNpemUoKTtcblx0XHRcdGNoYXJ0V2lkdGggPSBjaGFydC5jaGFydFdpZHRoO1xuXHRcdFx0Y2hhcnRIZWlnaHQgPSBjaGFydC5jaGFydEhlaWdodDtcblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSBpbm5lciBjb250YWluZXJcblx0XHRcdGNoYXJ0LmNvbnRhaW5lciA9IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoRElWLCB7XG5cdFx0XHRcdFx0Y2xhc3NOYW1lOiBQUkVGSVggKyAnY29udGFpbmVyJyArXG5cdFx0XHRcdFx0XHQob3B0aW9uc0NoYXJ0LmNsYXNzTmFtZSA/ICcgJyArIG9wdGlvbnNDaGFydC5jbGFzc05hbWUgOiAnJyksXG5cdFx0XHRcdFx0aWQ6IGNvbnRhaW5lcklkXG5cdFx0XHRcdH0sIGV4dGVuZCh7XG5cdFx0XHRcdFx0cG9zaXRpb246IFJFTEFUSVZFLFxuXHRcdFx0XHRcdG92ZXJmbG93OiBISURERU4sIC8vIG5lZWRlZCBmb3IgY29udGV4dCBtZW51IChhdm9pZCBzY3JvbGxiYXJzKSBhbmRcblx0XHRcdFx0XHRcdC8vIGNvbnRlbnQgb3ZlcmZsb3cgaW4gSUVcblx0XHRcdFx0XHR3aWR0aDogY2hhcnRXaWR0aCArIFBYLFxuXHRcdFx0XHRcdGhlaWdodDogY2hhcnRIZWlnaHQgKyBQWCxcblx0XHRcdFx0XHR0ZXh0QWxpZ246ICdsZWZ0Jyxcblx0XHRcdFx0XHRsaW5lSGVpZ2h0OiAnbm9ybWFsJywgLy8gIzQyN1xuXHRcdFx0XHRcdHpJbmRleDogMCwgLy8gIzEwNzJcblx0XHRcdFx0XHQnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJzogJ3JnYmEoMCwwLDAsMCknXG5cdFx0XHRcdH0sIG9wdGlvbnNDaGFydC5zdHlsZSksXG5cdFx0XHRcdGNoYXJ0LnJlbmRlclRvQ2xvbmUgfHwgcmVuZGVyVG9cblx0XHRcdCk7XG5cblx0XHRcdC8vIGNhY2hlIHRoZSBjdXJzb3IgKCMxNjUwKVxuXHRcdFx0Y2hhcnQuX2N1cnNvciA9IGNvbnRhaW5lci5zdHlsZS5jdXJzb3I7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgdGhlIHJlbmRlcmVyXG5cdFx0XHRjaGFydC5yZW5kZXJlciA9XG5cdFx0XHRcdG9wdGlvbnNDaGFydC5mb3JFeHBvcnQgPyAvLyBmb3JjZSBTVkcsIHVzZWQgZm9yIFNWRyBleHBvcnRcblx0XHRcdFx0XHRuZXcgU1ZHUmVuZGVyZXIoY29udGFpbmVyLCBjaGFydFdpZHRoLCBjaGFydEhlaWdodCwgb3B0aW9uc0NoYXJ0LnN0eWxlLCB0cnVlKSA6XG5cdFx0XHRcdFx0bmV3IFJlbmRlcmVyKGNvbnRhaW5lciwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQsIG9wdGlvbnNDaGFydC5zdHlsZSk7XG5cblx0XHRcdGlmICh1c2VDYW5WRykge1xuXHRcdFx0XHQvLyBJZiB3ZSBuZWVkIGNhbnZnIGxpYnJhcnksIGV4dGVuZCBhbmQgY29uZmlndXJlIHRoZSByZW5kZXJlclxuXHRcdFx0XHQvLyB0byBnZXQgdGhlIHRyYWNrZXIgZm9yIHRyYW5zbGF0aW5nIG1vdXNlIGV2ZW50c1xuXHRcdFx0XHRjaGFydC5yZW5kZXJlci5jcmVhdGUoY2hhcnQsIGNvbnRhaW5lciwgY2hhcnRXaWR0aCwgY2hhcnRIZWlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWRkIGEgcmVmZXJlbmNlIHRvIHRoZSBjaGFydHMgaW5kZXhcblx0XHRcdGNoYXJ0LnJlbmRlcmVyLmNoYXJ0SW5kZXggPSBjaGFydC5pbmRleDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsY3VsYXRlIG1hcmdpbnMgYnkgcmVuZGVyaW5nIGF4aXMgbGFiZWxzIGluIGEgcHJlbGltaW5hcnkgcG9zaXRpb24uIFRpdGxlLFxuXHRcdCAqIHN1YnRpdGxlIGFuZCBsZWdlbmQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVuZGVyZWQgYXQgdGhpcyBzdGFnZSwgYnV0IHdpbGwgYmVcblx0XHQgKiBtb3ZlZCBpbnRvIHRoZWlyIGZpbmFsIHBvc2l0aW9uc1xuXHRcdCAqL1xuXHRcdGdldE1hcmdpbnM6IGZ1bmN0aW9uIChza2lwQXhlcykge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0c3BhY2luZyA9IGNoYXJ0LnNwYWNpbmcsXG5cdFx0XHRcdG1hcmdpbiA9IGNoYXJ0Lm1hcmdpbixcblx0XHRcdFx0dGl0bGVPZmZzZXQgPSBjaGFydC50aXRsZU9mZnNldDtcblxuXHRcdFx0Y2hhcnQucmVzZXRNYXJnaW5zKCk7XG5cblx0XHRcdC8vIEFkanVzdCBmb3IgdGl0bGUgYW5kIHN1YnRpdGxlXG5cdFx0XHRpZiAodGl0bGVPZmZzZXQgJiYgIWRlZmluZWQobWFyZ2luWzBdKSkge1xuXHRcdFx0XHRjaGFydC5wbG90VG9wID0gbWF0aE1heChjaGFydC5wbG90VG9wLCB0aXRsZU9mZnNldCArIGNoYXJ0Lm9wdGlvbnMudGl0bGUubWFyZ2luICsgc3BhY2luZ1swXSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIEFkanVzdCBmb3IgbGVnZW5kXG5cdFx0XHRjaGFydC5sZWdlbmQuYWRqdXN0TWFyZ2lucyhtYXJnaW4sIHNwYWNpbmcpO1xuXG5cdFx0XHQvLyBhZGp1c3QgZm9yIHNjcm9sbGVyXG5cdFx0XHRpZiAoY2hhcnQuZXh0cmFCb3R0b21NYXJnaW4pIHtcblx0XHRcdFx0Y2hhcnQubWFyZ2luQm90dG9tICs9IGNoYXJ0LmV4dHJhQm90dG9tTWFyZ2luO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNoYXJ0LmV4dHJhVG9wTWFyZ2luKSB7XG5cdFx0XHRcdGNoYXJ0LnBsb3RUb3AgKz0gY2hhcnQuZXh0cmFUb3BNYXJnaW47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXNraXBBeGVzKSB7XG5cdFx0XHRcdHRoaXMuZ2V0QXhpc01hcmdpbnMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0QXhpc01hcmdpbnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0YXhpc09mZnNldCA9IGNoYXJ0LmF4aXNPZmZzZXQgPSBbMCwgMCwgMCwgMF0sIC8vIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuXHRcdFx0XHRtYXJnaW4gPSBjaGFydC5tYXJnaW47XG5cdFx0XHRcblx0XHRcdC8vIHByZS1yZW5kZXIgYXhlcyB0byBnZXQgbGFiZWxzIG9mZnNldCB3aWR0aFxuXHRcdFx0aWYgKGNoYXJ0Lmhhc0NhcnRlc2lhblNlcmllcykge1xuXHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0YXhpcy5nZXRPZmZzZXQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0aGUgYXhpcyBvZmZzZXRzXG5cdFx0XHRlYWNoKG1hcmdpbk5hbWVzLCBmdW5jdGlvbiAobSwgc2lkZSkge1xuXHRcdFx0XHRpZiAoIWRlZmluZWQobWFyZ2luW3NpZGVdKSkge1xuXHRcdFx0XHRcdGNoYXJ0W21dICs9IGF4aXNPZmZzZXRbc2lkZV07XG5cdFx0XHRcdH1cdFx0XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2hhcnQuc2V0Q2hhcnRTaXplKCk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVzaXplIHRoZSBjaGFydCB0byBpdHMgY29udGFpbmVyIGlmIHNpemUgaXMgbm90IGV4cGxpY2l0bHkgc2V0XG5cdFx0ICovXG5cdFx0cmVmbG93OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0cmVuZGVyVG8gPSBjaGFydC5yZW5kZXJUbyxcblx0XHRcdFx0d2lkdGggPSBvcHRpb25zQ2hhcnQud2lkdGggfHwgYWRhcHRlclJ1bihyZW5kZXJUbywgJ3dpZHRoJyksXG5cdFx0XHRcdGhlaWdodCA9IG9wdGlvbnNDaGFydC5oZWlnaHQgfHwgYWRhcHRlclJ1bihyZW5kZXJUbywgJ2hlaWdodCcpLFxuXHRcdFx0XHR0YXJnZXQgPSBlID8gZS50YXJnZXQgOiB3aW4sIC8vICM4MDUgLSBNb29Ub29scyBkb2Vzbid0IHN1cHBseSBlXG5cdFx0XHRcdGRvUmVmbG93ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChjaGFydC5jb250YWluZXIpIHsgLy8gSXQgbWF5IGhhdmUgYmVlbiBkZXN0cm95ZWQgaW4gdGhlIG1lYW50aW1lICgjMTI1Nylcblx0XHRcdFx0XHRcdGNoYXJ0LnNldFNpemUod2lkdGgsIGhlaWdodCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0Y2hhcnQuaGFzVXNlclNpemUgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IGNoZWNrcyBmb3IgZGlzcGxheTpub25lLiBUYXJnZXQgaXMgZG9jIGluIElFOCBhbmQgT3BlcmEsXG5cdFx0XHQvLyB3aW4gaW4gRmlyZWZveCwgQ2hyb21lIGFuZCBJRTkuXG5cdFx0XHRpZiAoIWNoYXJ0Lmhhc1VzZXJTaXplICYmICFjaGFydC5pc1ByaW50aW5nICYmIHdpZHRoICYmIGhlaWdodCAmJiAodGFyZ2V0ID09PSB3aW4gfHwgdGFyZ2V0ID09PSBkb2MpKSB7IC8vICMxMDkzXG5cdFx0XHRcdGlmICh3aWR0aCAhPT0gY2hhcnQuY29udGFpbmVyV2lkdGggfHwgaGVpZ2h0ICE9PSBjaGFydC5jb250YWluZXJIZWlnaHQpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoY2hhcnQucmVmbG93VGltZW91dCk7XG5cdFx0XHRcdFx0aWYgKGUpIHsgLy8gQ2FsbGVkIGZyb20gd2luZG93LnJlc2l6ZVxuXHRcdFx0XHRcdFx0Y2hhcnQucmVmbG93VGltZW91dCA9IHNldFRpbWVvdXQoZG9SZWZsb3csIDEwMCk7XG5cdFx0XHRcdFx0fSBlbHNlIHsgLy8gQ2FsbGVkIGRpcmVjdGx5ICgjMjIyNClcblx0XHRcdFx0XHRcdGRvUmVmbG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNoYXJ0LmNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG5cdFx0XHRcdGNoYXJ0LmNvbnRhaW5lckhlaWdodCA9IGhlaWdodDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkIHRoZSBldmVudCBoYW5kbGVycyBuZWNlc3NhcnkgZm9yIGF1dG8gcmVzaXppbmdcblx0XHQgKi9cblx0XHRpbml0UmVmbG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRyZWZsb3cgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGNoYXJ0LnJlZmxvdyhlKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcblx0XHRcdGFkZEV2ZW50KHdpbiwgJ3Jlc2l6ZScsIHJlZmxvdyk7XG5cdFx0XHRhZGRFdmVudChjaGFydCwgJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJlbW92ZUV2ZW50KHdpbiwgJ3Jlc2l6ZScsIHJlZmxvdyk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVzaXplIHRoZSBjaGFydCB0byBhIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R8Qm9vbGVhbn0gYW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0c2V0U2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGFuaW1hdGlvbikge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0Y2hhcnRXaWR0aCxcblx0XHRcdFx0Y2hhcnRIZWlnaHQsXG5cdFx0XHRcdGZpcmVFbmRSZXNpemU7XG5cblx0XHRcdC8vIEhhbmRsZSB0aGUgaXNSZXNpemluZyBjb3VudGVyXG5cdFx0XHRjaGFydC5pc1Jlc2l6aW5nICs9IDE7XG5cdFx0XHRmaXJlRW5kUmVzaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoY2hhcnQpIHtcblx0XHRcdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdlbmRSZXNpemUnLCBudWxsLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRjaGFydC5pc1Jlc2l6aW5nIC09IDE7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIHNldCB0aGUgYW5pbWF0aW9uIGZvciB0aGUgY3VycmVudCBwcm9jZXNzXG5cdFx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cblx0XHRcdGNoYXJ0Lm9sZENoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQ7XG5cdFx0XHRjaGFydC5vbGRDaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aDtcblx0XHRcdGlmIChkZWZpbmVkKHdpZHRoKSkge1xuXHRcdFx0XHRjaGFydC5jaGFydFdpZHRoID0gY2hhcnRXaWR0aCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKHdpZHRoKSk7XG5cdFx0XHRcdGNoYXJ0Lmhhc1VzZXJTaXplID0gISFjaGFydFdpZHRoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlZmluZWQoaGVpZ2h0KSkge1xuXHRcdFx0XHRjaGFydC5jaGFydEhlaWdodCA9IGNoYXJ0SGVpZ2h0ID0gbWF0aE1heCgwLCBtYXRoUm91bmQoaGVpZ2h0KSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2l6ZSB0aGUgY29udGFpbmVyIHdpdGggdGhlIGdsb2JhbCBhbmltYXRpb24gYXBwbGllZCBpZiBlbmFibGVkICgjMjUwMylcblx0XHRcdChnbG9iYWxBbmltYXRpb24gPyBhbmltYXRlIDogY3NzKShjaGFydC5jb250YWluZXIsIHtcblx0XHRcdFx0d2lkdGg6IGNoYXJ0V2lkdGggKyBQWCxcblx0XHRcdFx0aGVpZ2h0OiBjaGFydEhlaWdodCArIFBYXG5cdFx0XHR9LCBnbG9iYWxBbmltYXRpb24pO1xuXG5cdFx0XHRjaGFydC5zZXRDaGFydFNpemUodHJ1ZSk7XG5cdFx0XHRjaGFydC5yZW5kZXJlci5zZXRTaXplKGNoYXJ0V2lkdGgsIGNoYXJ0SGVpZ2h0LCBhbmltYXRpb24pO1xuXG5cdFx0XHQvLyBoYW5kbGUgYXhlc1xuXHRcdFx0Y2hhcnQubWF4VGlja3MgPSBudWxsO1xuXHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRheGlzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0XHRheGlzLnNldFNjYWxlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gbWFrZSBzdXJlIG5vbi1jYXJ0ZXNpYW4gc2VyaWVzIGFyZSBhbHNvIGhhbmRsZWRcblx0XHRcdGVhY2goY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWUpIHtcblx0XHRcdFx0c2VyaWUuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2hhcnQuaXNEaXJ0eUxlZ2VuZCA9IHRydWU7IC8vIGZvcmNlIGxlZ2VuZCByZWRyYXdcblx0XHRcdGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlOyAvLyBmb3JjZSByZWRyYXcgb2YgcGxvdCBhbmQgY2hhcnQgYm9yZGVyXG5cblx0XHRcdGNoYXJ0LmxheU91dFRpdGxlcygpOyAvLyAjMjg1N1xuXHRcdFx0Y2hhcnQuZ2V0TWFyZ2lucygpO1xuXG5cdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblxuXG5cdFx0XHRjaGFydC5vbGRDaGFydEhlaWdodCA9IG51bGw7XG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdyZXNpemUnKTtcblxuXHRcdFx0Ly8gZmlyZSBlbmRSZXNpemUgYW5kIHNldCBpc1Jlc2l6aW5nIGJhY2tcblx0XHRcdC8vIElmIGFuaW1hdGlvbiBpcyBkaXNhYmxlZCwgZmlyZSB3aXRob3V0IGRlbGF5XG5cdFx0XHRpZiAoZ2xvYmFsQW5pbWF0aW9uID09PSBmYWxzZSkge1xuXHRcdFx0XHRmaXJlRW5kUmVzaXplKCk7XG5cdFx0XHR9IGVsc2UgeyAvLyBlbHNlIHNldCBhIHRpbWVvdXQgd2l0aCB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uXG5cdFx0XHRcdHNldFRpbWVvdXQoZmlyZUVuZFJlc2l6ZSwgKGdsb2JhbEFuaW1hdGlvbiAmJiBnbG9iYWxBbmltYXRpb24uZHVyYXRpb24pIHx8IDUwMCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgcHVibGljIGNoYXJ0IHByb3BlcnRpZXMuIFRoaXMgaXMgZG9uZSBiZWZvcmUgYW5kIGFmdGVyIHRoZSBwcmUtcmVuZGVyXG5cdFx0ICogdG8gZGV0ZXJtaW5lIG1hcmdpbiBzaXplc1xuXHRcdCAqL1xuXHRcdHNldENoYXJ0U2l6ZTogZnVuY3Rpb24gKHNraXBBeGVzKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRjaGFydFdpZHRoID0gY2hhcnQuY2hhcnRXaWR0aCxcblx0XHRcdFx0Y2hhcnRIZWlnaHQgPSBjaGFydC5jaGFydEhlaWdodCxcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0c3BhY2luZyA9IGNoYXJ0LnNwYWNpbmcsXG5cdFx0XHRcdGNsaXBPZmZzZXQgPSBjaGFydC5jbGlwT2Zmc2V0LFxuXHRcdFx0XHRjbGlwWCxcblx0XHRcdFx0Y2xpcFksXG5cdFx0XHRcdHBsb3RMZWZ0LFxuXHRcdFx0XHRwbG90VG9wLFxuXHRcdFx0XHRwbG90V2lkdGgsXG5cdFx0XHRcdHBsb3RIZWlnaHQsXG5cdFx0XHRcdHBsb3RCb3JkZXJXaWR0aDtcblxuXHRcdFx0Y2hhcnQucGxvdExlZnQgPSBwbG90TGVmdCA9IG1hdGhSb3VuZChjaGFydC5wbG90TGVmdCk7XG5cdFx0XHRjaGFydC5wbG90VG9wID0gcGxvdFRvcCA9IG1hdGhSb3VuZChjaGFydC5wbG90VG9wKTtcblx0XHRcdGNoYXJ0LnBsb3RXaWR0aCA9IHBsb3RXaWR0aCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKGNoYXJ0V2lkdGggLSBwbG90TGVmdCAtIGNoYXJ0Lm1hcmdpblJpZ2h0KSk7XG5cdFx0XHRjaGFydC5wbG90SGVpZ2h0ID0gcGxvdEhlaWdodCA9IG1hdGhNYXgoMCwgbWF0aFJvdW5kKGNoYXJ0SGVpZ2h0IC0gcGxvdFRvcCAtIGNoYXJ0Lm1hcmdpbkJvdHRvbSkpO1xuXG5cdFx0XHRjaGFydC5wbG90U2l6ZVggPSBpbnZlcnRlZCA/IHBsb3RIZWlnaHQgOiBwbG90V2lkdGg7XG5cdFx0XHRjaGFydC5wbG90U2l6ZVkgPSBpbnZlcnRlZCA/IHBsb3RXaWR0aCA6IHBsb3RIZWlnaHQ7XG5cdFx0XHRcblx0XHRcdGNoYXJ0LnBsb3RCb3JkZXJXaWR0aCA9IG9wdGlvbnNDaGFydC5wbG90Qm9yZGVyV2lkdGggfHwgMDtcblxuXHRcdFx0Ly8gU2V0IGJveGVzIHVzZWQgZm9yIGFsaWdubWVudFxuXHRcdFx0Y2hhcnQuc3BhY2luZ0JveCA9IHJlbmRlcmVyLnNwYWNpbmdCb3ggPSB7XG5cdFx0XHRcdHg6IHNwYWNpbmdbM10sXG5cdFx0XHRcdHk6IHNwYWNpbmdbMF0sXG5cdFx0XHRcdHdpZHRoOiBjaGFydFdpZHRoIC0gc3BhY2luZ1szXSAtIHNwYWNpbmdbMV0sXG5cdFx0XHRcdGhlaWdodDogY2hhcnRIZWlnaHQgLSBzcGFjaW5nWzBdIC0gc3BhY2luZ1syXVxuXHRcdFx0fTtcblx0XHRcdGNoYXJ0LnBsb3RCb3ggPSByZW5kZXJlci5wbG90Qm94ID0ge1xuXHRcdFx0XHR4OiBwbG90TGVmdCxcblx0XHRcdFx0eTogcGxvdFRvcCxcblx0XHRcdFx0d2lkdGg6IHBsb3RXaWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBwbG90SGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0XHRwbG90Qm9yZGVyV2lkdGggPSAyICogbWF0aEZsb29yKGNoYXJ0LnBsb3RCb3JkZXJXaWR0aCAvIDIpO1xuXHRcdFx0Y2xpcFggPSBtYXRoQ2VpbChtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFszXSkgLyAyKTtcblx0XHRcdGNsaXBZID0gbWF0aENlaWwobWF0aE1heChwbG90Qm9yZGVyV2lkdGgsIGNsaXBPZmZzZXRbMF0pIC8gMik7XG5cdFx0XHRjaGFydC5jbGlwQm94ID0ge1xuXHRcdFx0XHR4OiBjbGlwWCwgXG5cdFx0XHRcdHk6IGNsaXBZLCBcblx0XHRcdFx0d2lkdGg6IG1hdGhGbG9vcihjaGFydC5wbG90U2l6ZVggLSBtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFsxXSkgLyAyIC0gY2xpcFgpLCBcblx0XHRcdFx0aGVpZ2h0OiBtYXRoTWF4KDAsIG1hdGhGbG9vcihjaGFydC5wbG90U2l6ZVkgLSBtYXRoTWF4KHBsb3RCb3JkZXJXaWR0aCwgY2xpcE9mZnNldFsyXSkgLyAyIC0gY2xpcFkpKVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCFza2lwQXhlcykge1xuXHRcdFx0XHRlYWNoKGNoYXJ0LmF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdFx0YXhpcy5zZXRBeGlzU2l6ZSgpO1xuXHRcdFx0XHRcdGF4aXMuc2V0QXhpc1RyYW5zbGF0aW9uKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsIG1hcmdpbnMgYmVmb3JlIGF1dG8gc2l6ZSBtYXJnaW5zIGFyZSBhcHBsaWVkXG5cdFx0ICovXG5cdFx0cmVzZXRNYXJnaW5zOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzO1xuXG5cdFx0XHRlYWNoKG1hcmdpbk5hbWVzLCBmdW5jdGlvbiAobSwgc2lkZSkge1xuXHRcdFx0XHRjaGFydFttXSA9IHBpY2soY2hhcnQubWFyZ2luW3NpZGVdLCBjaGFydC5zcGFjaW5nW3NpZGVdKTtcblx0XHRcdH0pO1xuXHRcdFx0Y2hhcnQuYXhpc09mZnNldCA9IFswLCAwLCAwLCAwXTsgLy8gdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XG5cdFx0XHRjaGFydC5jbGlwT2Zmc2V0ID0gWzAsIDAsIDAsIDBdO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSBib3JkZXJzIGFuZCBiYWNrZ3JvdW5kcyBmb3IgY2hhcnQgYW5kIHBsb3QgYXJlYVxuXHRcdCAqL1xuXHRcdGRyYXdDaGFydEJveDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0Y2hhcnRXaWR0aCA9IGNoYXJ0LmNoYXJ0V2lkdGgsXG5cdFx0XHRcdGNoYXJ0SGVpZ2h0ID0gY2hhcnQuY2hhcnRIZWlnaHQsXG5cdFx0XHRcdGNoYXJ0QmFja2dyb3VuZCA9IGNoYXJ0LmNoYXJ0QmFja2dyb3VuZCxcblx0XHRcdFx0cGxvdEJhY2tncm91bmQgPSBjaGFydC5wbG90QmFja2dyb3VuZCxcblx0XHRcdFx0cGxvdEJvcmRlciA9IGNoYXJ0LnBsb3RCb3JkZXIsXG5cdFx0XHRcdHBsb3RCR0ltYWdlID0gY2hhcnQucGxvdEJHSW1hZ2UsXG5cdFx0XHRcdGNoYXJ0Qm9yZGVyV2lkdGggPSBvcHRpb25zQ2hhcnQuYm9yZGVyV2lkdGggfHwgMCxcblx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zQ2hhcnQuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRwbG90QmFja2dyb3VuZENvbG9yID0gb3B0aW9uc0NoYXJ0LnBsb3RCYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdHBsb3RCYWNrZ3JvdW5kSW1hZ2UgPSBvcHRpb25zQ2hhcnQucGxvdEJhY2tncm91bmRJbWFnZSxcblx0XHRcdFx0cGxvdEJvcmRlcldpZHRoID0gb3B0aW9uc0NoYXJ0LnBsb3RCb3JkZXJXaWR0aCB8fCAwLFxuXHRcdFx0XHRtZ24sXG5cdFx0XHRcdGJnQXR0cixcblx0XHRcdFx0cGxvdExlZnQgPSBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0cGxvdFRvcCA9IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdHBsb3RXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aCxcblx0XHRcdFx0cGxvdEhlaWdodCA9IGNoYXJ0LnBsb3RIZWlnaHQsXG5cdFx0XHRcdHBsb3RCb3ggPSBjaGFydC5wbG90Qm94LFxuXHRcdFx0XHRjbGlwUmVjdCA9IGNoYXJ0LmNsaXBSZWN0LFxuXHRcdFx0XHRjbGlwQm94ID0gY2hhcnQuY2xpcEJveDtcblxuXHRcdFx0Ly8gQ2hhcnQgYXJlYVxuXHRcdFx0bWduID0gY2hhcnRCb3JkZXJXaWR0aCArIChvcHRpb25zQ2hhcnQuc2hhZG93ID8gOCA6IDApO1xuXG5cdFx0XHRpZiAoY2hhcnRCb3JkZXJXaWR0aCB8fCBjaGFydEJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0XHRpZiAoIWNoYXJ0QmFja2dyb3VuZCkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGJnQXR0ciA9IHtcblx0XHRcdFx0XHRcdGZpbGw6IGNoYXJ0QmFja2dyb3VuZENvbG9yIHx8IE5PTkVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmIChjaGFydEJvcmRlcldpZHRoKSB7IC8vICM5ODBcblx0XHRcdFx0XHRcdGJnQXR0ci5zdHJva2UgPSBvcHRpb25zQ2hhcnQuYm9yZGVyQ29sb3I7XG5cdFx0XHRcdFx0XHRiZ0F0dHJbJ3N0cm9rZS13aWR0aCddID0gY2hhcnRCb3JkZXJXaWR0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hhcnQuY2hhcnRCYWNrZ3JvdW5kID0gcmVuZGVyZXIucmVjdChtZ24gLyAyLCBtZ24gLyAyLCBjaGFydFdpZHRoIC0gbWduLCBjaGFydEhlaWdodCAtIG1nbixcblx0XHRcdFx0XHRcdFx0b3B0aW9uc0NoYXJ0LmJvcmRlclJhZGl1cywgY2hhcnRCb3JkZXJXaWR0aClcblx0XHRcdFx0XHRcdC5hdHRyKGJnQXR0cilcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyhQUkVGSVggKyAnYmFja2dyb3VuZCcpXG5cdFx0XHRcdFx0XHQuYWRkKClcblx0XHRcdFx0XHRcdC5zaGFkb3cob3B0aW9uc0NoYXJ0LnNoYWRvdyk7XG5cblx0XHRcdFx0fSBlbHNlIHsgLy8gcmVzaXplXG5cdFx0XHRcdFx0Y2hhcnRCYWNrZ3JvdW5kLmFuaW1hdGUoXG5cdFx0XHRcdFx0XHRjaGFydEJhY2tncm91bmQuY3Jpc3AoeyB3aWR0aDogY2hhcnRXaWR0aCAtIG1nbiwgaGVpZ2h0OiBjaGFydEhlaWdodCAtIG1nbiB9KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBQbG90IGJhY2tncm91bmRcblx0XHRcdGlmIChwbG90QmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRcdGlmICghcGxvdEJhY2tncm91bmQpIHtcblx0XHRcdFx0XHRjaGFydC5wbG90QmFja2dyb3VuZCA9IHJlbmRlcmVyLnJlY3QocGxvdExlZnQsIHBsb3RUb3AsIHBsb3RXaWR0aCwgcGxvdEhlaWdodCwgMClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0ZmlsbDogcGxvdEJhY2tncm91bmRDb2xvclxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQoKVxuXHRcdFx0XHRcdFx0LnNoYWRvdyhvcHRpb25zQ2hhcnQucGxvdFNoYWRvdyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGxvdEJhY2tncm91bmQuYW5pbWF0ZShwbG90Qm94KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBsb3RCYWNrZ3JvdW5kSW1hZ2UpIHtcblx0XHRcdFx0aWYgKCFwbG90QkdJbWFnZSkge1xuXHRcdFx0XHRcdGNoYXJ0LnBsb3RCR0ltYWdlID0gcmVuZGVyZXIuaW1hZ2UocGxvdEJhY2tncm91bmRJbWFnZSwgcGxvdExlZnQsIHBsb3RUb3AsIHBsb3RXaWR0aCwgcGxvdEhlaWdodClcblx0XHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbG90QkdJbWFnZS5hbmltYXRlKHBsb3RCb3gpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFBsb3QgY2xpcFxuXHRcdFx0aWYgKCFjbGlwUmVjdCkge1xuXHRcdFx0XHRjaGFydC5jbGlwUmVjdCA9IHJlbmRlcmVyLmNsaXBSZWN0KGNsaXBCb3gpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xpcFJlY3QuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0d2lkdGg6IGNsaXBCb3gud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBjbGlwQm94LmhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGxvdCBhcmVhIGJvcmRlclxuXHRcdFx0aWYgKHBsb3RCb3JkZXJXaWR0aCkge1xuXHRcdFx0XHRpZiAoIXBsb3RCb3JkZXIpIHtcblx0XHRcdFx0XHRjaGFydC5wbG90Qm9yZGVyID0gcmVuZGVyZXIucmVjdChwbG90TGVmdCwgcGxvdFRvcCwgcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCAwLCAtcGxvdEJvcmRlcldpZHRoKVxuXHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRzdHJva2U6IG9wdGlvbnNDaGFydC5wbG90Qm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBwbG90Qm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGZpbGw6IE5PTkUsXG5cdFx0XHRcdFx0XHRcdHpJbmRleDogMVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbG90Qm9yZGVyLmFuaW1hdGUoXG5cdFx0XHRcdFx0XHRwbG90Qm9yZGVyLmNyaXNwKHsgeDogcGxvdExlZnQsIHk6IHBsb3RUb3AsIHdpZHRoOiBwbG90V2lkdGgsIGhlaWdodDogcGxvdEhlaWdodCwgc3Ryb2tlV2lkdGg6IC1wbG90Qm9yZGVyV2lkdGggfSkgLy8jMzI4MiBwbG90Qm9yZGVyIHNob3VsZCBiZSBuZWdhdGl2ZVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzZXRcblx0XHRcdGNoYXJ0LmlzRGlydHlCb3ggPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZWN0IHdoZXRoZXIgYSBjZXJ0YWluIGNoYXJ0IHByb3BlcnR5IGlzIG5lZWRlZCBiYXNlZCBvbiBpbnNwZWN0aW5nIGl0cyBvcHRpb25zXG5cdFx0ICogYW5kIHNlcmllcy4gVGhpcyBtYWlubHkgYXBwbGllcyB0byB0aGUgY2hhcnQuaW52ZXJ0IHByb3BlcnR5LCBhbmQgaW4gZXh0ZW5zaW9ucyB0byBcblx0XHQgKiB0aGUgY2hhcnQuYW5ndWxhciBhbmQgY2hhcnQucG9sYXIgcHJvcGVydGllcy5cblx0XHQgKi9cblx0XHRwcm9wRnJvbVNlcmllczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0b3B0aW9uc0NoYXJ0ID0gY2hhcnQub3B0aW9ucy5jaGFydCxcblx0XHRcdFx0a2xhc3MsXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBjaGFydC5vcHRpb25zLnNlcmllcyxcblx0XHRcdFx0aSxcblx0XHRcdFx0dmFsdWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdGVhY2goWydpbnZlcnRlZCcsICdhbmd1bGFyJywgJ3BvbGFyJ10sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoZSBkZWZhdWx0IHNlcmllcyB0eXBlJ3MgY2xhc3Ncblx0XHRcdFx0a2xhc3MgPSBzZXJpZXNUeXBlc1tvcHRpb25zQ2hhcnQudHlwZSB8fCBvcHRpb25zQ2hhcnQuZGVmYXVsdFNlcmllc1R5cGVdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gR2V0IHRoZSB2YWx1ZSBmcm9tIGF2YWlsYWJsZSBjaGFydC13aWRlIHByb3BlcnRpZXNcblx0XHRcdFx0dmFsdWUgPSAoXG5cdFx0XHRcdFx0Y2hhcnRba2V5XSB8fCAvLyAxLiBpdCBpcyBzZXQgYmVmb3JlXG5cdFx0XHRcdFx0b3B0aW9uc0NoYXJ0W2tleV0gfHwgLy8gMi4gaXQgaXMgc2V0IGluIHRoZSBvcHRpb25zXG5cdFx0XHRcdFx0KGtsYXNzICYmIGtsYXNzLnByb3RvdHlwZVtrZXldKSAvLyAzLiBpdCdzIGRlZmF1bHQgc2VyaWVzIGNsYXNzIHJlcXVpcmVzIGl0XG5cdFx0XHRcdCk7XG5cdFx0XG5cdFx0XHRcdC8vIDQuIENoZWNrIGlmIGFueSB0aGUgY2hhcnQncyBzZXJpZXMgcmVxdWlyZSBpdFxuXHRcdFx0XHRpID0gc2VyaWVzT3B0aW9ucyAmJiBzZXJpZXNPcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCF2YWx1ZSAmJiBpLS0pIHtcblx0XHRcdFx0XHRrbGFzcyA9IHNlcmllc1R5cGVzW3Nlcmllc09wdGlvbnNbaV0udHlwZV07XG5cdFx0XHRcdFx0aWYgKGtsYXNzICYmIGtsYXNzLnByb3RvdHlwZVtrZXldKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XG5cdFx0XHRcdC8vIFNldCB0aGUgY2hhcnQgcHJvcGVydHlcblx0XHRcdFx0Y2hhcnRba2V5XSA9IHZhbHVlO1x0XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMaW5rIHR3byBvciBtb3JlIHNlcmllcyB0b2dldGhlci4gVGhpcyBpcyBkb25lIGluaXRpYWxseSBmcm9tIENoYXJ0LnJlbmRlcixcblx0XHQgKiBhbmQgYWZ0ZXIgQ2hhcnQuYWRkU2VyaWVzIGFuZCBTZXJpZXMucmVtb3ZlLlxuXHRcdCAqL1xuXHRcdGxpbmtTZXJpZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0U2VyaWVzID0gY2hhcnQuc2VyaWVzO1xuXG5cdFx0XHQvLyBSZXNldCBsaW5rc1xuXHRcdFx0ZWFjaChjaGFydFNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRzZXJpZXMubGlua2VkU2VyaWVzLmxlbmd0aCA9IDA7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgbmV3IGxpbmtzXG5cdFx0XHRlYWNoKGNoYXJ0U2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdFx0XHRcdHZhciBsaW5rZWRUbyA9IHNlcmllcy5vcHRpb25zLmxpbmtlZFRvO1xuXHRcdFx0XHRpZiAoaXNTdHJpbmcobGlua2VkVG8pKSB7XG5cdFx0XHRcdFx0aWYgKGxpbmtlZFRvID09PSAnOnByZXZpb3VzJykge1xuXHRcdFx0XHRcdFx0bGlua2VkVG8gPSBjaGFydC5zZXJpZXNbc2VyaWVzLmluZGV4IC0gMV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxpbmtlZFRvID0gY2hhcnQuZ2V0KGxpbmtlZFRvKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxpbmtlZFRvKSB7XG5cdFx0XHRcdFx0XHRsaW5rZWRUby5saW5rZWRTZXJpZXMucHVzaChzZXJpZXMpO1xuXHRcdFx0XHRcdFx0c2VyaWVzLmxpbmtlZFBhcmVudCA9IGxpbmtlZFRvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlciBzZXJpZXMgZm9yIHRoZSBjaGFydFxuXHRcdCAqL1xuXHRcdHJlbmRlclNlcmllczogZnVuY3Rpb24gKCkge1xuXHRcdFx0ZWFjaCh0aGlzLnNlcmllcywgZnVuY3Rpb24gKHNlcmllKSB7XG5cdFx0XHRcdHNlcmllLnRyYW5zbGF0ZSgpO1xuXHRcdFx0XHRzZXJpZS5yZW5kZXIoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0XHRcblx0XHQvKipcblx0XHQgKiBSZW5kZXIgbGFiZWxzIGZvciB0aGUgY2hhcnRcblx0XHQgKi9cblx0XHRyZW5kZXJMYWJlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGxhYmVscyA9IGNoYXJ0Lm9wdGlvbnMubGFiZWxzO1xuXHRcdFx0aWYgKGxhYmVscy5pdGVtcykge1xuXHRcdFx0XHRlYWNoKGxhYmVscy5pdGVtcywgZnVuY3Rpb24gKGxhYmVsKSB7XG5cdFx0XHRcdFx0dmFyIHN0eWxlID0gZXh0ZW5kKGxhYmVscy5zdHlsZSwgbGFiZWwuc3R5bGUpLFxuXHRcdFx0XHRcdFx0eCA9IHBJbnQoc3R5bGUubGVmdCkgKyBjaGFydC5wbG90TGVmdCxcblx0XHRcdFx0XHRcdHkgPSBwSW50KHN0eWxlLnRvcCkgKyBjaGFydC5wbG90VG9wICsgMTI7XG5cblx0XHRcdFx0XHQvLyBkZWxldGUgdG8gcHJldmVudCByZXdyaXRpbmcgaW4gSUVcblx0XHRcdFx0XHRkZWxldGUgc3R5bGUubGVmdDtcblx0XHRcdFx0XHRkZWxldGUgc3R5bGUudG9wO1xuXG5cdFx0XHRcdFx0Y2hhcnQucmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRcdGxhYmVsLmh0bWwsXG5cdFx0XHRcdFx0XHR4LFxuXHRcdFx0XHRcdFx0eVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogMiB9KVxuXHRcdFx0XHRcdC5jc3Moc3R5bGUpXG5cdFx0XHRcdFx0LmFkZCgpO1xuXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgYWxsIGdyYXBoaWNzIGZvciB0aGUgY2hhcnRcblx0XHQgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRvcHRpb25zID0gY2hhcnQub3B0aW9ucyxcblx0XHRcdFx0dGVtcFdpZHRoLFxuXHRcdFx0XHR0ZW1wSGVpZ2h0LFxuXHRcdFx0XHRyZWRvSG9yaXpvbnRhbCxcblx0XHRcdFx0cmVkb1ZlcnRpY2FsO1xuXG5cdFx0XHQvLyBUaXRsZVxuXHRcdFx0Y2hhcnQuc2V0VGl0bGUoKTtcblxuXG5cdFx0XHQvLyBMZWdlbmRcblx0XHRcdGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoY2hhcnQsIG9wdGlvbnMubGVnZW5kKTtcblxuXHRcdFx0Y2hhcnQuZ2V0U3RhY2tzKCk7IC8vIHJlbmRlciBzdGFja3NcblxuXHRcdFx0Ly8gR2V0IGNoYXJ0IG1hcmdpbnNcblx0XHRcdGNoYXJ0LmdldE1hcmdpbnModHJ1ZSk7XG5cdFx0XHRjaGFydC5zZXRDaGFydFNpemUoKTtcblxuXHRcdFx0Ly8gUmVjb3JkIHByZWxpbWluYXJ5IGRpbWVuc2lvbnMgZm9yIGxhdGVyIGNvbXBhcmlzb25cblx0XHRcdHRlbXBXaWR0aCA9IGNoYXJ0LnBsb3RXaWR0aDtcblx0XHRcdHRlbXBIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCAtIDEzOyAvLyAxMyBpcyB0aGUgbW9zdCBjb21tb24gaGVpZ2h0IG9mIFggYXhpcyBsYWJlbHNcblxuXHRcdFx0Ly8gR2V0IG1hcmdpbnMgYnkgcHJlLXJlbmRlcmluZyBheGVzXG5cdFx0XHRlYWNoKGF4ZXMsIGZ1bmN0aW9uIChheGlzKSB7XG5cdFx0XHRcdGF4aXMuc2V0U2NhbGUoKTtcblx0XHRcdH0pO1xuXHRcdFx0Y2hhcnQuZ2V0QXhpc01hcmdpbnMoKTtcblxuXHRcdFx0Ly8gSWYgdGhlIHBsb3QgYXJlYSBzaXplIGhhcyBjaGFuZ2VkIHNpZ25pZmljYW50bHksIGNhbGN1bGF0ZSB0aWNrIHBvc2l0aW9ucyBhZ2FpblxuXHRcdFx0cmVkb0hvcml6b250YWwgPSB0ZW1wV2lkdGggLyBjaGFydC5wbG90V2lkdGggPiAxLjI7XG5cdFx0XHRyZWRvVmVydGljYWwgPSB0ZW1wSGVpZ2h0IC8gY2hhcnQucGxvdEhlaWdodCA+IDEuMTtcblxuXHRcdFx0aWYgKHJlZG9Ib3Jpem9udGFsIHx8IHJlZG9WZXJ0aWNhbCkge1xuXG5cdFx0XHRcdGNoYXJ0Lm1heFRpY2tzID0gbnVsbDsgLy8gcmVzZXQgZm9yIHNlY29uZCBwYXNzXG5cdFx0XHRcdGVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcblx0XHRcdFx0XHRpZiAoKGF4aXMuaG9yaXogJiYgcmVkb0hvcml6b250YWwpIHx8ICghYXhpcy5ob3JpeiAmJiByZWRvVmVydGljYWwpKSB7XG5cdFx0XHRcdFx0XHRheGlzLnNldFRpY2tJbnRlcnZhbCh0cnVlKTsgLy8gdXBkYXRlIHRvIHJlZmxlY3QgdGhlIG5ldyBtYXJnaW5zXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y2hhcnQuZ2V0TWFyZ2lucygpOyAvLyBzZWNvbmQgcGFzcyB0byBjaGVjayBmb3IgbmV3IGxhYmVsc1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEcmF3IHRoZSBib3JkZXJzIGFuZCBiYWNrZ3JvdW5kc1xuXHRcdFx0Y2hhcnQuZHJhd0NoYXJ0Qm94KCk7XHRcdFxuXG5cblx0XHRcdC8vIEF4ZXNcblx0XHRcdGlmIChjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMpIHtcblx0XHRcdFx0ZWFjaChheGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGF4aXMucmVuZGVyKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgc2VyaWVzXG5cdFx0XHRpZiAoIWNoYXJ0LnNlcmllc0dyb3VwKSB7XG5cdFx0XHRcdGNoYXJ0LnNlcmllc0dyb3VwID0gcmVuZGVyZXIuZygnc2VyaWVzLWdyb3VwJylcblx0XHRcdFx0XHQuYXR0cih7IHpJbmRleDogMyB9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdH1cblx0XHRcdGNoYXJ0LnJlbmRlclNlcmllcygpO1xuXG5cdFx0XHQvLyBMYWJlbHNcblx0XHRcdGNoYXJ0LnJlbmRlckxhYmVscygpO1xuXG5cdFx0XHQvLyBDcmVkaXRzXG5cdFx0XHRjaGFydC5zaG93Q3JlZGl0cyhvcHRpb25zLmNyZWRpdHMpO1xuXG5cdFx0XHQvLyBTZXQgZmxhZ1xuXHRcdFx0Y2hhcnQuaGFzUmVuZGVyZWQgPSB0cnVlO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNob3cgY2hhcnQgY3JlZGl0cyBiYXNlZCBvbiBjb25maWcgb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHNob3dDcmVkaXRzOiBmdW5jdGlvbiAoY3JlZGl0cykge1xuXHRcdFx0aWYgKGNyZWRpdHMuZW5hYmxlZCAmJiAhdGhpcy5jcmVkaXRzKSB7XG5cdFx0XHRcdHRoaXMuY3JlZGl0cyA9IHRoaXMucmVuZGVyZXIudGV4dChcblx0XHRcdFx0XHRjcmVkaXRzLnRleHQsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwXG5cdFx0XHRcdClcblx0XHRcdFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoY3JlZGl0cy5ocmVmKSB7XG5cdFx0XHRcdFx0XHRsb2NhdGlvbi5ocmVmID0gY3JlZGl0cy5ocmVmO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdGFsaWduOiBjcmVkaXRzLnBvc2l0aW9uLmFsaWduLFxuXHRcdFx0XHRcdHpJbmRleDogOFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY3NzKGNyZWRpdHMuc3R5bGUpXG5cdFx0XHRcdC5hZGQoKVxuXHRcdFx0XHQuYWxpZ24oY3JlZGl0cy5wb3NpdGlvbik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENsZWFuIHVwIG1lbW9yeSB1c2FnZVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGF4ZXMgPSBjaGFydC5heGVzLFxuXHRcdFx0XHRzZXJpZXMgPSBjaGFydC5zZXJpZXMsXG5cdFx0XHRcdGNvbnRhaW5lciA9IGNoYXJ0LmNvbnRhaW5lcixcblx0XHRcdFx0aSxcblx0XHRcdFx0cGFyZW50Tm9kZSA9IGNvbnRhaW5lciAmJiBjb250YWluZXIucGFyZW50Tm9kZTtcblx0XHRcdFx0XG5cdFx0XHQvLyBmaXJlIHRoZSBjaGFydC5kZXN0b3kgZXZlbnRcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2Rlc3Ryb3knKTtcblx0XHRcdFxuXHRcdFx0Ly8gRGVsZXRlIHRoZSBjaGFydCBmcm9tIGNoYXJ0cyBsb29rdXAgYXJyYXlcblx0XHRcdGNoYXJ0c1tjaGFydC5pbmRleF0gPSBVTkRFRklORUQ7XG5cdFx0XHRjaGFydENvdW50LS07XG5cdFx0XHRjaGFydC5yZW5kZXJUby5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaGlnaGNoYXJ0cy1jaGFydCcpO1xuXG5cdFx0XHQvLyByZW1vdmUgZXZlbnRzXG5cdFx0XHRyZW1vdmVFdmVudChjaGFydCk7XG5cblx0XHRcdC8vID09PT0gRGVzdHJveSBjb2xsZWN0aW9uczpcblx0XHRcdC8vIERlc3Ryb3kgYXhlc1xuXHRcdFx0aSA9IGF4ZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRheGVzW2ldID0gYXhlc1tpXS5kZXN0cm95KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlc3Ryb3kgZWFjaCBzZXJpZXNcblx0XHRcdGkgPSBzZXJpZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzZXJpZXNbaV0gPSBzZXJpZXNbaV0uZGVzdHJveSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyA9PT09IERlc3Ryb3kgY2hhcnQgcHJvcGVydGllczpcblx0XHRcdGVhY2goWyd0aXRsZScsICdzdWJ0aXRsZScsICdjaGFydEJhY2tncm91bmQnLCAncGxvdEJhY2tncm91bmQnLCAncGxvdEJHSW1hZ2UnLCBcblx0XHRcdFx0XHQncGxvdEJvcmRlcicsICdzZXJpZXNHcm91cCcsICdjbGlwUmVjdCcsICdjcmVkaXRzJywgJ3BvaW50ZXInLCAnc2Nyb2xsZXInLCBcblx0XHRcdFx0XHQncmFuZ2VTZWxlY3RvcicsICdsZWdlbmQnLCAncmVzZXRab29tQnV0dG9uJywgJ3Rvb2x0aXAnLCAncmVuZGVyZXInXSwgZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0dmFyIHByb3AgPSBjaGFydFtuYW1lXTtcblxuXHRcdFx0XHRpZiAocHJvcCAmJiBwcm9wLmRlc3Ryb3kpIHtcblx0XHRcdFx0XHRjaGFydFtuYW1lXSA9IHByb3AuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGNvbnRhaW5lciBhbmQgYWxsIFNWR1xuXHRcdFx0aWYgKGNvbnRhaW5lcikgeyAvLyBjYW4gYnJlYWsgaW4gSUUgd2hlbiBkZXN0cm95ZWQgYmVmb3JlIGZpbmlzaGVkIGxvYWRpbmdcblx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRyZW1vdmVFdmVudChjb250YWluZXIpO1xuXHRcdFx0XHRpZiAocGFyZW50Tm9kZSkge1xuXHRcdFx0XHRcdGRpc2NhcmRFbGVtZW50KGNvbnRhaW5lcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbGVhbiBpdCBhbGwgdXBcblx0XHRcdGZvciAoaSBpbiBjaGFydCkge1xuXHRcdFx0XHRkZWxldGUgY2hhcnRbaV07XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBWTUwgbmFtZXNwYWNlcyBjYW4ndCBiZSBhZGRlZCB1bnRpbCBhZnRlciBjb21wbGV0ZS4gTGlzdGVuaW5nXG5cdFx0ICogZm9yIFBlcmluaSdzIGRvU2Nyb2xsIGhhY2sgaXMgbm90IGVub3VnaC5cblx0XHQgKi9cblx0XHRpc1JlYWR5VG9SZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXM7XG5cblx0XHRcdC8vIE5vdGU6IGluIHNwaXRlIG9mIEpTTGludCdzIGNvbXBsYWludHMsIHdpbiA9PSB3aW4udG9wIGlzIHJlcXVpcmVkXG5cdFx0XHQvKmpzbGludCBlcWVxOiB0cnVlKi9cblx0XHRcdGlmICgoIWhhc1NWRyAmJiAod2luID09IHdpbi50b3AgJiYgZG9jLnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpKSB8fCAodXNlQ2FuVkcgJiYgIXdpbi5jYW52ZykpIHtcblx0XHRcdC8qanNsaW50IGVxZXE6IGZhbHNlKi9cblx0XHRcdFx0aWYgKHVzZUNhblZHKSB7XG5cdFx0XHRcdFx0Ly8gRGVsYXkgcmVuZGVyaW5nIHVudGlsIGNhbnZnIGxpYnJhcnkgaXMgZG93bmxvYWRlZCBhbmQgcmVhZHlcblx0XHRcdFx0XHRDYW5WR0NvbnRyb2xsZXIucHVzaChmdW5jdGlvbiAoKSB7IGNoYXJ0LmZpcnN0UmVuZGVyKCk7IH0sIGNoYXJ0Lm9wdGlvbnMuZ2xvYmFsLmNhbnZhc1Rvb2xzVVJMKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb2MuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGRvYy5kZXRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgY2hhcnQuZmlyc3RSZW5kZXIpO1xuXHRcdFx0XHRcdFx0aWYgKGRvYy5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG5cdFx0XHRcdFx0XHRcdGNoYXJ0LmZpcnN0UmVuZGVyKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFByZXBhcmUgZm9yIGZpcnN0IHJlbmRlcmluZyBhZnRlciBhbGwgZGF0YSBhcmUgbG9hZGVkXG5cdFx0ICovXG5cdFx0Zmlyc3RSZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0XHRjYWxsYmFjayA9IGNoYXJ0LmNhbGxiYWNrO1xuXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIHRoZSBjaGFydCBpcyByZWFkeSB0byByZW5kZXJcblx0XHRcdGlmICghY2hhcnQuaXNSZWFkeVRvUmVuZGVyKCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGNvbnRhaW5lclxuXHRcdFx0Y2hhcnQuZ2V0Q29udGFpbmVyKCk7XG5cblx0XHRcdC8vIFJ1biBhbiBlYXJseSBldmVudCBhZnRlciB0aGUgY29udGFpbmVyIGFuZCByZW5kZXJlciBhcmUgZXN0YWJsaXNoZWRcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ2luaXQnKTtcblxuXHRcdFx0XG5cdFx0XHRjaGFydC5yZXNldE1hcmdpbnMoKTtcblx0XHRcdGNoYXJ0LnNldENoYXJ0U2l6ZSgpO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGNvbW1vbiBjaGFydCBwcm9wZXJ0aWVzIChtYWlubHkgaW52ZXJ0KSBmcm9tIHRoZSBnaXZlbiBzZXJpZXNcblx0XHRcdGNoYXJ0LnByb3BGcm9tU2VyaWVzKCk7XG5cblx0XHRcdC8vIGdldCBheGVzXG5cdFx0XHRjaGFydC5nZXRBeGVzKCk7XG5cblx0XHRcdC8vIEluaXRpYWxpemUgdGhlIHNlcmllc1xuXHRcdFx0ZWFjaChvcHRpb25zLnNlcmllcyB8fCBbXSwgZnVuY3Rpb24gKHNlcmllT3B0aW9ucykge1xuXHRcdFx0XHRjaGFydC5pbml0U2VyaWVzKHNlcmllT3B0aW9ucyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y2hhcnQubGlua1NlcmllcygpO1xuXG5cdFx0XHQvLyBSdW4gYW4gZXZlbnQgYWZ0ZXIgYXhlcyBhbmQgc2VyaWVzIGFyZSBpbml0aWFsaXplZCwgYnV0IGJlZm9yZSByZW5kZXIuIEF0IHRoaXMgc3RhZ2UsXG5cdFx0XHQvLyB0aGUgc2VyaWVzIGRhdGEgaXMgaW5kZXhlZCBhbmQgY2FjaGVkIGluIHRoZSB4RGF0YSBhbmQgeURhdGEgYXJyYXlzLCBzbyB3ZSBjYW4gYWNjZXNzXG5cdFx0XHQvLyB0aG9zZSBiZWZvcmUgcmVuZGVyaW5nLiBVc2VkIGluIEhpZ2hzdG9jay4gXG5cdFx0XHRmaXJlRXZlbnQoY2hhcnQsICdiZWZvcmVSZW5kZXInKTsgXG5cblx0XHRcdC8vIGRlcGVuZHMgb24gaW52ZXJ0ZWQgYW5kIG9uIG1hcmdpbnMgYmVpbmcgc2V0XG5cdFx0XHRpZiAoSGlnaGNoYXJ0cy5Qb2ludGVyKSB7XG5cdFx0XHRcdGNoYXJ0LnBvaW50ZXIgPSBuZXcgUG9pbnRlcihjaGFydCwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnJlbmRlcigpO1xuXG5cdFx0XHQvLyBhZGQgY2FudmFzXG5cdFx0XHRjaGFydC5yZW5kZXJlci5kcmF3KCk7XG5cdFx0XHQvLyBydW4gY2FsbGJhY2tzXG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoY2hhcnQsIFtjaGFydF0pO1xuXHRcdFx0fVxuXHRcdFx0ZWFjaChjaGFydC5jYWxsYmFja3MsIGZ1bmN0aW9uIChmbikge1xuXHRcdFx0XHRpZiAoY2hhcnQuaW5kZXggIT09IFVOREVGSU5FRCkgeyAvLyBDaGFydCBkZXN0cm95ZWQgaW4gaXRzIG93biBjYWxsYmFjayAoIzM2MDApXG5cdFx0XHRcdFx0Zm4uYXBwbHkoY2hhcnQsIFtjaGFydF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gRmlyZSB0aGUgbG9hZCBldmVudFxuXHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnbG9hZCcpO1x0XHRcblx0XHRcdFxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJ0IHdhcyByZW5kZXJlZCBvdXRzaWRlIHRoZSB0b3AgY29udGFpbmVyLCBwdXQgaXQgYmFjayBpbiAoIzM2NzkpXG5cdFx0XHRjaGFydC5jbG9uZVJlbmRlclRvKHRydWUpO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCogQ3JlYXRlcyBhcnJheXMgZm9yIHNwYWNpbmcgYW5kIG1hcmdpbiBmcm9tIGdpdmVuIG9wdGlvbnMuXG5cdFx0Ki9cblx0XHRzcGxhc2hBcnJheTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIG9WYXIgPSBvcHRpb25zW3RhcmdldF0sXG5cdFx0XHRcdHRBcnJheSA9IGlzT2JqZWN0KG9WYXIpID8gb1ZhciA6IFtvVmFyLCBvVmFyLCBvVmFyLCBvVmFyXTtcblxuXHRcdFx0cmV0dXJuIFtwaWNrKG9wdGlvbnNbdGFyZ2V0ICsgJ1RvcCddLCB0QXJyYXlbMF0pLFxuXHRcdFx0XHRcdHBpY2sob3B0aW9uc1t0YXJnZXQgKyAnUmlnaHQnXSwgdEFycmF5WzFdKSxcblx0XHRcdFx0XHRwaWNrKG9wdGlvbnNbdGFyZ2V0ICsgJ0JvdHRvbSddLCB0QXJyYXlbMl0pLFxuXHRcdFx0XHRcdHBpY2sob3B0aW9uc1t0YXJnZXQgKyAnTGVmdCddLCB0QXJyYXlbM10pXTtcblx0XHR9XG5cdH07IC8vIGVuZCBDaGFydFxuXG5cdHZhciBDZW50ZXJlZFNlcmllc01peGluID0gSGlnaGNoYXJ0cy5DZW50ZXJlZFNlcmllc01peGluID0ge1xuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBwaWUgYmFzZWQgb24gdGhlIHNpemUgYW5kIGNlbnRlciBvcHRpb25zIHJlbGF0aXZlIHRvIHRoZSAgXG5cdFx0ICogcGxvdCBhcmVhLiBCb3Jyb3dlZCBieSB0aGUgcG9sYXIgYW5kIGdhdWdlIHNlcmllcyB0eXBlcy5cblx0XHQgKi9cblx0XHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0c2xpY2luZ1Jvb20gPSAyICogKG9wdGlvbnMuc2xpY2VkT2Zmc2V0IHx8IDApLFxuXHRcdFx0XHRoYW5kbGVTbGljaW5nUm9vbSxcblx0XHRcdFx0cGxvdFdpZHRoID0gY2hhcnQucGxvdFdpZHRoIC0gMiAqIHNsaWNpbmdSb29tLFxuXHRcdFx0XHRwbG90SGVpZ2h0ID0gY2hhcnQucGxvdEhlaWdodCAtIDIgKiBzbGljaW5nUm9vbSxcblx0XHRcdFx0Y2VudGVyT3B0aW9uID0gb3B0aW9ucy5jZW50ZXIsXG5cdFx0XHRcdHBvc2l0aW9ucyA9IFtwaWNrKGNlbnRlck9wdGlvblswXSwgJzUwJScpLCBwaWNrKGNlbnRlck9wdGlvblsxXSwgJzUwJScpLCBvcHRpb25zLnNpemUgfHwgJzEwMCUnLCBvcHRpb25zLmlubmVyU2l6ZSB8fCAwXSxcblx0XHRcdFx0c21hbGxlc3RTaXplID0gbWF0aE1pbihwbG90V2lkdGgsIHBsb3RIZWlnaHQpLFxuXHRcdFx0XHRpc1BlcmNlbnQsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHZhbHVlO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgNDsgKytpKSB7XG5cdFx0XHRcdHZhbHVlID0gcG9zaXRpb25zW2ldO1xuXHRcdFx0XHRpc1BlcmNlbnQgPSAvJSQvLnRlc3QodmFsdWUpO1xuXHRcdFx0XHRoYW5kbGVTbGljaW5nUm9vbSA9IGkgPCAyIHx8IChpID09PSAyICYmIGlzUGVyY2VudCk7XG5cdFx0XHRcdHBvc2l0aW9uc1tpXSA9IChpc1BlcmNlbnQgP1xuXHRcdFx0XHRcdC8vIGkgPT0gMDogY2VudGVyWCwgcmVsYXRpdmUgdG8gd2lkdGhcblx0XHRcdFx0XHQvLyBpID09IDE6IGNlbnRlclksIHJlbGF0aXZlIHRvIGhlaWdodFxuXHRcdFx0XHRcdC8vIGkgPT0gMjogc2l6ZSwgcmVsYXRpdmUgdG8gc21hbGxlc3RTaXplXG5cdFx0XHRcdFx0Ly8gaSA9PSAzOiBpbm5lclNpemUsIHJlbGF0aXZlIHRvIHNpemVcblx0XHRcdFx0XHRbcGxvdFdpZHRoLCBwbG90SGVpZ2h0LCBzbWFsbGVzdFNpemUsIHBvc2l0aW9uc1syXV1baV0gKlxuXHRcdFx0XHRcdFx0cEludCh2YWx1ZSkgLyAxMDAgOlxuXHRcdFx0XHRcdHBJbnQodmFsdWUpKSArIChoYW5kbGVTbGljaW5nUm9vbSA/IHNsaWNpbmdSb29tIDogMCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcG9zaXRpb25zO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIFBvaW50IG9iamVjdCBhbmQgcHJvdG90eXBlLiBJbmhlcml0YWJsZSBhbmQgdXNlZCBhcyBiYXNlIGZvciBQaWVQb2ludFxuXHQgKi9cblx0dmFyIFBvaW50ID0gZnVuY3Rpb24gKCkge307XG5cdFBvaW50LnByb3RvdHlwZSA9IHtcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIHBvaW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHNlcmllcyBUaGUgc2VyaWVzIG9iamVjdCBjb250YWluaW5nIHRoaXMgcG9pbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgZGF0YSBpbiBlaXRoZXIgbnVtYmVyLCBhcnJheSBvciBvYmplY3QgZm9ybWF0XG5cdFx0ICovXG5cdFx0aW5pdDogZnVuY3Rpb24gKHNlcmllcywgb3B0aW9ucywgeCkge1xuXG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRjb2xvcnM7XG5cdFx0XHRwb2ludC5zZXJpZXMgPSBzZXJpZXM7XG5cdFx0XHRwb2ludC5jb2xvciA9IHNlcmllcy5jb2xvcjsgLy8gIzM0NDVcblx0XHRcdHBvaW50LmFwcGx5T3B0aW9ucyhvcHRpb25zLCB4KTtcblx0XHRcdHBvaW50LnBvaW50QXR0ciA9IHt9O1xuXG5cdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuY29sb3JCeVBvaW50KSB7XG5cdFx0XHRcdGNvbG9ycyA9IHNlcmllcy5vcHRpb25zLmNvbG9ycyB8fCBzZXJpZXMuY2hhcnQub3B0aW9ucy5jb2xvcnM7XG5cdFx0XHRcdHBvaW50LmNvbG9yID0gcG9pbnQuY29sb3IgfHwgY29sb3JzW3Nlcmllcy5jb2xvckNvdW50ZXIrK107XG5cdFx0XHRcdC8vIGxvb3AgYmFjayB0byB6ZXJvXG5cdFx0XHRcdGlmIChzZXJpZXMuY29sb3JDb3VudGVyID09PSBjb2xvcnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0c2VyaWVzLmNvbG9yQ291bnRlciA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c2VyaWVzLmNoYXJ0LnBvaW50Q291bnQrKztcblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IHRoZSBvcHRpb25zIGNvbnRhaW5pbmcgdGhlIHggYW5kIHkgZGF0YSBhbmQgcG9zc2libGUgc29tZSBleHRyYSBwcm9wZXJ0aWVzLlxuXHRcdCAqIFRoaXMgaXMgY2FsbGVkIG9uIHBvaW50IGluaXQgb3IgZnJvbSBwb2ludC51cGRhdGUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHRcdGFwcGx5T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMsIHgpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0cG9pbnRWYWxLZXkgPSBzZXJpZXMub3B0aW9ucy5wb2ludFZhbEtleSB8fCBzZXJpZXMucG9pbnRWYWxLZXk7XG5cblx0XHRcdG9wdGlvbnMgPSBQb2ludC5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cblx0XHRcdC8vIGNvcHkgb3B0aW9ucyBkaXJlY3RseSB0byBwb2ludFxuXHRcdFx0ZXh0ZW5kKHBvaW50LCBvcHRpb25zKTtcblx0XHRcdHBvaW50Lm9wdGlvbnMgPSBwb2ludC5vcHRpb25zID8gZXh0ZW5kKHBvaW50Lm9wdGlvbnMsIG9wdGlvbnMpIDogb3B0aW9ucztcblxuXHRcdFx0Ly8gRm9yIGhpZ2hlciBkaW1lbnNpb24gc2VyaWVzIHR5cGVzLiBGb3IgaW5zdGFuY2UsIGZvciByYW5nZXMsIHBvaW50LnkgaXMgbWFwcGVkIHRvIHBvaW50Lmxvdy5cblx0XHRcdGlmIChwb2ludFZhbEtleSkge1xuXHRcdFx0XHRwb2ludC55ID0gcG9pbnRbcG9pbnRWYWxLZXldO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBubyB4IGlzIHNldCBieSBub3csIGdldCBhdXRvIGluY3JlbWVudGVkIHZhbHVlLiBBbGwgcG9pbnRzIG11c3QgaGF2ZSBhblxuXHRcdFx0Ly8geCB2YWx1ZSwgaG93ZXZlciB0aGUgeSB2YWx1ZSBjYW4gYmUgbnVsbCB0byBjcmVhdGUgYSBnYXAgaW4gdGhlIHNlcmllc1xuXHRcdFx0aWYgKHBvaW50LnggPT09IFVOREVGSU5FRCAmJiBzZXJpZXMpIHtcblx0XHRcdFx0cG9pbnQueCA9IHggPT09IFVOREVGSU5FRCA/IHNlcmllcy5hdXRvSW5jcmVtZW50KCkgOiB4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybSBudW1iZXIgb3IgYXJyYXkgY29uZmlncyBpbnRvIG9iamVjdHNcblx0XHQgKi9cblx0XHRvcHRpb25zVG9PYmplY3Q6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0XHR2YXIgcmV0ID0ge30sXG5cdFx0XHRcdHNlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdFx0XHRwb2ludEFycmF5TWFwID0gc2VyaWVzLnBvaW50QXJyYXlNYXAgfHwgWyd5J10sXG5cdFx0XHRcdHZhbHVlQ291bnQgPSBwb2ludEFycmF5TWFwLmxlbmd0aCxcblx0XHRcdFx0Zmlyc3RJdGVtVHlwZSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0W3BvaW50QXJyYXlNYXBbMF1dID0gb3B0aW9ucztcblxuXHRcdFx0fSBlbHNlIGlmIChpc0FycmF5KG9wdGlvbnMpKSB7XG5cdFx0XHRcdC8vIHdpdGggbGVhZGluZyB4IHZhbHVlXG5cdFx0XHRcdGlmIChvcHRpb25zLmxlbmd0aCA+IHZhbHVlQ291bnQpIHtcblx0XHRcdFx0XHRmaXJzdEl0ZW1UeXBlID0gdHlwZW9mIG9wdGlvbnNbMF07XG5cdFx0XHRcdFx0aWYgKGZpcnN0SXRlbVR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHRyZXQubmFtZSA9IG9wdGlvbnNbMF07XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChmaXJzdEl0ZW1UeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdFx0cmV0LnggPSBvcHRpb25zWzBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKGogPCB2YWx1ZUNvdW50KSB7XG5cdFx0XHRcdFx0cmV0W3BvaW50QXJyYXlNYXBbaisrXV0gPSBvcHRpb25zW2krK107XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHJldCA9IG9wdGlvbnM7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyB0aGUgZmFzdGVzdCB3YXkgdG8gZGV0ZWN0IGlmIHRoZXJlIGFyZSBpbmRpdmlkdWFsIHBvaW50IGRhdGFMYWJlbHMgdGhhdCBuZWVkXG5cdFx0XHRcdC8vIHRvIGJlIGNvbnNpZGVyZWQgaW4gZHJhd0RhdGFMYWJlbHMuIFRoZXNlIGNhbiBvbmx5IG9jY3VyIGluIG9iamVjdCBjb25maWdzLlxuXHRcdFx0XHRpZiAob3B0aW9ucy5kYXRhTGFiZWxzKSB7XG5cdFx0XHRcdFx0c2VyaWVzLl9oYXNQb2ludExhYmVscyA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTYW1lIGFwcHJvYWNoIGFzIGFib3ZlIGZvciBtYXJrZXJzXG5cdFx0XHRcdGlmIChvcHRpb25zLm1hcmtlcikge1xuXHRcdFx0XHRcdHNlcmllcy5faGFzUG9pbnRNYXJrZXJzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveSBhIHBvaW50IHRvIGNsZWFyIG1lbW9yeS4gSXRzIHJlZmVyZW5jZSBzdGlsbCBzdGF5cyBpbiBzZXJpZXMuZGF0YS5cblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzLFxuXHRcdFx0XHRwcm9wO1xuXG5cdFx0XHRjaGFydC5wb2ludENvdW50LS07XG5cblx0XHRcdGlmIChob3ZlclBvaW50cykge1xuXHRcdFx0XHRwb2ludC5zZXRTdGF0ZSgpO1xuXHRcdFx0XHRlcmFzZShob3ZlclBvaW50cywgcG9pbnQpO1xuXHRcdFx0XHRpZiAoIWhvdmVyUG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNoYXJ0LmhvdmVyUG9pbnRzID0gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHRpZiAocG9pbnQgPT09IGNoYXJ0LmhvdmVyUG9pbnQpIHtcblx0XHRcdFx0cG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgYWxsIGV2ZW50c1xuXHRcdFx0aWYgKHBvaW50LmdyYXBoaWMgfHwgcG9pbnQuZGF0YUxhYmVsKSB7IC8vIHJlbW92ZUV2ZW50IGFuZCBkZXN0cm95RWxlbWVudHMgYXJlIHBlcmZvcm1hbmNlIGV4cGVuc2l2ZVxuXHRcdFx0XHRyZW1vdmVFdmVudChwb2ludCk7XG5cdFx0XHRcdHBvaW50LmRlc3Ryb3lFbGVtZW50cygpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocG9pbnQubGVnZW5kSXRlbSkgeyAvLyBwaWVzIGhhdmUgbGVnZW5kIGl0ZW1zXG5cdFx0XHRcdGNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShwb2ludCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAocHJvcCBpbiBwb2ludCkge1xuXHRcdFx0XHRwb2ludFtwcm9wXSA9IG51bGw7XG5cdFx0XHR9XG5cblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXN0cm95IFNWRyBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHBvaW50XG5cdFx0ICovXG5cdFx0ZGVzdHJveUVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRwcm9wcyA9IFsnZ3JhcGhpYycsICdkYXRhTGFiZWwnLCAnZGF0YUxhYmVsVXBwZXInLCAnZ3JvdXAnLCAnY29ubmVjdG9yJywgJ3NoYWRvd0dyb3VwJ10sXG5cdFx0XHRcdHByb3AsXG5cdFx0XHRcdGkgPSA2O1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRwcm9wID0gcHJvcHNbaV07XG5cdFx0XHRcdGlmIChwb2ludFtwcm9wXSkge1xuXHRcdFx0XHRcdHBvaW50W3Byb3BdID0gcG9pbnRbcHJvcF0uZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiB0aGUgY29uZmlndXJhdGlvbiBoYXNoIG5lZWRlZCBmb3IgdGhlIGRhdGEgbGFiZWwgYW5kIHRvb2x0aXAgZm9ybWF0dGVyc1xuXHRcdCAqL1xuXHRcdGdldExhYmVsQ29uZmlnOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogcG9pbnQuY2F0ZWdvcnksXG5cdFx0XHRcdHk6IHBvaW50LnksXG5cdFx0XHRcdGtleTogcG9pbnQubmFtZSB8fCBwb2ludC5jYXRlZ29yeSxcblx0XHRcdFx0c2VyaWVzOiBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdHBvaW50OiBwb2ludCxcblx0XHRcdFx0cGVyY2VudGFnZTogcG9pbnQucGVyY2VudGFnZSxcblx0XHRcdFx0dG90YWw6IHBvaW50LnRvdGFsIHx8IHBvaW50LnN0YWNrVG90YWxcblx0XHRcdH07XG5cdFx0fSxcdFxuXG5cdFx0LyoqXG5cdFx0ICogRXh0ZW5kYWJsZSBtZXRob2QgZm9yIGZvcm1hdHRpbmcgZWFjaCBwb2ludCdzIHRvb2x0aXAgbGluZVxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyB0byBiZSBjb25jYXRlbmF0ZWQgaW4gdG8gdGhlIGNvbW1vbiB0b29sdGlwIHRleHRcblx0XHQgKi9cblx0XHR0b29sdGlwRm9ybWF0dGVyOiBmdW5jdGlvbiAocG9pbnRGb3JtYXQpIHtcblxuXHRcdFx0Ly8gSW5zZXJ0IG9wdGlvbnMgZm9yIHZhbHVlRGVjaW1hbHMsIHZhbHVlUHJlZml4LCBhbmQgdmFsdWVTdWZmaXhcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdFx0c2VyaWVzVG9vbHRpcE9wdGlvbnMgPSBzZXJpZXMudG9vbHRpcE9wdGlvbnMsXG5cdFx0XHRcdHZhbHVlRGVjaW1hbHMgPSBwaWNrKHNlcmllc1Rvb2x0aXBPcHRpb25zLnZhbHVlRGVjaW1hbHMsICcnKSxcblx0XHRcdFx0dmFsdWVQcmVmaXggPSBzZXJpZXNUb29sdGlwT3B0aW9ucy52YWx1ZVByZWZpeCB8fCAnJyxcblx0XHRcdFx0dmFsdWVTdWZmaXggPSBzZXJpZXNUb29sdGlwT3B0aW9ucy52YWx1ZVN1ZmZpeCB8fCAnJztcblxuXHRcdFx0Ly8gTG9vcCBvdmVyIHRoZSBwb2ludCBhcnJheSBtYXAgYW5kIHJlcGxhY2UgdW5mb3JtYXR0ZWQgdmFsdWVzIHdpdGggc3ByaW50ZiBmb3JtYXR0aW5nIG1hcmt1cFxuXHRcdFx0ZWFjaChzZXJpZXMucG9pbnRBcnJheU1hcCB8fCBbJ3knXSwgZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRrZXkgPSAne3BvaW50LicgKyBrZXk7IC8vIHdpdGhvdXQgdGhlIGNsb3NpbmcgYnJhY2tldFxuXHRcdFx0XHRpZiAodmFsdWVQcmVmaXggfHwgdmFsdWVTdWZmaXgpIHtcblx0XHRcdFx0XHRwb2ludEZvcm1hdCA9IHBvaW50Rm9ybWF0LnJlcGxhY2Uoa2V5ICsgJ30nLCB2YWx1ZVByZWZpeCArIGtleSArICd9JyArIHZhbHVlU3VmZml4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwb2ludEZvcm1hdCA9IHBvaW50Rm9ybWF0LnJlcGxhY2Uoa2V5ICsgJ30nLCBrZXkgKyAnOiwuJyArIHZhbHVlRGVjaW1hbHMgKyAnZn0nKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZm9ybWF0KHBvaW50Rm9ybWF0LCB7XG5cdFx0XHRcdHBvaW50OiB0aGlzLFxuXHRcdFx0XHRzZXJpZXM6IHRoaXMuc2VyaWVzXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRmlyZSBhbiBldmVudCBvbiB0aGUgUG9pbnQgb2JqZWN0LiBNdXN0IG5vdCBiZSByZW5hbWVkIHRvIGZpcmVFdmVudCwgYXMgdGhpc1xuXHRcdCAqIGNhdXNlcyBhIG5hbWUgY2xhc2ggaW4gTW9vVG9vbHNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50QXJncyBBZGRpdGlvbmFsIGV2ZW50IGFyZ3VtZW50c1xuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRlZmF1bHRGdW5jdGlvbiBEZWZhdWx0IGV2ZW50IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmaXJlUG9pbnRFdmVudDogZnVuY3Rpb24gKGV2ZW50VHlwZSwgZXZlbnRBcmdzLCBkZWZhdWx0RnVuY3Rpb24pIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHNlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnM7XG5cblx0XHRcdC8vIGxvYWQgZXZlbnQgaGFuZGxlcnMgb24gZGVtYW5kIHRvIHNhdmUgdGltZSBvbiBtb3VzZW92ZXIvb3V0XG5cdFx0XHRpZiAoc2VyaWVzT3B0aW9ucy5wb2ludC5ldmVudHNbZXZlbnRUeXBlXSB8fCAocG9pbnQub3B0aW9ucyAmJiBwb2ludC5vcHRpb25zLmV2ZW50cyAmJiBwb2ludC5vcHRpb25zLmV2ZW50c1tldmVudFR5cGVdKSkge1xuXHRcdFx0XHR0aGlzLmltcG9ydEV2ZW50cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgZGVmYXVsdCBoYW5kbGVyIGlmIGluIHNlbGVjdGlvbiBtb2RlXG5cdFx0XHRpZiAoZXZlbnRUeXBlID09PSAnY2xpY2snICYmIHNlcmllc09wdGlvbnMuYWxsb3dQb2ludFNlbGVjdCkge1xuXHRcdFx0XHRkZWZhdWx0RnVuY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHQvLyBDb250cm9sIGtleSBpcyBmb3IgV2luZG93cywgbWV0YSAoPSBDbWQga2V5KSBmb3IgTWFjLCBTaGlmdCBmb3IgT3BlcmFcblx0XHRcdFx0XHRwb2ludC5zZWxlY3QobnVsbCwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyZUV2ZW50KHRoaXMsIGV2ZW50VHlwZSwgZXZlbnRBcmdzLCBkZWZhdWx0RnVuY3Rpb24pO1xuXHRcdH1cblx0fTsvKipcblx0ICogQGNsYXNzRGVzY3JpcHRpb24gVGhlIGJhc2UgZnVuY3Rpb24gd2hpY2ggYWxsIG90aGVyIHNlcmllcyB0eXBlcyBpbmhlcml0IGZyb20uIFRoZSBkYXRhIGluIHRoZSBzZXJpZXMgaXMgc3RvcmVkXG5cdCAqIGluIHZhcmlvdXMgYXJyYXlzLlxuXHQgKlxuXHQgKiAtIEZpcnN0LCBzZXJpZXMub3B0aW9ucy5kYXRhIGNvbnRhaW5zIGFsbCB0aGUgb3JpZ2luYWwgY29uZmlnIG9wdGlvbnMgZm9yXG5cdCAqIGVhY2ggcG9pbnQgd2hldGhlciBhZGRlZCBieSBvcHRpb25zIG9yIG1ldGhvZHMgbGlrZSBzZXJpZXMuYWRkUG9pbnQuXG5cdCAqIC0gTmV4dCwgc2VyaWVzLmRhdGEgY29udGFpbnMgdGhvc2UgdmFsdWVzIGNvbnZlcnRlZCB0byBwb2ludHMsIGJ1dCBpbiBjYXNlIHRoZSBzZXJpZXMgZGF0YSBsZW5ndGhcblx0ICogZXhjZWVkcyB0aGUgY3JvcFRocmVzaG9sZCwgb3IgaWYgdGhlIGRhdGEgaXMgZ3JvdXBlZCwgc2VyaWVzLmRhdGEgZG9lc24ndCBjb250YWluIGFsbCB0aGUgcG9pbnRzLiBJdFxuXHQgKiBvbmx5IGNvbnRhaW5zIHRoZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZCBvbiBkZW1hbmQuXG5cdCAqIC0gVGhlbiB0aGVyZSdzIHNlcmllcy5wb2ludHMgdGhhdCBjb250YWlucyBhbGwgY3VycmVudGx5IHZpc2libGUgcG9pbnQgb2JqZWN0cy4gSW4gY2FzZSBvZiBjcm9wcGluZyxcblx0ICogdGhlIGNyb3BwZWQtYXdheSBwb2ludHMgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgYXJyYXkuIFRoZSBzZXJpZXMucG9pbnRzIGFycmF5IHN0YXJ0cyBhdCBzZXJpZXMuY3JvcFN0YXJ0XG5cdCAqIGNvbXBhcmVkIHRvIHNlcmllcy5kYXRhIGFuZCBzZXJpZXMub3B0aW9ucy5kYXRhLiBJZiBob3dldmVyIHRoZSBzZXJpZXMgZGF0YSBpcyBncm91cGVkLCB0aGVzZSBjYW4ndFxuXHQgKiBiZSBjb3JyZWxhdGVkIG9uZSB0byBvbmUuXG5cdCAqIC0gc2VyaWVzLnhEYXRhIGFuZCBzZXJpZXMucHJvY2Vzc2VkWERhdGEgY29udGFpbiBjbGVhbiB4IHZhbHVlcywgZXF1aXZhbGVudCB0byBzZXJpZXMuZGF0YSBhbmQgc2VyaWVzLnBvaW50cy5cblx0ICogLSBzZXJpZXMueURhdGEgYW5kIHNlcmllcy5wcm9jZXNzZWRZRGF0YSBjb250YWluIGNsZWFuIHggdmFsdWVzLCBlcXVpdmFsZW50IHRvIHNlcmllcy5kYXRhIGFuZCBzZXJpZXMucG9pbnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY2hhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICovXG5cdHZhciBTZXJpZXMgPSBIaWdoY2hhcnRzLlNlcmllcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdFNlcmllcy5wcm90b3R5cGUgPSB7XG5cblx0XHRpc0NhcnRlc2lhbjogdHJ1ZSxcblx0XHR0eXBlOiAnbGluZScsXG5cdFx0cG9pbnRDbGFzczogUG9pbnQsXG5cdFx0c29ydGVkOiB0cnVlLCAvLyByZXF1aXJlcyB0aGUgZGF0YSB0byBiZSBzb3J0ZWRcblx0XHRyZXF1aXJlU29ydGluZzogdHJ1ZSxcblx0XHRwb2ludEF0dHJUb09wdGlvbnM6IHsgLy8gbWFwcGluZyBiZXR3ZWVuIFNWRyBhdHRyaWJ1dGVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBvcHRpb25zXG5cdFx0XHRzdHJva2U6ICdsaW5lQ29sb3InLFxuXHRcdFx0J3N0cm9rZS13aWR0aCc6ICdsaW5lV2lkdGgnLFxuXHRcdFx0ZmlsbDogJ2ZpbGxDb2xvcicsXG5cdFx0XHRyOiAncmFkaXVzJ1xuXHRcdH0sXG5cdFx0YXhpc1R5cGVzOiBbJ3hBeGlzJywgJ3lBeGlzJ10sXG5cdFx0Y29sb3JDb3VudGVyOiAwLFxuXHRcdHBhcmFsbGVsQXJyYXlzOiBbJ3gnLCAneSddLCAvLyBlYWNoIHBvaW50J3MgeCBhbmQgeSB2YWx1ZXMgYXJlIHN0b3JlZCBpbiB0aGlzLnhEYXRhIGFuZCB0aGlzLnlEYXRhXG5cdFx0aW5pdDogZnVuY3Rpb24gKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0ZXZlbnRUeXBlLFxuXHRcdFx0XHRldmVudHMsXG5cdFx0XHRcdGNoYXJ0U2VyaWVzID0gY2hhcnQuc2VyaWVzLFxuXHRcdFx0XHRzb3J0QnlJbmRleCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBpY2soYS5vcHRpb25zLmluZGV4LCBhLl9pKSAtIHBpY2soYi5vcHRpb25zLmluZGV4LCBiLl9pKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0c2VyaWVzLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0XHRzZXJpZXMub3B0aW9ucyA9IG9wdGlvbnMgPSBzZXJpZXMuc2V0T3B0aW9ucyhvcHRpb25zKTsgLy8gbWVyZ2Ugd2l0aCBwbG90T3B0aW9uc1xuXHRcdFx0c2VyaWVzLmxpbmtlZFNlcmllcyA9IFtdO1xuXG5cdFx0XHQvLyBiaW5kIHRoZSBheGVzXG5cdFx0XHRzZXJpZXMuYmluZEF4ZXMoKTtcblxuXHRcdFx0Ly8gc2V0IHNvbWUgdmFyaWFibGVzXG5cdFx0XHRleHRlbmQoc2VyaWVzLCB7XG5cdFx0XHRcdG5hbWU6IG9wdGlvbnMubmFtZSxcblx0XHRcdFx0c3RhdGU6IE5PUk1BTF9TVEFURSxcblx0XHRcdFx0cG9pbnRBdHRyOiB7fSxcblx0XHRcdFx0dmlzaWJsZTogb3B0aW9ucy52aXNpYmxlICE9PSBmYWxzZSwgLy8gdHJ1ZSBieSBkZWZhdWx0XG5cdFx0XHRcdHNlbGVjdGVkOiBvcHRpb25zLnNlbGVjdGVkID09PSB0cnVlIC8vIGZhbHNlIGJ5IGRlZmF1bHRcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBzcGVjaWFsXG5cdFx0XHRpZiAodXNlQ2FuVkcpIHtcblx0XHRcdFx0b3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG5cdFx0XHRldmVudHMgPSBvcHRpb25zLmV2ZW50cztcblx0XHRcdGZvciAoZXZlbnRUeXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHRhZGRFdmVudChzZXJpZXMsIGV2ZW50VHlwZSwgZXZlbnRzW2V2ZW50VHlwZV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHQoZXZlbnRzICYmIGV2ZW50cy5jbGljaykgfHxcblx0XHRcdFx0KG9wdGlvbnMucG9pbnQgJiYgb3B0aW9ucy5wb2ludC5ldmVudHMgJiYgb3B0aW9ucy5wb2ludC5ldmVudHMuY2xpY2spIHx8XG5cdFx0XHRcdG9wdGlvbnMuYWxsb3dQb2ludFNlbGVjdFxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoYXJ0LnJ1blRyYWNrZXJDbGljayA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy5nZXRDb2xvcigpO1xuXHRcdFx0c2VyaWVzLmdldFN5bWJvbCgpO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGFcblx0XHRcdGVhY2goc2VyaWVzLnBhcmFsbGVsQXJyYXlzLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdHNlcmllc1trZXkgKyAnRGF0YSddID0gW107XG5cdFx0XHR9KTtcblx0XHRcdHNlcmllcy5zZXREYXRhKG9wdGlvbnMuZGF0YSwgZmFsc2UpO1xuXG5cdFx0XHQvLyBNYXJrIGNhcnRlc2lhblxuXHRcdFx0aWYgKHNlcmllcy5pc0NhcnRlc2lhbikge1xuXHRcdFx0XHRjaGFydC5oYXNDYXJ0ZXNpYW5TZXJpZXMgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWdpc3RlciBpdCBpbiB0aGUgY2hhcnRcblx0XHRcdGNoYXJ0U2VyaWVzLnB1c2goc2VyaWVzKTtcblx0XHRcdHNlcmllcy5faSA9IGNoYXJ0U2VyaWVzLmxlbmd0aCAtIDE7XG5cblx0XHRcdC8vIFNvcnQgc2VyaWVzIGFjY29yZGluZyB0byBpbmRleCBvcHRpb24gKCMyNDgsICMxMTIzLCAjMjQ1Nilcblx0XHRcdHN0YWJsZVNvcnQoY2hhcnRTZXJpZXMsIHNvcnRCeUluZGV4KTtcblx0XHRcdGlmICh0aGlzLnlBeGlzKSB7XG5cdFx0XHRcdHN0YWJsZVNvcnQodGhpcy55QXhpcy5zZXJpZXMsIHNvcnRCeUluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0ZWFjaChjaGFydFNlcmllcywgZnVuY3Rpb24gKHNlcmllcywgaSkge1xuXHRcdFx0XHRzZXJpZXMuaW5kZXggPSBpO1xuXHRcdFx0XHRzZXJpZXMubmFtZSA9IHNlcmllcy5uYW1lIHx8ICdTZXJpZXMgJyArIChpICsgMSk7XG5cdFx0XHR9KTtcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHhBeGlzIGFuZCB5QXhpcyBwcm9wZXJ0aWVzIG9mIGNhcnRlc2lhbiBzZXJpZXMsIGFuZCByZWdpc3RlciB0aGUgc2VyaWVzXG5cdFx0ICogaW4gdGhlIGF4aXMuc2VyaWVzIGFycmF5XG5cdFx0ICovXG5cdFx0YmluZEF4ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRheGlzT3B0aW9ucztcblxuXHRcdFx0ZWFjaChzZXJpZXMuYXhpc1R5cGVzIHx8IFtdLCBmdW5jdGlvbiAoQVhJUykgeyAvLyByZXBlYXQgZm9yIHhBeGlzIGFuZCB5QXhpc1xuXG5cdFx0XHRcdGVhY2goY2hhcnRbQVhJU10sIGZ1bmN0aW9uIChheGlzKSB7IC8vIGxvb3AgdGhyb3VnaCB0aGUgY2hhcnQncyBheGlzIG9iamVjdHNcblx0XHRcdFx0XHRheGlzT3B0aW9ucyA9IGF4aXMub3B0aW9ucztcblxuXHRcdFx0XHRcdC8vIGFwcGx5IGlmIHRoZSBzZXJpZXMgeEF4aXMgb3IgeUF4aXMgb3B0aW9uIG1hdGhjaGVzIHRoZSBudW1iZXIgb2YgdGhlXG5cdFx0XHRcdFx0Ly8gYXhpcywgb3IgaWYgdW5kZWZpbmVkLCB1c2UgdGhlIGZpcnN0IGF4aXNcblx0XHRcdFx0XHRpZiAoKHNlcmllc09wdGlvbnNbQVhJU10gPT09IGF4aXNPcHRpb25zLmluZGV4KSB8fFxuXHRcdFx0XHRcdFx0XHQoc2VyaWVzT3B0aW9uc1tBWElTXSAhPT0gVU5ERUZJTkVEICYmIHNlcmllc09wdGlvbnNbQVhJU10gPT09IGF4aXNPcHRpb25zLmlkKSB8fFxuXHRcdFx0XHRcdFx0XHQoc2VyaWVzT3B0aW9uc1tBWElTXSA9PT0gVU5ERUZJTkVEICYmIGF4aXNPcHRpb25zLmluZGV4ID09PSAwKSkge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpc3RlciB0aGlzIHNlcmllcyBpbiB0aGUgYXhpcy5zZXJpZXMgbG9va3VwXG5cdFx0XHRcdFx0XHRheGlzLnNlcmllcy5wdXNoKHNlcmllcyk7XG5cblx0XHRcdFx0XHRcdC8vIHNldCB0aGlzIHNlcmllcy54QXhpcyBvciBzZXJpZXMueUF4aXMgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRzZXJpZXNbQVhJU10gPSBheGlzO1xuXG5cdFx0XHRcdFx0XHQvLyBtYXJrIGRpcnR5IGZvciByZWRyYXdcblx0XHRcdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBUaGUgc2VyaWVzIG5lZWRzIGFuIFggYW5kIGFuIFkgYXhpc1xuXHRcdFx0XHRpZiAoIXNlcmllc1tBWElTXSAmJiBzZXJpZXMub3B0aW9uYWxBeGlzICE9PSBBWElTKSB7XG5cdFx0XHRcdFx0ZXJyb3IoMTgsIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGb3Igc2ltcGxlIHNlcmllcyB0eXBlcyBsaWtlIGxpbmUgYW5kIGNvbHVtbiwgdGhlIGRhdGEgdmFsdWVzIGFyZSBoZWxkIGluIGFycmF5cyBsaWtlXG5cdFx0ICogeERhdGEgYW5kIHlEYXRhIGZvciBxdWljayBsb29rdXAgdG8gZmluZCBleHRyZW1lcyBhbmQgbW9yZS4gRm9yIG11bHRpZGltZW5zaW9uYWwgc2VyaWVzXG5cdFx0ICogbGlrZSBidWJibGUgYW5kIG1hcCwgdGhpcyBjYW4gYmUgZXh0ZW5kZWQgd2l0aCBhcnJheXMgbGlrZSB6RGF0YSBhbmQgdmFsdWVEYXRhIGJ5XG5cdFx0ICogYWRkaW5nIHRvIHRoZSBzZXJpZXMucGFyYWxsZWxBcnJheXMgYXJyYXkuXG5cdFx0ICovXG5cdFx0dXBkYXRlUGFyYWxsZWxBcnJheXM6IGZ1bmN0aW9uIChwb2ludCwgaSkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0Zm4gPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgP1xuXHRcdFx0XHRcdCAvLyBJbnNlcnQgdGhlIHZhbHVlIGluIHRoZSBnaXZlbiBwb3NpdGlvblxuXHRcdFx0XHRcdGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdHZhciB2YWwgPSBrZXkgPT09ICd5JyAmJiBzZXJpZXMudG9ZRGF0YSA/IHNlcmllcy50b1lEYXRhKHBvaW50KSA6IHBvaW50W2tleV07XG5cdFx0XHRcdFx0XHRzZXJpZXNba2V5ICsgJ0RhdGEnXVtpXSA9IHZhbDtcblx0XHRcdFx0XHR9IDpcblx0XHRcdFx0XHQvLyBBcHBseSB0aGUgbWV0aG9kIHNwZWNpZmllZCBpbiBpIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHMgYXMgYXJndW1lbnRzXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdFx0QXJyYXkucHJvdG90eXBlW2ldLmFwcGx5KHNlcmllc1trZXkgKyAnRGF0YSddLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAyKSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0ZWFjaChzZXJpZXMucGFyYWxsZWxBcnJheXMsIGZuKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGFuIGF1dG8gaW5jcmVtZW50ZWQgeCB2YWx1ZSBiYXNlZCBvbiB0aGUgcG9pbnRTdGFydCBhbmQgcG9pbnRJbnRlcnZhbCBvcHRpb25zLlxuXHRcdCAqIFRoaXMgaXMgb25seSB1c2VkIGlmIGFuIHggdmFsdWUgaXMgbm90IGdpdmVuIGZvciB0aGUgcG9pbnQgdGhhdCBjYWxscyBhdXRvSW5jcmVtZW50LlxuXHRcdCAqL1xuXHRcdGF1dG9JbmNyZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHhJbmNyZW1lbnQgPSB0aGlzLnhJbmNyZW1lbnQsXG5cdFx0XHRcdGRhdGUsXG5cdFx0XHRcdHBvaW50SW50ZXJ2YWwsXG5cdFx0XHRcdHBvaW50SW50ZXJ2YWxVbml0ID0gb3B0aW9ucy5wb2ludEludGVydmFsVW5pdDtcblx0XHRcdFxuXHRcdFx0eEluY3JlbWVudCA9IHBpY2soeEluY3JlbWVudCwgb3B0aW9ucy5wb2ludFN0YXJ0LCAwKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5wb2ludEludGVydmFsID0gcG9pbnRJbnRlcnZhbCA9IHBpY2sodGhpcy5wb2ludEludGVydmFsLCBvcHRpb25zLnBvaW50SW50ZXJ2YWwsIDEpO1xuXHRcdFx0XG5cdFx0XHQvLyBBZGRlZCBjb2RlIGZvciBwb2ludEludGVydmFsIHN0cmluZ3Ncblx0XHRcdGlmIChwb2ludEludGVydmFsVW5pdCA9PT0gJ21vbnRoJyB8fCBwb2ludEludGVydmFsVW5pdCA9PT0gJ3llYXInKSB7XG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSh4SW5jcmVtZW50KTtcblx0XHRcdFx0ZGF0ZSA9IChwb2ludEludGVydmFsVW5pdCA9PT0gJ21vbnRoJykgP1xuXHRcdFx0XHRcdCtkYXRlW3NldE1vbnRoXShkYXRlW2dldE1vbnRoXSgpICsgcG9pbnRJbnRlcnZhbCkgOlxuXHRcdFx0XHRcdCtkYXRlW3NldEZ1bGxZZWFyXShkYXRlW2dldEZ1bGxZZWFyXSgpICsgcG9pbnRJbnRlcnZhbCk7XG5cdFx0XHRcdHBvaW50SW50ZXJ2YWwgPSBkYXRlIC0geEluY3JlbWVudDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy54SW5jcmVtZW50ID0geEluY3JlbWVudCArIHBvaW50SW50ZXJ2YWw7XG5cdFx0XHRyZXR1cm4geEluY3JlbWVudDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGl2aWRlIHRoZSBzZXJpZXMgZGF0YSBpbnRvIHNlZ21lbnRzIGRpdmlkZWQgYnkgbnVsbCB2YWx1ZXMuXG5cdFx0ICovXG5cdFx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRsYXN0TnVsbCA9IC0xLFxuXHRcdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0XHRwb2ludHNMZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHRpZiAocG9pbnRzTGVuZ3RoKSB7IC8vIG5vIGFjdGlvbiByZXF1aXJlZCBmb3IgW11cblxuXHRcdFx0XHQvLyBpZiBjb25uZWN0IG51bGxzLCBqdXN0IHJlbW92ZSBudWxsIHBvaW50c1xuXHRcdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMuY29ubmVjdE51bGxzKSB7XG5cdFx0XHRcdFx0aSA9IHBvaW50c0xlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0XHRpZiAocG9pbnRzW2ldLnkgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0cG9pbnRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHNlZ21lbnRzID0gW3BvaW50c107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGVsc2UsIHNwbGl0IG9uIG51bGwgcG9pbnRzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWFjaChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCwgaSkge1xuXHRcdFx0XHRcdFx0aWYgKHBvaW50LnkgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGkgPiBsYXN0TnVsbCArIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKHBvaW50cy5zbGljZShsYXN0TnVsbCArIDEsIGkpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRsYXN0TnVsbCA9IGk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IHBvaW50c0xlbmd0aCAtIDEpIHsgLy8gbGFzdCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKHBvaW50cy5zbGljZShsYXN0TnVsbCArIDEsIGkgKyAxKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVnaXN0ZXIgaXRcblx0XHRcdHNlcmllcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHNlcmllcyBvcHRpb25zIGJ5IG1lcmdpbmcgZnJvbSB0aGUgb3B0aW9ucyB0cmVlXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1PcHRpb25zXG5cdFx0ICovXG5cdFx0c2V0T3B0aW9uczogZnVuY3Rpb24gKGl0ZW1PcHRpb25zKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRjaGFydE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0XHRwbG90T3B0aW9ucyA9IGNoYXJ0T3B0aW9ucy5wbG90T3B0aW9ucyxcblx0XHRcdFx0dXNlck9wdGlvbnMgPSBjaGFydC51c2VyT3B0aW9ucyB8fCB7fSxcblx0XHRcdFx0dXNlclBsb3RPcHRpb25zID0gdXNlck9wdGlvbnMucGxvdE9wdGlvbnMgfHwge30sXG5cdFx0XHRcdHR5cGVPcHRpb25zID0gcGxvdE9wdGlvbnNbdGhpcy50eXBlXSxcblx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0em9uZXM7XG5cblx0XHRcdHRoaXMudXNlck9wdGlvbnMgPSBpdGVtT3B0aW9ucztcblxuXHRcdFx0Ly8gR2VuZXJhbCBzZXJpZXMgb3B0aW9ucyB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0eXBlIG9wdGlvbnMgYmVjYXVzZSBvdGhlcndpc2UsIGRlZmF1bHRcblx0XHRcdC8vIHR5cGUgb3B0aW9ucyBsaWtlIGNvbHVtbi5hbmltYXRpb24gd291bGQgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIGdlbmVyYWwgb3B0aW9uLlxuXHRcdFx0Ly8gQnV0IGlzc3VlcyBoYXZlIGJlZW4gcmFpc2VkIGhlcmUgKCMzODgxKSwgYW5kIHRoZSBzb2x1dGlvbiBtYXkgYmUgdG8gZGlzdGluZ3Vpc2ggXG5cdFx0XHQvLyBiZXR3ZWVuIGRlZmF1bHQgb3B0aW9uIGFuZCB1c2VyT3B0aW9ucyBsaWtlIGluIHRoZSB0b29sdGlwIGJlbG93LlxuXHRcdFx0b3B0aW9ucyA9IG1lcmdlKFxuXHRcdFx0XHR0eXBlT3B0aW9ucyxcblx0XHRcdFx0cGxvdE9wdGlvbnMuc2VyaWVzLFxuXHRcdFx0XHRpdGVtT3B0aW9uc1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gVGhlIHRvb2x0aXAgb3B0aW9ucyBhcmUgbWVyZ2VkIGJldHdlZW4gZ2xvYmFsIGFuZCBzZXJpZXMgc3BlY2lmaWMgb3B0aW9uc1xuXHRcdFx0dGhpcy50b29sdGlwT3B0aW9ucyA9IG1lcmdlKFxuXHRcdFx0XHRkZWZhdWx0T3B0aW9ucy50b29sdGlwLFxuXHRcdFx0XHRkZWZhdWx0T3B0aW9ucy5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLnRvb2x0aXAsXG5cdFx0XHRcdHVzZXJPcHRpb25zLnRvb2x0aXAsXG5cdFx0XHRcdHVzZXJQbG90T3B0aW9ucy5zZXJpZXMgJiYgdXNlclBsb3RPcHRpb25zLnNlcmllcy50b29sdGlwLFxuXHRcdFx0XHR1c2VyUGxvdE9wdGlvbnNbdGhpcy50eXBlXSAmJiB1c2VyUGxvdE9wdGlvbnNbdGhpcy50eXBlXS50b29sdGlwLFxuXHRcdFx0XHRpdGVtT3B0aW9ucy50b29sdGlwXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBEZWxldGUgbWFya2VyIG9iamVjdCBpZiBub3QgYWxsb3dlZCAoIzExMjUpXG5cdFx0XHRpZiAodHlwZU9wdGlvbnMubWFya2VyID09PSBudWxsKSB7XG5cdFx0XHRcdGRlbGV0ZSBvcHRpb25zLm1hcmtlcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIGNvbG9yIHpvbmVzXG5cdFx0XHR0aGlzLnpvbmVBeGlzID0gb3B0aW9ucy56b25lQXhpcztcblx0XHRcdHpvbmVzID0gdGhpcy56b25lcyA9IChvcHRpb25zLnpvbmVzIHx8IFtdKS5zbGljZSgpO1xuXHRcdFx0aWYgKChvcHRpb25zLm5lZ2F0aXZlQ29sb3IgfHwgb3B0aW9ucy5uZWdhdGl2ZUZpbGxDb2xvcikgJiYgIW9wdGlvbnMuem9uZXMpIHtcblx0XHRcdFx0em9uZXMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG9wdGlvbnNbdGhpcy56b25lQXhpcyArICdUaHJlc2hvbGQnXSB8fCBvcHRpb25zLnRocmVzaG9sZCB8fCAwLFxuXHRcdFx0XHRcdGNvbG9yOiBvcHRpb25zLm5lZ2F0aXZlQ29sb3IsXG5cdFx0XHRcdFx0ZmlsbENvbG9yOiBvcHRpb25zLm5lZ2F0aXZlRmlsbENvbG9yXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHpvbmVzLmxlbmd0aCkgeyAvLyBQdXNoIG9uZSBleHRyYSB6b25lIGZvciB0aGUgcmVzdFxuXHRcdFx0XHRpZiAoZGVmaW5lZCh6b25lc1t6b25lcy5sZW5ndGggLSAxXS52YWx1ZSkpIHtcblx0XHRcdFx0XHR6b25lcy5wdXNoKHtcblx0XHRcdFx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLFxuXHRcdFx0XHRcdFx0ZmlsbENvbG9yOiB0aGlzLmZpbGxDb2xvclxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHR9LFxuXG5cdFx0Z2V0Q3ljbGljOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUsIGRlZmF1bHRzKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0dXNlck9wdGlvbnMgPSB0aGlzLnVzZXJPcHRpb25zLFxuXHRcdFx0XHRpbmRleE5hbWUgPSAnXycgKyBwcm9wICsgJ0luZGV4Jyxcblx0XHRcdFx0Y291bnRlck5hbWUgPSBwcm9wICsgJ0NvdW50ZXInO1xuXG5cdFx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdGlmIChkZWZpbmVkKHVzZXJPcHRpb25zW2luZGV4TmFtZV0pKSB7IC8vIGFmdGVyIFNlcmllcy51cGRhdGUoKVxuXHRcdFx0XHRcdGkgPSB1c2VyT3B0aW9uc1tpbmRleE5hbWVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVzZXJPcHRpb25zW2luZGV4TmFtZV0gPSBpID0gdGhpcy5jaGFydFtjb3VudGVyTmFtZV0gJSBkZWZhdWx0cy5sZW5ndGg7XG5cdFx0XHRcdFx0dGhpcy5jaGFydFtjb3VudGVyTmFtZV0gKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IGRlZmF1bHRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0dGhpc1twcm9wXSA9IHZhbHVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNlcmllcycgY29sb3Jcblx0XHQgKi9cblx0XHRnZXRDb2xvcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuY29sb3JCeVBvaW50KSB7XG5cdFx0XHRcdHRoaXMuZ2V0Q3ljbGljKCdjb2xvcicsIHRoaXMub3B0aW9ucy5jb2xvciB8fCBkZWZhdWx0UGxvdE9wdGlvbnNbdGhpcy50eXBlXS5jb2xvciwgdGhpcy5jaGFydC5vcHRpb25zLmNvbG9ycyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNlcmllcycgc3ltYm9sXG5cdFx0ICovXG5cdFx0Z2V0U3ltYm9sOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzTWFya2VyT3B0aW9uID0gdGhpcy5vcHRpb25zLm1hcmtlcjtcblxuXHRcdFx0dGhpcy5nZXRDeWNsaWMoJ3N5bWJvbCcsIHNlcmllc01hcmtlck9wdGlvbi5zeW1ib2wsIHRoaXMuY2hhcnQub3B0aW9ucy5zeW1ib2xzKTtcblxuXHRcdFx0Ly8gZG9uJ3Qgc3Vic3RyYWN0IHJhZGl1cyBpbiBpbWFnZSBzeW1ib2xzICgjNjA0KVxuXHRcdFx0aWYgKC9edXJsLy50ZXN0KHRoaXMuc3ltYm9sKSkge1xuXHRcdFx0XHRzZXJpZXNNYXJrZXJPcHRpb24ucmFkaXVzID0gMDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZHJhd0xlZ2VuZFN5bWJvbDogTGVnZW5kU3ltYm9sTWl4aW4uZHJhd0xpbmVNYXJrZXIsXG5cblx0XHQvKipcblx0XHQgKiBSZXBsYWNlIHRoZSBzZXJpZXMgZGF0YSB3aXRoIGEgbmV3IHNldCBvZiBkYXRhXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcmVkcmF3XG5cdFx0ICovXG5cdFx0c2V0RGF0YTogZnVuY3Rpb24gKGRhdGEsIHJlZHJhdywgYW5pbWF0aW9uLCB1cGRhdGVQb2ludHMpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvbGREYXRhID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdFx0b2xkRGF0YUxlbmd0aCA9IChvbGREYXRhICYmIG9sZERhdGEubGVuZ3RoKSB8fCAwLFxuXHRcdFx0XHRkYXRhTGVuZ3RoLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRmaXJzdFBvaW50ID0gbnVsbCxcblx0XHRcdFx0eEF4aXMgPSBzZXJpZXMueEF4aXMsXG5cdFx0XHRcdGhhc0NhdGVnb3JpZXMgPSB4QXhpcyAmJiAhIXhBeGlzLmNhdGVnb3JpZXMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdHR1cmJvVGhyZXNob2xkID0gb3B0aW9ucy50dXJib1RocmVzaG9sZCxcblx0XHRcdFx0cHQsXG5cdFx0XHRcdHhEYXRhID0gdGhpcy54RGF0YSxcblx0XHRcdFx0eURhdGEgPSB0aGlzLnlEYXRhLFxuXHRcdFx0XHRwb2ludEFycmF5TWFwID0gc2VyaWVzLnBvaW50QXJyYXlNYXAsXG5cdFx0XHRcdHZhbHVlQ291bnQgPSBwb2ludEFycmF5TWFwICYmIHBvaW50QXJyYXlNYXAubGVuZ3RoO1xuXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBbXTtcblx0XHRcdGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0XHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTtcblxuXHRcdFx0Ly8gSWYgdGhlIHBvaW50IGNvdW50IGlzIHRoZSBzYW1lIGFzIGlzIHdhcywganVzdCBydW4gUG9pbnQudXBkYXRlIHdoaWNoIGlzXG5cdFx0XHQvLyBjaGVhcGVyLCBhbGxvd3MgYW5pbWF0aW9uLCBhbmQga2VlcHMgcmVmZXJlbmNlcyB0byBwb2ludHMuXG5cdFx0XHRpZiAodXBkYXRlUG9pbnRzICE9PSBmYWxzZSAmJiBkYXRhTGVuZ3RoICYmIG9sZERhdGFMZW5ndGggPT09IGRhdGFMZW5ndGggJiYgIXNlcmllcy5jcm9wcGVkICYmICFzZXJpZXMuaGFzR3JvdXBlZERhdGEgJiYgc2VyaWVzLnZpc2libGUpIHtcblx0XHRcdFx0ZWFjaChkYXRhLCBmdW5jdGlvbiAocG9pbnQsIGkpIHtcblx0XHRcdFx0XHRvbGREYXRhW2ldLnVwZGF0ZShwb2ludCwgZmFsc2UsIG51bGwsIGZhbHNlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUmVzZXQgcHJvcGVydGllc1xuXHRcdFx0XHRzZXJpZXMueEluY3JlbWVudCA9IG51bGw7XG5cdFx0XHRcdHNlcmllcy5wb2ludFJhbmdlID0gaGFzQ2F0ZWdvcmllcyA/IDEgOiBvcHRpb25zLnBvaW50UmFuZ2U7XG5cblx0XHRcdFx0c2VyaWVzLmNvbG9yQ291bnRlciA9IDA7IC8vIGZvciBzZXJpZXMgd2l0aCBjb2xvckJ5UG9pbnQgKCMxNTQ3KVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVXBkYXRlIHBhcmFsbGVsIGFycmF5c1xuXHRcdFx0XHRlYWNoKHRoaXMucGFyYWxsZWxBcnJheXMsIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRzZXJpZXNba2V5ICsgJ0RhdGEnXS5sZW5ndGggPSAwO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBJbiB0dXJibyBtb2RlLCBvbmx5IG9uZS0gb3IgdHdvZGltZW5zaW9uYWwgYXJyYXlzIG9mIG51bWJlcnMgYXJlIGFsbG93ZWQuIFRoZVxuXHRcdFx0XHQvLyBmaXJzdCB2YWx1ZSBpcyB0ZXN0ZWQsIGFuZCB3ZSBhc3N1bWUgdGhhdCBhbGwgdGhlIHJlc3QgYXJlIGRlZmluZWQgdGhlIHNhbWVcblx0XHRcdFx0Ly8gd2F5LiBBbHRob3VnaCB0aGUgJ2ZvcicgbG9vcHMgYXJlIHNpbWlsYXIsIHRoZXkgYXJlIHJlcGVhdGVkIGluc2lkZSBlYWNoXG5cdFx0XHRcdC8vIGlmLWVsc2UgY29uZGl0aW9uYWwgZm9yIG1heCBwZXJmb3JtYW5jZS5cblx0XHRcdFx0aWYgKHR1cmJvVGhyZXNob2xkICYmIGRhdGFMZW5ndGggPiB0dXJib1RocmVzaG9sZCkge1xuXG5cdFx0XHRcdFx0Ly8gZmluZCB0aGUgZmlyc3Qgbm9uLW51bGwgcG9pbnRcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoZmlyc3RQb2ludCA9PT0gbnVsbCAmJiBpIDwgZGF0YUxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Zmlyc3RQb2ludCA9IGRhdGFbaV07XG5cdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRpZiAoaXNOdW1iZXIoZmlyc3RQb2ludCkpIHsgLy8gYXNzdW1lIGFsbCBwb2ludHMgYXJlIG51bWJlcnNcblx0XHRcdFx0XHRcdHZhciB4ID0gcGljayhvcHRpb25zLnBvaW50U3RhcnQsIDApLFxuXHRcdFx0XHRcdFx0XHRwb2ludEludGVydmFsID0gcGljayhvcHRpb25zLnBvaW50SW50ZXJ2YWwsIDEpO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHhEYXRhW2ldID0geDtcblx0XHRcdFx0XHRcdFx0eURhdGFbaV0gPSBkYXRhW2ldO1xuXHRcdFx0XHRcdFx0XHR4ICs9IHBvaW50SW50ZXJ2YWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzZXJpZXMueEluY3JlbWVudCA9IHg7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpc0FycmF5KGZpcnN0UG9pbnQpKSB7IC8vIGFzc3VtZSBhbGwgcG9pbnRzIGFyZSBhcnJheXNcblx0XHRcdFx0XHRcdGlmICh2YWx1ZUNvdW50KSB7IC8vIFt4LCBsb3csIGhpZ2hdIG9yIFt4LCBvLCBoLCBsLCBjXVxuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQgPSBkYXRhW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHhEYXRhW2ldID0gcHRbMF07XG5cdFx0XHRcdFx0XHRcdFx0eURhdGFbaV0gPSBwdC5zbGljZSgxLCB2YWx1ZUNvdW50ICsgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIFt4LCB5XVxuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQgPSBkYXRhW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHhEYXRhW2ldID0gcHRbMF07XG5cdFx0XHRcdFx0XHRcdFx0eURhdGFbaV0gPSBwdFsxXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlcnJvcigxMik7IC8vIEhpZ2hjaGFydHMgZXhwZWN0cyBjb25maWdzIHRvIGJlIG51bWJlcnMgb3IgYXJyYXlzIGluIHR1cmJvIG1vZGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGRhdGFbaV0gIT09IFVOREVGSU5FRCkgeyAvLyBzdHJheSBjb21tYXMgaW4gb2xkSUVcblx0XHRcdFx0XHRcdFx0cHQgPSB7IHNlcmllczogc2VyaWVzIH07XG5cdFx0XHRcdFx0XHRcdHNlcmllcy5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkocHQsIFtkYXRhW2ldXSk7XG5cdFx0XHRcdFx0XHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwdCwgaSk7XG5cdFx0XHRcdFx0XHRcdGlmIChoYXNDYXRlZ29yaWVzICYmIHB0Lm5hbWUpIHtcblx0XHRcdFx0XHRcdFx0XHR4QXhpcy5uYW1lc1twdC54XSA9IHB0Lm5hbWU7IC8vICMyMDQ2XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JnZXR0aW5nIHRvIGNhc3Qgc3RyaW5ncyB0byBudW1iZXJzIGlzIGEgY29tbW9uIGNhdmVhdCB3aGVuIGhhbmRsaW5nIENTViBvciBKU09OXG5cdFx0XHRcdGlmIChpc1N0cmluZyh5RGF0YVswXSkpIHtcblx0XHRcdFx0XHRlcnJvcigxNCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXJpZXMuZGF0YSA9IFtdO1xuXHRcdFx0XHRzZXJpZXMub3B0aW9ucy5kYXRhID0gZGF0YTtcblx0XHRcdFx0Ly9zZXJpZXMuekRhdGEgPSB6RGF0YTtcblxuXHRcdFx0XHQvLyBkZXN0cm95IG9sZCBwb2ludHNcblx0XHRcdFx0aSA9IG9sZERhdGFMZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRpZiAob2xkRGF0YVtpXSAmJiBvbGREYXRhW2ldLmRlc3Ryb3kpIHtcblx0XHRcdFx0XHRcdG9sZERhdGFbaV0uZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlc2V0IG1pblJhbmdlICgjODc4KVxuXHRcdFx0XHRpZiAoeEF4aXMpIHtcblx0XHRcdFx0XHR4QXhpcy5taW5SYW5nZSA9IHhBeGlzLnVzZXJNaW5SYW5nZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5RGF0YSA9IGNoYXJ0LmlzRGlydHlCb3ggPSB0cnVlO1xuXHRcdFx0XHRhbmltYXRpb24gPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUHJvY2VzcyB0aGUgZGF0YSBieSBjcm9wcGluZyBhd2F5IHVudXNlZCBkYXRhIHBvaW50cyBpZiB0aGUgc2VyaWVzIGlzIGxvbmdlclxuXHRcdCAqIHRoYW4gdGhlIGNyb3AgdGhyZXNob2xkLiBUaGlzIHNhdmVzIGNvbXB1dGluZyB0aW1lIGZvciBsYWdlIHNlcmllcy5cblx0XHQgKi9cblx0XHRwcm9jZXNzRGF0YTogZnVuY3Rpb24gKGZvcmNlKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBzZXJpZXMueERhdGEsIC8vIGNvcGllZCBkdXJpbmcgc2xpY2Ugb3BlcmF0aW9uIGJlbG93XG5cdFx0XHRcdHByb2Nlc3NlZFlEYXRhID0gc2VyaWVzLnlEYXRhLFxuXHRcdFx0XHRkYXRhTGVuZ3RoID0gcHJvY2Vzc2VkWERhdGEubGVuZ3RoLFxuXHRcdFx0XHRjcm9wcGVkRGF0YSxcblx0XHRcdFx0Y3JvcFN0YXJ0ID0gMCxcblx0XHRcdFx0Y3JvcHBlZCxcblx0XHRcdFx0ZGlzdGFuY2UsXG5cdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlLFxuXHRcdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdFx0aSwgLy8gbG9vcCB2YXJpYWJsZVxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGNyb3BUaHJlc2hvbGQgPSBvcHRpb25zLmNyb3BUaHJlc2hvbGQsXG5cdFx0XHRcdGlzQ2FydGVzaWFuID0gc2VyaWVzLmlzQ2FydGVzaWFuLFxuXHRcdFx0XHR4RXh0cmVtZXMsXG5cdFx0XHRcdG1pbixcblx0XHRcdFx0bWF4O1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VyaWVzIGRhdGEgb3IgYXhlcyBoYXZlbid0IGNoYW5nZWQsIGRvbid0IGdvIHRocm91Z2ggdGhpcy4gUmV0dXJuIGZhbHNlIHRvIHBhc3Ncblx0XHRcdC8vIHRoZSBtZXNzYWdlIG9uIHRvIG92ZXJyaWRlIG1ldGhvZHMgbGlrZSBpbiBkYXRhIGdyb3VwaW5nLlxuXHRcdFx0aWYgKGlzQ2FydGVzaWFuICYmICFzZXJpZXMuaXNEaXJ0eSAmJiAheEF4aXMuaXNEaXJ0eSAmJiAhc2VyaWVzLnlBeGlzLmlzRGlydHkgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHhBeGlzKSB7XG5cdFx0XHRcdHhFeHRyZW1lcyA9IHhBeGlzLmdldEV4dHJlbWVzKCk7IC8vIGNvcnJlY3RlZCBmb3IgbG9nIGF4aXMgKCMzMDUzKVxuXHRcdFx0XHRtaW4gPSB4RXh0cmVtZXMubWluO1xuXHRcdFx0XHRtYXggPSB4RXh0cmVtZXMubWF4O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBvcHRpb25hbGx5IGZpbHRlciBvdXQgcG9pbnRzIG91dHNpZGUgdGhlIHBsb3QgYXJlYVxuXHRcdFx0aWYgKGlzQ2FydGVzaWFuICYmIHNlcmllcy5zb3J0ZWQgJiYgKCFjcm9wVGhyZXNob2xkIHx8IGRhdGFMZW5ndGggPiBjcm9wVGhyZXNob2xkIHx8IHNlcmllcy5mb3JjZUNyb3ApKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpdCdzIG91dHNpZGUgY3VycmVudCBleHRyZW1lc1xuXHRcdFx0XHRpZiAocHJvY2Vzc2VkWERhdGFbZGF0YUxlbmd0aCAtIDFdIDwgbWluIHx8IHByb2Nlc3NlZFhEYXRhWzBdID4gbWF4KSB7XG5cdFx0XHRcdFx0cHJvY2Vzc2VkWERhdGEgPSBbXTtcblx0XHRcdFx0XHRwcm9jZXNzZWRZRGF0YSA9IFtdO1xuXG5cdFx0XHRcdC8vIG9ubHkgY3JvcCBpZiBpdCdzIGFjdHVhbGx5IHNwaWxsaW5nIG91dFxuXHRcdFx0XHR9IGVsc2UgaWYgKHByb2Nlc3NlZFhEYXRhWzBdIDwgbWluIHx8IHByb2Nlc3NlZFhEYXRhW2RhdGFMZW5ndGggLSAxXSA+IG1heCkge1xuXHRcdFx0XHRcdGNyb3BwZWREYXRhID0gdGhpcy5jcm9wRGF0YShzZXJpZXMueERhdGEsIHNlcmllcy55RGF0YSwgbWluLCBtYXgpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZFhEYXRhID0gY3JvcHBlZERhdGEueERhdGE7XG5cdFx0XHRcdFx0cHJvY2Vzc2VkWURhdGEgPSBjcm9wcGVkRGF0YS55RGF0YTtcblx0XHRcdFx0XHRjcm9wU3RhcnQgPSBjcm9wcGVkRGF0YS5zdGFydDtcblx0XHRcdFx0XHRjcm9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiBwcm9jZXNzZWQgcG9pbnRzXG5cdFx0XHRmb3IgKGkgPSBwcm9jZXNzZWRYRGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRkaXN0YW5jZSA9IHByb2Nlc3NlZFhEYXRhW2ldIC0gcHJvY2Vzc2VkWERhdGFbaSAtIDFdO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGRpc3RhbmNlID4gMCAmJiAoY2xvc2VzdFBvaW50UmFuZ2UgPT09IFVOREVGSU5FRCB8fCBkaXN0YW5jZSA8IGNsb3Nlc3RQb2ludFJhbmdlKSkge1xuXHRcdFx0XHRcdGNsb3Nlc3RQb2ludFJhbmdlID0gZGlzdGFuY2U7XG5cblx0XHRcdFx0Ly8gVW5zb3J0ZWQgZGF0YSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBsaW5lIHRvb2x0aXAsIGFzIHdlbGwgYXMgZGF0YSBncm91cGluZyBhbmRcblx0XHRcdFx0Ly8gbmF2aWdhdGlvbiBpbiBTdG9jayBjaGFydHMgKCM3MjUpIGFuZCB3aWR0aCBjYWxjdWxhdGlvbiBvZiBjb2x1bW5zICgjMTkwMClcblx0XHRcdFx0fSBlbHNlIGlmIChkaXN0YW5jZSA8IDAgJiYgc2VyaWVzLnJlcXVpcmVTb3J0aW5nKSB7XG5cdFx0XHRcdFx0ZXJyb3IoMTUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlY29yZCB0aGUgcHJvcGVydGllc1xuXHRcdFx0c2VyaWVzLmNyb3BwZWQgPSBjcm9wcGVkOyAvLyB1bmRlZmluZWQgb3IgdHJ1ZVxuXHRcdFx0c2VyaWVzLmNyb3BTdGFydCA9IGNyb3BTdGFydDtcblx0XHRcdHNlcmllcy5wcm9jZXNzZWRYRGF0YSA9IHByb2Nlc3NlZFhEYXRhO1xuXHRcdFx0c2VyaWVzLnByb2Nlc3NlZFlEYXRhID0gcHJvY2Vzc2VkWURhdGE7XG5cblx0XHRcdGlmIChvcHRpb25zLnBvaW50UmFuZ2UgPT09IG51bGwpIHsgLy8gbnVsbCBtZWFucyBhdXRvLCBhcyBmb3IgY29sdW1ucywgY2FuZGxlc3RpY2tzIGFuZCBPSExDXG5cdFx0XHRcdHNlcmllcy5wb2ludFJhbmdlID0gY2xvc2VzdFBvaW50UmFuZ2UgfHwgMTtcblx0XHRcdH1cblx0XHRcdHNlcmllcy5jbG9zZXN0UG9pbnRSYW5nZSA9IGNsb3Nlc3RQb2ludFJhbmdlO1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEl0ZXJhdGUgb3ZlciB4RGF0YSBhbmQgY3JvcCB2YWx1ZXMgYmV0d2VlbiBtaW4gYW5kIG1heC4gUmV0dXJucyBvYmplY3QgY29udGFpbmluZyBjcm9wIHN0YXJ0L2VuZFxuXHRcdCAqIGNyb3BwZWQgeERhdGEgd2l0aCBjb3JyZXNwb25kaW5nIHBhcnQgb2YgeURhdGEsIGRhdGFNaW4gYW5kIGRhdGFNYXggd2l0aGluIHRoZSBjcm9wcGVkIHJhbmdlXG5cdFx0ICovXG5cdFx0Y3JvcERhdGE6IGZ1bmN0aW9uICh4RGF0YSwgeURhdGEsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgZGF0YUxlbmd0aCA9IHhEYXRhLmxlbmd0aCxcblx0XHRcdFx0Y3JvcFN0YXJ0ID0gMCxcblx0XHRcdFx0Y3JvcEVuZCA9IGRhdGFMZW5ndGgsXG5cdFx0XHRcdGNyb3BTaG91bGRlciA9IHBpY2sodGhpcy5jcm9wU2hvdWxkZXIsIDEpLCAvLyBsaW5lLXR5cGUgc2VyaWVzIG5lZWQgb25lIHBvaW50IG91dHNpZGVcblx0XHRcdFx0aTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSB1cCB0byBmaW5kIHNsaWNlIHN0YXJ0XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh4RGF0YVtpXSA+PSBtaW4pIHtcblx0XHRcdFx0XHRjcm9wU3RhcnQgPSBtYXRoTWF4KDAsIGkgLSBjcm9wU2hvdWxkZXIpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2NlZWQgdG8gZmluZCBzbGljZSBlbmRcblx0XHRcdGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh4RGF0YVtpXSA+IG1heCkge1xuXHRcdFx0XHRcdGNyb3BFbmQgPSBpICsgY3JvcFNob3VsZGVyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHhEYXRhOiB4RGF0YS5zbGljZShjcm9wU3RhcnQsIGNyb3BFbmQpLFxuXHRcdFx0XHR5RGF0YTogeURhdGEuc2xpY2UoY3JvcFN0YXJ0LCBjcm9wRW5kKSxcblx0XHRcdFx0c3RhcnQ6IGNyb3BTdGFydCxcblx0XHRcdFx0ZW5kOiBjcm9wRW5kXG5cdFx0XHR9O1xuXHRcdH0sXG5cblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRlIHRoZSBkYXRhIHBvaW50IGFmdGVyIHRoZSBkYXRhIGhhcyBiZWVuIHByb2Nlc3NlZCBieSBjcm9wcGluZyBhd2F5XG5cdFx0ICogdW51c2VkIHBvaW50cyBhbmQgb3B0aW9uYWxseSBncm91cGVkIGluIEhpZ2hjaGFydHMgU3RvY2suXG5cdFx0ICovXG5cdFx0Z2VuZXJhdGVQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGRhdGFPcHRpb25zID0gb3B0aW9ucy5kYXRhLFxuXHRcdFx0XHRkYXRhID0gc2VyaWVzLmRhdGEsXG5cdFx0XHRcdGRhdGFMZW5ndGgsXG5cdFx0XHRcdHByb2Nlc3NlZFhEYXRhID0gc2VyaWVzLnByb2Nlc3NlZFhEYXRhLFxuXHRcdFx0XHRwcm9jZXNzZWRZRGF0YSA9IHNlcmllcy5wcm9jZXNzZWRZRGF0YSxcblx0XHRcdFx0cG9pbnRDbGFzcyA9IHNlcmllcy5wb2ludENsYXNzLFxuXHRcdFx0XHRwcm9jZXNzZWREYXRhTGVuZ3RoID0gcHJvY2Vzc2VkWERhdGEubGVuZ3RoLFxuXHRcdFx0XHRjcm9wU3RhcnQgPSBzZXJpZXMuY3JvcFN0YXJ0IHx8IDAsXG5cdFx0XHRcdGN1cnNvcixcblx0XHRcdFx0aGFzR3JvdXBlZERhdGEgPSBzZXJpZXMuaGFzR3JvdXBlZERhdGEsXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRwb2ludHMgPSBbXSxcblx0XHRcdFx0aTtcblxuXHRcdFx0aWYgKCFkYXRhICYmICFoYXNHcm91cGVkRGF0YSkge1xuXHRcdFx0XHR2YXIgYXJyID0gW107XG5cdFx0XHRcdGFyci5sZW5ndGggPSBkYXRhT3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSA9IGFycjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHByb2Nlc3NlZERhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjdXJzb3IgPSBjcm9wU3RhcnQgKyBpO1xuXHRcdFx0XHRpZiAoIWhhc0dyb3VwZWREYXRhKSB7XG5cdFx0XHRcdFx0aWYgKGRhdGFbY3Vyc29yXSkge1xuXHRcdFx0XHRcdFx0cG9pbnQgPSBkYXRhW2N1cnNvcl07XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChkYXRhT3B0aW9uc1tjdXJzb3JdICE9PSBVTkRFRklORUQpIHsgLy8gIzk3MFxuXHRcdFx0XHRcdFx0ZGF0YVtjdXJzb3JdID0gcG9pbnQgPSAobmV3IHBvaW50Q2xhc3MoKSkuaW5pdChzZXJpZXMsIGRhdGFPcHRpb25zW2N1cnNvcl0sIHByb2Nlc3NlZFhEYXRhW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9pbnRzW2ldID0gcG9pbnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gc3BsYXQgdGhlIHkgZGF0YSBpbiBjYXNlIG9mIG9obGMgZGF0YSBhcnJheVxuXHRcdFx0XHRcdHBvaW50c1tpXSA9IChuZXcgcG9pbnRDbGFzcygpKS5pbml0KHNlcmllcywgW3Byb2Nlc3NlZFhEYXRhW2ldXS5jb25jYXQoc3BsYXQocHJvY2Vzc2VkWURhdGFbaV0pKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9pbnRzW2ldLmluZGV4ID0gY3Vyc29yOyAvLyBGb3IgZmFzdGVyIGFjY2VzcyBpbiBQb2ludC51cGRhdGVcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGlkZSBjcm9wcGVkLWF3YXkgcG9pbnRzIC0gdGhpcyBvbmx5IHJ1bnMgd2hlbiB0aGUgbnVtYmVyIG9mIHBvaW50cyBpcyBhYm92ZSBjcm9wVGhyZXNob2xkLCBvciB3aGVuXG5cdFx0XHQvLyBzd2l0aGNoaW5nIHZpZXcgZnJvbSBub24tZ3JvdXBlZCBkYXRhIHRvIGdyb3VwZWQgZGF0YSAoIzYzNylcblx0XHRcdGlmIChkYXRhICYmIChwcm9jZXNzZWREYXRhTGVuZ3RoICE9PSAoZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoKSB8fCBoYXNHcm91cGVkRGF0YSkpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpID09PSBjcm9wU3RhcnQgJiYgIWhhc0dyb3VwZWREYXRhKSB7IC8vIHdoZW4gaGFzIGdyb3VwZWQgZGF0YSwgY2xlYXIgYWxsIHBvaW50c1xuXHRcdFx0XHRcdFx0aSArPSBwcm9jZXNzZWREYXRhTGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGF0YVtpXSkge1xuXHRcdFx0XHRcdFx0ZGF0YVtpXS5kZXN0cm95RWxlbWVudHMoKTtcblx0XHRcdFx0XHRcdGRhdGFbaV0ucGxvdFggPSBVTkRFRklORUQ7IC8vICMxMDAzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy5kYXRhID0gZGF0YTtcblx0XHRcdHNlcmllcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENhbGN1bGF0ZSBZIGV4dHJlbWVzIGZvciB2aXNpYmxlIGRhdGFcblx0XHQgKi9cblx0XHRnZXRFeHRyZW1lczogZnVuY3Rpb24gKHlEYXRhKSB7XG5cdFx0XHR2YXIgeEF4aXMgPSB0aGlzLnhBeGlzLFxuXHRcdFx0XHR5QXhpcyA9IHRoaXMueUF4aXMsXG5cdFx0XHRcdHhEYXRhID0gdGhpcy5wcm9jZXNzZWRYRGF0YSxcblx0XHRcdFx0eURhdGFMZW5ndGgsXG5cdFx0XHRcdGFjdGl2ZVlEYXRhID0gW10sXG5cdFx0XHRcdGFjdGl2ZUNvdW50ZXIgPSAwLFxuXHRcdFx0XHR4RXh0cmVtZXMgPSB4QXhpcy5nZXRFeHRyZW1lcygpLCAvLyAjMjExNywgbmVlZCB0byBjb21wZW5zYXRlIGZvciBsb2cgWCBheGlzXG5cdFx0XHRcdHhNaW4gPSB4RXh0cmVtZXMubWluLFxuXHRcdFx0XHR4TWF4ID0geEV4dHJlbWVzLm1heCxcblx0XHRcdFx0dmFsaWRWYWx1ZSxcblx0XHRcdFx0d2l0aGluUmFuZ2UsXG5cdFx0XHRcdGRhdGFNaW4sXG5cdFx0XHRcdGRhdGFNYXgsXG5cdFx0XHRcdHgsXG5cdFx0XHRcdHksXG5cdFx0XHRcdGksXG5cdFx0XHRcdGo7XG5cblx0XHRcdHlEYXRhID0geURhdGEgfHwgdGhpcy5zdGFja2VkWURhdGEgfHwgdGhpcy5wcm9jZXNzZWRZRGF0YTtcblx0XHRcdHlEYXRhTGVuZ3RoID0geURhdGEubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgeURhdGFMZW5ndGg7IGkrKykge1xuXG5cdFx0XHRcdHggPSB4RGF0YVtpXTtcblx0XHRcdFx0eSA9IHlEYXRhW2ldO1xuXG5cdFx0XHRcdC8vIEZvciBwb2ludHMgd2l0aGluIHRoZSB2aXNpYmxlIHJhbmdlLCBpbmNsdWRpbmcgdGhlIGZpcnN0IHBvaW50IG91dHNpZGUgdGhlXG5cdFx0XHRcdC8vIHZpc2libGUgcmFuZ2UsIGNvbnNpZGVyIHkgZXh0cmVtZXNcblx0XHRcdFx0dmFsaWRWYWx1ZSA9IHkgIT09IG51bGwgJiYgeSAhPT0gVU5ERUZJTkVEICYmICgheUF4aXMuaXNMb2cgfHwgKHkubGVuZ3RoIHx8IHkgPiAwKSk7XG5cdFx0XHRcdHdpdGhpblJhbmdlID0gdGhpcy5nZXRFeHRyZW1lc0Zyb21BbGwgfHwgdGhpcy5jcm9wcGVkIHx8ICgoeERhdGFbaSArIDFdIHx8IHgpID49IHhNaW4gJiZcblx0XHRcdFx0XHQoeERhdGFbaSAtIDFdIHx8IHgpIDw9IHhNYXgpO1xuXG5cdFx0XHRcdGlmICh2YWxpZFZhbHVlICYmIHdpdGhpblJhbmdlKSB7XG5cblx0XHRcdFx0XHRqID0geS5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKGopIHsgLy8gYXJyYXksIGxpa2Ugb2hsYyBvciByYW5nZSBkYXRhXG5cdFx0XHRcdFx0XHR3aGlsZSAoai0tKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh5W2pdICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWN0aXZlWURhdGFbYWN0aXZlQ291bnRlcisrXSA9IHlbal07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YWN0aXZlWURhdGFbYWN0aXZlQ291bnRlcisrXSA9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRhdGFNaW4gPSBwaWNrKGRhdGFNaW4sIGFycmF5TWluKGFjdGl2ZVlEYXRhKSk7XG5cdFx0XHR0aGlzLmRhdGFNYXggPSBwaWNrKGRhdGFNYXgsIGFycmF5TWF4KGFjdGl2ZVlEYXRhKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zbGF0ZSBkYXRhIHBvaW50cyBmcm9tIHJhdyBkYXRhIHZhbHVlcyB0byBjaGFydCBzcGVjaWZpYyBwb3NpdGlvbmluZyBkYXRhXG5cdFx0ICogbmVlZGVkIGxhdGVyIGluIGRyYXdQb2ludHMsIGRyYXdHcmFwaCBhbmQgZHJhd1RyYWNrZXIuXG5cdFx0ICovXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXRoaXMucHJvY2Vzc2VkWERhdGEpIHsgLy8gaGlkZGVuIHNlcmllc1xuXHRcdFx0XHR0aGlzLnByb2Nlc3NEYXRhKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmdlbmVyYXRlUG9pbnRzKCk7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRzdGFja2luZyA9IG9wdGlvbnMuc3RhY2tpbmcsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHRjYXRlZ29yaWVzID0geEF4aXMuY2F0ZWdvcmllcyxcblx0XHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXMsXG5cdFx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRcdGRhdGFMZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuXHRcdFx0XHRoYXNNb2RpZnlWYWx1ZSA9ICEhc2VyaWVzLm1vZGlmeVZhbHVlLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRwb2ludFBsYWNlbWVudCA9IG9wdGlvbnMucG9pbnRQbGFjZW1lbnQsXG5cdFx0XHRcdGR5bmFtaWNhbGx5UGxhY2VkID0gcG9pbnRQbGFjZW1lbnQgPT09ICdiZXR3ZWVuJyB8fCBpc051bWJlcihwb2ludFBsYWNlbWVudCksXG5cdFx0XHRcdHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkLFxuXHRcdFx0XHRwbG90WCxcblx0XHRcdFx0cGxvdFksXG5cdFx0XHRcdGxhc3RQbG90WCxcblx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2VQeCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblx0XHRcdC8vIFRyYW5zbGF0ZSBlYWNoIHBvaW50XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IHBvaW50c1tpXSxcblx0XHRcdFx0XHR4VmFsdWUgPSBwb2ludC54LFxuXHRcdFx0XHRcdHlWYWx1ZSA9IHBvaW50LnksXG5cdFx0XHRcdFx0eUJvdHRvbSA9IHBvaW50Lmxvdyxcblx0XHRcdFx0XHRzdGFjayA9IHN0YWNraW5nICYmIHlBeGlzLnN0YWNrc1soc2VyaWVzLm5lZ1N0YWNrcyAmJiB5VmFsdWUgPCB0aHJlc2hvbGQgPyAnLScgOiAnJykgKyBzZXJpZXMuc3RhY2tLZXldLFxuXHRcdFx0XHRcdHBvaW50U3RhY2ssXG5cdFx0XHRcdFx0c3RhY2tWYWx1ZXM7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCBkaXNhbGxvd2VkIHkgdmFsdWVzIGZvciBsb2cgYXhlcyAoIzM0MzQpXG5cdFx0XHRcdGlmICh5QXhpcy5pc0xvZyAmJiB5VmFsdWUgIT09IG51bGwgJiYgeVZhbHVlIDw9IDApIHtcblx0XHRcdFx0XHRwb2ludC55ID0geVZhbHVlID0gbnVsbDtcblx0XHRcdFx0XHRlcnJvcigxMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgdGhlIHBsb3RYIHRyYW5zbGF0aW9uXG5cdFx0XHRcdHBvaW50LnBsb3RYID0gcGxvdFggPSB4QXhpcy50cmFuc2xhdGUoeFZhbHVlLCAwLCAwLCAwLCAxLCBwb2ludFBsYWNlbWVudCwgdGhpcy50eXBlID09PSAnZmxhZ3MnKTsgLy8gTWF0aC5yb3VuZCBmaXhlcyAjNTkxXG5cblxuXHRcdFx0XHQvLyBDYWxjdWxhdGUgdGhlIGJvdHRvbSB5IHZhbHVlIGZvciBzdGFja2VkIHNlcmllc1xuXHRcdFx0XHRpZiAoc3RhY2tpbmcgJiYgc2VyaWVzLnZpc2libGUgJiYgc3RhY2sgJiYgc3RhY2tbeFZhbHVlXSkge1xuXG5cdFx0XHRcdFx0cG9pbnRTdGFjayA9IHN0YWNrW3hWYWx1ZV07XG5cdFx0XHRcdFx0c3RhY2tWYWx1ZXMgPSBwb2ludFN0YWNrLnBvaW50c1tzZXJpZXMuaW5kZXggKyAnLCcgKyBpXTtcblx0XHRcdFx0XHR5Qm90dG9tID0gc3RhY2tWYWx1ZXNbMF07XG5cdFx0XHRcdFx0eVZhbHVlID0gc3RhY2tWYWx1ZXNbMV07XG5cblx0XHRcdFx0XHRpZiAoeUJvdHRvbSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0eUJvdHRvbSA9IHBpY2sodGhyZXNob2xkLCB5QXhpcy5taW4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeUF4aXMuaXNMb2cgJiYgeUJvdHRvbSA8PSAwKSB7IC8vICMxMjAwLCAjMTIzMlxuXHRcdFx0XHRcdFx0eUJvdHRvbSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cG9pbnQudG90YWwgPSBwb2ludC5zdGFja1RvdGFsID0gcG9pbnRTdGFjay50b3RhbDtcblx0XHRcdFx0XHRwb2ludC5wZXJjZW50YWdlID0gcG9pbnRTdGFjay50b3RhbCAmJiAocG9pbnQueSAvIHBvaW50U3RhY2sudG90YWwgKiAxMDApO1xuXHRcdFx0XHRcdHBvaW50LnN0YWNrWSA9IHlWYWx1ZTtcblxuXHRcdFx0XHRcdC8vIFBsYWNlIHRoZSBzdGFjayBsYWJlbFxuXHRcdFx0XHRcdHBvaW50U3RhY2suc2V0T2Zmc2V0KHNlcmllcy5wb2ludFhPZmZzZXQgfHwgMCwgc2VyaWVzLmJhclcgfHwgMCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCB0cmFuc2xhdGVkIHlCb3R0b20gb3IgcmVtb3ZlIGl0XG5cdFx0XHRcdHBvaW50LnlCb3R0b20gPSBkZWZpbmVkKHlCb3R0b20pID9cblx0XHRcdFx0XHR5QXhpcy50cmFuc2xhdGUoeUJvdHRvbSwgMCwgMSwgMCwgMSkgOlxuXHRcdFx0XHRcdG51bGw7XG5cblx0XHRcdFx0Ly8gZ2VuZXJhbCBob29rLCB1c2VkIGZvciBIaWdoc3RvY2sgY29tcGFyZSBtb2RlXG5cdFx0XHRcdGlmIChoYXNNb2RpZnlWYWx1ZSkge1xuXHRcdFx0XHRcdHlWYWx1ZSA9IHNlcmllcy5tb2RpZnlWYWx1ZSh5VmFsdWUsIHBvaW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCB0aGUgdGhlIHBsb3RZIHZhbHVlLCByZXNldCBpdCBmb3IgcmVkcmF3c1xuXHRcdFx0XHRwb2ludC5wbG90WSA9IHBsb3RZID0gKHR5cGVvZiB5VmFsdWUgPT09ICdudW1iZXInICYmIHlWYWx1ZSAhPT0gSW5maW5pdHkpID9cblx0XHRcdFx0XHRtYXRoTWluKG1hdGhNYXgoLTFlNSwgeUF4aXMudHJhbnNsYXRlKHlWYWx1ZSwgMCwgMSwgMCwgMSkpLCAxZTUpIDogLy8gIzMyMDFcblx0XHRcdFx0XHRVTkRFRklORUQ7XG5cdFx0XHRcdHBvaW50LmlzSW5zaWRlID0gcGxvdFkgIT09IFVOREVGSU5FRCAmJiBwbG90WSA+PSAwICYmIHBsb3RZIDw9IHlBeGlzLmxlbiAmJiAvLyAjMzUxOVxuXHRcdFx0XHRcdHBsb3RYID49IDAgJiYgcGxvdFggPD0geEF4aXMubGVuO1xuXG5cblx0XHRcdFx0Ly8gU2V0IGNsaWVudCByZWxhdGVkIHBvc2l0aW9ucyBmb3IgbW91c2UgdHJhY2tpbmdcblx0XHRcdFx0cG9pbnQuY2xpZW50WCA9IGR5bmFtaWNhbGx5UGxhY2VkID8geEF4aXMudHJhbnNsYXRlKHhWYWx1ZSwgMCwgMCwgMCwgMSkgOiBwbG90WDsgLy8gIzE1MTRcblxuXHRcdFx0XHRwb2ludC5uZWdhdGl2ZSA9IHBvaW50LnkgPCAodGhyZXNob2xkIHx8IDApO1xuXG5cdFx0XHRcdC8vIHNvbWUgQVBJIGRhdGFcblx0XHRcdFx0cG9pbnQuY2F0ZWdvcnkgPSBjYXRlZ29yaWVzICYmIGNhdGVnb3JpZXNbcG9pbnQueF0gIT09IFVOREVGSU5FRCA/XG5cdFx0XHRcdFx0Y2F0ZWdvcmllc1twb2ludC54XSA6IHBvaW50Lng7XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGF1dG8gZW5hYmxpbmcgb2YgbWFya2VycyAoIzM2MzUpXG5cdFx0XHRcdGlmIChpKSB7XG5cdFx0XHRcdFx0Y2xvc2VzdFBvaW50UmFuZ2VQeCA9IG1hdGhNaW4oY2xvc2VzdFBvaW50UmFuZ2VQeCwgbWF0aEFicyhwbG90WCAtIGxhc3RQbG90WCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RQbG90WCA9IHBsb3RYO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy5jbG9zZXN0UG9pbnRSYW5nZVB4ID0gY2xvc2VzdFBvaW50UmFuZ2VQeDtcblxuXHRcdFx0Ly8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgY3JvcHBlZCBkYXRhLCBidWlsZCB0aGUgc2VnbWVudHNcblx0XHRcdHNlcmllcy5nZXRTZWdtZW50cygpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGNsaXBwaW5nIGZvciB0aGUgc2VyaWVzLiBGb3IgYW5pbWF0ZWQgc2VyaWVzIGl0IGlzIGNhbGxlZCB0d2ljZSwgZmlyc3QgdG8gaW5pdGlhdGVcblx0XHQgKiBhbmltYXRpbmcgdGhlIGNsaXAgdGhlbiB0aGUgc2Vjb25kIHRpbWUgd2l0aG91dCB0aGUgYW5pbWF0aW9uIHRvIHNldCB0aGUgZmluYWwgY2xpcC5cblx0XHQgKi9cblx0XHRzZXRDbGlwOiBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0XHRzZXJpZXNDbGlwQm94ID0gdGhpcy5jbGlwQm94LFxuXHRcdFx0XHRjbGlwQm94ID0gc2VyaWVzQ2xpcEJveCB8fCBjaGFydC5jbGlwQm94LFxuXHRcdFx0XHRzaGFyZWRDbGlwS2V5ID0gdGhpcy5zaGFyZWRDbGlwS2V5IHx8IFsnX3NoYXJlZENsaXAnLCBhbmltYXRpb24gJiYgYW5pbWF0aW9uLmR1cmF0aW9uLCBhbmltYXRpb24gJiYgYW5pbWF0aW9uLmVhc2luZywgY2xpcEJveC5oZWlnaHRdLmpvaW4oJywnKSxcblx0XHRcdFx0Y2xpcFJlY3QgPSBjaGFydFtzaGFyZWRDbGlwS2V5XSxcblx0XHRcdFx0bWFya2VyQ2xpcFJlY3QgPSBjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXTtcblxuXHRcdFx0Ly8gSWYgYSBjbGlwcGluZyByZWN0YW5nbGUgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGlzIGN1cnJlbnRseSBwcmVzZW50IGluIHRoZSBjaGFydCwgdXNlIHRoYXQuXG5cdFx0XHRpZiAoIWNsaXBSZWN0KSB7XG5cblx0XHRcdFx0Ly8gV2hlbiBhbmltYXRpb24gaXMgc2V0LCBwcmVwYXJlIHRoZSBpbml0aWFsIHBvc2l0aW9uc1xuXHRcdFx0XHRpZiAoYW5pbWF0aW9uKSB7IFxuXHRcdFx0XHRcdGNsaXBCb3gud2lkdGggPSAwO1xuXG5cdFx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10gPSBtYXJrZXJDbGlwUmVjdCA9IHJlbmRlcmVyLmNsaXBSZWN0KFxuXHRcdFx0XHRcdFx0LTk5LCAvLyBpbmNsdWRlIHRoZSB3aWR0aCBvZiB0aGUgZmlyc3QgbWFya2VyXG5cdFx0XHRcdFx0XHRpbnZlcnRlZCA/IC1jaGFydC5wbG90TGVmdCA6IC1jaGFydC5wbG90VG9wLFxuXHRcdFx0XHRcdFx0OTksXG5cdFx0XHRcdFx0XHRpbnZlcnRlZCA/IGNoYXJ0LmNoYXJ0V2lkdGggOiBjaGFydC5jaGFydEhlaWdodFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleV0gPSBjbGlwUmVjdCA9IHJlbmRlcmVyLmNsaXBSZWN0KGNsaXBCb3gpO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdFx0Y2xpcFJlY3QuY291bnQgKz0gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5jbGlwICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLmdyb3VwLmNsaXAoYW5pbWF0aW9uIHx8IHNlcmllc0NsaXBCb3ggPyBjbGlwUmVjdCA6IGNoYXJ0LmNsaXBSZWN0KTtcblx0XHRcdFx0dGhpcy5tYXJrZXJHcm91cC5jbGlwKG1hcmtlckNsaXBSZWN0KTtcblx0XHRcdFx0dGhpcy5zaGFyZWRDbGlwS2V5ID0gc2hhcmVkQ2xpcEtleTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBzaGFyZWQgY2xpcHBpbmcgcmVjdGFuY2dsZSB3aGVuIGFsbCBzZXJpZXMgYXJlIHNob3duXG5cdFx0XHRpZiAoIWFuaW1hdGlvbikge1xuXHRcdFx0XHRjbGlwUmVjdC5jb3VudCAtPSAxO1xuXHRcdFx0XHRpZiAoY2xpcFJlY3QuY291bnQgPD0gMCAmJiBzaGFyZWRDbGlwS2V5ICYmIGNoYXJ0W3NoYXJlZENsaXBLZXldKSB7XG5cdFx0XHRcdFx0aWYgKCFzZXJpZXNDbGlwQm94KSB7XG5cdFx0XHRcdFx0XHRjaGFydFtzaGFyZWRDbGlwS2V5XSA9IGNoYXJ0W3NoYXJlZENsaXBLZXldLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddKSB7XG5cdFx0XHRcdFx0XHRjaGFydFtzaGFyZWRDbGlwS2V5ICsgJ20nXSA9IGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQW5pbWF0ZSBpbiB0aGUgc2VyaWVzXG5cdFx0ICovXG5cdFx0YW5pbWF0ZTogZnVuY3Rpb24gKGluaXQpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0Y2xpcFJlY3QsXG5cdFx0XHRcdGFuaW1hdGlvbiA9IHNlcmllcy5vcHRpb25zLmFuaW1hdGlvbixcblx0XHRcdFx0c2hhcmVkQ2xpcEtleTtcblxuXHRcdFx0Ly8gQW5pbWF0aW9uIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZVxuXHRcdFx0aWYgKGFuaW1hdGlvbiAmJiAhaXNPYmplY3QoYW5pbWF0aW9uKSkge1xuXHRcdFx0XHRhbmltYXRpb24gPSBkZWZhdWx0UGxvdE9wdGlvbnNbc2VyaWVzLnR5cGVdLmFuaW1hdGlvbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgYW5pbWF0aW9uLiBTZXQgdXAgdGhlIGNsaXBwaW5nIHJlY3RhbmdsZS5cblx0XHRcdGlmIChpbml0KSB7XG5cblx0XHRcdFx0c2VyaWVzLnNldENsaXAoYW5pbWF0aW9uKTtcblxuXHRcdFx0Ly8gUnVuIHRoZSBhbmltYXRpb25cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNoYXJlZENsaXBLZXkgPSB0aGlzLnNoYXJlZENsaXBLZXk7XG5cdFx0XHRcdGNsaXBSZWN0ID0gY2hhcnRbc2hhcmVkQ2xpcEtleV07XG5cdFx0XHRcdGlmIChjbGlwUmVjdCkge1xuXHRcdFx0XHRcdGNsaXBSZWN0LmFuaW1hdGUoe1xuXHRcdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LnBsb3RTaXplWFxuXHRcdFx0XHRcdH0sIGFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNoYXJ0W3NoYXJlZENsaXBLZXkgKyAnbSddKSB7XG5cdFx0XHRcdFx0Y2hhcnRbc2hhcmVkQ2xpcEtleSArICdtJ10uYW5pbWF0ZSh7XG5cdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdFNpemVYICsgOTlcblx0XHRcdFx0XHR9LCBhbmltYXRpb24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGVsZXRlIHRoaXMgZnVuY3Rpb24gdG8gYWxsb3cgaXQgb25seSBvbmNlXG5cdFx0XHRcdHNlcmllcy5hbmltYXRlID0gbnVsbDtcblx0IFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHJ1bnMgYWZ0ZXIgYW5pbWF0aW9uIHRvIGxhbmQgb24gdGhlIGZpbmFsIHBsb3QgY2xpcHBpbmdcblx0XHQgKi9cblx0XHRhZnRlckFuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuc2V0Q2xpcCgpO1xuXHRcdFx0ZmlyZUV2ZW50KHRoaXMsICdhZnRlckFuaW1hdGUnKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyB0aGUgbWFya2Vyc1xuXHRcdCAqL1xuXHRcdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRwb2ludEF0dHIsXG5cdFx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRwbG90WCxcblx0XHRcdFx0cGxvdFksXG5cdFx0XHRcdGksXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRyYWRpdXMsXG5cdFx0XHRcdHN5bWJvbCxcblx0XHRcdFx0aXNJbWFnZSxcblx0XHRcdFx0Z3JhcGhpYyxcblx0XHRcdFx0b3B0aW9ucyA9IHNlcmllcy5vcHRpb25zLFxuXHRcdFx0XHRzZXJpZXNNYXJrZXJPcHRpb25zID0gb3B0aW9ucy5tYXJrZXIsXG5cdFx0XHRcdHNlcmllc1BvaW50QXR0ciA9IHNlcmllcy5wb2ludEF0dHJbJyddLFxuXHRcdFx0XHRwb2ludE1hcmtlck9wdGlvbnMsXG5cdFx0XHRcdGhhc1BvaW50TWFya2VyLFxuXHRcdFx0XHRlbmFibGVkLFxuXHRcdFx0XHRpc0luc2lkZSxcblx0XHRcdFx0bWFya2VyR3JvdXAgPSBzZXJpZXMubWFya2VyR3JvdXAsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHRnbG9iYWxseUVuYWJsZWQgPSBwaWNrKFxuXHRcdFx0XHRcdHNlcmllc01hcmtlck9wdGlvbnMuZW5hYmxlZCwgXG5cdFx0XHRcdFx0eEF4aXMuaXNSYWRpYWwsXG5cdFx0XHRcdFx0c2VyaWVzLmNsb3Nlc3RQb2ludFJhbmdlUHggPiAyICogc2VyaWVzTWFya2VyT3B0aW9ucy5yYWRpdXNcblx0XHRcdFx0KTtcblxuXHRcdFx0aWYgKHNlcmllc01hcmtlck9wdGlvbnMuZW5hYmxlZCAhPT0gZmFsc2UgfHwgc2VyaWVzLl9oYXNQb2ludE1hcmtlcnMpIHtcblxuXHRcdFx0XHRpID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdFx0XHRcdHBsb3RYID0gbWF0aEZsb29yKHBvaW50LnBsb3RYKTsgLy8gIzE4NDNcblx0XHRcdFx0XHRwbG90WSA9IHBvaW50LnBsb3RZO1xuXHRcdFx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljO1xuXHRcdFx0XHRcdHBvaW50TWFya2VyT3B0aW9ucyA9IHBvaW50Lm1hcmtlciB8fCB7fTtcblx0XHRcdFx0XHRoYXNQb2ludE1hcmtlciA9ICEhcG9pbnQubWFya2VyO1xuXHRcdFx0XHRcdGVuYWJsZWQgPSAoZ2xvYmFsbHlFbmFibGVkICYmIHBvaW50TWFya2VyT3B0aW9ucy5lbmFibGVkID09PSBVTkRFRklORUQpIHx8IHBvaW50TWFya2VyT3B0aW9ucy5lbmFibGVkO1xuXHRcdFx0XHRcdGlzSW5zaWRlID0gcG9pbnQuaXNJbnNpZGU7XG5cblx0XHRcdFx0XHQvLyBvbmx5IGRyYXcgdGhlIHBvaW50IGlmIHkgaXMgZGVmaW5lZFxuXHRcdFx0XHRcdGlmIChlbmFibGVkICYmIHBsb3RZICE9PSBVTkRFRklORUQgJiYgIWlzTmFOKHBsb3RZKSAmJiBwb2ludC55ICE9PSBudWxsKSB7XG5cblx0XHRcdFx0XHRcdC8vIHNob3J0Y3V0c1xuXHRcdFx0XHRcdFx0cG9pbnRBdHRyID0gcG9pbnQucG9pbnRBdHRyW3BvaW50LnNlbGVjdGVkID8gU0VMRUNUX1NUQVRFIDogTk9STUFMX1NUQVRFXSB8fCBzZXJpZXNQb2ludEF0dHI7XG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBwb2ludEF0dHIucjtcblx0XHRcdFx0XHRcdHN5bWJvbCA9IHBpY2socG9pbnRNYXJrZXJPcHRpb25zLnN5bWJvbCwgc2VyaWVzLnN5bWJvbCk7XG5cdFx0XHRcdFx0XHRpc0ltYWdlID0gc3ltYm9sLmluZGV4T2YoJ3VybCcpID09PSAwO1xuXG5cdFx0XHRcdFx0XHRpZiAoZ3JhcGhpYykgeyAvLyB1cGRhdGVcblx0XHRcdFx0XHRcdFx0Z3JhcGhpY1tpc0luc2lkZSA/ICdzaG93JyA6ICdoaWRlJ10odHJ1ZSkgLy8gU2luY2UgdGhlIG1hcmtlciBncm91cCBpc24ndCBjbGlwcGVkLCBlYWNoIGluZGl2aWR1YWwgbWFya2VyIG11c3QgYmUgdG9nZ2xlZFxuXHRcdFx0XHRcdFx0XHRcdC5hbmltYXRlKGV4dGVuZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHk6IHBsb3RZIC0gcmFkaXVzXG5cdFx0XHRcdFx0XHRcdFx0fSwgZ3JhcGhpYy5zeW1ib2xOYW1lID8geyAvLyBkb24ndCBhcHBseSB0byBpbWFnZSBzeW1ib2xzICM1MDdcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoOiAyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAyICogcmFkaXVzXG5cdFx0XHRcdFx0XHRcdFx0fSA6IHt9KSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzSW5zaWRlICYmIChyYWRpdXMgPiAwIHx8IGlzSW1hZ2UpKSB7XG5cdFx0XHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljID0gY2hhcnQucmVuZGVyZXIuc3ltYm9sKFxuXHRcdFx0XHRcdFx0XHRcdHN5bWJvbCxcblx0XHRcdFx0XHRcdFx0XHRwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRwbG90WSAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHQyICogcmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdDIgKiByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0aGFzUG9pbnRNYXJrZXIgPyBwb2ludE1hcmtlck9wdGlvbnMgOiBzZXJpZXNNYXJrZXJPcHRpb25zXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0LmF0dHIocG9pbnRBdHRyKVxuXHRcdFx0XHRcdFx0XHQuYWRkKG1hcmtlckdyb3VwKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYyA9IGdyYXBoaWMuZGVzdHJveSgpOyAvLyAjMTI2OVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnQgc3RhdGUgcHJvcGVydGllcyBmcm9tIEFQSSBuYW1pbmcgY29udmVudGlvbnMgdG8gU1ZHIGF0dHJpYnV0ZXNcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFQSSBvcHRpb25zIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBiYXNlMSBTVkcgYXR0cmlidXRlIG9iamVjdCB0byBpbmhlcml0IGZyb21cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gYmFzZTIgU2Vjb25kIGxldmVsIFNWRyBhdHRyaWJ1dGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbVxuXHRcdCAqL1xuXHRcdGNvbnZlcnRBdHRyaWJzOiBmdW5jdGlvbiAob3B0aW9ucywgYmFzZTEsIGJhc2UyLCBiYXNlMykge1xuXHRcdFx0dmFyIGNvbnZlcnNpb24gPSB0aGlzLnBvaW50QXR0clRvT3B0aW9ucyxcblx0XHRcdFx0YXR0cixcblx0XHRcdFx0b3B0aW9uLFxuXHRcdFx0XHRvYmogPSB7fTtcblxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRiYXNlMSA9IGJhc2UxIHx8IHt9O1xuXHRcdFx0YmFzZTIgPSBiYXNlMiB8fCB7fTtcblx0XHRcdGJhc2UzID0gYmFzZTMgfHwge307XG5cblx0XHRcdGZvciAoYXR0ciBpbiBjb252ZXJzaW9uKSB7XG5cdFx0XHRcdG9wdGlvbiA9IGNvbnZlcnNpb25bYXR0cl07XG5cdFx0XHRcdG9ialthdHRyXSA9IHBpY2sob3B0aW9uc1tvcHRpb25dLCBiYXNlMVthdHRyXSwgYmFzZTJbYXR0cl0sIGJhc2UzW2F0dHJdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgc3RhdGUgYXR0cmlidXRlcy4gRWFjaCBzZXJpZXMgdHlwZSBoYXMgaXRzIG93biBzZXQgb2YgYXR0cmlidXRlc1xuXHRcdCAqIHRoYXQgYXJlIGFsbG93ZWQgdG8gY2hhbmdlIG9uIGEgcG9pbnQncyBzdGF0ZSBjaGFuZ2UuIFNlcmllcyB3aWRlIGF0dHJpYnV0ZXMgYXJlIHN0b3JlZCBmb3Jcblx0XHQgKiBhbGwgc2VyaWVzLCBhbmQgYWRkaXRpb25hbGx5IHBvaW50IHNwZWNpZmljIGF0dHJpYnV0ZXMgYXJlIHN0b3JlZCBmb3IgYWxsXG5cdFx0ICogcG9pbnRzIHdpdGggaW5kaXZpZHVhbCBtYXJrZXIgb3B0aW9ucy4gSWYgc3VjaCBvcHRpb25zIGFyZSBub3QgZGVmaW5lZCBmb3IgdGhlIHBvaW50LFxuXHRcdCAqIGEgcmVmZXJlbmNlIHRvIHRoZSBzZXJpZXMgd2lkZSBhdHRyaWJ1dGVzIGlzIHN0b3JlZCBpbiBwb2ludC5wb2ludEF0dHIuXG5cdFx0ICovXG5cdFx0Z2V0QXR0cmliczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0bm9ybWFsT3B0aW9ucyA9IGRlZmF1bHRQbG90T3B0aW9uc1tzZXJpZXMudHlwZV0ubWFya2VyID8gc2VyaWVzT3B0aW9ucy5tYXJrZXIgOiBzZXJpZXNPcHRpb25zLFxuXHRcdFx0XHRzdGF0ZU9wdGlvbnMgPSBub3JtYWxPcHRpb25zLnN0YXRlcyxcblx0XHRcdFx0c3RhdGVPcHRpb25zSG92ZXIgPSBzdGF0ZU9wdGlvbnNbSE9WRVJfU1RBVEVdLFxuXHRcdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyLFxuXHRcdFx0XHRzZXJpZXNDb2xvciA9IHNlcmllcy5jb2xvcixcblx0XHRcdFx0c2VyaWVzTmVnYXRpdmVDb2xvciA9IHNlcmllcy5vcHRpb25zLm5lZ2F0aXZlQ29sb3IsXG5cdFx0XHRcdG5vcm1hbERlZmF1bHRzID0ge1xuXHRcdFx0XHRcdHN0cm9rZTogc2VyaWVzQ29sb3IsXG5cdFx0XHRcdFx0ZmlsbDogc2VyaWVzQ29sb3Jcblx0XHRcdFx0fSxcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyB8fCBbXSwgLy8gIzkyN1xuXHRcdFx0XHRpLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0c2VyaWVzUG9pbnRBdHRyID0gW10sXG5cdFx0XHRcdHBvaW50QXR0cixcblx0XHRcdFx0cG9pbnRBdHRyVG9PcHRpb25zID0gc2VyaWVzLnBvaW50QXR0clRvT3B0aW9ucyxcblx0XHRcdFx0aGFzUG9pbnRTcGVjaWZpY09wdGlvbnMgPSBzZXJpZXMuaGFzUG9pbnRTcGVjaWZpY09wdGlvbnMsXG5cdFx0XHRcdGRlZmF1bHRMaW5lQ29sb3IgPSBub3JtYWxPcHRpb25zLmxpbmVDb2xvcixcblx0XHRcdFx0ZGVmYXVsdEZpbGxDb2xvciA9IG5vcm1hbE9wdGlvbnMuZmlsbENvbG9yLFxuXHRcdFx0XHR0dXJib1RocmVzaG9sZCA9IHNlcmllc09wdGlvbnMudHVyYm9UaHJlc2hvbGQsXG5cdFx0XHRcdHpvbmVzID0gc2VyaWVzLnpvbmVzLFxuXHRcdFx0XHR6b25lQXhpcyA9IHNlcmllcy56b25lQXhpcyB8fCAneScsXG5cdFx0XHRcdGF0dHIsXG5cdFx0XHRcdGtleTtcblxuXHRcdFx0Ly8gc2VyaWVzIHR5cGUgc3BlY2lmaWMgbW9kaWZpY2F0aW9uc1xuXHRcdFx0aWYgKHNlcmllc09wdGlvbnMubWFya2VyKSB7IC8vIGxpbmUsIHNwbGluZSwgYXJlYSwgYXJlYXNwbGluZSwgc2NhdHRlclxuXG5cdFx0XHRcdC8vIGlmIG5vIGhvdmVyIHJhZGl1cyBpcyBnaXZlbiwgZGVmYXVsdCB0byBub3JtYWwgcmFkaXVzICsgMlxuXHRcdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5yYWRpdXMgPSBzdGF0ZU9wdGlvbnNIb3Zlci5yYWRpdXMgfHwgbm9ybWFsT3B0aW9ucy5yYWRpdXMgKyBzdGF0ZU9wdGlvbnNIb3Zlci5yYWRpdXNQbHVzO1xuXHRcdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5saW5lV2lkdGggPSBzdGF0ZU9wdGlvbnNIb3Zlci5saW5lV2lkdGggfHwgbm9ybWFsT3B0aW9ucy5saW5lV2lkdGggKyBzdGF0ZU9wdGlvbnNIb3Zlci5saW5lV2lkdGhQbHVzO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyBjb2x1bW4sIGJhciwgcGllXG5cblx0XHRcdFx0Ly8gaWYgbm8gaG92ZXIgY29sb3IgaXMgZ2l2ZW4sIGJyaWdodGVuIHRoZSBub3JtYWwgY29sb3Jcblx0XHRcdFx0c3RhdGVPcHRpb25zSG92ZXIuY29sb3IgPSBzdGF0ZU9wdGlvbnNIb3Zlci5jb2xvciB8fFxuXHRcdFx0XHRcdENvbG9yKHN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yIHx8IHNlcmllc0NvbG9yKVxuXHRcdFx0XHRcdFx0LmJyaWdodGVuKHN0YXRlT3B0aW9uc0hvdmVyLmJyaWdodG5lc3MpLmdldCgpO1xuXG5cdFx0XHRcdC8vIGlmIG5vIGhvdmVyIG5lZ2F0aXZlQ29sb3IgaXMgZ2l2ZW4sIGJyaWdodGVuIHRoZSBub3JtYWwgbmVnYXRpdmVDb2xvclxuXHRcdFx0XHRzdGF0ZU9wdGlvbnNIb3Zlci5uZWdhdGl2ZUNvbG9yID0gc3RhdGVPcHRpb25zSG92ZXIubmVnYXRpdmVDb2xvciB8fFxuXHRcdFx0XHRcdENvbG9yKHN0YXRlT3B0aW9uc0hvdmVyLm5lZ2F0aXZlQ29sb3IgfHwgc2VyaWVzTmVnYXRpdmVDb2xvcilcblx0XHRcdFx0XHRcdC5icmlnaHRlbihzdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzKS5nZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2VuZXJhbCBwb2ludCBhdHRyaWJ1dGVzIGZvciB0aGUgc2VyaWVzIG5vcm1hbCBzdGF0ZVxuXHRcdFx0c2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0gPSBzZXJpZXMuY29udmVydEF0dHJpYnMobm9ybWFsT3B0aW9ucywgbm9ybWFsRGVmYXVsdHMpO1xuXG5cdFx0XHQvLyBIT1ZFUl9TVEFURSBhbmQgU0VMRUNUX1NUQVRFIHN0YXRlcyBpbmhlcml0IGZyb20gbm9ybWFsIHN0YXRlIGV4Y2VwdCB0aGUgZGVmYXVsdCByYWRpdXNcblx0XHRcdGVhY2goW0hPVkVSX1NUQVRFLCBTRUxFQ1RfU1RBVEVdLCBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHRcdFx0c2VyaWVzUG9pbnRBdHRyW3N0YXRlXSA9XG5cdFx0XHRcdFx0XHRzZXJpZXMuY29udmVydEF0dHJpYnMoc3RhdGVPcHRpb25zW3N0YXRlXSwgc2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHNldCBpdFxuXHRcdFx0c2VyaWVzLnBvaW50QXR0ciA9IHNlcmllc1BvaW50QXR0cjtcblxuXG5cdFx0XHQvLyBHZW5lcmF0ZSB0aGUgcG9pbnQtc3BlY2lmaWMgYXR0cmlidXRlIGNvbGxlY3Rpb25zIGlmIHNwZWNpZmljIHBvaW50XG5cdFx0XHQvLyBvcHRpb25zIGFyZSBnaXZlbi4gSWYgbm90LCBjcmVhdGUgYSByZWZlcmFuY2UgdG8gdGhlIHNlcmllcyB3aWRlIHBvaW50XG5cdFx0XHQvLyBhdHRyaWJ1dGVzXG5cdFx0XHRpID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdGlmICghdHVyYm9UaHJlc2hvbGQgfHwgaSA8IHR1cmJvVGhyZXNob2xkIHx8IGhhc1BvaW50U3BlY2lmaWNPcHRpb25zKSB7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdFx0XHRub3JtYWxPcHRpb25zID0gKHBvaW50Lm9wdGlvbnMgJiYgcG9pbnQub3B0aW9ucy5tYXJrZXIpIHx8IHBvaW50Lm9wdGlvbnM7XG5cdFx0XHRcdFx0aWYgKG5vcm1hbE9wdGlvbnMgJiYgbm9ybWFsT3B0aW9ucy5lbmFibGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0bm9ybWFsT3B0aW9ucy5yYWRpdXMgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh6b25lcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHZhciBqID0gMCxcblx0XHRcdFx0XHRcdFx0dGhyZXNob2xkID0gem9uZXNbal07XG5cdFx0XHRcdFx0XHR3aGlsZSAocG9pbnRbem9uZUF4aXNdID49IHRocmVzaG9sZC52YWx1ZSkge1x0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHRocmVzaG9sZCA9IHpvbmVzWysral07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHBvaW50LmNvbG9yID0gcG9pbnQuZmlsbENvbG9yID0gdGhyZXNob2xkLmNvbG9yO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGhhc1BvaW50U3BlY2lmaWNPcHRpb25zID0gc2VyaWVzT3B0aW9ucy5jb2xvckJ5UG9pbnQgfHwgcG9pbnQuY29sb3I7IC8vICM4NjhcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSBwb2ludCBoYXMgc3BlY2lmaWMgdmlzdWFsIG9wdGlvbnNcblx0XHRcdFx0XHRpZiAocG9pbnQub3B0aW9ucykge1xuXHRcdFx0XHRcdFx0Zm9yIChrZXkgaW4gcG9pbnRBdHRyVG9PcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChkZWZpbmVkKG5vcm1hbE9wdGlvbnNbcG9pbnRBdHRyVG9PcHRpb25zW2tleV1dKSkge1xuXHRcdFx0XHRcdFx0XHRcdGhhc1BvaW50U3BlY2lmaWNPcHRpb25zID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGEgc3BlY2lmaWMgbWFya2VyIGNvbmZpZyBvYmplY3QgaXMgZGVmaW5lZCBmb3IgdGhlIGluZGl2aWR1YWwgcG9pbnQ6XG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGl0J3Mgb3duIGF0dHJpYnV0ZSBjb2xsZWN0aW9uXG5cdFx0XHRcdFx0aWYgKGhhc1BvaW50U3BlY2lmaWNPcHRpb25zKSB7XG5cdFx0XHRcdFx0XHRub3JtYWxPcHRpb25zID0gbm9ybWFsT3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0XHRcdHBvaW50QXR0ciA9IFtdO1xuXHRcdFx0XHRcdFx0c3RhdGVPcHRpb25zID0gbm9ybWFsT3B0aW9ucy5zdGF0ZXMgfHwge307IC8vIHJlYXNzaWduIGZvciBpbmRpdmlkdWFsIHBvaW50XG5cdFx0XHRcdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyID0gc3RhdGVPcHRpb25zW0hPVkVSX1NUQVRFXSA9IHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBjb2xvcnMgZm9yIGNvbHVtbiBhbmQgcGllc1xuXHRcdFx0XHRcdFx0aWYgKCFzZXJpZXNPcHRpb25zLm1hcmtlcikgeyAvLyBjb2x1bW4sIGJhciwgcG9pbnRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgbm8gaG92ZXIgY29sb3IgaXMgZ2l2ZW4sIGJyaWdodGVuIHRoZSBub3JtYWwgY29sb3IuICMxNjE5LCAjMjU3OVxuXHRcdFx0XHRcdFx0XHRwb2ludFN0YXRlT3B0aW9uc0hvdmVyLmNvbG9yID0gcG9pbnRTdGF0ZU9wdGlvbnNIb3Zlci5jb2xvciB8fCAoIXBvaW50Lm9wdGlvbnMuY29sb3IgJiYgc3RhdGVPcHRpb25zSG92ZXJbKHBvaW50Lm5lZ2F0aXZlICYmIHNlcmllc05lZ2F0aXZlQ29sb3IgPyAnbmVnYXRpdmVDb2xvcicgOiAnY29sb3InKV0pIHx8XG5cdFx0XHRcdFx0XHRcdFx0Q29sb3IocG9pbnQuY29sb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHQuYnJpZ2h0ZW4ocG9pbnRTdGF0ZU9wdGlvbnNIb3Zlci5icmlnaHRuZXNzIHx8IHN0YXRlT3B0aW9uc0hvdmVyLmJyaWdodG5lc3MpXG5cdFx0XHRcdFx0XHRcdFx0XHQuZ2V0KCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIG5vcm1hbCBwb2ludCBzdGF0ZSBpbmhlcml0cyBzZXJpZXMgd2lkZSBub3JtYWwgc3RhdGVcblx0XHRcdFx0XHRcdGF0dHIgPSB7IGNvbG9yOiBwb2ludC5jb2xvciB9OyAvLyAjODY4XG5cdFx0XHRcdFx0XHRpZiAoIWRlZmF1bHRGaWxsQ29sb3IpIHsgLy8gSW5kaXZpZHVhbCBwb2ludCBjb2xvciBvciBuZWdhdGl2ZSBjb2xvciBtYXJrZXJzICgjMjIxOSlcblx0XHRcdFx0XHRcdFx0YXR0ci5maWxsQ29sb3IgPSBwb2ludC5jb2xvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghZGVmYXVsdExpbmVDb2xvcikge1xuXHRcdFx0XHRcdFx0XHRhdHRyLmxpbmVDb2xvciA9IHBvaW50LmNvbG9yOyAvLyBCdWJibGVzIHRha2UgcG9pbnQgY29sb3IsIGxpbmUgbWFya2VycyB1c2Ugd2hpdGVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKGV4dGVuZChhdHRyLCBub3JtYWxPcHRpb25zKSwgc2VyaWVzUG9pbnRBdHRyW05PUk1BTF9TVEFURV0pO1xuXG5cdFx0XHRcdFx0XHQvLyBpbmhlcml0IGZyb20gcG9pbnQgbm9ybWFsIGFuZCBzZXJpZXMgaG92ZXJcblx0XHRcdFx0XHRcdHBvaW50QXR0cltIT1ZFUl9TVEFURV0gPSBzZXJpZXMuY29udmVydEF0dHJpYnMoXG5cdFx0XHRcdFx0XHRcdHN0YXRlT3B0aW9uc1tIT1ZFUl9TVEFURV0sXG5cdFx0XHRcdFx0XHRcdHNlcmllc1BvaW50QXR0cltIT1ZFUl9TVEFURV0sXG5cdFx0XHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBpbmhlcml0IGZyb20gcG9pbnQgbm9ybWFsIGFuZCBzZXJpZXMgaG92ZXJcblx0XHRcdFx0XHRcdHBvaW50QXR0cltTRUxFQ1RfU1RBVEVdID0gc2VyaWVzLmNvbnZlcnRBdHRyaWJzKFxuXHRcdFx0XHRcdFx0XHRzdGF0ZU9wdGlvbnNbU0VMRUNUX1NUQVRFXSxcblx0XHRcdFx0XHRcdFx0c2VyaWVzUG9pbnRBdHRyW1NFTEVDVF9TVEFURV0sXG5cdFx0XHRcdFx0XHRcdHBvaW50QXR0cltOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdFx0XHQpO1xuXG5cblx0XHRcdFx0XHQvLyBubyBtYXJrZXIgY29uZmlnIG9iamVjdCBpcyBjcmVhdGVkOiBjb3B5IGEgcmVmZXJlbmNlIHRvIHRoZSBzZXJpZXMtd2lkZVxuXHRcdFx0XHRcdC8vIGF0dHJpYnV0ZSBjb2xsZWN0aW9uXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvaW50QXR0ciA9IHNlcmllc1BvaW50QXR0cjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwb2ludC5wb2ludEF0dHIgPSBwb2ludEF0dHI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2xlYXIgRE9NIG9iamVjdHMgYW5kIGZyZWUgdXAgbWVtb3J5XG5cdFx0ICovXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRpc3N1ZTEzNCA9IC9BcHBsZVdlYktpdFxcLzUzMy8udGVzdCh1c2VyQWdlbnQpLFxuXHRcdFx0XHRkZXN0cm95LFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRkYXRhID0gc2VyaWVzLmRhdGEgfHwgW10sXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHRwcm9wLFxuXHRcdFx0XHRheGlzO1xuXG5cdFx0XHQvLyBhZGQgZXZlbnQgaG9va1xuXHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgJ2Rlc3Ryb3knKTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGFsbCBldmVudHNcblx0XHRcdHJlbW92ZUV2ZW50KHNlcmllcyk7XG5cblx0XHRcdC8vIGVyYXNlIGZyb20gYXhlc1xuXHRcdFx0ZWFjaChzZXJpZXMuYXhpc1R5cGVzIHx8IFtdLCBmdW5jdGlvbiAoQVhJUykge1xuXHRcdFx0XHRheGlzID0gc2VyaWVzW0FYSVNdO1xuXHRcdFx0XHRpZiAoYXhpcykge1xuXHRcdFx0XHRcdGVyYXNlKGF4aXMuc2VyaWVzLCBzZXJpZXMpO1xuXHRcdFx0XHRcdGF4aXMuaXNEaXJ0eSA9IGF4aXMuZm9yY2VSZWRyYXcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGxlZ2VuZCBpdGVtc1xuXHRcdFx0aWYgKHNlcmllcy5sZWdlbmRJdGVtKSB7XG5cdFx0XHRcdHNlcmllcy5jaGFydC5sZWdlbmQuZGVzdHJveUl0ZW0oc2VyaWVzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVzdHJveSBhbGwgcG9pbnRzIHdpdGggdGhlaXIgZWxlbWVudHNcblx0XHRcdGkgPSBkYXRhLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0cG9pbnQgPSBkYXRhW2ldO1xuXHRcdFx0XHRpZiAocG9pbnQgJiYgcG9pbnQuZGVzdHJveSkge1xuXHRcdFx0XHRcdHBvaW50LmRlc3Ryb3koKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VyaWVzLnBvaW50cyA9IG51bGw7XG5cblx0XHRcdC8vIENsZWFyIHRoZSBhbmltYXRpb24gdGltZW91dCBpZiB3ZSBhcmUgZGVzdHJveWluZyB0aGUgc2VyaWVzIGR1cmluZyBpbml0aWFsIGFuaW1hdGlvblxuXHRcdFx0Y2xlYXJUaW1lb3V0KHNlcmllcy5hbmltYXRpb25UaW1lb3V0KTtcblxuXHRcdFx0Ly8gZGVzdHJveSBhbGwgU1ZHRWxlbWVudHMgYXNzb2NpYXRlZCB0byB0aGUgc2VyaWVzXG5cdFx0XHRlYWNoKFsnYXJlYScsICdncmFwaCcsICdkYXRhTGFiZWxzR3JvdXAnLCAnZ3JvdXAnLCAnbWFya2VyR3JvdXAnLCAndHJhY2tlcicsXG5cdFx0XHRcdFx0J2dyYXBoTmVnJywgJ2FyZWFOZWcnLCAncG9zQ2xpcCcsICduZWdDbGlwJ10sIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdGlmIChzZXJpZXNbcHJvcF0pIHtcblxuXHRcdFx0XHRcdC8vIGlzc3VlIDEzNCB3b3JrYXJvdW5kXG5cdFx0XHRcdFx0ZGVzdHJveSA9IGlzc3VlMTM0ICYmIHByb3AgPT09ICdncm91cCcgP1xuXHRcdFx0XHRcdFx0J2hpZGUnIDpcblx0XHRcdFx0XHRcdCdkZXN0cm95JztcblxuXHRcdFx0XHRcdHNlcmllc1twcm9wXVtkZXN0cm95XSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGZyb20gaG92ZXJTZXJpZXNcblx0XHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyA9PT0gc2VyaWVzKSB7XG5cdFx0XHRcdGNoYXJ0LmhvdmVyU2VyaWVzID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGVyYXNlKGNoYXJ0LnNlcmllcywgc2VyaWVzKTtcblxuXHRcdFx0Ly8gY2xlYXIgYWxsIG1lbWJlcnNcblx0XHRcdGZvciAocHJvcCBpbiBzZXJpZXMpIHtcblx0XHRcdFx0ZGVsZXRlIHNlcmllc1twcm9wXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIHRoZSBncmFwaCBwYXRoIG9mIGEgc2VnbWVudFxuXHRcdCAqL1xuXHRcdGdldFNlZ21lbnRQYXRoOiBmdW5jdGlvbiAoc2VnbWVudCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHNlZ21lbnRQYXRoID0gW10sXG5cdFx0XHRcdHN0ZXAgPSBzZXJpZXMub3B0aW9ucy5zdGVwO1xuXG5cdFx0XHQvLyBidWlsZCB0aGUgc2VnbWVudCBsaW5lXG5cdFx0XHRlYWNoKHNlZ21lbnQsIGZ1bmN0aW9uIChwb2ludCwgaSkge1xuXG5cdFx0XHRcdHZhciBwbG90WCA9IHBvaW50LnBsb3RYLFxuXHRcdFx0XHRcdHBsb3RZID0gcG9pbnQucGxvdFksXG5cdFx0XHRcdFx0bGFzdFBvaW50O1xuXG5cdFx0XHRcdGlmIChzZXJpZXMuZ2V0UG9pbnRTcGxpbmUpIHsgLy8gZ2VuZXJhdGUgdGhlIHNwbGluZSBhcyBkZWZpbmVkIGluIHRoZSBTcGxpbmVTZXJpZXMgb2JqZWN0XG5cdFx0XHRcdFx0c2VnbWVudFBhdGgucHVzaC5hcHBseShzZWdtZW50UGF0aCwgc2VyaWVzLmdldFBvaW50U3BsaW5lKHNlZ21lbnQsIHBvaW50LCBpKSk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG1vdmVUbyBvciBsaW5lVG9cblx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKGkgPyBMIDogTSk7XG5cblx0XHRcdFx0XHQvLyBzdGVwIGxpbmU/XG5cdFx0XHRcdFx0aWYgKHN0ZXAgJiYgaSkge1xuXHRcdFx0XHRcdFx0bGFzdFBvaW50ID0gc2VnbWVudFtpIC0gMV07XG5cdFx0XHRcdFx0XHRpZiAoc3RlcCA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHRcdFx0XHRzZWdtZW50UGF0aC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RQb2ludC5wbG90WCxcblx0XHRcdFx0XHRcdFx0XHRwbG90WVxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0ZXAgPT09ICdjZW50ZXInKSB7XG5cdFx0XHRcdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0KGxhc3RQb2ludC5wbG90WCArIHBsb3RYKSAvIDIsXG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdFx0XHRcdChsYXN0UG9pbnQucGxvdFggKyBwbG90WCkgLyAyLFxuXHRcdFx0XHRcdFx0XHRcdHBsb3RZXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFgsXG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBvaW50LnBsb3RZXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbm9ybWFsIGxpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdHNlZ21lbnRQYXRoLnB1c2goXG5cdFx0XHRcdFx0XHRwb2ludC5wbG90WCxcblx0XHRcdFx0XHRcdHBvaW50LnBsb3RZXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBzZWdtZW50UGF0aDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBncmFwaCBwYXRoXG5cdFx0ICovXG5cdFx0Z2V0R3JhcGhQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Z3JhcGhQYXRoID0gW10sXG5cdFx0XHRcdHNlZ21lbnRQYXRoLFxuXHRcdFx0XHRzaW5nbGVQb2ludHMgPSBbXTsgLy8gdXNlZCBpbiBkcmF3VHJhY2tlclxuXG5cdFx0XHQvLyBEaXZpZGUgaW50byBzZWdtZW50cyBhbmQgYnVpbGQgZ3JhcGggYW5kIGFyZWEgcGF0aHNcblx0XHRcdGVhY2goc2VyaWVzLnNlZ21lbnRzLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuXG5cdFx0XHRcdHNlZ21lbnRQYXRoID0gc2VyaWVzLmdldFNlZ21lbnRQYXRoKHNlZ21lbnQpO1xuXG5cdFx0XHRcdC8vIGFkZCB0aGUgc2VnbWVudCB0byB0aGUgZ3JhcGgsIG9yIGEgc2luZ2xlIHBvaW50IGZvciB0cmFja2luZ1xuXHRcdFx0XHRpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0Z3JhcGhQYXRoID0gZ3JhcGhQYXRoLmNvbmNhdChzZWdtZW50UGF0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2luZ2xlUG9pbnRzLnB1c2goc2VnbWVudFswXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBSZWNvcmQgaXQgZm9yIHVzZSBpbiBkcmF3R3JhcGggYW5kIGRyYXdUcmFja2VyLCBhbmQgcmV0dXJuIGdyYXBoUGF0aFxuXHRcdFx0c2VyaWVzLnNpbmdsZVBvaW50cyA9IHNpbmdsZVBvaW50cztcblx0XHRcdHNlcmllcy5ncmFwaFBhdGggPSBncmFwaFBhdGg7XG5cblx0XHRcdHJldHVybiBncmFwaFBhdGg7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRHJhdyB0aGUgYWN0dWFsIGdyYXBoXG5cdFx0ICovXG5cdFx0ZHJhd0dyYXBoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0cHJvcHMgPSBbWydncmFwaCcsIG9wdGlvbnMubGluZUNvbG9yIHx8IHRoaXMuY29sb3IsIG9wdGlvbnMuZGFzaFN0eWxlXV0sXG5cdFx0XHRcdGxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoLFxuXHRcdFx0XHRyb3VuZENhcCA9IG9wdGlvbnMubGluZWNhcCAhPT0gJ3NxdWFyZScsXG5cdFx0XHRcdGdyYXBoUGF0aCA9IHRoaXMuZ2V0R3JhcGhQYXRoKCksXG5cdFx0XHRcdGZpbGxDb2xvciA9ICh0aGlzLmZpbGxHcmFwaCAmJiB0aGlzLmNvbG9yKSB8fCBOT05FLCAvLyBwb2x5Z29uIHNlcmllcyB1c2UgZmlsbGVkIGdyYXBoXG5cdFx0XHRcdHpvbmVzID0gdGhpcy56b25lcztcblxuXHRcdFx0ZWFjaCh6b25lcywgZnVuY3Rpb24gKHRocmVzaG9sZCwgaSkge1xuXHRcdFx0XHRwcm9wcy5wdXNoKFsnY29sb3JHcmFwaCcgKyBpLCB0aHJlc2hvbGQuY29sb3IgfHwgc2VyaWVzLmNvbG9yLCB0aHJlc2hvbGQuZGFzaFN0eWxlIHx8IG9wdGlvbnMuZGFzaFN0eWxlXSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly8gRHJhdyB0aGUgZ3JhcGhcblx0XHRcdGVhY2gocHJvcHMsIGZ1bmN0aW9uIChwcm9wLCBpKSB7XG5cdFx0XHRcdHZhciBncmFwaEtleSA9IHByb3BbMF0sXG5cdFx0XHRcdFx0Z3JhcGggPSBzZXJpZXNbZ3JhcGhLZXldLFxuXHRcdFx0XHRcdGF0dHJpYnM7XG5cblx0XHRcdFx0aWYgKGdyYXBoKSB7XG5cdFx0XHRcdFx0c3RvcChncmFwaCk7IC8vIGNhbmNlbCBydW5uaW5nIGFuaW1hdGlvbnMsICM0NTlcblx0XHRcdFx0XHRncmFwaC5hbmltYXRlKHsgZDogZ3JhcGhQYXRoIH0pO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoKGxpbmVXaWR0aCB8fCBmaWxsQ29sb3IpICYmIGdyYXBoUGF0aC5sZW5ndGgpIHsgLy8gIzE0ODdcblx0XHRcdFx0XHRhdHRyaWJzID0ge1xuXHRcdFx0XHRcdFx0c3Ryb2tlOiBwcm9wWzFdLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGxpbmVXaWR0aCxcblx0XHRcdFx0XHRcdGZpbGw6IGZpbGxDb2xvcixcblx0XHRcdFx0XHRcdHpJbmRleDogMSAvLyAjMTA2OVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKHByb3BbMl0pIHtcblx0XHRcdFx0XHRcdGF0dHJpYnMuZGFzaHN0eWxlID0gcHJvcFsyXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJvdW5kQ2FwKSB7XG5cdFx0XHRcdFx0XHRhdHRyaWJzWydzdHJva2UtbGluZWNhcCddID0gYXR0cmlic1snc3Ryb2tlLWxpbmVqb2luJ10gPSAncm91bmQnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNlcmllc1tncmFwaEtleV0gPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIucGF0aChncmFwaFBhdGgpXG5cdFx0XHRcdFx0XHQuYXR0cihhdHRyaWJzKVxuXHRcdFx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApXG5cdFx0XHRcdFx0XHQuc2hhZG93KChpIDwgMikgJiYgb3B0aW9ucy5zaGFkb3cpOyAvLyBhZGQgc2hhZG93IHRvIG5vcm1hbCBzZXJpZXMgKDApIG9yIHRvIGZpcnN0IHpvbmUgKDEpICMzOTMyXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDbGlwIHRoZSBncmFwaHMgaW50byB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGNvbG91cmVkIGdyYXBoc1xuXHRcdCAqL1xuXHRcdGFwcGx5Wm9uZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdHJlbmRlcmVyID0gY2hhcnQucmVuZGVyZXIsXG5cdFx0XHRcdHpvbmVzID0gdGhpcy56b25lcyxcblx0XHRcdFx0dHJhbnNsYXRlZEZyb20sXG5cdFx0XHRcdHRyYW5zbGF0ZWRUbyxcblx0XHRcdFx0Y2xpcHMgPSB0aGlzLmNsaXBzIHx8IFtdLFxuXHRcdFx0XHRjbGlwQXR0cixcblx0XHRcdFx0Z3JhcGggPSB0aGlzLmdyYXBoLFxuXHRcdFx0XHRhcmVhID0gdGhpcy5hcmVhLFxuXHRcdFx0XHRjaGFydFNpemVNYXggPSBtYXRoTWF4KGNoYXJ0LmNoYXJ0V2lkdGgsIGNoYXJ0LmNoYXJ0SGVpZ2h0KSxcblx0XHRcdFx0em9uZUF4aXMgPSB0aGlzLnpvbmVBeGlzIHx8ICd5Jyxcblx0XHRcdFx0YXhpcyA9IHRoaXNbem9uZUF4aXMgKyAnQXhpcyddLFxuXHRcdFx0XHRyZXZlcnNlZCA9IGF4aXMucmV2ZXJzZWQsXG5cdFx0XHRcdGhvcml6ID0gYXhpcy5ob3Jpeixcblx0XHRcdFx0aWdub3JlWm9uZXMgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHpvbmVzLmxlbmd0aCAmJiAoZ3JhcGggfHwgYXJlYSkpIHtcblx0XHRcdFx0Ly8gVGhlIHVzZSBvZiB0aGUgQ29sb3IgVGhyZXNob2xkIGFzc3VtZXMgdGhlcmUgYXJlIG5vIGdhcHNcblx0XHRcdFx0Ly8gc28gaXQgaXMgc2FmZSB0byBoaWRlIHRoZSBvcmlnaW5hbCBncmFwaCBhbmQgYXJlYVxuXHRcdFx0XHRncmFwaC5oaWRlKCk7XG5cdFx0XHRcdGlmIChhcmVhKSB7IGFyZWEuaGlkZSgpOyB9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBjbGlwc1xuXHRcdFx0XHRlYWNoKHpvbmVzLCBmdW5jdGlvbiAodGhyZXNob2xkLCBpKSB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlZEZyb20gPSBwaWNrKHRyYW5zbGF0ZWRUbywgKHJldmVyc2VkID8gKGhvcml6ID8gY2hhcnQucGxvdFdpZHRoIDogMCkgOiAoaG9yaXogPyAwIDogYXhpcy50b1BpeGVscyhheGlzLm1pbikpKSk7XG5cdFx0XHRcdFx0dHJhbnNsYXRlZFRvID0gbWF0aFJvdW5kKGF4aXMudG9QaXhlbHMocGljayh0aHJlc2hvbGQudmFsdWUsIGF4aXMubWF4KSwgdHJ1ZSkpO1xuXG5cdFx0XHRcdFx0aWYgKGlnbm9yZVpvbmVzKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2xhdGVkRnJvbSA9IHRyYW5zbGF0ZWRUbyA9IGF4aXMudG9QaXhlbHMoYXhpcy5tYXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChheGlzLmlzWEF4aXMpIHtcblx0XHRcdFx0XHRcdGNsaXBBdHRyID0ge1xuXHRcdFx0XHRcdFx0XHR4OiByZXZlcnNlZCA/IHRyYW5zbGF0ZWRUbyA6IHRyYW5zbGF0ZWRGcm9tLFxuXHRcdFx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogTWF0aC5hYnModHJhbnNsYXRlZEZyb20gLSB0cmFuc2xhdGVkVG8pLCBcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBjaGFydFNpemVNYXhcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRpZiAoIWhvcml6KSB7XG5cdFx0XHRcdFx0XHRcdGNsaXBBdHRyLnggPSBjaGFydC5wbG90SGVpZ2h0IC0gY2xpcEF0dHIueDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xpcEF0dHIgPSB7XG5cdFx0XHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0XHRcdHk6IHJldmVyc2VkID8gdHJhbnNsYXRlZEZyb20gOiB0cmFuc2xhdGVkVG8sXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBjaGFydFNpemVNYXgsIFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IE1hdGguYWJzKHRyYW5zbGF0ZWRGcm9tIC0gdHJhbnNsYXRlZFRvKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGlmIChob3Jpeikge1xuXHRcdFx0XHRcdFx0XHRjbGlwQXR0ci55ID0gY2hhcnQucGxvdFdpZHRoIC0gY2xpcEF0dHIueTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IFxuXG5cdFx0XHRcdFx0Ly8vIFZNTCBTVVBQUE9SVFxuXHRcdFx0XHRcdGlmIChjaGFydC5pbnZlcnRlZCAmJiByZW5kZXJlci5pc1ZNTCkge1xuXHRcdFx0XHRcdFx0aWYgKGF4aXMuaXNYQXhpcykge1x0XHRcdFxuXHRcdFx0XHRcdFx0XHRjbGlwQXR0ciA9IHtcblx0XHRcdFx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdFx0XHRcdHk6IHJldmVyc2VkID8gdHJhbnNsYXRlZEZyb20gOiB0cmFuc2xhdGVkVG8sXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBjbGlwQXR0ci53aWR0aCxcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQuY2hhcnRXaWR0aFxuXHRcdFx0XHRcdFx0XHR9O1x0XHRcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y2xpcEF0dHIgPSB7XG5cdFx0XHRcdFx0XHRcdFx0eDogY2xpcEF0dHIueSAtIGNoYXJ0LnBsb3RMZWZ0IC0gY2hhcnQuc3BhY2luZ0JveC54LFxuXHRcdFx0XHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6IGNsaXBBdHRyLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGNoYXJ0LmNoYXJ0SGVpZ2h0XG5cdFx0XHRcdFx0XHRcdH07XHRcblx0XHRcdFx0XHRcdH1cdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLy8gRU5EIE9GIFZNTCBTVVBQT1JUXG5cblx0XHRcdFx0XHRpZiAoY2xpcHNbaV0pIHtcblx0XHRcdFx0XHRcdGNsaXBzW2ldLmFuaW1hdGUoY2xpcEF0dHIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbGlwc1tpXSA9IHJlbmRlcmVyLmNsaXBSZWN0KGNsaXBBdHRyKTtcblxuXHRcdFx0XHRcdFx0c2VyaWVzWydjb2xvckdyYXBoJyArIGldLmNsaXAoY2xpcHNbaV0pO1xuXG5cdFx0XHRcdFx0XHRpZiAoYXJlYSkge1xuXHRcdFx0XHRcdFx0XHRzZXJpZXNbJ2NvbG9yQXJlYScgKyBpXS5jbGlwKGNsaXBzW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyB6b25lIGV4dGVuZHMgb3V0IG9mIHRoZSBheGlzLCBpZ25vcmUgdGhlIG90aGVyc1xuXHRcdFx0XHRcdGlnbm9yZVpvbmVzID0gdGhyZXNob2xkLnZhbHVlID4gYXhpcy5tYXg7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLmNsaXBzID0gY2xpcHM7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgYW5kIHBlcmZvcm0gZ3JvdXAgaW52ZXJzaW9uIG9uIHNlcmllcy5ncm91cCBhbmQgc2VyaWVzLm1hcmtlckdyb3VwXG5cdFx0ICovXG5cdFx0aW52ZXJ0R3JvdXBzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cblx0XHRcdC8vIFBpZSwgZ28gYXdheSAoIzE3MzYpXG5cdFx0XHRpZiAoIXNlcmllcy54QXhpcykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEEgZml4ZWQgc2l6ZSBpcyBuZWVkZWQgZm9yIGludmVyc2lvbiB0byB3b3JrXG5cdFx0XHRmdW5jdGlvbiBzZXRJbnZlcnQoKSB7XG5cdFx0XHRcdHZhciBzaXplID0ge1xuXHRcdFx0XHRcdHdpZHRoOiBzZXJpZXMueUF4aXMubGVuLFxuXHRcdFx0XHRcdGhlaWdodDogc2VyaWVzLnhBeGlzLmxlblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGVhY2goWydncm91cCcsICdtYXJrZXJHcm91cCddLCBmdW5jdGlvbiAoZ3JvdXBOYW1lKSB7XG5cdFx0XHRcdFx0aWYgKHNlcmllc1tncm91cE5hbWVdKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXNbZ3JvdXBOYW1lXS5hdHRyKHNpemUpLmludmVydCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGFkZEV2ZW50KGNoYXJ0LCAncmVzaXplJywgc2V0SW52ZXJ0KTsgLy8gZG8gaXQgb24gcmVzaXplXG5cdFx0XHRhZGRFdmVudChzZXJpZXMsICdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZW1vdmVFdmVudChjaGFydCwgJ3Jlc2l6ZScsIHNldEludmVydCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRG8gaXQgbm93XG5cdFx0XHRzZXRJbnZlcnQoKTsgLy8gZG8gaXQgbm93XG5cblx0XHRcdC8vIE9uIHN1YnNlcXVlbnQgcmVuZGVyIGFuZCByZWRyYXcsIGp1c3QgZG8gc2V0SW52ZXJ0IHdpdGhvdXQgc2V0dGluZyB1cCBldmVudHMgYWdhaW5cblx0XHRcdHNlcmllcy5pbnZlcnRHcm91cHMgPSBzZXRJbnZlcnQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYWwgYWJzdHJhY3Rpb24gZm9yIGNyZWF0aW5nIHBsb3QgZ3JvdXBzIGxpa2Ugc2VyaWVzLmdyb3VwLCBzZXJpZXMuZGF0YUxhYmVsc0dyb3VwIGFuZFxuXHRcdCAqIHNlcmllcy5tYXJrZXJHcm91cC4gT24gc3Vic2VxdWVudCBjYWxscywgdGhlIGdyb3VwIHdpbGwgb25seSBiZSBhZGp1c3RlZCB0byB0aGUgdXBkYXRlZCBwbG90IHNpemUuXG5cdFx0ICovXG5cdFx0cGxvdEdyb3VwOiBmdW5jdGlvbiAocHJvcCwgbmFtZSwgdmlzaWJpbGl0eSwgekluZGV4LCBwYXJlbnQpIHtcblx0XHRcdHZhciBncm91cCA9IHRoaXNbcHJvcF0sXG5cdFx0XHRcdGlzTmV3ID0gIWdyb3VwO1xuXG5cdFx0XHQvLyBHZW5lcmF0ZSBpdCBvbiBmaXJzdCBjYWxsXG5cdFx0XHRpZiAoaXNOZXcpIHtcblx0XHRcdFx0dGhpc1twcm9wXSA9IGdyb3VwID0gdGhpcy5jaGFydC5yZW5kZXJlci5nKG5hbWUpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0dmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcblx0XHRcdFx0XHRcdHpJbmRleDogekluZGV4IHx8IDAuMSAvLyBJRTggbmVlZHMgdGhpc1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZChwYXJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUGxhY2UgaXQgb24gZmlyc3QgYW5kIHN1YnNlcXVlbnQgKHJlZHJhdykgY2FsbHNcblx0XHRcdGdyb3VwW2lzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXSh0aGlzLmdldFBsb3RCb3goKSk7XG5cdFx0XHRyZXR1cm4gZ3JvdXA7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgdHJhbnNsYXRpb24gYW5kIHNjYWxlIGZvciB0aGUgcGxvdCBhcmVhIG9mIHRoaXMgc2VyaWVzXG5cdFx0ICovXG5cdFx0Z2V0UGxvdEJveDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0eEF4aXMgPSB0aGlzLnhBeGlzLFxuXHRcdFx0XHR5QXhpcyA9IHRoaXMueUF4aXM7XG5cblx0XHRcdC8vIFN3YXAgYXhlcyBmb3IgaW52ZXJ0ZWQgKCMyMzM5KVxuXHRcdFx0aWYgKGNoYXJ0LmludmVydGVkKSB7XG5cdFx0XHRcdHhBeGlzID0geUF4aXM7XG5cdFx0XHRcdHlBeGlzID0gdGhpcy54QXhpcztcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRyYW5zbGF0ZVg6IHhBeGlzID8geEF4aXMubGVmdCA6IGNoYXJ0LnBsb3RMZWZ0LFxuXHRcdFx0XHR0cmFuc2xhdGVZOiB5QXhpcyA/IHlBeGlzLnRvcCA6IGNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdHNjYWxlWDogMSwgLy8gIzE2MjNcblx0XHRcdFx0c2NhbGVZOiAxXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZW5kZXIgdGhlIGdyYXBoIGFuZCBtYXJrZXJzXG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdGdyb3VwLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLFxuXHRcdFx0XHQvLyBBbmltYXRpb24gZG9lc24ndCB3b3JrIGluIElFOCBxdWlya3Mgd2hlbiB0aGUgZ3JvdXAgZGl2IGlzIGhpZGRlbixcblx0XHRcdFx0Ly8gYW5kIGxvb2tzIGJhZCBpbiBvdGhlciBvbGRJRVxuXHRcdFx0XHRhbmltRHVyYXRpb24gPSAoYW5pbWF0aW9uICYmICEhc2VyaWVzLmFuaW1hdGUgJiYgY2hhcnQucmVuZGVyZXIuaXNTVkcgJiYgcGljayhhbmltYXRpb24uZHVyYXRpb24sIDUwMCkpIHx8IDAsXG5cdFx0XHRcdHZpc2liaWxpdHkgPSBzZXJpZXMudmlzaWJsZSA/IFZJU0lCTEUgOiBISURERU4sXG5cdFx0XHRcdHpJbmRleCA9IG9wdGlvbnMuekluZGV4LFxuXHRcdFx0XHRoYXNSZW5kZXJlZCA9IHNlcmllcy5oYXNSZW5kZXJlZCxcblx0XHRcdFx0Y2hhcnRTZXJpZXNHcm91cCA9IGNoYXJ0LnNlcmllc0dyb3VwO1xuXG5cdFx0XHQvLyB0aGUgZ3JvdXBcblx0XHRcdGdyb3VwID0gc2VyaWVzLnBsb3RHcm91cChcblx0XHRcdFx0J2dyb3VwJyxcblx0XHRcdFx0J3NlcmllcycsXG5cdFx0XHRcdHZpc2liaWxpdHksXG5cdFx0XHRcdHpJbmRleCxcblx0XHRcdFx0Y2hhcnRTZXJpZXNHcm91cFxuXHRcdFx0KTtcblxuXHRcdFx0c2VyaWVzLm1hcmtlckdyb3VwID0gc2VyaWVzLnBsb3RHcm91cChcblx0XHRcdFx0J21hcmtlckdyb3VwJyxcblx0XHRcdFx0J21hcmtlcnMnLFxuXHRcdFx0XHR2aXNpYmlsaXR5LFxuXHRcdFx0XHR6SW5kZXgsXG5cdFx0XHRcdGNoYXJ0U2VyaWVzR3JvdXBcblx0XHRcdCk7XG5cblx0XHRcdC8vIGluaXRpYXRlIHRoZSBhbmltYXRpb25cblx0XHRcdGlmIChhbmltRHVyYXRpb24pIHtcblx0XHRcdFx0c2VyaWVzLmFuaW1hdGUodHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhY2hlIGF0dHJpYnV0ZXMgZm9yIHNoYXBlc1xuXHRcdFx0c2VyaWVzLmdldEF0dHJpYnMoKTtcblxuXHRcdFx0Ly8gU1ZHUmVuZGVyZXIgbmVlZHMgdG8ga25vdyB0aGlzIGJlZm9yZSBkcmF3aW5nIGVsZW1lbnRzICgjMTA4OSwgIzE3OTUpXG5cdFx0XHRncm91cC5pbnZlcnRlZCA9IHNlcmllcy5pc0NhcnRlc2lhbiA/IGNoYXJ0LmludmVydGVkIDogZmFsc2U7XG5cblx0XHRcdC8vIGRyYXcgdGhlIGdyYXBoIGlmIGFueVxuXHRcdFx0aWYgKHNlcmllcy5kcmF3R3JhcGgpIHtcblx0XHRcdFx0c2VyaWVzLmRyYXdHcmFwaCgpO1xuXHRcdFx0XHRzZXJpZXMuYXBwbHlab25lcygpO1xuXHRcdFx0fVxuXG5cdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRpZiAocG9pbnQucmVkcmF3KSB7XG5cdFx0XHRcdFx0cG9pbnQucmVkcmF3KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBkcmF3IHRoZSBkYXRhIGxhYmVscyAoaW5uIHBpZXMgdGhleSBnbyBiZWZvcmUgdGhlIHBvaW50cylcblx0XHRcdGlmIChzZXJpZXMuZHJhd0RhdGFMYWJlbHMpIHtcblx0XHRcdFx0c2VyaWVzLmRyYXdEYXRhTGFiZWxzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRyYXcgdGhlIHBvaW50c1xuXHRcdFx0aWYgKHNlcmllcy52aXNpYmxlKSB7XG5cdFx0XHRcdHNlcmllcy5kcmF3UG9pbnRzKCk7XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gZHJhdyB0aGUgbW91c2UgdHJhY2tpbmcgYXJlYVxuXHRcdFx0aWYgKHNlcmllcy5kcmF3VHJhY2tlciAmJiBzZXJpZXMub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nICE9PSBmYWxzZSkge1xuXHRcdFx0XHRzZXJpZXMuZHJhd1RyYWNrZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIGludmVydGVkIHNlcmllcyBhbmQgdHJhY2tlciBncm91cHNcblx0XHRcdGlmIChjaGFydC5pbnZlcnRlZCkge1xuXHRcdFx0XHRzZXJpZXMuaW52ZXJ0R3JvdXBzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluaXRpYWwgY2xpcHBpbmcsIG11c3QgYmUgZGVmaW5lZCBhZnRlciBpbnZlcnRpbmcgZ3JvdXBzIGZvciBWTUwuIEFwcGxpZXMgdG8gY29sdW1ucyBldGMuICgjMzgzOSkuXG5cdFx0XHRpZiAob3B0aW9ucy5jbGlwICE9PSBmYWxzZSAmJiAhc2VyaWVzLnNoYXJlZENsaXBLZXkgJiYgIWhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdGdyb3VwLmNsaXAoY2hhcnQuY2xpcFJlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSdW4gdGhlIGFuaW1hdGlvblxuXHRcdFx0aWYgKGFuaW1EdXJhdGlvbikge1xuXHRcdFx0XHRzZXJpZXMuYW5pbWF0ZSgpO1xuXHRcdFx0fSBcblxuXHRcdFx0Ly8gQ2FsbCB0aGUgYWZ0ZXJBbmltYXRlIGZ1bmN0aW9uIG9uIGFuaW1hdGlvbiBjb21wbGV0ZSAoYnV0IGRvbid0IG92ZXJ3cml0ZSB0aGUgYW5pbWF0aW9uLmNvbXBsZXRlIG9wdGlvblxuXHRcdFx0Ly8gd2hpY2ggc2hvdWxkIGJlIGF2YWlsYWJsZSB0byB0aGUgdXNlcikuXG5cdFx0XHRpZiAoIWhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdGlmIChhbmltRHVyYXRpb24pIHtcblx0XHRcdFx0XHRzZXJpZXMuYW5pbWF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0c2VyaWVzLmFmdGVyQW5pbWF0ZSgpO1xuXHRcdFx0XHRcdH0sIGFuaW1EdXJhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VyaWVzLmFmdGVyQW5pbWF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy5pc0RpcnR5ID0gc2VyaWVzLmlzRGlydHlEYXRhID0gZmFsc2U7IC8vIG1lYW5zIGRhdGEgaXMgaW4gYWNjb3JkYW5jZSB3aXRoIHdoYXQgeW91IHNlZVxuXHRcdFx0Ly8gKFNlZSAjMzIyKSBzZXJpZXMuaXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5RGF0YSA9IGZhbHNlOyAvLyBtZWFucyBkYXRhIGlzIGluIGFjY29yZGFuY2Ugd2l0aCB3aGF0IHlvdSBzZWVcblx0XHRcdHNlcmllcy5oYXNSZW5kZXJlZCA9IHRydWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZHJhdyB0aGUgc2VyaWVzIGFmdGVyIGFuIHVwZGF0ZSBpbiB0aGUgYXhlcy5cblx0XHQgKi9cblx0XHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0d2FzRGlydHlEYXRhID0gc2VyaWVzLmlzRGlydHlEYXRhLCAvLyBjYWNoZSBpdCBoZXJlIGFzIGl0IGlzIHNldCB0byBmYWxzZSBpbiByZW5kZXIsIGJ1dCB1c2VkIGFmdGVyXG5cdFx0XHRcdHdhc0RpcnR5ID0gc2VyaWVzLmlzRGlydHksXG5cdFx0XHRcdGdyb3VwID0gc2VyaWVzLmdyb3VwLFxuXHRcdFx0XHR4QXhpcyA9IHNlcmllcy54QXhpcyxcblx0XHRcdFx0eUF4aXMgPSBzZXJpZXMueUF4aXM7XG5cblx0XHRcdC8vIHJlcG9zaXRpb24gb24gcmVzaXplXG5cdFx0XHRpZiAoZ3JvdXApIHtcblx0XHRcdFx0aWYgKGNoYXJ0LmludmVydGVkKSB7XG5cdFx0XHRcdFx0Z3JvdXAuYXR0cih7XG5cdFx0XHRcdFx0XHR3aWR0aDogY2hhcnQucGxvdFdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBjaGFydC5wbG90SGVpZ2h0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRncm91cC5hbmltYXRlKHtcblx0XHRcdFx0XHR0cmFuc2xhdGVYOiBwaWNrKHhBeGlzICYmIHhBeGlzLmxlZnQsIGNoYXJ0LnBsb3RMZWZ0KSxcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiBwaWNrKHlBeGlzICYmIHlBeGlzLnRvcCwgY2hhcnQucGxvdFRvcClcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHNlcmllcy50cmFuc2xhdGUoKTtcblx0XHRcdHNlcmllcy5yZW5kZXIoKTtcblx0XHRcdGlmICh3YXNEaXJ0eURhdGEpIHtcblx0XHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgJ3VwZGF0ZWREYXRhJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAod2FzRGlydHkgfHwgd2FzRGlydHlEYXRhKSB7XHRcdFx0Ly8gIzM5NDUgcmVjYWxjdWxhdGUgdGhlIGtkdHJlZSB3aGVuIGRpcnR5XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmtkVHJlZTsgLy8gIzM4NjggcmVjYWxjdWxhdGUgdGhlIGtkdHJlZSB3aXRoIGRpcnR5IGRhdGFcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogS0QgVHJlZSAmJiBQb2ludFNlYXJjaGluZyBJbXBsZW1lbnRhdGlvblxuXHRcdCAqL1xuXG5cdFx0a2REaW1lbnNpb25zOiAxLFxuXHRcdGtkVHJlZTogbnVsbCxcblx0XHRrZEF4aXNBcnJheTogWydjbGllbnRYJywgJ3Bsb3RZJ10sXG5cdFx0a2RDb21wYXJlcjogJ2Rpc3RYJyxcblxuXHRcdHNlYXJjaFBvaW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdFx0aW52ZXJ0ZWQgPSBzZXJpZXMuY2hhcnQuaW52ZXJ0ZWQ7XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnNlYXJjaEtEVHJlZSh7XG5cdFx0XHRcdGNsaWVudFg6IGludmVydGVkID8geEF4aXMubGVuIC0gZS5jaGFydFkgKyB4QXhpcy5wb3MgOiBlLmNoYXJ0WCAtIHhBeGlzLnBvcyxcblx0XHRcdFx0cGxvdFk6IGludmVydGVkID8geUF4aXMubGVuIC0gZS5jaGFydFggKyB5QXhpcy5wb3MgOiBlLmNoYXJ0WSAtIHlBeGlzLnBvc1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGJ1aWxkS0RUcmVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0ZGltZW5zaW9ucyA9IHNlcmllcy5rZERpbWVuc2lvbnM7XG5cblx0XHRcdC8vIEludGVybmFsIGZ1bmN0aW9uXG5cdFx0XHRmdW5jdGlvbiBfa2R0cmVlKHBvaW50cywgZGVwdGgsIGRpbWVuc2lvbnMpIHtcblx0XHRcdFx0dmFyIGF4aXMsIG1lZGlhbiwgbGVuZ3RoID0gcG9pbnRzICYmIHBvaW50cy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKGxlbmd0aCkge1xuXG5cdFx0XHRcdFx0Ly8gYWx0ZXJuYXRlIGJldHdlZW4gdGhlIGF4aXNcblx0XHRcdFx0XHRheGlzID0gc2VyaWVzLmtkQXhpc0FycmF5W2RlcHRoICUgZGltZW5zaW9uc107XG5cblx0XHRcdFx0XHQvLyBzb3J0IHBvaW50IGFycmF5XG5cdFx0XHRcdFx0cG9pbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFbYXhpc10gLSBiW2F4aXNdO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0XHRtZWRpYW4gPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGJ1aWxkIGFuZCByZXR1cm4gbm9kZVxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRwb2ludDogcG9pbnRzW21lZGlhbl0sXG5cdFx0XHRcdFx0XHRsZWZ0OiBfa2R0cmVlKHBvaW50cy5zbGljZSgwLCBtZWRpYW4pLCBkZXB0aCArIDEsIGRpbWVuc2lvbnMpLFxuXHRcdFx0XHRcdFx0cmlnaHQ6IF9rZHRyZWUocG9pbnRzLnNsaWNlKG1lZGlhbiArIDEpLCBkZXB0aCArIDEsIGRpbWVuc2lvbnMpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIHJlY3Vyc2l2ZSBidWlsZCBwcm9jZXNzIHdpdGggYSBjbG9uZSBvZiB0aGUgcG9pbnRzIGFycmF5IGFuZCBudWxsIHBvaW50cyBmaWx0ZXJlZCBvdXQgKCMzODczKVxuXHRcdFx0ZnVuY3Rpb24gc3RhcnRSZWN1cnNpdmUoKSB7XG5cdFx0XHRcdHZhciBwb2ludHMgPSBncmVwKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdHJldHVybiBwb2ludC55ICE9PSBudWxsO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2VyaWVzLmtkVHJlZSA9IF9rZHRyZWUocG9pbnRzLCBkaW1lbnNpb25zLCBkaW1lbnNpb25zKTtcdFx0XG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBzZXJpZXMua2RUcmVlO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2VyaWVzLm9wdGlvbnMua2RTeW5jKSB7ICAvLyBGb3IgdGVzdGluZyB0b29sdGlwcywgZG9uJ3QgYnVpbGQgYXN5bmNcblx0XHRcdFx0c3RhcnRSZWN1cnNpdmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoc3RhcnRSZWN1cnNpdmUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZWFyY2hLRFRyZWU6IGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGtkQ29tcGFyZXIgPSB0aGlzLmtkQ29tcGFyZXIsXG5cdFx0XHRcdGtkWCA9IHRoaXMua2RBeGlzQXJyYXlbMF0sXG5cdFx0XHRcdGtkWSA9IHRoaXMua2RBeGlzQXJyYXlbMV07XG5cblx0XHRcdC8vIEludGVybmFsIGZ1bmN0aW9uXG5cdFx0XHRmdW5jdGlvbiBfZGlzdGFuY2UocDEsIHAyKSB7XG5cdFx0XHRcdHZhciB4ID0gKGRlZmluZWQocDFba2RYXSkgJiYgZGVmaW5lZChwMltrZFhdKSkgPyBNYXRoLnBvdyhwMVtrZFhdIC0gcDJba2RYXSwgMikgOiBudWxsLFxuXHRcdFx0XHRcdHkgPSAoZGVmaW5lZChwMVtrZFldKSAmJiBkZWZpbmVkKHAyW2tkWV0pKSA/IE1hdGgucG93KHAxW2tkWV0gLSBwMltrZFldLCAyKSA6IG51bGwsXG5cdFx0XHRcdFx0ciA9ICh4IHx8IDApICsgKHkgfHwgMCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZGlzdFg6IGRlZmluZWQoeCkgPyBNYXRoLnNxcnQoeCkgOiBOdW1iZXIuTUFYX1ZBTFVFLFxuXHRcdFx0XHRcdGRpc3RZOiBkZWZpbmVkKHkpID8gTWF0aC5zcXJ0KHkpIDogTnVtYmVyLk1BWF9WQUxVRSxcblx0XHRcdFx0XHRkaXN0UjogZGVmaW5lZChyKSA/IE1hdGguc3FydChyKSA6IE51bWJlci5NQVhfVkFMVUVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIF9zZWFyY2goc2VhcmNoLCB0cmVlLCBkZXB0aCwgZGltZW5zaW9ucykge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSB0cmVlLnBvaW50LFxuXHRcdFx0XHRcdGF4aXMgPSBzZXJpZXMua2RBeGlzQXJyYXlbZGVwdGggJSBkaW1lbnNpb25zXSxcblx0XHRcdFx0XHR0ZGlzdCxcblx0XHRcdFx0XHRzaWRlQSxcblx0XHRcdFx0XHRzaWRlQixcblx0XHRcdFx0XHRyZXQgPSBwb2ludCxcblx0XHRcdFx0XHRuUG9pbnQxLFxuXHRcdFx0XHRcdG5Qb2ludDI7XG5cdFx0XHRcdHBvaW50LmRpc3QgPSBfZGlzdGFuY2Uoc2VhcmNoLCBwb2ludCk7XG5cblx0XHRcdFx0Ly8gUGljayBzaWRlIGJhc2VkIG9uIGRpc3RhbmNlIHRvIHNwbGl0dGluZyBwb2ludFxuXHRcdFx0XHR0ZGlzdCA9IHNlYXJjaFtheGlzXSAtIHBvaW50W2F4aXNdO1xuXHRcdFx0XHRzaWRlQSA9IHRkaXN0IDwgMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cblx0XHRcdFx0Ly8gRW5kIG9mIHRyZWVcblx0XHRcdFx0aWYgKHRyZWVbc2lkZUFdKSB7XG5cdFx0XHRcdFx0blBvaW50MSA9X3NlYXJjaChzZWFyY2gsIHRyZWVbc2lkZUFdLCBkZXB0aCArIDEsIGRpbWVuc2lvbnMpO1xuXG5cdFx0XHRcdFx0cmV0ID0gKG5Qb2ludDEuZGlzdFtrZENvbXBhcmVyXSA8IHJldC5kaXN0W2tkQ29tcGFyZXJdID8gblBvaW50MSA6IHBvaW50KTtcblxuXHRcdFx0XHRcdHNpZGVCID0gdGRpc3QgPCAwID8gJ3JpZ2h0JyA6ICdsZWZ0Jztcblx0XHRcdFx0XHRpZiAodHJlZVtzaWRlQl0pIHtcblx0XHRcdFx0XHRcdC8vIGNvbXBhcmUgZGlzdGFuY2UgdG8gY3VycmVudCBiZXN0IHRvIHNwbGl0dGluZyBwb2ludCB0byBkZWNpZGUgd2V0aGVyIHRvIGNoZWNrIHNpZGUgQiBvciBub3Rcblx0XHRcdFx0XHRcdGlmIChNYXRoLnNxcnQodGRpc3QqdGRpc3QpIDwgcmV0LmRpc3Rba2RDb21wYXJlcl0pIHtcblx0XHRcdFx0XHRcdFx0blBvaW50MiA9IF9zZWFyY2goc2VhcmNoLCB0cmVlW3NpZGVCXSwgZGVwdGggKyAxLCBkaW1lbnNpb25zKTtcblx0XHRcdFx0XHRcdFx0cmV0ID0gKG5Qb2ludDIuZGlzdFtrZENvbXBhcmVyXSA8IHJldC5kaXN0W2tkQ29tcGFyZXJdID8gblBvaW50MiA6IHJldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5rZFRyZWUpIHtcblx0XHRcdFx0dGhpcy5idWlsZEtEVHJlZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5rZFRyZWUpIHtcblx0XHRcdFx0cmV0dXJuIF9zZWFyY2gocG9pbnQsIFxuXHRcdFx0XHRcdHRoaXMua2RUcmVlLCB0aGlzLmtkRGltZW5zaW9ucywgdGhpcy5rZERpbWVuc2lvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9OyAvLyBlbmQgU2VyaWVzIHByb3RvdHlwZVxuXG5cdC8qKlxuXHQgKiBUaGUgY2xhc3MgZm9yIHN0YWNrIGl0ZW1zXG5cdCAqL1xuXHRmdW5jdGlvbiBTdGFja0l0ZW0oYXhpcywgb3B0aW9ucywgaXNOZWdhdGl2ZSwgeCwgc3RhY2tPcHRpb24pIHtcblx0XHRcblx0XHR2YXIgaW52ZXJ0ZWQgPSBheGlzLmNoYXJ0LmludmVydGVkO1xuXG5cdFx0dGhpcy5heGlzID0gYXhpcztcblxuXHRcdC8vIFRlbGxzIGlmIHRoZSBzdGFjayBpcyBuZWdhdGl2ZVxuXHRcdHRoaXMuaXNOZWdhdGl2ZSA9IGlzTmVnYXRpdmU7XG5cblx0XHQvLyBTYXZlIHRoZSBvcHRpb25zIHRvIGJlIGFibGUgdG8gc3R5bGUgdGhlIGxhYmVsXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuXHRcdC8vIFNhdmUgdGhlIHggdmFsdWUgdG8gYmUgYWJsZSB0byBwb3NpdGlvbiB0aGUgbGFiZWwgbGF0ZXJcblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0b3RhbCB2YWx1ZVxuXHRcdHRoaXMudG90YWwgPSBudWxsO1xuXG5cdFx0Ly8gVGhpcyB3aWxsIGtlZXAgZWFjaCBwb2ludHMnIGV4dHJlbWVzIHN0b3JlZCBieSBzZXJpZXMuaW5kZXggYW5kIHBvaW50IGluZGV4XG5cdFx0dGhpcy5wb2ludHMgPSB7fTtcblxuXHRcdC8vIFNhdmUgdGhlIHN0YWNrIG9wdGlvbiBvbiB0aGUgc2VyaWVzIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBhbmQgd2hldGhlciB0byB0cmVhdCBpdCBhcyBwZXJjZW50XG5cdFx0dGhpcy5zdGFjayA9IHN0YWNrT3B0aW9uO1xuXG5cdFx0Ly8gVGhlIGFsaWduIG9wdGlvbnMgYW5kIHRleHQgYWxpZ24gdmFyaWVzIG9uIHdoZXRoZXIgdGhlIHN0YWNrIGlzIG5lZ2F0aXZlIGFuZFxuXHRcdC8vIGlmIHRoZSBjaGFydCBpcyBpbnZlcnRlZCBvciBub3QuXG5cdFx0Ly8gRmlyc3QgdGVzdCB0aGUgdXNlciBzdXBwbGllZCB2YWx1ZSwgdGhlbiB1c2UgdGhlIGR5bmFtaWMuXG5cdFx0dGhpcy5hbGlnbk9wdGlvbnMgPSB7XG5cdFx0XHRhbGlnbjogb3B0aW9ucy5hbGlnbiB8fCAoaW52ZXJ0ZWQgPyAoaXNOZWdhdGl2ZSA/ICdsZWZ0JyA6ICdyaWdodCcpIDogJ2NlbnRlcicpLFxuXHRcdFx0dmVydGljYWxBbGlnbjogb3B0aW9ucy52ZXJ0aWNhbEFsaWduIHx8IChpbnZlcnRlZCA/ICdtaWRkbGUnIDogKGlzTmVnYXRpdmUgPyAnYm90dG9tJyA6ICd0b3AnKSksXG5cdFx0XHR5OiBwaWNrKG9wdGlvbnMueSwgaW52ZXJ0ZWQgPyA0IDogKGlzTmVnYXRpdmUgPyAxNCA6IC02KSksXG5cdFx0XHR4OiBwaWNrKG9wdGlvbnMueCwgaW52ZXJ0ZWQgPyAoaXNOZWdhdGl2ZSA/IC02IDogNikgOiAwKVxuXHRcdH07XG5cblx0XHR0aGlzLnRleHRBbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduIHx8IChpbnZlcnRlZCA/IChpc05lZ2F0aXZlID8gJ3JpZ2h0JyA6ICdsZWZ0JykgOiAnY2VudGVyJyk7XG5cdH1cblxuXHRTdGFja0l0ZW0ucHJvdG90eXBlID0ge1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzKHRoaXMsIHRoaXMuYXhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbmRlcnMgdGhlIHN0YWNrIHRvdGFsIGxhYmVsIGFuZCBhZGRzIGl0IHRvIHRoZSBzdGFjayBsYWJlbCBncm91cC5cblx0XHQgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uIChncm91cCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGZvcm1hdE9wdGlvbiA9IG9wdGlvbnMuZm9ybWF0LFxuXHRcdFx0XHRzdHIgPSBmb3JtYXRPcHRpb24gP1xuXHRcdFx0XHRcdGZvcm1hdChmb3JtYXRPcHRpb24sIHRoaXMpIDogXG5cdFx0XHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIuY2FsbCh0aGlzKTsgIC8vIGZvcm1hdCB0aGUgdGV4dCBpbiB0aGUgbGFiZWxcblxuXHRcdFx0Ly8gQ2hhbmdlIHRoZSB0ZXh0IHRvIHJlZmxlY3QgdGhlIG5ldyB0b3RhbCBhbmQgc2V0IHZpc2liaWxpdHkgdG8gaGlkZGVuIGluIGNhc2UgdGhlIHNlcmllIGlzIGhpZGRlblxuXHRcdFx0aWYgKHRoaXMubGFiZWwpIHtcblx0XHRcdFx0dGhpcy5sYWJlbC5hdHRyKHt0ZXh0OiBzdHIsIHZpc2liaWxpdHk6IEhJRERFTn0pO1xuXHRcdFx0Ly8gQ3JlYXRlIG5ldyBsYWJlbFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5sYWJlbCA9XG5cdFx0XHRcdFx0dGhpcy5heGlzLmNoYXJ0LnJlbmRlcmVyLnRleHQoc3RyLCBudWxsLCBudWxsLCBvcHRpb25zLnVzZUhUTUwpXHRcdC8vIGR1bW15IHBvc2l0aW9ucywgYWN0dWFsIHBvc2l0aW9uIHVwZGF0ZWQgd2l0aCBzZXRPZmZzZXQgbWV0aG9kIGluIGNvbHVtbnNlcmllc1xuXHRcdFx0XHRcdFx0LmNzcyhvcHRpb25zLnN0eWxlKVx0XHRcdFx0Ly8gYXBwbHkgc3R5bGVcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0YWxpZ246IHRoaXMudGV4dEFsaWduLFx0XHRcdFx0Ly8gZml4IHRoZSB0ZXh0LWFuY2hvclxuXHRcdFx0XHRcdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcdC8vIHJvdGF0aW9uXG5cdFx0XHRcdFx0XHRcdHZpc2liaWxpdHk6IEhJRERFTlx0XHRcdFx0XHQvLyBoaWRkZW4gdW50aWwgc2V0T2Zmc2V0IGlzIGNhbGxlZFxuXHRcdFx0XHRcdFx0fSlcdFx0XHRcdFxuXHRcdFx0XHRcdFx0LmFkZChncm91cCk7XHRcdFx0XHRcdFx0XHQvLyBhZGQgdG8gdGhlIGxhYmVscy1ncm91cFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBvZmZzZXQgdGhhdCB0aGUgc3RhY2sgaGFzIGZyb20gdGhlIHggdmFsdWUgYW5kIHJlcG9zaXRpb25zIHRoZSBsYWJlbC5cblx0XHQgKi9cblx0XHRzZXRPZmZzZXQ6IGZ1bmN0aW9uICh4T2Zmc2V0LCB4V2lkdGgpIHtcblx0XHRcdHZhciBzdGFja0l0ZW0gPSB0aGlzLFxuXHRcdFx0XHRheGlzID0gc3RhY2tJdGVtLmF4aXMsXG5cdFx0XHRcdGNoYXJ0ID0gYXhpcy5jaGFydCxcblx0XHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0bmVnID0gdGhpcy5pc05lZ2F0aXZlLFx0XHRcdFx0XHRcdFx0Ly8gc3BlY2lhbCB0cmVhdG1lbnQgaXMgbmVlZGVkIGZvciBuZWdhdGl2ZSBzdGFja3Ncblx0XHRcdFx0eSA9IGF4aXMudHJhbnNsYXRlKGF4aXMudXNlUGVyY2VudGFnZSA/IDEwMCA6IHRoaXMudG90YWwsIDAsIDAsIDAsIDEpLCAvLyBzdGFjayB2YWx1ZSB0cmFuc2xhdGVkIG1hcHBlZCB0byBjaGFydCBjb29yZGluYXRlc1xuXHRcdFx0XHR5WmVybyA9IGF4aXMudHJhbnNsYXRlKDApLFx0XHRcdFx0XHRcdC8vIHN0YWNrIG9yaWdpblxuXHRcdFx0XHRoID0gbWF0aEFicyh5IC0geVplcm8pLFx0XHRcdFx0XHRcdFx0Ly8gc3RhY2sgaGVpZ2h0XG5cdFx0XHRcdHggPSBjaGFydC54QXhpc1swXS50cmFuc2xhdGUodGhpcy54KSArIHhPZmZzZXQsXHQvLyBzdGFjayB4IHBvc2l0aW9uXG5cdFx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0LFxuXHRcdFx0XHRzdGFja0JveCA9IHtcdC8vIHRoaXMgaXMgdGhlIGJveCBmb3IgdGhlIGNvbXBsZXRlIHN0YWNrXG5cdFx0XHRcdFx0eDogaW52ZXJ0ZWQgPyAobmVnID8geSA6IHkgLSBoKSA6IHgsXG5cdFx0XHRcdFx0eTogaW52ZXJ0ZWQgPyBwbG90SGVpZ2h0IC0geCAtIHhXaWR0aCA6IChuZWcgPyAocGxvdEhlaWdodCAtIHkgLSBoKSA6IHBsb3RIZWlnaHQgLSB5KSxcblx0XHRcdFx0XHR3aWR0aDogaW52ZXJ0ZWQgPyBoIDogeFdpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogaW52ZXJ0ZWQgPyB4V2lkdGggOiBoXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxhYmVsID0gdGhpcy5sYWJlbCxcblx0XHRcdFx0YWxpZ25BdHRyO1xuXHRcdFx0XG5cdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0bGFiZWwuYWxpZ24odGhpcy5hbGlnbk9wdGlvbnMsIG51bGwsIHN0YWNrQm94KTtcdC8vIGFsaWduIHRoZSBsYWJlbCB0byB0aGUgYm94XG5cdFx0XHRcdFx0XG5cdFx0XHRcdC8vIFNldCB2aXNpYmlsaXR5ICgjNjc4KVxuXHRcdFx0XHRhbGlnbkF0dHIgPSBsYWJlbC5hbGlnbkF0dHI7XG5cdFx0XHRcdGxhYmVsW3RoaXMub3B0aW9ucy5jcm9wID09PSBmYWxzZSB8fCBjaGFydC5pc0luc2lkZVBsb3QoYWxpZ25BdHRyLngsIGFsaWduQXR0ci55KSA/ICdzaG93JyA6ICdoaWRlJ10odHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblx0Ly8gU3RhY2tpbmcgbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBBeGlzIHByb3RvdHlwZVxuXG5cdC8qKlxuXHQgKiBCdWlsZCB0aGUgc3RhY2tzIGZyb20gdG9wIGRvd25cblx0ICovXG5cdEF4aXMucHJvdG90eXBlLmJ1aWxkU3RhY2tzID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzZXJpZXMgPSB0aGlzLnNlcmllcyxcblx0XHRcdHJldmVyc2VkU3RhY2tzID0gcGljayh0aGlzLm9wdGlvbnMucmV2ZXJzZWRTdGFja3MsIHRydWUpLFxuXHRcdFx0aSA9IHNlcmllcy5sZW5ndGg7XG5cdFx0aWYgKCF0aGlzLmlzWEF4aXMpIHtcblx0XHRcdHRoaXMudXNlUGVyY2VudGFnZSA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRzZXJpZXNbcmV2ZXJzZWRTdGFja3MgPyBpIDogc2VyaWVzLmxlbmd0aCAtIGkgLSAxXS5zZXRTdGFja2VkUG9pbnRzKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBMb29wIHVwIGFnYWluIHRvIGNvbXB1dGUgcGVyY2VudCBzdGFja1xuXHRcdFx0aWYgKHRoaXMudXNlUGVyY2VudGFnZSkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c2VyaWVzW2ldLnNldFBlcmNlbnRTdGFja3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRBeGlzLnByb3RvdHlwZS5yZW5kZXJTdGFja1RvdGFscyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXhpcyA9IHRoaXMsXG5cdFx0XHRjaGFydCA9IGF4aXMuY2hhcnQsXG5cdFx0XHRyZW5kZXJlciA9IGNoYXJ0LnJlbmRlcmVyLFxuXHRcdFx0c3RhY2tzID0gYXhpcy5zdGFja3MsXG5cdFx0XHRzdGFja0tleSwgXG5cdFx0XHRvbmVTdGFjaywgXG5cdFx0XHRzdGFja0NhdGVnb3J5LFxuXHRcdFx0c3RhY2tUb3RhbEdyb3VwID0gYXhpcy5zdGFja1RvdGFsR3JvdXA7XG5cblx0XHQvLyBDcmVhdGUgYSBzZXBhcmF0ZSBncm91cCBmb3IgdGhlIHN0YWNrIHRvdGFsIGxhYmVsc1xuXHRcdGlmICghc3RhY2tUb3RhbEdyb3VwKSB7XG5cdFx0XHRheGlzLnN0YWNrVG90YWxHcm91cCA9IHN0YWNrVG90YWxHcm91cCA9XG5cdFx0XHRcdHJlbmRlcmVyLmcoJ3N0YWNrLWxhYmVscycpXG5cdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0dmlzaWJpbGl0eTogVklTSUJMRSxcblx0XHRcdFx0XHRcdHpJbmRleDogNlxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdH1cblxuXHRcdC8vIHBsb3RMZWZ0L1RvcCB3aWxsIGNoYW5nZSB3aGVuIHkgYXhpcyBnZXRzIHdpZGVyIHNvIHdlIG5lZWQgdG8gdHJhbnNsYXRlIHRoZVxuXHRcdC8vIHN0YWNrVG90YWxHcm91cCBhdCBldmVyeSByZW5kZXIgY2FsbC4gU2VlIGJ1ZyAjNTA2IGFuZCAjNTE2XG5cdFx0c3RhY2tUb3RhbEdyb3VwLnRyYW5zbGF0ZShjaGFydC5wbG90TGVmdCwgY2hhcnQucGxvdFRvcCk7XG5cblx0XHQvLyBSZW5kZXIgZWFjaCBzdGFjayB0b3RhbFxuXHRcdGZvciAoc3RhY2tLZXkgaW4gc3RhY2tzKSB7XG5cdFx0XHRvbmVTdGFjayA9IHN0YWNrc1tzdGFja0tleV07XG5cdFx0XHRmb3IgKHN0YWNrQ2F0ZWdvcnkgaW4gb25lU3RhY2spIHtcblx0XHRcdFx0b25lU3RhY2tbc3RhY2tDYXRlZ29yeV0ucmVuZGVyKHN0YWNrVG90YWxHcm91cCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblx0Ly8gU3RhY2tpbmcgbWV0aG9kcyBkZWZuaWVkIGZvciBTZXJpZXMgcHJvdG90eXBlXG5cblx0LyoqXG5cdCAqIEFkZHMgc2VyaWVzJyBwb2ludHMgdmFsdWUgdG8gY29ycmVzcG9uZGluZyBzdGFja1xuXHQgKi9cblx0U2VyaWVzLnByb3RvdHlwZS5zZXRTdGFja2VkUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5vcHRpb25zLnN0YWNraW5nIHx8ICh0aGlzLnZpc2libGUgIT09IHRydWUgJiYgdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyAhPT0gZmFsc2UpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHR4RGF0YSA9IHNlcmllcy5wcm9jZXNzZWRYRGF0YSxcblx0XHRcdHlEYXRhID0gc2VyaWVzLnByb2Nlc3NlZFlEYXRhLFxuXHRcdFx0c3RhY2tlZFlEYXRhID0gW10sXG5cdFx0XHR5RGF0YUxlbmd0aCA9IHlEYXRhLmxlbmd0aCxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdHRocmVzaG9sZCA9IHNlcmllc09wdGlvbnMudGhyZXNob2xkLFxuXHRcdFx0c3RhY2tPcHRpb24gPSBzZXJpZXNPcHRpb25zLnN0YWNrLFxuXHRcdFx0c3RhY2tpbmcgPSBzZXJpZXNPcHRpb25zLnN0YWNraW5nLFxuXHRcdFx0c3RhY2tLZXkgPSBzZXJpZXMuc3RhY2tLZXksXG5cdFx0XHRuZWdLZXkgPSAnLScgKyBzdGFja0tleSxcblx0XHRcdG5lZ1N0YWNrcyA9IHNlcmllcy5uZWdTdGFja3MsXG5cdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdHN0YWNrcyA9IHlBeGlzLnN0YWNrcyxcblx0XHRcdG9sZFN0YWNrcyA9IHlBeGlzLm9sZFN0YWNrcyxcblx0XHRcdGlzTmVnYXRpdmUsXG5cdFx0XHRzdGFjayxcblx0XHRcdG90aGVyLFxuXHRcdFx0a2V5LFxuXHRcdFx0cG9pbnRLZXksXG5cdFx0XHRpLFxuXHRcdFx0eCxcblx0XHRcdHk7XG5cblx0XHQvLyBsb29wIG92ZXIgdGhlIG5vbi1udWxsIHkgdmFsdWVzIGFuZCByZWFkIHRoZW0gaW50byBhIGxvY2FsIGFycmF5XG5cdFx0Zm9yIChpID0gMDsgaSA8IHlEYXRhTGVuZ3RoOyBpKyspIHtcblx0XHRcdHggPSB4RGF0YVtpXTtcblx0XHRcdHkgPSB5RGF0YVtpXTtcblx0XHRcdHBvaW50S2V5ID0gc2VyaWVzLmluZGV4ICsgJywnICsgaTtcblxuXHRcdFx0Ly8gUmVhZCBzdGFja2VkIHZhbHVlcyBpbnRvIGEgc3RhY2sgYmFzZWQgb24gdGhlIHggdmFsdWUsXG5cdFx0XHQvLyB0aGUgc2lnbiBvZiB5IGFuZCB0aGUgc3RhY2sga2V5LiBTdGFja2luZyBpcyBhbHNvIGhhbmRsZWQgZm9yIG51bGwgdmFsdWVzICgjNzM5KVxuXHRcdFx0aXNOZWdhdGl2ZSA9IG5lZ1N0YWNrcyAmJiB5IDwgdGhyZXNob2xkO1xuXHRcdFx0a2V5ID0gaXNOZWdhdGl2ZSA/IG5lZ0tleSA6IHN0YWNrS2V5O1xuXG5cdFx0XHQvLyBDcmVhdGUgZW1wdHkgb2JqZWN0IGZvciB0aGlzIHN0YWNrIGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0XG5cdFx0XHRpZiAoIXN0YWNrc1trZXldKSB7XG5cdFx0XHRcdHN0YWNrc1trZXldID0ge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluaXRpYWxpemUgU3RhY2tJdGVtIGZvciB0aGlzIHhcblx0XHRcdGlmICghc3RhY2tzW2tleV1beF0pIHtcblx0XHRcdFx0aWYgKG9sZFN0YWNrc1trZXldICYmIG9sZFN0YWNrc1trZXldW3hdKSB7XG5cdFx0XHRcdFx0c3RhY2tzW2tleV1beF0gPSBvbGRTdGFja3Nba2V5XVt4XTtcblx0XHRcdFx0XHRzdGFja3Nba2V5XVt4XS50b3RhbCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhY2tzW2tleV1beF0gPSBuZXcgU3RhY2tJdGVtKHlBeGlzLCB5QXhpcy5vcHRpb25zLnN0YWNrTGFiZWxzLCBpc05lZ2F0aXZlLCB4LCBzdGFja09wdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIFN0YWNrSXRlbSBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXQgZmlyc3Rcblx0XHRcdHN0YWNrID0gc3RhY2tzW2tleV1beF07XG5cdFx0XHRzdGFjay5wb2ludHNbcG9pbnRLZXldID0gW3N0YWNrLmN1bSB8fCAwXTtcblxuXHRcdFx0Ly8gQWRkIHZhbHVlIHRvIHRoZSBzdGFjayB0b3RhbFxuXHRcdFx0aWYgKHN0YWNraW5nID09PSAncGVyY2VudCcpIHtcblxuXHRcdFx0XHQvLyBQZXJjZW50IHN0YWNrZWQgY29sdW1uLCB0b3RhbHMgYXJlIHRoZSBzYW1lIGZvciB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHN0YWNrc1xuXHRcdFx0XHRvdGhlciA9IGlzTmVnYXRpdmUgPyBzdGFja0tleSA6IG5lZ0tleTtcblx0XHRcdFx0aWYgKG5lZ1N0YWNrcyAmJiBzdGFja3Nbb3RoZXJdICYmIHN0YWNrc1tvdGhlcl1beF0pIHtcblx0XHRcdFx0XHRvdGhlciA9IHN0YWNrc1tvdGhlcl1beF07XG5cdFx0XHRcdFx0c3RhY2sudG90YWwgPSBvdGhlci50b3RhbCA9IG1hdGhNYXgob3RoZXIudG90YWwsIHN0YWNrLnRvdGFsKSArIG1hdGhBYnMoeSkgfHwgMDtcblxuXHRcdFx0XHQvLyBQZXJjZW50IHN0YWNrZWQgYXJlYXNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGFjay50b3RhbCA9IGNvcnJlY3RGbG9hdChzdGFjay50b3RhbCArIChtYXRoQWJzKHkpIHx8IDApKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhY2sudG90YWwgPSBjb3JyZWN0RmxvYXQoc3RhY2sudG90YWwgKyAoeSB8fCAwKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0YWNrLmN1bSA9IChzdGFjay5jdW0gfHwgMCkgKyAoeSB8fCAwKTtcblxuXHRcdFx0c3RhY2sucG9pbnRzW3BvaW50S2V5XS5wdXNoKHN0YWNrLmN1bSk7XG5cdFx0XHRzdGFja2VkWURhdGFbaV0gPSBzdGFjay5jdW07XG5cblx0XHR9XG5cblx0XHRpZiAoc3RhY2tpbmcgPT09ICdwZXJjZW50Jykge1xuXHRcdFx0eUF4aXMudXNlUGVyY2VudGFnZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdGFja2VkWURhdGEgPSBzdGFja2VkWURhdGE7IC8vIFRvIGJlIHVzZWQgaW4gZ2V0RXh0cmVtZXNcblxuXHRcdC8vIFJlc2V0IG9sZCBzdGFja3Ncblx0XHR5QXhpcy5vbGRTdGFja3MgPSB7fTtcblx0fTtcblxuXHQvKipcblx0ICogSXRlcmF0ZSBvdmVyIGFsbCBzdGFja3MgYW5kIGNvbXB1dGUgdGhlIGFic29sdXRlIHZhbHVlcyB0byBwZXJjZW50XG5cdCAqL1xuXHRTZXJpZXMucHJvdG90eXBlLnNldFBlcmNlbnRTdGFja3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRzdGFja0tleSA9IHNlcmllcy5zdGFja0tleSxcblx0XHRcdHN0YWNrcyA9IHNlcmllcy55QXhpcy5zdGFja3MsXG5cdFx0XHRwcm9jZXNzZWRYRGF0YSA9IHNlcmllcy5wcm9jZXNzZWRYRGF0YTtcblxuXHRcdGVhY2goW3N0YWNrS2V5LCAnLScgKyBzdGFja0tleV0sIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHZhciBpID0gcHJvY2Vzc2VkWERhdGEubGVuZ3RoLFxuXHRcdFx0XHR4LFxuXHRcdFx0XHRzdGFjayxcblx0XHRcdFx0cG9pbnRFeHRyZW1lcyxcblx0XHRcdFx0dG90YWxGYWN0b3I7XG5cblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0eCA9IHByb2Nlc3NlZFhEYXRhW2ldO1xuXHRcdFx0XHRzdGFjayA9IHN0YWNrc1trZXldICYmIHN0YWNrc1trZXldW3hdO1xuXHRcdFx0XHRwb2ludEV4dHJlbWVzID0gc3RhY2sgJiYgc3RhY2sucG9pbnRzW3Nlcmllcy5pbmRleCArICcsJyArIGldO1xuXHRcdFx0XHRpZiAocG9pbnRFeHRyZW1lcykge1xuXHRcdFx0XHRcdHRvdGFsRmFjdG9yID0gc3RhY2sudG90YWwgPyAxMDAgLyBzdGFjay50b3RhbCA6IDA7XG5cdFx0XHRcdFx0cG9pbnRFeHRyZW1lc1swXSA9IGNvcnJlY3RGbG9hdChwb2ludEV4dHJlbWVzWzBdICogdG90YWxGYWN0b3IpOyAvLyBZIGJvdHRvbSB2YWx1ZVxuXHRcdFx0XHRcdHBvaW50RXh0cmVtZXNbMV0gPSBjb3JyZWN0RmxvYXQocG9pbnRFeHRyZW1lc1sxXSAqIHRvdGFsRmFjdG9yKTsgLy8gWSB2YWx1ZVxuXHRcdFx0XHRcdHNlcmllcy5zdGFja2VkWURhdGFbaV0gPSBwb2ludEV4dHJlbWVzWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0Ly8gRXh0ZW5kIHRoZSBDaGFydCBwcm90b3R5cGUgZm9yIGR5bmFtaWMgbWV0aG9kc1xuXHRleHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cblx0XHQvKipcblx0XHQgKiBBZGQgYSBzZXJpZXMgZHluYW1pY2FsbHkgYWZ0ZXIgIHRpbWVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBjb25maWcgb3B0aW9uc1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBhZnRlciBhZGRpbmcuIERlZmF1bHRzIHRvIHRydWUuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0XHQgKiAgICBjb25maWd1cmF0aW9uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IHNlcmllcyBUaGUgbmV3bHkgY3JlYXRlZCBzZXJpZXMgb2JqZWN0XG5cdFx0ICovXG5cdFx0YWRkU2VyaWVzOiBmdW5jdGlvbiAob3B0aW9ucywgcmVkcmF3LCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBzZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gdGhpcztcblxuXHRcdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpOyAvLyBkZWZhdWx0cyB0byB0cnVlXG5cblx0XHRcdFx0ZmlyZUV2ZW50KGNoYXJ0LCAnYWRkU2VyaWVzJywgeyBvcHRpb25zOiBvcHRpb25zIH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRzZXJpZXMgPSBjaGFydC5pbml0U2VyaWVzKG9wdGlvbnMpO1xuXG5cdFx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUxlZ2VuZCA9IHRydWU7IC8vIHRoZSBzZXJpZXMgYXJyYXkgaXMgb3V0IG9mIHN5bmMgd2l0aCB0aGUgZGlzcGxheVxuXHRcdFx0XHRcdGNoYXJ0LmxpbmtTZXJpZXMoKTtcblx0XHRcdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdFx0XHRjaGFydC5yZWRyYXcoYW5pbWF0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2VyaWVzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0ICAgICAqIEFkZCBhbiBheGlzIHRvIHRoZSBjaGFydFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIGF4aXMgb3B0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzWCBXaGV0aGVyIGl0IGlzIGFuIFggYXhpcyBvciBhIHZhbHVlIGF4aXNcblx0ICAgICAqL1xuXHRcdGFkZEF4aXM6IGZ1bmN0aW9uIChvcHRpb25zLCBpc1gsIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIga2V5ID0gaXNYID8gJ3hBeGlzJyA6ICd5QXhpcycsXG5cdFx0XHRcdGNoYXJ0T3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0YXhpcztcblxuXHRcdFx0Lypqc2xpbnQgdW51c2VkOiBmYWxzZSovXG5cdFx0XHRheGlzID0gbmV3IEF4aXModGhpcywgbWVyZ2Uob3B0aW9ucywge1xuXHRcdFx0XHRpbmRleDogdGhpc1trZXldLmxlbmd0aCxcblx0XHRcdFx0aXNYOiBpc1hcblx0XHRcdH0pKTtcblx0XHRcdC8qanNsaW50IHVudXNlZDogdHJ1ZSovXG5cblx0XHRcdC8vIFB1c2ggdGhlIG5ldyBheGlzIG9wdGlvbnMgdG8gdGhlIGNoYXJ0IG9wdGlvbnNcblx0XHRcdGNoYXJ0T3B0aW9uc1trZXldID0gc3BsYXQoY2hhcnRPcHRpb25zW2tleV0gfHwge30pO1xuXHRcdFx0Y2hhcnRPcHRpb25zW2tleV0ucHVzaChvcHRpb25zKTtcblxuXHRcdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0XHR0aGlzLnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEaW0gdGhlIGNoYXJ0IGFuZCBzaG93IGEgbG9hZGluZyB0ZXh0IG9yIHN5bWJvbFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQW4gb3B0aW9uYWwgdGV4dCB0byBzaG93IGluIHRoZSBsb2FkaW5nIGxhYmVsIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lXG5cdFx0ICovXG5cdFx0c2hvd0xvYWRpbmc6IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLFxuXHRcdFx0XHRsb2FkaW5nRGl2ID0gY2hhcnQubG9hZGluZ0Rpdixcblx0XHRcdFx0bG9hZGluZ09wdGlvbnMgPSBvcHRpb25zLmxvYWRpbmcsXG5cdFx0XHRcdHNldExvYWRpbmdTaXplID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChsb2FkaW5nRGl2KSB7XG5cdFx0XHRcdFx0XHRjc3MobG9hZGluZ0Rpdiwge1xuXHRcdFx0XHRcdFx0XHRsZWZ0OiBjaGFydC5wbG90TGVmdCArIFBYLFxuXHRcdFx0XHRcdFx0XHR0b3A6IGNoYXJ0LnBsb3RUb3AgKyBQWCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGNoYXJ0LnBsb3RXaWR0aCArIFBYLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGNoYXJ0LnBsb3RIZWlnaHQgKyBQWFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBjcmVhdGUgdGhlIGxheWVyIGF0IHRoZSBmaXJzdCBjYWxsXG5cdFx0XHRpZiAoIWxvYWRpbmdEaXYpIHtcblx0XHRcdFx0Y2hhcnQubG9hZGluZ0RpdiA9IGxvYWRpbmdEaXYgPSBjcmVhdGVFbGVtZW50KERJViwge1xuXHRcdFx0XHRcdGNsYXNzTmFtZTogUFJFRklYICsgJ2xvYWRpbmcnXG5cdFx0XHRcdH0sIGV4dGVuZChsb2FkaW5nT3B0aW9ucy5zdHlsZSwge1xuXHRcdFx0XHRcdHpJbmRleDogMTAsXG5cdFx0XHRcdFx0ZGlzcGxheTogTk9ORVxuXHRcdFx0XHR9KSwgY2hhcnQuY29udGFpbmVyKTtcblxuXHRcdFx0XHRjaGFydC5sb2FkaW5nU3BhbiA9IGNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdFx0J3NwYW4nLFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0bG9hZGluZ09wdGlvbnMubGFiZWxTdHlsZSxcblx0XHRcdFx0XHRsb2FkaW5nRGl2XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGFkZEV2ZW50KGNoYXJ0LCAncmVkcmF3Jywgc2V0TG9hZGluZ1NpemUpOyAvLyAjMTA4MFxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgdGV4dFxuXHRcdFx0Y2hhcnQubG9hZGluZ1NwYW4uaW5uZXJIVE1MID0gc3RyIHx8IG9wdGlvbnMubGFuZy5sb2FkaW5nO1xuXG5cdFx0XHQvLyBzaG93IGl0XG5cdFx0XHRpZiAoIWNoYXJ0LmxvYWRpbmdTaG93bikge1xuXHRcdFx0XHRjc3MobG9hZGluZ0Rpdiwge1xuXHRcdFx0XHRcdG9wYWNpdHk6IDAsXG5cdFx0XHRcdFx0ZGlzcGxheTogJydcdFx0XHRcdFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0YW5pbWF0ZShsb2FkaW5nRGl2LCB7XG5cdFx0XHRcdFx0b3BhY2l0eTogbG9hZGluZ09wdGlvbnMuc3R5bGUub3BhY2l0eVxuXHRcdFx0XHR9LCB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IGxvYWRpbmdPcHRpb25zLnNob3dEdXJhdGlvbiB8fCAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjaGFydC5sb2FkaW5nU2hvd24gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0c2V0TG9hZGluZ1NpemUoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlkZSB0aGUgbG9hZGluZyBsYXllclxuXHRcdCAqL1xuXHRcdGhpZGVMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0bG9hZGluZ0RpdiA9IHRoaXMubG9hZGluZ0RpdjtcblxuXHRcdFx0aWYgKGxvYWRpbmdEaXYpIHtcblx0XHRcdFx0YW5pbWF0ZShsb2FkaW5nRGl2LCB7XG5cdFx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0XHR9LCB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMubG9hZGluZy5oaWRlRHVyYXRpb24gfHwgMTAwLFxuXHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRjc3MobG9hZGluZ0RpdiwgeyBkaXNwbGF5OiBOT05FIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxvYWRpbmdTaG93biA9IGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gZXh0ZW5kIHRoZSBQb2ludCBwcm90b3R5cGUgZm9yIGR5bmFtaWMgbWV0aG9kc1xuXHRleHRlbmQoUG9pbnQucHJvdG90eXBlLCB7XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBwb2ludCB3aXRoIG5ldyBvcHRpb25zICh0eXBpY2FsbHkgeC95IGRhdGEpIGFuZCBvcHRpb25hbGx5IHJlZHJhdyB0aGUgc2VyaWVzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUG9pbnQgb3B0aW9ucyBhcyBkZWZpbmVkIGluIHRoZSBzZXJpZXMuZGF0YSBhcnJheVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBvciB3YWl0IGZvciBhbiBleHBsaWNpdCBjYWxsXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0XHQgKiAgICBjb25maWd1cmF0aW9uXG5cdFx0ICpcblx0XHQgKi9cblx0XHR1cGRhdGU6IGZ1bmN0aW9uIChvcHRpb25zLCByZWRyYXcsIGFuaW1hdGlvbiwgcnVuRXZlbnQpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0Z3JhcGhpYyA9IHBvaW50LmdyYXBoaWMsXG5cdFx0XHRcdGksXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdG5hbWVzID0gc2VyaWVzLnhBeGlzICYmIHNlcmllcy54QXhpcy5uYW1lcztcblxuXHRcdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHRcdFx0cG9pbnQuYXBwbHlPcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSB2aXN1YWxzXG5cdFx0XHRcdGlmIChpc09iamVjdChvcHRpb25zKSAmJiAhaXNBcnJheShvcHRpb25zKSkge1xuXHRcdFx0XHRcdC8vIERlZmVyIHRoZSBhY3R1YWwgcmVkcmF3IHVudGlsIGdldEF0dHJpYnMgaGFzIGJlZW4gY2FsbGVkICgjMzI2MClcblx0XHRcdFx0XHRwb2ludC5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlciAmJiBvcHRpb25zLm1hcmtlci5zeW1ib2wpIHtcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Z3JhcGhpYy5hdHRyKHBvaW50LnBvaW50QXR0cltwb2ludC5zdGF0ZSB8fCAnJ10pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhdGFMYWJlbHMgJiYgcG9pbnQuZGF0YUxhYmVsKSB7IC8vICMyNDY4XG5cdFx0XHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbCA9IHBvaW50LmRhdGFMYWJlbC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwb2ludC5yZWRyYXcgPSBudWxsO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgY2hhbmdlcyBpbiB0aGUgcGFyYWxsZWwgYXJyYXlzXG5cdFx0XHRcdGkgPSBwb2ludC5pbmRleDtcblx0XHRcdFx0c2VyaWVzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHBvaW50LCBpKTtcblx0XHRcdFx0aWYgKG5hbWVzICYmIHBvaW50Lm5hbWUpIHtcblx0XHRcdFx0XHRuYW1lc1twb2ludC54XSA9IHBvaW50Lm5hbWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXJpZXNPcHRpb25zLmRhdGFbaV0gPSBwb2ludC5vcHRpb25zO1xuXG5cdFx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHNlcmllcy5pc0RpcnR5RGF0YSA9IHRydWU7XG5cdFx0XHRcdGlmICghc2VyaWVzLmZpeGVkQm94ICYmIHNlcmllcy5oYXNDYXJ0ZXNpYW5TZXJpZXMpIHsgLy8gIzE5MDYsICMyMzIwXG5cdFx0XHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY2hhcnQubGVnZW5kLmRpc3BsYXkgJiYgc2VyaWVzT3B0aW9ucy5sZWdlbmRUeXBlID09PSAncG9pbnQnKSB7IC8vICMxODMxLCAjMTg4NSwgIzM5MzRcblx0XHRcdFx0XHRzZXJpZXMudXBkYXRlVG90YWxzKCk7XG5cdFx0XHRcdFx0Y2hhcnQubGVnZW5kLmNsZWFySXRlbXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVkcmF3KSB7XG5cdFx0XHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmlyZSB0aGUgZXZlbnQgd2l0aCBhIGRlZmF1bHQgaGFuZGxlciBvZiBkb2luZyB0aGUgdXBkYXRlXG5cdFx0XHRpZiAocnVuRXZlbnQgPT09IGZhbHNlKSB7IC8vIFdoZW4gY2FsbGVkIGZyb20gc2V0RGF0YVxuXHRcdFx0XHR1cGRhdGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50LmZpcmVQb2ludEV2ZW50KCd1cGRhdGUnLCB7IG9wdGlvbnM6IG9wdGlvbnMgfSwgdXBkYXRlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGEgcG9pbnQgYW5kIG9wdGlvbmFsbHkgcmVkcmF3IHRoZSBzZXJpZXMgYW5kIGlmIG5lY2Vzc2FyeSB0aGUgYXhlc1xuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBvciB3YWl0IGZvciBhbiBleHBsaWNpdCBjYWxsXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0XHQgKiAgICBjb25maWd1cmF0aW9uXG5cdFx0ICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAocmVkcmF3LCBhbmltYXRpb24pIHtcblx0XHRcdHRoaXMuc2VyaWVzLnJlbW92ZVBvaW50KGluQXJyYXkodGhpcywgdGhpcy5zZXJpZXMuZGF0YSksIHJlZHJhdywgYW5pbWF0aW9uKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIEV4dGVuZCB0aGUgc2VyaWVzIHByb3RvdHlwZSBmb3IgZHluYW1pYyBtZXRob2RzXG5cdGV4dGVuZChTZXJpZXMucHJvdG90eXBlLCB7XG5cdFx0LyoqXG5cdFx0ICogQWRkIGEgcG9pbnQgZHluYW1pY2FsbHkgYWZ0ZXIgY2hhcnQgbG9hZCB0aW1lXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUG9pbnQgb3B0aW9ucyBhcyBnaXZlbiBpbiBzZXJpZXMuZGF0YVxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjaGFydCBvciB3YWl0IGZvciBhbiBleHBsaWNpdCBjYWxsXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzaGlmdCBJZiBzaGlmdCBpcyB0cnVlLCBhIHBvaW50IGlzIHNoaWZ0ZWQgb2ZmIHRoZSBzdGFydFxuXHRcdCAqICAgIG9mIHRoZSBzZXJpZXMgYXMgb25lIGlzIGFwcGVuZGVkIHRvIHRoZSBlbmQuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYW5pbWF0aW9uIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb25cblx0XHQgKiAgICBjb25maWd1cmF0aW9uXG5cdFx0ICovXG5cdFx0YWRkUG9pbnQ6IGZ1bmN0aW9uIChvcHRpb25zLCByZWRyYXcsIHNoaWZ0LCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXNPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGRhdGEgPSBzZXJpZXMuZGF0YSxcblx0XHRcdFx0Z3JhcGggPSBzZXJpZXMuZ3JhcGgsXG5cdFx0XHRcdGFyZWEgPSBzZXJpZXMuYXJlYSxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdG5hbWVzID0gc2VyaWVzLnhBeGlzICYmIHNlcmllcy54QXhpcy5uYW1lcyxcblx0XHRcdFx0Y3VycmVudFNoaWZ0ID0gKGdyYXBoICYmIGdyYXBoLnNoaWZ0KSB8fCAwLFxuXHRcdFx0XHRkYXRhT3B0aW9ucyA9IHNlcmllc09wdGlvbnMuZGF0YSxcblx0XHRcdFx0cG9pbnQsXG5cdFx0XHRcdGlzSW5UaGVNaWRkbGUsXG5cdFx0XHRcdHhEYXRhID0gc2VyaWVzLnhEYXRhLFxuXHRcdFx0XHR4LFxuXHRcdFx0XHRpO1xuXG5cdFx0XHRzZXRBbmltYXRpb24oYW5pbWF0aW9uLCBjaGFydCk7XG5cblx0XHRcdC8vIE1ha2UgZ3JhcGggYW5pbWF0ZSBzaWRld2F5c1xuXHRcdFx0aWYgKHNoaWZ0KSB7XG5cdFx0XHRcdGVhY2goW2dyYXBoLCBhcmVhLCBzZXJpZXMuZ3JhcGhOZWcsIHNlcmllcy5hcmVhTmVnXSwgZnVuY3Rpb24gKHNoYXBlKSB7XG5cdFx0XHRcdFx0aWYgKHNoYXBlKSB7XG5cdFx0XHRcdFx0XHRzaGFwZS5zaGlmdCA9IGN1cnJlbnRTaGlmdCArIDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGlmIChhcmVhKSB7XG5cdFx0XHRcdGFyZWEuaXNBcmVhID0gdHJ1ZTsgLy8gbmVlZGVkIGluIGFuaW1hdGlvbiwgYm90aCB3aXRoIGFuZCB3aXRob3V0IHNoaWZ0XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wdGlvbmFsIHJlZHJhdywgZGVmYXVsdHMgdG8gdHJ1ZVxuXHRcdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0XHQvLyBHZXQgb3B0aW9ucyBhbmQgcHVzaCB0aGUgcG9pbnQgdG8geERhdGEsIHlEYXRhIGFuZCBzZXJpZXMub3B0aW9ucy4gSW4gc2VyaWVzLmdlbmVyYXRlUG9pbnRzXG5cdFx0XHQvLyB0aGUgUG9pbnQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkIG9uIGRlbWFuZCBhbmQgcHVzaGVkIHRvIHRoZSBzZXJpZXMuZGF0YSBhcnJheS5cblx0XHRcdHBvaW50ID0geyBzZXJpZXM6IHNlcmllcyB9O1xuXHRcdFx0c2VyaWVzLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseShwb2ludCwgW29wdGlvbnNdKTtcblx0XHRcdHggPSBwb2ludC54O1xuXG5cdFx0XHQvLyBHZXQgdGhlIGluc2VydGlvbiBwb2ludFxuXHRcdFx0aSA9IHhEYXRhLmxlbmd0aDtcblx0XHRcdGlmIChzZXJpZXMucmVxdWlyZVNvcnRpbmcgJiYgeCA8IHhEYXRhW2kgLSAxXSkge1xuXHRcdFx0XHRpc0luVGhlTWlkZGxlID0gdHJ1ZTtcblx0XHRcdFx0d2hpbGUgKGkgJiYgeERhdGFbaSAtIDFdID4geCkge1xuXHRcdFx0XHRcdGktLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzZXJpZXMudXBkYXRlUGFyYWxsZWxBcnJheXMocG9pbnQsICdzcGxpY2UnLCBpLCAwLCAwKTsgLy8gaW5zZXJ0IHVuZGVmaW5lZCBpdGVtXG5cdFx0XHRzZXJpZXMudXBkYXRlUGFyYWxsZWxBcnJheXMocG9pbnQsIGkpOyAvLyB1cGRhdGUgaXRcblxuXHRcdFx0aWYgKG5hbWVzICYmIHBvaW50Lm5hbWUpIHtcblx0XHRcdFx0bmFtZXNbeF0gPSBwb2ludC5uYW1lO1xuXHRcdFx0fVxuXHRcdFx0ZGF0YU9wdGlvbnMuc3BsaWNlKGksIDAsIG9wdGlvbnMpO1xuXG5cdFx0XHRpZiAoaXNJblRoZU1pZGRsZSkge1xuXHRcdFx0XHRzZXJpZXMuZGF0YS5zcGxpY2UoaSwgMCwgbnVsbCk7XG5cdFx0XHRcdHNlcmllcy5wcm9jZXNzRGF0YSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZW5lcmF0ZSBwb2ludHMgdG8gYmUgYWRkZWQgdG8gdGhlIGxlZ2VuZCAoIzEzMjkpXG5cdFx0XHRpZiAoc2VyaWVzT3B0aW9ucy5sZWdlbmRUeXBlID09PSAncG9pbnQnKSB7XG5cdFx0XHRcdHNlcmllcy5nZW5lcmF0ZVBvaW50cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaGlmdCB0aGUgZmlyc3QgcG9pbnQgb2ZmIHRoZSBwYXJhbGxlbCBhcnJheXNcblx0XHRcdC8vIHRvZG86IGNvbnNpZGVyIHNlcmllcy5yZW1vdmVQb2ludChpKSBtZXRob2Rcblx0XHRcdGlmIChzaGlmdCkge1xuXHRcdFx0XHRpZiAoZGF0YVswXSAmJiBkYXRhWzBdLnJlbW92ZSkge1xuXHRcdFx0XHRcdGRhdGFbMF0ucmVtb3ZlKGZhbHNlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhLnNoaWZ0KCk7XG5cdFx0XHRcdFx0c2VyaWVzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHBvaW50LCAnc2hpZnQnKTtcblxuXHRcdFx0XHRcdGRhdGFPcHRpb25zLnNoaWZ0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVkcmF3XG5cdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRzZXJpZXMuaXNEaXJ0eURhdGEgPSB0cnVlO1xuXHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRzZXJpZXMuZ2V0QXR0cmlicygpOyAvLyAjMTkzN1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGEgcG9pbnQgKHJlbmRlcmVkIG9yIG5vdCksIGJ5IGluZGV4XG5cdFx0ICovXG5cdFx0cmVtb3ZlUG9pbnQ6IGZ1bmN0aW9uIChpLCByZWRyYXcsIGFuaW1hdGlvbikge1xuXG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0ZGF0YSA9IHNlcmllcy5kYXRhLFxuXHRcdFx0XHRwb2ludCA9IGRhdGFbaV0sXG5cdFx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRpZiAoZGF0YS5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHBvaW50cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdHNlcmllcy5vcHRpb25zLmRhdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdHNlcmllcy51cGRhdGVQYXJhbGxlbEFycmF5cyhwb2ludCB8fCB7IHNlcmllczogc2VyaWVzIH0sICdzcGxpY2UnLCBpLCAxKTtcblxuXHRcdFx0XHRcdGlmIChwb2ludCkge1xuXHRcdFx0XHRcdFx0cG9pbnQuZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHJlZHJhd1xuXHRcdFx0XHRcdHNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRzZXJpZXMuaXNEaXJ0eURhdGEgPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChyZWRyYXcpIHtcblx0XHRcdFx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXHRcdFx0cmVkcmF3ID0gcGljayhyZWRyYXcsIHRydWUpO1xuXG5cdFx0XHQvLyBGaXJlIHRoZSBldmVudCB3aXRoIGEgZGVmYXVsdCBoYW5kbGVyIG9mIHJlbW92aW5nIHRoZSBwb2ludFxuXHRcdFx0aWYgKHBvaW50KSB7XG5cdFx0XHRcdHBvaW50LmZpcmVQb2ludEV2ZW50KCdyZW1vdmUnLCBudWxsLCByZW1vdmUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhIHNlcmllcyBhbmQgb3B0aW9uYWxseSByZWRyYXcgdGhlIGNoYXJ0XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdyBXaGV0aGVyIHRvIHJlZHJhdyB0aGUgY2hhcnQgb3Igd2FpdCBmb3IgYW4gZXhwbGljaXQgY2FsbFxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IGFuaW1hdGlvbiBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uXG5cdFx0ICogICAgY29uZmlndXJhdGlvblxuXHRcdCAqL1xuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAocmVkcmF3LCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblx0XHRcdHJlZHJhdyA9IHBpY2socmVkcmF3LCB0cnVlKTtcblxuXHRcdFx0aWYgKCFzZXJpZXMuaXNSZW1vdmluZykgeyAgLyogcHJldmVudCB0cmlnZ2VyaW5nIG5hdGl2ZSBldmVudCBpbiBqUXVlcnlcblx0XHRcdFx0XHQoY2FsbGluZyB0aGUgcmVtb3ZlIGZ1bmN0aW9uIGZyb20gdGhlIHJlbW92ZSBldmVudCkgKi9cblx0XHRcdFx0c2VyaWVzLmlzUmVtb3ZpbmcgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIGZpcmUgdGhlIGV2ZW50IHdpdGggYSBkZWZhdWx0IGhhbmRsZXIgb2YgcmVtb3ZpbmcgdGhlIHBvaW50XG5cdFx0XHRcdGZpcmVFdmVudChzZXJpZXMsICdyZW1vdmUnLCBudWxsLCBmdW5jdGlvbiAoKSB7XG5cblxuXHRcdFx0XHRcdC8vIGRlc3Ryb3kgZWxlbWVudHNcblx0XHRcdFx0XHRzZXJpZXMuZGVzdHJveSgpO1xuXG5cblx0XHRcdFx0XHQvLyByZWRyYXdcblx0XHRcdFx0XHRjaGFydC5pc0RpcnR5TGVnZW5kID0gY2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cdFx0XHRcdFx0Y2hhcnQubGlua1NlcmllcygpO1xuXG5cdFx0XHRcdFx0aWYgKHJlZHJhdykge1xuXHRcdFx0XHRcdFx0Y2hhcnQucmVkcmF3KGFuaW1hdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0fVxuXHRcdFx0c2VyaWVzLmlzUmVtb3ZpbmcgPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBzZXJpZXMgd2l0aCBhIG5ldyBzZXQgb2Ygb3B0aW9uc1xuXHRcdCAqL1xuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKG5ld09wdGlvbnMsIHJlZHJhdykge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gdGhpcy5jaGFydCxcblx0XHRcdFx0Ly8gbXVzdCB1c2UgdXNlciBvcHRpb25zIHdoZW4gY2hhbmdpbmcgdHlwZSBiZWNhdXNlIHRoaXMub3B0aW9ucyBpcyBtZXJnZWRcblx0XHRcdFx0Ly8gaW4gd2l0aCB0eXBlIHNwZWNpZmljIHBsb3RPcHRpb25zXG5cdFx0XHRcdG9sZE9wdGlvbnMgPSB0aGlzLnVzZXJPcHRpb25zLFxuXHRcdFx0XHRvbGRUeXBlID0gdGhpcy50eXBlLFxuXHRcdFx0XHRwcm90byA9IHNlcmllc1R5cGVzW29sZFR5cGVdLnByb3RvdHlwZSxcblx0XHRcdFx0cHJlc2VydmUgPSBbJ2dyb3VwJywgJ21hcmtlckdyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCddLFxuXHRcdFx0XHRuO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSBjaGFuZ2luZyB0eXBlIG9yIHpJbmRleCwgY3JlYXRlIG5ldyBncm91cHMgKCMzMzgwLCAjMzQwNClcblx0XHRcdGlmICgobmV3T3B0aW9ucy50eXBlICYmIG5ld09wdGlvbnMudHlwZSAhPT0gb2xkVHlwZSkgfHwgbmV3T3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwcmVzZXJ2ZS5sZW5ndGggPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgZ3JvdXBzIGFyZSBub3QgZGVzdHJveWVkICgjMzA5NClcblx0XHRcdGVhY2gocHJlc2VydmUsIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdHByZXNlcnZlW3Byb3BdID0gc2VyaWVzW3Byb3BdO1xuXHRcdFx0XHRkZWxldGUgc2VyaWVzW3Byb3BdO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIERvIHRoZSBtZXJnZSwgd2l0aCBzb21lIGZvcmNlZCBvcHRpb25zXG5cdFx0XHRuZXdPcHRpb25zID0gbWVyZ2Uob2xkT3B0aW9ucywge1xuXHRcdFx0XHRhbmltYXRpb246IGZhbHNlLFxuXHRcdFx0XHRpbmRleDogdGhpcy5pbmRleCxcblx0XHRcdFx0cG9pbnRTdGFydDogdGhpcy54RGF0YVswXSAvLyB3aGVuIHVwZGF0aW5nIGFmdGVyIGFkZFBvaW50XG5cdFx0XHR9LCB7IGRhdGE6IHRoaXMub3B0aW9ucy5kYXRhIH0sIG5ld09wdGlvbnMpO1xuXG5cdFx0XHQvLyBEZXN0cm95IHRoZSBzZXJpZXMgYW5kIGRlbGV0ZSBhbGwgcHJvcGVydGllcy4gUmVpbnNlcnQgYWxsIG1ldGhvZHMgXG5cdFx0XHQvLyBhbmQgcHJvcGVydGllcyBmcm9tIHRoZSBuZXcgdHlwZSBwcm90b3R5cGUgKCMyMjcwLCAjMzcxOSlcblx0XHRcdHRoaXMucmVtb3ZlKGZhbHNlKTtcblx0XHRcdGZvciAobiBpbiBwcm90bykge1xuXHRcdFx0XHR0aGlzW25dID0gVU5ERUZJTkVEO1xuXHRcdFx0fVxuXHRcdFx0ZXh0ZW5kKHRoaXMsIHNlcmllc1R5cGVzW25ld09wdGlvbnMudHlwZSB8fCBvbGRUeXBlXS5wcm90b3R5cGUpO1xuXG5cdFx0XHQvLyBSZS1yZWdpc3RlciBncm91cHMgKCMzMDk0KVxuXHRcdFx0ZWFjaChwcmVzZXJ2ZSwgZnVuY3Rpb24gKHByb3ApIHtcblx0XHRcdFx0c2VyaWVzW3Byb3BdID0gcHJlc2VydmVbcHJvcF07XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5pbml0KGNoYXJ0LCBuZXdPcHRpb25zKTtcblx0XHRcdGNoYXJ0LmxpbmtTZXJpZXMoKTsgLy8gTGlua3MgYXJlIGxvc3QgaW4gdGhpcy5yZW1vdmUgKCMzMDI4KVxuXHRcdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0Ly8gRXh0ZW5kIHRoZSBBeGlzLnByb3RvdHlwZSBmb3IgZHluYW1pYyBtZXRob2RzXG5cdGV4dGVuZChBeGlzLnByb3RvdHlwZSwge1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBheGlzIHdpdGggYSBuZXcgb3B0aW9ucyBzdHJ1Y3R1cmVcblx0XHQgKi9cblx0XHR1cGRhdGU6IGZ1bmN0aW9uIChuZXdPcHRpb25zLCByZWRyYXcpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cblx0XHRcdG5ld09wdGlvbnMgPSBjaGFydC5vcHRpb25zW3RoaXMuY29sbF1bdGhpcy5vcHRpb25zLmluZGV4XSA9IG1lcmdlKHRoaXMudXNlck9wdGlvbnMsIG5ld09wdGlvbnMpO1xuXG5cdFx0XHR0aGlzLmRlc3Ryb3kodHJ1ZSk7XG5cdFx0XHR0aGlzLl9hZGRlZFBsb3RMQiA9IFVOREVGSU5FRDsgLy8gIzE2MTEsICMyODg3XG5cblx0XHRcdHRoaXMuaW5pdChjaGFydCwgZXh0ZW5kKG5ld09wdGlvbnMsIHsgZXZlbnRzOiBVTkRFRklORUQgfSkpO1xuXG5cdFx0XHRjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTtcblx0XHRcdGlmIChwaWNrKHJlZHJhdywgdHJ1ZSkpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHQgICAgICogUmVtb3ZlIHRoZSBheGlzIGZyb20gdGhlIGNoYXJ0XG5cdCAgICAgKi9cblx0XHRyZW1vdmU6IGZ1bmN0aW9uIChyZWRyYXcpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdGtleSA9IHRoaXMuY29sbCwgLy8geEF4aXMgb3IgeUF4aXNcblx0XHRcdFx0YXhpc1NlcmllcyA9IHRoaXMuc2VyaWVzLFxuXHRcdFx0XHRpID0gYXhpc1Nlcmllcy5sZW5ndGg7XG5cblx0XHRcdC8vIFJlbW92ZSBhc3NvY2lhdGVkIHNlcmllcyAoIzI2ODcpXG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGlmIChheGlzU2VyaWVzW2ldKSB7XG5cdFx0XHRcdFx0YXhpc1Nlcmllc1tpXS5yZW1vdmUoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSB0aGUgYXhpc1xuXHRcdFx0ZXJhc2UoY2hhcnQuYXhlcywgdGhpcyk7XG5cdFx0XHRlcmFzZShjaGFydFtrZXldLCB0aGlzKTtcblx0XHRcdGNoYXJ0Lm9wdGlvbnNba2V5XS5zcGxpY2UodGhpcy5vcHRpb25zLmluZGV4LCAxKTtcblx0XHRcdGVhY2goY2hhcnRba2V5XSwgZnVuY3Rpb24gKGF4aXMsIGkpIHsgLy8gUmUtaW5kZXgsICMxNzA2XG5cdFx0XHRcdGF4aXMub3B0aW9ucy5pbmRleCA9IGk7XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0Y2hhcnQuaXNEaXJ0eUJveCA9IHRydWU7XG5cblx0XHRcdGlmIChwaWNrKHJlZHJhdywgdHJ1ZSkpIHtcblx0XHRcdFx0Y2hhcnQucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZSB0aGUgYXhpcyB0aXRsZSBieSBvcHRpb25zXG5cdFx0ICovXG5cdFx0c2V0VGl0bGU6IGZ1bmN0aW9uIChuZXdUaXRsZU9wdGlvbnMsIHJlZHJhdykge1xuXHRcdFx0dGhpcy51cGRhdGUoeyB0aXRsZTogbmV3VGl0bGVPcHRpb25zIH0sIHJlZHJhdyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCBuZXcgYXhpcyBjYXRlZ29yaWVzIGFuZCBvcHRpb25hbGx5IHJlZHJhd1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGNhdGVnb3JpZXNcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhd1xuXHRcdCAqL1xuXHRcdHNldENhdGVnb3JpZXM6IGZ1bmN0aW9uIChjYXRlZ29yaWVzLCByZWRyYXcpIHtcblx0XHRcdHRoaXMudXBkYXRlKHsgY2F0ZWdvcmllczogY2F0ZWdvcmllcyB9LCByZWRyYXcpO1xuXHRcdH1cblxuXHR9KTtcblxuXG5cdC8qKlxuXHQgKiBMaW5lU2VyaWVzIG9iamVjdFxuXHQgKi9cblx0dmFyIExpbmVTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMpO1xuXHRzZXJpZXNUeXBlcy5saW5lID0gTGluZVNlcmllcztcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFyZWFcblx0ICovXG5cdGRlZmF1bHRQbG90T3B0aW9ucy5hcmVhID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMsIHtcblx0XHR0aHJlc2hvbGQ6IDBcblx0XHQvLyB0cmFja0J5QXJlYTogZmFsc2UsXG5cdFx0Ly8gbGluZUNvbG9yOiBudWxsLCAvLyBvdmVycmlkZXMgY29sb3IsIGJ1dCBsZXRzIGZpbGxDb2xvciBiZSB1bmFsdGVyZWRcblx0XHQvLyBmaWxsT3BhY2l0eTogMC43NSxcblx0XHQvLyBmaWxsQ29sb3I6IG51bGxcblx0fSk7XG5cblx0LyoqXG5cdCAqIEFyZWFTZXJpZXMgb2JqZWN0XG5cdCAqL1xuXHR2YXIgQXJlYVNlcmllcyA9IGV4dGVuZENsYXNzKFNlcmllcywge1xuXHRcdHR5cGU6ICdhcmVhJyxcblx0XHQvKipcblx0XHQgKiBGb3Igc3RhY2tzLCBkb24ndCBzcGxpdCBzZWdtZW50cyBvbiBudWxsIHZhbHVlcy4gSW5zdGVhZCwgZHJhdyBudWxsIHZhbHVlcyB3aXRoIFxuXHRcdCAqIG5vIG1hcmtlci4gQWxzbyBpbnNlcnQgZHVtbXkgcG9pbnRzIGZvciBhbnkgWCBwb3NpdGlvbiB0aGF0IGV4aXN0cyBpbiBvdGhlciBzZXJpZXNcblx0XHQgKiBpbiB0aGUgc3RhY2suXG5cdFx0ICovIFxuXHRcdGdldFNlZ21lbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0c2VnbWVudHMgPSBbXSxcblx0XHRcdFx0c2VnbWVudCA9IFtdLFxuXHRcdFx0XHRrZXlzID0gW10sXG5cdFx0XHRcdHhBeGlzID0gdGhpcy54QXhpcyxcblx0XHRcdFx0eUF4aXMgPSB0aGlzLnlBeGlzLFxuXHRcdFx0XHRzdGFjayA9IHlBeGlzLnN0YWNrc1t0aGlzLnN0YWNrS2V5XSxcblx0XHRcdFx0cG9pbnRNYXAgPSB7fSxcblx0XHRcdFx0cGxvdFgsXG5cdFx0XHRcdHBsb3RZLFxuXHRcdFx0XHRwb2ludHMgPSB0aGlzLnBvaW50cyxcblx0XHRcdFx0Y29ubmVjdE51bGxzID0gdGhpcy5vcHRpb25zLmNvbm5lY3ROdWxscyxcblx0XHRcdFx0aSxcblx0XHRcdFx0eDtcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdGFja2luZyAmJiAhdGhpcy5jcm9wcGVkKSB7IC8vIGNyb3BwZWQgY2F1c2VzIGFydGVmYWN0cyBpbiBTdG9jaywgYW5kIHBlcmYgaXNzdWVcblx0XHRcdFx0Ly8gQ3JlYXRlIGEgbWFwIHdoZXJlIHdlIGNhbiBxdWlja2x5IGxvb2sgdXAgdGhlIHBvaW50cyBieSB0aGVpciBYIHZhbHVlLlxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cG9pbnRNYXBbcG9pbnRzW2ldLnhdID0gcG9pbnRzW2ldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU29ydCB0aGUga2V5cyAoIzE2NTEpXG5cdFx0XHRcdGZvciAoeCBpbiBzdGFjaykge1xuXHRcdFx0XHRcdGlmIChzdGFja1t4XS50b3RhbCAhPT0gbnVsbCkgeyAvLyBudWxsZWQgYWZ0ZXIgc3dpdGNoaW5nIGJldHdlZW4gZ3JvdXBpbmcgYW5kIG5vdCAoIzE2NTEsICMyMzM2KVxuXHRcdFx0XHRcdFx0a2V5cy5wdXNoKCt4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRlYWNoKGtleXMsIGZ1bmN0aW9uICh4KSB7XG5cdFx0XHRcdFx0dmFyIHkgPSAwLFxuXHRcdFx0XHRcdFx0c3RhY2tQb2ludDtcblxuXHRcdFx0XHRcdGlmIChjb25uZWN0TnVsbHMgJiYgKCFwb2ludE1hcFt4XSB8fCBwb2ludE1hcFt4XS55ID09PSBudWxsKSkgeyAvLyAjMTgzNlxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0Ly8gVGhlIHBvaW50IGV4aXN0cywgcHVzaCBpdCB0byB0aGUgc2VnbWVudFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG9pbnRNYXBbeF0pIHtcblx0XHRcdFx0XHRcdHNlZ21lbnQucHVzaChwb2ludE1hcFt4XSk7XG5cblx0XHRcdFx0XHQvLyBUaGVyZSBpcyBubyBwb2ludCBmb3IgdGhpcyBYIHZhbHVlIGluIHRoaXMgc2VyaWVzLCBzbyB3ZSBcblx0XHRcdFx0XHQvLyBpbnNlcnQgYSBkdW1teSBwb2ludCBpbiBvcmRlciBmb3IgdGhlIGFyZWFzIHRvIGJlIGRyYXduXG5cdFx0XHRcdFx0Ly8gY29ycmVjdGx5LlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIExvb3AgZG93biB0aGUgc3RhY2sgdG8gZmluZCB0aGUgc2VyaWVzIGJlbG93IHRoaXMgb25lIHRoYXQgaGFzXG5cdFx0XHRcdFx0XHQvLyBhIHZhbHVlICgjMTk5MSlcblx0XHRcdFx0XHRcdGZvciAoaSA9IHNlcmllcy5pbmRleDsgaSA8PSB5QXhpcy5zZXJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0c3RhY2tQb2ludCA9IHN0YWNrW3hdLnBvaW50c1tpICsgJywnICsgeF07XG5cdFx0XHRcdFx0XHRcdGlmIChzdGFja1BvaW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0eSA9IHN0YWNrUG9pbnRbMV07XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cGxvdFggPSB4QXhpcy50cmFuc2xhdGUoeCk7XG5cdFx0XHRcdFx0XHRwbG90WSA9IHlBeGlzLnRvUGl4ZWxzKHksIHRydWUpO1xuXHRcdFx0XHRcdFx0c2VnbWVudC5wdXNoKHsgXG5cdFx0XHRcdFx0XHRcdHk6IG51bGwsIFxuXHRcdFx0XHRcdFx0XHRwbG90WDogcGxvdFgsXG5cdFx0XHRcdFx0XHRcdGNsaWVudFg6IHBsb3RYLCBcblx0XHRcdFx0XHRcdFx0cGxvdFk6IHBsb3RZLCBcblx0XHRcdFx0XHRcdFx0eUJvdHRvbTogcGxvdFksXG5cdFx0XHRcdFx0XHRcdG9uTW91c2VPdmVyOiBub29wXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChzZWdtZW50Lmxlbmd0aCkge1xuXHRcdFx0XHRcdHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0U2VyaWVzLnByb3RvdHlwZS5nZXRTZWdtZW50cy5jYWxsKHRoaXMpO1xuXHRcdFx0XHRzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZCB0aGUgYmFzZSBTZXJpZXMgZ2V0U2VnbWVudFBhdGggbWV0aG9kIGJ5IGFkZGluZyB0aGUgcGF0aCBmb3IgdGhlIGFyZWEuXG5cdFx0ICogVGhpcyBwYXRoIGlzIHB1c2hlZCB0byB0aGUgc2VyaWVzLmFyZWFQYXRoIHByb3BlcnR5LlxuXHRcdCAqL1xuXHRcdGdldFNlZ21lbnRQYXRoOiBmdW5jdGlvbiAoc2VnbWVudCkge1xuXHRcdFx0XG5cdFx0XHR2YXIgc2VnbWVudFBhdGggPSBTZXJpZXMucHJvdG90eXBlLmdldFNlZ21lbnRQYXRoLmNhbGwodGhpcywgc2VnbWVudCksIC8vIGNhbGwgYmFzZSBtZXRob2Rcblx0XHRcdFx0YXJlYVNlZ21lbnRQYXRoID0gW10uY29uY2F0KHNlZ21lbnRQYXRoKSwgLy8gd29yayBvbiBhIGNvcHkgZm9yIHRoZSBhcmVhIHBhdGhcblx0XHRcdFx0aSxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0c2VnTGVuZ3RoID0gc2VnbWVudFBhdGgubGVuZ3RoLFxuXHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkID0gdGhpcy55QXhpcy5nZXRUaHJlc2hvbGQob3B0aW9ucy50aHJlc2hvbGQpLCAvLyAjMjE4MVxuXHRcdFx0XHR5Qm90dG9tO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2VnTGVuZ3RoID09PSAzKSB7IC8vIGZvciBhbmltYXRpb24gZnJvbSAxIHRvIHR3byBwb2ludHNcblx0XHRcdFx0YXJlYVNlZ21lbnRQYXRoLnB1c2goTCwgc2VnbWVudFBhdGhbMV0sIHNlZ21lbnRQYXRoWzJdKTtcblx0XHRcdH1cblx0XHRcdGlmIChvcHRpb25zLnN0YWNraW5nICYmICF0aGlzLmNsb3NlZFN0YWNrcykge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRm9sbG93IHN0YWNrIGJhY2suIFRvZG86IGltcGxlbWVudCBhcmVhc3BsaW5lLiBBIGdlbmVyYWwgc29sdXRpb24gY291bGQgYmUgdG8gXG5cdFx0XHRcdC8vIHJldmVyc2UgdGhlIGVudGlyZSBncmFwaFBhdGggb2YgdGhlIHByZXZpb3VzIHNlcmllcywgdGhvdWdoIG1heSBiZSBoYXJkIHdpdGhcblx0XHRcdFx0Ly8gc3BsaW5lcyBhbmQgd2l0aCBzZXJpZXMgd2l0aCBkaWZmZXJlbnQgZXh0cmVtZXNcblx0XHRcdFx0Zm9yIChpID0gc2VnbWVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXG5cdFx0XHRcdFx0eUJvdHRvbSA9IHBpY2soc2VnbWVudFtpXS55Qm90dG9tLCB0cmFuc2xhdGVkVGhyZXNob2xkKTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gc3RlcCBsaW5lP1xuXHRcdFx0XHRcdGlmIChpIDwgc2VnbWVudC5sZW5ndGggLSAxICYmIG9wdGlvbnMuc3RlcCkge1xuXHRcdFx0XHRcdFx0YXJlYVNlZ21lbnRQYXRoLnB1c2goc2VnbWVudFtpICsgMV0ucGxvdFgsIHlCb3R0b20pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRhcmVhU2VnbWVudFBhdGgucHVzaChzZWdtZW50W2ldLnBsb3RYLCB5Qm90dG9tKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgeyAvLyBmb2xsb3cgemVybyBsaW5lIGJhY2tcblx0XHRcdFx0dGhpcy5jbG9zZVNlZ21lbnQoYXJlYVNlZ21lbnRQYXRoLCBzZWdtZW50LCB0cmFuc2xhdGVkVGhyZXNob2xkKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuYXJlYVBhdGggPSB0aGlzLmFyZWFQYXRoLmNvbmNhdChhcmVhU2VnbWVudFBhdGgpO1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRQYXRoO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRXh0ZW5kYWJsZSBtZXRob2QgdG8gY2xvc2UgdGhlIHNlZ21lbnQgcGF0aCBvZiBhbiBhcmVhLiBUaGlzIGlzIG92ZXJyaWRkZW4gaW4gcG9sYXIgXG5cdFx0ICogY2hhcnRzLlxuXHRcdCAqL1xuXHRcdGNsb3NlU2VnbWVudDogZnVuY3Rpb24gKHBhdGgsIHNlZ21lbnQsIHRyYW5zbGF0ZWRUaHJlc2hvbGQpIHtcblx0XHRcdHBhdGgucHVzaChcblx0XHRcdFx0TCxcblx0XHRcdFx0c2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDFdLnBsb3RYLFxuXHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkLFxuXHRcdFx0XHRMLFxuXHRcdFx0XHRzZWdtZW50WzBdLnBsb3RYLFxuXHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkXG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRHJhdyB0aGUgZ3JhcGggYW5kIHRoZSB1bmRlcmx5aW5nIGFyZWEuIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBTZXJpZXMgYmFzZVxuXHRcdCAqIGZ1bmN0aW9uIGFuZCBhZGRzIHRoZSBhcmVhLiBUaGUgYXJlYVBhdGggaXMgY2FsY3VsYXRlZCBpbiB0aGUgZ2V0U2VnbWVudFBhdGhcblx0XHQgKiBtZXRob2QgY2FsbGVkIGZyb20gU2VyaWVzLnByb3RvdHlwZS5kcmF3R3JhcGguXG5cdFx0ICovXG5cdFx0ZHJhd0dyYXBoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcblx0XHRcdC8vIERlZmluZSBvciByZXNldCBhcmVhUGF0aFxuXHRcdFx0dGhpcy5hcmVhUGF0aCA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvLyBDYWxsIHRoZSBiYXNlIG1ldGhvZFxuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5kcmF3R3JhcGguYXBwbHkodGhpcyk7XG5cdFx0XHRcblx0XHRcdC8vIERlZmluZSBsb2NhbCB2YXJpYWJsZXNcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRhcmVhUGF0aCA9IHRoaXMuYXJlYVBhdGgsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHpvbmVzID0gdGhpcy56b25lcyxcblx0XHRcdFx0cHJvcHMgPSBbWydhcmVhJywgdGhpcy5jb2xvciwgb3B0aW9ucy5maWxsQ29sb3JdXTsgLy8gYXJlYSBuYW1lLCBtYWluIGNvbG9yLCBmaWxsIGNvbG9yXG5cdFx0XHRcblx0XHRcdGVhY2goem9uZXMsIGZ1bmN0aW9uICh0aHJlc2hvbGQsIGkpIHtcblx0XHRcdFx0cHJvcHMucHVzaChbJ2NvbG9yQXJlYScgKyBpLCB0aHJlc2hvbGQuY29sb3IgfHwgc2VyaWVzLmNvbG9yLCB0aHJlc2hvbGQuZmlsbENvbG9yIHx8IG9wdGlvbnMuZmlsbENvbG9yXSk7XG5cdFx0XHR9KTtcblx0XHRcdGVhY2gocHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdHZhciBhcmVhS2V5ID0gcHJvcFswXSxcblx0XHRcdFx0XHRhcmVhID0gc2VyaWVzW2FyZWFLZXldO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHQvLyBDcmVhdGUgb3IgdXBkYXRlIHRoZSBhcmVhXG5cdFx0XHRcdGlmIChhcmVhKSB7IC8vIHVwZGF0ZVxuXHRcdFx0XHRcdGFyZWEuYW5pbWF0ZSh7IGQ6IGFyZWFQYXRoIH0pO1xuXHRcdFxuXHRcdFx0XHR9IGVsc2UgeyAvLyBjcmVhdGVcblx0XHRcdFx0XHRzZXJpZXNbYXJlYUtleV0gPSBzZXJpZXMuY2hhcnQucmVuZGVyZXIucGF0aChhcmVhUGF0aClcblx0XHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdFx0ZmlsbDogcGljayhcblx0XHRcdFx0XHRcdFx0XHRwcm9wWzJdLFxuXHRcdFx0XHRcdFx0XHRcdENvbG9yKHByb3BbMV0pLnNldE9wYWNpdHkocGljayhvcHRpb25zLmZpbGxPcGFjaXR5LCAwLjc1KSkuZ2V0KClcblx0XHRcdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRcdFx0ekluZGV4OiAwIC8vICMxMDY5XG5cdFx0XHRcdFx0XHR9KS5hZGQoc2VyaWVzLmdyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGRyYXdMZWdlbmRTeW1ib2w6IExlZ2VuZFN5bWJvbE1peGluLmRyYXdSZWN0YW5nbGVcblx0fSk7XG5cblx0c2VyaWVzVHlwZXMuYXJlYSA9IEFyZWFTZXJpZXM7XG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3Igc3BsaW5lXG5cdCAqL1xuXHRkZWZhdWx0UGxvdE9wdGlvbnMuc3BsaW5lID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMpO1xuXG5cdC8qKlxuXHQgKiBTcGxpbmVTZXJpZXMgb2JqZWN0XG5cdCAqL1xuXHR2YXIgU3BsaW5lU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzLCB7XG5cdFx0dHlwZTogJ3NwbGluZScsXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIHNwbGluZSBzZWdtZW50IGZyb20gYSBnaXZlbiBwb2ludCdzIHByZXZpb3VzIG5laWdoYm91ciB0byB0aGUgZ2l2ZW4gcG9pbnRcblx0XHQgKi9cblx0XHRnZXRQb2ludFNwbGluZTogZnVuY3Rpb24gKHNlZ21lbnQsIHBvaW50LCBpKSB7XG5cdFx0XHR2YXIgc21vb3RoaW5nID0gMS41LCAvLyAxIG1lYW5zIGNvbnRyb2wgcG9pbnRzIG1pZHdheSBiZXR3ZWVuIHBvaW50cywgMiBtZWFucyAxLzMgZnJvbSB0aGUgcG9pbnQsIDMgaXMgMS80IGV0Y1xuXHRcdFx0XHRkZW5vbSA9IHNtb290aGluZyArIDEsXG5cdFx0XHRcdHBsb3RYID0gcG9pbnQucGxvdFgsXG5cdFx0XHRcdHBsb3RZID0gcG9pbnQucGxvdFksXG5cdFx0XHRcdGxhc3RQb2ludCA9IHNlZ21lbnRbaSAtIDFdLFxuXHRcdFx0XHRuZXh0UG9pbnQgPSBzZWdtZW50W2kgKyAxXSxcblx0XHRcdFx0bGVmdENvbnRYLFxuXHRcdFx0XHRsZWZ0Q29udFksXG5cdFx0XHRcdHJpZ2h0Q29udFgsXG5cdFx0XHRcdHJpZ2h0Q29udFksXG5cdFx0XHRcdHJldDtcblxuXHRcdFx0Ly8gZmluZCBjb250cm9sIHBvaW50c1xuXHRcdFx0aWYgKGxhc3RQb2ludCAmJiBuZXh0UG9pbnQpIHtcblx0XHRcdFxuXHRcdFx0XHR2YXIgbGFzdFggPSBsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0bGFzdFkgPSBsYXN0UG9pbnQucGxvdFksXG5cdFx0XHRcdFx0bmV4dFggPSBuZXh0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0bmV4dFkgPSBuZXh0UG9pbnQucGxvdFksXG5cdFx0XHRcdFx0Y29ycmVjdGlvbjtcblxuXHRcdFx0XHRsZWZ0Q29udFggPSAoc21vb3RoaW5nICogcGxvdFggKyBsYXN0WCkgLyBkZW5vbTtcblx0XHRcdFx0bGVmdENvbnRZID0gKHNtb290aGluZyAqIHBsb3RZICsgbGFzdFkpIC8gZGVub207XG5cdFx0XHRcdHJpZ2h0Q29udFggPSAoc21vb3RoaW5nICogcGxvdFggKyBuZXh0WCkgLyBkZW5vbTtcblx0XHRcdFx0cmlnaHRDb250WSA9IChzbW9vdGhpbmcgKiBwbG90WSArIG5leHRZKSAvIGRlbm9tO1xuXG5cdFx0XHRcdC8vIGhhdmUgdGhlIHR3byBjb250cm9sIHBvaW50cyBtYWtlIGEgc3RyYWlnaHQgbGluZSB0aHJvdWdoIG1haW4gcG9pbnRcblx0XHRcdFx0Y29ycmVjdGlvbiA9ICgocmlnaHRDb250WSAtIGxlZnRDb250WSkgKiAocmlnaHRDb250WCAtIHBsb3RYKSkgL1xuXHRcdFx0XHRcdChyaWdodENvbnRYIC0gbGVmdENvbnRYKSArIHBsb3RZIC0gcmlnaHRDb250WTtcblxuXHRcdFx0XHRsZWZ0Q29udFkgKz0gY29ycmVjdGlvbjtcblx0XHRcdFx0cmlnaHRDb250WSArPSBjb3JyZWN0aW9uO1xuXG5cdFx0XHRcdC8vIHRvIHByZXZlbnQgZmFsc2UgZXh0cmVtZXMsIGNoZWNrIHRoYXQgY29udHJvbCBwb2ludHMgYXJlIGJldHdlZW5cblx0XHRcdFx0Ly8gbmVpZ2hib3VyaW5nIHBvaW50cycgeSB2YWx1ZXNcblx0XHRcdFx0aWYgKGxlZnRDb250WSA+IGxhc3RZICYmIGxlZnRDb250WSA+IHBsb3RZKSB7XG5cdFx0XHRcdFx0bGVmdENvbnRZID0gbWF0aE1heChsYXN0WSwgcGxvdFkpO1xuXHRcdFx0XHRcdHJpZ2h0Q29udFkgPSAyICogcGxvdFkgLSBsZWZ0Q29udFk7IC8vIG1pcnJvciBvZiBsZWZ0IGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0fSBlbHNlIGlmIChsZWZ0Q29udFkgPCBsYXN0WSAmJiBsZWZ0Q29udFkgPCBwbG90WSkge1xuXHRcdFx0XHRcdGxlZnRDb250WSA9IG1hdGhNaW4obGFzdFksIHBsb3RZKTtcblx0XHRcdFx0XHRyaWdodENvbnRZID0gMiAqIHBsb3RZIC0gbGVmdENvbnRZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyaWdodENvbnRZID4gbmV4dFkgJiYgcmlnaHRDb250WSA+IHBsb3RZKSB7XG5cdFx0XHRcdFx0cmlnaHRDb250WSA9IG1hdGhNYXgobmV4dFksIHBsb3RZKTtcblx0XHRcdFx0XHRsZWZ0Q29udFkgPSAyICogcGxvdFkgLSByaWdodENvbnRZO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJpZ2h0Q29udFkgPCBuZXh0WSAmJiByaWdodENvbnRZIDwgcGxvdFkpIHtcblx0XHRcdFx0XHRyaWdodENvbnRZID0gbWF0aE1pbihuZXh0WSwgcGxvdFkpO1xuXHRcdFx0XHRcdGxlZnRDb250WSA9IDIgKiBwbG90WSAtIHJpZ2h0Q29udFk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWNvcmQgZm9yIGRyYXdpbmcgaW4gbmV4dCBwb2ludFxuXHRcdFx0XHRwb2ludC5yaWdodENvbnRYID0gcmlnaHRDb250WDtcblx0XHRcdFx0cG9pbnQucmlnaHRDb250WSA9IHJpZ2h0Q29udFk7XG5cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVmlzdWFsaXplIGNvbnRyb2wgcG9pbnRzIGZvciBkZWJ1Z2dpbmdcblx0XHRcdC8qXG5cdFx0XHRpZiAobGVmdENvbnRYKSB7XG5cdFx0XHRcdHRoaXMuY2hhcnQucmVuZGVyZXIuY2lyY2xlKGxlZnRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIGxlZnRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCwgMilcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6ICdyZWQnLFxuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDEsXG5cdFx0XHRcdFx0XHRmaWxsOiAnbm9uZSdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hZGQoKTtcblx0XHRcdFx0dGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKFsnTScsIGxlZnRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIGxlZnRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCxcblx0XHRcdFx0XHQnTCcsIHBsb3RYICsgdGhpcy5jaGFydC5wbG90TGVmdCwgcGxvdFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3BdKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdHN0cm9rZTogJ3JlZCcsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0XHR0aGlzLmNoYXJ0LnJlbmRlcmVyLmNpcmNsZShyaWdodENvbnRYICsgdGhpcy5jaGFydC5wbG90TGVmdCwgcmlnaHRDb250WSArIHRoaXMuY2hhcnQucGxvdFRvcCwgMilcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6ICdncmVlbicsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMSxcblx0XHRcdFx0XHRcdGZpbGw6ICdub25lJ1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0XHR0aGlzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoWydNJywgcmlnaHRDb250WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHJpZ2h0Q29udFkgKyB0aGlzLmNoYXJ0LnBsb3RUb3AsXG5cdFx0XHRcdFx0J0wnLCBwbG90WCArIHRoaXMuY2hhcnQucGxvdExlZnQsIHBsb3RZICsgdGhpcy5jaGFydC5wbG90VG9wXSlcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzdHJva2U6ICdncmVlbicsXG5cdFx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJzogMVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFkZCgpO1xuXHRcdFx0fVxuXHRcdFx0Ki9cblxuXHRcdFx0Ly8gbW92ZVRvIG9yIGxpbmVUb1xuXHRcdFx0aWYgKCFpKSB7XG5cdFx0XHRcdHJldCA9IFtNLCBwbG90WCwgcGxvdFldO1xuXHRcdFx0fSBlbHNlIHsgLy8gY3VydmUgZnJvbSBsYXN0IHBvaW50IHRvIHRoaXNcblx0XHRcdFx0cmV0ID0gW1xuXHRcdFx0XHRcdCdDJyxcblx0XHRcdFx0XHRsYXN0UG9pbnQucmlnaHRDb250WCB8fCBsYXN0UG9pbnQucGxvdFgsXG5cdFx0XHRcdFx0bGFzdFBvaW50LnJpZ2h0Q29udFkgfHwgbGFzdFBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdGxlZnRDb250WCB8fCBwbG90WCxcblx0XHRcdFx0XHRsZWZ0Q29udFkgfHwgcGxvdFksXG5cdFx0XHRcdFx0cGxvdFgsXG5cdFx0XHRcdFx0cGxvdFlcblx0XHRcdFx0XTtcblx0XHRcdFx0bGFzdFBvaW50LnJpZ2h0Q29udFggPSBsYXN0UG9pbnQucmlnaHRDb250WSA9IG51bGw7IC8vIHJlc2V0IGZvciB1cGRhdGluZyBzZXJpZXMgbGF0ZXJcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9KTtcblx0c2VyaWVzVHlwZXMuc3BsaW5lID0gU3BsaW5lU2VyaWVzO1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYXJlYXNwbGluZVxuXHQgKi9cblx0ZGVmYXVsdFBsb3RPcHRpb25zLmFyZWFzcGxpbmUgPSBtZXJnZShkZWZhdWx0UGxvdE9wdGlvbnMuYXJlYSk7XG5cblx0LyoqXG5cdCAqIEFyZWFTcGxpbmVTZXJpZXMgb2JqZWN0XG5cdCAqL1xuXHR2YXIgYXJlYVByb3RvID0gQXJlYVNlcmllcy5wcm90b3R5cGUsXG5cdFx0QXJlYVNwbGluZVNlcmllcyA9IGV4dGVuZENsYXNzKFNwbGluZVNlcmllcywge1xuXHRcdFx0dHlwZTogJ2FyZWFzcGxpbmUnLFxuXHRcdFx0Y2xvc2VkU3RhY2tzOiB0cnVlLCAvLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgcHJldmlvdXMgZ3JhcGggYmFjaywgZm9sbG93IHRoZSB0aHJlc2hvbGQgYmFja1xuXHRcdFx0XG5cdFx0XHQvLyBNaXggaW4gbWV0aG9kcyBmcm9tIHRoZSBhcmVhIHNlcmllc1xuXHRcdFx0Z2V0U2VnbWVudFBhdGg6IGFyZWFQcm90by5nZXRTZWdtZW50UGF0aCxcblx0XHRcdGNsb3NlU2VnbWVudDogYXJlYVByb3RvLmNsb3NlU2VnbWVudCxcblx0XHRcdGRyYXdHcmFwaDogYXJlYVByb3RvLmRyYXdHcmFwaCxcblx0XHRcdGRyYXdMZWdlbmRTeW1ib2w6IExlZ2VuZFN5bWJvbE1peGluLmRyYXdSZWN0YW5nbGVcblx0XHR9KTtcblxuXHRzZXJpZXNUeXBlcy5hcmVhc3BsaW5lID0gQXJlYVNwbGluZVNlcmllcztcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGNvbHVtblxuXHQgKi9cblx0ZGVmYXVsdFBsb3RPcHRpb25zLmNvbHVtbiA9IG1lcmdlKGRlZmF1bHRTZXJpZXNPcHRpb25zLCB7XG5cdFx0Ym9yZGVyQ29sb3I6ICcjRkZGRkZGJyxcblx0XHQvL2JvcmRlcldpZHRoOiAxLFxuXHRcdGJvcmRlclJhZGl1czogMCxcblx0XHQvL2NvbG9yQnlQb2ludDogdW5kZWZpbmVkLFxuXHRcdGdyb3VwUGFkZGluZzogMC4yLFxuXHRcdC8vZ3JvdXBpbmc6IHRydWUsXG5cdFx0bWFya2VyOiBudWxsLCAvLyBwb2ludCBvcHRpb25zIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGJhc2Ugb3B0aW9uc1xuXHRcdHBvaW50UGFkZGluZzogMC4xLFxuXHRcdC8vcG9pbnRXaWR0aDogbnVsbCxcblx0XHRtaW5Qb2ludExlbmd0aDogMCxcblx0XHRjcm9wVGhyZXNob2xkOiA1MCwgLy8gd2hlbiB0aGVyZSBhcmUgbW9yZSBwb2ludHMsIHRoZXkgd2lsbCBub3QgYW5pbWF0ZSBvdXQgb2YgdGhlIGNoYXJ0IG9uIHhBeGlzLnNldEV4dHJlbWVzXG5cdFx0cG9pbnRSYW5nZTogbnVsbCwgLy8gbnVsbCBtZWFucyBhdXRvLCBtZWFuaW5nIDEgaW4gYSBjYXRlZ29yaXplZCBheGlzIGFuZCBsZWFzdCBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBpZiBub3QgY2F0ZWdvcmllc1xuXHRcdHN0YXRlczoge1xuXHRcdFx0aG92ZXI6IHtcblx0XHRcdFx0YnJpZ2h0bmVzczogMC4xLFxuXHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuXHRcdFx0XHRoYWxvOiBmYWxzZVxuXHRcdFx0fSxcblx0XHRcdHNlbGVjdDoge1xuXHRcdFx0XHRjb2xvcjogJyNDMEMwQzAnLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogJyMwMDAwMDAnLFxuXHRcdFx0XHRzaGFkb3c6IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkYXRhTGFiZWxzOiB7XG5cdFx0XHRhbGlnbjogbnVsbCwgLy8gYXV0b1xuXHRcdFx0dmVydGljYWxBbGlnbjogbnVsbCwgLy8gYXV0b1xuXHRcdFx0eTogbnVsbFxuXHRcdH0sXG5cdFx0c3RpY2t5VHJhY2tpbmc6IGZhbHNlLFxuXHRcdHRvb2x0aXA6IHtcblx0XHRcdGRpc3RhbmNlOiA2XG5cdFx0fSxcblx0XHR0aHJlc2hvbGQ6IDBcblx0fSk7XG5cblx0LyoqXG5cdCAqIENvbHVtblNlcmllcyBvYmplY3Rcblx0ICovXG5cdHZhciBDb2x1bW5TZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIHtcblx0XHR0eXBlOiAnY29sdW1uJyxcblx0XHRwb2ludEF0dHJUb09wdGlvbnM6IHsgLy8gbWFwcGluZyBiZXR3ZWVuIFNWRyBhdHRyaWJ1dGVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBvcHRpb25zXG5cdFx0XHRzdHJva2U6ICdib3JkZXJDb2xvcicsXG5cdFx0XHRmaWxsOiAnY29sb3InLFxuXHRcdFx0cjogJ2JvcmRlclJhZGl1cydcblx0XHR9LFxuXHRcdGNyb3BTaG91bGRlcjogMCxcblx0XHRkaXJlY3RUb3VjaDogdHJ1ZSwgLy8gV2hlbiB0b29sdGlwIGlzIG5vdCBzaGFyZWQsIHRoaXMgc2VyaWVzIChhbmQgZGVyaXZhdGl2ZXMpIHJlcXVpcmVzIGRpcmVjdCB0b3VjaC9ob3Zlci4gS0QtdHJlZSBkb2VzIG5vdCBhcHBseS5cblx0XHR0cmFja2VyR3JvdXBzOiBbJ2dyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCddLFxuXHRcdG5lZ1N0YWNrczogdHJ1ZSwgLy8gdXNlIHNlcGFyYXRlIG5lZ2F0aXZlIHN0YWNrcywgdW5saWtlIGFyZWEgc3RhY2tzIHdoZXJlIGEgbmVnYXRpdmUgXG5cdFx0XHQvLyBwb2ludCBpcyBzdWJzdHJhY3RlZCBmcm9tIHByZXZpb3VzICgjMTkxMClcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplIHRoZSBzZXJpZXNcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0O1xuXG5cdFx0XHQvLyBpZiB0aGUgc2VyaWVzIGlzIGFkZGVkIGR5bmFtaWNhbGx5LCBmb3JjZSByZWRyYXcgb2Ygb3RoZXJcblx0XHRcdC8vIHNlcmllcyBhZmZlY3RlZCBieSBhIG5ldyBjb2x1bW5cblx0XHRcdGlmIChjaGFydC5oYXNSZW5kZXJlZCkge1xuXHRcdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKG90aGVyU2VyaWVzKSB7XG5cdFx0XHRcdFx0aWYgKG90aGVyU2VyaWVzLnR5cGUgPT09IHNlcmllcy50eXBlKSB7XG5cdFx0XHRcdFx0XHRvdGhlclNlcmllcy5pc0RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdGhlIHdpZHRoIGFuZCB4IG9mZnNldCBvZiB0aGUgY29sdW1ucyBhZGp1c3RlZCBmb3IgZ3JvdXBpbmcsIGdyb3VwUGFkZGluZywgcG9pbnRQYWRkaW5nLFxuXHRcdCAqIHBvaW50V2lkdGggZXRjLiBcblx0XHQgKi9cblx0XHRnZXRDb2x1bW5NZXRyaWNzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdHhBeGlzID0gc2VyaWVzLnhBeGlzLFxuXHRcdFx0XHR5QXhpcyA9IHNlcmllcy55QXhpcyxcblx0XHRcdFx0cmV2ZXJzZWRYQXhpcyA9IHhBeGlzLnJldmVyc2VkLFxuXHRcdFx0XHRzdGFja0tleSxcblx0XHRcdFx0c3RhY2tHcm91cHMgPSB7fSxcblx0XHRcdFx0Y29sdW1uSW5kZXgsXG5cdFx0XHRcdGNvbHVtbkNvdW50ID0gMDtcblxuXHRcdFx0Ly8gR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1uIHR5cGUgc2VyaWVzLlxuXHRcdFx0Ly8gVGhpcyBpcyBjYWxsZWQgb24gZXZlcnkgc2VyaWVzLiBDb25zaWRlciBtb3ZpbmcgdGhpcyBsb2dpYyB0byBhXG5cdFx0XHQvLyBjaGFydC5vcmRlclN0YWNrcygpIGZ1bmN0aW9uIGFuZCBjYWxsIGl0IG9uIGluaXQsIGFkZFNlcmllcyBhbmQgcmVtb3ZlU2VyaWVzXG5cdFx0XHRpZiAob3B0aW9ucy5ncm91cGluZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29sdW1uQ291bnQgPSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFjaChzZXJpZXMuY2hhcnQuc2VyaWVzLCBmdW5jdGlvbiAob3RoZXJTZXJpZXMpIHtcblx0XHRcdFx0XHR2YXIgb3RoZXJPcHRpb25zID0gb3RoZXJTZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0XHRcdG90aGVyWUF4aXMgPSBvdGhlclNlcmllcy55QXhpcztcblx0XHRcdFx0XHRpZiAob3RoZXJTZXJpZXMudHlwZSA9PT0gc2VyaWVzLnR5cGUgJiYgb3RoZXJTZXJpZXMudmlzaWJsZSAmJlxuXHRcdFx0XHRcdFx0XHR5QXhpcy5sZW4gPT09IG90aGVyWUF4aXMubGVuICYmIHlBeGlzLnBvcyA9PT0gb3RoZXJZQXhpcy5wb3MpIHsgIC8vICM2NDIsICMyMDg2XG5cdFx0XHRcdFx0XHRpZiAob3RoZXJPcHRpb25zLnN0YWNraW5nKSB7XG5cdFx0XHRcdFx0XHRcdHN0YWNrS2V5ID0gb3RoZXJTZXJpZXMuc3RhY2tLZXk7XG5cdFx0XHRcdFx0XHRcdGlmIChzdGFja0dyb3Vwc1tzdGFja0tleV0gPT09IFVOREVGSU5FRCkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YWNrR3JvdXBzW3N0YWNrS2V5XSA9IGNvbHVtbkNvdW50Kys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29sdW1uSW5kZXggPSBzdGFja0dyb3Vwc1tzdGFja0tleV07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG90aGVyT3B0aW9ucy5ncm91cGluZyAhPT0gZmFsc2UpIHsgLy8gIzExNjJcblx0XHRcdFx0XHRcdFx0Y29sdW1uSW5kZXggPSBjb2x1bW5Db3VudCsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b3RoZXJTZXJpZXMuY29sdW1uSW5kZXggPSBjb2x1bW5JbmRleDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2F0ZWdvcnlXaWR0aCA9IG1hdGhNaW4oXG5cdFx0XHRcdFx0bWF0aEFicyh4QXhpcy50cmFuc0EpICogKHhBeGlzLm9yZGluYWxTbG9wZSB8fCBvcHRpb25zLnBvaW50UmFuZ2UgfHwgeEF4aXMuY2xvc2VzdFBvaW50UmFuZ2UgfHwgeEF4aXMudGlja0ludGVydmFsIHx8IDEpLCAvLyAjMjYxMFxuXHRcdFx0XHRcdHhBeGlzLmxlbiAvLyAjMTUzNVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRncm91cFBhZGRpbmcgPSBjYXRlZ29yeVdpZHRoICogb3B0aW9ucy5ncm91cFBhZGRpbmcsXG5cdFx0XHRcdGdyb3VwV2lkdGggPSBjYXRlZ29yeVdpZHRoIC0gMiAqIGdyb3VwUGFkZGluZyxcblx0XHRcdFx0cG9pbnRPZmZzZXRXaWR0aCA9IGdyb3VwV2lkdGggLyBjb2x1bW5Db3VudCxcblx0XHRcdFx0b3B0aW9uUG9pbnRXaWR0aCA9IG9wdGlvbnMucG9pbnRXaWR0aCxcblx0XHRcdFx0cG9pbnRQYWRkaW5nID0gZGVmaW5lZChvcHRpb25Qb2ludFdpZHRoKSA/IChwb2ludE9mZnNldFdpZHRoIC0gb3B0aW9uUG9pbnRXaWR0aCkgLyAyIDpcblx0XHRcdFx0XHRwb2ludE9mZnNldFdpZHRoICogb3B0aW9ucy5wb2ludFBhZGRpbmcsXG5cdFx0XHRcdHBvaW50V2lkdGggPSBwaWNrKG9wdGlvblBvaW50V2lkdGgsIHBvaW50T2Zmc2V0V2lkdGggLSAyICogcG9pbnRQYWRkaW5nKSwgLy8gZXhhY3QgcG9pbnQgd2lkdGgsIHVzZWQgaW4gcG9sYXIgY2hhcnRzXG5cdFx0XHRcdGNvbEluZGV4ID0gKHJldmVyc2VkWEF4aXMgPyBcblx0XHRcdFx0XHRjb2x1bW5Db3VudCAtIChzZXJpZXMuY29sdW1uSW5kZXggfHwgMCkgOiAvLyAjMTI1MVxuXHRcdFx0XHRcdHNlcmllcy5jb2x1bW5JbmRleCkgfHwgMCxcblx0XHRcdFx0cG9pbnRYT2Zmc2V0ID0gcG9pbnRQYWRkaW5nICsgKGdyb3VwUGFkZGluZyArIGNvbEluZGV4ICpcblx0XHRcdFx0XHRwb2ludE9mZnNldFdpZHRoIC0gKGNhdGVnb3J5V2lkdGggLyAyKSkgKlxuXHRcdFx0XHRcdChyZXZlcnNlZFhBeGlzID8gLTEgOiAxKTtcblxuXHRcdFx0Ly8gU2F2ZSBpdCBmb3IgcmVhZGluZyBpbiBsaW5rZWQgc2VyaWVzIChFcnJvciBiYXJzIHBhcnRpY3VsYXJseSlcblx0XHRcdHJldHVybiAoc2VyaWVzLmNvbHVtbk1ldHJpY3MgPSB7IFxuXHRcdFx0XHR3aWR0aDogcG9pbnRXaWR0aCwgXG5cdFx0XHRcdG9mZnNldDogcG9pbnRYT2Zmc2V0IFxuXHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUcmFuc2xhdGUgZWFjaCBwb2ludCB0byB0aGUgcGxvdCBhcmVhIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCBmaW5kIHNoYXBlIHBvc2l0aW9uc1xuXHRcdCAqL1xuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGJvcmRlcldpZHRoID0gc2VyaWVzLmJvcmRlcldpZHRoID0gcGljayhcblx0XHRcdFx0XHRvcHRpb25zLmJvcmRlcldpZHRoLCBcblx0XHRcdFx0XHRzZXJpZXMuY2xvc2VzdFBvaW50UmFuZ2UgKiBzZXJpZXMueEF4aXMudHJhbnNBIDwgMiA/IDAgOiAxIC8vICMzNjM1XG5cdFx0XHRcdCksXG5cdFx0XHRcdHlBeGlzID0gc2VyaWVzLnlBeGlzLFxuXHRcdFx0XHR0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCxcblx0XHRcdFx0dHJhbnNsYXRlZFRocmVzaG9sZCA9IHNlcmllcy50cmFuc2xhdGVkVGhyZXNob2xkID0geUF4aXMuZ2V0VGhyZXNob2xkKHRocmVzaG9sZCksXG5cdFx0XHRcdG1pblBvaW50TGVuZ3RoID0gcGljayhvcHRpb25zLm1pblBvaW50TGVuZ3RoLCA1KSxcblx0XHRcdFx0bWV0cmljcyA9IHNlcmllcy5nZXRDb2x1bW5NZXRyaWNzKCksXG5cdFx0XHRcdHBvaW50V2lkdGggPSBtZXRyaWNzLndpZHRoLFxuXHRcdFx0XHRzZXJpZXNCYXJXID0gc2VyaWVzLmJhclcgPSBtYXRoTWF4KHBvaW50V2lkdGgsIDEgKyAyICogYm9yZGVyV2lkdGgpLCAvLyBwb3N0cHJvY2Vzc2VkIGZvciBib3JkZXIgd2lkdGhcblx0XHRcdFx0cG9pbnRYT2Zmc2V0ID0gc2VyaWVzLnBvaW50WE9mZnNldCA9IG1ldHJpY3Mub2Zmc2V0LFxuXHRcdFx0XHR4Q3Jpc3AgPSAtKGJvcmRlcldpZHRoICUgMiA/IDAuNSA6IDApLFxuXHRcdFx0XHR5Q3Jpc3AgPSBib3JkZXJXaWR0aCAlIDIgPyAwLjUgOiAxO1xuXG5cdFx0XHRpZiAoY2hhcnQucmVuZGVyZXIuaXNWTUwgJiYgY2hhcnQuaW52ZXJ0ZWQpIHtcblx0XHRcdFx0eUNyaXNwICs9IDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdoZW4gdGhlIHBvaW50UGFkZGluZyBpcyAwLCB3ZSB3YW50IHRoZSBjb2x1bW5zIHRvIGJlIHBhY2tlZCB0aWdodGx5LCBzbyB3ZSBhbGxvdyBpbmRpdmlkdWFsXG5cdFx0XHQvLyBjb2x1bW5zIHRvIGhhdmUgaW5kaXZpZHVhbCBzaXplcy4gV2hlbiBwb2ludFBhZGRpbmcgaXMgZ3JlYXRlciwgd2Ugc3RyaXZlIGZvciBlcXVhbC13aWR0aFxuXHRcdFx0Ly8gY29sdW1ucyAoIzI2OTQpLlxuXHRcdFx0aWYgKG9wdGlvbnMucG9pbnRQYWRkaW5nKSB7XG5cdFx0XHRcdHNlcmllc0JhclcgPSBtYXRoQ2VpbChzZXJpZXNCYXJXKTtcblx0XHRcdH1cblxuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS50cmFuc2xhdGUuYXBwbHkoc2VyaWVzKTtcblxuXHRcdFx0Ly8gUmVjb3JkIHRoZSBuZXcgdmFsdWVzXG5cdFx0XHRlYWNoKHNlcmllcy5wb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHR2YXIgeUJvdHRvbSA9IHBpY2socG9pbnQueUJvdHRvbSwgdHJhbnNsYXRlZFRocmVzaG9sZCksXG5cdFx0XHRcdFx0cGxvdFkgPSBtYXRoTWluKG1hdGhNYXgoLTk5OSAtIHlCb3R0b20sIHBvaW50LnBsb3RZKSwgeUF4aXMubGVuICsgOTk5ICsgeUJvdHRvbSksIC8vIERvbid0IGRyYXcgdG9vIGZhciBvdXRzaWRlIHBsb3QgYXJlYSAoIzEzMDMsICMyMjQxKVxuXHRcdFx0XHRcdGJhclggPSBwb2ludC5wbG90WCArIHBvaW50WE9mZnNldCxcblx0XHRcdFx0XHRiYXJXID0gc2VyaWVzQmFyVyxcblx0XHRcdFx0XHRiYXJZID0gbWF0aE1pbihwbG90WSwgeUJvdHRvbSksXG5cdFx0XHRcdFx0cmlnaHQsXG5cdFx0XHRcdFx0Ym90dG9tLFxuXHRcdFx0XHRcdGZyb21Ub3AsXG5cdFx0XHRcdFx0YmFySCA9IG1hdGhNYXgocGxvdFksIHlCb3R0b20pIC0gYmFyWTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgb3B0aW9ucy5taW5Qb2ludExlbmd0aFxuXHRcdFx0XHRpZiAobWF0aEFicyhiYXJIKSA8IG1pblBvaW50TGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYgKG1pblBvaW50TGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRiYXJIID0gbWluUG9pbnRMZW5ndGg7XG5cdFx0XHRcdFx0XHRiYXJZID1cblx0XHRcdFx0XHRcdFx0bWF0aFJvdW5kKG1hdGhBYnMoYmFyWSAtIHRyYW5zbGF0ZWRUaHJlc2hvbGQpID4gbWluUG9pbnRMZW5ndGggPyAvLyBzdGFja2VkXG5cdFx0XHRcdFx0XHRcdFx0eUJvdHRvbSAtIG1pblBvaW50TGVuZ3RoIDogLy8ga2VlcCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQgLSAoeUF4aXMudHJhbnNsYXRlKHBvaW50LnksIDAsIDEsIDAsIDEpIDw9IHRyYW5zbGF0ZWRUaHJlc2hvbGQgPyBtaW5Qb2ludExlbmd0aCA6IDApKTsgLy8gdXNlIGV4YWN0IHlBeGlzLnRyYW5zbGF0aW9uICgjMTQ4NSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWNoZSBmb3IgYWNjZXNzIGluIHBvbGFyXG5cdFx0XHRcdHBvaW50LmJhclggPSBiYXJYO1xuXHRcdFx0XHRwb2ludC5wb2ludFdpZHRoID0gcG9pbnRXaWR0aDtcblxuXHRcdFx0XHQvLyBGaXggdGhlIHRvb2x0aXAgb24gY2VudGVyIG9mIGdyb3VwZWQgY29sdW1ucyAoIzEyMTYsICM0MjQsICMzNjQ4KVxuXHRcdFx0XHRwb2ludC50b29sdGlwUG9zID0gY2hhcnQuaW52ZXJ0ZWQgPyBcblx0XHRcdFx0XHRbeUF4aXMubGVuICsgeUF4aXMucG9zIC0gY2hhcnQucGxvdExlZnQgLSBwbG90WSwgc2VyaWVzLnhBeGlzLmxlbiAtIGJhclggLSBiYXJXIC8gMl0gOiBcblx0XHRcdFx0XHRbYmFyWCArIGJhclcgLyAyLCBwbG90WSArIHlBeGlzLnBvcyAtIGNoYXJ0LnBsb3RUb3BdO1xuXG5cdFx0XHRcdC8vIFJvdW5kIG9mZiB0byBvYnRhaW4gY3Jpc3AgZWRnZXMgYW5kIGF2b2lkIG92ZXJsYXBwaW5nIHdpdGggbmVpZ2hib3VycyAoIzI2OTQpXG5cdFx0XHRcdHJpZ2h0ID0gbWF0aFJvdW5kKGJhclggKyBiYXJXKSArIHhDcmlzcDtcblx0XHRcdFx0YmFyWCA9IG1hdGhSb3VuZChiYXJYKSArIHhDcmlzcDtcblx0XHRcdFx0YmFyVyA9IHJpZ2h0IC0gYmFyWDtcblxuXHRcdFx0XHRmcm9tVG9wID0gbWF0aEFicyhiYXJZKSA8IDAuNTtcblx0XHRcdFx0Ym90dG9tID0gbWF0aE1pbihtYXRoUm91bmQoYmFyWSArIGJhckgpICsgeUNyaXNwLCA5ZTQpOyAvLyAjMzU3NVxuXHRcdFx0XHRiYXJZID0gbWF0aFJvdW5kKGJhclkpICsgeUNyaXNwO1xuXHRcdFx0XHRiYXJIID0gYm90dG9tIC0gYmFyWTtcblxuXHRcdFx0XHQvLyBUb3AgZWRnZXMgYXJlIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKGZyb21Ub3ApIHtcblx0XHRcdFx0XHRiYXJZIC09IDE7XG5cdFx0XHRcdFx0YmFySCArPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVnaXN0ZXIgc2hhcGUgdHlwZSBhbmQgYXJndW1lbnRzIHRvIGJlIHVzZWQgaW4gZHJhd1BvaW50c1xuXHRcdFx0XHRwb2ludC5zaGFwZVR5cGUgPSAncmVjdCc7XG5cdFx0XHRcdHBvaW50LnNoYXBlQXJncyA9IHtcblx0XHRcdFx0XHR4OiBiYXJYLFxuXHRcdFx0XHRcdHk6IGJhclksXG5cdFx0XHRcdFx0d2lkdGg6IGJhclcsXG5cdFx0XHRcdFx0aGVpZ2h0OiBiYXJIXG5cdFx0XHRcdH07XG5cblx0XHRcdH0pO1xuXG5cdFx0fSxcblxuXHRcdGdldFN5bWJvbDogbm9vcCxcblx0XHRcblx0XHQvKipcblx0XHQgKiBVc2UgYSBzb2xpZCByZWN0YW5nbGUgbGlrZSB0aGUgYXJlYSBzZXJpZXMgdHlwZXNcblx0XHQgKi9cblx0XHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlLFxuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIENvbHVtbnMgaGF2ZSBubyBncmFwaFxuXHRcdCAqL1xuXHRcdGRyYXdHcmFwaDogbm9vcCxcblxuXHRcdC8qKlxuXHRcdCAqIERyYXcgdGhlIGNvbHVtbnMuIEZvciBiYXJzLCB0aGUgc2VyaWVzLmdyb3VwIGlzIHJvdGF0ZWQsIHNvIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5cdFx0ICogYXBwbHkgZm9yIGNvbHVtbnMgYW5kIGJhcnMuIFRoaXMgbWV0aG9kIGlzIGluaGVyaXRlZCBieSBzY2F0dGVyIHNlcmllcy5cblx0XHQgKlxuXHRcdCAqL1xuXHRcdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0YW5pbWF0aW9uTGltaXQgPSBvcHRpb25zLmFuaW1hdGlvbkxpbWl0IHx8IDI1MCxcblx0XHRcdFx0c2hhcGVBcmdzLFxuXHRcdFx0XHRwb2ludEF0dHI7XG5cblx0XHRcdC8vIGRyYXcgdGhlIGNvbHVtbnNcblx0XHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdHZhciBwbG90WSA9IHBvaW50LnBsb3RZLFxuXHRcdFx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljLFxuXHRcdFx0XHRcdGJvcmRlckF0dHI7XG5cblx0XHRcdFx0aWYgKHBsb3RZICE9PSBVTkRFRklORUQgJiYgIWlzTmFOKHBsb3RZKSAmJiBwb2ludC55ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0c2hhcGVBcmdzID0gcG9pbnQuc2hhcGVBcmdzO1xuXG5cdFx0XHRcdFx0Ym9yZGVyQXR0ciA9IGRlZmluZWQoc2VyaWVzLmJvcmRlcldpZHRoKSA/IHtcblx0XHRcdFx0XHRcdCdzdHJva2Utd2lkdGgnOiBzZXJpZXMuYm9yZGVyV2lkdGhcblx0XHRcdFx0XHR9IDoge307XG5cblx0XHRcdFx0XHRwb2ludEF0dHIgPSBwb2ludC5wb2ludEF0dHJbcG9pbnQuc2VsZWN0ZWQgPyBTRUxFQ1RfU1RBVEUgOiBOT1JNQUxfU1RBVEVdIHx8IHNlcmllcy5wb2ludEF0dHJbTk9STUFMX1NUQVRFXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiAoZ3JhcGhpYykgeyAvLyB1cGRhdGVcblx0XHRcdFx0XHRcdHN0b3AoZ3JhcGhpYyk7XG5cdFx0XHRcdFx0XHRncmFwaGljLmF0dHIoYm9yZGVyQXR0cilbY2hhcnQucG9pbnRDb3VudCA8IGFuaW1hdGlvbkxpbWl0ID8gJ2FuaW1hdGUnIDogJ2F0dHInXShtZXJnZShzaGFwZUFyZ3MpKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb2ludC5ncmFwaGljID0gZ3JhcGhpYyA9IHJlbmRlcmVyW3BvaW50LnNoYXBlVHlwZV0oc2hhcGVBcmdzKVxuXHRcdFx0XHRcdFx0XHQuYXR0cihib3JkZXJBdHRyKVxuXHRcdFx0XHRcdFx0XHQuYXR0cihwb2ludEF0dHIpXG5cdFx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKVxuXHRcdFx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnMuc2hhZG93LCBudWxsLCBvcHRpb25zLnN0YWNraW5nICYmICFvcHRpb25zLmJvcmRlclJhZGl1cyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdHBvaW50LmdyYXBoaWMgPSBncmFwaGljLmRlc3Ryb3koKTsgLy8gIzEyNjlcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFuaW1hdGUgdGhlIGNvbHVtbiBoZWlnaHRzIG9uZSBieSBvbmUgZnJvbSB6ZXJvXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBpbml0IFdoZXRoZXIgdG8gaW5pdGlhbGl6ZSB0aGUgYW5pbWF0aW9uIG9yIHJ1biBpdFxuXHRcdCAqL1xuXHRcdGFuaW1hdGU6IGZ1bmN0aW9uIChpbml0KSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0eUF4aXMgPSB0aGlzLnlBeGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGludmVydGVkID0gdGhpcy5jaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0YXR0ciA9IHt9LFxuXHRcdFx0XHR0cmFuc2xhdGVkVGhyZXNob2xkO1xuXG5cdFx0XHRpZiAoaGFzU1ZHKSB7IC8vIFZNTCBpcyB0b28gc2xvdyBhbnl3YXlcblx0XHRcdFx0aWYgKGluaXQpIHtcblx0XHRcdFx0XHRhdHRyLnNjYWxlWSA9IDAuMDAxO1xuXHRcdFx0XHRcdHRyYW5zbGF0ZWRUaHJlc2hvbGQgPSBtYXRoTWluKHlBeGlzLnBvcyArIHlBeGlzLmxlbiwgbWF0aE1heCh5QXhpcy5wb3MsIHlBeGlzLnRvUGl4ZWxzKG9wdGlvbnMudGhyZXNob2xkKSkpO1xuXHRcdFx0XHRcdGlmIChpbnZlcnRlZCkge1xuXHRcdFx0XHRcdFx0YXR0ci50cmFuc2xhdGVYID0gdHJhbnNsYXRlZFRocmVzaG9sZCAtIHlBeGlzLmxlbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YXR0ci50cmFuc2xhdGVZID0gdHJhbnNsYXRlZFRocmVzaG9sZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VyaWVzLmdyb3VwLmF0dHIoYXR0cik7XG5cblx0XHRcdFx0fSBlbHNlIHsgLy8gcnVuIHRoZSBhbmltYXRpb25cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRhdHRyLnNjYWxlWSA9IDE7XG5cdFx0XHRcdFx0YXR0cltpbnZlcnRlZCA/ICd0cmFuc2xhdGVYJyA6ICd0cmFuc2xhdGVZJ10gPSB5QXhpcy5wb3M7XG5cdFx0XHRcdFx0c2VyaWVzLmdyb3VwLmFuaW1hdGUoYXR0ciwgc2VyaWVzLm9wdGlvbnMuYW5pbWF0aW9uKTtcblxuXHRcdFx0XHRcdC8vIGRlbGV0ZSB0aGlzIGZ1bmN0aW9uIHRvIGFsbG93IGl0IG9ubHkgb25jZVxuXHRcdFx0XHRcdHNlcmllcy5hbmltYXRlID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoaXMgc2VyaWVzIGZyb20gdGhlIGNoYXJ0XG5cdFx0ICovXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQ7XG5cblx0XHRcdC8vIGNvbHVtbiBhbmQgYmFyIHNlcmllcyBhZmZlY3RzIG90aGVyIHNlcmllcyBvZiB0aGUgc2FtZSB0eXBlXG5cdFx0XHQvLyBhcyB0aGV5IGFyZSBlaXRoZXIgc3RhY2tlZCBvciBncm91cGVkXG5cdFx0XHRpZiAoY2hhcnQuaGFzUmVuZGVyZWQpIHtcblx0XHRcdFx0ZWFjaChjaGFydC5zZXJpZXMsIGZ1bmN0aW9uIChvdGhlclNlcmllcykge1xuXHRcdFx0XHRcdGlmIChvdGhlclNlcmllcy50eXBlID09PSBzZXJpZXMudHlwZSkge1xuXHRcdFx0XHRcdFx0b3RoZXJTZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5yZW1vdmUuYXBwbHkoc2VyaWVzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fSk7XG5cdHNlcmllc1R5cGVzLmNvbHVtbiA9IENvbHVtblNlcmllcztcblx0LyoqXG5cdCAqIFNldCB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBiYXJcblx0ICovXG5cdGRlZmF1bHRQbG90T3B0aW9ucy5iYXIgPSBtZXJnZShkZWZhdWx0UGxvdE9wdGlvbnMuY29sdW1uKTtcblx0LyoqXG5cdCAqIFRoZSBCYXIgc2VyaWVzIGNsYXNzXG5cdCAqL1xuXHR2YXIgQmFyU2VyaWVzID0gZXh0ZW5kQ2xhc3MoQ29sdW1uU2VyaWVzLCB7XG5cdFx0dHlwZTogJ2JhcicsXG5cdFx0aW52ZXJ0ZWQ6IHRydWVcblx0fSk7XG5cdHNlcmllc1R5cGVzLmJhciA9IEJhclNlcmllcztcblxuXHQvKipcblx0ICogU2V0IHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHNjYXR0ZXJcblx0ICovXG5cdGRlZmF1bHRQbG90T3B0aW9ucy5zY2F0dGVyID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMsIHtcblx0XHRsaW5lV2lkdGg6IDAsXG5cdFx0bWFya2VyOiB7XG5cdFx0XHRlbmFibGVkOiB0cnVlIC8vIE92ZXJyaWRlcyBhdXRvLWVuYWJsaW5nIGluIGxpbmUgc2VyaWVzICgjMzY0Nylcblx0XHR9LFxuXHRcdHRvb2x0aXA6IHtcblx0XHRcdGhlYWRlckZvcm1hdDogJzxzcGFuIHN0eWxlPVwiY29sb3I6e3Nlcmllcy5jb2xvcn1cIj5cXHUyNUNGPC9zcGFuPiA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweDtcIj4ge3Nlcmllcy5uYW1lfTwvc3Bhbj48YnIvPicsXG5cdFx0XHRwb2ludEZvcm1hdDogJ3g6IDxiPntwb2ludC54fTwvYj48YnIvPnk6IDxiPntwb2ludC55fTwvYj48YnIvPidcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgc2NhdHRlciBzZXJpZXMgY2xhc3Ncblx0ICovXG5cdHZhciBTY2F0dGVyU2VyaWVzID0gZXh0ZW5kQ2xhc3MoU2VyaWVzLCB7XG5cdFx0dHlwZTogJ3NjYXR0ZXInLFxuXHRcdHNvcnRlZDogZmFsc2UsXG5cdFx0cmVxdWlyZVNvcnRpbmc6IGZhbHNlLFxuXHRcdG5vU2hhcmVkVG9vbHRpcDogdHJ1ZSxcblx0XHR0cmFja2VyR3JvdXBzOiBbJ2dyb3VwJywgJ21hcmtlckdyb3VwJywgJ2RhdGFMYWJlbHNHcm91cCddLFxuXHRcdHRha2VPcmRpbmFsUG9zaXRpb246IGZhbHNlLCAvLyAjMjM0MlxuXHRcdGtkRGltZW5zaW9uczogMixcblx0XHRrZENvbXBhcmVyOiAnZGlzdFInLFxuXHRcdGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5saW5lV2lkdGgpIHtcblx0XHRcdFx0U2VyaWVzLnByb3RvdHlwZS5kcmF3R3JhcGguY2FsbCh0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHNlcmllc1R5cGVzLnNjYXR0ZXIgPSBTY2F0dGVyU2VyaWVzO1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgcGllXG5cdCAqL1xuXHRkZWZhdWx0UGxvdE9wdGlvbnMucGllID0gbWVyZ2UoZGVmYXVsdFNlcmllc09wdGlvbnMsIHtcblx0XHRib3JkZXJDb2xvcjogJyNGRkZGRkYnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdGNlbnRlcjogW251bGwsIG51bGxdLFxuXHRcdGNsaXA6IGZhbHNlLFxuXHRcdGNvbG9yQnlQb2ludDogdHJ1ZSwgLy8gYWx3YXlzIHRydWUgZm9yIHBpZXNcblx0XHRkYXRhTGFiZWxzOiB7XG5cdFx0XHQvLyBhbGlnbjogbnVsbCxcblx0XHRcdC8vIGNvbm5lY3RvcldpZHRoOiAxLFxuXHRcdFx0Ly8gY29ubmVjdG9yQ29sb3I6IHBvaW50LmNvbG9yLFxuXHRcdFx0Ly8gY29ubmVjdG9yUGFkZGluZzogNSxcblx0XHRcdGRpc3RhbmNlOiAzMCxcblx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHsgLy8gIzI5NDVcblx0XHRcdFx0cmV0dXJuIHRoaXMucG9pbnQubmFtZTtcblx0XHRcdH0sXG5cdFx0XHQvLyBzb2Z0Q29ubmVjdG9yOiB0cnVlLFxuXHRcdFx0eDogMFxuXHRcdFx0Ly8geTogMFxuXHRcdH0sXG5cdFx0aWdub3JlSGlkZGVuUG9pbnQ6IHRydWUsXG5cdFx0Ly9pbm5lclNpemU6IDAsXG5cdFx0bGVnZW5kVHlwZTogJ3BvaW50Jyxcblx0XHRtYXJrZXI6IG51bGwsIC8vIHBvaW50IG9wdGlvbnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgYmFzZSBvcHRpb25zXG5cdFx0c2l6ZTogbnVsbCxcblx0XHRzaG93SW5MZWdlbmQ6IGZhbHNlLFxuXHRcdHNsaWNlZE9mZnNldDogMTAsXG5cdFx0c3RhdGVzOiB7XG5cdFx0XHRob3Zlcjoge1xuXHRcdFx0XHRicmlnaHRuZXNzOiAwLjEsXG5cdFx0XHRcdHNoYWRvdzogZmFsc2Vcblx0XHRcdH1cblx0XHR9LFxuXHRcdHN0aWNreVRyYWNraW5nOiBmYWxzZSxcblx0XHR0b29sdGlwOiB7XG5cdFx0XHRmb2xsb3dQb2ludGVyOiB0cnVlXG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogRXh0ZW5kZWQgcG9pbnQgb2JqZWN0IGZvciBwaWVzXG5cdCAqL1xuXHR2YXIgUGllUG9pbnQgPSBleHRlbmRDbGFzcyhQb2ludCwge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYXRlIHRoZSBwaWUgc2xpY2Vcblx0XHQgKi9cblx0XHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFBvaW50LnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHRvZ2dsZVNsaWNlO1xuXG5cdFx0XHRleHRlbmQocG9pbnQsIHtcblx0XHRcdFx0dmlzaWJsZTogcG9pbnQudmlzaWJsZSAhPT0gZmFsc2UsXG5cdFx0XHRcdG5hbWU6IHBpY2socG9pbnQubmFtZSwgJ1NsaWNlJylcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBhZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHNlbGVjdFxuXHRcdFx0dG9nZ2xlU2xpY2UgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRwb2ludC5zbGljZShlLnR5cGUgPT09ICdzZWxlY3QnKTtcblx0XHRcdH07XG5cdFx0XHRhZGRFdmVudChwb2ludCwgJ3NlbGVjdCcsIHRvZ2dsZVNsaWNlKTtcblx0XHRcdGFkZEV2ZW50KHBvaW50LCAndW5zZWxlY3QnLCB0b2dnbGVTbGljZSk7XG5cblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBwaWUgc2xpY2Vcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZpcyBXaGV0aGVyIHRvIHNob3cgdGhlIHNsaWNlIG9yIG5vdC4gSWYgdW5kZWZpbmVkLCB0aGVcblx0XHQgKiAgICB2aXNpYmlsaXR5IGlzIHRvZ2dsZWRcblx0XHQgKi9cblx0XHRzZXRWaXNpYmxlOiBmdW5jdGlvbiAodmlzKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRkb1JlZHJhdyA9ICFzZXJpZXMuaXNEaXJ0eSAmJiBzZXJpZXMub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtcblxuXHRcdFx0Ly8gaWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHRvZ2dsZSB2aXNpYmlsaXR5XG5cdFx0XHRwb2ludC52aXNpYmxlID0gcG9pbnQub3B0aW9ucy52aXNpYmxlID0gdmlzID0gdmlzID09PSBVTkRFRklORUQgPyAhcG9pbnQudmlzaWJsZSA6IHZpcztcblx0XHRcdHNlcmllcy5vcHRpb25zLmRhdGFbaW5BcnJheShwb2ludCwgc2VyaWVzLmRhdGEpXSA9IHBvaW50Lm9wdGlvbnM7IC8vIHVwZGF0ZSB1c2VyT3B0aW9ucy5kYXRhXG5cblx0XHRcdC8vIFNob3cgYW5kIGhpZGUgYXNzb2NpYXRlZCBlbGVtZW50c1xuXHRcdFx0ZWFjaChbJ2dyYXBoaWMnLCAnZGF0YUxhYmVsJywgJ2Nvbm5lY3RvcicsICdzaGFkb3dHcm91cCddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmIChwb2ludFtrZXldKSB7XG5cdFx0XHRcdFx0cG9pbnRba2V5XVt2aXMgPyAnc2hvdycgOiAnaGlkZSddKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHBvaW50LmxlZ2VuZEl0ZW0pIHtcblx0XHRcdFx0aWYgKGNoYXJ0Lmhhc1JlbmRlcmVkKSB7XG5cdFx0XHRcdFx0c2VyaWVzLnVwZGF0ZVRvdGFscygpO1xuXHRcdFx0XHRcdGNoYXJ0LmxlZ2VuZC5jbGVhckl0ZW1zKCk7XG5cdFx0XHRcdFx0aWYgKCFkb1JlZHJhdykge1xuXHRcdFx0XHRcdFx0Y2hhcnQubGVnZW5kLnJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjaGFydC5sZWdlbmQuY29sb3JpemVJdGVtKHBvaW50LCB2aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgaWdub3JlIGhpZGRlbiBzbGljZXNcblx0XHRcdGlmIChkb1JlZHJhdykge1xuXHRcdFx0XHRzZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgb3IgdG9nZ2xlIHdoZXRoZXIgdGhlIHNsaWNlIGlzIGN1dCBvdXQgZnJvbSB0aGUgcGllXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzbGljZWQgV2hlbiB1bmRlZmluZWQsIHRoZSBzbGljZSBzdGF0ZSBpcyB0b2dnbGVkXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSByZWRyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNoYXJ0LiBUcnVlIGJ5IGRlZmF1bHQuXG5cdFx0ICovXG5cdFx0c2xpY2U6IGZ1bmN0aW9uIChzbGljZWQsIHJlZHJhdywgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHR0cmFuc2xhdGlvbjtcblxuXHRcdFx0c2V0QW5pbWF0aW9uKGFuaW1hdGlvbiwgY2hhcnQpO1xuXG5cdFx0XHQvLyByZWRyYXcgaXMgdHJ1ZSBieSBkZWZhdWx0XG5cdFx0XHRyZWRyYXcgPSBwaWNrKHJlZHJhdywgdHJ1ZSk7XG5cblx0XHRcdC8vIGlmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCB0b2dnbGVcblx0XHRcdHBvaW50LnNsaWNlZCA9IHBvaW50Lm9wdGlvbnMuc2xpY2VkID0gc2xpY2VkID0gZGVmaW5lZChzbGljZWQpID8gc2xpY2VkIDogIXBvaW50LnNsaWNlZDtcblx0XHRcdHNlcmllcy5vcHRpb25zLmRhdGFbaW5BcnJheShwb2ludCwgc2VyaWVzLmRhdGEpXSA9IHBvaW50Lm9wdGlvbnM7IC8vIHVwZGF0ZSB1c2VyT3B0aW9ucy5kYXRhXG5cblx0XHRcdHRyYW5zbGF0aW9uID0gc2xpY2VkID8gcG9pbnQuc2xpY2VkVHJhbnNsYXRpb24gOiB7XG5cdFx0XHRcdHRyYW5zbGF0ZVg6IDAsXG5cdFx0XHRcdHRyYW5zbGF0ZVk6IDBcblx0XHRcdH07XG5cblx0XHRcdHBvaW50LmdyYXBoaWMuYW5pbWF0ZSh0cmFuc2xhdGlvbik7XG5cdFx0XHRcblx0XHRcdGlmIChwb2ludC5zaGFkb3dHcm91cCkge1xuXHRcdFx0XHRwb2ludC5zaGFkb3dHcm91cC5hbmltYXRlKHRyYW5zbGF0aW9uKTtcblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRoYWxvUGF0aDogZnVuY3Rpb24gKHNpemUpIHtcblx0XHRcdHZhciBzaGFwZUFyZ3MgPSB0aGlzLnNoYXBlQXJncyxcblx0XHRcdFx0Y2hhcnQgPSB0aGlzLnNlcmllcy5jaGFydDtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2xpY2VkIHx8ICF0aGlzLnZpc2libGUgPyBbXSA6IHRoaXMuc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnN5bWJvbHMuYXJjKGNoYXJ0LnBsb3RMZWZ0ICsgc2hhcGVBcmdzLngsIGNoYXJ0LnBsb3RUb3AgKyBzaGFwZUFyZ3MueSwgc2hhcGVBcmdzLnIgKyBzaXplLCBzaGFwZUFyZ3MuciArIHNpemUsIHtcblx0XHRcdFx0aW5uZXJSOiB0aGlzLnNoYXBlQXJncy5yLFxuXHRcdFx0XHRzdGFydDogc2hhcGVBcmdzLnN0YXJ0LFxuXHRcdFx0XHRlbmQ6IHNoYXBlQXJncy5lbmRcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIFRoZSBQaWUgc2VyaWVzIGNsYXNzXG5cdCAqL1xuXHR2YXIgUGllU2VyaWVzID0ge1xuXHRcdHR5cGU6ICdwaWUnLFxuXHRcdGlzQ2FydGVzaWFuOiBmYWxzZSxcblx0XHRwb2ludENsYXNzOiBQaWVQb2ludCxcblx0XHRyZXF1aXJlU29ydGluZzogZmFsc2UsXG5cdFx0bm9TaGFyZWRUb29sdGlwOiB0cnVlLFxuXHRcdHRyYWNrZXJHcm91cHM6IFsnZ3JvdXAnLCAnZGF0YUxhYmVsc0dyb3VwJ10sXG5cdFx0YXhpc1R5cGVzOiBbXSxcblx0XHRwb2ludEF0dHJUb09wdGlvbnM6IHsgLy8gbWFwcGluZyBiZXR3ZWVuIFNWRyBhdHRyaWJ1dGVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBvcHRpb25zXG5cdFx0XHRzdHJva2U6ICdib3JkZXJDb2xvcicsXG5cdFx0XHQnc3Ryb2tlLXdpZHRoJzogJ2JvcmRlcldpZHRoJyxcblx0XHRcdGZpbGw6ICdjb2xvcidcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUGllcyBoYXZlIG9uZSBjb2xvciBlYWNoIHBvaW50XG5cdFx0ICovXG5cdFx0Z2V0Q29sb3I6IG5vb3AsXG5cblx0XHQvKipcblx0XHQgKiBBbmltYXRlIHRoZSBwaWVzIGluXG5cdFx0ICovXG5cdFx0YW5pbWF0ZTogZnVuY3Rpb24gKGluaXQpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRwb2ludHMgPSBzZXJpZXMucG9pbnRzLFxuXHRcdFx0XHRzdGFydEFuZ2xlUmFkID0gc2VyaWVzLnN0YXJ0QW5nbGVSYWQ7XG5cblx0XHRcdGlmICghaW5pdCkge1xuXHRcdFx0XHRlYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdFx0dmFyIGdyYXBoaWMgPSBwb2ludC5ncmFwaGljLFxuXHRcdFx0XHRcdFx0YXJncyA9IHBvaW50LnNoYXBlQXJncztcblxuXHRcdFx0XHRcdGlmIChncmFwaGljKSB7XG5cdFx0XHRcdFx0XHQvLyBzdGFydCB2YWx1ZXNcblx0XHRcdFx0XHRcdGdyYXBoaWMuYXR0cih7XG5cdFx0XHRcdFx0XHRcdHI6IHNlcmllcy5jZW50ZXJbM10gLyAyLCAvLyBhbmltYXRlIGZyb20gaW5uZXIgcmFkaXVzICgjNzc5KVxuXHRcdFx0XHRcdFx0XHRzdGFydDogc3RhcnRBbmdsZVJhZCxcblx0XHRcdFx0XHRcdFx0ZW5kOiBzdGFydEFuZ2xlUmFkXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0Ly8gYW5pbWF0ZVxuXHRcdFx0XHRcdFx0Z3JhcGhpYy5hbmltYXRlKHtcblx0XHRcdFx0XHRcdFx0cjogYXJncy5yLFxuXHRcdFx0XHRcdFx0XHRzdGFydDogYXJncy5zdGFydCxcblx0XHRcdFx0XHRcdFx0ZW5kOiBhcmdzLmVuZFxuXHRcdFx0XHRcdFx0fSwgc2VyaWVzLm9wdGlvbnMuYW5pbWF0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIGRlbGV0ZSB0aGlzIGZ1bmN0aW9uIHRvIGFsbG93IGl0IG9ubHkgb25jZVxuXHRcdFx0XHRzZXJpZXMuYW5pbWF0ZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEV4dGVuZCB0aGUgYmFzaWMgc2V0RGF0YSBtZXRob2QgYnkgcnVubmluZyBwcm9jZXNzRGF0YSBhbmQgZ2VuZXJhdGVQb2ludHMgaW1tZWRpYXRlbHksXG5cdFx0ICogaW4gb3JkZXIgdG8gYWNjZXNzIHRoZSBwb2ludHMgZnJvbSB0aGUgbGVnZW5kLlxuXHRcdCAqL1xuXHRcdHNldERhdGE6IGZ1bmN0aW9uIChkYXRhLCByZWRyYXcsIGFuaW1hdGlvbiwgdXBkYXRlUG9pbnRzKSB7XG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLnNldERhdGEuY2FsbCh0aGlzLCBkYXRhLCBmYWxzZSwgYW5pbWF0aW9uLCB1cGRhdGVQb2ludHMpO1xuXHRcdFx0dGhpcy5wcm9jZXNzRGF0YSgpO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuXHRcdFx0aWYgKHBpY2socmVkcmF3LCB0cnVlKSkge1xuXHRcdFx0XHR0aGlzLmNoYXJ0LnJlZHJhdyhhbmltYXRpb24pO1xuXHRcdFx0fSBcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVjb21wdXRlIHRvdGFsIGNoYXJ0IHN1bSBhbmQgdXBkYXRlIHBlcmNlbnRhZ2VzIG9mIHBvaW50cy5cblx0XHQgKi9cblx0XHR1cGRhdGVUb3RhbHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHR0b3RhbCA9IDAsXG5cdFx0XHRcdHBvaW50cyxcblx0XHRcdFx0bGVuLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0aWdub3JlSGlkZGVuUG9pbnQgPSB0aGlzLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQ7XG5cblx0XHRcdC8vIFBvcHVsYXRlIGxvY2FsIHZhcnNcblx0XHRcdHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdFx0bGVuID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdFxuXHRcdFx0Ly8gR2V0IHRoZSB0b3RhbCBzdW1cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwb2ludCA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHQvLyBEaXNhbGxvdyBuZWdhdGl2ZSB2YWx1ZXMgKCMxNTMwLCAjMzYyMylcblx0XHRcdFx0aWYgKHBvaW50LnkgPCAwKSB7XG5cdFx0XHRcdFx0cG9pbnQueSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHRvdGFsICs9IChpZ25vcmVIaWRkZW5Qb2ludCAmJiAhcG9pbnQudmlzaWJsZSkgPyAwIDogcG9pbnQueTtcblx0XHRcdH1cblx0XHRcdHRoaXMudG90YWwgPSB0b3RhbDtcblxuXHRcdFx0Ly8gU2V0IGVhY2ggcG9pbnQncyBwcm9wZXJ0aWVzXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdC8vcG9pbnQucGVyY2VudGFnZSA9ICh0b3RhbCA8PSAwIHx8IGlnbm9yZUhpZGRlblBvaW50ICYmICFwb2ludC52aXNpYmxlKSA/IDAgOiBwb2ludC55IC8gdG90YWwgKiAxMDA7XG5cdFx0XHRcdHBvaW50LnBlcmNlbnRhZ2UgPSAodG90YWwgPiAwICYmIChwb2ludC52aXNpYmxlIHx8ICFpZ25vcmVIaWRkZW5Qb2ludCkpID8gcG9pbnQueSAvIHRvdGFsICogMTAwIDogMDtcblx0XHRcdFx0cG9pbnQudG90YWwgPSB0b3RhbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRXh0ZW5kIHRoZSBnZW5lcmF0ZVBvaW50cyBtZXRob2QgYnkgYWRkaW5nIHRvdGFsIGFuZCBwZXJjZW50YWdlIHByb3BlcnRpZXMgdG8gZWFjaCBwb2ludFxuXHRcdCAqL1xuXHRcdGdlbmVyYXRlUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLmdlbmVyYXRlUG9pbnRzLmNhbGwodGhpcyk7XG5cdFx0XHR0aGlzLnVwZGF0ZVRvdGFscygpO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogRG8gdHJhbnNsYXRpb24gZm9yIHBpZSBzbGljZXNcblx0XHQgKi9cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uIChwb3NpdGlvbnMpIHtcblx0XHRcdHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcblx0XHRcdFxuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGN1bXVsYXRpdmUgPSAwLFxuXHRcdFx0XHRwcmVjaXNpb24gPSAxMDAwLCAvLyBpc3N1ZSAjMTcyXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0c2xpY2VkT2Zmc2V0ID0gb3B0aW9ucy5zbGljZWRPZmZzZXQsXG5cdFx0XHRcdGNvbm5lY3Rvck9mZnNldCA9IHNsaWNlZE9mZnNldCArIG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdHN0YXJ0LFxuXHRcdFx0XHRlbmQsXG5cdFx0XHRcdGFuZ2xlLFxuXHRcdFx0XHRzdGFydEFuZ2xlID0gb3B0aW9ucy5zdGFydEFuZ2xlIHx8IDAsXG5cdFx0XHRcdHN0YXJ0QW5nbGVSYWQgPSBzZXJpZXMuc3RhcnRBbmdsZVJhZCA9IG1hdGhQSSAvIDE4MCAqIChzdGFydEFuZ2xlIC0gOTApLFxuXHRcdFx0XHRlbmRBbmdsZVJhZCA9IHNlcmllcy5lbmRBbmdsZVJhZCA9IG1hdGhQSSAvIDE4MCAqICgocGljayhvcHRpb25zLmVuZEFuZ2xlLCBzdGFydEFuZ2xlICsgMzYwKSkgLSA5MCksXG5cdFx0XHRcdGNpcmMgPSBlbmRBbmdsZVJhZCAtIHN0YXJ0QW5nbGVSYWQsIC8vMiAqIG1hdGhQSSxcblx0XHRcdFx0cG9pbnRzID0gc2VyaWVzLnBvaW50cyxcblx0XHRcdFx0cmFkaXVzWCwgLy8gdGhlIHggY29tcG9uZW50IG9mIHRoZSByYWRpdXMgdmVjdG9yIGZvciBhIGdpdmVuIHBvaW50XG5cdFx0XHRcdHJhZGl1c1ksXG5cdFx0XHRcdGxhYmVsRGlzdGFuY2UgPSBvcHRpb25zLmRhdGFMYWJlbHMuZGlzdGFuY2UsXG5cdFx0XHRcdGlnbm9yZUhpZGRlblBvaW50ID0gb3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludCxcblx0XHRcdFx0aSxcblx0XHRcdFx0bGVuID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdFx0cG9pbnQ7XG5cblx0XHRcdC8vIEdldCBwb3NpdGlvbnMgLSBlaXRoZXIgYW4gaW50ZWdlciBvciBhIHBlcmNlbnRhZ2Ugc3RyaW5nIG11c3QgYmUgZ2l2ZW4uXG5cdFx0XHQvLyBJZiBwb3NpdGlvbnMgYXJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlciwgd2UncmUgaW4gYSByZWN1cnNpdmUgbG9vcCBmb3IgYWRqdXN0aW5nXG5cdFx0XHQvLyBzcGFjZSBmb3IgZGF0YSBsYWJlbHMuXG5cdFx0XHRpZiAoIXBvc2l0aW9ucykge1xuXHRcdFx0XHRzZXJpZXMuY2VudGVyID0gcG9zaXRpb25zID0gc2VyaWVzLmdldENlbnRlcigpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1dGlsaXR5IGZvciBnZXR0aW5nIHRoZSB4IHZhbHVlIGZyb20gYSBnaXZlbiB5LCB1c2VkIGZvciBhbnRpY29sbGlzaW9uIGxvZ2ljIGluIGRhdGEgbGFiZWxzXG5cdFx0XHRzZXJpZXMuZ2V0WCA9IGZ1bmN0aW9uICh5LCBsZWZ0KSB7XG5cblx0XHRcdFx0YW5nbGUgPSBtYXRoLmFzaW4obWF0aE1pbigoeSAtIHBvc2l0aW9uc1sxXSkgLyAocG9zaXRpb25zWzJdIC8gMiArIGxhYmVsRGlzdGFuY2UpLCAxKSk7XG5cblx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uc1swXSArXG5cdFx0XHRcdFx0KGxlZnQgPyAtMSA6IDEpICpcblx0XHRcdFx0XHQobWF0aENvcyhhbmdsZSkgKiAocG9zaXRpb25zWzJdIC8gMiArIGxhYmVsRGlzdGFuY2UpKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgZ2VvbWV0cnkgZm9yIGVhY2ggcG9pbnRcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcblx0XHRcdFx0cG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBzZXQgc3RhcnQgYW5kIGVuZCBhbmdsZVxuXHRcdFx0XHRzdGFydCA9IHN0YXJ0QW5nbGVSYWQgKyAoY3VtdWxhdGl2ZSAqIGNpcmMpO1xuXHRcdFx0XHRpZiAoIWlnbm9yZUhpZGRlblBvaW50IHx8IHBvaW50LnZpc2libGUpIHtcblx0XHRcdFx0XHRjdW11bGF0aXZlICs9IHBvaW50LnBlcmNlbnRhZ2UgLyAxMDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZW5kID0gc3RhcnRBbmdsZVJhZCArIChjdW11bGF0aXZlICogY2lyYyk7XG5cblx0XHRcdFx0Ly8gc2V0IHRoZSBzaGFwZVxuXHRcdFx0XHRwb2ludC5zaGFwZVR5cGUgPSAnYXJjJztcblx0XHRcdFx0cG9pbnQuc2hhcGVBcmdzID0ge1xuXHRcdFx0XHRcdHg6IHBvc2l0aW9uc1swXSxcblx0XHRcdFx0XHR5OiBwb3NpdGlvbnNbMV0sXG5cdFx0XHRcdFx0cjogcG9zaXRpb25zWzJdIC8gMixcblx0XHRcdFx0XHRpbm5lclI6IHBvc2l0aW9uc1szXSAvIDIsXG5cdFx0XHRcdFx0c3RhcnQ6IG1hdGhSb3VuZChzdGFydCAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24sXG5cdFx0XHRcdFx0ZW5kOiBtYXRoUm91bmQoZW5kICogcHJlY2lzaW9uKSAvIHByZWNpc2lvblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIFRoZSBhbmdsZSBtdXN0IHN0YXkgd2l0aGluIC05MCBhbmQgMjcwICgjMjY0NSlcblx0XHRcdFx0YW5nbGUgPSAoZW5kICsgc3RhcnQpIC8gMjtcblx0XHRcdFx0aWYgKGFuZ2xlID4gMS41ICogbWF0aFBJKSB7XG5cdFx0XHRcdFx0YW5nbGUgLT0gMiAqIG1hdGhQSTtcblx0XHRcdFx0fSBlbHNlIGlmIChhbmdsZSA8IC1tYXRoUEkgLyAyKSB7XG5cdFx0XHRcdFx0YW5nbGUgKz0gMiAqIG1hdGhQSTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENlbnRlciBmb3IgdGhlIHNsaWNlZCBvdXQgc2xpY2Vcblx0XHRcdFx0cG9pbnQuc2xpY2VkVHJhbnNsYXRpb24gPSB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWDogbWF0aFJvdW5kKG1hdGhDb3MoYW5nbGUpICogc2xpY2VkT2Zmc2V0KSxcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiBtYXRoUm91bmQobWF0aFNpbihhbmdsZSkgKiBzbGljZWRPZmZzZXQpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gc2V0IHRoZSBhbmNob3IgcG9pbnQgZm9yIHRvb2x0aXBzXG5cdFx0XHRcdHJhZGl1c1ggPSBtYXRoQ29zKGFuZ2xlKSAqIHBvc2l0aW9uc1syXSAvIDI7XG5cdFx0XHRcdHJhZGl1c1kgPSBtYXRoU2luKGFuZ2xlKSAqIHBvc2l0aW9uc1syXSAvIDI7XG5cdFx0XHRcdHBvaW50LnRvb2x0aXBQb3MgPSBbXG5cdFx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCAqIDAuNyxcblx0XHRcdFx0XHRwb3NpdGlvbnNbMV0gKyByYWRpdXNZICogMC43XG5cdFx0XHRcdF07XG5cdFx0XHRcdFxuXHRcdFx0XHRwb2ludC5oYWxmID0gYW5nbGUgPCAtbWF0aFBJIC8gMiB8fCBhbmdsZSA+IG1hdGhQSSAvIDIgPyAxIDogMDtcblx0XHRcdFx0cG9pbnQuYW5nbGUgPSBhbmdsZTtcblxuXHRcdFx0XHQvLyBzZXQgdGhlIGFuY2hvciBwb2ludCBmb3IgZGF0YSBsYWJlbHNcblx0XHRcdFx0Y29ubmVjdG9yT2Zmc2V0ID0gbWF0aE1pbihjb25uZWN0b3JPZmZzZXQsIGxhYmVsRGlzdGFuY2UgLyAyKTsgLy8gIzE2Nzhcblx0XHRcdFx0cG9pbnQubGFiZWxQb3MgPSBbXG5cdFx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCArIG1hdGhDb3MoYW5nbGUpICogbGFiZWxEaXN0YW5jZSwgLy8gZmlyc3QgYnJlYWsgb2YgY29ubmVjdG9yXG5cdFx0XHRcdFx0cG9zaXRpb25zWzFdICsgcmFkaXVzWSArIG1hdGhTaW4oYW5nbGUpICogbGFiZWxEaXN0YW5jZSwgLy8gYS9hXG5cdFx0XHRcdFx0cG9zaXRpb25zWzBdICsgcmFkaXVzWCArIG1hdGhDb3MoYW5nbGUpICogY29ubmVjdG9yT2Zmc2V0LCAvLyBzZWNvbmQgYnJlYWssIHJpZ2h0IG91dHNpZGUgcGllXG5cdFx0XHRcdFx0cG9zaXRpb25zWzFdICsgcmFkaXVzWSArIG1hdGhTaW4oYW5nbGUpICogY29ubmVjdG9yT2Zmc2V0LCAvLyBhL2Fcblx0XHRcdFx0XHRwb3NpdGlvbnNbMF0gKyByYWRpdXNYLCAvLyBsYW5kaW5nIHBvaW50IGZvciBjb25uZWN0b3Jcblx0XHRcdFx0XHRwb3NpdGlvbnNbMV0gKyByYWRpdXNZLCAvLyBhL2Fcblx0XHRcdFx0XHRsYWJlbERpc3RhbmNlIDwgMCA/IC8vIGFsaWdubWVudFxuXHRcdFx0XHRcdFx0J2NlbnRlcicgOlxuXHRcdFx0XHRcdFx0cG9pbnQuaGFsZiA/ICdyaWdodCcgOiAnbGVmdCcsIC8vIGFsaWdubWVudFxuXHRcdFx0XHRcdGFuZ2xlIC8vIGNlbnRlciBhbmdsZVxuXHRcdFx0XHRdO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHRkcmF3R3JhcGg6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSBkYXRhIHBvaW50c1xuXHRcdCAqL1xuXHRcdGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0Z3JvdXBUcmFuc2xhdGlvbixcblx0XHRcdFx0Ly9jZW50ZXIsXG5cdFx0XHRcdGdyYXBoaWMsXG5cdFx0XHRcdC8vZ3JvdXAsXG5cdFx0XHRcdHNoYWRvdyA9IHNlcmllcy5vcHRpb25zLnNoYWRvdyxcblx0XHRcdFx0c2hhZG93R3JvdXAsXG5cdFx0XHRcdHNoYXBlQXJncztcblxuXHRcdFx0aWYgKHNoYWRvdyAmJiAhc2VyaWVzLnNoYWRvd0dyb3VwKSB7XG5cdFx0XHRcdHNlcmllcy5zaGFkb3dHcm91cCA9IHJlbmRlcmVyLmcoJ3NoYWRvdycpXG5cdFx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkcmF3IHRoZSBzbGljZXNcblx0XHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdGdyYXBoaWMgPSBwb2ludC5ncmFwaGljO1xuXHRcdFx0XHRzaGFwZUFyZ3MgPSBwb2ludC5zaGFwZUFyZ3M7XG5cdFx0XHRcdHNoYWRvd0dyb3VwID0gcG9pbnQuc2hhZG93R3JvdXA7XG5cblx0XHRcdFx0Ly8gcHV0IHRoZSBzaGFkb3cgYmVoaW5kIGFsbCBwb2ludHNcblx0XHRcdFx0aWYgKHNoYWRvdyAmJiAhc2hhZG93R3JvdXApIHtcblx0XHRcdFx0XHRzaGFkb3dHcm91cCA9IHBvaW50LnNoYWRvd0dyb3VwID0gcmVuZGVyZXIuZygnc2hhZG93Jylcblx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLnNoYWRvd0dyb3VwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIHRoZSBwb2ludCBpcyBzbGljZWQsIHVzZSBzcGVjaWFsIHRyYW5zbGF0aW9uLCBlbHNlIHVzZSBwbG90IGFyZWEgdHJhc2xhdGlvblxuXHRcdFx0XHRncm91cFRyYW5zbGF0aW9uID0gcG9pbnQuc2xpY2VkID8gcG9pbnQuc2xpY2VkVHJhbnNsYXRpb24gOiB7XG5cdFx0XHRcdFx0dHJhbnNsYXRlWDogMCxcblx0XHRcdFx0XHR0cmFuc2xhdGVZOiAwXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly9ncm91cC50cmFuc2xhdGUoZ3JvdXBUcmFuc2xhdGlvblswXSwgZ3JvdXBUcmFuc2xhdGlvblsxXSk7XG5cdFx0XHRcdGlmIChzaGFkb3dHcm91cCkge1xuXHRcdFx0XHRcdHNoYWRvd0dyb3VwLmF0dHIoZ3JvdXBUcmFuc2xhdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBkcmF3IHRoZSBzbGljZVxuXHRcdFx0XHRpZiAoZ3JhcGhpYykge1xuXHRcdFx0XHRcdGdyYXBoaWMuYW5pbWF0ZShleHRlbmQoc2hhcGVBcmdzLCBncm91cFRyYW5zbGF0aW9uKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYyA9IGdyYXBoaWMgPSByZW5kZXJlcltwb2ludC5zaGFwZVR5cGVdKHNoYXBlQXJncylcblx0XHRcdFx0XHRcdC5zZXRSYWRpYWxSZWZlcmVuY2Uoc2VyaWVzLmNlbnRlcilcblx0XHRcdFx0XHRcdC5hdHRyKFxuXHRcdFx0XHRcdFx0XHRwb2ludC5wb2ludEF0dHJbcG9pbnQuc2VsZWN0ZWQgPyBTRUxFQ1RfU1RBVEUgOiBOT1JNQUxfU1RBVEVdXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXR0cih7IFxuXHRcdFx0XHRcdFx0XHQnc3Ryb2tlLWxpbmVqb2luJzogJ3JvdW5kJ1xuXHRcdFx0XHRcdFx0XHQvL3pJbmRleDogMSAvLyAjMjcyMiAocmV2ZXJzZWQpXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmF0dHIoZ3JvdXBUcmFuc2xhdGlvbilcblx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLmdyb3VwKVxuXHRcdFx0XHRcdFx0LnNoYWRvdyhzaGFkb3csIHNoYWRvd0dyb3VwKTtcdFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZGV0ZWN0IHBvaW50IHNwZWNpZmljIHZpc2liaWxpdHkgKCMyNDMwKVxuXHRcdFx0XHRpZiAocG9pbnQudmlzaWJsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cG9pbnQuc2V0VmlzaWJsZShwb2ludC52aXNpYmxlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KTtcblxuXHRcdH0sXG5cblxuXHRcdHNlYXJjaFBvaW50OiBub29wLFxuXG5cdFx0LyoqXG5cdFx0ICogVXRpbGl0eSBmb3Igc29ydGluZyBkYXRhIGxhYmVsc1xuXHRcdCAqL1xuXHRcdHNvcnRCeUFuZ2xlOiBmdW5jdGlvbiAocG9pbnRzLCBzaWduKSB7XG5cdFx0XHRwb2ludHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS5hbmdsZSAhPT0gdW5kZWZpbmVkICYmIChiLmFuZ2xlIC0gYS5hbmdsZSkgKiBzaWduO1xuXHRcdFx0fSk7XG5cdFx0fSxcdFx0XG5cblx0XHQvKipcblx0XHQgKiBVc2UgYSBzaW1wbGUgc3ltYm9sIGZyb20gTGVnZW5kU3ltYm9sTWl4aW5cblx0XHQgKi9cblx0XHRkcmF3TGVnZW5kU3ltYm9sOiBMZWdlbmRTeW1ib2xNaXhpbi5kcmF3UmVjdGFuZ2xlLFxuXG5cdFx0LyoqXG5cdFx0ICogVXNlIHRoZSBnZXRDZW50ZXIgbWV0aG9kIGZyb20gZHJhd0xlZ2VuZFN5bWJvbFxuXHRcdCAqL1xuXHRcdGdldENlbnRlcjogQ2VudGVyZWRTZXJpZXNNaXhpbi5nZXRDZW50ZXIsXG5cblx0XHQvKipcblx0XHQgKiBQaWVzIGRvbid0IGhhdmUgcG9pbnQgbWFya2VyIHN5bWJvbHNcblx0XHQgKi9cblx0XHRnZXRTeW1ib2w6IG5vb3BcblxuXHR9O1xuXHRQaWVTZXJpZXMgPSBleHRlbmRDbGFzcyhTZXJpZXMsIFBpZVNlcmllcyk7XG5cdHNlcmllc1R5cGVzLnBpZSA9IFBpZVNlcmllcztcblxuXHQvKipcblx0ICogRHJhdyB0aGUgZGF0YSBsYWJlbHNcblx0ICovXG5cdFNlcmllcy5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdHNlcmllc09wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdGN1cnNvciA9IHNlcmllc09wdGlvbnMuY3Vyc29yLFxuXHRcdFx0b3B0aW9ucyA9IHNlcmllc09wdGlvbnMuZGF0YUxhYmVscyxcblx0XHRcdHBvaW50cyA9IHNlcmllcy5wb2ludHMsXG5cdFx0XHRwb2ludE9wdGlvbnMsXG5cdFx0XHRnZW5lcmFsT3B0aW9ucyxcblx0XHRcdGhhc1JlbmRlcmVkID0gc2VyaWVzLmhhc1JlbmRlcmVkIHx8IDAsXG5cdFx0XHRzdHIsXG5cdFx0XHRkYXRhTGFiZWxzR3JvdXAsXG5cdFx0XHRyZW5kZXJlciA9IHNlcmllcy5jaGFydC5yZW5kZXJlcjtcblxuXHRcdGlmIChvcHRpb25zLmVuYWJsZWQgfHwgc2VyaWVzLl9oYXNQb2ludExhYmVscykge1xuXG5cdFx0XHQvLyBQcm9jZXNzIGRlZmF1bHQgYWxpZ25tZW50IG9mIGRhdGEgbGFiZWxzIGZvciBjb2x1bW5zXG5cdFx0XHRpZiAoc2VyaWVzLmRsUHJvY2Vzc09wdGlvbnMpIHtcblx0XHRcdFx0c2VyaWVzLmRsUHJvY2Vzc09wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBhIHNlcGFyYXRlIGdyb3VwIGZvciB0aGUgZGF0YSBsYWJlbHMgdG8gYXZvaWQgcm90YXRpb25cblx0XHRcdGRhdGFMYWJlbHNHcm91cCA9IHNlcmllcy5wbG90R3JvdXAoXG5cdFx0XHRcdCdkYXRhTGFiZWxzR3JvdXAnLFxuXHRcdFx0XHQnZGF0YS1sYWJlbHMnLFxuXHRcdFx0XHRvcHRpb25zLmRlZmVyID8gSElEREVOIDogVklTSUJMRSxcblx0XHRcdFx0b3B0aW9ucy56SW5kZXggfHwgNlxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHBpY2sob3B0aW9ucy5kZWZlciwgdHJ1ZSkpIHtcblx0XHRcdFx0ZGF0YUxhYmVsc0dyb3VwLmF0dHIoeyBvcGFjaXR5OiAraGFzUmVuZGVyZWQgfSk7IC8vICMzMzAwXG5cdFx0XHRcdGlmICghaGFzUmVuZGVyZWQpIHtcblx0XHRcdFx0XHRhZGRFdmVudChzZXJpZXMsICdhZnRlckFuaW1hdGUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2VyaWVzLnZpc2libGUpIHsgLy8gIzMwMjMsICMzMDI0XG5cdFx0XHRcdFx0XHRcdGRhdGFMYWJlbHNHcm91cC5zaG93KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWxzR3JvdXBbc2VyaWVzT3B0aW9ucy5hbmltYXRpb24gPyAnYW5pbWF0ZScgOiAnYXR0ciddKHsgb3BhY2l0eTogMSB9LCB7IGR1cmF0aW9uOiAyMDAgfSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSB0aGUgbGFiZWxzIGZvciBlYWNoIHBvaW50XG5cdFx0XHRnZW5lcmFsT3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRlYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cblx0XHRcdFx0dmFyIGVuYWJsZWQsXG5cdFx0XHRcdFx0ZGF0YUxhYmVsID0gcG9pbnQuZGF0YUxhYmVsLFxuXHRcdFx0XHRcdGxhYmVsQ29uZmlnLFxuXHRcdFx0XHRcdGF0dHIsXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRyb3RhdGlvbixcblx0XHRcdFx0XHRjb25uZWN0b3IgPSBwb2ludC5jb25uZWN0b3IsXG5cdFx0XHRcdFx0aXNOZXcgPSB0cnVlLFxuXHRcdFx0XHRcdHN0eWxlLFxuXHRcdFx0XHRcdG1vcmVTdHlsZSA9IHt9O1xuXG5cdFx0XHRcdC8vIERldGVybWluZSBpZiBlYWNoIGRhdGEgbGFiZWwgaXMgZW5hYmxlZFxuXHRcdFx0XHRwb2ludE9wdGlvbnMgPSBwb2ludC5kbE9wdGlvbnMgfHwgKHBvaW50Lm9wdGlvbnMgJiYgcG9pbnQub3B0aW9ucy5kYXRhTGFiZWxzKTsgLy8gZGxPcHRpb25zIGlzIHVzZWQgaW4gdHJlZW1hcHNcblx0XHRcdFx0ZW5hYmxlZCA9IHBpY2socG9pbnRPcHRpb25zICYmIHBvaW50T3B0aW9ucy5lbmFibGVkLCBnZW5lcmFsT3B0aW9ucy5lbmFibGVkKTsgLy8gIzIyODJcblxuXG5cdFx0XHRcdC8vIElmIHRoZSBwb2ludCBpcyBvdXRzaWRlIHRoZSBwbG90IGFyZWEsIGRlc3Ryb3kgaXQuICM2NzgsICM4MjBcblx0XHRcdFx0aWYgKGRhdGFMYWJlbCAmJiAhZW5hYmxlZCkge1xuXHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbCA9IGRhdGFMYWJlbC5kZXN0cm95KCk7XG5cblx0XHRcdFx0Ly8gSW5kaXZpZHVhbCBsYWJlbHMgYXJlIGRpc2FibGVkIGlmIHRoZSBhcmUgZXhwbGljaXRseSBkaXNhYmxlZFxuXHRcdFx0XHQvLyBpbiB0aGUgcG9pbnQgb3B0aW9ucywgb3IgaWYgdGhleSBmYWxsIG91dHNpZGUgdGhlIHBsb3QgYXJlYS5cblx0XHRcdFx0fSBlbHNlIGlmIChlbmFibGVkKSB7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgaW5kaXZpZHVhbCBvcHRpb25zIHN0cnVjdHVyZSB0aGF0IGNhbiBiZSBleHRlbmRlZCB3aXRob3V0XG5cdFx0XHRcdFx0Ly8gYWZmZWN0aW5nIG90aGVyc1xuXHRcdFx0XHRcdG9wdGlvbnMgPSBtZXJnZShnZW5lcmFsT3B0aW9ucywgcG9pbnRPcHRpb25zKTtcblx0XHRcdFx0XHRzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cblx0XHRcdFx0XHRyb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdGxhYmVsQ29uZmlnID0gcG9pbnQuZ2V0TGFiZWxDb25maWcoKTtcblx0XHRcdFx0XHRzdHIgPSBvcHRpb25zLmZvcm1hdCA/XG5cdFx0XHRcdFx0XHRmb3JtYXQob3B0aW9ucy5mb3JtYXQsIGxhYmVsQ29uZmlnKSA6XG5cdFx0XHRcdFx0XHRvcHRpb25zLmZvcm1hdHRlci5jYWxsKGxhYmVsQ29uZmlnLCBvcHRpb25zKTtcblxuXHRcdFx0XHRcdC8vIERldGVybWluZSB0aGUgY29sb3Jcblx0XHRcdFx0XHRzdHlsZS5jb2xvciA9IHBpY2sob3B0aW9ucy5jb2xvciwgc3R5bGUuY29sb3IsIHNlcmllcy5jb2xvciwgJ2JsYWNrJyk7XG5cblxuXHRcdFx0XHRcdC8vIHVwZGF0ZSBleGlzdGluZyBsYWJlbFxuXHRcdFx0XHRcdGlmIChkYXRhTGFiZWwpIHtcblxuXHRcdFx0XHRcdFx0aWYgKGRlZmluZWQoc3RyKSkge1xuXHRcdFx0XHRcdFx0XHRkYXRhTGFiZWxcblx0XHRcdFx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiBzdHJcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0aXNOZXcgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gIzE0MzcgLSB0aGUgbGFiZWwgaXMgc2hvd24gY29uZGl0aW9uYWxseVxuXHRcdFx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwgPSBkYXRhTGFiZWwgPSBkYXRhTGFiZWwuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoY29ubmVjdG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuY29ubmVjdG9yID0gY29ubmVjdG9yLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIG5ldyBsYWJlbFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGVmaW5lZChzdHIpKSB7XG5cdFx0XHRcdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRcdFx0XHQvL2FsaWduOiBhbGlnbixcblx0XHRcdFx0XHRcdFx0ZmlsbDogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZTogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRcdHI6IG9wdGlvbnMuYm9yZGVyUmFkaXVzIHx8IDAsXG5cdFx0XHRcdFx0XHRcdHJvdGF0aW9uOiByb3RhdGlvbixcblx0XHRcdFx0XHRcdFx0cGFkZGluZzogb3B0aW9ucy5wYWRkaW5nLFxuXHRcdFx0XHRcdFx0XHR6SW5kZXg6IDFcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIEdldCBhdXRvbWF0ZWQgY29udHJhc3QgY29sb3Jcblx0XHRcdFx0XHRcdGlmIChzdHlsZS5jb2xvciA9PT0gJ2NvbnRyYXN0Jykge1xuXHRcdFx0XHRcdFx0XHRtb3JlU3R5bGUuY29sb3IgPSBvcHRpb25zLmluc2lkZSB8fCBvcHRpb25zLmRpc3RhbmNlIDwgMCB8fCAhIXNlcmllc09wdGlvbnMuc3RhY2tpbmcgPyBcblx0XHRcdFx0XHRcdFx0XHRyZW5kZXJlci5nZXRDb250cmFzdChwb2ludC5jb2xvciB8fCBzZXJpZXMuY29sb3IpIDogXG5cdFx0XHRcdFx0XHRcdFx0JyMwMDAwMDAnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1cnNvcikge1xuXHRcdFx0XHRcdFx0XHRtb3JlU3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSB1bnVzZWQgYXR0cmlidXRlcyAoIzk0Nylcblx0XHRcdFx0XHRcdGZvciAobmFtZSBpbiBhdHRyKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhdHRyW25hbWVdID09PSBVTkRFRklORUQpIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgYXR0cltuYW1lXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWwgPSByZW5kZXJlcltyb3RhdGlvbiA/ICd0ZXh0JyA6ICdsYWJlbCddKCAvLyBsYWJlbHMgZG9uJ3Qgc3VwcG9ydCByb3RhdGlvblxuXHRcdFx0XHRcdFx0XHRzdHIsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdC05OTksXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuc2hhcGUsXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMudXNlSFRNTFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmF0dHIoYXR0cilcblx0XHRcdFx0XHRcdC5jc3MoZXh0ZW5kKHN0eWxlLCBtb3JlU3R5bGUpKVxuXHRcdFx0XHRcdFx0LmFkZChkYXRhTGFiZWxzR3JvdXApXG5cdFx0XHRcdFx0XHQuc2hhZG93KG9wdGlvbnMuc2hhZG93KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkYXRhTGFiZWwpIHtcblx0XHRcdFx0XHRcdC8vIE5vdyB0aGUgZGF0YSBsYWJlbCBpcyBjcmVhdGVkIGFuZCBwbGFjZWQgYXQgMCwwLCBzbyB3ZSBuZWVkIHRvIGFsaWduIGl0XG5cdFx0XHRcdFx0XHRzZXJpZXMuYWxpZ25EYXRhTGFiZWwocG9pbnQsIGRhdGFMYWJlbCwgb3B0aW9ucywgbnVsbCwgaXNOZXcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbGlnbiBlYWNoIGluZGl2aWR1YWwgZGF0YSBsYWJlbFxuXHQgKi9cblx0U2VyaWVzLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9IGZ1bmN0aW9uIChwb2ludCwgZGF0YUxhYmVsLCBvcHRpb25zLCBhbGlnblRvLCBpc05ldykge1xuXHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQsXG5cdFx0XHRpbnZlcnRlZCA9IGNoYXJ0LmludmVydGVkLFxuXHRcdFx0cGxvdFggPSBwaWNrKHBvaW50LnBsb3RYLCAtOTk5KSxcblx0XHRcdHBsb3RZID0gcGljayhwb2ludC5wbG90WSwgLTk5OSksXG5cdFx0XHRiQm94ID0gZGF0YUxhYmVsLmdldEJCb3goKSxcblx0XHRcdGJhc2VsaW5lID0gY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3Mob3B0aW9ucy5zdHlsZS5mb250U2l6ZSkuYixcblx0XHRcdHJvdENvcnIsIC8vIHJvdGF0aW9uIGNvcnJlY3Rpb25cblx0XHRcdC8vIE1hdGgucm91bmQgZm9yIHJvdW5kaW5nIGVycm9ycyAoIzI2ODMpLCBhbGlnblRvIHRvIGFsbG93IGNvbHVtbiBsYWJlbHMgKCMyNzAwKVxuXHRcdFx0dmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiAocG9pbnQuc2VyaWVzLmZvcmNlREwgfHwgY2hhcnQuaXNJbnNpZGVQbG90KHBsb3RYLCBtYXRoUm91bmQocGxvdFkpLCBpbnZlcnRlZCkgfHxcblx0XHRcdFx0KGFsaWduVG8gJiYgY2hhcnQuaXNJbnNpZGVQbG90KHBsb3RYLCBpbnZlcnRlZCA/IGFsaWduVG8ueCArIDEgOiBhbGlnblRvLnkgKyBhbGlnblRvLmhlaWdodCAtIDEsIGludmVydGVkKSkpLFxuXHRcdFx0YWxpZ25BdHRyOyAvLyB0aGUgZmluYWwgcG9zaXRpb247XG5cblx0XHRpZiAodmlzaWJsZSkge1xuXG5cdFx0XHQvLyBUaGUgYWxpZ25tZW50IGJveCBpcyBhIHNpbmd1bGFyIHBvaW50XG5cdFx0XHRhbGlnblRvID0gZXh0ZW5kKHtcblx0XHRcdFx0eDogaW52ZXJ0ZWQgPyBjaGFydC5wbG90V2lkdGggLSBwbG90WSA6IHBsb3RYLFxuXHRcdFx0XHR5OiBtYXRoUm91bmQoaW52ZXJ0ZWQgPyBjaGFydC5wbG90SGVpZ2h0IC0gcGxvdFggOiBwbG90WSksXG5cdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRoZWlnaHQ6IDBcblx0XHRcdH0sIGFsaWduVG8pO1xuXG5cdFx0XHQvLyBBZGQgdGhlIHRleHQgc2l6ZSBmb3IgYWxpZ25tZW50IGNhbGN1bGF0aW9uXG5cdFx0XHRleHRlbmQob3B0aW9ucywge1xuXHRcdFx0XHR3aWR0aDogYkJveC53aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBiQm94LmhlaWdodFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFsbG93IGEgaG9vayBmb3IgY2hhbmdpbmcgYWxpZ25tZW50IGluIHRoZSBsYXN0IG1vbWVudCwgdGhlbiBkbyB0aGUgYWxpZ25tZW50XG5cdFx0XHRpZiAob3B0aW9ucy5yb3RhdGlvbikgeyAvLyBGYW5jeSBib3ggYWxpZ25tZW50IGlzbid0IHN1cHBvcnRlZCBmb3Igcm90YXRlZCB0ZXh0XG5cdFx0XHRcdHJvdENvcnIgPSBjaGFydC5yZW5kZXJlci5yb3RDb3JyKGJhc2VsaW5lLCBvcHRpb25zLnJvdGF0aW9uKTsgLy8gIzM3MjNcblx0XHRcdFx0ZGF0YUxhYmVsW2lzTmV3ID8gJ2F0dHInIDogJ2FuaW1hdGUnXSh7XG5cdFx0XHRcdFx0XHR4OiBhbGlnblRvLnggKyBvcHRpb25zLnggKyBhbGlnblRvLndpZHRoIC8gMiArIHJvdENvcnIueCxcblx0XHRcdFx0XHRcdHk6IGFsaWduVG8ueSArIG9wdGlvbnMueSArIGFsaWduVG8uaGVpZ2h0IC8gMlxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmF0dHIoeyAvLyAjMzAwM1xuXHRcdFx0XHRcdFx0YWxpZ246IG9wdGlvbnMuYWxpZ25cblx0XHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFMYWJlbC5hbGlnbihvcHRpb25zLCBudWxsLCBhbGlnblRvKTtcblx0XHRcdFx0YWxpZ25BdHRyID0gZGF0YUxhYmVsLmFsaWduQXR0cjtcblxuXHRcdFx0XHQvLyBIYW5kbGUganVzdGlmeSBvciBjcm9wXG5cdFx0XHRcdGlmIChwaWNrKG9wdGlvbnMub3ZlcmZsb3csICdqdXN0aWZ5JykgPT09ICdqdXN0aWZ5Jykge1xuXHRcdFx0XHRcdHRoaXMuanVzdGlmeURhdGFMYWJlbChkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduQXR0ciwgYkJveCwgYWxpZ25UbywgaXNOZXcpO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAocGljayhvcHRpb25zLmNyb3AsIHRydWUpKSB7XG5cdFx0XHRcdFx0Ly8gTm93IGNoZWNrIHRoYXQgdGhlIGRhdGEgbGFiZWwgaXMgd2l0aGluIHRoZSBwbG90IGFyZWFcblx0XHRcdFx0XHR2aXNpYmxlID0gY2hhcnQuaXNJbnNpZGVQbG90KGFsaWduQXR0ci54LCBhbGlnbkF0dHIueSkgJiYgY2hhcnQuaXNJbnNpZGVQbG90KGFsaWduQXR0ci54ICsgYkJveC53aWR0aCwgYWxpZ25BdHRyLnkgKyBiQm94LmhlaWdodCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdoZW4gd2UncmUgdXNpbmcgYSBzaGFwZSwgbWFrZSBpdCBwb3NzaWJsZSB3aXRoIGEgY29ubmVjdG9yIG9yIGFuIGFycm93IHBvaW50aW5nIHRvIHRoaWUgcG9pbnRcblx0XHRcdFx0aWYgKG9wdGlvbnMuc2hhcGUpIHtcblx0XHRcdFx0XHRkYXRhTGFiZWwuYXR0cih7XG5cdFx0XHRcdFx0XHRhbmNob3JYOiBwb2ludC5wbG90WCxcblx0XHRcdFx0XHRcdGFuY2hvclk6IHBvaW50LnBsb3RZXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNob3cgb3IgaGlkZSBiYXNlZCBvbiB0aGUgZmluYWwgYWxpZ25lZCBwb3NpdGlvblxuXHRcdGlmICghdmlzaWJsZSkge1xuXHRcdFx0ZGF0YUxhYmVsLmF0dHIoeyB5OiAtOTk5IH0pO1xuXHRcdFx0ZGF0YUxhYmVsLnBsYWNlZCA9IGZhbHNlOyAvLyBkb24ndCBhbmltYXRlIGJhY2sgaW5cblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogSWYgZGF0YSBsYWJlbHMgZmFsbCBwYXJ0bHkgb3V0c2lkZSB0aGUgcGxvdCBhcmVhLCBhbGlnbiB0aGVtIGJhY2sgaW4sIGluIGEgd2F5IHRoYXRcblx0ICogZG9lc24ndCBoaWRlIHRoZSBwb2ludC5cblx0ICovXG5cdFNlcmllcy5wcm90b3R5cGUuanVzdGlmeURhdGFMYWJlbCA9IGZ1bmN0aW9uIChkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduQXR0ciwgYkJveCwgYWxpZ25UbywgaXNOZXcpIHtcblx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0LFxuXHRcdFx0YWxpZ24gPSBvcHRpb25zLmFsaWduLFxuXHRcdFx0dmVydGljYWxBbGlnbiA9IG9wdGlvbnMudmVydGljYWxBbGlnbixcblx0XHRcdG9mZixcblx0XHRcdGp1c3RpZmllZCxcblx0XHRcdHBhZGRpbmcgPSBkYXRhTGFiZWwuYm94ID8gMCA6IChkYXRhTGFiZWwucGFkZGluZyB8fCAwKTtcblxuXHRcdC8vIE9mZiBsZWZ0XG5cdFx0b2ZmID0gYWxpZ25BdHRyLnggKyBwYWRkaW5nO1xuXHRcdGlmIChvZmYgPCAwKSB7XG5cdFx0XHRpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0b3B0aW9ucy5hbGlnbiA9ICdsZWZ0Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMueCA9IC1vZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9mZiByaWdodFxuXHRcdG9mZiA9IGFsaWduQXR0ci54ICsgYkJveC53aWR0aCAtIHBhZGRpbmc7XG5cdFx0aWYgKG9mZiA+IGNoYXJ0LnBsb3RXaWR0aCkge1xuXHRcdFx0aWYgKGFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0b3B0aW9ucy5hbGlnbiA9ICdyaWdodCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLnggPSBjaGFydC5wbG90V2lkdGggLSBvZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9mZiB0b3Bcblx0XHRvZmYgPSBhbGlnbkF0dHIueSArIHBhZGRpbmc7XG5cdFx0aWYgKG9mZiA8IDApIHtcblx0XHRcdGlmICh2ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuXHRcdFx0XHRvcHRpb25zLnZlcnRpY2FsQWxpZ24gPSAndG9wJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMueSA9IC1vZmY7XG5cdFx0XHR9XG5cdFx0XHRqdXN0aWZpZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9mZiBib3R0b21cblx0XHRvZmYgPSBhbGlnbkF0dHIueSArIGJCb3guaGVpZ2h0IC0gcGFkZGluZztcblx0XHRpZiAob2ZmID4gY2hhcnQucGxvdEhlaWdodCkge1xuXHRcdFx0aWYgKHZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0XHRcdG9wdGlvbnMudmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0aW9ucy55ID0gY2hhcnQucGxvdEhlaWdodCAtIG9mZjtcblx0XHRcdH1cblx0XHRcdGp1c3RpZmllZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGp1c3RpZmllZCkge1xuXHRcdFx0ZGF0YUxhYmVsLnBsYWNlZCA9ICFpc05ldztcblx0XHRcdGRhdGFMYWJlbC5hbGlnbihvcHRpb25zLCBudWxsLCBhbGlnblRvKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRlIHRoZSBiYXNlIGRyYXdEYXRhTGFiZWxzIG1ldGhvZCBieSBwaWUgc3BlY2lmaWMgZnVuY3Rpb25hbGl0eVxuXHQgKi9cblx0aWYgKHNlcmllc1R5cGVzLnBpZSkge1xuXHRcdHNlcmllc1R5cGVzLnBpZS5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0ZGF0YSA9IHNlcmllcy5kYXRhLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucy5kYXRhTGFiZWxzLFxuXHRcdFx0XHRjb25uZWN0b3JQYWRkaW5nID0gcGljayhvcHRpb25zLmNvbm5lY3RvclBhZGRpbmcsIDEwKSxcblx0XHRcdFx0Y29ubmVjdG9yV2lkdGggPSBwaWNrKG9wdGlvbnMuY29ubmVjdG9yV2lkdGgsIDEpLFxuXHRcdFx0XHRwbG90V2lkdGggPSBjaGFydC5wbG90V2lkdGgsXG5cdFx0XHRcdHBsb3RIZWlnaHQgPSBjaGFydC5wbG90SGVpZ2h0LFxuXHRcdFx0XHRjb25uZWN0b3IsXG5cdFx0XHRcdGNvbm5lY3RvclBhdGgsXG5cdFx0XHRcdHNvZnRDb25uZWN0b3IgPSBwaWNrKG9wdGlvbnMuc29mdENvbm5lY3RvciwgdHJ1ZSksXG5cdFx0XHRcdGRpc3RhbmNlT3B0aW9uID0gb3B0aW9ucy5kaXN0YW5jZSxcblx0XHRcdFx0c2VyaWVzQ2VudGVyID0gc2VyaWVzLmNlbnRlcixcblx0XHRcdFx0cmFkaXVzID0gc2VyaWVzQ2VudGVyWzJdIC8gMixcblx0XHRcdFx0Y2VudGVyWSA9IHNlcmllc0NlbnRlclsxXSxcblx0XHRcdFx0b3V0c2lkZSA9IGRpc3RhbmNlT3B0aW9uID4gMCxcblx0XHRcdFx0ZGF0YUxhYmVsLFxuXHRcdFx0XHRkYXRhTGFiZWxXaWR0aCxcblx0XHRcdFx0bGFiZWxQb3MsXG5cdFx0XHRcdGxhYmVsSGVpZ2h0LFxuXHRcdFx0XHRoYWx2ZXMgPSBbLy8gZGl2aWRlIHRoZSBwb2ludHMgaW50byByaWdodCBhbmQgbGVmdCBoYWx2ZXMgZm9yIGFudGkgY29sbGlzaW9uXG5cdFx0XHRcdFx0W10sIC8vIHJpZ2h0XG5cdFx0XHRcdFx0W10gIC8vIGxlZnRcblx0XHRcdFx0XSxcblx0XHRcdFx0eCxcblx0XHRcdFx0eSxcblx0XHRcdFx0dmlzaWJpbGl0eSxcblx0XHRcdFx0cmFua0Fycixcblx0XHRcdFx0aSxcblx0XHRcdFx0aixcblx0XHRcdFx0b3ZlcmZsb3cgPSBbMCwgMCwgMCwgMF0sIC8vIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuXHRcdFx0XHRzb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYi55IC0gYS55O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBnZXQgb3V0IGlmIG5vdCBlbmFibGVkXG5cdFx0XHRpZiAoIXNlcmllcy52aXNpYmxlIHx8ICghb3B0aW9ucy5lbmFibGVkICYmICFzZXJpZXMuX2hhc1BvaW50TGFiZWxzKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJ1biBwYXJlbnQgbWV0aG9kXG5cdFx0XHRTZXJpZXMucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzLmFwcGx5KHNlcmllcyk7XG5cblx0XHRcdC8vIGFycmFuZ2UgcG9pbnRzIGZvciBkZXRlY3Rpb24gY29sbGlzaW9uXG5cdFx0XHRlYWNoKGRhdGEsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRpZiAocG9pbnQuZGF0YUxhYmVsICYmIHBvaW50LnZpc2libGUpIHsgLy8gIzQwNywgIzI1MTBcblx0XHRcdFx0XHRoYWx2ZXNbcG9pbnQuaGFsZl0ucHVzaChwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvKiBMb29wIG92ZXIgdGhlIHBvaW50cyBpbiBlYWNoIGhhbGYsIHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBhbmQgYm90dG9tXG5cdFx0XHQgKiBvZiB0aGUgcGllIHRvIGRldGVjdCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdFx0XHQgKi9cblx0XHRcdGkgPSAyO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXG5cdFx0XHRcdHZhciBzbG90cyA9IFtdLFxuXHRcdFx0XHRcdHNsb3RzTGVuZ3RoLFxuXHRcdFx0XHRcdHVzZWRTbG90cyA9IFtdLFxuXHRcdFx0XHRcdHBvaW50cyA9IGhhbHZlc1tpXSxcblx0XHRcdFx0XHRwb3MsXG5cdFx0XHRcdFx0Ym90dG9tLFxuXHRcdFx0XHRcdGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG5cdFx0XHRcdFx0c2xvdEluZGV4O1xuXG5cdFx0XHRcdGlmICghbGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTb3J0IGJ5IGFuZ2xlXG5cdFx0XHRcdHNlcmllcy5zb3J0QnlBbmdsZShwb2ludHMsIGkgLSAwLjUpO1xuXG5cdFx0XHRcdC8vIEFzc3VtZSBlcXVhbCBsYWJlbCBoZWlnaHRzIG9uIGVpdGhlciBoZW1pc3BoZXJlICgjMjYzMClcblx0XHRcdFx0aiA9IGxhYmVsSGVpZ2h0ID0gMDtcblx0XHRcdFx0d2hpbGUgKCFsYWJlbEhlaWdodCAmJiBwb2ludHNbal0pIHsgLy8gIzE1Njlcblx0XHRcdFx0XHRsYWJlbEhlaWdodCA9IHBvaW50c1tqXSAmJiBwb2ludHNbal0uZGF0YUxhYmVsICYmIChwb2ludHNbal0uZGF0YUxhYmVsLmdldEJCb3goKS5oZWlnaHQgfHwgMjEpOyAvLyAyMSBpcyBmb3IgIzk2OFxuXHRcdFx0XHRcdGorKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE9ubHkgZG8gYW50aS1jb2xsaXNpb24gd2hlbiB3ZSBhcmUgb3V0c2lkZSB0aGUgcGllIGFuZCBoYXZlIGNvbm5lY3RvcnMgKCM4NTYpXG5cdFx0XHRcdGlmIChkaXN0YW5jZU9wdGlvbiA+IDApIHtcblxuXHRcdFx0XHRcdC8vIEJ1aWxkIHRoZSBzbG90c1xuXHRcdFx0XHRcdGJvdHRvbSA9IG1hdGhNaW4oY2VudGVyWSArIHJhZGl1cyArIGRpc3RhbmNlT3B0aW9uLCBjaGFydC5wbG90SGVpZ2h0KTtcblx0XHRcdFx0XHRmb3IgKHBvcyA9IG1hdGhNYXgoMCwgY2VudGVyWSAtIHJhZGl1cyAtIGRpc3RhbmNlT3B0aW9uKTsgcG9zIDw9IGJvdHRvbTsgcG9zICs9IGxhYmVsSGVpZ2h0KSB7XG5cdFx0XHRcdFx0XHRzbG90cy5wdXNoKHBvcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNsb3RzTGVuZ3RoID0gc2xvdHMubGVuZ3RoO1xuXG5cblx0XHRcdFx0XHQvKiBWaXN1YWxpemUgdGhlIHNsb3RzXG5cdFx0XHRcdFx0aWYgKCFzZXJpZXMuc2xvdEVsZW1lbnRzKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMuc2xvdEVsZW1lbnRzID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpID09PSAxKSB7XG5cdFx0XHRcdFx0XHRzZXJpZXMuc2xvdEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcblx0XHRcdFx0XHRcdFx0ZWxlbS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHNlcmllcy5zbG90RWxlbWVudHMubGVuZ3RoID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRzbG90cy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MsIG5vKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2xvdFggPSBzZXJpZXMuZ2V0WChwb3MsIGkpICsgY2hhcnQucGxvdExlZnQgLSAoaSA/IDEwMCA6IDApLFxuXHRcdFx0XHRcdFx0XHRzbG90WSA9IHBvcyArIGNoYXJ0LnBsb3RUb3A7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICghaXNOYU4oc2xvdFgpKSB7XG5cdFx0XHRcdFx0XHRcdHNlcmllcy5zbG90RWxlbWVudHMucHVzaChjaGFydC5yZW5kZXJlci5yZWN0KHNsb3RYLCBzbG90WSAtIDcsIDEwMCwgbGFiZWxIZWlnaHQsIDEpXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJva2U6ICdzaWx2ZXInLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsbDogJ3JnYmEoMCwwLDI1NSwwLjEpJ1xuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0LmFkZCgpKTtcblx0XHRcdFx0XHRcdFx0c2VyaWVzLnNsb3RFbGVtZW50cy5wdXNoKGNoYXJ0LnJlbmRlcmVyLnRleHQoJ1Nsb3QgJysgbm8sIHNsb3RYLCBzbG90WSArIDQpXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsbDogJ3NpbHZlcidcblx0XHRcdFx0XHRcdFx0XHR9KS5hZGQoKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gKi9cblxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBtb3JlIHZhbHVlcyB0aGFuIGF2YWlsYWJsZSBzbG90cywgcmVtb3ZlIGxvd2VzdCB2YWx1ZXNcblx0XHRcdFx0XHRpZiAobGVuZ3RoID4gc2xvdHNMZW5ndGgpIHtcblx0XHRcdFx0XHRcdC8vIGNyZWF0ZSBhbiBhcnJheSBmb3Igc29ydGluZyBhbmQgcmFua2luZyB0aGUgcG9pbnRzIHdpdGhpbiBlYWNoIHF1YXJ0ZXJcblx0XHRcdFx0XHRcdHJhbmtBcnIgPSBbXS5jb25jYXQocG9pbnRzKTtcblx0XHRcdFx0XHRcdHJhbmtBcnIuc29ydChzb3J0KTtcblx0XHRcdFx0XHRcdGogPSBsZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoai0tKSB7XG5cdFx0XHRcdFx0XHRcdHJhbmtBcnJbal0ucmFuayA9IGo7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRqID0gbGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGotLSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocG9pbnRzW2pdLnJhbmsgPj0gc2xvdHNMZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRwb2ludHMuc3BsaWNlKGosIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRoZSBsYWJlbCBnb2VzIHRvIHRoZSBuZWFyZXN0IG9wZW4gc2xvdCwgYnV0IG5vdCBjbG9zZXIgdG8gdGhlIGVkZ2UgdGhhblxuXHRcdFx0XHRcdC8vIHRoZSBsYWJlbCdzIGluZGV4LlxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXG5cdFx0XHRcdFx0XHRwb2ludCA9IHBvaW50c1tqXTtcblx0XHRcdFx0XHRcdGxhYmVsUG9zID0gcG9pbnQubGFiZWxQb3M7XG5cblx0XHRcdFx0XHRcdHZhciBjbG9zZXN0ID0gOTk5OSxcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdHNsb3RJO1xuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIHRoZSBjbG9zZXN0IHNsb3QgaW5kZXhcblx0XHRcdFx0XHRcdGZvciAoc2xvdEkgPSAwOyBzbG90SSA8IHNsb3RzTGVuZ3RoOyBzbG90SSsrKSB7XG5cdFx0XHRcdFx0XHRcdGRpc3RhbmNlID0gbWF0aEFicyhzbG90c1tzbG90SV0gLSBsYWJlbFBvc1sxXSk7XG5cdFx0XHRcdFx0XHRcdGlmIChkaXN0YW5jZSA8IGNsb3Nlc3QpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gc2xvdEk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhhdCBzbG90IGluZGV4IGlzIGNsb3NlciB0byB0aGUgZWRnZXMgb2YgdGhlIHNsb3RzLCBtb3ZlIGl0XG5cdFx0XHRcdFx0XHQvLyB0byB0aGUgY2xvc2VzdCBhcHByb3ByaWF0ZSBzbG90XG5cdFx0XHRcdFx0XHRpZiAoc2xvdEluZGV4IDwgaiAmJiBzbG90c1tqXSAhPT0gbnVsbCkgeyAvLyBjbHVzdGVyIGF0IHRoZSB0b3Bcblx0XHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gajtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc2xvdHNMZW5ndGggIDwgbGVuZ3RoIC0gaiArIHNsb3RJbmRleCAmJiBzbG90c1tqXSAhPT0gbnVsbCkgeyAvLyBjbHVzdGVyIGF0IHRoZSBib3R0b21cblx0XHRcdFx0XHRcdFx0c2xvdEluZGV4ID0gc2xvdHNMZW5ndGggLSBsZW5ndGggKyBqO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoc2xvdHNbc2xvdEluZGV4XSA9PT0gbnVsbCkgeyAvLyBtYWtlIHN1cmUgaXQgaXMgbm90IHRha2VuXG5cdFx0XHRcdFx0XHRcdFx0c2xvdEluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNsb3QgaXMgdGFrZW4sIGZpbmQgbmV4dCBmcmVlIHNsb3QgYmVsb3cuIEluIHRoZSBuZXh0IHJ1biwgdGhlIG5leHQgc2xpY2Ugd2lsbCBmaW5kIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBzbG90IGFib3ZlIHRoZXNlLCBiZWNhdXNlIGl0IGlzIHRoZSBjbG9zZXN0IG9uZVxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoc2xvdHNbc2xvdEluZGV4XSA9PT0gbnVsbCkgeyAvLyBtYWtlIHN1cmUgaXQgaXMgbm90IHRha2VuXG5cdFx0XHRcdFx0XHRcdFx0c2xvdEluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dXNlZFNsb3RzLnB1c2goeyBpOiBzbG90SW5kZXgsIHk6IHNsb3RzW3Nsb3RJbmRleF0gfSk7XG5cdFx0XHRcdFx0XHRzbG90c1tzbG90SW5kZXhdID0gbnVsbDsgLy8gbWFyayBhcyB0YWtlblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBzb3J0IHRoZW0gaW4gb3JkZXIgdG8gZmlsbCBpbiBmcm9tIHRoZSB0b3Bcblx0XHRcdFx0XHR1c2VkU2xvdHMuc29ydChzb3J0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyB0aGUgdXNlZCBzbG90cyBhcmUgc29ydGVkLCBmaWxsIHRoZW0gdXAgc2VxdWVudGlhbGx5XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuXG5cdFx0XHRcdFx0dmFyIHNsb3QsIG5hdHVyYWxZO1xuXG5cdFx0XHRcdFx0cG9pbnQgPSBwb2ludHNbal07XG5cdFx0XHRcdFx0bGFiZWxQb3MgPSBwb2ludC5sYWJlbFBvcztcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWw7XG5cdFx0XHRcdFx0dmlzaWJpbGl0eSA9IHBvaW50LnZpc2libGUgPT09IGZhbHNlID8gSElEREVOIDogVklTSUJMRTtcblx0XHRcdFx0XHRuYXR1cmFsWSA9IGxhYmVsUG9zWzFdO1xuXG5cdFx0XHRcdFx0aWYgKGRpc3RhbmNlT3B0aW9uID4gMCkge1xuXHRcdFx0XHRcdFx0c2xvdCA9IHVzZWRTbG90cy5wb3AoKTtcblx0XHRcdFx0XHRcdHNsb3RJbmRleCA9IHNsb3QuaTtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIHNsb3QgbmV4dCB0byBjdXJycmVudCBzbG90IGlzIGZyZWUsIHRoZSB5IHZhbHVlIGlzIGFsbG93ZWRcblx0XHRcdFx0XHRcdC8vIHRvIGZhbGwgYmFjayB0byB0aGUgbmF0dXJhbCBwb3NpdGlvblxuXHRcdFx0XHRcdFx0eSA9IHNsb3QueTtcblx0XHRcdFx0XHRcdGlmICgobmF0dXJhbFkgPiB5ICYmIHNsb3RzW3Nsb3RJbmRleCArIDFdICE9PSBudWxsKSB8fFxuXHRcdFx0XHRcdFx0XHRcdChuYXR1cmFsWSA8IHkgJiYgIHNsb3RzW3Nsb3RJbmRleCAtIDFdICE9PSBudWxsKSkge1xuXHRcdFx0XHRcdFx0XHR5ID0gbWF0aE1pbihtYXRoTWF4KDAsIG5hdHVyYWxZKSwgY2hhcnQucGxvdEhlaWdodCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eSA9IG5hdHVyYWxZO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGdldCB0aGUgeCAtIHVzZSB0aGUgbmF0dXJhbCB4IHBvc2l0aW9uIGZvciBmaXJzdCBhbmQgbGFzdCBzbG90LCB0byBwcmV2ZW50IHRoZSB0b3Bcblx0XHRcdFx0XHQvLyBhbmQgYm90dG9uIHNsaWNlIGNvbm5lY3RvcnMgZnJvbSB0b3VjaGluZyBlYWNoIG90aGVyIG9uIGVpdGhlciBzaWRlXG5cdFx0XHRcdFx0eCA9IG9wdGlvbnMuanVzdGlmeSA/XG5cdFx0XHRcdFx0XHRzZXJpZXNDZW50ZXJbMF0gKyAoaSA/IC0xIDogMSkgKiAocmFkaXVzICsgZGlzdGFuY2VPcHRpb24pIDpcblx0XHRcdFx0XHRcdHNlcmllcy5nZXRYKHkgPT09IGNlbnRlclkgLSByYWRpdXMgLSBkaXN0YW5jZU9wdGlvbiB8fCB5ID09PSBjZW50ZXJZICsgcmFkaXVzICsgZGlzdGFuY2VPcHRpb24gPyBuYXR1cmFsWSA6IHksIGkpO1xuXG5cblx0XHRcdFx0XHQvLyBSZWNvcmQgdGhlIHBsYWNlbWVudCBhbmQgdmlzaWJpbGl0eVxuXHRcdFx0XHRcdGRhdGFMYWJlbC5fYXR0ciA9IHtcblx0XHRcdFx0XHRcdHZpc2liaWxpdHk6IHZpc2liaWxpdHksXG5cdFx0XHRcdFx0XHRhbGlnbjogbGFiZWxQb3NbNl1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGRhdGFMYWJlbC5fcG9zID0ge1xuXHRcdFx0XHRcdFx0eDogeCArIG9wdGlvbnMueCArXG5cdFx0XHRcdFx0XHRcdCh7IGxlZnQ6IGNvbm5lY3RvclBhZGRpbmcsIHJpZ2h0OiAtY29ubmVjdG9yUGFkZGluZyB9W2xhYmVsUG9zWzZdXSB8fCAwKSxcblx0XHRcdFx0XHRcdHk6IHkgKyBvcHRpb25zLnkgLSAxMCAvLyAxMCBpcyBmb3IgdGhlIGJhc2VsaW5lIChsYWJlbCB2cyB0ZXh0KVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZGF0YUxhYmVsLmNvbm5YID0geDtcblx0XHRcdFx0XHRkYXRhTGFiZWwuY29ublkgPSB5O1xuXG5cblx0XHRcdFx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3dpbmcgZGF0YSBsYWJlbHNcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnNpemUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGRhdGFMYWJlbFdpZHRoID0gZGF0YUxhYmVsLndpZHRoO1xuXHRcdFx0XHRcdFx0Ly8gT3ZlcmZsb3cgbGVmdFxuXHRcdFx0XHRcdFx0aWYgKHggLSBkYXRhTGFiZWxXaWR0aCA8IGNvbm5lY3RvclBhZGRpbmcpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmZsb3dbM10gPSBtYXRoTWF4KG1hdGhSb3VuZChkYXRhTGFiZWxXaWR0aCAtIHggKyBjb25uZWN0b3JQYWRkaW5nKSwgb3ZlcmZsb3dbM10pO1xuXG5cdFx0XHRcdFx0XHQvLyBPdmVyZmxvdyByaWdodFxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh4ICsgZGF0YUxhYmVsV2lkdGggPiBwbG90V2lkdGggLSBjb25uZWN0b3JQYWRkaW5nKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJmbG93WzFdID0gbWF0aE1heChtYXRoUm91bmQoeCArIGRhdGFMYWJlbFdpZHRoIC0gcGxvdFdpZHRoICsgY29ubmVjdG9yUGFkZGluZyksIG92ZXJmbG93WzFdKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gT3ZlcmZsb3cgdG9wXG5cdFx0XHRcdFx0XHRpZiAoeSAtIGxhYmVsSGVpZ2h0IC8gMiA8IDApIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmZsb3dbMF0gPSBtYXRoTWF4KG1hdGhSb3VuZCgteSArIGxhYmVsSGVpZ2h0IC8gMiksIG92ZXJmbG93WzBdKTtcblxuXHRcdFx0XHRcdFx0Ly8gT3ZlcmZsb3cgbGVmdFxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh5ICsgbGFiZWxIZWlnaHQgLyAyID4gcGxvdEhlaWdodCkge1xuXHRcdFx0XHRcdFx0XHRvdmVyZmxvd1syXSA9IG1hdGhNYXgobWF0aFJvdW5kKHkgKyBsYWJlbEhlaWdodCAvIDIgLSBwbG90SGVpZ2h0KSwgb3ZlcmZsb3dbMl0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyBmb3IgZWFjaCBwb2ludFxuXHRcdFx0fSAvLyBmb3IgZWFjaCBoYWxmXG5cblx0XHRcdC8vIERvIG5vdCBhcHBseSB0aGUgZmluYWwgcGxhY2VtZW50IGFuZCBkcmF3IHRoZSBjb25uZWN0b3JzIHVudGlsIHdlIGhhdmUgdmVyaWZpZWRcblx0XHRcdC8vIHRoYXQgbGFiZWxzIGFyZSBub3Qgc3BpbGxpbmcgb3Zlci5cblx0XHRcdGlmIChhcnJheU1heChvdmVyZmxvdykgPT09IDAgfHwgdGhpcy52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdyhvdmVyZmxvdykpIHtcblxuXHRcdFx0XHQvLyBQbGFjZSB0aGUgbGFiZWxzIGluIHRoZSBmaW5hbCBwb3NpdGlvblxuXHRcdFx0XHR0aGlzLnBsYWNlRGF0YUxhYmVscygpO1xuXG5cdFx0XHRcdC8vIERyYXcgdGhlIGNvbm5lY3RvcnNcblx0XHRcdFx0aWYgKG91dHNpZGUgJiYgY29ubmVjdG9yV2lkdGgpIHtcblx0XHRcdFx0XHRlYWNoKHRoaXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRcdGNvbm5lY3RvciA9IHBvaW50LmNvbm5lY3Rvcjtcblx0XHRcdFx0XHRcdGxhYmVsUG9zID0gcG9pbnQubGFiZWxQb3M7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWw7XG5cblx0XHRcdFx0XHRcdGlmIChkYXRhTGFiZWwgJiYgZGF0YUxhYmVsLl9wb3MpIHtcblx0XHRcdFx0XHRcdFx0dmlzaWJpbGl0eSA9IGRhdGFMYWJlbC5fYXR0ci52aXNpYmlsaXR5O1xuXHRcdFx0XHRcdFx0XHR4ID0gZGF0YUxhYmVsLmNvbm5YO1xuXHRcdFx0XHRcdFx0XHR5ID0gZGF0YUxhYmVsLmNvbm5ZO1xuXHRcdFx0XHRcdFx0XHRjb25uZWN0b3JQYXRoID0gc29mdENvbm5lY3RvciA/IFtcblx0XHRcdFx0XHRcdFx0XHRNLFxuXHRcdFx0XHRcdFx0XHRcdHggKyAobGFiZWxQb3NbNl0gPT09ICdsZWZ0JyA/IDUgOiAtNSksIHksIC8vIGVuZCBvZiB0aGUgc3RyaW5nIGF0IHRoZSBsYWJlbFxuXHRcdFx0XHRcdFx0XHRcdCdDJyxcblx0XHRcdFx0XHRcdFx0XHR4LCB5LCAvLyBmaXJzdCBicmVhaywgbmV4dCB0byB0aGUgbGFiZWxcblx0XHRcdFx0XHRcdFx0XHQyICogbGFiZWxQb3NbMl0gLSBsYWJlbFBvc1s0XSwgMiAqIGxhYmVsUG9zWzNdIC0gbGFiZWxQb3NbNV0sXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWxQb3NbMl0sIGxhYmVsUG9zWzNdLCAvLyBzZWNvbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRMLFxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsUG9zWzRdLCBsYWJlbFBvc1s1XSAvLyBiYXNlXG5cdFx0XHRcdFx0XHRcdF0gOiBbXG5cdFx0XHRcdFx0XHRcdFx0TSxcblx0XHRcdFx0XHRcdFx0XHR4ICsgKGxhYmVsUG9zWzZdID09PSAnbGVmdCcgPyA1IDogLTUpLCB5LCAvLyBlbmQgb2YgdGhlIHN0cmluZyBhdCB0aGUgbGFiZWxcblx0XHRcdFx0XHRcdFx0XHRMLFxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsUG9zWzJdLCBsYWJlbFBvc1szXSwgLy8gc2Vjb25kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0TCxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFBvc1s0XSwgbGFiZWxQb3NbNV0gLy8gYmFzZVxuXHRcdFx0XHRcdFx0XHRdO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChjb25uZWN0b3IpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25uZWN0b3IuYW5pbWF0ZSh7IGQ6IGNvbm5lY3RvclBhdGggfSk7XG5cdFx0XHRcdFx0XHRcdFx0Y29ubmVjdG9yLmF0dHIoJ3Zpc2liaWxpdHknLCB2aXNpYmlsaXR5KTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmNvbm5lY3RvciA9IGNvbm5lY3RvciA9IHNlcmllcy5jaGFydC5yZW5kZXJlci5wYXRoKGNvbm5lY3RvclBhdGgpLmF0dHIoe1xuXHRcdFx0XHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGNvbm5lY3RvcldpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdFx0c3Ryb2tlOiBvcHRpb25zLmNvbm5lY3RvckNvbG9yIHx8IHBvaW50LmNvbG9yIHx8ICcjNjA2MDYwJyxcblx0XHRcdFx0XHRcdFx0XHRcdHZpc2liaWxpdHk6IHZpc2liaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vekluZGV4OiAwIC8vICMyNzIyIChyZXZlcnNlZClcblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdC5hZGQoc2VyaWVzLmRhdGFMYWJlbHNHcm91cCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoY29ubmVjdG9yKSB7XG5cdFx0XHRcdFx0XHRcdHBvaW50LmNvbm5lY3RvciA9IGNvbm5lY3Rvci5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdC8qKlxuXHRcdCAqIFBlcmZvcm0gdGhlIGZpbmFsIHBsYWNlbWVudCBvZiB0aGUgZGF0YSBsYWJlbHMgYWZ0ZXIgd2UgaGF2ZSB2ZXJpZmllZCB0aGF0IHRoZXlcblx0XHQgKiBmYWxsIHdpdGhpbiB0aGUgcGxvdCBhcmVhLlxuXHRcdCAqL1xuXHRcdHNlcmllc1R5cGVzLnBpZS5wcm90b3R5cGUucGxhY2VEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ZWFjaCh0aGlzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdHZhciBkYXRhTGFiZWwgPSBwb2ludC5kYXRhTGFiZWwsXG5cdFx0XHRcdFx0X3BvcztcblxuXHRcdFx0XHRpZiAoZGF0YUxhYmVsKSB7XG5cdFx0XHRcdFx0X3BvcyA9IGRhdGFMYWJlbC5fcG9zO1xuXHRcdFx0XHRcdGlmIChfcG9zKSB7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwuYXR0cihkYXRhTGFiZWwuX2F0dHIpO1xuXHRcdFx0XHRcdFx0ZGF0YUxhYmVsW2RhdGFMYWJlbC5tb3ZlZCA/ICdhbmltYXRlJyA6ICdhdHRyJ10oX3Bvcyk7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwubW92ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZGF0YUxhYmVsKSB7XG5cdFx0XHRcdFx0XHRkYXRhTGFiZWwuYXR0cih7IHk6IC05OTkgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0c2VyaWVzVHlwZXMucGllLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9ICBub29wO1xuXG5cdFx0LyoqXG5cdFx0ICogVmVyaWZ5IHdoZXRoZXIgdGhlIGRhdGEgbGFiZWxzIGFyZSBhbGxvd2VkIHRvIGRyYXcsIG9yIHdlIHNob3VsZCBydW4gbW9yZSB0cmFuc2xhdGlvbiBhbmQgZGF0YVxuXHRcdCAqIGxhYmVsIHBvc2l0aW9uaW5nIHRvIGtlZXAgdGhlbSBpbnNpZGUgdGhlIHBsb3QgYXJlYS4gUmV0dXJucyB0cnVlIHdoZW4gZGF0YSBsYWJlbHMgYXJlIHJlYWR5XG5cdFx0ICogdG8gZHJhdy5cblx0XHQgKi9cblx0XHRzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLnZlcmlmeURhdGFMYWJlbE92ZXJmbG93ID0gZnVuY3Rpb24gKG92ZXJmbG93KSB7XG5cblx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcixcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0Y2VudGVyT3B0aW9uID0gb3B0aW9ucy5jZW50ZXIsXG5cdFx0XHRcdG1pblNpemUgPSBvcHRpb25zLm1pblNpemUgfHwgODAsXG5cdFx0XHRcdG5ld1NpemUgPSBtaW5TaXplLFxuXHRcdFx0XHRyZXQ7XG5cblx0XHRcdC8vIEhhbmRsZSBob3Jpem9udGFsIHNpemUgYW5kIGNlbnRlclxuXHRcdFx0aWYgKGNlbnRlck9wdGlvblswXSAhPT0gbnVsbCkgeyAvLyBGaXhlZCBjZW50ZXJcblx0XHRcdFx0bmV3U2l6ZSA9IG1hdGhNYXgoY2VudGVyWzJdIC0gbWF0aE1heChvdmVyZmxvd1sxXSwgb3ZlcmZsb3dbM10pLCBtaW5TaXplKTtcblxuXHRcdFx0fSBlbHNlIHsgLy8gQXV0byBjZW50ZXJcblx0XHRcdFx0bmV3U2l6ZSA9IG1hdGhNYXgoXG5cdFx0XHRcdFx0Y2VudGVyWzJdIC0gb3ZlcmZsb3dbMV0gLSBvdmVyZmxvd1szXSwgLy8gaG9yaXpvbnRhbCBvdmVyZmxvd1xuXHRcdFx0XHRcdG1pblNpemVcblx0XHRcdFx0KTtcblx0XHRcdFx0Y2VudGVyWzBdICs9IChvdmVyZmxvd1szXSAtIG92ZXJmbG93WzFdKSAvIDI7IC8vIGhvcml6b250YWwgY2VudGVyXG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSB2ZXJ0aWNhbCBzaXplIGFuZCBjZW50ZXJcblx0XHRcdGlmIChjZW50ZXJPcHRpb25bMV0gIT09IG51bGwpIHsgLy8gRml4ZWQgY2VudGVyXG5cdFx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KG1hdGhNaW4obmV3U2l6ZSwgY2VudGVyWzJdIC0gbWF0aE1heChvdmVyZmxvd1swXSwgb3ZlcmZsb3dbMl0pKSwgbWluU2l6ZSk7XG5cblx0XHRcdH0gZWxzZSB7IC8vIEF1dG8gY2VudGVyXG5cdFx0XHRcdG5ld1NpemUgPSBtYXRoTWF4KFxuXHRcdFx0XHRcdG1hdGhNaW4oXG5cdFx0XHRcdFx0XHRuZXdTaXplLFxuXHRcdFx0XHRcdFx0Y2VudGVyWzJdIC0gb3ZlcmZsb3dbMF0gLSBvdmVyZmxvd1syXSAvLyB2ZXJ0aWNhbCBvdmVyZmxvd1xuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0bWluU2l6ZVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjZW50ZXJbMV0gKz0gKG92ZXJmbG93WzBdIC0gb3ZlcmZsb3dbMl0pIC8gMjsgLy8gdmVydGljYWwgY2VudGVyXG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBzaXplIG11c3QgYmUgZGVjcmVhc2VkLCB3ZSBuZWVkIHRvIHJ1biB0cmFuc2xhdGUgYW5kIGRyYXdEYXRhTGFiZWxzIGFnYWluXG5cdFx0XHRpZiAobmV3U2l6ZSA8IGNlbnRlclsyXSkge1xuXHRcdFx0XHRjZW50ZXJbMl0gPSBuZXdTaXplO1xuXHRcdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdFx0XHRlYWNoKHRoaXMucG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcblx0XHRcdFx0XHRpZiAocG9pbnQuZGF0YUxhYmVsKSB7XG5cdFx0XHRcdFx0XHRwb2ludC5kYXRhTGFiZWwuX3BvcyA9IG51bGw7IC8vIHJlc2V0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAodGhpcy5kcmF3RGF0YUxhYmVscykge1xuXHRcdFx0XHRcdHRoaXMuZHJhd0RhdGFMYWJlbHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0Ly8gRWxzZSwgcmV0dXJuIHRydWUgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcGllIGFuZCBpdHMgbGFiZWxzIGlzIHdpdGhpbiB0aGUgcGxvdCBhcmVhXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9O1xuXHR9XG5cblx0aWYgKHNlcmllc1R5cGVzLmNvbHVtbikge1xuXG5cdFx0LyoqXG5cdFx0ICogT3ZlcnJpZGUgdGhlIGJhc2ljIGRhdGEgbGFiZWwgYWxpZ25tZW50IGJ5IGFkanVzdGluZyBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb2x1bW5cblx0XHQgKi9cblx0XHRzZXJpZXNUeXBlcy5jb2x1bW4ucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsID0gZnVuY3Rpb24gKHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsICBhbGlnblRvLCBpc05ldykge1xuXHRcdFx0dmFyIGludmVydGVkID0gdGhpcy5jaGFydC5pbnZlcnRlZCxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRkbEJveCA9IHBvaW50LmRsQm94IHx8IHBvaW50LnNoYXBlQXJncywgLy8gZGF0YSBsYWJlbCBib3ggZm9yIGFsaWdubWVudFxuXHRcdFx0XHRiZWxvdyA9IHBvaW50LmJlbG93IHx8IChwb2ludC5wbG90WSA+IHBpY2sodGhpcy50cmFuc2xhdGVkVGhyZXNob2xkLCBzZXJpZXMueUF4aXMubGVuKSksXG5cdFx0XHRcdGluc2lkZSA9IHBpY2sob3B0aW9ucy5pbnNpZGUsICEhdGhpcy5vcHRpb25zLnN0YWNraW5nKTsgLy8gZHJhdyBpdCBpbnNpZGUgdGhlIGJveD9cblxuXHRcdFx0Ly8gQWxpZ24gdG8gdGhlIGNvbHVtbiBpdHNlbGYsIG9yIHRoZSB0b3Agb2YgaXRcblx0XHRcdGlmIChkbEJveCkgeyAvLyBBcmVhIHJhbmdlIHVzZXMgdGhpcyBtZXRob2QgYnV0IG5vdCBhbGlnblRvXG5cdFx0XHRcdGFsaWduVG8gPSBtZXJnZShkbEJveCk7XG5cblx0XHRcdFx0aWYgKGludmVydGVkKSB7XG5cdFx0XHRcdFx0YWxpZ25UbyA9IHtcblx0XHRcdFx0XHRcdHg6IHNlcmllcy55QXhpcy5sZW4gLSBhbGlnblRvLnkgLSBhbGlnblRvLmhlaWdodCxcblx0XHRcdFx0XHRcdHk6IHNlcmllcy54QXhpcy5sZW4gLSBhbGlnblRvLnggLSBhbGlnblRvLndpZHRoLFxuXHRcdFx0XHRcdFx0d2lkdGg6IGFsaWduVG8uaGVpZ2h0LFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBhbGlnblRvLndpZHRoXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbXB1dGUgdGhlIGFsaWdubWVudCBib3hcblx0XHRcdFx0aWYgKCFpbnNpZGUpIHtcblx0XHRcdFx0XHRpZiAoaW52ZXJ0ZWQpIHtcblx0XHRcdFx0XHRcdGFsaWduVG8ueCArPSBiZWxvdyA/IDAgOiBhbGlnblRvLndpZHRoO1xuXHRcdFx0XHRcdFx0YWxpZ25Uby53aWR0aCA9IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFsaWduVG8ueSArPSBiZWxvdyA/IGFsaWduVG8uaGVpZ2h0IDogMDtcblx0XHRcdFx0XHRcdGFsaWduVG8uaGVpZ2h0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBXaGVuIGFsaWdubWVudCBpcyB1bmRlZmluZWQgKHR5cGljYWxseSBjb2x1bW5zIGFuZCBiYXJzKSwgZGlzcGxheSB0aGUgaW5kaXZpZHVhbFxuXHRcdFx0Ly8gcG9pbnQgYmVsb3cgb3IgYWJvdmUgdGhlIHBvaW50IGRlcGVuZGluZyBvbiB0aGUgdGhyZXNob2xkXG5cdFx0XHRvcHRpb25zLmFsaWduID0gcGljayhcblx0XHRcdFx0b3B0aW9ucy5hbGlnbixcblx0XHRcdFx0IWludmVydGVkIHx8IGluc2lkZSA/ICdjZW50ZXInIDogYmVsb3cgPyAncmlnaHQnIDogJ2xlZnQnXG5cdFx0XHQpO1xuXHRcdFx0b3B0aW9ucy52ZXJ0aWNhbEFsaWduID0gcGljayhcblx0XHRcdFx0b3B0aW9ucy52ZXJ0aWNhbEFsaWduLFxuXHRcdFx0XHRpbnZlcnRlZCB8fCBpbnNpZGUgPyAnbWlkZGxlJyA6IGJlbG93ID8gJ3RvcCcgOiAnYm90dG9tJ1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gQ2FsbCB0aGUgcGFyZW50IG1ldGhvZFxuXHRcdFx0U2VyaWVzLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsIHBvaW50LCBkYXRhTGFiZWwsIG9wdGlvbnMsIGFsaWduVG8sIGlzTmV3KTtcblx0XHR9O1xuXHR9XG5cblxuXG5cdC8qKlxuXHQgKiBIaWdoY2hhcnRzIEpTIHY0LjEuNC1tb2RpZmllZCAoKVxuXHQgKiBIaWdoY2hhcnRzIG1vZHVsZSB0byBoaWRlIG92ZXJsYXBwaW5nIGRhdGEgbGFiZWxzLiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBieSBkZWZhdWx0IGluIEhpZ2htYXBzLlxuXHQgKlxuXHQgKiAoYykgMjAxMC0yMDE0IFRvcnN0ZWluIEhvbnNpXG5cdCAqXG5cdCAqIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG5cdCAqL1xuXG5cdC8qZ2xvYmFsIEhpZ2hjaGFydHMsIEhpZ2hjaGFydHNBZGFwdGVyICovXG5cdChmdW5jdGlvbiAoSCkge1xuXHRcdHZhciBDaGFydCA9IEguQ2hhcnQsXG5cdFx0XHRlYWNoID0gSC5lYWNoLFxuXHRcdFx0YWRkRXZlbnQgPSBIaWdoY2hhcnRzQWRhcHRlci5hZGRFdmVudDtcblxuXHRcdC8vIENvbGxlY3QgcG90ZW5zaWFsIG92ZXJsYXBwaW5nIGRhdGEgbGFiZWxzLiBTdGFjayBsYWJlbHMgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byBiZSBcblx0XHQvLyBjb25zaWRlcmVkIGJlY2F1c2UgdGhleSBhcmUgdXN1YWxseSBhY2NvbXBhbmllZCBieSBkYXRhIGxhYmVscyB0aGF0IGxpZSBpbnNpZGUgdGhlIGNvbHVtbnMuXG5cdFx0Q2hhcnQucHJvdG90eXBlLmNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChjaGFydCkge1xuXHRcdFx0ZnVuY3Rpb24gY29sbGVjdEFuZEhpZGUoKSB7XG5cdFx0XHRcdHZhciBsYWJlbHMgPSBbXTtcblxuXHRcdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKHNlcmllcykge1xuXHRcdFx0XHRcdHZhciBkbE9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucy5kYXRhTGFiZWxzO1xuXHRcdFx0XHRcdGlmICgoZGxPcHRpb25zLmVuYWJsZWQgfHwgc2VyaWVzLl9oYXNQb2ludExhYmVscykgJiYgIWRsT3B0aW9ucy5hbGxvd092ZXJsYXAgJiYgc2VyaWVzLnZpc2libGUpIHsgLy8gIzM4NjZcblx0XHRcdFx0XHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7IFxuXHRcdFx0XHRcdFx0XHRpZiAocG9pbnQuZGF0YUxhYmVsKSB7XG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuZGF0YUxhYmVsLmxhYmVscmFuayA9IHBvaW50LmxhYmVscmFuaztcblx0XHRcdFx0XHRcdFx0XHRsYWJlbHMucHVzaChwb2ludC5kYXRhTGFiZWwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjaGFydC5oaWRlT3ZlcmxhcHBpbmdMYWJlbHMobGFiZWxzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRG8gaXQgbm93IC4uLlxuXHRcdFx0Y29sbGVjdEFuZEhpZGUoKTtcblxuXHRcdFx0Ly8gLi4uIGFuZCBhZnRlciBlYWNoIGNoYXJ0IHJlZHJhd1xuXHRcdFx0YWRkRXZlbnQoY2hhcnQsICdyZWRyYXcnLCBjb2xsZWN0QW5kSGlkZSk7XG5cblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIEhpZGUgb3ZlcmxhcHBpbmcgbGFiZWxzLiBMYWJlbHMgYXJlIG1vdmVkIGFuZCBmYWRlZCBpbiBhbmQgb3V0IG9uIHpvb20gdG8gcHJvdmlkZSBhIHNtb290aCBcblx0XHQgKiB2aXN1YWwgaW1yZXNzaW9uLlxuXHRcdCAqL1x0XHRcblx0XHRDaGFydC5wcm90b3R5cGUuaGlkZU92ZXJsYXBwaW5nTGFiZWxzID0gZnVuY3Rpb24gKGxhYmVscykge1xuXG5cdFx0XHR2YXIgbGVuID0gbGFiZWxzLmxlbmd0aCxcblx0XHRcdFx0bGFiZWwsXG5cdFx0XHRcdGksXG5cdFx0XHRcdGosXG5cdFx0XHRcdGxhYmVsMSxcblx0XHRcdFx0bGFiZWwyLFxuXHRcdFx0XHRpbnRlcnNlY3RSZWN0ID0gZnVuY3Rpb24gKHBvczEsIHBvczIsIHNpemUxLCBzaXplMikge1xuXHRcdFx0XHRcdHJldHVybiAhKFxuXHRcdFx0XHRcdFx0cG9zMi54ID4gcG9zMS54ICsgc2l6ZTEud2lkdGggfHxcblx0XHRcdFx0XHRcdHBvczIueCArIHNpemUyLndpZHRoIDwgcG9zMS54IHx8XG5cdFx0XHRcdFx0XHRwb3MyLnkgPiBwb3MxLnkgKyBzaXplMS5oZWlnaHQgfHxcblx0XHRcdFx0XHRcdHBvczIueSArIHNpemUyLmhlaWdodCA8IHBvczEueVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH07XG5cdFx0XG5cdFx0XHQvLyBNYXJrIHdpdGggaW5pdGlhbCBvcGFjaXR5XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0bGFiZWwgPSBsYWJlbHNbaV07XG5cdFx0XHRcdGlmIChsYWJlbCkge1xuXHRcdFx0XHRcdGxhYmVsLm9sZE9wYWNpdHkgPSBsYWJlbC5vcGFjaXR5O1xuXHRcdFx0XHRcdGxhYmVsLm5ld09wYWNpdHkgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVjdCBvdmVybGFwcGluZyBsYWJlbHNcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRsYWJlbDEgPSBsYWJlbHNbaV07XG5cblx0XHRcdFx0Zm9yIChqID0gaSArIDE7IGogPCBsZW47ICsraikge1xuXHRcdFx0XHRcdGxhYmVsMiA9IGxhYmVsc1tqXTtcblx0XHRcdFx0XHRpZiAobGFiZWwxICYmIGxhYmVsMiAmJiBsYWJlbDEucGxhY2VkICYmIGxhYmVsMi5wbGFjZWQgJiYgbGFiZWwxLm5ld09wYWNpdHkgIT09IDAgJiYgbGFiZWwyLm5ld09wYWNpdHkgIT09IDAgJiYgXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdFJlY3QobGFiZWwxLmFsaWduQXR0ciwgbGFiZWwyLmFsaWduQXR0ciwgbGFiZWwxLCBsYWJlbDIpKSB7XG5cdFx0XHRcdFx0XHQobGFiZWwxLmxhYmVscmFuayA8IGxhYmVsMi5sYWJlbHJhbmsgPyBsYWJlbDEgOiBsYWJlbDIpLm5ld09wYWNpdHkgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBIaWRlIG9yIHNob3dcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRsYWJlbCA9IGxhYmVsc1tpXTtcblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0aWYgKGxhYmVsLm9sZE9wYWNpdHkgIT09IGxhYmVsLm5ld09wYWNpdHkgJiYgbGFiZWwucGxhY2VkKSB7XG5cdFx0XHRcdFx0XHRsYWJlbC5hbGlnbkF0dHIub3BhY2l0eSA9IGxhYmVsLm5ld09wYWNpdHk7XG5cdFx0XHRcdFx0XHRsYWJlbFtsYWJlbC5pc09sZCAmJiBsYWJlbC5uZXdPcGFjaXR5ID8gJ2FuaW1hdGUnIDogJ2F0dHInXShsYWJlbC5hbGlnbkF0dHIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsYWJlbC5pc09sZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdH0oSGlnaGNoYXJ0cykpOy8qKlxuXHQgKiBUcmFja2VyTWl4aW4gZm9yIHBvaW50cyBhbmQgZ3JhcGhzXG5cdCAqL1xuXG5cdHZhciBUcmFja2VyTWl4aW4gPSBIaWdoY2hhcnRzLlRyYWNrZXJNaXhpbiA9IHtcblxuXHRcdGRyYXdUcmFja2VyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydCxcblx0XHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRcdGN1cnNvciA9IHNlcmllcy5vcHRpb25zLmN1cnNvcixcblx0XHRcdFx0Y3NzID0gY3Vyc29yICYmIHsgY3Vyc29yOiBjdXJzb3IgfSxcblx0XHRcdFx0b25Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldCxcblx0XHRcdFx0XHRwb2ludDtcblxuXHRcdFx0XHRcdHdoaWxlICh0YXJnZXQgJiYgIXBvaW50KSB7XG5cdFx0XHRcdFx0XHRwb2ludCA9IHRhcmdldC5wb2ludDtcblx0XHRcdFx0XHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChwb2ludCAhPT0gVU5ERUZJTkVEICYmIHBvaW50ICE9PSBjaGFydC5ob3ZlclBvaW50KSB7IC8vIHVuZGVmaW5lZCBvbiBncmFwaCBpbiBzY2F0dGVyY2hhcnRcblx0XHRcdFx0XHRcdHBvaW50Lm9uTW91c2VPdmVyKGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gQWRkIHJlZmVyZW5jZSB0byB0aGUgcG9pbnRcblx0XHRcdGVhY2goc2VyaWVzLnBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHRcdGlmIChwb2ludC5ncmFwaGljKSB7XG5cdFx0XHRcdFx0cG9pbnQuZ3JhcGhpYy5lbGVtZW50LnBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBvaW50LmRhdGFMYWJlbCkge1xuXHRcdFx0XHRcdHBvaW50LmRhdGFMYWJlbC5lbGVtZW50LnBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVycywgd2UgbmVlZCB0byBkbyB0aGlzIG9ubHkgb25jZVxuXHRcdFx0aWYgKCFzZXJpZXMuX2hhc1RyYWNraW5nKSB7XG5cdFx0XHRcdGVhY2goc2VyaWVzLnRyYWNrZXJHcm91cHMsIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRpZiAoc2VyaWVzW2tleV0pIHsgLy8gd2UgZG9uJ3QgYWx3YXlzIGhhdmUgZGF0YUxhYmVsc0dyb3VwXG5cdFx0XHRcdFx0XHRzZXJpZXNba2V5XVxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoUFJFRklYICsgJ3RyYWNrZXInKVxuXHRcdFx0XHRcdFx0XHQub24oJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKVxuXHRcdFx0XHRcdFx0XHQub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHsgcG9pbnRlci5vblRyYWNrZXJNb3VzZU91dChlKTsgfSlcblx0XHRcdFx0XHRcdFx0LmNzcyhjc3MpO1xuXHRcdFx0XHRcdFx0aWYgKGhhc1RvdWNoKSB7XG5cdFx0XHRcdFx0XHRcdHNlcmllc1trZXldLm9uKCd0b3VjaHN0YXJ0Jywgb25Nb3VzZU92ZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNlcmllcy5faGFzVHJhY2tpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEcmF3IHRoZSB0cmFja2VyIG9iamVjdCB0aGF0IHNpdHMgYWJvdmUgYWxsIGRhdGEgbGFiZWxzIGFuZCBtYXJrZXJzIHRvXG5cdFx0ICogdHJhY2sgbW91c2UgZXZlbnRzIG9uIHRoZSBncmFwaCBvciBwb2ludHMuIEZvciB0aGUgbGluZSB0eXBlIGNoYXJ0c1xuXHRcdCAqIHRoZSB0cmFja2VyIHVzZXMgdGhlIHNhbWUgZ3JhcGhQYXRoLCBidXQgd2l0aCBhIGdyZWF0ZXIgc3Ryb2tlIHdpZHRoXG5cdFx0ICogZm9yIGJldHRlciBjb250cm9sLlxuXHRcdCAqL1xuXHRcdGRyYXdUcmFja2VyR3JhcGg6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdHRyYWNrQnlBcmVhID0gb3B0aW9ucy50cmFja0J5QXJlYSxcblx0XHRcdFx0dHJhY2tlclBhdGggPSBbXS5jb25jYXQodHJhY2tCeUFyZWEgPyBzZXJpZXMuYXJlYVBhdGggOiBzZXJpZXMuZ3JhcGhQYXRoKSxcblx0XHRcdFx0dHJhY2tlclBhdGhMZW5ndGggPSB0cmFja2VyUGF0aC5sZW5ndGgsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRwb2ludGVyID0gY2hhcnQucG9pbnRlcixcblx0XHRcdFx0cmVuZGVyZXIgPSBjaGFydC5yZW5kZXJlcixcblx0XHRcdFx0c25hcCA9IGNoYXJ0Lm9wdGlvbnMudG9vbHRpcC5zbmFwLFxuXHRcdFx0XHR0cmFja2VyID0gc2VyaWVzLnRyYWNrZXIsXG5cdFx0XHRcdGN1cnNvciA9IG9wdGlvbnMuY3Vyc29yLFxuXHRcdFx0XHRjc3MgPSBjdXJzb3IgJiYgeyBjdXJzb3I6IGN1cnNvciB9LFxuXHRcdFx0XHRzaW5nbGVQb2ludHMgPSBzZXJpZXMuc2luZ2xlUG9pbnRzLFxuXHRcdFx0XHRzaW5nbGVQb2ludCxcblx0XHRcdFx0aSxcblx0XHRcdFx0b25Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKGNoYXJ0LmhvdmVyU2VyaWVzICE9PSBzZXJpZXMpIHtcblx0XHRcdFx0XHRcdHNlcmllcy5vbk1vdXNlT3ZlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Lypcblx0XHRcdFx0ICogRW1waXJpY2FsIGxvd2VzdCBwb3NzaWJsZSBvcGFjaXRpZXMgZm9yIFRSQUNLRVJfRklMTCBmb3IgYW4gZWxlbWVudCB0byBzdGF5IGludmlzaWJsZSBidXQgY2xpY2thYmxlXG5cdFx0XHRcdCAqIElFNjogMC4wMDJcblx0XHRcdFx0ICogSUU3OiAwLjAwMlxuXHRcdFx0XHQgKiBJRTg6IDAuMDAyXG5cdFx0XHRcdCAqIElFOTogMC4wMDAwMDAwMDAwMSAodW5saW1pdGVkKVxuXHRcdFx0XHQgKiBJRTEwOiAwLjAwMDEgKGV4cG9ydGluZyBvbmx5KVxuXHRcdFx0XHQgKiBGRjogMC4wMDAwMDAwMDAwMSAodW5saW1pdGVkKVxuXHRcdFx0XHQgKiBDaHJvbWU6IDAuMDAwMDAxXG5cdFx0XHRcdCAqIFNhZmFyaTogMC4wMDAwMDFcblx0XHRcdFx0ICogT3BlcmE6IDAuMDAwMDAwMDAwMDEgKHVubGltaXRlZClcblx0XHRcdFx0ICovXG5cdFx0XHRcdFRSQUNLRVJfRklMTCA9ICdyZ2JhKDE5MiwxOTIsMTkyLCcgKyAoaGFzU1ZHID8gMC4wMDAxIDogMC4wMDIpICsgJyknO1xuXG5cdFx0XHQvLyBFeHRlbmQgZW5kIHBvaW50cy4gQSBiZXR0ZXIgd2F5IHdvdWxkIGJlIHRvIHVzZSByb3VuZCBsaW5lY2Fwcyxcblx0XHRcdC8vIGJ1dCB0aG9zZSBhcmUgbm90IGNsaWNrYWJsZSBpbiBWTUwuXG5cdFx0XHRpZiAodHJhY2tlclBhdGhMZW5ndGggJiYgIXRyYWNrQnlBcmVhKSB7XG5cdFx0XHRcdGkgPSB0cmFja2VyUGF0aExlbmd0aCArIDE7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRpZiAodHJhY2tlclBhdGhbaV0gPT09IE0pIHsgLy8gZXh0ZW5kIGxlZnQgc2lkZVxuXHRcdFx0XHRcdFx0dHJhY2tlclBhdGguc3BsaWNlKGkgKyAxLCAwLCB0cmFja2VyUGF0aFtpICsgMV0gLSBzbmFwLCB0cmFja2VyUGF0aFtpICsgMl0sIEwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKGkgJiYgdHJhY2tlclBhdGhbaV0gPT09IE0pIHx8IGkgPT09IHRyYWNrZXJQYXRoTGVuZ3RoKSB7IC8vIGV4dGVuZCByaWdodCBzaWRlXG5cdFx0XHRcdFx0XHR0cmFja2VyUGF0aC5zcGxpY2UoaSwgMCwgTCwgdHJhY2tlclBhdGhbaSAtIDJdICsgc25hcCwgdHJhY2tlclBhdGhbaSAtIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gaGFuZGxlIHNpbmdsZSBwb2ludHNcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzaW5nbGVQb2ludHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c2luZ2xlUG9pbnQgPSBzaW5nbGVQb2ludHNbaV07XG5cdFx0XHRcdHRyYWNrZXJQYXRoLnB1c2goTSwgc2luZ2xlUG9pbnQucGxvdFggLSBzbmFwLCBzaW5nbGVQb2ludC5wbG90WSxcblx0XHRcdFx0TCwgc2luZ2xlUG9pbnQucGxvdFggKyBzbmFwLCBzaW5nbGVQb2ludC5wbG90WSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRyYXcgdGhlIHRyYWNrZXJcblx0XHRcdGlmICh0cmFja2VyKSB7XG5cdFx0XHRcdHRyYWNrZXIuYXR0cih7IGQ6IHRyYWNrZXJQYXRoIH0pO1xuXHRcdFx0fSBlbHNlIHsgLy8gY3JlYXRlXG5cblx0XHRcdFx0c2VyaWVzLnRyYWNrZXIgPSByZW5kZXJlci5wYXRoKHRyYWNrZXJQYXRoKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0J3N0cm9rZS1saW5lam9pbic6ICdyb3VuZCcsIC8vICMxMjI1XG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogc2VyaWVzLnZpc2libGUgPyBWSVNJQkxFIDogSElEREVOLFxuXHRcdFx0XHRcdHN0cm9rZTogVFJBQ0tFUl9GSUxMLFxuXHRcdFx0XHRcdGZpbGw6IHRyYWNrQnlBcmVhID8gVFJBQ0tFUl9GSUxMIDogTk9ORSxcblx0XHRcdFx0XHQnc3Ryb2tlLXdpZHRoJyA6IG9wdGlvbnMubGluZVdpZHRoICsgKHRyYWNrQnlBcmVhID8gMCA6IDIgKiBzbmFwKSxcblx0XHRcdFx0XHR6SW5kZXg6IDJcblx0XHRcdFx0fSlcblx0XHRcdFx0LmFkZChzZXJpZXMuZ3JvdXApO1xuXG5cdFx0XHRcdC8vIFRoZSB0cmFja2VyIGlzIGFkZGVkIHRvIHRoZSBzZXJpZXMgZ3JvdXAsIHdoaWNoIGlzIGNsaXBwZWQsIGJ1dCBpcyBjb3ZlcmVkXG5cdFx0XHRcdC8vIGJ5IHRoZSBtYXJrZXIgZ3JvdXAuIFNvIHRoZSBtYXJrZXIgZ3JvdXAgYWxzbyBuZWVkcyB0byBjYXB0dXJlIGV2ZW50cy5cblx0XHRcdFx0ZWFjaChbc2VyaWVzLnRyYWNrZXIsIHNlcmllcy5tYXJrZXJHcm91cF0sIGZ1bmN0aW9uICh0cmFja2VyKSB7XG5cdFx0XHRcdFx0dHJhY2tlci5hZGRDbGFzcyhQUkVGSVggKyAndHJhY2tlcicpXG5cdFx0XHRcdFx0XHQub24oJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKVxuXHRcdFx0XHRcdFx0Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChlKSB7IHBvaW50ZXIub25UcmFja2VyTW91c2VPdXQoZSk7IH0pXG5cdFx0XHRcdFx0XHQuY3NzKGNzcyk7XG5cblx0XHRcdFx0XHRpZiAoaGFzVG91Y2gpIHtcblx0XHRcdFx0XHRcdHRyYWNrZXIub24oJ3RvdWNoc3RhcnQnLCBvbk1vdXNlT3Zlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdC8qIEVuZCBUcmFja2VyTWl4aW4gKi9cblxuXG5cdC8qKlxuXHQgKiBBZGQgdHJhY2tpbmcgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHNlcmllcyBncm91cCwgc28gdGhlIHBvaW50IGdyYXBoaWNzXG5cdCAqIHRoZW1zZWx2ZXMgYWN0IGFzIHRyYWNrZXJzXG5cdCAqLyBcblxuXHRpZiAoc2VyaWVzVHlwZXMuY29sdW1uKSB7XG5cdFx0Q29sdW1uU2VyaWVzLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlclBvaW50O1x0XG5cdH1cblxuXHRpZiAoc2VyaWVzVHlwZXMucGllKSB7XG5cdFx0c2VyaWVzVHlwZXMucGllLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlclBvaW50O1xuXHR9XG5cblx0aWYgKHNlcmllc1R5cGVzLnNjYXR0ZXIpIHtcblx0XHRTY2F0dGVyU2VyaWVzLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IFRyYWNrZXJNaXhpbi5kcmF3VHJhY2tlclBvaW50O1xuXHR9XG5cblx0LyogXG5cdCAqIEV4dGVuZCBMZWdlbmQgZm9yIGl0ZW0gZXZlbnRzIFxuXHQgKi8gXG5cdGV4dGVuZChMZWdlbmQucHJvdG90eXBlLCB7XG5cblx0XHRzZXRJdGVtRXZlbnRzOiBmdW5jdGlvbiAoaXRlbSwgbGVnZW5kSXRlbSwgdXNlSFRNTCwgaXRlbVN0eWxlLCBpdGVtSGlkZGVuU3R5bGUpIHtcblx0XHR2YXIgbGVnZW5kID0gdGhpcztcblx0XHQvLyBTZXQgdGhlIGV2ZW50cyBvbiB0aGUgaXRlbSBncm91cCwgb3IgaW4gY2FzZSBvZiB1c2VIVE1MLCB0aGUgaXRlbSBpdHNlbGYgKCMxMjQ5KVxuXHRcdCh1c2VIVE1MID8gbGVnZW5kSXRlbSA6IGl0ZW0ubGVnZW5kR3JvdXApLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGl0ZW0uc2V0U3RhdGUoSE9WRVJfU1RBVEUpO1xuXHRcdFx0XHRsZWdlbmRJdGVtLmNzcyhsZWdlbmQub3B0aW9ucy5pdGVtSG92ZXJTdHlsZSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bGVnZW5kSXRlbS5jc3MoaXRlbS52aXNpYmxlID8gaXRlbVN0eWxlIDogaXRlbUhpZGRlblN0eWxlKTtcblx0XHRcdFx0aXRlbS5zZXRTdGF0ZSgpO1xuXHRcdFx0fSlcblx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0dmFyIHN0ckxlZ2VuZEl0ZW1DbGljayA9ICdsZWdlbmRJdGVtQ2xpY2snLFxuXHRcdFx0XHRcdGZuTGVnZW5kSXRlbUNsaWNrID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aXRlbS5zZXRWaXNpYmxlKCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0Ly8gUGFzcyBvdmVyIHRoZSBjbGljay90b3VjaCBldmVudC4gIzQuXG5cdFx0XHRcdGV2ZW50ID0ge1xuXHRcdFx0XHRcdGJyb3dzZXJFdmVudDogZXZlbnRcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBjbGljayB0aGUgbmFtZSBvciBzeW1ib2xcblx0XHRcdFx0aWYgKGl0ZW0uZmlyZVBvaW50RXZlbnQpIHsgLy8gcG9pbnRcblx0XHRcdFx0XHRpdGVtLmZpcmVQb2ludEV2ZW50KHN0ckxlZ2VuZEl0ZW1DbGljaywgZXZlbnQsIGZuTGVnZW5kSXRlbUNsaWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaXJlRXZlbnQoaXRlbSwgc3RyTGVnZW5kSXRlbUNsaWNrLCBldmVudCwgZm5MZWdlbmRJdGVtQ2xpY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlQ2hlY2tib3hGb3JJdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGxlZ2VuZCA9IHRoaXM7XG5cblx0XHRcdGl0ZW0uY2hlY2tib3ggPSBjcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcblx0XHRcdFx0dHlwZTogJ2NoZWNrYm94Jyxcblx0XHRcdFx0Y2hlY2tlZDogaXRlbS5zZWxlY3RlZCxcblx0XHRcdFx0ZGVmYXVsdENoZWNrZWQ6IGl0ZW0uc2VsZWN0ZWQgLy8gcmVxdWlyZWQgYnkgSUU3XG5cdFx0XHR9LCBsZWdlbmQub3B0aW9ucy5pdGVtQ2hlY2tib3hTdHlsZSwgbGVnZW5kLmNoYXJ0LmNvbnRhaW5lcik7XG5cblx0XHRcdGFkZEV2ZW50KGl0ZW0uY2hlY2tib3gsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRmaXJlRXZlbnQoaXRlbS5zZXJpZXMgfHwgaXRlbSwgJ2NoZWNrYm94Q2xpY2snLCB7IC8vICMzNzEyXG5cdFx0XHRcdFx0XHRjaGVja2VkOiB0YXJnZXQuY2hlY2tlZCxcblx0XHRcdFx0XHRcdGl0ZW06IGl0ZW1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGl0ZW0uc2VsZWN0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fVx0XG5cdH0pO1xuXG5cdC8qIFxuXHQgKiBBZGQgcG9pbnRlciBjdXJzb3IgdG8gbGVnZW5kIGl0ZW1zdHlsZSBpbiBkZWZhdWx0T3B0aW9uc1xuXHQgKi9cblx0ZGVmYXVsdE9wdGlvbnMubGVnZW5kLml0ZW1TdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG5cblxuXHQvKiBcblx0ICogRXh0ZW5kIHRoZSBDaGFydCBvYmplY3Qgd2l0aCBpbnRlcmFjdGlvblxuXHQgKi9cblxuXHRleHRlbmQoQ2hhcnQucHJvdG90eXBlLCB7XG5cdFx0LyoqXG5cdFx0ICogRGlzcGxheSB0aGUgem9vbSBidXR0b25cblx0XHQgKi9cblx0XHRzaG93UmVzZXRab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLFxuXHRcdFx0XHRsYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZyxcblx0XHRcdFx0YnRuT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQucmVzZXRab29tQnV0dG9uLFxuXHRcdFx0XHR0aGVtZSA9IGJ0bk9wdGlvbnMudGhlbWUsXG5cdFx0XHRcdHN0YXRlcyA9IHRoZW1lLnN0YXRlcyxcblx0XHRcdFx0YWxpZ25UbyA9IGJ0bk9wdGlvbnMucmVsYXRpdmVUbyA9PT0gJ2NoYXJ0JyA/IG51bGwgOiAncGxvdEJveCc7XG5cdFx0XHRcdFxuXHRcdFx0dGhpcy5yZXNldFpvb21CdXR0b24gPSBjaGFydC5yZW5kZXJlci5idXR0b24obGFuZy5yZXNldFpvb20sIG51bGwsIG51bGwsIGZ1bmN0aW9uICgpIHsgY2hhcnQuem9vbU91dCgpOyB9LCB0aGVtZSwgc3RhdGVzICYmIHN0YXRlcy5ob3Zlcilcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdGFsaWduOiBidG5PcHRpb25zLnBvc2l0aW9uLmFsaWduLFxuXHRcdFx0XHRcdHRpdGxlOiBsYW5nLnJlc2V0Wm9vbVRpdGxlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGQoKVxuXHRcdFx0XHQuYWxpZ24oYnRuT3B0aW9ucy5wb3NpdGlvbiwgZmFsc2UsIGFsaWduVG8pO1xuXHRcdFx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogWm9vbSBvdXQgdG8gMToxXG5cdFx0ICovXG5cdFx0em9vbU91dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcztcblx0XHRcdGZpcmVFdmVudChjaGFydCwgJ3NlbGVjdGlvbicsIHsgcmVzZXRTZWxlY3Rpb246IHRydWUgfSwgZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0Y2hhcnQuem9vbSgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFpvb20gaW50byBhIGdpdmVuIHBvcnRpb24gb2YgdGhlIGNoYXJ0IGdpdmVuIGJ5IGF4aXMgY29vcmRpbmF0ZXNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0XHQgKi9cblx0XHR6b29tOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMsXG5cdFx0XHRcdGhhc1pvb21lZCxcblx0XHRcdFx0cG9pbnRlciA9IGNoYXJ0LnBvaW50ZXIsXG5cdFx0XHRcdGRpc3BsYXlCdXR0b24gPSBmYWxzZSxcblx0XHRcdFx0cmVzZXRab29tQnV0dG9uO1xuXG5cdFx0XHQvLyBJZiB6b29tIGlzIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmVzZXQgdGhlIGF4ZXNcblx0XHRcdGlmICghZXZlbnQgfHwgZXZlbnQucmVzZXRTZWxlY3Rpb24pIHtcblx0XHRcdFx0ZWFjaChjaGFydC5heGVzLCBmdW5jdGlvbiAoYXhpcykge1xuXHRcdFx0XHRcdGhhc1pvb21lZCA9IGF4aXMuem9vbSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7IC8vIGVsc2UsIHpvb20gaW4gb24gYWxsIGF4ZXNcblx0XHRcdFx0ZWFjaChldmVudC54QXhpcy5jb25jYXQoZXZlbnQueUF4aXMpLCBmdW5jdGlvbiAoYXhpc0RhdGEpIHtcblx0XHRcdFx0XHR2YXIgYXhpcyA9IGF4aXNEYXRhLmF4aXMsXG5cdFx0XHRcdFx0XHRpc1hBeGlzID0gYXhpcy5pc1hBeGlzO1xuXG5cdFx0XHRcdFx0Ly8gZG9uJ3Qgem9vbSBtb3JlIHRoYW4gbWluUmFuZ2Vcblx0XHRcdFx0XHRpZiAocG9pbnRlcltpc1hBeGlzID8gJ3pvb21YJyA6ICd6b29tWSddIHx8IHBvaW50ZXJbaXNYQXhpcyA/ICdwaW5jaFgnIDogJ3BpbmNoWSddKSB7XG5cdFx0XHRcdFx0XHRoYXNab29tZWQgPSBheGlzLnpvb20oYXhpc0RhdGEubWluLCBheGlzRGF0YS5tYXgpO1xuXHRcdFx0XHRcdFx0aWYgKGF4aXMuZGlzcGxheUJ0bikge1xuXHRcdFx0XHRcdFx0XHRkaXNwbGF5QnV0dG9uID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBTaG93IG9yIGhpZGUgdGhlIFJlc2V0IHpvb20gYnV0dG9uXG5cdFx0XHRyZXNldFpvb21CdXR0b24gPSBjaGFydC5yZXNldFpvb21CdXR0b247XG5cdFx0XHRpZiAoZGlzcGxheUJ1dHRvbiAmJiAhcmVzZXRab29tQnV0dG9uKSB7XG5cdFx0XHRcdGNoYXJ0LnNob3dSZXNldFpvb20oKTtcblx0XHRcdH0gZWxzZSBpZiAoIWRpc3BsYXlCdXR0b24gJiYgaXNPYmplY3QocmVzZXRab29tQnV0dG9uKSkge1xuXHRcdFx0XHRjaGFydC5yZXNldFpvb21CdXR0b24gPSByZXNldFpvb21CdXR0b24uZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cblx0XHRcdC8vIFJlZHJhd1xuXHRcdFx0aWYgKGhhc1pvb21lZCkge1xuXHRcdFx0XHRjaGFydC5yZWRyYXcoXG5cdFx0XHRcdFx0cGljayhjaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiwgZXZlbnQgJiYgZXZlbnQuYW5pbWF0aW9uLCBjaGFydC5wb2ludENvdW50IDwgMTAwKSAvLyBhbmltYXRpb25cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUGFuIHRoZSBjaGFydCBieSBkcmFnZ2luZyB0aGUgbW91c2UgYWNyb3NzIHRoZSBwYW5lLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuXHRcdCAqIG9uIG1vdXNlIG1vdmUsIGFuZCB0aGUgZGlzdGFuY2UgdG8gcGFuIGlzIGNvbXB1dGVkIGZyb20gY2hhcnRYIGNvbXBhcmVkIHRvXG5cdFx0ICogdGhlIGZpcnN0IGNoYXJ0WCBwb3NpdGlvbiBpbiB0aGUgZHJhZ2dpbmcgb3BlcmF0aW9uLlxuXHRcdCAqL1xuXHRcdHBhbjogZnVuY3Rpb24gKGUsIHBhbm5pbmcpIHtcblxuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcyxcblx0XHRcdFx0aG92ZXJQb2ludHMgPSBjaGFydC5ob3ZlclBvaW50cyxcblx0XHRcdFx0ZG9SZWRyYXc7XG5cblx0XHRcdC8vIHJlbW92ZSBhY3RpdmUgcG9pbnRzIGZvciBzaGFyZWQgdG9vbHRpcFxuXHRcdFx0aWYgKGhvdmVyUG9pbnRzKSB7XG5cdFx0XHRcdGVhY2goaG92ZXJQb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0XHRcdHBvaW50LnNldFN0YXRlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRlYWNoKHBhbm5pbmcgPT09ICd4eScgPyBbMSwgMF0gOiBbMV0sIGZ1bmN0aW9uIChpc1gpIHsgLy8geHkgaXMgdXNlZCBpbiBtYXBzXG5cdFx0XHRcdHZhciBtb3VzZVBvcyA9IGVbaXNYID8gJ2NoYXJ0WCcgOiAnY2hhcnRZJ10sXG5cdFx0XHRcdFx0YXhpcyA9IGNoYXJ0W2lzWCA/ICd4QXhpcycgOiAneUF4aXMnXVswXSxcblx0XHRcdFx0XHRzdGFydFBvcyA9IGNoYXJ0W2lzWCA/ICdtb3VzZURvd25YJyA6ICdtb3VzZURvd25ZJ10sXG5cdFx0XHRcdFx0aGFsZlBvaW50UmFuZ2UgPSAoYXhpcy5wb2ludFJhbmdlIHx8IDApIC8gMixcblx0XHRcdFx0XHRleHRyZW1lcyA9IGF4aXMuZ2V0RXh0cmVtZXMoKSxcblx0XHRcdFx0XHRuZXdNaW4gPSBheGlzLnRvVmFsdWUoc3RhcnRQb3MgLSBtb3VzZVBvcywgdHJ1ZSkgKyBoYWxmUG9pbnRSYW5nZSxcblx0XHRcdFx0XHRuZXdNYXggPSBheGlzLnRvVmFsdWUoc3RhcnRQb3MgKyBjaGFydFtpc1ggPyAncGxvdFdpZHRoJyA6ICdwbG90SGVpZ2h0J10gLSBtb3VzZVBvcywgdHJ1ZSkgLSBoYWxmUG9pbnRSYW5nZSxcblx0XHRcdFx0XHRnb2luZ0xlZnQgPSBzdGFydFBvcyA+IG1vdXNlUG9zOyAvLyAjMzYxM1xuXG5cdFx0XHRcdGlmIChheGlzLnNlcmllcy5sZW5ndGggJiYgXG5cdFx0XHRcdFx0XHQoZ29pbmdMZWZ0IHx8IG5ld01pbiA+IG1hdGhNaW4oZXh0cmVtZXMuZGF0YU1pbiwgZXh0cmVtZXMubWluKSkgJiYgXG5cdFx0XHRcdFx0XHQoIWdvaW5nTGVmdCB8fCBuZXdNYXggPCBtYXRoTWF4KGV4dHJlbWVzLmRhdGFNYXgsIGV4dHJlbWVzLm1heCkpKSB7XG5cdFx0XHRcdFx0YXhpcy5zZXRFeHRyZW1lcyhuZXdNaW4sIG5ld01heCwgZmFsc2UsIGZhbHNlLCB7IHRyaWdnZXI6ICdwYW4nIH0pO1xuXHRcdFx0XHRcdGRvUmVkcmF3ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNoYXJ0W2lzWCA/ICdtb3VzZURvd25YJyA6ICdtb3VzZURvd25ZJ10gPSBtb3VzZVBvczsgLy8gc2V0IG5ldyByZWZlcmVuY2UgZm9yIG5leHQgcnVuXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGRvUmVkcmF3KSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRjc3MoY2hhcnQuY29udGFpbmVyLCB7IGN1cnNvcjogJ21vdmUnIH0pO1xuXHRcdH1cblx0fSk7XG5cblx0Lypcblx0ICogRXh0ZW5kIHRoZSBQb2ludCBvYmplY3Qgd2l0aCBpbnRlcmFjdGlvblxuXHQgKi9cblx0ZXh0ZW5kKFBvaW50LnByb3RvdHlwZSwge1xuXHRcdC8qKlxuXHRcdCAqIFRvZ2dsZSB0aGUgc2VsZWN0aW9uIHN0YXR1cyBvZiBhIHBvaW50XG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzZWxlY3RlZCBXaGV0aGVyIHRvIHNlbGVjdCBvciB1bnNlbGVjdCB0aGUgcG9pbnQuXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBhY2N1bXVsYXRlIFdoZXRoZXIgdG8gYWRkIHRvIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQsXG5cdFx0ICpcdFx0IHRoaXMgaGFwcGVucyBpZiB0aGUgY29udHJvbCBrZXkgKENtZCBvbiBNYWMpIHdhcyBwcmVzc2VkIGR1cmluZyBjbGlja2luZy5cblx0XHQgKi9cblx0XHRzZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZCwgYWNjdW11bGF0ZSkge1xuXHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0c2VyaWVzID0gcG9pbnQuc2VyaWVzLFxuXHRcdFx0XHRjaGFydCA9IHNlcmllcy5jaGFydDtcblxuXHRcdFx0c2VsZWN0ZWQgPSBwaWNrKHNlbGVjdGVkLCAhcG9pbnQuc2VsZWN0ZWQpO1xuXG5cdFx0XHQvLyBmaXJlIHRoZSBldmVudCB3aXRoIHRoZSBkZWZhbHV0IGhhbmRsZXJcblx0XHRcdHBvaW50LmZpcmVQb2ludEV2ZW50KHNlbGVjdGVkID8gJ3NlbGVjdCcgOiAndW5zZWxlY3QnLCB7IGFjY3VtdWxhdGU6IGFjY3VtdWxhdGUgfSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwb2ludC5zZWxlY3RlZCA9IHBvaW50Lm9wdGlvbnMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcblx0XHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YVtpbkFycmF5KHBvaW50LCBzZXJpZXMuZGF0YSldID0gcG9pbnQub3B0aW9ucztcblxuXHRcdFx0XHRwb2ludC5zZXRTdGF0ZShzZWxlY3RlZCAmJiBTRUxFQ1RfU1RBVEUpO1xuXG5cdFx0XHRcdC8vIHVuc2VsZWN0IGFsbCBvdGhlciBwb2ludHMgdW5sZXNzIEN0cmwgb3IgQ21kICsgY2xpY2tcblx0XHRcdFx0aWYgKCFhY2N1bXVsYXRlKSB7XG5cdFx0XHRcdFx0ZWFjaChjaGFydC5nZXRTZWxlY3RlZFBvaW50cygpLCBmdW5jdGlvbiAobG9vcFBvaW50KSB7XG5cdFx0XHRcdFx0XHRpZiAobG9vcFBvaW50LnNlbGVjdGVkICYmIGxvb3BQb2ludCAhPT0gcG9pbnQpIHtcblx0XHRcdFx0XHRcdFx0bG9vcFBvaW50LnNlbGVjdGVkID0gbG9vcFBvaW50Lm9wdGlvbnMuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0c2VyaWVzLm9wdGlvbnMuZGF0YVtpbkFycmF5KGxvb3BQb2ludCwgc2VyaWVzLmRhdGEpXSA9IGxvb3BQb2ludC5vcHRpb25zO1xuXHRcdFx0XHRcdFx0XHRsb29wUG9pbnQuc2V0U3RhdGUoTk9STUFMX1NUQVRFKTtcblx0XHRcdFx0XHRcdFx0XHRsb29wUG9pbnQuZmlyZVBvaW50RXZlbnQoJ3Vuc2VsZWN0Jyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSdW5zIG9uIG1vdXNlIG92ZXIgdGhlIHBvaW50XG5cdFx0ICovXG5cdFx0b25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLFxuXHRcdFx0XHRzZXJpZXMgPSBwb2ludC5zZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHR0b29sdGlwID0gY2hhcnQudG9vbHRpcCxcblx0XHRcdFx0aG92ZXJQb2ludCA9IGNoYXJ0LmhvdmVyUG9pbnQ7XG5cblx0XHRcdGlmIChjaGFydC5ob3ZlclNlcmllcyAhPT0gc2VyaWVzKSB7XG5cdFx0XHRcdHNlcmllcy5vbk1vdXNlT3ZlcigpO1xuXHRcdFx0fVx0XHRcblxuXHRcdFx0Ly8gc2V0IG5vcm1hbCBzdGF0ZSB0byBwcmV2aW91cyBzZXJpZXNcblx0XHRcdGlmIChob3ZlclBvaW50ICYmIGhvdmVyUG9pbnQgIT09IHBvaW50KSB7XG5cdFx0XHRcdGhvdmVyUG9pbnQub25Nb3VzZU91dCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cmlnZ2VyIHRoZSBldmVudFxuXHRcdFx0cG9pbnQuZmlyZVBvaW50RXZlbnQoJ21vdXNlT3ZlcicpO1xuXG5cdFx0XHQvLyB1cGRhdGUgdGhlIHRvb2x0aXBcblx0XHRcdGlmICh0b29sdGlwICYmICghdG9vbHRpcC5zaGFyZWQgfHwgc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkpIHtcblx0XHRcdFx0dG9vbHRpcC5yZWZyZXNoKHBvaW50LCBlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaG92ZXIgdGhpc1xuXHRcdFx0cG9pbnQuc2V0U3RhdGUoSE9WRVJfU1RBVEUpO1xuXHRcdFx0Y2hhcnQuaG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSdW5zIG9uIG1vdXNlIG91dCBmcm9tIHRoZSBwb2ludFxuXHRcdCAqL1xuXHRcdG9uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRob3ZlclBvaW50cyA9IGNoYXJ0LmhvdmVyUG9pbnRzO1xuXG5cdFx0XHR0aGlzLmZpcmVQb2ludEV2ZW50KCdtb3VzZU91dCcpO1xuXG5cdFx0XHRpZiAoIWhvdmVyUG9pbnRzIHx8IGluQXJyYXkodGhpcywgaG92ZXJQb2ludHMpID09PSAtMSkgeyAvLyAjODg3LCAjMjI0MFxuXHRcdFx0XHR0aGlzLnNldFN0YXRlKCk7XG5cdFx0XHRcdGNoYXJ0LmhvdmVyUG9pbnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbXBvcnQgZXZlbnRzIGZyb20gdGhlIHNlcmllcycgYW5kIHBvaW50J3Mgb3B0aW9ucy4gT25seSBkbyBpdCBvblxuXHRcdCAqIGRlbWFuZCwgdG8gc2F2ZSBwcm9jZXNzaW5nIHRpbWUgb24gaG92ZXJpbmcuXG5cdFx0ICovXG5cdFx0aW1wb3J0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXRoaXMuaGFzSW1wb3J0ZWRFdmVudHMpIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gdGhpcyxcblx0XHRcdFx0XHRvcHRpb25zID0gbWVyZ2UocG9pbnQuc2VyaWVzLm9wdGlvbnMucG9pbnQsIHBvaW50Lm9wdGlvbnMpLFxuXHRcdFx0XHRcdGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzLFxuXHRcdFx0XHRcdGV2ZW50VHlwZTtcblxuXHRcdFx0XHRwb2ludC5ldmVudHMgPSBldmVudHM7XG5cblx0XHRcdFx0Zm9yIChldmVudFR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHRcdFx0YWRkRXZlbnQocG9pbnQsIGV2ZW50VHlwZSwgZXZlbnRzW2V2ZW50VHlwZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuaGFzSW1wb3J0ZWRFdmVudHMgPSB0cnVlO1xuXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgcG9pbnQncyBzdGF0ZVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZVxuXHRcdCAqL1xuXHRcdHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUsIG1vdmUpIHtcblx0XHRcdHZhciBwb2ludCA9IHRoaXMsXG5cdFx0XHRcdHBsb3RYID0gcG9pbnQucGxvdFgsXG5cdFx0XHRcdHBsb3RZID0gcG9pbnQucGxvdFksXG5cdFx0XHRcdHNlcmllcyA9IHBvaW50LnNlcmllcyxcblx0XHRcdFx0c3RhdGVPcHRpb25zID0gc2VyaWVzLm9wdGlvbnMuc3RhdGVzLFxuXHRcdFx0XHRtYXJrZXJPcHRpb25zID0gZGVmYXVsdFBsb3RPcHRpb25zW3Nlcmllcy50eXBlXS5tYXJrZXIgJiYgc2VyaWVzLm9wdGlvbnMubWFya2VyLFxuXHRcdFx0XHRub3JtYWxEaXNhYmxlZCA9IG1hcmtlck9wdGlvbnMgJiYgIW1hcmtlck9wdGlvbnMuZW5hYmxlZCxcblx0XHRcdFx0bWFya2VyU3RhdGVPcHRpb25zID0gbWFya2VyT3B0aW9ucyAmJiBtYXJrZXJPcHRpb25zLnN0YXRlc1tzdGF0ZV0sXG5cdFx0XHRcdHN0YXRlRGlzYWJsZWQgPSBtYXJrZXJTdGF0ZU9wdGlvbnMgJiYgbWFya2VyU3RhdGVPcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlLFxuXHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWMgPSBzZXJpZXMuc3RhdGVNYXJrZXJHcmFwaGljLFxuXHRcdFx0XHRwb2ludE1hcmtlciA9IHBvaW50Lm1hcmtlciB8fCB7fSxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHJhZGl1cyxcblx0XHRcdFx0aGFsbyA9IHNlcmllcy5oYWxvLFxuXHRcdFx0XHRoYWxvT3B0aW9ucyxcblx0XHRcdFx0bmV3U3ltYm9sLFxuXHRcdFx0XHRwb2ludEF0dHI7XG5cblx0XHRcdHN0YXRlID0gc3RhdGUgfHwgTk9STUFMX1NUQVRFOyAvLyBlbXB0eSBzdHJpbmdcblx0XHRcdHBvaW50QXR0ciA9IHBvaW50LnBvaW50QXR0cltzdGF0ZV0gfHwgc2VyaWVzLnBvaW50QXR0cltzdGF0ZV07XG5cblx0XHRcdGlmIChcblx0XHRcdFx0XHQvLyBhbHJlYWR5IGhhcyB0aGlzIHN0YXRlXG5cdFx0XHRcdFx0KHN0YXRlID09PSBwb2ludC5zdGF0ZSAmJiAhbW92ZSkgfHxcblx0XHRcdFx0XHQvLyBzZWxlY3RlZCBwb2ludHMgZG9uJ3QgcmVzcG9uZCB0byBob3ZlclxuXHRcdFx0XHRcdChwb2ludC5zZWxlY3RlZCAmJiBzdGF0ZSAhPT0gU0VMRUNUX1NUQVRFKSB8fFxuXHRcdFx0XHRcdC8vIHNlcmllcycgc3RhdGUgb3B0aW9ucyBpcyBkaXNhYmxlZFxuXHRcdFx0XHRcdChzdGF0ZU9wdGlvbnNbc3RhdGVdICYmIHN0YXRlT3B0aW9uc1tzdGF0ZV0uZW5hYmxlZCA9PT0gZmFsc2UpIHx8XG5cdFx0XHRcdFx0Ly8gZ2VuZXJhbCBwb2ludCBtYXJrZXIncyBzdGF0ZSBvcHRpb25zIGlzIGRpc2FibGVkXG5cdFx0XHRcdFx0KHN0YXRlICYmIChzdGF0ZURpc2FibGVkIHx8IChub3JtYWxEaXNhYmxlZCAmJiBtYXJrZXJTdGF0ZU9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpKSkgfHxcblx0XHRcdFx0XHQvLyBpbmRpdmlkdWFsIHBvaW50IG1hcmtlcidzIHN0YXRlIG9wdGlvbnMgaXMgZGlzYWJsZWRcblx0XHRcdFx0XHQoc3RhdGUgJiYgcG9pbnRNYXJrZXIuc3RhdGVzICYmIHBvaW50TWFya2VyLnN0YXRlc1tzdGF0ZV0gJiYgcG9pbnRNYXJrZXIuc3RhdGVzW3N0YXRlXS5lbmFibGVkID09PSBmYWxzZSkgLy8gIzE2MTBcblxuXHRcdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhcHBseSBob3ZlciBzdHlsZXMgdG8gdGhlIGV4aXN0aW5nIHBvaW50XG5cdFx0XHRpZiAocG9pbnQuZ3JhcGhpYykge1xuXHRcdFx0XHRyYWRpdXMgPSBtYXJrZXJPcHRpb25zICYmIHBvaW50LmdyYXBoaWMuc3ltYm9sTmFtZSAmJiBwb2ludEF0dHIucjtcblx0XHRcdFx0cG9pbnQuZ3JhcGhpYy5hdHRyKG1lcmdlKFxuXHRcdFx0XHRcdHBvaW50QXR0cixcblx0XHRcdFx0XHRyYWRpdXMgPyB7IC8vIG5ldyBzeW1ib2wgYXR0cmlidXRlcyAoIzUwNywgIzYxMilcblx0XHRcdFx0XHRcdHg6IHBsb3RYIC0gcmFkaXVzLFxuXHRcdFx0XHRcdFx0eTogcGxvdFkgLSByYWRpdXMsXG5cdFx0XHRcdFx0XHR3aWR0aDogMiAqIHJhZGl1cyxcblx0XHRcdFx0XHRcdGhlaWdodDogMiAqIHJhZGl1c1xuXHRcdFx0XHRcdH0gOiB7fVxuXHRcdFx0XHQpKTtcblxuXHRcdFx0XHQvLyBab29taW5nIGluIGZyb20gYSByYW5nZSB3aXRoIG5vIG1hcmtlcnMgdG8gYSByYW5nZSB3aXRoIG1hcmtlcnNcblx0XHRcdFx0aWYgKHN0YXRlTWFya2VyR3JhcGhpYykge1xuXHRcdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpYy5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGlmIGEgZ3JhcGhpYyBpcyBub3QgYXBwbGllZCB0byBlYWNoIHBvaW50IGluIHRoZSBub3JtYWwgc3RhdGUsIGNyZWF0ZSBhIHNoYXJlZFxuXHRcdFx0XHQvLyBncmFwaGljIGZvciB0aGUgaG92ZXIgc3RhdGVcblx0XHRcdFx0aWYgKHN0YXRlICYmIG1hcmtlclN0YXRlT3B0aW9ucykge1xuXHRcdFx0XHRcdHJhZGl1cyA9IG1hcmtlclN0YXRlT3B0aW9ucy5yYWRpdXM7XG5cdFx0XHRcdFx0bmV3U3ltYm9sID0gcG9pbnRNYXJrZXIuc3ltYm9sIHx8IHNlcmllcy5zeW1ib2w7XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcG9pbnQgaGFzIGFub3RoZXIgc3ltYm9sIHRoYW4gdGhlIHByZXZpb3VzIG9uZSwgdGhyb3cgYXdheSB0aGVcblx0XHRcdFx0XHQvLyBzdGF0ZSBtYXJrZXIgZ3JhcGhpYyBhbmQgZm9yY2UgYSBuZXcgb25lICgjMTQ1OSlcblx0XHRcdFx0XHRpZiAoc3RhdGVNYXJrZXJHcmFwaGljICYmIHN0YXRlTWFya2VyR3JhcGhpYy5jdXJyZW50U3ltYm9sICE9PSBuZXdTeW1ib2wpIHtcblx0XHRcdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpYyA9IHN0YXRlTWFya2VyR3JhcGhpYy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQWRkIGEgbmV3IHN0YXRlIG1hcmtlciBncmFwaGljXG5cdFx0XHRcdFx0aWYgKCFzdGF0ZU1hcmtlckdyYXBoaWMpIHtcblx0XHRcdFx0XHRcdGlmIChuZXdTeW1ib2wpIHtcblx0XHRcdFx0XHRcdFx0c2VyaWVzLnN0YXRlTWFya2VyR3JhcGhpYyA9IHN0YXRlTWFya2VyR3JhcGhpYyA9IGNoYXJ0LnJlbmRlcmVyLnN5bWJvbChcblx0XHRcdFx0XHRcdFx0XHRuZXdTeW1ib2wsXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFggLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0cGxvdFkgLSByYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0MiAqIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHQyICogcmFkaXVzXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0LmF0dHIocG9pbnRBdHRyKVxuXHRcdFx0XHRcdFx0XHQuYWRkKHNlcmllcy5tYXJrZXJHcm91cCk7XG5cdFx0XHRcdFx0XHRcdHN0YXRlTWFya2VyR3JhcGhpYy5jdXJyZW50U3ltYm9sID0gbmV3U3ltYm9sO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTW92ZSB0aGUgZXhpc3RpbmcgZ3JhcGhpY1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWNbbW92ZSA/ICdhbmltYXRlJyA6ICdhdHRyJ10oeyAvLyAjMTA1NFxuXHRcdFx0XHRcdFx0XHR4OiBwbG90WCAtIHJhZGl1cyxcblx0XHRcdFx0XHRcdFx0eTogcGxvdFkgLSByYWRpdXNcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzdGF0ZU1hcmtlckdyYXBoaWMpIHtcblx0XHRcdFx0XHRzdGF0ZU1hcmtlckdyYXBoaWNbc3RhdGUgJiYgY2hhcnQuaXNJbnNpZGVQbG90KHBsb3RYLCBwbG90WSwgY2hhcnQuaW52ZXJ0ZWQpID8gJ3Nob3cnIDogJ2hpZGUnXSgpOyAvLyAjMjQ1MFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgbWUgeW91ciBoYWxvXG5cdFx0XHRoYWxvT3B0aW9ucyA9IHN0YXRlT3B0aW9uc1tzdGF0ZV0gJiYgc3RhdGVPcHRpb25zW3N0YXRlXS5oYWxvO1xuXHRcdFx0aWYgKGhhbG9PcHRpb25zICYmIGhhbG9PcHRpb25zLnNpemUpIHtcblx0XHRcdFx0aWYgKCFoYWxvKSB7XG5cdFx0XHRcdFx0c2VyaWVzLmhhbG8gPSBoYWxvID0gY2hhcnQucmVuZGVyZXIucGF0aCgpXG5cdFx0XHRcdFx0XHQuYWRkKGNoYXJ0LnNlcmllc0dyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoYWxvLmF0dHIoZXh0ZW5kKHtcblx0XHRcdFx0XHRmaWxsOiBDb2xvcihwb2ludC5jb2xvciB8fCBzZXJpZXMuY29sb3IpLnNldE9wYWNpdHkoaGFsb09wdGlvbnMub3BhY2l0eSkuZ2V0KClcblx0XHRcdFx0fSwgaGFsb09wdGlvbnMuYXR0cmlidXRlcykpW21vdmUgPyAnYW5pbWF0ZScgOiAnYXR0ciddKHtcblx0XHRcdFx0XHRkOiBwb2ludC5oYWxvUGF0aChoYWxvT3B0aW9ucy5zaXplKVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAoaGFsbykge1xuXHRcdFx0XHRoYWxvLmF0dHIoeyBkOiBbXSB9KTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnQuc3RhdGUgPSBzdGF0ZTtcblx0XHR9LFxuXG5cdFx0aGFsb1BhdGg6IGZ1bmN0aW9uIChzaXplKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcy5zZXJpZXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRwbG90Qm94ID0gc2VyaWVzLmdldFBsb3RCb3goKSxcblx0XHRcdFx0aW52ZXJ0ZWQgPSBjaGFydC5pbnZlcnRlZDtcblxuXHRcdFx0cmV0dXJuIGNoYXJ0LnJlbmRlcmVyLnN5bWJvbHMuY2lyY2xlKFxuXHRcdFx0XHRwbG90Qm94LnRyYW5zbGF0ZVggKyAoaW52ZXJ0ZWQgPyBzZXJpZXMueUF4aXMubGVuIC0gdGhpcy5wbG90WSA6IHRoaXMucGxvdFgpIC0gc2l6ZSwgXG5cdFx0XHRcdHBsb3RCb3gudHJhbnNsYXRlWSArIChpbnZlcnRlZCA/IHNlcmllcy54QXhpcy5sZW4gLSB0aGlzLnBsb3RYIDogdGhpcy5wbG90WSkgLSBzaXplLCBcblx0XHRcdFx0c2l6ZSAqIDIsIFxuXHRcdFx0XHRzaXplICogMlxuXHRcdFx0KTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qXG5cdCAqIEV4dGVuZCB0aGUgU2VyaWVzIG9iamVjdCB3aXRoIGludGVyYWN0aW9uXG5cdCAqL1xuXG5cdGV4dGVuZChTZXJpZXMucHJvdG90eXBlLCB7XG5cdFx0LyoqXG5cdFx0ICogU2VyaWVzIG1vdXNlIG92ZXIgaGFuZGxlclxuXHRcdCAqL1xuXHRcdG9uTW91c2VPdmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VyaWVzID0gdGhpcyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdGhvdmVyU2VyaWVzID0gY2hhcnQuaG92ZXJTZXJpZXM7XG5cblx0XHRcdC8vIHNldCBub3JtYWwgc3RhdGUgdG8gcHJldmlvdXMgc2VyaWVzXG5cdFx0XHRpZiAoaG92ZXJTZXJpZXMgJiYgaG92ZXJTZXJpZXMgIT09IHNlcmllcykge1xuXHRcdFx0XHRob3ZlclNlcmllcy5vbk1vdXNlT3V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRyaWdnZXIgdGhlIGV2ZW50LCBidXQgdG8gc2F2ZSBwcm9jZXNzaW5nIHRpbWUsXG5cdFx0XHQvLyBvbmx5IGlmIGRlZmluZWRcblx0XHRcdGlmIChzZXJpZXMub3B0aW9ucy5ldmVudHMubW91c2VPdmVyKSB7XG5cdFx0XHRcdGZpcmVFdmVudChzZXJpZXMsICdtb3VzZU92ZXInKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaG92ZXIgdGhpc1xuXHRcdFx0c2VyaWVzLnNldFN0YXRlKEhPVkVSX1NUQVRFKTtcblx0XHRcdGNoYXJ0LmhvdmVyU2VyaWVzID0gc2VyaWVzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXJpZXMgbW91c2Ugb3V0IGhhbmRsZXJcblx0XHQgKi9cblx0XHRvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyB0cmlnZ2VyIHRoZSBldmVudCBvbmx5IGlmIGxpc3RlbmVycyBleGlzdFxuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdG9wdGlvbnMgPSBzZXJpZXMub3B0aW9ucyxcblx0XHRcdFx0Y2hhcnQgPSBzZXJpZXMuY2hhcnQsXG5cdFx0XHRcdHRvb2x0aXAgPSBjaGFydC50b29sdGlwLFxuXHRcdFx0XHRob3ZlclBvaW50ID0gY2hhcnQuaG92ZXJQb2ludDtcblxuXHRcdFx0Ly8gdHJpZ2dlciBtb3VzZSBvdXQgb24gdGhlIHBvaW50LCB3aGljaCBtdXN0IGJlIGluIHRoaXMgc2VyaWVzXG5cdFx0XHRpZiAoaG92ZXJQb2ludCkge1xuXHRcdFx0XHRob3ZlclBvaW50Lm9uTW91c2VPdXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZmlyZSB0aGUgbW91c2Ugb3V0IGV2ZW50XG5cdFx0XHRpZiAoc2VyaWVzICYmIG9wdGlvbnMuZXZlbnRzLm1vdXNlT3V0KSB7XG5cdFx0XHRcdGZpcmVFdmVudChzZXJpZXMsICdtb3VzZU91dCcpO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vIGhpZGUgdGhlIHRvb2x0aXBcblx0XHRcdGlmICh0b29sdGlwICYmICFvcHRpb25zLnN0aWNreVRyYWNraW5nICYmICghdG9vbHRpcC5zaGFyZWQgfHwgc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCkpIHtcblx0XHRcdFx0dG9vbHRpcC5oaWRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCBub3JtYWwgc3RhdGVcblx0XHRcdHNlcmllcy5zZXRTdGF0ZSgpO1xuXHRcdFx0Y2hhcnQuaG92ZXJTZXJpZXMgPSBudWxsO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBncmFwaFxuXHRcdCAqL1xuXHRcdHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzLFxuXHRcdFx0XHRvcHRpb25zID0gc2VyaWVzLm9wdGlvbnMsXG5cdFx0XHRcdGdyYXBoID0gc2VyaWVzLmdyYXBoLFxuXHRcdFx0XHRncmFwaE5lZyA9IHNlcmllcy5ncmFwaE5lZyxcblx0XHRcdFx0c3RhdGVPcHRpb25zID0gb3B0aW9ucy5zdGF0ZXMsXG5cdFx0XHRcdGxpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoLFxuXHRcdFx0XHRhdHRyaWJzO1xuXG5cdFx0XHRzdGF0ZSA9IHN0YXRlIHx8IE5PUk1BTF9TVEFURTtcblxuXHRcdFx0aWYgKHNlcmllcy5zdGF0ZSAhPT0gc3RhdGUpIHtcblx0XHRcdFx0c2VyaWVzLnN0YXRlID0gc3RhdGU7XG5cblx0XHRcdFx0aWYgKHN0YXRlT3B0aW9uc1tzdGF0ZV0gJiYgc3RhdGVPcHRpb25zW3N0YXRlXS5lbmFibGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzdGF0ZSkge1xuXHRcdFx0XHRcdGxpbmVXaWR0aCA9IChzdGF0ZU9wdGlvbnNbc3RhdGVdLmxpbmVXaWR0aCB8fCBsaW5lV2lkdGgpICsgKHN0YXRlT3B0aW9uc1tzdGF0ZV0ubGluZVdpZHRoUGx1cyB8fCAwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChncmFwaCAmJiAhZ3JhcGguZGFzaHN0eWxlKSB7IC8vIGhvdmVyIGlzIHR1cm5lZCBvZmYgZm9yIGRhc2hlZCBsaW5lcyBpbiBWTUxcblx0XHRcdFx0XHRhdHRyaWJzID0ge1xuXHRcdFx0XHRcdFx0J3N0cm9rZS13aWR0aCc6IGxpbmVXaWR0aFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gdXNlIGF0dHIgYmVjYXVzZSBhbmltYXRlIHdpbGwgY2F1c2UgYW55IG90aGVyIGFuaW1hdGlvbiBvbiB0aGUgZ3JhcGggdG8gc3RvcFxuXHRcdFx0XHRcdGdyYXBoLmF0dHIoYXR0cmlicyk7XG5cdFx0XHRcdFx0aWYgKGdyYXBoTmVnKSB7XG5cdFx0XHRcdFx0XHRncmFwaE5lZy5hdHRyKGF0dHJpYnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGdyYXBoXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gdmlzIHtCb29sZWFufSBUcnVlIHRvIHNob3cgdGhlIHNlcmllcywgZmFsc2UgdG8gaGlkZS4gSWYgVU5ERUZJTkVELFxuXHRcdCAqXHRcdFx0XHR0aGUgdmlzaWJpbGl0eSBpcyB0b2dnbGVkLlxuXHRcdCAqL1xuXHRcdHNldFZpc2libGU6IGZ1bmN0aW9uICh2aXMsIHJlZHJhdykge1xuXHRcdFx0dmFyIHNlcmllcyA9IHRoaXMsXG5cdFx0XHRcdGNoYXJ0ID0gc2VyaWVzLmNoYXJ0LFxuXHRcdFx0XHRsZWdlbmRJdGVtID0gc2VyaWVzLmxlZ2VuZEl0ZW0sXG5cdFx0XHRcdHNob3dPckhpZGUsXG5cdFx0XHRcdGlnbm9yZUhpZGRlblNlcmllcyA9IGNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzLFxuXHRcdFx0XHRvbGRWaXNpYmlsaXR5ID0gc2VyaWVzLnZpc2libGU7XG5cblx0XHRcdC8vIGlmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCB0b2dnbGUgdmlzaWJpbGl0eVxuXHRcdFx0c2VyaWVzLnZpc2libGUgPSB2aXMgPSBzZXJpZXMudXNlck9wdGlvbnMudmlzaWJsZSA9IHZpcyA9PT0gVU5ERUZJTkVEID8gIW9sZFZpc2liaWxpdHkgOiB2aXM7XG5cdFx0XHRzaG93T3JIaWRlID0gdmlzID8gJ3Nob3cnIDogJ2hpZGUnO1xuXG5cdFx0XHQvLyBzaG93IG9yIGhpZGUgZWxlbWVudHNcblx0XHRcdGVhY2goWydncm91cCcsICdkYXRhTGFiZWxzR3JvdXAnLCAnbWFya2VyR3JvdXAnLCAndHJhY2tlciddLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmIChzZXJpZXNba2V5XSkge1xuXHRcdFx0XHRcdHNlcmllc1trZXldW3Nob3dPckhpZGVdKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cblx0XHRcdC8vIGhpZGUgdG9vbHRpcCAoIzEzNjEpXG5cdFx0XHRpZiAoY2hhcnQuaG92ZXJTZXJpZXMgPT09IHNlcmllcyB8fCAoY2hhcnQuaG92ZXJQb2ludCAmJiBjaGFydC5ob3ZlclBvaW50LnNlcmllcykgPT09IHNlcmllcykge1xuXHRcdFx0XHRzZXJpZXMub25Nb3VzZU91dCgpO1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmIChsZWdlbmRJdGVtKSB7XG5cdFx0XHRcdGNoYXJ0LmxlZ2VuZC5jb2xvcml6ZUl0ZW0oc2VyaWVzLCB2aXMpO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vIHJlc2NhbGUgb3IgYWRhcHQgdG8gcmVzaXplZCBjaGFydFxuXHRcdFx0c2VyaWVzLmlzRGlydHkgPSB0cnVlO1xuXHRcdFx0Ly8gaW4gYSBzdGFjaywgYWxsIG90aGVyIHNlcmllcyBhcmUgYWZmZWN0ZWRcblx0XHRcdGlmIChzZXJpZXMub3B0aW9ucy5zdGFja2luZykge1xuXHRcdFx0XHRlYWNoKGNoYXJ0LnNlcmllcywgZnVuY3Rpb24gKG90aGVyU2VyaWVzKSB7XG5cdFx0XHRcdFx0aWYgKG90aGVyU2VyaWVzLm9wdGlvbnMuc3RhY2tpbmcgJiYgb3RoZXJTZXJpZXMudmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0b3RoZXJTZXJpZXMuaXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2hvdyBvciBoaWRlIGxpbmtlZCBzZXJpZXNcblx0XHRcdGVhY2goc2VyaWVzLmxpbmtlZFNlcmllcywgZnVuY3Rpb24gKG90aGVyU2VyaWVzKSB7XG5cdFx0XHRcdG90aGVyU2VyaWVzLnNldFZpc2libGUodmlzLCBmYWxzZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGlnbm9yZUhpZGRlblNlcmllcykge1xuXHRcdFx0XHRjaGFydC5pc0RpcnR5Qm94ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChyZWRyYXcgIT09IGZhbHNlKSB7XG5cdFx0XHRcdGNoYXJ0LnJlZHJhdygpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJlRXZlbnQoc2VyaWVzLCBzaG93T3JIaWRlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2hvdyB0aGUgZ3JhcGhcblx0XHQgKi9cblx0XHRzaG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnNldFZpc2libGUodHJ1ZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhpZGUgdGhlIGdyYXBoXG5cdFx0ICovXG5cdFx0aGlkZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5zZXRWaXNpYmxlKGZhbHNlKTtcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBncmFwaFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHNlbGVjdGVkIHtCb29sZWFufSBUcnVlIHRvIHNlbGVjdCB0aGUgc2VyaWVzLCBmYWxzZSB0byB1bnNlbGVjdC4gSWZcblx0XHQgKlx0XHRcdFx0VU5ERUZJTkVELCB0aGUgc2VsZWN0aW9uIHN0YXRlIGlzIHRvZ2dsZWQuXG5cdFx0ICovXG5cdFx0c2VsZWN0OiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcblx0XHRcdHZhciBzZXJpZXMgPSB0aGlzO1xuXHRcdFx0Ly8gaWYgY2FsbGVkIHdpdGhvdXQgYW4gYXJndW1lbnQsIHRvZ2dsZVxuXHRcdFx0c2VyaWVzLnNlbGVjdGVkID0gc2VsZWN0ZWQgPSAoc2VsZWN0ZWQgPT09IFVOREVGSU5FRCkgPyAhc2VyaWVzLnNlbGVjdGVkIDogc2VsZWN0ZWQ7XG5cblx0XHRcdGlmIChzZXJpZXMuY2hlY2tib3gpIHtcblx0XHRcdFx0c2VyaWVzLmNoZWNrYm94LmNoZWNrZWQgPSBzZWxlY3RlZDtcblx0XHRcdH1cblxuXHRcdFx0ZmlyZUV2ZW50KHNlcmllcywgc2VsZWN0ZWQgPyAnc2VsZWN0JyA6ICd1bnNlbGVjdCcpO1xuXHRcdH0sXG5cblx0XHRkcmF3VHJhY2tlcjogVHJhY2tlck1peGluLmRyYXdUcmFja2VyR3JhcGhcblx0fSk7XG5cdC8vIGdsb2JhbCB2YXJpYWJsZXNcblx0ZXh0ZW5kKEhpZ2hjaGFydHMsIHtcblx0XHRcblx0XHQvLyBDb25zdHJ1Y3RvcnNcblx0XHRDb2xvcjogQ29sb3IsXG5cdFx0UG9pbnQ6IFBvaW50LFxuXHRcdFRpY2s6IFRpY2ssXHRcblx0XHRSZW5kZXJlcjogUmVuZGVyZXIsXG5cdFx0U1ZHRWxlbWVudDogU1ZHRWxlbWVudCxcblx0XHRTVkdSZW5kZXJlcjogU1ZHUmVuZGVyZXIsXG5cdFx0XG5cdFx0Ly8gVmFyaW91c1xuXHRcdGFycmF5TWluOiBhcnJheU1pbixcblx0XHRhcnJheU1heDogYXJyYXlNYXgsXG5cdFx0Y2hhcnRzOiBjaGFydHMsXG5cdFx0ZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcblx0XHRlcnJvcjogZXJyb3IsXG5cdFx0Zm9ybWF0OiBmb3JtYXQsXG5cdFx0cGF0aEFuaW06IHBhdGhBbmltLFxuXHRcdGdldE9wdGlvbnM6IGdldE9wdGlvbnMsXG5cdFx0aGFzQmlkaUJ1ZzogaGFzQmlkaUJ1Zyxcblx0XHRpc1RvdWNoRGV2aWNlOiBpc1RvdWNoRGV2aWNlLFxuXHRcdHNldE9wdGlvbnM6IHNldE9wdGlvbnMsXG5cdFx0YWRkRXZlbnQ6IGFkZEV2ZW50LFxuXHRcdHJlbW92ZUV2ZW50OiByZW1vdmVFdmVudCxcblx0XHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuXHRcdGRpc2NhcmRFbGVtZW50OiBkaXNjYXJkRWxlbWVudCxcblx0XHRjc3M6IGNzcyxcblx0XHRlYWNoOiBlYWNoLFxuXHRcdG1hcDogbWFwLFxuXHRcdG1lcmdlOiBtZXJnZSxcblx0XHRzcGxhdDogc3BsYXQsXG5cdFx0ZXh0ZW5kQ2xhc3M6IGV4dGVuZENsYXNzLFxuXHRcdHBJbnQ6IHBJbnQsXG5cdFx0c3ZnOiBoYXNTVkcsXG5cdFx0Y2FudmFzOiB1c2VDYW5WRyxcblx0XHR2bWw6ICFoYXNTVkcgJiYgIXVzZUNhblZHLFxuXHRcdHByb2R1Y3Q6IFBST0RVQ1QsXG5cdFx0dmVyc2lvbjogVkVSU0lPTlxuXHR9KTtcblxuXHR9KCkpO1xuXG5cblx0LyoqKiBFWFBPUlRTIEZST00gZXhwb3J0cy1sb2FkZXIgKioqL1xuXHRtb2R1bGUuZXhwb3J0cyA9IEhpZ2hjaGFydHNcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuIiwidmFyIHdhcm5pbmcgPSByZXF1aXJlKCcuL2xpYi93YXJuaW5nJyk7XG53YXJuaW5nKFxuICBmYWxzZSxcbiAgJ3JlcXVpcmUoXCJyZWFjdC9hZGRvbnNcIikgaXMgZGVwcmVjYXRlZC4gJyArXG4gICdBY2Nlc3MgdXNpbmcgcmVxdWlyZShcInJlYWN0L2FkZG9ucy97YWRkb259XCIpIGluc3RlYWQuJ1xuKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFdpdGhBZGRvbnMnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNNaXhpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoXCIuL2ZpbmRET01Ob2RlXCIpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoXCIuL2ZvY3VzTm9kZVwiKTtcblxudmFyIEF1dG9Gb2N1c01peGluID0ge1xuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgZm9jdXNOb2RlKGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzTWl4aW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZShcIi4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlXCIpO1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50XCIpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNJbnB1dEV2ZW50XCIpO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGUsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZTpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghY3VycmVudENvbXBvc2l0aW9uICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0UG9vbGVkKHRvcExldmVsVGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQgfHwgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnJlbGVhc2UoY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggJiYgIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCldO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlZm9yZUlucHV0RXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU0NvcmVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFRoZSBDU1NDb3JlIG1vZHVsZSBzcGVjaWZpZXMgdGhlIEFQSSAoYW5kIGltcGxlbWVudHMgbW9zdCBvZiB0aGUgbWV0aG9kcylcbiAqIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBkZWFsaW5nIHdpdGggdGhlIGRpc3BsYXkgb2YgZWxlbWVudHMgKHZpYSB0aGVpclxuICogQ1NTIGNsYXNzZXMgYW5kIHZpc2liaWxpdHkgb24gc2NyZWVuLiBJdCBpcyBhbiBBUEkgZm9jdXNlZCBvbiBtdXRhdGluZyB0aGVcbiAqIGRpc3BsYXkgYW5kIG5vdCByZWFkaW5nIGl0IGFzIG5vIGxvZ2ljYWwgc3RhdGUgc2hvdWxkIGJlIGVuY29kZWQgaW4gdGhlXG4gKiBkaXNwbGF5IG9mIGVsZW1lbnRzLlxuICovXG5cbnZhciBDU1NDb3JlID0ge1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBjbGFzcyBwYXNzZWQgaW4gdG8gdGhlIGVsZW1lbnQgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG4gICAqL1xuICBhZGRDbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICEhL1xccy8udGVzdChjbGFzc05hbWUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0NTU0NvcmUuYWRkQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLiBcIiVzXCIgY29udGFpbnMgJyArICdtdWx0aXBsZSBjbGFzc2VzLicsIGNsYXNzTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIGlmICghQ1NTQ29yZS5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBjbGFzcyBwYXNzZWQgaW4gZnJvbSB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAhIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdDU1NDb3JlLnJlbW92ZUNsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4gXCIlc1wiIGNvbnRhaW5zICcgKyAnbXVsdGlwbGUgY2xhc3Nlcy4nLCBjbGFzc05hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQ1NTQ29yZS5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzfCQpJywgJ2cnKSwgJyQxJykucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIG11bHRpcGxlIHNwYWNlcyB0byBvbmVcbiAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTsgLy8gdHJpbSB0aGUgZW5kc1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIHRvIGFkZCBvciByZW1vdmUgYSBjbGFzcyBmcm9tIGFuIGVsZW1lbnQgYmFzZWQgb24gYSBjb25kaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHBhcmFtIHsqfSBib29sIGNvbmRpdGlvbiB0byB3aGV0aGVyIHRvIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgY29uZGl0aW9uQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGJvb2wpIHtcbiAgICByZXR1cm4gKGJvb2wgPyBDU1NDb3JlLmFkZENsYXNzIDogQ1NTQ29yZS5yZW1vdmVDbGFzcykoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzIHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtET01Ob2RlfERPTVdpbmRvd30gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzLCBmYWxzZSBpZiBub3RcbiAgICovXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgISEvXFxzLy50ZXN0KGNsYXNzTmFtZSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnQ1NTLmhhc0NsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gISFjbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuICgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbGFzc05hbWUgKyAnICcpID4gLTE7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NDb3JlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb246IHRydWUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgYm9yZGVyV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyTGVmdENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgYm9yZGVyUmlnaHRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyVG9wOiB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyVG9wU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcbiAgfSxcbiAgZm9udDoge1xuICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgIGZvbnRTaXplOiB0cnVlLFxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKFwiLi9DU1NQcm9wZXJ0eVwiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKFwiLi9jYW1lbGl6ZVN0eWxlTmFtZVwiKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZShcIi4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZVwiKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKFwiLi9oeXBoZW5hdGVTdHlsZU5hbWVcIik7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKFwiLi9tZW1vaXplU3RyaW5nT25seVwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbn0pO1xuXG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4IG9ubHkgc3VwcG9ydHMgYWNjZXNzaW5nIGNzc0Zsb2F0IChzdGFuZGFyZCkgYXMgc3R5bGVGbG9hdFxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmNzc0Zsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbn1cblxuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiAnICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uIChub2RlLCBzdHlsZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVGbG9hdEFjY2Vzc29yO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gQ1NTUHJvcGVydHkuc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcbiAgICAgICAgICAvLyBjb21wb25lbnQgdG8gcGxhY2F0ZSBpdFxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENhbGxiYWNrUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrUXVldWUoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbn1cblxuYXNzaWduKENhbGxiYWNrUXVldWUucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAhKGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDaGFuZ2VFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL2lzRXZlbnRTdXBwb3J0ZWRcIik7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZShcIi4vaXNUZXh0SW5wdXRFbGVtZW50XCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2hhbmdlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DaGFuZ2VDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLCB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHJldHVybiBlbGVtLm5vZGVOYW1lID09PSAnU0VMRUNUJyB8fCBlbGVtLm5vZGVOYW1lID09PSAnSU5QVVQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJRCwgbmF0aXZlRXZlbnQpO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENoYW5nZSkge1xuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50c1xuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJRCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SUQgPSB0YXJnZXRJRDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGRlbGV0ZSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVmaW5pdGlvblxuICBkZWxldGUgYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcblxuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xuICBpZiAodmFsdWUgPT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB2YWx1ZTtcblxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBJZiBhIGBjaGFuZ2VgIGV2ZW50IHNob3VsZCBiZSBmaXJlZCwgcmV0dXJucyB0aGUgdGFyZ2V0J3MgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wSW5wdXQpIHtcbiAgICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMgKGkuZS4sIG5vdCBJRTggb3IgSUU5KSwgdGhlIGlucHV0IGV2ZW50IGlzIGV4YWN0bHlcbiAgICAvLyB3aGF0IHdlIHdhbnQgc28gZmFsbCB0aHJvdWdoIGhlcmUgYW5kIHRyaWdnZXIgYW4gYWJzdHJhY3QgZXZlbnRcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93bikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgICAgYWN0aXZlRWxlbWVudFZhbHVlID0gYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SUQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpIHtcblxuICAgIHZhciBnZXRUYXJnZXRJREZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFODtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldElERnVuYykge1xuICAgICAgdmFyIHRhcmdldElEID0gZ2V0VGFyZ2V0SURGdW5jKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICAgICAgaWYgKHRhcmdldElEKSB7XG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgdGFyZ2V0SUQsIG5hdGl2ZUV2ZW50KTtcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2xpZW50UmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmV4dFJlYWN0Um9vdEluZGV4ID0gMDtcblxudmFyIENsaWVudFJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXh0UmVhY3RSb290SW5kZXgrKztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRSZWFjdFJvb3RJbmRleDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NQ2hpbGRyZW5PcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERhbmdlciA9IHJlcXVpcmUoXCIuL0RhbmdlclwiKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoXCIuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXCIpO1xuXG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKFwiLi9zZXRUZXh0Q29udGVudFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgaW5kZXgpIHtcbiAgLy8gQnkgZXhwbG9pdGluZyBhcnJheXMgcmV0dXJuaW5nIGB1bmRlZmluZWRgIGZvciBhbiB1bmRlZmluZWQgaW5kZXgsIHdlIGNhblxuICAvLyByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiBIb3dldmVyLCB1c2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGxcbiAgLy8gYnJvd3NlcnMgc28gd2UgbXVzdCByZXBsYWNlIGl0IHdpdGggYG51bGxgLlxuXG4gIC8vIGZpeCByZW5kZXIgb3JkZXIgZXJyb3IgaW4gc2FmYXJpXG4gIC8vIElFOCB3aWxsIHRocm93IGVycm9yIHdoZW4gaW5kZXggb3V0IG9mIGxpc3Qgc2l6ZS5cbiAgdmFyIGJlZm9yZUNoaWxkID0gaW5kZXggPj0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/IG51bGwgOiBwYXJlbnROb2RlLmNoaWxkTm9kZXMuaXRlbShpbmRleCk7XG5cbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBiZWZvcmVDaGlsZCk7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcblxuICB1cGRhdGVUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuIFRoZVxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzVXBkYXRlczogZnVuY3Rpb24gKHVwZGF0ZXMsIG1hcmt1cExpc3QpIHtcbiAgICB2YXIgdXBkYXRlO1xuICAgIC8vIE1hcHBpbmcgZnJvbSBwYXJlbnQgSURzIHRvIGluaXRpYWwgY2hpbGQgb3JkZXJpbmdzLlxuICAgIHZhciBpbml0aWFsQ2hpbGRyZW4gPSBudWxsO1xuICAgIC8vIExpc3Qgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGJlIG1vdmVkIG9yIHJlbW92ZWQuXG4gICAgdmFyIHVwZGF0ZWRDaGlsZHJlbiA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZXNbaV07XG4gICAgICBpZiAodXBkYXRlLnR5cGUgPT09IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcgfHwgdXBkYXRlLnR5cGUgPT09IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFKSB7XG4gICAgICAgIHZhciB1cGRhdGVkSW5kZXggPSB1cGRhdGUuZnJvbUluZGV4O1xuICAgICAgICB2YXIgdXBkYXRlZENoaWxkID0gdXBkYXRlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1t1cGRhdGVkSW5kZXhdO1xuICAgICAgICB2YXIgcGFyZW50SUQgPSB1cGRhdGUucGFyZW50SUQ7XG5cbiAgICAgICAgIXVwZGF0ZWRDaGlsZCA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzVXBkYXRlcygpOiBVbmFibGUgdG8gZmluZCBjaGlsZCAlcyBvZiBlbGVtZW50LiBUaGlzICcgKyAncHJvYmFibHkgbWVhbnMgdGhlIERPTSB3YXMgdW5leHBlY3RlZGx5IG11dGF0ZWQgKGUuZy4sIGJ5IHRoZSAnICsgJ2Jyb3dzZXIpLCB1c3VhbGx5IGR1ZSB0byBmb3JnZXR0aW5nIGEgPHRib2R5PiB3aGVuIHVzaW5nIHRhYmxlcywgJyArICduZXN0aW5nIHRhZ3MgbGlrZSA8Zm9ybT4sIDxwPiwgb3IgPGE+LCBvciB1c2luZyBub24tU1ZHIGVsZW1lbnRzICcgKyAnaW4gYW4gPHN2Zz4gcGFyZW50LiBUcnkgaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgJyArICd3aXRoIFJlYWN0IElEIGAlc2AuJywgdXBkYXRlZEluZGV4LCBwYXJlbnRJRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGluaXRpYWxDaGlsZHJlbiA9IGluaXRpYWxDaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXSA9IGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gfHwgW107XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF1bdXBkYXRlZEluZGV4XSA9IHVwZGF0ZWRDaGlsZDtcblxuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4gPSB1cGRhdGVkQ2hpbGRyZW4gfHwgW107XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbi5wdXNoKHVwZGF0ZWRDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlcmVkTWFya3VwID0gRGFuZ2VyLmRhbmdlcm91c2x5UmVuZGVyTWFya3VwKG1hcmt1cExpc3QpO1xuXG4gICAgLy8gUmVtb3ZlIHVwZGF0ZWQgY2hpbGRyZW4gZmlyc3Qgc28gdGhhdCBgdG9JbmRleGAgaXMgY29uc2lzdGVudC5cbiAgICBpZiAodXBkYXRlZENoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVwZGF0ZWRDaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW5bal0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh1cGRhdGVkQ2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdXBkYXRlID0gdXBkYXRlc1trXTtcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQOlxuICAgICAgICAgIGluc2VydENoaWxkQXQodXBkYXRlLnBhcmVudE5vZGUsIHJlbmRlcmVkTWFya3VwW3VwZGF0ZS5tYXJrdXBJbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIGluc2VydENoaWxkQXQodXBkYXRlLnBhcmVudE5vZGUsIGluaXRpYWxDaGlsZHJlblt1cGRhdGUucGFyZW50SURdW3VwZGF0ZS5mcm9tSW5kZXhdLCB1cGRhdGUudG9JbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5UOlxuICAgICAgICAgIHNldFRleHRDb250ZW50KHVwZGF0ZS5wYXJlbnROb2RlLCB1cGRhdGUudGV4dENvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFOlxuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZCBieSB0aGUgZm9yLWxvb3AgYWJvdmUuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5PcGVyYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX0FUVFJJQlVURTogMSxcbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDIsXG4gIEhBU19TSURFX0VGRkVDVFM6IDQsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiA4LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMTYsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAzMiB8IDE2LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiA2NCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgJyArICdcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSAnICsgJ2luamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlICcgKyAnaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtwcm9wTmFtZV0gPSB0cnVlO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW3Byb3BOYW1lXSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW3Byb3BOYW1lXSA9IGxvd2VyQ2FzZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lc3BhY2VbcHJvcE5hbWVdID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lc3BhY2VbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgRE9NUHJvcGVydHkuZ2V0UHJvcGVydHlOYW1lW3Byb3BOYW1lXSA9IERPTVByb3BlcnR5TmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV0gOiBwcm9wTmFtZTtcblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0TXV0YXRpb25NZXRob2RbcHJvcE5hbWVdID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldE11dGF0aW9uTWV0aG9kW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICBET01Qcm9wZXJ0eS5tdXN0VXNlQXR0cmlidXRlW3Byb3BOYW1lXSA9IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBET01Qcm9wZXJ0eUluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEUpO1xuICAgICAgRE9NUHJvcGVydHkubXVzdFVzZVByb3BlcnR5W3Byb3BOYW1lXSA9IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBET01Qcm9wZXJ0eUluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSk7XG4gICAgICBET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1twcm9wTmFtZV0gPSBjaGVja01hc2socHJvcENvbmZpZywgRE9NUHJvcGVydHlJbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUyk7XG4gICAgICBET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbcHJvcE5hbWVdID0gY2hlY2tNYXNrKHByb3BDb25maWcsIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKTtcbiAgICAgIERPTVByb3BlcnR5Lmhhc051bWVyaWNWYWx1ZVtwcm9wTmFtZV0gPSBjaGVja01hc2socHJvcENvbmZpZywgRE9NUHJvcGVydHlJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpO1xuICAgICAgRE9NUHJvcGVydHkuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWVbcHJvcE5hbWVdID0gY2hlY2tNYXNrKHByb3BDb25maWcsIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKTtcbiAgICAgIERPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbcHJvcE5hbWVdID0gY2hlY2tNYXNrKHByb3BDb25maWcsIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpO1xuXG4gICAgICAhKCFET01Qcm9wZXJ0eS5tdXN0VXNlQXR0cmlidXRlW3Byb3BOYW1lXSB8fCAhRE9NUHJvcGVydHkubXVzdFVzZVByb3BlcnR5W3Byb3BOYW1lXSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IENhbm5vdCByZXF1aXJlIHVzaW5nIGJvdGggYXR0cmlidXRlIGFuZCBwcm9wZXJ0eTogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgIShET01Qcm9wZXJ0eS5tdXN0VXNlUHJvcGVydHlbcHJvcE5hbWVdIHx8ICFET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1twcm9wTmFtZV0pID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBQcm9wZXJ0aWVzIHRoYXQgaGF2ZSBzaWRlIGVmZmVjdHMgbXVzdCB1c2UgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICEoISFET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbcHJvcE5hbWVdICsgISFET01Qcm9wZXJ0eS5oYXNOdW1lcmljVmFsdWVbcHJvcE5hbWVdICsgISFET01Qcm9wZXJ0eS5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlW3Byb3BOYW1lXSA8PSAxKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yICcgKyAnbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59O1xudmFyIGRlZmF1bHRWYWx1ZUNhY2hlID0ge307XG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBzdGFuZGFyZCBwcm9wZXJ0eS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGlzU3RhbmRhcmROYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gYXR0cmlidXRlIG5hbWVzIHRoYXQgZGlmZmVyLiBBdHRyaWJ1dGVcbiAgICogbmFtZXMgYXJlIHVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGVOYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gbmFtZXNwYWNlcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldEF0dHJpYnV0ZU5hbWVzcGFjZToge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkIG5hbWVzIHRvIHByb3BlcnRpZXMgb24gRE9NIG5vZGUgaW5zdGFuY2VzLlxuICAgKiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0byBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFByb3BlcnR5TmFtZToge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkIG5hbWVzIHRvIG11dGF0aW9uIG1ldGhvZHMuIFRoaXMgd2lsbCBvbmx5IGV4aXN0IGlmXG4gICAqIG11dGF0aW9uIGNhbm5vdCBiZSBzZXQgc2ltcGx5IGJ5IHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TXV0YXRpb25NZXRob2Q6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIG11c3RVc2VBdHRyaWJ1dGU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIHVzaW5nIGAqQXR0cmlidXRlKClgLlxuICAgKiAoVGhpcyBpbmNsdWRlcyBhbnl0aGluZyB0aGF0IGZhaWxzIGA8cHJvcE5hbWU+IGluIDxlbGVtZW50PmAuKVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgbXVzdFVzZVByb3BlcnR5OiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3Qgc2V0dGluZyBhIHZhbHVlIGNhdXNlcyBzaWRlIGVmZmVjdHMgc3VjaCBhcyB0cmlnZ2VyaW5nXG4gICAqIHJlc291cmNlcyB0byBiZSBsb2FkZWQgb3IgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcy4gV2UgbXVzdCBlbnN1cmUgdGhhdFxuICAgKiB0aGUgdmFsdWUgaXMgb25seSBzZXQgaWYgaXQgaGFzIGNoYW5nZWQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNTaWRlRWZmZWN0czoge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgaGFzQm9vbGVhblZhbHVlOiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGFcbiAgICogbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNOdW1lcmljVmFsdWU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLiBSZW1vdmVkXG4gICAqIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW4gc3RyaWN0bHkgZXF1YWxcbiAgICogdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZToge30sXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlIGZvciBhIERPTSBwcm9wZXJ0eSAoaS5lLiwgbm90IGFuXG4gICAqIGF0dHJpYnV0ZSkuIE1vc3QgZGVmYXVsdCB2YWx1ZXMgYXJlICcnIG9yIGZhbHNlLCBidXQgbm90IGFsbC4gV29yc2UgeWV0LFxuICAgKiBzb21lIChpbiBwYXJ0aWN1bGFyLCBgdHlwZWApIHZhcnkgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGVsZW1lbnQuXG4gICAqXG4gICAqIFRPRE86IElzIGl0IGJldHRlciB0byBncmFiIGFsbCB0aGUgcG9zc2libGUgcHJvcGVydGllcyB3aGVuIGNyZWF0aW5nIGFuXG4gICAqIGVsZW1lbnQgdG8gYXZvaWQgaGF2aW5nIHRvIGNyZWF0ZSB0aGUgc2FtZSBlbGVtZW50IHR3aWNlP1xuICAgKi9cbiAgZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlTmFtZSwgcHJvcCkge1xuICAgIHZhciBub2RlRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV07XG4gICAgdmFyIHRlc3RFbGVtZW50O1xuICAgIGlmICghbm9kZURlZmF1bHRzKSB7XG4gICAgICBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV0gPSBub2RlRGVmYXVsdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCEocHJvcCBpbiBub2RlRGVmYXVsdHMpKSB7XG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgbm9kZURlZmF1bHRzW3Byb3BdID0gdGVzdEVsZW1lbnRbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlRGVmYXVsdHNbcHJvcF07XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoXCIuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbbmFtZV0gJiYgIXZhbHVlIHx8IERPTVByb3BlcnR5Lmhhc051bWVyaWNWYWx1ZVtuYW1lXSAmJiBpc05hTih2YWx1ZSkgfHwgRE9NUHJvcGVydHkuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWVbbmFtZV0gJiYgdmFsdWUgPCAxIHx8IERPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbbmFtZV0gJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlXG4gIH07XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHdhcm5Vbmtub3duUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gRm9yIG5vdywgb25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIHN1Z2dlc3RlZCBjb3JyZWN0aW9uLiBUaGlzIHByZXZlbnRzXG4gICAgLy8gbG9nZ2luZyB0b28gbXVjaCB3aGVuIHVzaW5nIHRyYW5zZmVyUHJvcHNUby5cbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhzdGFuZGFyZE5hbWUgPT0gbnVsbCwgJ1Vua25vd24gRE9NIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgc3RhbmRhcmROYW1lKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtuYW1lXSkge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbbmFtZV07XG4gICAgICBpZiAoRE9NUHJvcGVydHkuaGFzQm9vbGVhblZhbHVlW25hbWVdIHx8IERPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbbmFtZV0gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KG5hbWUpICYmIERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW25hbWVdKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBET01Qcm9wZXJ0eS5nZXRNdXRhdGlvbk1ldGhvZFtuYW1lXTtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbbmFtZV0pIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW25hbWVdO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gRE9NUHJvcGVydHkuZ2V0QXR0cmlidXRlTmFtZXNwYWNlW25hbWVdO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gRE9NUHJvcGVydHkuZ2V0UHJvcGVydHlOYW1lW25hbWVdO1xuICAgICAgICAvLyBNdXN0IGV4cGxpY2l0bHkgY2FzdCB2YWx1ZXMgZm9yIEhBU19TSURFX0VGRkVDVFMtcHJvcGVydGllcyB0byB0aGVcbiAgICAgICAgLy8gcHJvcGVydHkgdHlwZSBiZWZvcmUgY29tcGFyaW5nOyBvbmx5IGB2YWx1ZWAgZG9lcyBhbmQgaXMgc3RyaW5nLlxuICAgICAgICBpZiAoIURPTVByb3BlcnR5Lmhhc1NpZGVFZmZlY3RzW25hbWVdIHx8ICcnICsgbm9kZVtwcm9wTmFtZV0gIT09ICcnICsgdmFsdWUpIHtcbiAgICAgICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtuYW1lXSkge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gRE9NUHJvcGVydHkuZ2V0TXV0YXRpb25NZXRob2RbbmFtZV07XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkubXVzdFVzZUF0dHJpYnV0ZVtuYW1lXSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW25hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IERPTVByb3BlcnR5LmdldFByb3BlcnR5TmFtZVtuYW1lXTtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IERPTVByb3BlcnR5LmdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5KG5vZGUubm9kZU5hbWUsIHByb3BOYW1lKTtcbiAgICAgICAgaWYgKCFET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1tuYW1lXSB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERhbmdlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZShcIi4vY3JlYXRlTm9kZXNGcm9tTWFya3VwXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKFwiLi9nZXRNYXJrdXBXcmFwXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIE9QRU5fVEFHX05BTUVfRVhQID0gL14oPFteIFxcLz5dKykvO1xudmFyIFJFU1VMVF9JTkRFWF9BVFRSID0gJ2RhdGEtZGFuZ2VyLWluZGV4JztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBmcm9tIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBOT1RFOiBFeHRyYWN0aW5nIHRoZSBgbm9kZU5hbWVgIGRvZXMgbm90IHJlcXVpcmUgYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hcbiAqIGJlY2F1c2Ugd2UgbWFrZSBhc3N1bXB0aW9ucyBhYm91dCBSZWFjdC1nZW5lcmF0ZWQgbWFya3VwIChpLmUuIHRoZXJlIGFyZSBub1xuICogc3BhY2VzIHN1cnJvdW5kaW5nIHRoZSBvcGVuaW5nIHRhZyBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZXh0cmFjdC1ub2RlbmFtZVxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgcmV0dXJuIG1hcmt1cC5zdWJzdHJpbmcoMSwgbWFya3VwLmluZGV4T2YoJyAnKSk7XG59XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgbWFya3VwIGludG8gYW4gYXJyYXkgb2Ygbm9kZXMuIFRoZSBtYXJrdXAgaXMgZXhwZWN0ZWQgdG8gcmVuZGVyXG4gICAqIGludG8gYSBsaXN0IG9mIHJvb3Qgbm9kZXMuIEFsc28sIHRoZSBsZW5ndGggb2YgYHJlc3VsdExpc3RgIGFuZFxuICAgKiBgbWFya3VwTGlzdGAgc2hvdWxkIGJlIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncyB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnQ+fSBMaXN0IG9mIHJlbmRlcmVkIG5vZGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVuZGVyTWFya3VwOiBmdW5jdGlvbiAobWFya3VwTGlzdCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgJyArICd0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5ICcgKyAnYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArICdSZWFjdC5yZW5kZXJUb1N0cmluZyBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIG5vZGVOYW1lO1xuICAgIHZhciBtYXJrdXBCeU5vZGVOYW1lID0ge307XG4gICAgLy8gR3JvdXAgbWFya3VwIGJ5IGBub2RlTmFtZWAgaWYgYSB3cmFwIGlzIG5lY2Vzc2FyeSwgZWxzZSBieSAnKicuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrdXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAhbWFya3VwTGlzdFtpXSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cExpc3RbaV0pO1xuICAgICAgbm9kZU5hbWUgPSBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSA/IG5vZGVOYW1lIDogJyonO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSB8fCBbXTtcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdW2ldID0gbWFya3VwTGlzdFtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdExpc3QgPSBbXTtcbiAgICB2YXIgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9IDA7XG4gICAgZm9yIChub2RlTmFtZSBpbiBtYXJrdXBCeU5vZGVOYW1lKSB7XG4gICAgICBpZiAoIW1hcmt1cEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmt1cExpc3RCeU5vZGVOYW1lID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV07XG5cbiAgICAgIC8vIFRoaXMgZm9yLWluIGxvb3Agc2tpcHMgdGhlIGhvbGVzIG9mIHRoZSBzcGFyc2UgYXJyYXkuIFRoZSBvcmRlciBvZlxuICAgICAgLy8gaXRlcmF0aW9uIHNob3VsZCBmb2xsb3cgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQsIHdoaWNoIGhhcHBlbnMgdG8gbWF0Y2hcbiAgICAgIC8vIG51bWVyaWNhbCBpbmRleCBvcmRlciwgYnV0IHdlIGRvbid0IHJlbHkgb24gdGhhdC5cbiAgICAgIHZhciByZXN1bHRJbmRleDtcbiAgICAgIGZvciAocmVzdWx0SW5kZXggaW4gbWFya3VwTGlzdEJ5Tm9kZU5hbWUpIHtcbiAgICAgICAgaWYgKG1hcmt1cExpc3RCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSkge1xuICAgICAgICAgIHZhciBtYXJrdXAgPSBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAvLyBQdXNoIHRoZSByZXF1ZXN0ZWQgbWFya3VwIHdpdGggYW4gYWRkaXRpb25hbCBSRVNVTFRfSU5ERVhfQVRUUlxuICAgICAgICAgIC8vIGF0dHJpYnV0ZS4gIElmIHRoZSBtYXJrdXAgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIDwgY2hhcmFjdGVyLCBpdFxuICAgICAgICAgIC8vIHdpbGwgYmUgZGlzY2FyZGVkIGJlbG93ICh3aXRoIGFuIGFwcHJvcHJpYXRlIGNvbnNvbGUuZXJyb3IpLlxuICAgICAgICAgIG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XSA9IG1hcmt1cC5yZXBsYWNlKE9QRU5fVEFHX05BTUVfRVhQLFxuICAgICAgICAgIC8vIFRoaXMgaW5kZXggd2lsbCBiZSBwYXJzZWQgYmFjayBvdXQgYmVsb3cuXG4gICAgICAgICAgJyQxICcgKyBSRVNVTFRfSU5ERVhfQVRUUiArICc9XCInICsgcmVzdWx0SW5kZXggKyAnXCIgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGVhY2ggZ3JvdXAgb2YgbWFya3VwIHdpdGggc2ltaWxhciB3cmFwcGluZyBgbm9kZU5hbWVgLlxuICAgICAgdmFyIHJlbmRlck5vZGVzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cExpc3RCeU5vZGVOYW1lLmpvaW4oJycpLCBlbXB0eUZ1bmN0aW9uIC8vIERvIG5vdGhpbmcgc3BlY2lhbCB3aXRoIDxzY3JpcHQ+IHRhZ3MuXG4gICAgICApO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbmRlck5vZGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciByZW5kZXJOb2RlID0gcmVuZGVyTm9kZXNbal07XG4gICAgICAgIGlmIChyZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZSAmJiByZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUikpIHtcblxuICAgICAgICAgIHJlc3VsdEluZGV4ID0gK3JlbmRlck5vZGUuZ2V0QXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcbiAgICAgICAgICByZW5kZXJOb2RlLnJlbW92ZUF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG5cbiAgICAgICAgICAhIXJlc3VsdExpc3QuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogQXNzaWduaW5nIHRvIGFuIGFscmVhZHktb2NjdXBpZWQgcmVzdWx0IGluZGV4LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHJlc3VsdExpc3RbcmVzdWx0SW5kZXhdID0gcmVuZGVyTm9kZTtcblxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHJlc3VsdExpc3QubGVuZ3RoIGFuZCBtYXJrdXBMaXN0Lmxlbmd0aCB3aGVuXG4gICAgICAgICAgLy8gd2UncmUgZG9uZS5cbiAgICAgICAgICByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhbmdlcjogRGlzY2FyZGluZyB1bmV4cGVjdGVkIG5vZGU6JywgcmVuZGVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHRob3VnaCByZXN1bHRMaXN0IHdhcyBwb3B1bGF0ZWQgb3V0IG9mIG9yZGVyLCBpdCBzaG91bGQgbm93IGJlIGEgZGVuc2VcbiAgICAvLyBhcnJheS5cbiAgICAhKHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPT09IHJlc3VsdExpc3QubGVuZ3RoKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IERpZCBub3QgYXNzaWduIHRvIGV2ZXJ5IGluZGV4IG9mIHJlc3VsdExpc3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgIShyZXN1bHRMaXN0Lmxlbmd0aCA9PT0gbWFya3VwTGlzdC5sZW5ndGgpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogRXhwZWN0ZWQgbWFya3VwIHRvIHJlbmRlciAlcyBub2RlcywgYnV0IHJlbmRlcmVkICVzLicsIG1hcmt1cExpc3QubGVuZ3RoLCByZXN1bHRMaXN0Lmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHJlc3VsdExpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgJyArICd3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSAnICsgJ2dsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlICcgKyAnUmVhY3QucmVuZGVyVG9TdHJpbmcgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICFtYXJrdXAgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEob2xkQ2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgJyArICc8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlICcgKyAnYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2UgJyArICdzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3QucmVuZGVyVG9TdHJpbmcoKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IFtrZXlPZih7IFJlc3BvbmRlckV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNpbXBsZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFRhcEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEVudGVyTGVhdmVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBDaGFuZ2VFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTZWxlY3RFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEFuYWx5dGljc0V2ZW50UGx1Z2luOiBudWxsIH0pXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoXCIuL0V2ZW50UHJvcGFnYXRvcnNcIik7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY01vdXNlRXZlbnRcIik7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG52YXIgZ2V0Rmlyc3RSZWFjdERPTSA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VFbnRlcjogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUxlYXZlOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9XG59O1xuXG52YXIgZXh0cmFjdGVkRXZlbnRzID0gW251bGwsIG51bGxdO1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlciAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0ICYmIHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmICh0b3BMZXZlbFRhcmdldC53aW5kb3cgPT09IHRvcExldmVsVGFyZ2V0KSB7XG4gICAgICAvLyBgdG9wTGV2ZWxUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IHRvcExldmVsVGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gdG9wTGV2ZWxUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb20sIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQpIHtcbiAgICAgIGZyb20gPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgIHRvID0gZ2V0Rmlyc3RSZWFjdERPTShuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudCkgfHwgd2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tID0gd2luO1xuICAgICAgdG8gPSB0b3BMZXZlbFRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tSUQgPSBmcm9tID8gUmVhY3RNb3VudC5nZXRJRChmcm9tKSA6ICcnO1xuICAgIHZhciB0b0lEID0gdG8gPyBSZWFjdE1vdW50LmdldElEKHRvKSA6ICcnO1xuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tSUQsIG5hdGl2ZUV2ZW50KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb207XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUVudGVyLCB0b0lELCBuYXRpdmVFdmVudCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0bztcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKTtcblxuICAgIGV4dHJhY3RlZEV2ZW50c1swXSA9IGxlYXZlO1xuICAgIGV4dHJhY3RlZEV2ZW50c1sxXSA9IGVudGVyO1xuXG4gICAgcmV0dXJuIGV4dHJhY3RlZEV2ZW50cztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRDb25zdGFudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IGtleU1pcnJvcih7IGJ1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsIH0pO1xuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKi9cbnZhciB0b3BMZXZlbFR5cGVzID0ga2V5TWlycm9yKHtcbiAgdG9wQmx1cjogbnVsbCxcbiAgdG9wQ2hhbmdlOiBudWxsLFxuICB0b3BDbGljazogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiBudWxsLFxuICB0b3BDb250ZXh0TWVudTogbnVsbCxcbiAgdG9wQ29weTogbnVsbCxcbiAgdG9wQ3V0OiBudWxsLFxuICB0b3BEb3VibGVDbGljazogbnVsbCxcbiAgdG9wRHJhZzogbnVsbCxcbiAgdG9wRHJhZ0VuZDogbnVsbCxcbiAgdG9wRHJhZ0VudGVyOiBudWxsLFxuICB0b3BEcmFnRXhpdDogbnVsbCxcbiAgdG9wRHJhZ0xlYXZlOiBudWxsLFxuICB0b3BEcmFnT3ZlcjogbnVsbCxcbiAgdG9wRHJhZ1N0YXJ0OiBudWxsLFxuICB0b3BEcm9wOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUmVzZXQ6IG51bGwsXG4gIHRvcFNjcm9sbDogbnVsbCxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BTdWJtaXQ6IG51bGwsXG4gIHRvcFRleHRJbnB1dDogbnVsbCxcbiAgdG9wVG91Y2hDYW5jZWw6IG51bGwsXG4gIHRvcFRvdWNoRW5kOiBudWxsLFxuICB0b3BUb3VjaE1vdmU6IG51bGwsXG4gIHRvcFRvdWNoU3RhcnQ6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiAoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpbkh1YlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblJlZ2lzdHJ5XCIpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblV0aWxzXCIpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKFwiLi9hY2N1bXVsYXRlSW50b1wiKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKFwiLi9mb3JFYWNoQWNjdW11bGF0ZWRcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgdmFyIGV4ZWN1dGVEaXNwYXRjaCA9IEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoO1xuICAgIC8vIFBsdWdpbnMgY2FuIHByb3ZpZGUgY3VzdG9tIGJlaGF2aW9yIHdoZW4gZGlzcGF0Y2hpbmcgZXZlbnRzLlxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmdldFBsdWdpbk1vZHVsZUZvckV2ZW50KGV2ZW50KTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2gpIHtcbiAgICAgIGV4ZWN1dGVEaXNwYXRjaCA9IFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2g7XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBleGVjdXRlRGlzcGF0Y2gpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIC0gYEluc3RhbmNlSGFuZGxlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBwZXJmb3JtcyBsb2dpY2FsIHRyYXZlcnNhbHMgb2YgRE9NXG4gKiAgIGhpZXJhcmNoeSBnaXZlbiBpZHMgb2YgdGhlIGxvZ2ljYWwgRE9NIGVsZW1lbnRzIGludm9sdmVkLlxuICovXG52YXIgSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCkge1xuICB2YXIgdmFsaWQgPSBJbnN0YW5jZUhhbmRsZSAmJiBJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZVR3b1BoYXNlICYmIEluc3RhbmNlSGFuZGxlLnRyYXZlcnNlRW50ZXJMZWF2ZTtcbiAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcodmFsaWQsICdJbnN0YW5jZUhhbmRsZSBub3QgaW5qZWN0ZWQgYmVmb3JlIHVzZSEnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZE1vdW50XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdE1vdW50OiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZEluc3RhbmNlSGFuZGxlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbiAoSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgSW5zdGFuY2VIYW5kbGUgPSBJbmplY3RlZEluc3RhbmNlSGFuZGxlO1xuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEluc3RhbmNlSGFuZGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpZCkge1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UpO1xuICAgICEhZXZlbnRRdWV1ZSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgJyArICdhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlc2UgYXJlIG5lZWRlZCBmb3IgdGVzdHMgb25seS4gRG8gbm90IHVzZSFcbiAgICovXG4gIF9fcHVyZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcbiAgfSxcblxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsaXN0ZW5lckJhbms7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5SZWdpc3RyeVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghRXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYEV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IEV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiAnICsgJ3RoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIVBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgICcgKyAnbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG5cbiAgLyoqXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICAgKi9cbiAgcGx1Z2luczogW10sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICAgKi9cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uIChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAhIUV2ZW50UGx1Z2luT3JkZXIgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuICcgKyAnb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gICAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGZ1bmN0aW9uIChpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyAnICsgJ3VzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvb2tzIHVwIHRoZSBwbHVnaW4gZm9yIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEEgc3ludGhldGljIGV2ZW50LlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBUaGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnO1xuICAgIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICByZXR1cm4gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lXSB8fCBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBwaGFzZSBpbiBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKCFkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSkge1xuICAgICAgICByZXR1cm4gUGx1Z2luTW9kdWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5VdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgTW91bnRgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgZG9tIElEcyBhbmRcbiAqICAgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIGluamVjdGlvbiA9IHtcbiAgTW91bnQ6IG51bGwsXG4gIGluamVjdE1vdW50OiBmdW5jdGlvbiAoSW5qZWN0ZWRNb3VudCkge1xuICAgIGluamVjdGlvbi5Nb3VudCA9IEluamVjdGVkTW91bnQ7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKEluamVjdGVkTW91bnQgJiYgSW5qZWN0ZWRNb3VudC5nZXROb2RlICYmIEluamVjdGVkTW91bnQuZ2V0SUQsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCguLi4pOiBJbmplY3RlZCBNb3VudCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGUgb3IgZ2V0SUQuJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDtcbn1cblxuZnVuY3Rpb24gaXNNb3ZlaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlO1xufVxuZnVuY3Rpb24gaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24gfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ7XG59XG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbmlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBpZHNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJRHMpO1xuICAgIHZhciBJRHNMZW4gPSBpZHNJc0FyciA/IGRpc3BhdGNoSURzLmxlbmd0aCA6IGRpc3BhdGNoSURzID8gMSA6IDA7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGlkc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBJRHNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjYihldmVudCwgbGlzdGVuZXIsIGlkKWAuIEF2b2lkcyB1c2luZyBjYWxsIGlmIG5vIHNjb3BlIGlzXG4gKiBwcm92aWRlZC4gVGhlIGAobGlzdGVuZXIsaWQpYCBwYWlyIGVmZmVjdGl2ZWx5IGZvcm1zIHRoZSBcImRpc3BhdGNoXCIgYnV0IGFyZVxuICoga2VwdCBzZXBhcmF0ZSB0byBjb25zZXJ2ZSBtZW1vcnkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hFdmVudERpc3BhdGNoKGV2ZW50LCBjYikge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGNiKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJRHNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGNiKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJRHMpO1xuICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBQbHVnaW5Nb2R1bGUuZXhlY3V0ZURpc3BhdGNoKCkuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tSUQgRE9NIGlkIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBkb21JRCkge1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gaW5qZWN0aW9uLk1vdW50LmdldE5vZGUoZG9tSUQpO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBsaXN0ZW5lcihldmVudCwgZG9tSUQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIGNiKSB7XG4gIGZvckVhY2hFdmVudERpc3BhdGNoKGV2ZW50LCBjYik7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMsIGJ1dCBzdG9wc1xuICogYXQgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiByZXR1cm5pbmcgdHJ1ZSwgYW5kIHJldHVybnMgdGhhdCBpZC5cbiAqXG4gKiBAcmV0dXJuIGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJucyB0cnVlLCBvclxuICogbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJRHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaElEc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSURzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSURzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSUQgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50LCBkaXNwYXRjaElEKSA6IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2x9IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2g6IGV4ZWN1dGVEaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXG5cbiAgZ2V0Tm9kZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGlkKTtcbiAgfSxcbiAgZ2V0SUQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGluamVjdGlvbi5Nb3VudC5nZXRJRChub2RlKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFByb3BhZ2F0b3JzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoXCIuL2FjY3VtdWxhdGVJbnRvXCIpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoXCIuL2ZvckVhY2hBY2N1bXVsYXRlZFwiKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0gRXZlbnRDb25zdGFudHMuUHJvcGFnYXRpb25QaGFzZXM7XG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaWQsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGRvbUlELCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGRvbUlELCAnRGlzcGF0Y2hpbmcgaWQgbXVzdCBub3QgYmUgbnVsbCcpIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBwaGFzZSA9IHVwd2FyZHMgPyBQcm9wYWdhdGlvblBoYXNlcy5idWJibGVkIDogUHJvcGFnYXRpb25QaGFzZXMuY2FwdHVyZWQ7XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShkb21JRCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSURzLCBkb21JRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbiBub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlVHdvUGhhc2VTa2lwVGFyZ2V0KGV2ZW50LmRpc3BhdGNoTWFya2VyLCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpZCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGlkKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50LmRpc3BhdGNoTWFya2VyLCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb21JRCwgdG9JRCkge1xuICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbUlELCB0b0lELCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVudCBhXG4gKiBzaW5nbGUgb25lLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBFdmVudFByb3BhZ2F0b3JzXG4gKi9cbnZhciBFdmVudFByb3BhZ2F0b3JzID0ge1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG4gIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQcm9wYWdhdG9yczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXhlY3V0aW9uRW52aXJvbm1lbnRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKFwiLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yXCIpO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcbiAqL1xuZnVuY3Rpb24gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHJvb3QpIHtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBIVE1MRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBNVVNUX1VTRV9BVFRSSUJVVEUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFO1xudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19TSURFX0VGRkVDVFMgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUztcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBoYXNTVkc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciBpbXBsZW1lbnRhdGlvbiA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xuICBoYXNTVkcgPSBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyk7XG59XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihkYXRhfGFyaWEpLVthLXpfXVthLXpcXGRfLlxcLV0qJC8pLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogbnVsbCxcbiAgICBhY2NlcHRDaGFyc2V0OiBudWxsLFxuICAgIGFjY2Vzc0tleTogbnVsbCxcbiAgICBhY3Rpb246IG51bGwsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGFsdDogbnVsbCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiBudWxsLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzTWl4aW5cbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogbnVsbCxcbiAgICBjZWxsU3BhY2luZzogbnVsbCxcbiAgICBjaGFyU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjbGFzc0lEOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gVG8gc2V0IGNsYXNzTmFtZSBvbiBTVkcgZWxlbWVudHMsIGl0J3MgbmVjZXNzYXJ5IHRvIHVzZSAuc2V0QXR0cmlidXRlO1xuICAgIC8vIHRoaXMgd29ya3Mgb24gSFRNTCBlbGVtZW50cyB0b28gaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBJRTguIENvbnZlbmllbnRseSxcbiAgICAvLyBJRTggZG9lc24ndCBzdXBwb3J0IFNWRyBhbmQgc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIGF0dHJpYnV0ZSBpblxuICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBTVkcgYW5kIHRoZSBwcm9wZXJ0eSBpbiBicm93c2VycyB0aGF0IGRvbid0LFxuICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgZWxlbWVudCBpcyBIVE1MIG9yIFNWRy5cbiAgICBjbGFzc05hbWU6IGhhc1NWRyA/IE1VU1RfVVNFX0FUVFJJQlVURSA6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGNvbHM6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBjb250ZW50RWRpdGFibGU6IG51bGwsXG4gICAgY29udGV4dE1lbnU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjb250cm9sczogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IG51bGwsXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgZGF0YTogbnVsbCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogbnVsbCxcbiAgICBkaXNhYmxlZDogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiBudWxsLFxuICAgIGVuY1R5cGU6IG51bGwsXG4gICAgZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1BY3Rpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtRW5jVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1NZXRob2Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZyYW1lQm9yZGVyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICBoZWlnaHQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoaWRkZW46IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IG51bGwsXG4gICAgaHJlZjogbnVsbCxcbiAgICBocmVmTGFuZzogbnVsbCxcbiAgICBodG1sRm9yOiBudWxsLFxuICAgIGh0dHBFcXVpdjogbnVsbCxcbiAgICBpY29uOiBudWxsLFxuICAgIGlkOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBsYW5nOiBudWxsLFxuICAgIGxpc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBsb29wOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogbnVsbCxcbiAgICBtYW5pZmVzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmdpbkhlaWdodDogbnVsbCxcbiAgICBtYXJnaW5XaWR0aDogbnVsbCxcbiAgICBtYXg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWVkaWE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYUdyb3VwOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBtaW46IG51bGwsXG4gICAgbWluTGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbmFtZTogbnVsbCxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcHRpbXVtOiBudWxsLFxuICAgIHBhdHRlcm46IG51bGwsXG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgcG9zdGVyOiBudWxsLFxuICAgIHByZWxvYWQ6IG51bGwsXG4gICAgcmFkaW9Hcm91cDogbnVsbCxcbiAgICByZWFkT25seTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWw6IG51bGwsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByb3dzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBudWxsLFxuICAgIHNhbmRib3g6IG51bGwsXG4gICAgc2NvcGU6IG51bGwsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IG51bGwsXG4gICAgc2VhbWxlc3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiBudWxsLFxuICAgIHNpemU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogbnVsbCxcbiAgICBzcmM6IG51bGwsXG4gICAgc3JjRG9jOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBzcmNTZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICB0YWJJbmRleDogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB1c2VNYXA6IG51bGwsXG4gICAgdmFsdWU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX1NJREVfRUZGRUNUUyxcbiAgICB3aWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdtb2RlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXG4gICAgLy8ga2V5Ym9hcmQgaGludHMuXG4gICAgYXV0b0NhcGl0YWxpemU6IG51bGwsXG4gICAgYXV0b0NvcnJlY3Q6IG51bGwsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpdGVtU2NvcGU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGl0ZW1UeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgdGhlIFdIQVRXRyBzcGVjIGRvY3VtZW50LiBTZWVcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9taWNyb2RhdGEuaHRtbCNtaWNyb2RhdGEtZG9tLWFwaVxuICAgIGl0ZW1JRDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGl0ZW1SZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IG51bGwsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBjb250cm9scyBmb2N1cyBiZWhhdmlvclxuICAgIHVuc2VsZWN0YWJsZTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge1xuICAgIGF1dG9DYXBpdGFsaXplOiAnYXV0b2NhcGl0YWxpemUnLFxuICAgIGF1dG9Db21wbGV0ZTogJ2F1dG9jb21wbGV0ZScsXG4gICAgYXV0b0NvcnJlY3Q6ICdhdXRvY29ycmVjdCcsXG4gICAgYXV0b0ZvY3VzOiAnYXV0b2ZvY3VzJyxcbiAgICBhdXRvUGxheTogJ2F1dG9wbGF5JyxcbiAgICAvLyBgZW5jb2RpbmdgIGlzIGVxdWl2YWxlbnQgdG8gYGVuY3R5cGVgLCBJRTggbGFja3MgYW4gYGVuY3R5cGVgIHNldHRlci5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2RvbS1mcy1lbmNvZGluZ1xuICAgIGVuY1R5cGU6ICdlbmNvZGluZycsXG4gICAgaHJlZkxhbmc6ICdocmVmbGFuZycsXG4gICAgcmFkaW9Hcm91cDogJ3JhZGlvZ3JvdXAnLFxuICAgIHNwZWxsQ2hlY2s6ICdzcGVsbGNoZWNrJyxcbiAgICBzcmNEb2M6ICdzcmNkb2MnLFxuICAgIHNyY1NldDogJ3NyY3NldCdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFN0YXRlTWl4aW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RMaW5rID0gcmVxdWlyZShcIi4vUmVhY3RMaW5rXCIpO1xudmFyIFJlYWN0U3RhdGVTZXR0ZXJzID0gcmVxdWlyZShcIi4vUmVhY3RTdGF0ZVNldHRlcnNcIik7XG5cbi8qKlxuICogQSBzaW1wbGUgbWl4aW4gYXJvdW5kIFJlYWN0TGluay5mb3JTdGF0ZSgpLlxuICovXG52YXIgTGlua2VkU3RhdGVNaXhpbiA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIFJlYWN0TGluayB0aGF0J3MgbGlua2VkIHRvIHBhcnQgb2YgdGhpcyBjb21wb25lbnQncyBzdGF0ZS4gVGhlXG4gICAqIFJlYWN0TGluayB3aWxsIGhhdmUgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcy5zdGF0ZVtrZXldIGFuZCB3aWxsIGNhbGxcbiAgICogc2V0U3RhdGUoKSB3aGVuIGEgY2hhbmdlIGlzIHJlcXVlc3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdGF0ZSBrZXkgdG8gdXBkYXRlLiBOb3RlOiB5b3UgbWF5IHdhbnQgdG8gdXNlIGtleU9mKClcbiAgICogaWYgeW91J3JlIHVzaW5nIEdvb2dsZSBDbG9zdXJlIENvbXBpbGVyIGFkdmFuY2VkIG1vZGUuXG4gICAqIEByZXR1cm4ge1JlYWN0TGlua30gUmVhY3RMaW5rIGluc3RhbmNlIGxpbmtpbmcgdG8gdGhlIHN0YXRlLlxuICAgKi9cbiAgbGlua1N0YXRlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBSZWFjdExpbmsodGhpcy5zdGF0ZVtrZXldLCBSZWFjdFN0YXRlU2V0dGVycy5jcmVhdGVTdGF0ZUtleVNldHRlcih0aGlzLCBrZXkpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRTdGF0ZU1peGluOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBMaW5rZWRWYWx1ZVV0aWxzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZXNcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ2ltYWdlJzogdHJ1ZSxcbiAgJ2hpZGRlbic6IHRydWUsXG4gICdyYWRpbyc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKSB7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0UHJvcHMudmFsdWVMaW5rID09IG51bGwpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgdmFsdWVMaW5rLiBJZiB5b3Ugd2FudCB0byB1c2UgJyArICdjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgJyArICd0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiAnICsgJ0lmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvICcgKyAndXNlIGNoZWNrZWRMaW5rJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGUgY2hhbmdlIGV2ZW50IHRvIGhhbmRsZVxuICovXG5mdW5jdGlvbiBfaGFuZGxlTGlua2VkVmFsdWVDaGFuZ2UoZSkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB0aGlzLnByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGUudGFyZ2V0LnZhbHVlKTtcbn1cblxuLyoqXG4gICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZSBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICovXG5mdW5jdGlvbiBfaGFuZGxlTGlua2VkQ2hlY2tDaGFuZ2UoZSkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB0aGlzLnByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZS50YXJnZXQuY2hlY2tlZCk7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgTWl4aW46IHtcbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogUmVhY3RQcm9wVHlwZXMuZnVuY1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIHZhbHVlIHByb3Agb3IgbGluay5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IGNoZWNrZWQgc3RhdHVzIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSBjaGVja2VkIHByb3BcbiAgICogICAgICAgICAgICAgb3IgbGluay5cbiAgICovXG4gIGdldENoZWNrZWQ6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNoYW5nZSBjYWxsYmFjayBlaXRoZXIgZnJvbSBvbkNoYW5nZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gX2hhbmRsZUxpbmtlZFZhbHVlQ2hhbmdlO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIF9oYW5kbGVMaW5rZWRDaGVja0NoYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTG9jYWxFdmVudFRyYXBNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZShcIi4vYWNjdW11bGF0ZUludG9cIik7XG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKFwiLi9maW5kRE9NTm9kZVwiKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKFwiLi9mb3JFYWNoQWNjdW11bGF0ZWRcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG5mdW5jdGlvbiByZW1vdmUoZXZlbnQpIHtcbiAgZXZlbnQucmVtb3ZlKCk7XG59XG5cbnZhciBMb2NhbEV2ZW50VHJhcE1peGluID0ge1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUpIHtcbiAgICAhdGhpcy5pc01vdW50ZWQoKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG1vdW50ZWQgdG8gdHJhcCBldmVudHMnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXG4gICAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAhbm9kZSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdMb2NhbEV2ZW50VHJhcE1peGluLnRyYXBCdWJibGVkRXZlbnQoLi4uKTogUmVxdWlyZXMgbm9kZSB0byBiZSByZW5kZXJlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxpc3RlbmVyID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIG5vZGUpO1xuICAgIHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byh0aGlzLl9sb2NhbEV2ZW50TGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gIH0sXG5cbiAgLy8gdHJhcENhcHR1cmVkRXZlbnQgd291bGQgbG9vayBuZWFybHkgaWRlbnRpY2FsLiBXZSBkb24ndCBpbXBsZW1lbnQgdGhhdFxuICAvLyBtZXRob2QgYmVjYXVzZSBpdCBpc24ndCBjdXJyZW50bHkgbmVlZGVkLlxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZCh0aGlzLl9sb2NhbEV2ZW50TGlzdGVuZXJzLCByZW1vdmUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbEV2ZW50VHJhcE1peGluOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBPYmplY3QuYXNzaWduXG4gKi9cblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5hc3NpZ25cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gdGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tuZXh0SW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzb3JzIG5vciBwcm94aWVzLiBUaGVyZWZvcmUgdGhpc1xuICAgIC8vIGNvcHkgY2Fubm90IHRocm93LiBJZiB3ZSBldmVyIHN1cHBvcnRlZCB0aGlzIHRoZW4gd2UgbXVzdCBoYW5kbGVcbiAgICAvLyBleGNlcHRpb25zIGFuZCBzaWRlLWVmZmVjdHMuIFdlIGRvbid0IHN1cHBvcnQgc3ltYm9scyBzbyB0aGV5IHdvbid0XG4gICAgLy8gYmUgdHJhbnNmZXJyZWQuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFBvb2xlZENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoaW5zdGFuY2UuZGVzdHJ1Y3Rvcikge1xuICAgIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgfVxuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzIChvcHRpb25hbCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZml2ZUFyZ3VtZW50UG9vbGVyOiBmaXZlQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01DbGllbnQgPSByZXF1aXJlKFwiLi9SZWFjdERPTUNsaWVudFwiKTtcbnZhciBSZWFjdERPTVNlcnZlciA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NU2VydmVyXCIpO1xudmFyIFJlYWN0SXNvbW9ycGhpYyA9IHJlcXVpcmUoXCIuL1JlYWN0SXNvbW9ycGhpY1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG5cbnZhciBSZWFjdCA9IHt9O1xuXG5hc3NpZ24oUmVhY3QsIFJlYWN0SXNvbW9ycGhpYyk7XG5hc3NpZ24oUmVhY3QsIFJlYWN0RE9NQ2xpZW50KTtcbmFzc2lnbihSZWFjdCwgUmVhY3RET01TZXJ2ZXIpO1xuXG5SZWFjdC52ZXJzaW9uID0gJzAuMTQuMC1hbHBoYTMnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlTWFwXCIpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKFwiLi9maW5kRE9NTm9kZVwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIGRpZFdhcm5LZXkgPSAnX2dldERPTU5vZGVEaWRXYXJuJztcblxudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBjb21wb25lbnQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRET01Ob2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcodGhpcy5jb25zdHJ1Y3RvcltkaWRXYXJuS2V5XSwgJyVzLmdldERPTU5vZGUoLi4uKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICcgKyAnUmVhY3QuZmluZERPTU5vZGUoaW5zdGFuY2UpIGluc3RlYWQuJywgUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuZ2V0TmFtZSgpIHx8IHRoaXMudGFnTmFtZSB8fCAnVW5rbm93bicpIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuY29uc3RydWN0b3JbZGlkV2FybktleV0gPSB0cnVlO1xuICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5SZWdpc3RyeVwiKTtcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0gcmVxdWlyZShcIi4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpblwiKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKFwiLi9WaWV3cG9ydE1ldHJpY3NcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKFwiLi9pc0V2ZW50U3VwcG9ydGVkXCIpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGlzIHVzZWQgdG8gYXR0YWNoIHRvcC1sZXZlbCBldmVudCBsaXN0ZW5lcnMuIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBhc3NpZ24oe30sIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4sIHtcblxuICAvKipcbiAgICogSW5qZWN0YWJsZSBldmVudCBiYWNrZW5kXG4gICAqL1xuICBSZWFjdEV2ZW50TGlzdGVuZXI6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFJlYWN0RXZlbnRMaXN0ZW5lclxuICAgICAqL1xuICAgIGluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKFJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLnNldEhhbmRsZVRvcExldmVsKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5oYW5kbGVUb3BMZXZlbCk7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyID0gUmVhY3RFdmVudExpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCBhbnkgY3JlYXRlZCBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBUcnVlIGlmIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgaWYgKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuc2V0RW5hYmxlZChlbmFibGVkKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgY2FsbGJhY2tzIGFyZSBlbmFibGVkLlxuICAgKi9cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgJiYgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5pc0VuYWJsZWQoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIGxpc3RlbiBmb3IgYnViYmxlZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50IG9iamVjdC5cbiAgICpcbiAgICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICAgKiBtb3VudGluZyBgb25tb3VzZW1vdmVgIGV2ZW50cyBhdCBzb21lIG5vZGUgdGhhdCB3YXMgbm90IHRoZSBkb2N1bWVudFxuICAgKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICAgKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyBmb3IgYG9ubW91c2Vtb3ZlYCB3b24ndCBiZSBjYWxsZWQuIEhvd2V2ZXIsIGlmIHlvdVxuICAgKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICAgKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgdG8gdGhlIGRvY3VtZW50IG9iamVjdCBvbmx5LCBhdCBsZWFzdCBmb3IgdGhlc2VcbiAgICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gICAqXG4gICAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAgICogdGhleSBidWJibGUgdG8gZG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRlbnREb2N1bWVudEhhbmRsZSBEb2N1bWVudCB3aGljaCBvd25zIHRoZSBjb250YWluZXJcbiAgICovXG4gIGxpc3RlblRvOiBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgY29udGVudERvY3VtZW50SGFuZGxlKSB7XG4gICAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gICAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICAgIHZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wV2hlZWwpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wU2Nyb2xsKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyB8fCBkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wRm9jdXMsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wRm9jdXMsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEJsdXJdID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEZvY3VzXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVucyB0byB3aW5kb3cgc2Nyb2xsIGFuZCByZXNpemUgZXZlbnRzLiBXZSBjYWNoZSBzY3JvbGwgdmFsdWVzIHNvIHRoYXRcbiAgICogYXBwbGljYXRpb24gY29kZSBjYW4gYWNjZXNzIHRoZW0gd2l0aG91dCB0cmlnZ2VyaW5nIHJlZmxvd3MuXG4gICAqXG4gICAqIE5PVEU6IFNjcm9sbCBldmVudHMgZG8gbm90IGJ1YmJsZS5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvc2Nyb2xsLmh0bWxcbiAgICovXG4gIGVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUpIHtcbiAgICAgIHZhciByZWZyZXNoID0gVmlld3BvcnRNZXRyaWNzLnJlZnJlc2hTY3JvbGxWYWx1ZXM7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLm1vbml0b3JTY3JvbGxWYWx1ZShyZWZyZXNoKTtcbiAgICAgIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpbkh1Yi5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IEV2ZW50UGx1Z2luSHViLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIHB1dExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcixcblxuICBnZXRMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXIsXG5cbiAgZGVsZXRlTGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyLFxuXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwiLi9SZWFjdFwiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG5cbnZhciBSZWFjdFRyYW5zaXRpb25Hcm91cCA9IFJlYWN0LmNyZWF0ZUZhY3RvcnkocmVxdWlyZShcIi4vUmVhY3RUcmFuc2l0aW9uR3JvdXBcIikpO1xudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSBSZWFjdC5jcmVhdGVGYWN0b3J5KHJlcXVpcmUoXCIuL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGRcIikpO1xuXG52YXIgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRyYW5zaXRpb25OYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdHJhbnNpdGlvbkFwcGVhcjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdHJhbnNpdGlvbkVudGVyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uTGVhdmU6IFJlYWN0LlByb3BUeXBlcy5ib29sXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb25BcHBlYXI6IGZhbHNlLFxuICAgICAgdHJhbnNpdGlvbkVudGVyOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkxlYXZlOiB0cnVlXG4gICAgfTtcbiAgfSxcblxuICBfd3JhcENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdGhpcyBjaGlsZEZhY3Rvcnkgc28gdGhhdFxuICAgIC8vIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgY2FuIHJlY2VpdmUgdXBkYXRlcyB0byBuYW1lLCBlbnRlciwgYW5kXG4gICAgLy8gbGVhdmUgd2hpbGUgaXQgaXMgbGVhdmluZy5cbiAgICByZXR1cm4gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCh7XG4gICAgICBuYW1lOiB0aGlzLnByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgYXBwZWFyOiB0aGlzLnByb3BzLnRyYW5zaXRpb25BcHBlYXIsXG4gICAgICBlbnRlcjogdGhpcy5wcm9wcy50cmFuc2l0aW9uRW50ZXIsXG4gICAgICBsZWF2ZTogdGhpcy5wcm9wcy50cmFuc2l0aW9uTGVhdmVcbiAgICB9LCBjaGlsZCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0VHJhbnNpdGlvbkdyb3VwKGFzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBjaGlsZEZhY3Rvcnk6IHRoaXMuX3dyYXBDaGlsZCB9KSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIi4vUmVhY3RcIik7XG5cbnZhciBDU1NDb3JlID0gcmVxdWlyZShcIi4vQ1NTQ29yZVwiKTtcbnZhciBSZWFjdFRyYW5zaXRpb25FdmVudHMgPSByZXF1aXJlKFwiLi9SZWFjdFRyYW5zaXRpb25FdmVudHNcIik7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKFwiLi9vbmx5Q2hpbGRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8vIFdlIGRvbid0IHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00gdW50aWwgd2UgcmVjZWl2ZSBhbiBhbmltYXRpb25lbmQgb3Jcbi8vIHRyYW5zaXRpb25lbmQgZXZlbnQuIElmIHRoZSB1c2VyIHNjcmV3cyB1cCBhbmQgZm9yZ2V0cyB0byBhZGQgYW4gYW5pbWF0aW9uXG4vLyB0aGVpciBub2RlIHdpbGwgYmUgc3R1Y2sgaW4gdGhlIERPTSBmb3JldmVyLCBzbyB3ZSBkZXRlY3QgaWYgYW4gYW5pbWF0aW9uXG4vLyBkb2VzIG5vdCBzdGFydCBhbmQgaWYgaXQgZG9lc24ndCwgd2UganVzdCBjYWxsIHRoZSBlbmQgbGlzdGVuZXIgaW1tZWRpYXRlbHkuXG52YXIgVElDSyA9IDE3O1xudmFyIE5PX0VWRU5UX1RJTUVPVVQgPSA1MDAwO1xuXG52YXIgbm9FdmVudExpc3RlbmVyID0gbnVsbDtcblxuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgbm9FdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAndHJhbnNpdGlvbigpOiB0cmllZCB0byBwZXJmb3JtIGFuIGFuaW1hdGlvbiB3aXRob3V0ICcgKyAnYW4gYW5pbWF0aW9uZW5kIG9yIHRyYW5zaXRpb25lbmQgZXZlbnQgYWZ0ZXIgdGltZW91dCAoJyArICclc21zKS4gWW91IHNob3VsZCBlaXRoZXIgZGlzYWJsZSB0aGlzICcgKyAndHJhbnNpdGlvbiBpbiBKUyBvciBhZGQgYSBDU1MgYW5pbWF0aW9uL3RyYW5zaXRpb24uJywgTk9fRVZFTlRfVElNRU9VVCkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbnZhciBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQnLFxuXG4gIHRyYW5zaXRpb246IGZ1bmN0aW9uIChhbmltYXRpb25UeXBlLCBmaW5pc2hDYWxsYmFjaykge1xuICAgIHZhciBub2RlID0gUmVhY3QuZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMubmFtZSArICctJyArIGFuaW1hdGlvblR5cGU7XG4gICAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctYWN0aXZlJztcbiAgICB2YXIgbm9FdmVudFRpbWVvdXQgPSBudWxsO1xuXG4gICAgdmFyIGVuZExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChub0V2ZW50VGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIENTU0NvcmUucmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICAgIENTU0NvcmUucmVtb3ZlQ2xhc3Mobm9kZSwgYWN0aXZlQ2xhc3NOYW1lKTtcblxuICAgICAgUmVhY3RUcmFuc2l0aW9uRXZlbnRzLnJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kTGlzdGVuZXIpO1xuXG4gICAgICAvLyBVc3VhbGx5IHRoaXMgb3B0aW9uYWwgY2FsbGJhY2sgaXMgdXNlZCBmb3IgaW5mb3JtaW5nIGFuIG93bmVyIG9mXG4gICAgICAvLyBhIGxlYXZlIGFuaW1hdGlvbiBhbmQgdGVsbGluZyBpdCB0byByZW1vdmUgdGhlIGNoaWxkLlxuICAgICAgaWYgKGZpbmlzaENhbGxiYWNrKSB7XG4gICAgICAgIGZpbmlzaENhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFJlYWN0VHJhbnNpdGlvbkV2ZW50cy5hZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIGVuZExpc3RlbmVyKTtcblxuICAgIENTU0NvcmUuYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcblxuICAgIC8vIE5lZWQgdG8gZG8gdGhpcyB0byBhY3R1YWxseSB0cmlnZ2VyIGEgdHJhbnNpdGlvbi5cbiAgICB0aGlzLnF1ZXVlQ2xhc3MoYWN0aXZlQ2xhc3NOYW1lKTtcblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBub0V2ZW50VGltZW91dCA9IHNldFRpbWVvdXQobm9FdmVudExpc3RlbmVyLCBOT19FVkVOVF9USU1FT1VUKTtcbiAgICB9XG4gIH0sXG5cbiAgcXVldWVDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIHRoaXMuY2xhc3NOYW1lUXVldWUucHVzaChjbGFzc05hbWUpO1xuXG4gICAgaWYgKCF0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5mbHVzaENsYXNzTmFtZVF1ZXVlLCBUSUNLKTtcbiAgICB9XG4gIH0sXG5cbiAgZmx1c2hDbGFzc05hbWVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgICB0aGlzLmNsYXNzTmFtZVF1ZXVlLmZvckVhY2goQ1NTQ29yZS5hZGRDbGFzcy5iaW5kKENTU0NvcmUsIFJlYWN0LmZpbmRET01Ob2RlKHRoaXMpKSk7XG4gICAgfVxuICAgIHRoaXMuY2xhc3NOYW1lUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xhc3NOYW1lUXVldWUgPSBbXTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsQXBwZWFyOiBmdW5jdGlvbiAoZG9uZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmFwcGVhcikge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdhcHBlYXInLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsRW50ZXI6IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuZW50ZXIpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbignZW50ZXInLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsTGVhdmU6IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgaWYgKHRoaXMucHJvcHMubGVhdmUpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbignbGVhdmUnLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb25seUNoaWxkKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkUmVjb25jaWxlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKFwiLi9SZWFjdFJlY29uY2lsZXJcIik7XG5cbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKFwiLi9mbGF0dGVuQ2hpbGRyZW5cIik7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFwiKTtcblxuLyoqXG4gKiBSZWFjdENoaWxkUmVjb25jaWxlciBwcm92aWRlcyBoZWxwZXJzIGZvciBpbml0aWFsaXppbmcgb3IgdXBkYXRpbmcgYSBzZXQgb2ZcbiAqIGNoaWxkcmVuLiBJdHMgb3V0cHV0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGl0IG9udG8gUmVhY3RNdWx0aUNoaWxkIHdoaWNoXG4gKiBkb2VzIGRpZmZlZCByZW9yZGVyaW5nIGFuZCBpbnNlcnRpb24uXG4gKi9cbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzKTtcbiAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgIC8vIFRoZSByZW5kZXJlZCBjaGlsZHJlbiBtdXN0IGJlIHR1cm5lZCBpbnRvIGluc3RhbmNlcyBhcyB0aGV5J3JlXG4gICAgICAgIC8vIG1vdW50ZWQuXG4gICAgICAgIHZhciBjaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCwgbnVsbCk7XG4gICAgICAgIGNoaWxkcmVuW25hbWVdID0gY2hpbGRJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiBhbmQgcmV0dXJucyBhIG5ldyBzZXQgb2YgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGZvci4uaW4gd2UgY2FuIHppcCB0aGUgaXRlcmF0b3JzIGFuZCBjaGVjayBpZiBhbiBpdGVtIGhhc1xuICAgIC8vIG1vdmVkLlxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHF1aWNrbHkgYmFpbG91dCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkTm9kZXMpO1xuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbmFtZTtcbiAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBudWxsKTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xudmFyIFJlYWN0RnJhZ21lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEZyYWdtZW50XCIpO1xuXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL3RyYXZlcnNlQWxsQ2hpbGRyZW5cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50aHJlZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBib29rS2VlcGluZyA9IHRyYXZlcnNlQ29udGV4dDtcbiAgYm9va0tlZXBpbmcuZnVuYy5jYWxsKGJvb2tLZWVwaW5nLmNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmMuXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5mdW5jID0gbWFwRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCB0aHJlZUFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBib29rS2VlcGluZyA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIG1hcFJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcblxuICB2YXIga2V5VW5pcXVlID0gbWFwUmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoa2V5VW5pcXVlLCAnUmVhY3RDaGlsZHJlbi5tYXAoLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4nLCBuYW1lKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChrZXlVbmlxdWUpIHtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBib29rS2VlcGluZy5mdW5jLmNhbGwoYm9va0tlZXBpbmcuY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICAgIG1hcFJlc3VsdFtuYW1lXSA9IG1hcHBlZENoaWxkO1xuICB9XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBUT0RPOiBUaGlzIG1heSBsaWtlbHkgYnJlYWsgYW55IGNhbGxzIHRvIGBSZWFjdENoaWxkcmVuLm1hcGAgdGhhdCB3ZXJlXG4gKiBwcmV2aW91c2x5IHJlbHlpbmcgb24gdGhlIGZhY3QgdGhhdCB3ZSBndWFyZGVkIGFnYWluc3QgbnVsbCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gbWFwRnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IG1hcENvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciBtYXBSZXN1bHQgPSB7fTtcbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChtYXBSZXN1bHQsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG4gIHJldHVybiBSZWFjdEZyYWdtZW50LmNyZWF0ZShtYXBSZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKFwiLi9SZWFjdEVycm9yVXRpbHNcIik7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VNYXBcIik7XG52YXIgUmVhY3RMaWZlQ3ljbGUgPSByZXF1aXJlKFwiLi9SZWFjdExpZmVDeWNsZVwiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1wiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXCIpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZVF1ZXVlXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBNSVhJTlNfS0VZID0ga2V5T2YoeyBtaXhpbnM6IG51bGwgfSk7XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xudmFyIFNwZWNQb2xpY3kgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBvbmx5IG9uY2UgYnkgdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gb3IgbWl4aW4uXG4gICAqL1xuICBERUZJTkVfT05DRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgYnkgYm90aCB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBhbmQgbWl4aW5zLlxuICAgKiBTdWJzZXF1ZW50IGRlZmluaXRpb25zIHdpbGwgYmUgY2hhaW5lZC4gVGhlc2UgbWV0aG9kcyBtdXN0IHJldHVybiB2b2lkLlxuICAgKi9cbiAgREVGSU5FX01BTlk6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBvdmVycmlkaW5nIHRoZSBiYXNlIGNsYXNzLlxuICAgKi9cbiAgT1ZFUlJJREVfQkFTRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIHNpbWlsYXIgdG8gREVGSU5FX01BTlksIGV4Y2VwdCB3ZSBhc3N1bWUgdGhleSByZXR1cm5cbiAgICogb2JqZWN0cy4gV2UgdHJ5IHRvIG1lcmdlIHRoZSBrZXlzIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCB0aGUgbWl4ZWQgaW5cbiAgICogZnVuY3Rpb25zLiBJZiB0aGVyZSBpcyBhIGtleSBjb25mbGljdCB3ZSB0aHJvdy5cbiAgICovXG4gIERFRklORV9NQU5ZX01FUkdFRDogbnVsbFxufSk7XG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBuYXRpdmUgY29tcG9uZW50cy5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRVxuXG59O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAqL1xudmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICB9LFxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG5vdCBpbiBfX0RFVl9fXG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUocHJvdG8sIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5PVkVSUklERV9CQVNFKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArICdgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyAnICsgJ2RvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICsgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSAnICsgJ3RvIGEgbWl4aW4uJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICsgJ3VzZSBhIGNvbXBvbmVudCBjbGFzcyBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgISFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICsgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUocHJvdG8sIG5hbWUpO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgaWYgKCFwcm90by5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXBbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgIShpc1JlYWN0Q2xhc3NNZXRob2QgJiYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgJyArICd3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICBpZiAoIXN0YXRpY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gKG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTKTtcbiAgICAhIWlzUmVzZXJ2ZWQgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkICcgKyAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgKyAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICsgJ2NvbnN0cnVjdG9yLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IChuYW1lIGluIENvbnN0cnVjdG9yKTtcbiAgICAhIWlzSW5oZXJpdGVkID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICsgJ2R1ZSB0byBhIG1peGluLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogJyArICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCAnICsgJ21heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byAnICsgJ2dldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgJyArICd3aXRoIGNsYXNoaW5nIGtleXMuJywga2V5KSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb25lO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIGMgPSB7fTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBuby11bmRlZiAqL1xuICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICBmb3IgKHZhciBhdXRvQmluZEtleSBpbiBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgaWYgKGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXAuaGFzT3duUHJvcGVydHkoYXV0b0JpbmRLZXkpKSB7XG4gICAgICB2YXIgbWV0aG9kID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcFthdXRvQmluZEtleV07XG4gICAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgUmVhY3RFcnJvclV0aWxzLmd1YXJkKG1ldGhvZCwgY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lICsgJy4nICsgYXV0b0JpbmRLZXkpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHR5cGVEZXByZWNhdGlvbkRlc2NyaXB0b3IgPSB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmRpc3BsYXlOYW1lIHx8IHRoaXMubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJyVzLnR5cGUgaXMgZGVwcmVjYXRlZC4gVXNlICVzIGRpcmVjdGx5IHRvIGFjY2VzcyB0aGUgY2xhc3MuJywgZGlzcGxheU5hbWUsIGRpc3BsYXlOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICB2YWx1ZTogdGhpc1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAqL1xudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcblxuICAvKipcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZSAhPT0gUmVhY3RMaWZlQ3ljbGUuY3VycmVudGx5TW91bnRpbmdJbnN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc2V0UHJvcHM6IGZ1bmN0aW9uIChwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0UHJvcHModGhpcywgcGFydGlhbFByb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYWxsIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBwdWJsaWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHJlcGxhY2VQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzLCBjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VQcm9wcyh0aGlzLCBuZXdQcm9wcyk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xuICovXG52YXIgUmVhY3RDbGFzcyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCkge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBpcyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJyAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgaG9va1xuICAgIENvbnN0cnVjdG9yLnR5cGUgPSBDb25zdHJ1Y3RvcjtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCAndHlwZScsIHR5cGVEZXByZWNhdGlvbkRlc2NyaXB0b3IpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzcztcblxuLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5IChlczUtc2hpbS9zaGFtIHRvbykiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVRdWV1ZVwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhICcgKyAnZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhwYXJ0aWFsU3RhdGUgIT0gbnVsbCwgJ3NldFN0YXRlKC4uLik6IFlvdSBwYXNzZWQgYW4gdW5kZWZpbmVkIG9yIG51bGwgc3RhdGUgb2JqZWN0OyAnICsgJ2luc3RlYWQsIHVzZSBmb3JjZVVwZGF0ZSgpLicpIDogdW5kZWZpbmVkO1xuICB9XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGdldERPTU5vZGU6IFsnZ2V0RE9NTm9kZScsICdVc2UgUmVhY3QuZmluZERPTU5vZGUoY29tcG9uZW50KSBpbnN0ZWFkLiddLFxuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlUHJvcHM6IFsncmVwbGFjZVByb3BzJywgJ0luc3RlYWQsIGNhbGwgUmVhY3QucmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ10sXG4gICAgc2V0UHJvcHM6IFsnc2V0UHJvcHMnLCAnSW5zdGVhZCwgY2FsbCBSZWFjdC5yZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG4vLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHkgKGVzNS1zaGltL3NoYW0gdG9vKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vUmVhY3RET01JRE9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQsXG5cbiAgLyoqXG4gICAqIElmIGEgcGFydGljdWxhciBlbnZpcm9ubWVudCByZXF1aXJlcyB0aGF0IHNvbWUgcmVzb3VyY2VzIGJlIGNsZWFuZWQgdXAsXG4gICAqIHNwZWNpZnkgdGhpcyBpbiB0aGUgaW5qZWN0ZWQgTWl4aW4uIEluIHRoZSBET00sIHdlIHdvdWxkIGxpa2VseSB3YW50IHRvXG4gICAqIHB1cmdlIGFueSBjYWNoZWQgbm9kZSBJRCBsb29rdXBzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBmdW5jdGlvbiAocm9vdE5vZGVJRCkge1xuICAgIFJlYWN0TW91bnQucHVyZ2VJRChyb290Tm9kZUlEKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgaW5qZWN0ZWQgPSBmYWxzZTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSB7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY2xlYW51cCBob29rLiAoc2VydmVyIHZzLlxuICAgKiBicm93c2VyIGV0YykuIEV4YW1wbGU6IEEgYnJvd3NlciBzeXN0ZW0gY2FjaGVzIERPTSBub2RlcyBiYXNlZCBvbiBjb21wb25lbnRcbiAgICogSUQgYW5kIG11c3QgcmVtb3ZlIHRoYXQgY2FjaGUgZW50cnkgd2hlbiB0aGlzIGluc3RhbmNlIGlzIHVubW91bnRlZC5cbiAgICovXG4gIHVubW91bnRJREZyb21FbnZpcm9ubWVudDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBwcm9jZXNzaW5nIGEgcXVldWUgb2YgY2hpbGQgdXBkYXRlcy4gV2lsbFxuICAgKiBsYXRlciBtb3ZlIGludG8gTXVsdGlDaGlsZENvbXBvbmVudHMuXG4gICAqL1xuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVudmlyb25tZW50OiBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICEhaW5qZWN0ZWQgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IGluamVjdEVudmlyb25tZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQgPSBlbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2hhbGxvd0NvbXBhcmUgPSByZXF1aXJlKFwiLi9zaGFsbG93Q29tcGFyZVwiKTtcblxuLyoqXG4gKiBJZiB5b3VyIFJlYWN0IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbiBpcyBcInB1cmVcIiwgZS5nLiBpdCB3aWxsIHJlbmRlciB0aGVcbiAqIHNhbWUgcmVzdWx0IGdpdmVuIHRoZSBzYW1lIHByb3BzIGFuZCBzdGF0ZSwgcHJvdmlkZSB0aGlzIE1peGluIGZvciBhXG4gKiBjb25zaWRlcmFibGUgcGVyZm9ybWFuY2UgYm9vc3QuXG4gKlxuICogTW9zdCBSZWFjdCBjb21wb25lbnRzIGhhdmUgcHVyZSByZW5kZXIgZnVuY3Rpb25zLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICB2YXIgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluID1cbiAqICAgICByZXF1aXJlKCdSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4nKTtcbiAqICAgUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIG1peGluczogW1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbl0sXG4gKlxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfT5mb288L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBOb3RlOiBUaGlzIG9ubHkgY2hlY2tzIHNoYWxsb3cgZXF1YWxpdHkgZm9yIHByb3BzIGFuZCBzdGF0ZS4gSWYgdGhlc2UgY29udGFpblxuICogY29tcGxleCBkYXRhIHN0cnVjdHVyZXMgdGhpcyBtaXhpbiBtYXkgaGF2ZSBmYWxzZS1uZWdhdGl2ZXMgZm9yIGRlZXBlclxuICogZGlmZmVyZW5jZXMuIE9ubHkgbWl4aW4gdG8gY29tcG9uZW50cyB3aGljaCBoYXZlIHNpbXBsZSBwcm9wcyBhbmQgc3RhdGUsIG9yXG4gKiB1c2UgYGZvcmNlVXBkYXRlKClgIHdoZW4geW91IGtub3cgZGVlcCBkYXRhIHN0cnVjdHVyZXMgaGF2ZSBjaGFuZ2VkLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluID0ge1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiBzaGFsbG93Q29tcGFyZSh0aGlzLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50XCIpO1xudmFyIFJlYWN0Q29udGV4dCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29udGV4dFwiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3JcIik7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VNYXBcIik7XG52YXIgUmVhY3RMaWZlQ3ljbGUgPSByZXF1aXJlKFwiLi9SZWFjdExpZmVDeWNsZVwiKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0TmF0aXZlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1wiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXCIpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoXCIuL1JlYWN0UmVjb25jaWxlclwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZShcIi4vZW1wdHlPYmplY3RcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpIHtcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5faXNUb3BMZXZlbCA9IGZhbHNlO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyh0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChjb250ZXh0KTtcblxuICAgIHZhciBDb21wb25lbnQgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudC5nZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGluc3QgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0KTtcblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGluc3QucmVuZGVyICE9IG51bGwsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYCBpbiB5b3VyICcgKyAnY29tcG9uZW50IG9yIHlvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgdHJpZWQgdG8gcmVuZGVyIGFuIGVsZW1lbnQgJyArICd3aG9zZSB0eXBlIGlzIGEgZnVuY3Rpb24gdGhhdCBpc25cXCd0IGEgUmVhY3QgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhlc2Ugc2hvdWxkIGJlIHNldCB1cCBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgIC8vIHNpbXBsZXIgY2xhc3MgYWJzdHJhY3Rpb25zLCB3ZSBzZXQgdGhlbSB1cCBhZnRlciB0aGUgZmFjdC5cbiAgICBpbnN0LnByb3BzID0gcHVibGljUHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnJlZnMgPSBlbXB0eU9iamVjdDtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcblxuICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIGJhY2sgdG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cbiAgICAgIC8vIGNhdGNoIHRoZW0gaGVyZSwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSwgaW5zdGVhZC5cbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICB2YXIgcHJldmlvdXNseU1vdW50aW5nID0gUmVhY3RMaWZlQ3ljbGUuY3VycmVudGx5TW91bnRpbmdJbnN0YW5jZTtcbiAgICBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlNb3VudGluZ0luc3RhbmNlID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgaWYgKGluc3QuY29tcG9uZW50V2lsbE1vdW50KSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0TGlmZUN5Y2xlLmN1cnJlbnRseU1vdW50aW5nSW5zdGFuY2UgPSBwcmV2aW91c2x5TW91bnRpbmc7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSAvLyBUaGUgd3JhcHBpbmcgdHlwZVxuICAgICk7XG5cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCByb290SUQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICB2YXIgcHJldmlvdXNseVVubW91bnRpbmcgPSBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlVbm1vdW50aW5nSW5zdGFuY2U7XG4gICAgICBSZWFjdExpZmVDeWNsZS5jdXJyZW50bHlVbm1vdW50aW5nSW5zdGFuY2UgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RMaWZlQ3ljbGUuY3VycmVudGx5VW5tb3VudGluZ0luc3RhbmNlID0gcHJldmlvdXNseVVubW91bnRpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcblxuICAgIC8vIFJlc2V0IHBlbmRpbmcgZmllbGRzXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlIGEgcGFydGlhbCB1cGRhdGUgdG8gdGhlIHByb3BzLiBPbmx5IHVzZWQgZm9yIGludGVybmFsIHRlc3RpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0UHJvcHNJbnRlcm5hbDogZnVuY3Rpb24gKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVvcHRpbWl6ZWQgcGF0aC4gV2Ugb3B0aW1pemUgZm9yIGFsd2F5cyBoYXZpbmcgYW4gZWxlbWVudC5cbiAgICAvLyBUaGlzIGNyZWF0ZXMgYW4gZXh0cmEgaW50ZXJuYWwgZWxlbWVudC5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuX3BlbmRpbmdFbGVtZW50IHx8IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcywgcGFydGlhbFByb3BzKSk7XG4gICAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUodGhpcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2BcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYXNrQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IG51bGw7XG4gICAgdmFyIENvbXBvbmVudCA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudCk7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG4gICAgbWFza2VkQ29udGV4dCA9IHt9O1xuICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYCwgYW5kIGFzc2VydHMgdGhhdCB0aGV5IGFyZSB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHRoaXMuX21hc2tDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gUmVhY3ROYXRpdmVDb21wb25lbnQuZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChDb21wb25lbnQuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbnRleHRcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIChjdXJyZW50Q29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0ICYmIGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgaW5zdC5jb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoaW5zdC5jb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAhKG5hbWUgaW4gaW5zdC5jb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogUHJvY2Vzc2VzIHByb3BzIGJ5IHNldHRpbmcgZGVmYXVsdCB2YWx1ZXMgZm9yIHVuc3BlY2lmaWVkIHByb3BzIGFuZFxuICAgKiBhc3NlcnRpbmcgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkLiBEb2VzIG5vdCBtdXRhdGUgaXRzIGFyZ3VtZW50OyByZXR1cm5zXG4gICAqIGEgbmV3IHByb3BzIG9iamVjdCB3aXRoIGRlZmF1bHRzIG1lcmdlZCBpbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzUHJvcHM6IGZ1bmN0aW9uIChuZXdQcm9wcykge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gUmVhY3ROYXRpdmVDb21wb25lbnQuZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChDb21wb25lbnQucHJvcFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5wcm9wVHlwZXMsIG5ld1Byb3BzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3UHJvcHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BUeXBlcyBNYXAgb2YgcHJvcCBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrUHJvcFR5cGVzOiBmdW5jdGlvbiAocHJvcFR5cGVzLCBwcm9wcywgbG9jYXRpb24pIHtcbiAgICAvLyBUT0RPOiBTdG9wIHZhbGlkYXRpbmcgcHJvcCB0eXBlcyBoZXJlIGFuZCBvbmx5IHVzZSB0aGUgZWxlbWVudFxuICAgIC8vIHZhbGlkYXRpb24uXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSB0aGlzLmdldE5hbWUoKTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgISh0eXBlb2YgcHJvcFR5cGVzW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgJyArICdmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIC8vIFdlIG1heSB3YW50IHRvIGV4dGVuZCB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIGVycm9ycyBpblxuICAgICAgICAgIC8vIFJlYWN0LnJlbmRlciBjYWxscywgc28gSSdtIGFic3RyYWN0aW5nIGl0IGF3YXkgaW50b1xuICAgICAgICAgIC8vIGEgZnVuY3Rpb24gdG8gbWluaW1pemUgcmVmYWN0b3JpbmcgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSh0aGlzKTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKSB7XG4gICAgICAgICAgICAvLyBQcmVmYWNlIGdpdmVzIHVzIHNvbWV0aGluZyB0byBibGFja2xpc3QgaW4gd2FybmluZyBtb2R1bGVcbiAgICAgICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29udGV4dCBUeXBlczogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCB8fCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIFJlYWN0RWxlbWVudFZhbGlkYXRvci5jaGVja0FuZFdhcm5Gb3JNdXRhdGVkUHJvcHModGhpcy5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gdXBkYXRlIHRvIGEgbW91bnRlZCBjb21wb25lbnQuIFRoZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGFuZFxuICAgKiBzaG91bGRDb21wb25lbnRVcGRhdGUgbWV0aG9kcyBhcmUgY2FsbGVkLCB0aGVuIChhc3N1bWluZyB0aGUgdXBkYXRlIGlzbid0XG4gICAqIHNraXBwZWQpIHRoZSByZW1haW5pbmcgdXBkYXRlIGxpZmVjeWNsZSBtZXRob2RzIGFyZSBjYWxsZWQgYW5kIHRoZSBET01cbiAgICogcmVwcmVzZW50YXRpb24gaXMgdXBkYXRlZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2UGFyZW50RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dFBhcmVudEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZQYXJlbnRFbGVtZW50LCBuZXh0UGFyZW50RWxlbWVudCwgcHJldlVubWFza2VkQ29udGV4dCwgbmV4dFVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgbmV4dENvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgdmFyIG5leHRQcm9wcyA9IGluc3QucHJvcHM7XG5cbiAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGEgcHJvcHMgdXBkYXRlIHZlcnN1cyBhIHNpbXBsZSBzdGF0ZSB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgIT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICBuZXh0Q29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgICAgbmV4dFByb3BzID0gdGhpcy5fcHJvY2Vzc1Byb3BzKG5leHRQYXJlbnRFbGVtZW50LnByb3BzKTtcblxuICAgICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxuXG4gICAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgfHwgIWluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlIHx8IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcodHlwZW9mIHNob3VsZFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IGFzc2lnbih7fSwgcmVwbGFjZSA/IHF1ZXVlWzBdIDogaW5zdC5zdGF0ZSk7XG4gICAgZm9yICh2YXIgaSA9IHJlcGxhY2UgPyAxIDogMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHF1ZXVlW2ldO1xuICAgICAgYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBwcmV2UHJvcHMgPSBpbnN0LnByb3BzO1xuICAgIHZhciBwcmV2U3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIHZhciBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy5fY29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG5cbiAgICB0aGlzLl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCh0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXNlIHR3byBJRHMgYXJlIGFjdHVhbGx5IHRoZSBzYW1lISBCdXQgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGF0LlxuICAgICAgdmFyIHRoaXNJRCA9IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICB2YXIgcHJldkNvbXBvbmVudElEID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9yb290Tm9kZUlEO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHRoaXNJRCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQocHJldkNvbXBvbmVudElELCBuZXh0TWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVkQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZpb3VzQ29udGV4dCA9IFJlYWN0Q29udGV4dC5jdXJyZW50O1xuICAgIFJlYWN0Q29udGV4dC5jdXJyZW50ID0gdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dCh0aGlzLl9jdXJyZW50RWxlbWVudC5fY29udGV4dCk7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q29udGV4dC5jdXJyZW50ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgICEoXG4gICAgLy8gVE9ETzogQW4gYGlzVmFsaWROb2RlYCBmdW5jdGlvbiB3b3VsZCBwcm9iYWJseSBiZSBtb3JlIGFwcHJvcHJpYXRlXG4gICAgKHJlbmRlcmVkQ29tcG9uZW50ID09PSBudWxsIHx8IHJlbmRlcmVkQ29tcG9uZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnJXMucmVuZGVyKCk6IEEgdmFsaWQgUmVhY3RDb21wb25lbnQgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExhemlseSBhbGxvY2F0ZXMgdGhlIHJlZnMgb2JqZWN0IGFuZCBzdG9yZXMgYGNvbXBvbmVudGAgYXMgYHJlZmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgUmVmZXJlbmNlIG5hbWUuXG4gICAqIEBwYXJhbSB7Y29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHN0b3JlIGFzIGByZWZgLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF0dGFjaFJlZjogZnVuY3Rpb24gKHJlZiwgY29tcG9uZW50KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSBSZWFjdC5yZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlO1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4sICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIHtcbiAgbW91bnRDb21wb25lbnQ6ICdtb3VudENvbXBvbmVudCcsXG4gIHVwZGF0ZUNvbXBvbmVudDogJ3VwZGF0ZUNvbXBvbmVudCcsXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50J1xufSk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbnRleHRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoXCIuL2VtcHR5T2JqZWN0XCIpO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogVGhlIGNvbnRleHQgaXMgYXV0b21hdGljYWxseSBwYXNzZWQgZG93biB0aGUgY29tcG9uZW50IG93bmVyc2hpcCBoaWVyYXJjaHlcbiAqIGFuZCBpcyBhY2Nlc3NpYmxlIHZpYSBgdGhpcy5jb250ZXh0YCBvbiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudHMuXG4gKi9cbnZhciBSZWFjdENvbnRleHQgPSB7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbiAgY3VycmVudDogZW1wdHlPYmplY3RcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbnRleHQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q3VycmVudE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50VmFsaWRhdG9yXCIpO1xuXG52YXIgbWFwT2JqZWN0ID0gcmVxdWlyZShcIi4vbWFwT2JqZWN0XCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgKGUuZy4gYGRpdmApLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NRmFjdG9yeSh0YWcpIHtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3RvcnkodGFnKTtcbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkodGFnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NID0gbWFwT2JqZWN0KHtcbiAgYTogJ2EnLFxuICBhYmJyOiAnYWJicicsXG4gIGFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgYXJlYTogJ2FyZWEnLFxuICBhcnRpY2xlOiAnYXJ0aWNsZScsXG4gIGFzaWRlOiAnYXNpZGUnLFxuICBhdWRpbzogJ2F1ZGlvJyxcbiAgYjogJ2InLFxuICBiYXNlOiAnYmFzZScsXG4gIGJkaTogJ2JkaScsXG4gIGJkbzogJ2JkbycsXG4gIGJpZzogJ2JpZycsXG4gIGJsb2NrcXVvdGU6ICdibG9ja3F1b3RlJyxcbiAgYm9keTogJ2JvZHknLFxuICBicjogJ2JyJyxcbiAgYnV0dG9uOiAnYnV0dG9uJyxcbiAgY2FudmFzOiAnY2FudmFzJyxcbiAgY2FwdGlvbjogJ2NhcHRpb24nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNvZGU6ICdjb2RlJyxcbiAgY29sOiAnY29sJyxcbiAgY29sZ3JvdXA6ICdjb2xncm91cCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0YWxpc3Q6ICdkYXRhbGlzdCcsXG4gIGRkOiAnZGQnLFxuICBkZWw6ICdkZWwnLFxuICBkZXRhaWxzOiAnZGV0YWlscycsXG4gIGRmbjogJ2RmbicsXG4gIGRpYWxvZzogJ2RpYWxvZycsXG4gIGRpdjogJ2RpdicsXG4gIGRsOiAnZGwnLFxuICBkdDogJ2R0JyxcbiAgZW06ICdlbScsXG4gIGVtYmVkOiAnZW1iZWQnLFxuICBmaWVsZHNldDogJ2ZpZWxkc2V0JyxcbiAgZmlnY2FwdGlvbjogJ2ZpZ2NhcHRpb24nLFxuICBmaWd1cmU6ICdmaWd1cmUnLFxuICBmb290ZXI6ICdmb290ZXInLFxuICBmb3JtOiAnZm9ybScsXG4gIGgxOiAnaDEnLFxuICBoMjogJ2gyJyxcbiAgaDM6ICdoMycsXG4gIGg0OiAnaDQnLFxuICBoNTogJ2g1JyxcbiAgaDY6ICdoNicsXG4gIGhlYWQ6ICdoZWFkJyxcbiAgaGVhZGVyOiAnaGVhZGVyJyxcbiAgaGdyb3VwOiAnaGdyb3VwJyxcbiAgaHI6ICdocicsXG4gIGh0bWw6ICdodG1sJyxcbiAgaTogJ2knLFxuICBpZnJhbWU6ICdpZnJhbWUnLFxuICBpbWc6ICdpbWcnLFxuICBpbnB1dDogJ2lucHV0JyxcbiAgaW5zOiAnaW5zJyxcbiAga2JkOiAna2JkJyxcbiAga2V5Z2VuOiAna2V5Z2VuJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxlZ2VuZDogJ2xlZ2VuZCcsXG4gIGxpOiAnbGknLFxuICBsaW5rOiAnbGluaycsXG4gIG1haW46ICdtYWluJyxcbiAgbWFwOiAnbWFwJyxcbiAgbWFyazogJ21hcmsnLFxuICBtZW51OiAnbWVudScsXG4gIG1lbnVpdGVtOiAnbWVudWl0ZW0nLFxuICBtZXRhOiAnbWV0YScsXG4gIG1ldGVyOiAnbWV0ZXInLFxuICBuYXY6ICduYXYnLFxuICBub3NjcmlwdDogJ25vc2NyaXB0JyxcbiAgb2JqZWN0OiAnb2JqZWN0JyxcbiAgb2w6ICdvbCcsXG4gIG9wdGdyb3VwOiAnb3B0Z3JvdXAnLFxuICBvcHRpb246ICdvcHRpb24nLFxuICBvdXRwdXQ6ICdvdXRwdXQnLFxuICBwOiAncCcsXG4gIHBhcmFtOiAncGFyYW0nLFxuICBwaWN0dXJlOiAncGljdHVyZScsXG4gIHByZTogJ3ByZScsXG4gIHByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICBxOiAncScsXG4gIHJwOiAncnAnLFxuICBydDogJ3J0JyxcbiAgcnVieTogJ3J1YnknLFxuICBzOiAncycsXG4gIHNhbXA6ICdzYW1wJyxcbiAgc2NyaXB0OiAnc2NyaXB0JyxcbiAgc2VjdGlvbjogJ3NlY3Rpb24nLFxuICBzZWxlY3Q6ICdzZWxlY3QnLFxuICBzbWFsbDogJ3NtYWxsJyxcbiAgc291cmNlOiAnc291cmNlJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzdHJvbmc6ICdzdHJvbmcnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3ViOiAnc3ViJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICBzdXA6ICdzdXAnLFxuICB0YWJsZTogJ3RhYmxlJyxcbiAgdGJvZHk6ICd0Ym9keScsXG4gIHRkOiAndGQnLFxuICB0ZXh0YXJlYTogJ3RleHRhcmVhJyxcbiAgdGZvb3Q6ICd0Zm9vdCcsXG4gIHRoOiAndGgnLFxuICB0aGVhZDogJ3RoZWFkJyxcbiAgdGltZTogJ3RpbWUnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHI6ICd0cicsXG4gIHRyYWNrOiAndHJhY2snLFxuICB1OiAndScsXG4gIHVsOiAndWwnLFxuICAndmFyJzogJ3ZhcicsXG4gIHZpZGVvOiAndmlkZW8nLFxuICB3YnI6ICd3YnInLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6ICdjaXJjbGUnLFxuICBjbGlwUGF0aDogJ2NsaXBQYXRoJyxcbiAgZGVmczogJ2RlZnMnLFxuICBlbGxpcHNlOiAnZWxsaXBzZScsXG4gIGc6ICdnJyxcbiAgbGluZTogJ2xpbmUnLFxuICBsaW5lYXJHcmFkaWVudDogJ2xpbmVhckdyYWRpZW50JyxcbiAgbWFzazogJ21hc2snLFxuICBwYXRoOiAncGF0aCcsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcG9seWdvbjogJ3BvbHlnb24nLFxuICBwb2x5bGluZTogJ3BvbHlsaW5lJyxcbiAgcmFkaWFsR3JhZGllbnQ6ICdyYWRpYWxHcmFkaWVudCcsXG4gIHJlY3Q6ICdyZWN0JyxcbiAgc3RvcDogJ3N0b3AnLFxuICBzdmc6ICdzdmcnLFxuICB0ZXh0OiAndGV4dCcsXG4gIHRzcGFuOiAndHNwYW4nXG5cbn0sIGNyZWF0ZURPTUZhY3RvcnkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUJ1dHRvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEF1dG9Gb2N1c01peGluID0gcmVxdWlyZShcIi4vQXV0b0ZvY3VzTWl4aW5cIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG5cbnZhciBidXR0b24gPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSgnYnV0dG9uJyk7XG5cbnZhciBtb3VzZUxpc3RlbmVyTmFtZXMgPSBrZXlNaXJyb3Ioe1xuICBvbkNsaWNrOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrOiB0cnVlLFxuICBvbk1vdXNlRG93bjogdHJ1ZSxcbiAgb25Nb3VzZU1vdmU6IHRydWUsXG4gIG9uTW91c2VVcDogdHJ1ZSxcbiAgb25DbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxidXR0b24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NQnV0dG9uID0gUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01CdXR0b24nLFxuICB0YWdOYW1lOiAnQlVUVE9OJyxcblxuICBtaXhpbnM6IFtBdXRvRm9jdXNNaXhpbiwgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5dLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgLy8gQ29weSB0aGUgcHJvcHM7IGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzIGlmIHdlJ3JlIGRpc2FibGVkXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiYgKCF0aGlzLnByb3BzLmRpc2FibGVkIHx8ICFtb3VzZUxpc3RlbmVyTmFtZXNba2V5XSkpIHtcbiAgICAgICAgcHJvcHNba2V5XSA9IHRoaXMucHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnV0dG9uKHByb3BzLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01DbGllbnRcbiAqL1xuXG4vKiBnbG9iYWxzIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RET01UZXh0Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0RGVmYXVsdEluamVjdGlvblwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKFwiLi9SZWFjdFJlY29uY2lsZXJcIik7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoXCIuL2ZpbmRET01Ob2RlXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciByZW5kZXIgPSBSZWFjdFBlcmYubWVhc3VyZSgnUmVhY3QnLCAncmVuZGVyJywgUmVhY3RNb3VudC5yZW5kZXIpO1xuXG52YXIgUmVhY3QgPSB7XG4gIGNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudDogUmVhY3RNb3VudC5jb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnQsXG4gIGNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudEJ5SUQ6IFJlYWN0TW91bnQuY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50QnlJRCxcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuICByZW5kZXI6IHJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlXG59O1xuXG4vLyBJbmplY3QgdGhlIHJ1bnRpbWUgaW50byBhIGRldnRvb2xzIGdsb2JhbCBob29rIHJlZ2FyZGxlc3Mgb2YgYnJvd3Nlci5cbi8vIEFsbG93cyBmb3IgZGVidWdnaW5nIHdoZW4gdGhlIGhvb2sgaXMgaW5qZWN0ZWQgb24gdGhlIHBhZ2UuXG5pZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCh7XG4gICAgQ3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgICBJbnN0YW5jZUhhbmRsZXM6IFJlYWN0SW5zdGFuY2VIYW5kbGVzLFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlcixcbiAgICBUZXh0Q29tcG9uZW50OiBSZWFjdERPTVRleHRDb21wb25lbnRcbiAgfSk7XG59XG5cbmlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUsIGxvb2sgZm9yIHRoZSBkZXZ0b29scyBtYXJrZXIgYW5kIHByb3ZpZGUgYSBkb3dubG9hZFxuICAgIC8vIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xKSB7XG4gICAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tYmF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcbiAgICB2YXIgaWVDb21wYXRpYmlsaXR5TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4O1xuXG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgIC8vIHNoaW1zXG4gICAgQXJyYXkuaXNBcnJheSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIEFycmF5LnByb3RvdHlwZS5tYXAsIERhdGUubm93LCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgT2JqZWN0LmtleXMsIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsIFN0cmluZy5wcm90b3R5cGUudHJpbSxcblxuICAgIC8vIHNoYW1zXG4gICAgT2JqZWN0LmNyZWF0ZSwgT2JqZWN0LmZyZWV6ZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdPbmUgb3IgbW9yZSBFUzUgc2hpbS9zaGFtcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4vKiBnbG9iYWwgaGFzT3duUHJvcGVydHk6dHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZShcIi4vUmVhY3RNdWx0aUNoaWxkXCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZShcIi4vaXNFdmVudFN1cHBvcnRlZFwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuL3NoYWxsb3dFcXVhbFwiKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKFwiLi92YWxpZGF0ZURPTU5lc3RpbmdcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBkZWxldGVMaXN0ZW5lciA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5kZWxldGVMaXN0ZW5lcjtcbnZhciBsaXN0ZW5UbyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxudmFyIENPTlRFTlRfVFlQRVMgPSB7ICdzdHJpbmcnOiB0cnVlLCAnbnVtYmVyJzogdHJ1ZSB9O1xuXG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgSlNPTi5zdHJpbmdpZnkoc3R5bGUxKSwgSlNPTi5zdHJpbmdpZnkoc3R5bGUyKSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogT3B0aW9uYWxseSBpbmplY3RhYmxlIG9wZXJhdGlvbnMgZm9yIG11dGF0aW5nIHRoZSBET01cbiAqL1xudmFyIEJhY2tlbmRJRE9wZXJhdGlvbnMgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5vdCBoYXZlIGBjaGlsZHJlbmAgb3IgJyArICd1c2UgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nLCBjb21wb25lbnQuX3RhZykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmICdfX2h0bWwnIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCAnICsgJ2ZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHByb3BzLmlubmVySFRNTCA9PSBudWxsLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdW5kZWZpbmVkO1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKCFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCAnICsgJ25vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gJyArICd1c2luZyBKU1guJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIHZhciBkb2MgPSBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFID8gY29udGFpbmVyLm93bmVyRG9jdW1lbnQgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbiAgfVxuICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHB1dExpc3RlbmVyLCB7XG4gICAgaWQ6IGlkLFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucHV0TGlzdGVuZXIobGlzdGVuZXJUb1B1dC5pZCwgbGlzdGVuZXJUb1B1dC5yZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lclRvUHV0Lmxpc3RlbmVyKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsIGNhc2VkIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxuICAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxufTtcblxudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICAnbGlzdGluZyc6IHRydWUsXG4gICdwcmUnOiB0cnVlLFxuICAndGV4dGFyZWEnOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBhc3NpZ24oe1xuICAnbWVudWl0ZW0nOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxuLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xudmFyIGhhc093blByb3BlcnR5ID0gKHt9KS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCwgaW5zdCkge1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIC8vIFBhc3MgZG93biBvdXIgdGFnIG5hbWUgdG8gY2hpbGQgY29tcG9uZW50cyBmb3IgdmFsaWRhdGlvbiBwdXJwb3Nlc1xuICAgIGNvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICAgIHZhciBpbmZvID0gY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV07XG4gICAgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhpbmZvLCBpbnN0Ll90YWcsIGluc3QpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KHRhZykge1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl90YWcgPSB0YWc7XG4gIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBUaGUgcm9vdCBET00gSUQgZm9yIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzKTtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgaWYgKGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKSB7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyh0aGlzLl90YWcsIHRoaXMsIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24pO1xuICAgIHZhciB0YWdDb250ZW50ID0gdGhpcy5fY3JlYXRlQ29udGVudE1hcmt1cCh0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xuICAgICAgcmV0dXJuIHRhZ09wZW4gKyAnLz4nO1xuICAgIH1cbiAgICByZXR1cm4gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fdGFnICsgJz4nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fdGFnO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gYXNzaWduKHt9LCBwcm9wcy5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BWYWx1ZSA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gICAgLy8gYnl0ZXMuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHZhciBtYXJrdXBGb3JJRCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICByZXR1cm4gcmV0ICsgJyAnICsgbWFya3VwRm9ySUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHJldCA9IGlubmVySFRNTC5fX2h0bWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHJldCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcihjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBwcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQsIHRoaXMpKTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgbmF0aXZlIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhwcmV2RWxlbWVudC5wcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKHByZXZFbGVtZW50LnByb3BzLCB0cmFuc2FjdGlvbiwgcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0LCB0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIHByb3BlcnRpZXMgYnkgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzIGluIHByb3BlcnR5IHZhbHVlcyBhbmRcbiAgICogdXBkYXRpbmcgdGhlIERPTSBhcyBuZWNlc3NhcnkuIFRoaXMgZnVuY3Rpb24gaXMgcHJvYmFibHkgdGhlIHNpbmdsZSBtb3N0XG4gICAqIGNyaXRpY2FsIHBhdGggZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICpcbiAgICogVE9ETzogQmVuY2htYXJrIHdoZXRoZXIgY2hlY2tpbmcgZm9yIGNoYW5nZWQgdmFsdWVzIGluIG1lbW9yeSBhY3R1YWxseVxuICAgKiAgICAgICBpbXByb3ZlcyBwZXJmb3JtYW5jZSAoZXNwZWNpYWxseSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMpLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgdGhlIGVmZmVjdHMgb2YgcHV0dGluZyB0aGlzIGF0IHRoZSB0b3Agc2luY2UgOTklIG9mIHByb3BzXG4gICAqICAgICAgIGRvIG5vdCBjaGFuZ2UgZm9yIGEgZ2l2ZW4gcmVjb25jaWxpYXRpb24uXG4gICAqIFRPRE86IEJlbmNobWFyayBhcmVhcyB0aGF0IGNhbiBiZSBpbXByb3ZlZCB3aXRoIGNhY2hpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtwcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBCYWNrZW5kSURPcGVyYXRpb25zLmRlbGV0ZVByb3BlcnR5QnlJRCh0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IGFzc2lnbih7fSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXksIG5leHRQcm9wLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtwcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBCYWNrZW5kSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRCh0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAgIEJhY2tlbmRJRE9wZXJhdGlvbnMudXBkYXRlU3R5bGVzQnlJRCh0aGlzLl9yb290Tm9kZUlELCBzdHlsZVVwZGF0ZXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBuZXh0UHJvcHMuY2hpbGRyZW5dID8gbmV4dFByb3BzLmNoaWxkcmVuIDogbnVsbDtcblxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgQmFja2VuZElET3BlcmF0aW9ucy51cGRhdGVJbm5lckhUTUxCeUlEKHRoaXMuX3Jvb3ROb2RlSUQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveXMgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuIERvZXMgbm90IHJlbW92ZSBmcm9tXG4gICAqIHRoZSBET00uIFRoYXQgbXVzdCBiZSBkb25lIGJ5IHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKCk7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0RE9NQ29tcG9uZW50LCAnUmVhY3RET01Db21wb25lbnQnLCB7XG4gIG1vdW50Q29tcG9uZW50OiAnbW91bnRDb21wb25lbnQnLFxuICB1cGRhdGVDb21wb25lbnQ6ICd1cGRhdGVDb21wb25lbnQnXG59KTtcblxuYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cblJlYWN0RE9NQ29tcG9uZW50LmluamVjdGlvbiA9IHtcbiAgaW5qZWN0SURPcGVyYXRpb25zOiBmdW5jdGlvbiAoSURPcGVyYXRpb25zKSB7XG4gICAgUmVhY3RET01Db21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucyA9IEJhY2tlbmRJRE9wZXJhdGlvbnMgPSBJRE9wZXJhdGlvbnM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRm9ybVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgTG9jYWxFdmVudFRyYXBNaXhpbiA9IHJlcXVpcmUoXCIuL0xvY2FsRXZlbnRUcmFwTWl4aW5cIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG5cbnZhciBmb3JtID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoJ2Zvcm0nKTtcblxuLyoqXG4gKiBTaW5jZSBvblN1Ym1pdCBkb2Vzbid0IGJ1YmJsZSBPUiBjYXB0dXJlIG9uIHRoZSB0b3AgbGV2ZWwgaW4gSUU4LCB3ZSBuZWVkXG4gKiB0byBjYXB0dXJlIGl0IG9uIHRoZSA8Zm9ybT4gZWxlbWVudCBpdHNlbGYuIFRoZXJlIGFyZSBsb3RzIG9mIGhhY2tzIHdlIGNvdWxkXG4gKiBkbyB0byBhY2NvbXBsaXNoIHRoaXMsIGJ1dCB0aGUgbW9zdCByZWxpYWJsZSBpcyB0byBtYWtlIDxmb3JtPiBhXG4gKiBjb21wb3NpdGUgY29tcG9uZW50IGFuZCB1c2UgYGNvbXBvbmVudERpZE1vdW50YCB0byBhdHRhY2ggdGhlIGV2ZW50IGhhbmRsZXJzLlxuICovXG52YXIgUmVhY3RET01Gb3JtID0gUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01Gb3JtJyxcbiAgdGFnTmFtZTogJ0ZPUk0nLFxuXG4gIG1peGluczogW1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLCBMb2NhbEV2ZW50VHJhcE1peGluXSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHVzaW5nIGBSZWFjdERPTWAgZGlyZWN0bHksIHdlIHNob3VsZCB1c2UgSlNYLiBIb3dldmVyLFxuICAgIC8vIGBqc2hpbnRgIGZhaWxzIHRvIHBhcnNlIEpTWCBzbyBpbiBvcmRlciBmb3IgbGludGluZyB0byB3b3JrIGluIHRoZSBvcGVuXG4gICAgLy8gc291cmNlIHJlcG8sIHdlIG5lZWQgdG8ganVzdCB1c2UgYFJlYWN0RE9NLmZvcm1gLlxuICAgIHJldHVybiBmb3JtKHRoaXMucHJvcHMpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcpO1xuICAgIHRoaXMudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZvcm07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSURPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0NTU1Byb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01DaGlsZHJlbk9wZXJhdGlvbnNcIik7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKFwiLi9zZXRJbm5lckhUTUxcIik7XG5cbi8qKlxuICogRXJyb3JzIGZvciBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdCBiZSB1cGRhdGVkIHdpdGggYHVwZGF0ZVByb3BlcnR5QnlJZCgpYC5cbiAqXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIElOVkFMSURfUFJPUEVSVFlfRVJST1JTID0ge1xuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZUlubmVySFRNTEJ5SUQoKWAuJyxcbiAgc3R5bGU6ICdgc3R5bGVgIG11c3QgYmUgc2V0IHVzaW5nIGB1cGRhdGVTdHlsZXNCeUlEKClgLidcbn07XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuIFRoaXMgaXMgbWFkZSBpbmplY3RhYmxlIHZpYVxuICogYFJlYWN0RE9NQ29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnNgLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSB3aXRoIG5ldyBwcm9wZXJ0eSB2YWx1ZXMuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB0b1xuICAgKiB1cGRhdGUgRE9NIHByb3BlcnRpZXMgaW4gYERPTVByb3BlcnR5YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSB2YWxpZCBwcm9wZXJ0eSBuYW1lLCBzZWUgYERPTVByb3BlcnR5YC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZVByb3BlcnR5QnlJRDogZnVuY3Rpb24gKGlkLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAhIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVByb3BlcnR5QnlJRCguLi4pOiAlcycsIElOVkFMSURfUFJPUEVSVFlfRVJST1JTW25hbWVdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0YW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSB0byByZW1vdmUgYSBwcm9wZXJ0eS4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHRvIHJlbW92ZVxuICAgKiBET00gcHJvcGVydGllcyBpbiBgRE9NUHJvcGVydHlgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHByb3BlcnR5IG5hbWUgdG8gcmVtb3ZlLCBzZWUgYERPTVByb3BlcnR5YC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkZWxldGVQcm9wZXJ0eUJ5SUQ6IGZ1bmN0aW9uIChpZCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgISFJTlZBTElEX1BST1BFUlRZX0VSUk9SUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVQcm9wZXJ0eUJ5SUQoLi4uKTogJXMnLCBJTlZBTElEX1BST1BFUlRZX0VSUk9SU1tuYW1lXSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlIHdpdGggbmV3IHN0eWxlIHZhbHVlcy4gSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXMgJycsXG4gICAqIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXMgTWFwcGluZyBmcm9tIHN0eWxlcyB0byB2YWx1ZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlU3R5bGVzQnlJRDogZnVuY3Rpb24gKGlkLCBzdHlsZXMpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSdzIGlubmVySFRNTC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgQW4gSFRNTCBzdHJpbmcuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlSW5uZXJIVE1MQnlJRDogZnVuY3Rpb24gKGlkLCBodG1sKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgIHNldElubmVySFRNTChub2RlLCBodG1sKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlJ3MgdGV4dCBjb250ZW50IHNldCBieSBgcHJvcHMuY29udGVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IFRleHQgY29udGVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVUZXh0Q29udGVudEJ5SUQ6IGZ1bmN0aW9uIChpZCwgY29udGVudCkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMudXBkYXRlVGV4dENvbnRlbnQobm9kZSwgY29udGVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgRE9NIG5vZGUgdGhhdCBleGlzdHMgaW4gdGhlIGRvY3VtZW50IHdpdGggbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgY2hpbGQgdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgRGFuZ2Vyb3VzIG1hcmt1cCB0byBpbmplY3QgaW4gcGxhY2Ugb2YgY2hpbGQuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXB9XG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChpZCwgbWFya3VwKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChub2RlLCBtYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwIExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAodXBkYXRlcywgbWFya3VwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGVzW2ldLnBhcmVudE5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodXBkYXRlc1tpXS5wYXJlbnRJRCk7XG4gICAgfVxuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyh1cGRhdGVzLCBtYXJrdXApO1xuICB9XG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RET01JRE9wZXJhdGlvbnMsICdSZWFjdERPTUlET3BlcmF0aW9ucycsIHtcbiAgdXBkYXRlUHJvcGVydHlCeUlEOiAndXBkYXRlUHJvcGVydHlCeUlEJyxcbiAgZGVsZXRlUHJvcGVydHlCeUlEOiAnZGVsZXRlUHJvcGVydHlCeUlEJyxcbiAgdXBkYXRlU3R5bGVzQnlJRDogJ3VwZGF0ZVN0eWxlc0J5SUQnLFxuICB1cGRhdGVJbm5lckhUTUxCeUlEOiAndXBkYXRlSW5uZXJIVE1MQnlJRCcsXG4gIHVwZGF0ZVRleHRDb250ZW50QnlJRDogJ3VwZGF0ZVRleHRDb250ZW50QnlJRCcsXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCcsXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcydcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlmcmFtZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgTG9jYWxFdmVudFRyYXBNaXhpbiA9IHJlcXVpcmUoXCIuL0xvY2FsRXZlbnRUcmFwTWl4aW5cIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG5cbnZhciBpZnJhbWUgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSgnaWZyYW1lJyk7XG5cbi8qKlxuICogU2luY2Ugb25Mb2FkIGRvZXNuJ3QgYnViYmxlIE9SIGNhcHR1cmUgb24gdGhlIHRvcCBsZXZlbCBpbiBJRTgsIHdlIG5lZWQgdG9cbiAqIGNhcHR1cmUgaXQgb24gdGhlIDxpZnJhbWU+IGVsZW1lbnQgaXRzZWxmLiBUaGVyZSBhcmUgbG90cyBvZiBoYWNrcyB3ZSBjb3VsZFxuICogZG8gdG8gYWNjb21wbGlzaCB0aGlzLCBidXQgdGhlIG1vc3QgcmVsaWFibGUgaXMgdG8gbWFrZSA8aWZyYW1lPiBhIGNvbXBvc2l0ZVxuICogY29tcG9uZW50IGFuZCB1c2UgYGNvbXBvbmVudERpZE1vdW50YCB0byBhdHRhY2ggdGhlIGV2ZW50IGhhbmRsZXJzLlxuICovXG52YXIgUmVhY3RET01JZnJhbWUgPSBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTUlmcmFtZScsXG4gIHRhZ05hbWU6ICdJRlJBTUUnLFxuXG4gIG1peGluczogW1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLCBMb2NhbEV2ZW50VHJhcE1peGluXSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaWZyYW1lKHRoaXMucHJvcHMpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JZnJhbWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW1nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBMb2NhbEV2ZW50VHJhcE1peGluID0gcmVxdWlyZShcIi4vTG9jYWxFdmVudFRyYXBNaXhpblwiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKFwiLi9SZWFjdENsYXNzXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcblxudmFyIGltZyA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KCdpbWcnKTtcblxuLyoqXG4gKiBTaW5jZSBvbkxvYWQgZG9lc24ndCBidWJibGUgT1IgY2FwdHVyZSBvbiB0aGUgdG9wIGxldmVsIGluIElFOCwgd2UgbmVlZCB0b1xuICogY2FwdHVyZSBpdCBvbiB0aGUgPGltZz4gZWxlbWVudCBpdHNlbGYuIFRoZXJlIGFyZSBsb3RzIG9mIGhhY2tzIHdlIGNvdWxkIGRvXG4gKiB0byBhY2NvbXBsaXNoIHRoaXMsIGJ1dCB0aGUgbW9zdCByZWxpYWJsZSBpcyB0byBtYWtlIDxpbWc+IGEgY29tcG9zaXRlXG4gKiBjb21wb25lbnQgYW5kIHVzZSBgY29tcG9uZW50RGlkTW91bnRgIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gKi9cbnZhciBSZWFjdERPTUltZyA9IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NSW1nJyxcbiAgdGFnTmFtZTogJ0lNRycsXG5cbiAgbWl4aW5zOiBbUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4sIExvY2FsRXZlbnRUcmFwTWl4aW5dLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbWcodGhpcy5wcm9wcyk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcpO1xuICAgIHRoaXMudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbWc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW5wdXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBdXRvRm9jdXNNaXhpbiA9IHJlcXVpcmUoXCIuL0F1dG9Gb2N1c01peGluXCIpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZShcIi4vTGlua2VkVmFsdWVVdGlsc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKFwiLi9SZWFjdENsYXNzXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZShcIi4vZmluZERPTU5vZGVcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgaW5wdXQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSgnaW5wdXQnKTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RJRCA9IHt9O1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgaWYgKHRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NSW5wdXQnLFxuICB0YWdOYW1lOiAnSU5QVVQnLFxuXG4gIG1peGluczogW0F1dG9Gb2N1c01peGluLCBMaW5rZWRWYWx1ZVV0aWxzLk1peGluLCBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0aWFsQ2hlY2tlZDogdGhpcy5wcm9wcy5kZWZhdWx0Q2hlY2tlZCB8fCBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogZGVmYXVsdFZhbHVlICE9IG51bGwgPyBkZWZhdWx0VmFsdWUgOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDbG9uZSBgdGhpcy5wcm9wc2Agc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBpbnB1dC5cbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuXG4gICAgcHJvcHMuZGVmYXVsdENoZWNrZWQgPSBudWxsO1xuICAgIHByb3BzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMucHJvcHMpO1xuICAgIHByb3BzLnZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy5zdGF0ZS5pbml0aWFsVmFsdWU7XG5cbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZCh0aGlzLnByb3BzKTtcbiAgICBwcm9wcy5jaGVja2VkID0gY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IHRoaXMuc3RhdGUuaW5pdGlhbENoZWNrZWQ7XG5cbiAgICBwcm9wcy5vbkNoYW5nZSA9IHRoaXMuX2hhbmRsZUNoYW5nZTtcblxuICAgIHJldHVybiBpbnB1dChwcm9wcywgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWQgPSBSZWFjdE1vdW50LmdldElEKGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgICBpbnN0YW5jZXNCeVJlYWN0SURbaWRdID0gdGhpcztcbiAgfSxcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByb290Tm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHZhciBpZCA9IFJlYWN0TW91bnQuZ2V0SUQocm9vdE5vZGUpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0SURbaWRdO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCkge1xuICAgIHZhciByb290Tm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgIGlmICh0aGlzLnByb3BzLmNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkocm9vdE5vZGUsICdjaGVja2VkJywgdGhpcy5wcm9wcy5jaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMucHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkocm9vdE5vZGUsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdmFyIG9uQ2hhbmdlID0gTGlua2VkVmFsdWVVdGlscy5nZXRPbkNoYW5nZSh0aGlzLnByb3BzKTtcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIHJldHVyblZhbHVlID0gb25DaGFuZ2UuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gICAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgaWYgKHRoaXMucHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICAgIHZhciByb290Tm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG90aGVySUQgPSBSZWFjdE1vdW50LmdldElEKG90aGVyTm9kZSk7XG4gICAgICAgICFvdGhlcklEID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnICsgJ3NhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IGluc3RhbmNlc0J5UmVhY3RJRFtvdGhlcklEXTtcbiAgICAgICAgIW90aGVySW5zdGFuY2UgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogVW5rbm93biByYWRpbyBidXR0b24gSUQgJXMuJywgb3RoZXJJRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01PcHRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKFwiLi9SZWFjdENoaWxkcmVuXCIpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKFwiLi9SZWFjdENsYXNzXCIpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZShcIi4vUmVhY3RET01TZWxlY3RcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgb3B0aW9uID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoJ29wdGlvbicpO1xuXG52YXIgdmFsdWVDb250ZXh0S2V5ID0gUmVhY3RET01TZWxlY3QudmFsdWVDb250ZXh0S2V5O1xuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NT3B0aW9uJyxcbiAgdGFnTmFtZTogJ09QVElPTicsXG5cbiAgbWl4aW5zOiBbUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5dLFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7IHNlbGVjdGVkOiBudWxsIH07XG4gIH0sXG5cbiAgY29udGV4dFR5cGVzOiAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBvYmpbdmFsdWVDb250ZXh0S2V5XSA9IFJlYWN0UHJvcFR5cGVzLmFueTtcbiAgICByZXR1cm4gb2JqO1xuICB9KSgpLFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyh0aGlzLnByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJyB2aWEgcGFyZW50LWJhc2VkIGNvbnRleHRcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB2YXIgc2VsZWN0VmFsdWUgPSBjb250ZXh0W3ZhbHVlQ29udGV4dEtleV07XG5cbiAgICAvLyBJZiBjb250ZXh0IGtleSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0Pikgc2tpcCBwcm9wc1xuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09ICcnICsgdGhpcy5wcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09ICcnICsgdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3RlZDogc2VsZWN0ZWQgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxuICAgIC8vIG1hbnVhbGx5OyB3ZSBuZWVkIHRoZSBpbml0aWFsIHN0YXRlIG9ubHkgZm9yIHNlcnZlciByZW5kZXJpbmdcbiAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBwcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHsgc2VsZWN0ZWQ6IHRoaXMuc3RhdGUuc2VsZWN0ZWQgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAgIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAgIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gICAgUmVhY3RDaGlsZHJlbi5mb3JFYWNoKHRoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBvcHRpb24ocHJvcHMsIGNvbnRlbnQpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEF1dG9Gb2N1c01peGluID0gcmVxdWlyZShcIi4vQXV0b0ZvY3VzTWl4aW5cIik7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoXCIuL0xpbmtlZFZhbHVlVXRpbHNcIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZShcIi4vZmluZERPTU5vZGVcIik7XG5cbnZhciBzZWxlY3QgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSgnc2VsZWN0Jyk7XG5cbnZhciB2YWx1ZUNvbnRleHRLZXkgPSAnX19SZWFjdERPTVNlbGVjdF92YWx1ZSQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICBpZiAodGhpcy5fcGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3BlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMucHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VsZWN0VmFsdWVUeXBlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignVGhlIGAnICsgcHJvcE5hbWUgKyAnYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1RoZSBgJyArIHByb3BOYW1lICsgJ2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4nKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgSW5zdGFuY2Ugb2YgUmVhY3RET01TZWxlY3RcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhjb21wb25lbnQsIHByb3BWYWx1ZSkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcbiAgdmFyIG9wdGlvbnMgPSBmaW5kRE9NTm9kZShjb21wb25lbnQpLm9wdGlvbnM7XG5cbiAgaWYgKGNvbXBvbmVudC5wcm9wcy5tdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01TZWxlY3QnLFxuICB0YWdOYW1lOiAnU0VMRUNUJyxcblxuICBtaXhpbnM6IFtBdXRvRm9jdXNNaXhpbiwgTGlua2VkVmFsdWVVdGlscy5NaXhpbiwgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5dLFxuXG4gIHN0YXRpY3M6IHtcbiAgICB2YWx1ZUNvbnRleHRLZXk6IHZhbHVlQ29udGV4dEtleVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIGRlZmF1bHRWYWx1ZTogc2VsZWN0VmFsdWVUeXBlLFxuICAgIHZhbHVlOiBzZWxlY3RWYWx1ZVR5cGVcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBQYXNzIGRvd24gaW5pdGlhbCB2YWx1ZSBzbyBpbml0aWFsIGdlbmVyYXRlZCBtYXJrdXAgaGFzIGNvcnJlY3RcbiAgICAvLyBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMucHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4geyBpbml0aWFsVmFsdWU6IHZhbHVlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IGluaXRpYWxWYWx1ZTogdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUgfTtcbiAgICB9XG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9ialt2YWx1ZUNvbnRleHRLZXldID0gUmVhY3RQcm9wVHlwZXMuYW55O1xuICAgIHJldHVybiBvYmo7XG4gIH0pKCksXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9ialt2YWx1ZUNvbnRleHRLZXldID0gdGhpcy5zdGF0ZS5pbml0aWFsVmFsdWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDbG9uZSBgdGhpcy5wcm9wc2Agc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBpbnB1dC5cbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuXG4gICAgcHJvcHMub25DaGFuZ2UgPSB0aGlzLl9oYW5kbGVDaGFuZ2U7XG4gICAgcHJvcHMudmFsdWUgPSBudWxsO1xuXG4gICAgcmV0dXJuIHNlbGVjdChwcm9wcywgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGUgY29udGV4dCB2YWx1ZSBkb3duXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGluaXRpYWxWYWx1ZTogbnVsbCB9KTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMucHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCFwcmV2UHJvcHMubXVsdGlwbGUgIT09ICF0aGlzLnByb3BzLm11bHRpcGxlKSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgICBpZiAodGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCB0aGlzLnByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgb25DaGFuZ2UgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldE9uQ2hhbmdlKHRoaXMucHJvcHMpO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBvbkNoYW5nZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl9wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZShcIi4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFwiKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZShcIi4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclwiKTtcblxuLyoqXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgUmFuZ2Ugb2JqZWN0LCBJRTExIHNvbWV0aW1lcyBnZXRzIHRoZW0gd3JvbmcuXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsYXBzZWQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFuY2hvciBhbmQgZm9jdXMgbm9kZS9vZmZzZXQgcGFpcnMgZm9yIElFLlxuICpcbiAqIFRoZSBjYXRjaCBoZXJlIGlzIHRoYXQgSUUncyBzZWxlY3Rpb24gQVBJIGRvZXNuJ3QgcHJvdmlkZSBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dhcmQsIHNvIHdlIGhhdmUgdG9cbiAqIGJlaGF2ZSBhcyB0aG91Z2ggaXQncyBhbHdheXMgZm9yd2FyZC5cbiAqXG4gKiBJRSB0ZXh0IGRpZmZlcnMgZnJvbSBtb2Rlcm4gc2VsZWN0aW9uIGluIHRoYXQgaXQgYmVoYXZlcyBhcyB0aG91Z2hcbiAqIGJsb2NrIGVsZW1lbnRzIGVuZCB3aXRoIGEgbmV3IGxpbmUuIFRoaXMgbWVhbnMgY2hhcmFjdGVyIG9mZnNldHMgd2lsbFxuICogZGlmZmVyIGJldHdlZW4gdGhlIHR3byBBUElzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRJRU9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZFJhbmdlLnRleHQubGVuZ3RoO1xuXG4gIC8vIER1cGxpY2F0ZSBzZWxlY3Rpb24gc28gd2UgY2FuIG1vdmUgcmFuZ2Ugd2l0aG91dCBicmVha2luZyB1c2VyIHNlbGVjdGlvbi5cbiAgdmFyIGZyb21TdGFydCA9IHNlbGVjdGVkUmFuZ2UuZHVwbGljYXRlKCk7XG4gIGZyb21TdGFydC5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgZnJvbVN0YXJ0LnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0Jywgc2VsZWN0ZWRSYW5nZSk7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gZnJvbVN0YXJ0LnRleHQubGVuZ3RoO1xuICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBzZWxlY3RlZExlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydE9mZnNldCxcbiAgICBlbmQ6IGVuZE9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIHZhciBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgdmFyIGN1cnJlbnRSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAodHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gdHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJyA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZXJ2ZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdERlZmF1bHRJbmplY3Rpb25cIik7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmcgPSByZXF1aXJlKFwiLi9SZWFjdFNlcnZlclJlbmRlcmluZ1wiKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET01TZXJ2ZXIgPSB7XG4gIHJlbmRlclRvU3RyaW5nOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0cmluZyxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlclRvU3RhdGljTWFya3VwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VydmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcIik7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdERPTUNvbXBvbmVudFwiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXCIpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlRE9NTmVzdGluZ1wiKTtcblxuLyoqXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxuICpcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBpbiBlbGVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIHVuZGVyZ29cbiAqIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAocHJvcHMpIHt9O1xuXG5hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xuICAgIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG5cbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRJbmRleCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgaWYgKGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKSB7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZygnc3BhbicsIG51bGwsIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIHZhciBlc2NhcGVkVGV4dCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0aGlzLl9zdHJpbmdUZXh0KTtcblxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgaW4gYSBgc3BhbmAgZm9yIHRoZSByZWFzb25zIHN0YXRlZCBhYm92ZSwgYnV0XG4gICAgICAvLyBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlciAoc3RhdGljIHBhZ2VzKSxcbiAgICAgIC8vIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0ZXh0IGFzIGl0IGlzLlxuICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgIH1cblxuICAgIHJldHVybiAnPHNwYW4gJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRChyb290SUQpICsgJz4nICsgZXNjYXBlZFRleHQgKyAnPC9zcGFuPic7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIFJlYWN0RE9NQ29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnMudXBkYXRlVGV4dENvbnRlbnRCeUlEKHRoaXMuX3Jvb3ROb2RlSUQsIG5leHRTdHJpbmdUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7XG5cbi8vIFRoaXMgY29uc3RydWN0b3IgYW5kIGl0cyBhcmd1bWVudCBpcyBjdXJyZW50bHkgdXNlZCBieSBtb2Nrcy4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0YXJlYVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEF1dG9Gb2N1c01peGluID0gcmVxdWlyZShcIi4vQXV0b0ZvY3VzTWl4aW5cIik7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKFwiLi9MaW5rZWRWYWx1ZVV0aWxzXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoXCIuL1JlYWN0Q2xhc3NcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKFwiLi9maW5kRE9NTm9kZVwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIHRleHRhcmVhID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoJ3RleHRhcmVhJyk7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICBpZiAodGhpcy5pc01vdW50ZWQoKSkge1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NVGV4dGFyZWEnLFxuICB0YWdOYW1lOiAnVEVYVEFSRUEnLFxuXG4gIG1peGluczogW0F1dG9Gb2N1c01peGluLCBMaW5rZWRWYWx1ZVV0aWxzLk1peGluLCBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZSh0aGlzLnByb3BzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gV2Ugc2F2ZSB0aGUgaW5pdGlhbCB2YWx1ZSBzbyB0aGF0IGBSZWFjdERPTUNvbXBvbmVudGAgZG9lc24ndCB1cGRhdGVcbiAgICAgIC8vIGB0ZXh0Q29udGVudGAgKHVubmVjZXNzYXJ5IHNpbmNlIHdlIHVwZGF0ZSB2YWx1ZSkuXG4gICAgICAvLyBUaGUgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3NcbiAgICAgIC8vIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyAodmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlKVxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2xvbmUgYHRoaXMucHJvcHNgIHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgaW5wdXQuXG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCB0aGlzLnByb3BzKTtcblxuICAgICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcHJvcHMuZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICBwcm9wcy52YWx1ZSA9IG51bGw7XG4gICAgcHJvcHMub25DaGFuZ2UgPSB0aGlzLl9oYW5kbGVDaGFuZ2U7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuXG4gICAgcmV0dXJuIHRleHRhcmVhKHByb3BzLCB0aGlzLnN0YXRlLmluaXRpYWxWYWx1ZSk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZSh0aGlzLnByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHJvb3ROb2RlID0gZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkocm9vdE5vZGUsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdmFyIG9uQ2hhbmdlID0gTGlua2VkVmFsdWVVdGlscy5nZXRPbkNoYW5nZSh0aGlzLnByb3BzKTtcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIHJldHVyblZhbHVlID0gb25DaGFuZ2UuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL1RyYW5zYWN0aW9uXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxudmFyIFJFU0VUX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBGTFVTSF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBSZWFjdFVwZGF0ZXMuZmx1c2hCYXRjaGVkVXBkYXRlcy5iaW5kKFJlYWN0VXBkYXRlcylcbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtGTFVTSF9CQVRDSEVEX1VQREFURVMsIFJFU0VUX0JBVENIRURfVVBEQVRFU107XG5cbmZ1bmN0aW9uIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xufVxuXG5hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKGNhbGxiYWNrLCBudWxsLCBhLCBiLCBjLCBkLCBlKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW5cIik7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9DaGFuZ2VFdmVudFBsdWdpblwiKTtcbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL0NsaWVudFJlYWN0Um9vdEluZGV4XCIpO1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gcmVxdWlyZShcIi4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcIik7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZShcIi4vSFRNTERPTVByb3BlcnR5Q29uZmlnXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoXCIuL1JlYWN0Q2xhc3NcIik7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFwiKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVwiKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NQnV0dG9uID0gcmVxdWlyZShcIi4vUmVhY3RET01CdXR0b25cIik7XG52YXIgUmVhY3RET01Gb3JtID0gcmVxdWlyZShcIi4vUmVhY3RET01Gb3JtXCIpO1xudmFyIFJlYWN0RE9NSW1nID0gcmVxdWlyZShcIi4vUmVhY3RET01JbWdcIik7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9SZWFjdERPTUlET3BlcmF0aW9uc1wiKTtcbnZhciBSZWFjdERPTUlmcmFtZSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NSWZyYW1lXCIpO1xudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKFwiLi9SZWFjdERPTUlucHV0XCIpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RET01PcHRpb25cIik7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKFwiLi9SZWFjdERPTVNlbGVjdFwiKTtcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZShcIi4vUmVhY3RET01UZXh0YXJlYVwiKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdERPTVRleHRDb21wb25lbnRcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL1JlYWN0RXZlbnRMaXN0ZW5lclwiKTtcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0SW5qZWN0aW9uXCIpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZUhhbmRsZXNcIik7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VNYXBcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cIik7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9TZWxlY3RFdmVudFBsdWdpblwiKTtcbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL1NlcnZlclJlYWN0Um9vdEluZGV4XCIpO1xudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vU2ltcGxlRXZlbnRQbHVnaW5cIik7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKFwiLi9TVkdET01Qcm9wZXJ0eUNvbmZpZ1wiKTtcblxudmFyIGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vY3JlYXRlRnVsbFBhZ2VDb21wb25lbnRcIik7XG5cbmZ1bmN0aW9uIGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyh0eXBlKSB7XG4gIHJldHVybiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzKHtcbiAgICB0YWdOYW1lOiB0eXBlLnRvVXBwZXJDYXNlKCksXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb3B5IG93bmVyIGRvd24gZm9yIGRlYnVnZ2luZyBpbmZvXG4gICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpO1xuICAgICAgcmV0dXJuIG5ldyBSZWFjdEVsZW1lbnQodHlwZSwgbnVsbCwgLy8ga2V5XG4gICAgICBudWxsLCAvLyByZWZcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciwgLy8gb3duZXJcbiAgICAgIG51bGwsIC8vIGNvbnRleHRcbiAgICAgIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXG4gICAgLy8gdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlciBwYWNrYWdlLiBUaGV5IHNob3VsZCBiZSBidWlsdCBpbmRlcGVuZGVudGx5XG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcblxuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFJlYWN0RXZlbnRMaXN0ZW5lcik7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEluc3RhbmNlSGFuZGxlKFJlYWN0SW5zdGFuY2VIYW5kbGVzKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0TW91bnQoUmVhY3RNb3VudCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5OYXRpdmVDb21wb25lbnQuaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzKFJlYWN0RE9NQ29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5OYXRpdmVDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uTmF0aXZlQ29tcG9uZW50LmluamVjdEF1dG9XcmFwcGVyKGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyk7XG5cbiAgLy8gVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KCkgb3RoZXJ3aXNlIHRoZSBtaXhpblxuICAvLyB3b24ndCBiZSBpbmNsdWRlZC5cbiAgUmVhY3RJbmplY3Rpb24uQ2xhc3MuaW5qZWN0TWl4aW4oUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RDb21wb25lbnRDbGFzc2VzKHtcbiAgICAnYnV0dG9uJzogUmVhY3RET01CdXR0b24sXG4gICAgJ2Zvcm0nOiBSZWFjdERPTUZvcm0sXG4gICAgJ2lmcmFtZSc6IFJlYWN0RE9NSWZyYW1lLFxuICAgICdpbWcnOiBSZWFjdERPTUltZyxcbiAgICAnaW5wdXQnOiBSZWFjdERPTUlucHV0LFxuICAgICdvcHRpb24nOiBSZWFjdERPTU9wdGlvbixcbiAgICAnc2VsZWN0JzogUmVhY3RET01TZWxlY3QsXG4gICAgJ3RleHRhcmVhJzogUmVhY3RET01UZXh0YXJlYSxcblxuICAgICdodG1sJzogY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoJ2h0bWwnKSxcbiAgICAnaGVhZCc6IGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KCdoZWFkJyksXG4gICAgJ2JvZHknOiBjcmVhdGVGdWxsUGFnZUNvbXBvbmVudCgnYm9keScpXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudCgnbm9zY3JpcHQnKTtcblxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uUm9vdEluZGV4LmluamVjdENyZWF0ZVJlYWN0Um9vdEluZGV4KEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IENsaWVudFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4IDogU2VydmVyUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXgpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvbmVudC5pbmplY3RFbnZpcm9ubWVudChSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTUNvbXBvbmVudC5pbmplY3RJRE9wZXJhdGlvbnMoUmVhY3RET01JRE9wZXJhdGlvbnMpO1xuXG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgdmFyIHVybCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJztcbiAgICBpZiAoL1s/Jl1yZWFjdF9wZXJmXFxiLy50ZXN0KHVybCkpIHtcbiAgICAgIHZhciBSZWFjdERlZmF1bHRQZXJmID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0UGVyZlwiKTtcbiAgICAgIFJlYWN0RGVmYXVsdFBlcmYuc3RhcnQoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZShcIi4vcGVyZm9ybWFuY2VOb3dcIik7XG5cbmZ1bmN0aW9uIHJvdW5kRmxvYXQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHZhbCAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKG9iaiwga2V5LCB2YWwpIHtcbiAgb2JqW2tleV0gPSAob2JqW2tleV0gfHwgMCkgKyB2YWw7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmID0ge1xuICBfYWxsTWVhc3VyZW1lbnRzOiBbXSwgLy8gbGFzdCBpdGVtIGluIHRoZSBsaXN0IGlzIHRoZSBjdXJyZW50IG9uZVxuICBfbW91bnRTdGFjazogWzBdLFxuICBfaW5qZWN0ZWQ6IGZhbHNlLFxuXG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFSZWFjdERlZmF1bHRQZXJmLl9pbmplY3RlZCkge1xuICAgICAgUmVhY3RQZXJmLmluamVjdGlvbi5pbmplY3RNZWFzdXJlKFJlYWN0RGVmYXVsdFBlcmYubWVhc3VyZSk7XG4gICAgfVxuXG4gICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUgPSB0cnVlO1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IGZhbHNlO1xuICB9LFxuXG4gIGdldExhc3RNZWFzdXJlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICB9LFxuXG4gIHByaW50RXhjbHVzaXZlOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0NvbXBvbmVudCBjbGFzcyBuYW1lJzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnVG90YWwgaW5jbHVzaXZlIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5pbmNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIG1vdW50IHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIHJlbmRlciB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyKSxcbiAgICAgICAgJ01vdW50IHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdSZW5kZXIgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIC8vIFRPRE86IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUoKSBkb2VzIG5vdCByZXR1cm4gdGhlIGNvcnJlY3RcbiAgICAvLyBudW1iZXIuXG4gIH0sXG5cbiAgcHJpbnRJbmNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnT3duZXIgPiBjb21wb25lbnQnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdJbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnRpbWUpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgY29uc29sZS5sb2coJ1RvdGFsIHRpbWU6JywgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJyk7XG4gIH0sXG5cbiAgZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcDogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCB0cnVlKTtcbiAgICByZXR1cm4gc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1dhc3RlZCB0aW1lIChtcyknOiBpdGVtLnRpbWUsXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIHByaW50V2FzdGVkOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICBjb25zb2xlLnRhYmxlKFJlYWN0RGVmYXVsdFBlcmYuZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcChtZWFzdXJlbWVudHMpKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBwcmludERPTTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdFtET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRV0gPSBpdGVtLmlkO1xuICAgICAgcmVzdWx0Wyd0eXBlJ10gPSBpdGVtLnR5cGU7XG4gICAgICByZXN1bHRbJ2FyZ3MnXSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uYXJncyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBfcmVjb3JkV3JpdGU6IGZ1bmN0aW9uIChpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3MpIHtcbiAgICAvLyBUT0RPOiB0b3RhbFRpbWUgaXNuJ3QgdGhhdCB1c2VmdWwgc2luY2UgaXQgZG9lc24ndCBjb3VudCBwYWludHMvcmVmbG93c1xuICAgIHZhciB3cml0ZXMgPSBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLndyaXRlcztcbiAgICB3cml0ZXNbaWRdID0gd3JpdGVzW2lkXSB8fCBbXTtcbiAgICB3cml0ZXNbaWRdLnB1c2goe1xuICAgICAgdHlwZTogZm5OYW1lLFxuICAgICAgdGltZTogdG90YWxUaW1lLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICB9LFxuXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVGltZTtcbiAgICAgIHZhciBydjtcbiAgICAgIHZhciBzdGFydDtcblxuICAgICAgaWYgKGZuTmFtZSA9PT0gJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICdmbHVzaEJhdGNoZWRVcGRhdGVzJykge1xuICAgICAgICAvLyBBIFwibWVhc3VyZW1lbnRcIiBpcyBhIHNldCBvZiBtZXRyaWNzIHJlY29yZGVkIGZvciBlYWNoIGZsdXNoLiBXZSB3YW50XG4gICAgICAgIC8vIHRvIGdyb3VwIHRoZSBtZXRyaWNzIGZvciBhIGdpdmVuIGZsdXNoIHRvZ2V0aGVyIHNvIHdlIGNhbiBsb29rIGF0IHRoZVxuICAgICAgICAvLyBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgYW5kIHRoZSBET00gb3BlcmF0aW9ucyB0aGF0IGFjdHVhbGx5XG4gICAgICAgIC8vIGhhcHBlbmVkIHRvIGRldGVybWluZSB0aGUgYW1vdW50IG9mIFwid2FzdGVkIHdvcmtcIiBwZXJmb3JtZWQuXG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgICAgICBleGNsdXNpdmU6IHt9LFxuICAgICAgICAgIGluY2x1c2l2ZToge30sXG4gICAgICAgICAgcmVuZGVyOiB7fSxcbiAgICAgICAgICBjb3VudHM6IHt9LFxuICAgICAgICAgIHdyaXRlczoge30sXG4gICAgICAgICAgZGlzcGxheU5hbWVzOiB7fSxcbiAgICAgICAgICB0b3RhbFRpbWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLnRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdfbW91bnRJbWFnZUludG9Ob2RlJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RET01JRE9wZXJhdGlvbnMnKSB7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnKSB7XG4gICAgICAgICAgdmFyIG1vdW50SUQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMV0pO1xuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKG1vdW50SUQsIGZuTmFtZSwgdG90YWxUaW1lLCBhcmdzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBmb3JtYXRcbiAgICAgICAgICBhcmdzWzBdLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlQXJncyA9IHt9O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5mcm9tSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLmZyb21JbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRvSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRvSW5kZXggPSB1cGRhdGUudG9JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRleHRDb250ZW50ID0gdXBkYXRlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5tYXJrdXBJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MubWFya3VwID0gYXJnc1sxXVt1cGRhdGUubWFya3VwSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUodXBkYXRlLnBhcmVudElELCB1cGRhdGUudHlwZSwgdG90YWxUaW1lLCB3cml0ZUFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJhc2ljIGZvcm1hdFxuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKGFyZ3NbMF0sIGZuTmFtZSwgdG90YWxUaW1lLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChtb2R1bGVOYW1lID09PSAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnICYmIChmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgfHwgZm5OYW1lID09PSAndXBkYXRlQ29tcG9uZW50JyB8fCAvLyBUT0RPOiByZWNlaXZlQ29tcG9uZW50KCk/XG4gICAgICBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JykpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9vdE5vZGVJRCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JyA/IGFyZ3NbMF0gOiB0aGlzLl9yb290Tm9kZUlEO1xuICAgICAgICB2YXIgaXNSZW5kZXIgPSBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JztcbiAgICAgICAgdmFyIGlzTW91bnQgPSBmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG1vdW50U3RhY2sgPSBSZWFjdERlZmF1bHRQZXJmLl9tb3VudFN0YWNrO1xuICAgICAgICB2YXIgZW50cnkgPSBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChpc1JlbmRlcikge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmNvdW50cywgcm9vdE5vZGVJRCwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIG1vdW50U3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkucmVuZGVyLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgICB2YXIgc3ViTW91bnRUaW1lID0gbW91bnRTdGFjay5wb3AoKTtcbiAgICAgICAgICBtb3VudFN0YWNrW21vdW50U3RhY2subGVuZ3RoIC0gMV0gKz0gdG90YWxUaW1lO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmV4Y2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lIC0gc3ViTW91bnRUaW1lKTtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuaW5jbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW50cnkuZGlzcGxheU5hbWVzW3Jvb3ROb2RlSURdID0ge1xuICAgICAgICAgIGN1cnJlbnQ6IHRoaXMuZ2V0TmFtZSgpLFxuICAgICAgICAgIG93bmVyOiB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXIgPyB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpIDogJzxyb290PidcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdFBlcmY7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG5cbi8vIERvbid0IHRyeSB0byBzYXZlIHVzZXJzIGxlc3MgdGhhbiAxLjJtcyAoYSBudW1iZXIgSSBtYWRlIHVwKVxudmFyIERPTlRfQ0FSRV9USFJFU0hPTEQgPSAxLjI7XG52YXIgRE9NX09QRVJBVElPTl9UWVBFUyA9IHtcbiAgJ19tb3VudEltYWdlSW50b05vZGUnOiAnc2V0IGlubmVySFRNTCcsXG4gIElOU0VSVF9NQVJLVVA6ICdzZXQgaW5uZXJIVE1MJyxcbiAgTU9WRV9FWElTVElORzogJ21vdmUnLFxuICBSRU1PVkVfTk9ERTogJ3JlbW92ZScsXG4gIFRFWFRfQ09OVEVOVDogJ3NldCB0ZXh0Q29udGVudCcsXG4gICd1cGRhdGVQcm9wZXJ0eUJ5SUQnOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICdkZWxldGVQcm9wZXJ0eUJ5SUQnOiAnZGVsZXRlIGF0dHJpYnV0ZScsXG4gICd1cGRhdGVTdHlsZXNCeUlEJzogJ3VwZGF0ZSBzdHlsZXMnLFxuICAndXBkYXRlSW5uZXJIVE1MQnlJRCc6ICdzZXQgaW5uZXJIVE1MJyxcbiAgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCc6ICdyZXBsYWNlJ1xufTtcblxuZnVuY3Rpb24gZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykge1xuICAvLyBUT0RPOiByZXR1cm4gbnVtYmVyIG9mIERPTSBvcHM/IGNvdWxkIGJlIG1pc2xlYWRpbmcuXG4gIC8vIFRPRE86IG1lYXN1cmUgZHJvcHBlZCBmcmFtZXMgYWZ0ZXIgcmVjb25jaWxlP1xuICAvLyBUT0RPOiBsb2cgdG90YWwgdGltZSBvZiBlYWNoIHJlY29uY2lsZSBhbmQgdGhlIHRvcC1sZXZlbCBjb21wb25lbnRcbiAgLy8gY2xhc3MgdGhhdCB0cmlnZ2VyZWQgaXQuXG4gIHZhciB0b3RhbFRpbWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB0b3RhbFRpbWUgKz0gbWVhc3VyZW1lbnQudG90YWxUaW1lO1xuICB9XG4gIHJldHVybiB0b3RhbFRpbWU7XG59XG5cbmZ1bmN0aW9uIGdldERPTVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgaWQ7XG5cbiAgICBmb3IgKGlkIGluIG1lYXN1cmVtZW50LndyaXRlcykge1xuICAgICAgbWVhc3VyZW1lbnQud3JpdGVzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uICh3cml0ZSkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgdHlwZTogRE9NX09QRVJBVElPTl9UWVBFU1t3cml0ZS50eXBlXSB8fCB3cml0ZS50eXBlLFxuICAgICAgICAgIGFyZ3M6IHdyaXRlLmFyZ3NcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cykge1xuICB2YXIgY2FuZGlkYXRlcyA9IHt9O1xuICB2YXIgZGlzcGxheU5hbWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gICAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgICBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF0uY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0gPSBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSB8fCB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBpbmNsdXNpdmU6IDAsXG4gICAgICAgIGV4Y2x1c2l2ZTogMCxcbiAgICAgICAgcmVuZGVyOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcbiAgICAgIGlmIChtZWFzdXJlbWVudC5yZW5kZXJbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLnJlbmRlciArPSBtZWFzdXJlbWVudC5yZW5kZXJbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlICs9IG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5pbmNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGRpc3BsYXlOYW1lIGluIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdKTtcbiAgICB9XG4gIH1cblxuICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmV4Y2x1c2l2ZSAtIGEuZXhjbHVzaXZlO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRJbmNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cywgb25seUNsZWFuKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBpbmNsdXNpdmVLZXk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuICAgIHZhciBjbGVhbkNvbXBvbmVudHM7XG5cbiAgICBpZiAob25seUNsZWFuKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHMgPSBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGlmIChvbmx5Q2xlYW4gJiYgIWNsZWFuQ29tcG9uZW50c1tpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF07XG5cbiAgICAgIC8vIEluY2x1c2l2ZSB0aW1lIGlzIG5vdCB1c2VmdWwgZm9yIG1hbnkgY29tcG9uZW50cyB3aXRob3V0IGtub3dpbmcgd2hlcmVcbiAgICAgIC8vIHRoZXkgYXJlIGluc3RhbnRpYXRlZC4gU28gd2UgYWdncmVnYXRlIGluY2x1c2l2ZSB0aW1lIHdpdGggYm90aCB0aGVcbiAgICAgIC8vIG93bmVyIGFuZCBjdXJyZW50IGRpc3BsYXlOYW1lIGFzIHRoZSBrZXkuXG4gICAgICBpbmNsdXNpdmVLZXkgPSBkaXNwbGF5TmFtZS5vd25lciArICcgPiAnICsgZGlzcGxheU5hbWUuY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldID0gY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogaW5jbHVzaXZlS2V5LFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLnRpbWUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS5jb3VudCArPSBtZWFzdXJlbWVudC5jb3VudHNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGEgc29ydGVkIGFycmF5IHdpdGggdGhlIHJlc3VsdHMuXG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yIChpbmNsdXNpdmVLZXkgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSA+PSBET05UX0NBUkVfVEhSRVNIT0xEKSB7XG4gICAgICBhcnIucHVzaChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudGltZSAtIGEudGltZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0VW5jaGFuZ2VkQ29tcG9uZW50cyhtZWFzdXJlbWVudCkge1xuICAvLyBGb3IgYSBnaXZlbiByZWNvbmNpbGUsIGxvb2sgYXQgd2hpY2ggY29tcG9uZW50cyBkaWQgbm90IGFjdHVhbGx5XG4gIC8vIHJlbmRlciBhbnl0aGluZyB0byB0aGUgRE9NIGFuZCByZXR1cm4gYSBtYXBwaW5nIG9mIHRoZWlyIElEIHRvXG4gIC8vIHRoZSBhbW91bnQgb2YgdGltZSBpdCB0b29rIHRvIHJlbmRlciB0aGUgZW50aXJlIHN1YnRyZWUuXG4gIHZhciBjbGVhbkNvbXBvbmVudHMgPSB7fTtcbiAgdmFyIGRpcnR5TGVhZklEcyA9IE9iamVjdC5rZXlzKG1lYXN1cmVtZW50LndyaXRlcyk7XG4gIHZhciBhbGxJRHMgPSBhc3NpZ24oe30sIG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcblxuICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICB2YXIgaXNEaXJ0eSA9IGZhbHNlO1xuICAgIC8vIEZvciBlYWNoIGNvbXBvbmVudCB0aGF0IHJlbmRlcmVkLCBzZWUgaWYgYSBjb21wb25lbnQgdGhhdCB0cmlnZ2VyZWRcbiAgICAvLyBhIERPTSBvcCBpcyBpbiBpdHMgc3VidHJlZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnR5TGVhZklEcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRpcnR5TGVhZklEc1tpXS5pbmRleE9mKGlkKSA9PT0gMCkge1xuICAgICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNEaXJ0eSAmJiBtZWFzdXJlbWVudC5jb3VudHNbaWRdID4gMCkge1xuICAgICAgY2xlYW5Db21wb25lbnRzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGVhbkNvbXBvbmVudHM7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMgPSB7XG4gIGdldEV4Y2x1c2l2ZVN1bW1hcnk6IGdldEV4Y2x1c2l2ZVN1bW1hcnksXG4gIGdldEluY2x1c2l2ZVN1bW1hcnk6IGdldEluY2x1c2l2ZVN1bW1hcnksXG4gIGdldERPTVN1bW1hcnk6IGdldERPTVN1bW1hcnksXG4gIGdldFRvdGFsVGltZTogZ2V0VG90YWxUaW1lXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb250ZXh0ID0gcmVxdWlyZShcIi4vUmVhY3RDb250ZXh0XCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlXG59O1xuXG4vKipcbiAqIFdhcm4gZm9yIG11dGF0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV2FybmluZ1Byb3BlcnR5KG9iamVjdCwga2V5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX3N0b3JlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlW2tleV07XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ0RvblxcJ3Qgc2V0IHRoZSAlcyBwcm9wZXJ0eSBvZiB0aGUgUmVhY3QgZWxlbWVudC4gSW5zdGVhZCwgJyArICdzcGVjaWZ5IHRoZSBjb3JyZWN0IHZhbHVlIHdoZW4gaW5pdGlhbGx5IGNyZWF0aW5nIHRoZSBlbGVtZW50LicsIGtleSkgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9zdG9yZVtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdXBkYXRlZCB0byB0cnVlIGlmIHRoZSBtZW1icmFuZSBpcyBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cbiAqL1xudmFyIHVzZU11dGF0aW9uTWVtYnJhbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBXYXJuIGZvciBtdXRhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBkZWZpbmVNdXRhdGlvbk1lbWJyYW5lKHByb3RvdHlwZSkge1xuICB0cnkge1xuICAgIHZhciBwc2V1ZG9Gcm96ZW5Qcm9wZXJ0aWVzID0ge1xuICAgICAgcHJvcHM6IHRydWVcbiAgICB9O1xuICAgIGZvciAodmFyIGtleSBpbiBwc2V1ZG9Gcm96ZW5Qcm9wZXJ0aWVzKSB7XG4gICAgICBkZWZpbmVXYXJuaW5nUHJvcGVydHkocHJvdG90eXBlLCBrZXkpO1xuICAgIH1cbiAgICB1c2VNdXRhdGlvbk1lbWJyYW5lID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge31cbn1cblxuLyoqXG4gKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgUmVhY3QgZWxlbWVudHMuIFRoaXMgaXMgb25seSB1c2VkIHRvIG1ha2UgdGhpc1xuICogd29yayB3aXRoIGEgZHluYW1pYyBpbnN0YW5jZW9mIGNoZWNrLiBOb3RoaW5nIHNob3VsZCBsaXZlIG9uIHRoaXMgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgb3duZXIsIGNvbnRleHQsIHByb3BzKSB7XG4gIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMucmVmID0gcmVmO1xuXG4gIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gIHRoaXMuX293bmVyID0gb3duZXI7XG5cbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGFuZCBwcm9wcyBhcmUgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgdGhlbSBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIHRoaXMuX3N0b3JlID0geyBwcm9wczogcHJvcHMsIG9yaWdpbmFsUHJvcHM6IGFzc2lnbih7fSwgcHJvcHMpIH07XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLl9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICAgIHRoaXMuX3N0b3JlLnZhbGlkYXRlZCA9IGZhbHNlO1xuXG4gICAgLy8gV2UncmUgbm90IGFsbG93ZWQgdG8gc2V0IHByb3BzIGRpcmVjdGx5IG9uIHRoZSBvYmplY3Qgc28gd2UgZWFybHlcbiAgICAvLyByZXR1cm4gYW5kIHJlbHkgb24gdGhlIHByb3RvdHlwZSBtZW1icmFuZSB0byBmb3J3YXJkIHRvIHRoZSBiYWNraW5nXG4gICAgLy8gc3RvcmUuXG4gICAgaWYgKHVzZU11dGF0aW9uTWVtYnJhbmUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xufTtcblxuLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCBleHBvc2UgdGhlIGZ1bmN0aW9uIG9uIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cbi8vIFJlYWN0RWxlbWVudCBzaG91bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBhIHBsYWluIG9iamVjdC5cblJlYWN0RWxlbWVudC5wcm90b3R5cGUgPSB7XG4gIF9pc1JlYWN0RWxlbWVudDogdHJ1ZVxufTtcblxuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgZGVmaW5lTXV0YXRpb25NZW1icmFuZShSZWFjdEVsZW1lbnQucHJvdG90eXBlKTtcbn1cblxuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgcmVmID0gY29uZmlnLnJlZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5yZWY7XG4gICAga2V5ID0gY29uZmlnLmtleSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6ICcnICsgY29uZmlnLmtleTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBSZWFjdENvbnRleHQuY3VycmVudCwgcHJvcHMpO1xufTtcblxuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld1Byb3BzKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gbmV3IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG9sZEVsZW1lbnQua2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQuX2NvbnRleHQsIG5ld1Byb3BzKTtcblxuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIC8vIElmIHRoZSBrZXkgb24gdGhlIG9yaWdpbmFsIGlzIHZhbGlkLCB0aGVuIHRoZSBjbG9uZSBpcyB2YWxpZFxuICAgIG5ld0VsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IG9sZEVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZDtcbiAgfVxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChjb25maWcua2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIG93bmVyLCBlbGVtZW50Ll9jb250ZXh0LCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgLy8gUmVhY3RUZXN0VXRpbHMgaXMgb2Z0ZW4gdXNlZCBvdXRzaWRlIG9mIGJlZm9yZUVhY2ggd2hlcmUgYXMgUmVhY3QgaXNcbiAgLy8gd2l0aGluIGl0LiBUaGlzIGxlYWRzIHRvIHR3byBkaWZmZXJlbnQgaW5zdGFuY2VzIG9mIFJlYWN0IG9uIHRoZSBzYW1lXG4gIC8vIHBhZ2UuIFRvIGlkZW50aWZ5IGEgZWxlbWVudCBmcm9tIGEgZGlmZmVyZW50IFJlYWN0IGluc3RhbmNlIHdlIHVzZVxuICAvLyBhIGZsYWcgaW5zdGVhZCBvZiBhbiBpbnN0YW5jZW9mIGNoZWNrLlxuICB2YXIgaXNFbGVtZW50ID0gISEob2JqZWN0ICYmIG9iamVjdC5faXNSZWFjdEVsZW1lbnQpO1xuICAvLyBpZiAoaXNFbGVtZW50ICYmICEob2JqZWN0IGluc3RhbmNlb2YgUmVhY3RFbGVtZW50KSkge1xuICAvLyBUaGlzIGlzIGFuIGluZGljYXRvciB0aGF0IHlvdSdyZSB1c2luZyBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBSZWFjdCBhdCB0aGVcbiAgLy8gc2FtZSB0aW1lLiBUaGlzIHdpbGwgc2NyZXcgd2l0aCBvd25lcnNoaXAgYW5kIHN0dWZmLiBGaXggaXQsIHBsZWFzZS5cbiAgLy8gVE9ETzogV2UgY291bGQgcG9zc2libHkgd2FybiBoZXJlLlxuICAvLyB9XG4gIHJldHVybiBpc0VsZW1lbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudDtcblxuLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFZhbGlkYXRvclxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEZyYWdtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RGcmFnbWVudFwiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1wiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdE5hdGl2ZUNvbXBvbmVudFwiKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKFwiLi9nZXRJdGVyYXRvckZuXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG52YXIgTlVNRVJJQ19QUk9QRVJUWV9SRUdFWCA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIEdldHMgdGhlIGluc3RhbmNlJ3MgbmFtZSBmb3IgdXNlIGluIHdhcm5pbmdzLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybiB7P3N0cmluZ30gRGlzcGxheSBuYW1lIG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBnZXROYW1lKGluc3RhbmNlKSB7XG4gIHZhciBwdWJsaWNJbnN0YW5jZSA9IGluc3RhbmNlICYmIGluc3RhbmNlLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gIGlmICghcHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSB8fCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBvd25lcidzIGRpc3BsYXlOYW1lIGZvciB1c2UgaW4gd2FybmluZ3MuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBEaXNwbGF5IG5hbWUgb3IgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRPd25lckRpc3BsYXlOYW1lKCkge1xuICB2YXIgY3VycmVudCA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gIHJldHVybiBjdXJyZW50ICYmIGdldE5hbWUoY3VycmVudCkgfHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmIChlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHdhcm5BbmRNb25pdG9yRm9yS2V5VXNlKCdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nLCBlbGVtZW50LCBwYXJlbnRUeXBlKTtcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBrZXkgaXMgYmVpbmcgZGVmaW5lZCBhcyBhbiBvYmplY3QgcHJvcGVydHkgYnV0IGhhcyBhbiBpbmNvcnJlY3RcbiAqIHZhbHVlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUga2V5LlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlLZXkobmFtZSwgZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIU5VTUVSSUNfUFJPUEVSVFlfUkVHRVgudGVzdChuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuQW5kTW9uaXRvckZvcktleVVzZSgnQ2hpbGQgb2JqZWN0cyBzaG91bGQgaGF2ZSBub24tbnVtZXJpYyBrZXlzIHNvIG9yZGVyaW5nIGlzIHByZXNlcnZlZC4nLCBlbGVtZW50LCBwYXJlbnRUeXBlKTtcbn1cblxuLyoqXG4gKiBTaGFyZWQgd2FybmluZyBhbmQgbW9uaXRvcmluZyBjb2RlIGZvciB0aGUga2V5IHdhcm5pbmdzLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGJhc2Ugd2FybmluZyB0aGF0IGdldHMgb3V0cHV0LlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHdhcm5BbmRNb25pdG9yRm9yS2V5VXNlKG1lc3NhZ2UsIGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRPd25lckRpc3BsYXlOYW1lKCk7XG4gIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gIHZhciB1c2VOYW1lID0gb3duZXJOYW1lIHx8IHBhcmVudE5hbWU7XG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZ1ttZXNzYWdlXSB8fCAob3duZXJIYXNLZXlVc2VXYXJuaW5nW21lc3NhZ2VdID0ge30pO1xuICBpZiAobWVtb2l6ZXIuaGFzT3duUHJvcGVydHkodXNlTmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWVtb2l6ZXJbdXNlTmFtZV0gPSB0cnVlO1xuXG4gIHZhciBwYXJlbnRPck93bmVyQWRkZW5kdW0gPSBvd25lck5hbWUgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBvd25lck5hbWUgKyAnLicgOiBwYXJlbnROYW1lID8gJyBDaGVjayB0aGUgUmVhY3QucmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJyA6ICcnO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lckFkZGVuZHVtID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gTmFtZSBvZiB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgdmFyIGNoaWxkT3duZXJOYW1lID0gZ2V0TmFtZShlbGVtZW50Ll9vd25lcik7XG5cbiAgICBjaGlsZE93bmVyQWRkZW5kdW0gPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBjaGlsZE93bmVyTmFtZSArICcuJztcbiAgfVxuXG4gICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIHBhcmVudE9yT3duZXJBZGRlbmR1bSwgY2hpbGRPd25lckFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGZyYWdtZW50ID0gUmVhY3RGcmFnbWVudC5leHRyYWN0SWZGcmFnbWVudChub2RlKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmcmFnbWVudCkge1xuICAgICAgICBpZiAoZnJhZ21lbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhbGlkYXRlUHJvcGVydHlLZXkoa2V5LCBmcmFnbWVudFtrZXldLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BUeXBlcyBNYXAgb2YgcHJvcCBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyhjb21wb25lbnROYW1lLCBwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHByb3BUeXBlc1twcm9wTmFtZV0gPT09ICdmdW5jdGlvbicpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSwgdHlwZW9mIGVycm9yKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHdhcm5lZFByb3BzTXV0YXRpb25zID0ge307XG5cbi8qKlxuICogV2FybiBhYm91dCBtdXRhdGluZyBwcm9wcyB3aGVuIHNldHRpbmcgYHByb3BOYW1lYCBvbiBgZWxlbWVudGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIFRoZSBzdHJpbmcga2V5IHdpdGhpbiBwcm9wcyB0aGF0IHdhcyBzZXRcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHdhcm5Gb3JQcm9wc011dGF0aW9uKHByb3BOYW1lLCBlbGVtZW50KSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgZWxlbWVudE5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlIDogdHlwZS5kaXNwbGF5TmFtZTtcbiAgdmFyIG93bmVyTmFtZSA9IGVsZW1lbnQuX293bmVyID8gZWxlbWVudC5fb3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA6IG51bGw7XG5cbiAgdmFyIHdhcm5pbmdLZXkgPSBwcm9wTmFtZSArICd8JyArIGVsZW1lbnROYW1lICsgJ3wnICsgb3duZXJOYW1lO1xuICBpZiAod2FybmVkUHJvcHNNdXRhdGlvbnMuaGFzT3duUHJvcGVydHkod2FybmluZ0tleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkUHJvcHNNdXRhdGlvbnNbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gIHZhciBlbGVtZW50SW5mbyA9ICcnO1xuICBpZiAoZWxlbWVudE5hbWUpIHtcbiAgICBlbGVtZW50SW5mbyA9ICcgPCcgKyBlbGVtZW50TmFtZSArICcgLz4nO1xuICB9XG4gIHZhciBvd25lckluZm8gPSAnJztcbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIG93bmVySW5mbyA9ICcgVGhlIGVsZW1lbnQgd2FzIGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcuJztcbiAgfVxuXG4gICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnRG9uXFwndCBzZXQgLnByb3BzLiVzIG9mIHRoZSBSZWFjdCBjb21wb25lbnQlcy4gSW5zdGVhZCwgc3BlY2lmeSB0aGUgJyArICdjb3JyZWN0IHZhbHVlIHdoZW4gaW5pdGlhbGx5IGNyZWF0aW5nIHRoZSBlbGVtZW50IG9yIHVzZSAnICsgJ1JlYWN0LmNsb25lRWxlbWVudCB0byBtYWtlIGEgbmV3IGVsZW1lbnQgd2l0aCB1cGRhdGVkIHByb3BzLiVzJywgcHJvcE5hbWUsIGVsZW1lbnRJbmZvLCBvd25lckluZm8pIDogdW5kZWZpbmVkO1xufVxuXG4vLyBJbmxpbmUgT2JqZWN0LmlzIHBvbHlmaWxsXG5mdW5jdGlvbiBpcyhhLCBiKSB7XG4gIGlmIChhICE9PSBhKSB7XG4gICAgLy8gTmFOXG4gICAgcmV0dXJuIGIgIT09IGI7XG4gIH1cbiAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgIC8vICstMFxuICAgIHJldHVybiAxIC8gYSA9PT0gMSAvIGI7XG4gIH1cbiAgcmV0dXJuIGEgPT09IGI7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgY2hlY2sgaWYgaXRzIHByb3BzIGhhdmUgYmVlbiBtdXRhdGVkIHNpbmNlIGVsZW1lbnRcbiAqIGNyZWF0aW9uIChvciB0aGUgbGFzdCBjYWxsIHRvIHRoaXMgZnVuY3Rpb24pLiBJbiBwYXJ0aWN1bGFyLCBjaGVjayBpZiBhbnlcbiAqIG5ldyBwcm9wcyBoYXZlIGJlZW4gYWRkZWQsIHdoaWNoIHdlIGNhbid0IGRpcmVjdGx5IGNhdGNoIGJ5IGRlZmluaW5nIHdhcm5pbmdcbiAqIHByb3BlcnRpZXMgb24gdGhlIHByb3BzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkUHJvcHMoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlKSB7XG4gICAgLy8gRWxlbWVudCB3YXMgY3JlYXRlZCB1c2luZyBgbmV3IFJlYWN0RWxlbWVudGAgZGlyZWN0bHkgb3Igd2l0aFxuICAgIC8vIGBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudGA7IHNraXAgbXV0YXRpb24gY2hlY2tpbmdcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3JpZ2luYWxQcm9wcyA9IGVsZW1lbnQuX3N0b3JlLm9yaWdpbmFsUHJvcHM7XG4gIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBpZiAoIW9yaWdpbmFsUHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpIHx8ICFpcyhvcmlnaW5hbFByb3BzW3Byb3BOYW1lXSwgcHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICB3YXJuRm9yUHJvcHNNdXRhdGlvbihwcm9wTmFtZSwgZWxlbWVudCk7XG5cbiAgICAgICAgLy8gQ29weSBvdmVyIHRoZSBuZXcgdmFsdWUgc28gdGhhdCB0aGUgdHdvIHByb3BzIG9iamVjdHMgbWF0Y2ggYWdhaW5cbiAgICAgICAgb3JpZ2luYWxQcm9wc1twcm9wTmFtZV0gPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgaWYgKCEodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAvLyBUaGlzIGhhcyBhbHJlYWR5IHdhcm5lZC4gRG9uJ3QgdGhyb3cuXG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEV4dHJhY3QgdGhlIGNvbXBvbmVudCBjbGFzcyBmcm9tIHRoZSBlbGVtZW50LiBDb252ZXJ0cyBzdHJpbmcgdHlwZXNcbiAgLy8gdG8gYSBjb21wb3NpdGUgY2xhc3Mgd2hpY2ggbWF5IGhhdmUgcHJvcFR5cGVzLlxuICAvLyBUT0RPOiBWYWxpZGF0aW5nIGEgc3RyaW5nJ3MgcHJvcFR5cGVzIGlzIG5vdCBkZWNvdXBsZWQgZnJvbSB0aGVcbiAgLy8gcmVuZGVyaW5nIHRhcmdldCB3aGljaCBpcyBwcm9ibGVtYXRpYy5cbiAgdmFyIGNvbXBvbmVudENsYXNzID0gUmVhY3ROYXRpdmVDb21wb25lbnQuZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1Byb3BUeXBlcyhuYW1lLCBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcblxuICBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkUHJvcHM6IGNoZWNrQW5kV2FybkZvck11dGF0ZWRQcm9wcyxcblxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJywgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgc2hvdWxkIG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIGJvb2xlYW4sIG9yICcgKyAnbnVtYmVyLiBJdCBzaG91bGQgYmUgYSBzdHJpbmcgKGZvciBET00gZWxlbWVudHMpIG9yIGEgUmVhY3RDbGFzcyAnICsgJyhmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbiAgfSxcblxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudFZhbGlkYXRvcjtcblxuLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5IChlczUtc2hpbS9zaGFtIHRvbykiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbXB0eUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZU1hcFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIGNvbXBvbmVudDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2YgdGhlIFJlYWN0IElEcyBvZiB0aGUgY29tcG9uZW50cyB0aGF0IHJlbmRlcmVkIHRvXG4vLyBgbnVsbGAgKGluIHJlYWxpdHkgYSBwbGFjZWhvbGRlciBzdWNoIGFzIGBub3NjcmlwdGApXG52YXIgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5ID0ge307XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RFbXB0eUNvbXBvbmVudDogZnVuY3Rpb24gKGVtcHR5Q29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoZW1wdHlDb21wb25lbnQpO1xuICB9XG59O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcblJlYWN0RW1wdHlDb21wb25lbnRUeXBlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKTtcbiAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIHJ1biB0aGVzZSBtZXRob2RzIGluIHRoZSBjb3JyZWN0IG9yZGVyLCB3ZSBzaG91bGRuJ3RcbiAgLy8gbmVlZCB0aGlzIGNoZWNrLiBXZSdyZSBnb2luZyB0byBhc3N1bWUgaWYgd2UncmUgaGVyZSBpdCBtZWFucyB3ZSByYW5cbiAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgYWxyZWFkeSBzbyB0aGVyZSBpcyBubyBpbnRlcm5hbCBpbnN0YW5jZSAoaXQgZ2V0c1xuICAvLyByZW1vdmVkIGFzIHBhcnQgb2YgdGhlIHVubW91bnRpbmcgcHJvY2VzcykuXG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZWdpc3Rlck51bGxDb21wb25lbnRJRChpbnRlcm5hbEluc3RhbmNlLl9yb290Tm9kZUlEKTtcbn07XG5SZWFjdEVtcHR5Q29tcG9uZW50VHlwZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcyk7XG4gIC8vIFRPRE86IEdldCByaWQgb2YgdGhpcyBjaGVjay4gU2VlIFRPRE8gaW4gY29tcG9uZW50RGlkTW91bnQuXG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGludGVybmFsSW5zdGFuY2UuX3Jvb3ROb2RlSUQpO1xufTtcblJlYWN0RW1wdHlDb21wb25lbnRUeXBlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICFjb21wb25lbnQgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJldHVybiBudWxsIGZyb20gYSByZW5kZXIsIGJ1dCBubyBudWxsIHBsYWNlaG9sZGVyIGNvbXBvbmVudCAnICsgJ3dhcyBpbmplY3RlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjb21wb25lbnQoKTtcbn07XG5cbnZhciBlbXB0eUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudChSZWFjdEVtcHR5Q29tcG9uZW50VHlwZSk7XG5cbi8qKlxuICogTWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF0gPSB0cnVlO1xufVxuXG4vKipcbiAqIFVubWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsOiBpdCByZW5kZXJzIHRvIHNvbWV0aGluZyBub3cuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBkZWxldGUgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5W2lkXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCB0byBudWxsLlxuICovXG5mdW5jdGlvbiBpc051bGxDb21wb25lbnRJRChpZCkge1xuICByZXR1cm4gISFudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdO1xufVxuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHtcbiAgZW1wdHlFbGVtZW50OiBlbXB0eUVsZW1lbnQsXG4gIGluamVjdGlvbjogUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbixcbiAgaXNOdWxsQ29tcG9uZW50SUQ6IGlzTnVsbENvbXBvbmVudElEXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXJyb3JVdGlsc1xuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBndWFyZGVkIHZlcnNpb24gb2YgYSBmdW5jdGlvbi4gVGhpcyBpcyBzdXBwb3NlZCB0byBtYWtlIGRlYnVnZ2luZ1xuICAgKiBvZiBldmVudCBoYW5kbGVycyBlYXNpZXIuIFRvIGFpZCBkZWJ1Z2dpbmcgd2l0aCB0aGUgYnJvd3NlcidzIGRlYnVnZ2VyLFxuICAgKiB0aGlzIGN1cnJlbnRseSBzaW1wbHkgcmV0dXJucyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGd1YXJkXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgKi9cbiAgZ3VhcmQ6IGZ1bmN0aW9uIChmdW5jLCBuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50RW1pdHRlck1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoKTtcbn1cblxudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBlbnZpcm9ubWVudCBldmVudC5cbiAgICovXG4gIGhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCk7XG5cbiAgICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRFbWl0dGVyTWl4aW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRMaXN0ZW5lclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZShcIi4vRXZlbnRMaXN0ZW5lclwiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRUYXJnZXRcIik7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKFwiLi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblwiKTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGFyZW50IFJlYWN0IGNvbXBvbmVudCBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9IFBhcmVudCBjb250YWluZXIsIG9yIGBudWxsYCBpZiB0aGUgc3BlY2lmaWVkIG5vZGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IG5lc3RlZC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChub2RlKSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHZhciBub2RlSUQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY29udGFpbmVyKTtcbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciB0b3BMZXZlbFRhcmdldCA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTShnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpIHx8IHdpbmRvdztcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdG9wTGV2ZWxUYXJnZXQ7XG4gIHdoaWxlIChhbmNlc3Rvcikge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3BMZXZlbFRhcmdldCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICB2YXIgdG9wTGV2ZWxUYXJnZXRJRCA9IFJlYWN0TW91bnQuZ2V0SUQodG9wTGV2ZWxUYXJnZXQpIHx8ICcnO1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4qIEBwcm92aWRlc01vZHVsZSBSZWFjdEZyYWdtZW50XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLyoqXG4gKiBXZSB1c2VkIHRvIGFsbG93IGtleWVkIG9iamVjdHMgdG8gc2VydmUgYXMgYSBjb2xsZWN0aW9uIG9mIFJlYWN0RWxlbWVudHMsXG4gKiBvciBuZXN0ZWQgc2V0cy4gVGhpcyBhbGxvd2VkIHVzIGEgd2F5IHRvIGV4cGxpY2l0bHkga2V5IGEgc2V0IGEgZnJhZ21lbnQgb2ZcbiAqIGNvbXBvbmVudHMuIFRoaXMgaXMgbm93IGJlaW5nIHJlcGxhY2VkIHdpdGggYW4gb3BhcXVlIGRhdGEgc3RydWN0dXJlLlxuICogVGhlIHVwZ3JhZGUgcGF0aCBpcyB0byBjYWxsIFJlYWN0LmFkZG9ucy5jcmVhdGVGcmFnbWVudCh7IGtleTogdmFsdWUgfSkgdG9cbiAqIGNyZWF0ZSBhIGtleWVkIGZyYWdtZW50LiBUaGUgcmVzdWx0aW5nIGRhdGEgc3RydWN0dXJlIGlzIG9wYXF1ZSwgZm9yIG5vdy5cbiAqL1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICB2YXIgZnJhZ21lbnRLZXkgPSAnX3JlYWN0RnJhZ21lbnQnO1xuICB2YXIgZGlkV2FybktleSA9ICdfcmVhY3REaWRXYXJuJztcbiAgdmFyIGNhbldhcm5Gb3JSZWFjdEZyYWdtZW50ID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICAvLyBGZWF0dXJlIHRlc3QuIERvbid0IGV2ZW4gdHJ5IHRvIGlzc3VlIHRoaXMgd2FybmluZyBpZiB3ZSBjYW4ndCB1c2VcbiAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZS5cblxuICAgIHZhciBkdW1teSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIGZyYWdtZW50S2V5LCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogdHJ1ZSB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2tleScsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkdW1teSB9KTtcblxuICAgIGNhbldhcm5Gb3JSZWFjdEZyYWdtZW50ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge31cblxuICB2YXIgcHJveHlQcm9wZXJ0eUFjY2Vzc1dpdGhXYXJuaW5nID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHRoaXNbZGlkV2FybktleV0sICdBIFJlYWN0RnJhZ21lbnQgaXMgYW4gb3BhcXVlIHR5cGUuIEFjY2Vzc2luZyBhbnkgb2YgaXRzICcgKyAncHJvcGVydGllcyBpcyBkZXByZWNhdGVkLiBQYXNzIGl0IHRvIG9uZSBvZiB0aGUgUmVhY3QuQ2hpbGRyZW4gJyArICdoZWxwZXJzLicpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzW2RpZFdhcm5LZXldID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXNbZnJhZ21lbnRLZXldW2tleV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcodGhpc1tkaWRXYXJuS2V5XSwgJ0EgUmVhY3RGcmFnbWVudCBpcyBhbiBpbW11dGFibGUgb3BhcXVlIHR5cGUuIE11dGF0aW5nIGl0cyAnICsgJ3Byb3BlcnRpZXMgaXMgZGVwcmVjYXRlZC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpc1tkaWRXYXJuS2V5XSA9IHRydWU7XG4gICAgICAgIHRoaXNbZnJhZ21lbnRLZXldW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgaXNzdWVkV2FybmluZ3MgPSB7fTtcblxuICB2YXIgZGlkV2FybkZvckZyYWdtZW50ID0gZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgLy8gV2UgdXNlIHRoZSBrZXlzIGFuZCB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYXMgYSBoZXVyaXN0aWMgdG8gZGVkdXBlIHRoZVxuICAgIC8vIHdhcm5pbmcgdG8gYXZvaWQgc3BhbW1pbmcgdG9vIG11Y2guXG4gICAgdmFyIGZyYWdtZW50Q2FjaGVLZXkgPSAnJztcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJhZ21lbnQpIHtcbiAgICAgIGZyYWdtZW50Q2FjaGVLZXkgKz0ga2V5ICsgJzonICsgdHlwZW9mIGZyYWdtZW50W2tleV0gKyAnLCc7XG4gICAgfVxuICAgIHZhciBhbHJlYWR5V2FybmVkT25jZSA9ICEhaXNzdWVkV2FybmluZ3NbZnJhZ21lbnRDYWNoZUtleV07XG4gICAgaXNzdWVkV2FybmluZ3NbZnJhZ21lbnRDYWNoZUtleV0gPSB0cnVlO1xuICAgIHJldHVybiBhbHJlYWR5V2FybmVkT25jZTtcbiAgfTtcbn1cblxudmFyIFJlYWN0RnJhZ21lbnQgPSB7XG4gIC8vIFdyYXAgYSBrZXllZCBvYmplY3QgaW4gYW4gb3BhcXVlIHByb3h5IHRoYXQgd2FybnMgeW91IGlmIHlvdSBhY2Nlc3MgYW55XG4gIC8vIG9mIGl0cyBwcm9wZXJ0aWVzLlxuICBjcmVhdGU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnIHx8ICFvYmplY3QgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50IG9ubHkgYWNjZXB0cyBhIHNpbmdsZSBvYmplY3QuJywgb2JqZWN0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQob2JqZWN0KSkge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0LmFkZG9ucy5jcmVhdGVGcmFnbWVudCBkb2VzIG5vdCBhY2NlcHQgYSBSZWFjdEVsZW1lbnQgJyArICd3aXRob3V0IGEgd3JhcHBlciBvYmplY3QuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2FuV2FybkZvclJlYWN0RnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIHByb3h5ID0ge307XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgZnJhZ21lbnRLZXksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogb2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksIGRpZFdhcm5LZXksIHtcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBwcm94eVByb3BlcnR5QWNjZXNzV2l0aFdhcm5pbmcocHJveHksIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHByb3h5KTtcbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuICAvLyBFeHRyYWN0IHRoZSBvcmlnaW5hbCBrZXllZCBvYmplY3QgZnJvbSB0aGUgZnJhZ21lbnQgb3BhcXVlIHR5cGUuIFdhcm4gaWZcbiAgLy8gYSBwbGFpbiBvYmplY3QgaXMgcGFzc2VkIGhlcmUuXG4gIGV4dHJhY3Q6IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBpZiAoY2FuV2FybkZvclJlYWN0RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKCFmcmFnbWVudFtmcmFnbWVudEtleV0pIHtcbiAgICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhkaWRXYXJuRm9yRnJhZ21lbnQoZnJhZ21lbnQpLCAnQW55IHVzZSBvZiBhIGtleWVkIG9iamVjdCBzaG91bGQgYmUgd3JhcHBlZCBpbiAnICsgJ1JlYWN0LmFkZG9ucy5jcmVhdGVGcmFnbWVudChvYmplY3QpIGJlZm9yZSBiZWluZyBwYXNzZWQgYXMgYSAnICsgJ2NoaWxkLicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ21lbnRbZnJhZ21lbnRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH0sXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBmcmFnbWVudCBhbmQgaWYgc28sIGV4dHJhY3QgdGhlIGtleWVkIG9iamVjdC4gSWYgaXRcbiAgLy8gaXMgYSBmcmFnbWVudC1saWtlIG9iamVjdCwgd2FybiB0aGF0IGl0IHNob3VsZCBiZSB3cmFwcGVkLiBJZ25vcmUgaWYgd2VcbiAgLy8gY2FuJ3QgZGV0ZXJtaW5lIHdoYXQga2luZCBvZiBvYmplY3QgdGhpcyBpcy5cbiAgZXh0cmFjdElmRnJhZ21lbnQ6IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBpZiAoY2FuV2FybkZvclJlYWN0RnJhZ21lbnQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgdGhlIG9wYXF1ZSB0eXBlLCByZXR1cm4gdGhlIGtleWVkIG9iamVjdC5cbiAgICAgICAgaWYgKGZyYWdtZW50W2ZyYWdtZW50S2V5XSkge1xuICAgICAgICAgIHJldHVybiBmcmFnbWVudFtmcmFnbWVudEtleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBlYWNoIHByb3BlcnR5IGlmIGl0IGhhcyBhbiBlbGVtZW50LCBpZiBpdCBkb2VzXG4gICAgICAgIC8vIGl0IGlzIHByb2JhYmx5IG1lYW50IGFzIGEgZnJhZ21lbnQsIHNvIHdlIGNhbiB3YXJuIGVhcmx5LiBEZWZlcixcbiAgICAgICAgLy8gdGhlIHdhcm5pbmcgdG8gZXh0cmFjdC5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGZyYWdtZW50KSB7XG4gICAgICAgICAgaWYgKGZyYWdtZW50Lmhhc093blByb3BlcnR5KGtleSkgJiYgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGZyYWdtZW50W2tleV0pKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSBmcmFnbWVudCBvYmplY3QsIHdlIHNob3VsZCBwcm92aWRlIGFuXG4gICAgICAgICAgICAvLyBlYXJseSB3YXJuaW5nLlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0RnJhZ21lbnQuZXh0cmFjdChmcmFnbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZyYWdtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudFwiKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZShcIi4vUmVhY3RDbGFzc1wiKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbXB0eUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcIik7XG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdE5hdGl2ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL1JlYWN0Um9vdEluZGV4XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxuICBDbGFzczogUmVhY3RDbGFzcy5pbmplY3Rpb24sXG4gIERPTUNvbXBvbmVudDogUmVhY3RET01Db21wb25lbnQuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgTmF0aXZlQ29tcG9uZW50OiBSZWFjdE5hdGl2ZUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIFBlcmY6IFJlYWN0UGVyZi5pbmplY3Rpb24sXG4gIFJvb3RJbmRleDogUmVhY3RSb290SW5kZXguaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElucHV0U2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdERPTVNlbGVjdGlvblwiKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5zTm9kZVwiKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKFwiLi9mb2N1c05vZGVcIik7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoXCIuL2dldEFjdGl2ZUVsZW1lbnRcIik7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuXG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbSAmJiAoZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBlbGVtLm5vZGVOYW1lID09PSAnVEVYVEFSRUEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgLy8gSUU4IGlucHV0LlxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgc2VsZWN0aW9uIHBlciBkb2N1bWVudCBpbiBJRSwgc28gaXQgbXVzdFxuICAgICAgLy8gYmUgaW4gb3VyIGVsZW1lbnQuXG4gICAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xuICAgICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IC1yYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgIGVuZDogLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0gUmVhY3RET01TZWxlY3Rpb24uZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gICAqIHRoZSBpbnB1dC5cbiAgICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCwgb2Zmc2V0cykge1xuICAgIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZUhhbmRsZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSb290SW5kZXggPSByZXF1aXJlKFwiLi9SZWFjdFJvb3RJbmRleFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTRVBBUkFUT1JfTEVOR1RIID0gU0VQQVJBVE9SLmxlbmd0aDtcblxuLyoqXG4gKiBNYXhpbXVtIGRlcHRoIG9mIHRyYXZlcnNhbHMgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGJhZCBJRC5cbiAqL1xudmFyIE1BWF9UUkVFX0RFUFRIID0gMTAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBET00gSUQgcHJlZml4IHRvIHVzZSB3aGVuIG1vdW50aW5nIFJlYWN0IGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEEgdW5pcXVlIGludGVnZXJcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVhY3Qgcm9vdCBJRC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRFN0cmluZyhpbmRleCkge1xuICByZXR1cm4gU0VQQVJBVE9SICsgaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNoYXJhY3RlciBpbiB0aGUgc3VwcGxpZWQgSUQgaXMgYSBzZXBhcmF0b3Igb3IgdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdCBET00gSUQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGNoYXJhY3RlciB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNoYXJhY3RlciBpcyBhIHNlcGFyYXRvciBvciBlbmQgb2YgdGhlIElELlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCb3VuZGFyeShpZCwgaW5kZXgpIHtcbiAgcmV0dXJuIGlkLmNoYXJBdChpbmRleCkgPT09IFNFUEFSQVRPUiB8fCBpbmRleCA9PT0gaWQubGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc3VwcGxpZWQgc3RyaW5nIGlzIGEgdmFsaWQgUmVhY3QgRE9NIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRCwgbWF5YmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSUQoaWQpIHtcbiAgcmV0dXJuIGlkID09PSAnJyB8fCBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5jaGFyQXQoaWQubGVuZ3RoIC0gMSkgIT09IFNFUEFSQVRPUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGZpcnN0IElEIGlzIGFuIGFuY2VzdG9yIG9mIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQgSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFuY2VzdG9ySURcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjZW5kYW50SURcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYGFuY2VzdG9ySURgIGlzIGFuIGFuY2VzdG9yIG9mIGBkZXNjZW5kYW50SURgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzQW5jZXN0b3JJRE9mKGFuY2VzdG9ySUQsIGRlc2NlbmRhbnRJRCkge1xuICByZXR1cm4gZGVzY2VuZGFudElELmluZGV4T2YoYW5jZXN0b3JJRCkgPT09IDAgJiYgaXNCb3VuZGFyeShkZXNjZW5kYW50SUQsIGFuY2VzdG9ySUQubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgSUQgb2YgdGhlIHN1cHBsaWVkIFJlYWN0IERPTSBJRCwgYGlkYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBwYXJlbnQsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudElEKGlkKSB7XG4gIHJldHVybiBpZCA/IGlkLnN1YnN0cigwLCBpZC5sYXN0SW5kZXhPZihTRVBBUkFUT1IpKSA6ICcnO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgRE9NIElEIG9uIHRoZSB0cmVlIHBhdGggZnJvbSB0aGUgc3VwcGxpZWQgYGFuY2VzdG9ySURgIHRvIHRoZVxuICogc3VwcGxpZWQgYGRlc3RpbmF0aW9uSURgLiBJZiB0aGV5IGFyZSBlcXVhbCwgdGhlIElEIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEIElEIG9mIGFuIGFuY2VzdG9yIG5vZGUgb2YgYGRlc3RpbmF0aW9uSURgLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uSUQgSUQgb2YgdGhlIGRlc3RpbmF0aW9uIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5leHQgSUQgb24gdGhlIHBhdGggZnJvbSBgYW5jZXN0b3JJRGAgdG8gYGRlc3RpbmF0aW9uSURgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dERlc2NlbmRhbnRJRChhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSB7XG4gICEoaXNWYWxpZElEKGFuY2VzdG9ySUQpICYmIGlzVmFsaWRJRChkZXN0aW5hdGlvbklEKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0TmV4dERlc2NlbmRhbnRJRCglcywgJXMpOiBSZWNlaXZlZCBhbiBpbnZhbGlkIFJlYWN0IERPTSBJRC4nLCBhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICFpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROZXh0RGVzY2VuZGFudElEKC4uLik6IFJlYWN0IGhhcyBtYWRlIGFuIGludmFsaWQgYXNzdW1wdGlvbiBhYm91dCAnICsgJ3RoZSBET00gaGllcmFyY2h5LiBFeHBlY3RlZCBgJXNgIHRvIGJlIGFuIGFuY2VzdG9yIG9mIGAlc2AuJywgYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoYW5jZXN0b3JJRCA9PT0gZGVzdGluYXRpb25JRCkge1xuICAgIHJldHVybiBhbmNlc3RvcklEO1xuICB9XG4gIC8vIFNraXAgb3ZlciB0aGUgYW5jZXN0b3IgYW5kIHRoZSBpbW1lZGlhdGUgc2VwYXJhdG9yLiBUcmF2ZXJzZSB1bnRpbCB3ZSBoaXRcbiAgLy8gYW5vdGhlciBzZXBhcmF0b3Igb3Igd2UgcmVhY2ggdGhlIGVuZCBvZiBgZGVzdGluYXRpb25JRGAuXG4gIHZhciBzdGFydCA9IGFuY2VzdG9ySUQubGVuZ3RoICsgU0VQQVJBVE9SX0xFTkdUSDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgZGVzdGluYXRpb25JRC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KGRlc3RpbmF0aW9uSUQsIGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uSUQuc3Vic3RyKDAsIGkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIG9mIHR3byBJRHMuXG4gKlxuICogVXNpbmcgdGhpcyBJRCBzY2hlbWUsIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCBpcyB0aGUgbG9uZ2VzdCBjb21tb25cbiAqIHByZWZpeCBvZiB0aGUgdHdvIElEcyB0aGF0IGltbWVkaWF0ZWx5IHByZWNlZGVkIGEgXCJtYXJrZXJcIiBpbiBib3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9uZUlEXG4gKiBAcGFyYW0ge3N0cmluZ30gdHdvSURcbiAqIEByZXR1cm4ge3N0cmluZ30gTmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQsIG9yIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm9uZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChvbmVJRCwgdHdvSUQpIHtcbiAgdmFyIG1pbkxlbmd0aCA9IE1hdGgubWluKG9uZUlELmxlbmd0aCwgdHdvSUQubGVuZ3RoKTtcbiAgaWYgKG1pbkxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICB2YXIgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gMDtcbiAgLy8gVXNlIGA8PWAgdG8gdHJhdmVyc2UgdW50aWwgdGhlIFwiRU9MXCIgb2YgdGhlIHNob3J0ZXIgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8PSBtaW5MZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KG9uZUlELCBpKSAmJiBpc0JvdW5kYXJ5KHR3b0lELCBpKSkge1xuICAgICAgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gaTtcbiAgICB9IGVsc2UgaWYgKG9uZUlELmNoYXJBdChpKSAhPT0gdHdvSUQuY2hhckF0KGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGxvbmdlc3RDb21tb25JRCA9IG9uZUlELnN1YnN0cigwLCBsYXN0Q29tbW9uTWFya2VySW5kZXgpO1xuICAhaXNWYWxpZElEKGxvbmdlc3RDb21tb25JRCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKCVzLCAlcyk6IEV4cGVjdGVkIGEgdmFsaWQgUmVhY3QgRE9NIElEOiAlcycsIG9uZUlELCB0d29JRCwgbG9uZ2VzdENvbW1vbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBsb25nZXN0Q29tbW9uSUQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHR3byBJRHMgKGVpdGhlciB1cCBvciBkb3duKS4gVGhlIElEcyBtdXN0XG4gKiBub3QgYmUgdGhlIHNhbWUsIGFuZCB0aGVyZSBtdXN0IGV4aXN0IGEgcGFyZW50IHBhdGggYmV0d2VlbiB0aGVtLiBJZiB0aGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgdHJhdmVyc2FsIGlzIHN0b3BwZWQuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBzdGFydCBJRCBhdCB3aGljaCB0byBzdGFydCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0b3AgSUQgYXQgd2hpY2ggdG8gZW5kIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBlYWNoIElEIHdpdGguXG4gKiBAcGFyYW0gez9ib29sZWFufSBza2lwRmlyc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgZmlyc3Qgbm9kZS5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBMYXN0IFdoZXRoZXIgb3Igbm90IHRvIHNraXAgdGhlIGxhc3Qgbm9kZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlUGFyZW50UGF0aChzdGFydCwgc3RvcCwgY2IsIGFyZywgc2tpcEZpcnN0LCBza2lwTGFzdCkge1xuICBzdGFydCA9IHN0YXJ0IHx8ICcnO1xuICBzdG9wID0gc3RvcCB8fCAnJztcbiAgIShzdGFydCAhPT0gc3RvcCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKC4uLik6IENhbm5vdCB0cmF2ZXJzZSBmcm9tIGFuZCB0byB0aGUgc2FtZSBJRCwgYCVzYC4nLCBzdGFydCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgdHJhdmVyc2VVcCA9IGlzQW5jZXN0b3JJRE9mKHN0b3AsIHN0YXJ0KTtcbiAgISh0cmF2ZXJzZVVwIHx8IGlzQW5jZXN0b3JJRE9mKHN0YXJ0LCBzdG9wKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKCVzLCAlcywgLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gdHdvIElEcyB0aGF0IGRvICcgKyAnbm90IGhhdmUgYSBwYXJlbnQgcGF0aC4nLCBzdGFydCwgc3RvcCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAvLyBUcmF2ZXJzZSBmcm9tIGBzdGFydGAgdG8gYHN0b3BgIG9uZSBkZXB0aCBhdCBhIHRpbWUuXG4gIHZhciBkZXB0aCA9IDA7XG4gIHZhciB0cmF2ZXJzZSA9IHRyYXZlcnNlVXAgPyBnZXRQYXJlbnRJRCA6IGdldE5leHREZXNjZW5kYW50SUQ7XG4gIGZvciAodmFyIGlkID0gc3RhcnQ7OyBpZCA9IHRyYXZlcnNlKGlkLCBzdG9wKSkge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKCghc2tpcEZpcnN0IHx8IGlkICE9PSBzdGFydCkgJiYgKCFza2lwTGFzdCB8fCBpZCAhPT0gc3RvcCkpIHtcbiAgICAgIHJldCA9IGNiKGlkLCB0cmF2ZXJzZVVwLCBhcmcpO1xuICAgIH1cbiAgICBpZiAocmV0ID09PSBmYWxzZSB8fCBpZCA9PT0gc3RvcCkge1xuICAgICAgLy8gT25seSBicmVhayAvL2FmdGVyLy8gdmlzaXRpbmcgYHN0b3BgLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICEoZGVwdGgrKyA8IE1BWF9UUkVFX0RFUFRIKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBEZXRlY3RlZCBhbiBpbmZpbml0ZSBsb29wIHdoaWxlICcgKyAndHJhdmVyc2luZyB0aGUgUmVhY3QgRE9NIElEIHRyZWUuIFRoaXMgbWF5IGJlIGR1ZSB0byBtYWxmb3JtZWQgSURzOiAlcycsIHN0YXJ0LCBzdG9wKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBJRHMgYXNzaWduZWQgdG8gRE9NIHJlcHJlc2VudGF0aW9ucyBvZiBSZWFjdCBjb21wb25lbnRzLiBUaGlzXG4gKiB1c2VzIGEgc3BlY2lmaWMgc2NoZW1lIGluIG9yZGVyIHRvIHRyYXZlcnNlIHRoZSBET00gZWZmaWNpZW50bHkgKGUuZy4gaW5cbiAqIG9yZGVyIHRvIHNpbXVsYXRlIGV2ZW50cykuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IHJvb3QgSURcbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IHJvb3QgSUQuXG4gICAqL1xuICBjcmVhdGVSZWFjdFJvb3RJRDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRSZWFjdFJvb3RJRFN0cmluZyhSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IElEIGJ5IGpvaW5pbmcgYSByb290IElEIHdpdGggYSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFJvb3QgSUQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIGNvbXBvbmVudCdzIG5hbWUgKGFzIGZsYXR0ZW5lZCBjaGlsZHJlbikuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWFjdCBJRC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjcmVhdGVSZWFjdElEOiBmdW5jdGlvbiAocm9vdElELCBuYW1lKSB7XG4gICAgcmV0dXJuIHJvb3RJRCArIG5hbWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIERPTSBJRCBvZiB0aGUgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgdGhlIHJvb3Qgb2YgdGhlIHRyZWUgdGhhdFxuICAgKiBjb250YWlucyB0aGUgUmVhY3QgY29tcG9uZW50IHdpdGggdGhlIHN1cHBsaWVkIERPTSBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIERPTSBJRCBvZiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7P3N0cmluZ30gRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIGlmIChpZCAmJiBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKFNFUEFSQVRPUiwgMSk7XG4gICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGlkLnN1YnN0cigwLCBpbmRleCkgOiBpZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICAgKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gICAqXG4gICAqIE5PVEU6IERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2VcbiAgICogbm90aGluZyBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZWF2ZUlEIElEIGJlaW5nIGxlZnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRlcklEIElEIGJlaW5nIGVudGVyZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBlYWNoIGVudGVyZWQvbGVmdCBJRC5cbiAgICogQHBhcmFtIHsqfSB1cEFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gbGVmdCBJRHMuXG4gICAqIEBwYXJhbSB7Kn0gZG93bkFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gZW50ZXJlZCBJRHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbiAobGVhdmVJRCwgZW50ZXJJRCwgY2IsIHVwQXJnLCBkb3duQXJnKSB7XG4gICAgdmFyIGFuY2VzdG9ySUQgPSBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQobGVhdmVJRCwgZW50ZXJJRCk7XG4gICAgaWYgKGFuY2VzdG9ySUQgIT09IGxlYXZlSUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aChsZWF2ZUlELCBhbmNlc3RvcklELCBjYiwgdXBBcmcsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGFuY2VzdG9ySUQgIT09IGVudGVySUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aChhbmNlc3RvcklELCBlbnRlcklELCBjYiwgZG93bkFyZywgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXRJRCwgY2IsIGFyZykge1xuICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKHRhcmdldElELCAnJywgY2IsIGFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgdHJhdmVyc2VUd29QaGFzZWAgYnV0IHNraXBzIHRoZSBgdGFyZ2V0SURgLlxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZVNraXBUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRJRCwgY2IsIGFyZykge1xuICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlIGEgbm9kZSBJRCwgY2FsbGluZyB0aGUgc3VwcGxpZWQgYGNiYCBmb3IgZWFjaCBhbmNlc3RvciBJRC4gRm9yXG4gICAqIGV4YW1wbGUsIHBhc3NpbmcgYC4wLiRyb3ctMC4xYCB3b3VsZCByZXN1bHQgaW4gYGNiYCBnZXR0aW5nIGNhbGxlZFxuICAgKiB3aXRoIGAuMGAsIGAuMC4kcm93LTBgLCBhbmQgYC4wLiRyb3ctMC4xYC5cbiAgICpcbiAgICogTk9URTogVGhpcyB0cmF2ZXJzYWwgaGFwcGVucyBvbiBJRHMgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgZmFsc2UpO1xuICB9LFxuXG4gIGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRDogZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklELFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TmV4dERlc2NlbmRhbnRJRDogZ2V0TmV4dERlc2NlbmRhbnRJRCxcblxuICBpc0FuY2VzdG9ySURPZjogaXNBbmNlc3RvcklET2YsXG5cbiAgU0VQQVJBVE9SOiBTRVBBUkFUT1JcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlSGFuZGxlcztcbi8qIHVudGlsIGJyZWFrICovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdGFuY2VNYXBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKi9cblxuLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggRVM2OiB2YXIgUmVhY3RJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SXNvbW9ycGhpY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKFwiLi9SZWFjdENoaWxkcmVuXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRcIik7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoXCIuL1JlYWN0Q2xhc3NcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50VmFsaWRhdG9yXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoXCIuL29ubHlDaGlsZFwiKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTSxcblxuICAvLyBIb29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcgZWxzZS5cbiAgX19zcHJlYWQ6IGFzc2lnblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TGlmZUN5Y2xlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIG1hbmFnZXMgdGhlIGJvb2trZWVwaW5nIHdoZW4gYSBjb21wb25lbnQgaXMgaW4gdGhlIHByb2Nlc3NcbiAqIG9mIGJlaW5nIG1vdW50ZWQgb3IgYmVpbmcgdW5tb3VudGVkLiBUaGlzIGlzIHVzZWQgYXMgYSB3YXkgdG8gZW5mb3JjZVxuICogaW52YXJpYW50cyAob3Igd2FybmluZ3MpIHdoZW4gaXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGNhbGxcbiAqIHNldFN0YXRlL2ZvcmNlVXBkYXRlLlxuICpcbiAqIGN1cnJlbnRseU1vdW50aW5nSW5zdGFuY2U6IER1cmluZyB0aGUgY29uc3RydWN0aW9uIHBoYXNlLCBpdCBpcyBub3QgcG9zc2libGVcbiAqIHRvIHRyaWdnZXIgYW4gdXBkYXRlIHNpbmNlIHRoZSBpbnN0YW5jZSBpcyBub3QgZnVsbHkgbW91bnRlZCB5ZXQuIEhvd2V2ZXIsIHdlXG4gKiBjdXJyZW50bHkgYWxsb3cgdGhpcyBhcyBhIGNvbnZlbmllbmNlIGZvciBtdXRhdGluZyB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBjdXJyZW50bHlVbm1vdW50aW5nSW5zdGFuY2U6IER1cmluZyB0aGUgdW5tb3VudGluZyBwaGFzZSwgdGhlIGluc3RhbmNlIGlzXG4gKiBzdGlsbCBtb3VudGVkIGFuZCBjYW4gdGhlcmVmb3JlIHNjaGVkdWxlIGFuIHVwZGF0ZS4gSG93ZXZlciwgdGhpcyBpcyBub3RcbiAqIHJlY29tbWVuZGVkIGFuZCBwcm9iYWJseSBhbiBlcnJvciBzaW5jZSBpdCdzIGFib3V0IHRvIGJlIHVubW91bnRlZC5cbiAqIFRoZXJlZm9yZSB3ZSBzdGlsbCB3YW50IHRvIHRyaWdnZXIgaW4gYW4gZXJyb3IgZm9yIHRoYXQgY2FzZS5cbiAqL1xuXG52YXIgUmVhY3RMaWZlQ3ljbGUgPSB7XG4gIGN1cnJlbnRseU1vdW50aW5nSW5zdGFuY2U6IG51bGwsXG4gIGN1cnJlbnRseVVubW91bnRpbmdJbnN0YW5jZTogbnVsbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdExpZmVDeWNsZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RMaW5rXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZWFjdExpbmsgZW5jYXBzdWxhdGVzIGEgY29tbW9uIHBhdHRlcm4gaW4gd2hpY2ggYSBjb21wb25lbnQgd2FudHMgdG8gbW9kaWZ5XG4gKiBhIHByb3AgcmVjZWl2ZWQgZnJvbSBpdHMgcGFyZW50LiBSZWFjdExpbmsgYWxsb3dzIHRoZSBwYXJlbnQgdG8gcGFzcyBkb3duIGFcbiAqIHZhbHVlIGNvdXBsZWQgd2l0aCBhIGNhbGxiYWNrIHRoYXQsIHdoZW4gaW52b2tlZCwgZXhwcmVzc2VzIGFuIGludGVudCB0b1xuICogbW9kaWZ5IHRoYXQgdmFsdWUuIEZvciBleGFtcGxlOlxuICpcbiAqIFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAqICAgICByZXR1cm4ge3ZhbHVlOiAnJ307XG4gKiAgIH0sXG4gKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgdmFyIHZhbHVlTGluayA9IG5ldyBSZWFjdExpbmsodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5faGFuZGxlVmFsdWVDaGFuZ2UpO1xuICogICAgIHJldHVybiA8aW5wdXQgdmFsdWVMaW5rPXt2YWx1ZUxpbmt9IC8+O1xuICogICB9LFxuICogICB0aGlzLl9oYW5kbGVWYWx1ZUNoYW5nZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAqICAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogbmV3VmFsdWV9KTtcbiAqICAgfVxuICogfSk7XG4gKlxuICogV2UgaGF2ZSBwcm92aWRlZCBzb21lIHN1Z2FyeSBtaXhpbnMgdG8gbWFrZSB0aGUgY3JlYXRpb24gYW5kXG4gKiBjb25zdW1wdGlvbiBvZiBSZWFjdExpbmsgZWFzaWVyOyBzZWUgTGlua2VkVmFsdWVVdGlscyBhbmQgTGlua2VkU3RhdGVNaXhpbi5cbiAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwiLi9SZWFjdFwiKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGxpbmtcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlcXVlc3RDaGFuZ2UgY2FsbGJhY2sgdG8gcmVxdWVzdCBhIGNoYW5nZVxuICovXG5mdW5jdGlvbiBSZWFjdExpbmsodmFsdWUsIHJlcXVlc3RDaGFuZ2UpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLnJlcXVlc3RDaGFuZ2UgPSByZXF1ZXN0Q2hhbmdlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm9wVHlwZSB0aGF0IGVuZm9yY2VzIHRoZSBSZWFjdExpbmsgQVBJIGFuZCBvcHRpb25hbGx5IGNoZWNrcyB0aGVcbiAqIHR5cGUgb2YgdGhlIHZhbHVlIGJlaW5nIHBhc3NlZCBpbnNpZGUgdGhlIGxpbmsuIEV4YW1wbGU6XG4gKlxuICogTXlDb21wb25lbnQucHJvcFR5cGVzID0ge1xuICogICB0YWJJbmRleExpbms6IFJlYWN0TGluay5Qcm9wVHlwZXMubGluayhSZWFjdC5Qcm9wVHlwZXMubnVtYmVyKVxuICogfVxuICovXG5mdW5jdGlvbiBjcmVhdGVMaW5rVHlwZUNoZWNrZXIobGlua1R5cGUpIHtcbiAgdmFyIHNoYXBlcyA9IHtcbiAgICB2YWx1ZTogdHlwZW9mIGxpbmtUeXBlID09PSAndW5kZWZpbmVkJyA/IFJlYWN0LlByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZCA6IGxpbmtUeXBlLmlzUmVxdWlyZWQsXG4gICAgcmVxdWVzdENoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9O1xuICByZXR1cm4gUmVhY3QuUHJvcFR5cGVzLnNoYXBlKHNoYXBlcyk7XG59XG5cblJlYWN0TGluay5Qcm9wVHlwZXMgPSB7XG4gIGxpbms6IGNyZWF0ZUxpbmtUeXBlQ2hlY2tlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdExpbms7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TWFya3VwQ2hlY2tzdW1cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhZGxlcjMyID0gcmVxdWlyZShcIi4vYWRsZXIzMlwiKTtcblxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSB7XG4gIENIRUNLU1VNX0FUVFJfTkFNRTogJ2RhdGEtcmVhY3QtY2hlY2tzdW0nLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nIHdpdGggY2hlY2tzdW0gYXR0cmlidXRlIGF0dGFjaGVkXG4gICAqL1xuICBhZGRDaGVja3N1bVRvTWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXAucmVwbGFjZSgnPicsICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIj4nKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1vdW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50VmFsaWRhdG9yXCIpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVtcHR5Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZUhhbmRsZXNcIik7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VNYXBcIik7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoXCIuL1JlYWN0TWFya3VwQ2hlY2tzdW1cIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoXCIuL1JlYWN0UmVjb25jaWxlclwiKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVRdWV1ZVwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoXCIuL2VtcHR5T2JqZWN0XCIpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5zTm9kZVwiKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZShcIi4vc2V0SW5uZXJIVE1MXCIpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZShcIi4vdmFsaWRhdGVET01OZXN0aW5nXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgU0VQQVJBVE9SID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuU0VQQVJBVE9SO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgbm9kZUNhY2hlID0ge307XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLiAqL1xudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBgY29udGFpbmVyYCBub2Rlcy4gKi9cbnZhciBjb250YWluZXJzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAvKiogX19ERVZfXy1vbmx5IG1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byByb290IGVsZW1lbnRzLiAqL1xuICB2YXIgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRCA9IHt9O1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIHN0YXRlIGluIGZpbmRDb21wb25lbnRSb290LlxudmFyIGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSA9IFtdO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcbiAqL1xuZnVuY3Rpb24gZmlyc3REaWZmZXJlbmNlSW5kZXgoc3RyaW5nMSwgc3RyaW5nMikge1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xuICAgIGlmIChzdHJpbmcxLmNoYXJBdChpKSAhPT0gc3RyaW5nMi5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxuICogYSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluIGEgUmVhY3QgY29tcG9uZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gQSBcInJlYWN0Um9vdFwiIElELCBpZiBhIFJlYWN0IGNvbXBvbmVudCBpcyByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gcm9vdEVsZW1lbnQgJiYgUmVhY3RNb3VudC5nZXRJRChyb290RWxlbWVudCk7XG59XG5cbi8qKlxuICogQWNjZXNzaW5nIG5vZGVbQVRUUl9OQU1FXSBvciBjYWxsaW5nIGdldEF0dHJpYnV0ZShBVFRSX05BTUUpIG9uIGEgZm9ybVxuICogZWxlbWVudCBjYW4gcmV0dXJuIGl0cyBjb250cm9sIHdob3NlIG5hbWUgb3IgSUQgZXF1YWxzIEFUVFJfTkFNRS4gQWxsXG4gKiBET00gbm9kZXMgc3VwcG9ydCBgZ2V0QXR0cmlidXRlTm9kZWAgYnV0IHRoaXMgY2FuIGFsc28gZ2V0IGNhbGxlZCBvblxuICogb3RoZXIgb2JqZWN0cyBzbyBqdXN0IHJldHVybiAnJyBpZiB3ZSdyZSBnaXZlbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhXG4gKiBET00gbm9kZSAoc3VjaCBhcyB3aW5kb3cpLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR8RE9NV2luZG93fERPTURvY3VtZW50fERPTVRleHROb2RlfSBub2RlIERPTSBub2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBJRCBvZiB0aGUgc3VwcGxpZWQgYGRvbU5vZGVgLlxuICovXG5mdW5jdGlvbiBnZXRJRChub2RlKSB7XG4gIHZhciBpZCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChpZCkge1xuICAgIGlmIChub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB2YXIgY2FjaGVkID0gbm9kZUNhY2hlW2lkXTtcbiAgICAgIGlmIChjYWNoZWQgIT09IG5vZGUpIHtcbiAgICAgICAgISFpc1ZhbGlkKGNhY2hlZCwgaWQpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0TW91bnQ6IFR3byB2YWxpZCBidXQgdW5lcXVhbCBub2RlcyB3aXRoIHRoZSBzYW1lIGAlc2A6ICVzJywgQVRUUl9OQU1FLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBSZWFjdC1zcGVjaWZpYyBJRCBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgVGhlIERPTSBub2RlIHdob3NlIElEIHdpbGwgYmUgc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB2YWx1ZSBvZiB0aGUgSUQgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBzZXRJRChub2RlLCBpZCkge1xuICB2YXIgb2xkSUQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICBpZiAob2xkSUQgIT09IGlkKSB7XG4gICAgZGVsZXRlIG5vZGVDYWNoZVtvbGRJRF07XG4gIH1cbiAgbm9kZS5zZXRBdHRyaWJ1dGUoQVRUUl9OQU1FLCBpZCk7XG4gIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIFJlYWN0LWdlbmVyYXRlZCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsZWQgYGlkYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXROb2RlKGlkKSB7XG4gIGlmICghbm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSB8fCAhaXNWYWxpZChub2RlQ2FjaGVbaWRdLCBpZCkpIHtcbiAgICBub2RlQ2FjaGVbaWRdID0gUmVhY3RNb3VudC5maW5kUmVhY3ROb2RlQnlJRChpZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVDYWNoZVtpZF07XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgcHVibGljIFJlYWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gaW5zdGFuY2UgQSBwdWJsaWMgUmVhY3QgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdGFuY2UpLl9yb290Tm9kZUlEO1xuICBpZiAoUmVhY3RFbXB0eUNvbXBvbmVudC5pc051bGxDb21wb25lbnRJRChpZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIW5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkgfHwgIWlzVmFsaWQobm9kZUNhY2hlW2lkXSwgaWQpKSB7XG4gICAgbm9kZUNhY2hlW2lkXSA9IFJlYWN0TW91bnQuZmluZFJlYWN0Tm9kZUJ5SUQoaWQpO1xuICB9XG4gIHJldHVybiBub2RlQ2FjaGVbaWRdO1xufVxuXG4vKipcbiAqIEEgbm9kZSBpcyBcInZhbGlkXCIgaWYgaXQgaXMgY29udGFpbmVkIGJ5IGEgY3VycmVudGx5IG1vdW50ZWQgY29udGFpbmVyLlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbm9kZSBkb2VzIG5vdCBoYXZlIHRvIGJlIGNvbnRhaW5lZCBieSBhIGRvY3VtZW50IGluXG4gKiBvcmRlciB0byBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgZXhwZWN0ZWQgSUQgb2YgdGhlIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBub2RlIGlzIGNvbnRhaW5lZCBieSBhIG1vdW50ZWQgY29udGFpbmVyLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkKG5vZGUsIGlkKSB7XG4gIGlmIChub2RlKSB7XG4gICAgIShpbnRlcm5hbEdldElEKG5vZGUpID09PSBpZCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RNb3VudDogVW5leHBlY3RlZCBtb2RpZmljYXRpb24gb2YgYCVzYCcsIEFUVFJfTkFNRSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbnNOb2RlKGNvbnRhaW5lciwgbm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDYXVzZXMgdGhlIGNhY2hlIHRvIGZvcmdldCBhYm91dCBvbmUgUmVhY3Qtc3BlY2lmaWMgSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCB0byBmb3JnZXQuXG4gKi9cbmZ1bmN0aW9uIHB1cmdlSUQoaWQpIHtcbiAgZGVsZXRlIG5vZGVDYWNoZVtpZF07XG59XG5cbnZhciBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsKGFuY2VzdG9ySUQpIHtcbiAgdmFyIGFuY2VzdG9yID0gbm9kZUNhY2hlW2FuY2VzdG9ySURdO1xuICBpZiAoYW5jZXN0b3IgJiYgaXNWYWxpZChhbmNlc3RvciwgYW5jZXN0b3JJRCkpIHtcbiAgICBkZWVwZXN0Tm9kZVNvRmFyID0gYW5jZXN0b3I7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBub2RlIGlzbid0IHBvcHVsYXRlZCBpbiB0aGUgY2FjaGUsIHNvIHByZXN1bWFibHkgbm9uZSBvZiBpdHNcbiAgICAvLyBkZXNjZW5kYW50cyBhcmUuIEJyZWFrIG91dCBvZiB0aGUgbG9vcC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZXBlc3QgY2FjaGVkIG5vZGUgd2hvc2UgSUQgaXMgYSBwcmVmaXggb2YgYHRhcmdldElEYC5cbiAqL1xuZnVuY3Rpb24gZmluZERlZXBlc3RDYWNoZWRBbmNlc3Rvcih0YXJnZXRJRCkge1xuICBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbiAgUmVhY3RJbnN0YW5jZUhhbmRsZXMudHJhdmVyc2VBbmNlc3RvcnModGFyZ2V0SUQsIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsKTtcblxuICB2YXIgZm91bmROb2RlID0gZGVlcGVzdE5vZGVTb0ZhcjtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIHJldHVybiBmb3VuZE5vZGU7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gbW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmIChjb250ZXh0ID09PSBlbXB0eU9iamVjdCkge1xuICAgICAgY29udGV4dCA9IHt9O1xuICAgIH1cbiAgICB2YXIgdGFnID0gY29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB0YWcsIG51bGwpO1xuICB9XG4gIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICBjb21wb25lbnRJbnN0YW5jZS5faXNUb3BMZXZlbCA9IHRydWU7XG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXApO1xufVxuXG4vKipcbiAqIEJhdGNoZWQgbW91bnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICogQGZpbmFsXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIpIHtcbiAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQoaW5zdGFuY2UpO1xuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vZW1wdHlpbmctYS1ub2RlXG4gIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xuICogcmVwcmVzZW50YXRpdmUgRE9NIGVsZW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvIGEgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqICAgUmVhY3RNb3VudC5yZW5kZXIoXG4gKiAgICAgY29tcG9uZW50LFxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxuICogICApO1xuICpcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiAgICAgPGRpdiBkYXRhLXJlYWN0aWQ9XCIuM1wiPiAgICAgICAgICAgICAgPC0tIFJlbmRlcmVkIHJlYWN0Um9vdCBvZiBSZWFjdFxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxuICovXG52YXIgUmVhY3RNb3VudCA9IHtcbiAgLyoqIEV4cG9zZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyAqKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNoZWNrQW5kV2FybkZvck11dGF0ZWRQcm9wcyhuZXh0RWxlbWVudCk7XG4gICAgfVxuXG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50KTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKHByZXZDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXSA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNvbXBvbmVudCBpbnRvIHRoZSBpbnN0YW5jZSBtYXAgYW5kIHN0YXJ0cyBzY3JvbGwgdmFsdWVcbiAgICogbW9uaXRvcmluZ1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcmVhY3RSb290IElEIHByZWZpeFxuICAgKi9cbiAgX3JlZ2lzdGVyQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dENvbXBvbmVudCwgY29udGFpbmVyKSB7XG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5yZWdpc3RlckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gbmV4dENvbXBvbmVudDtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgbnVsbCk7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5fcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lcik7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCByZWFjdFJvb3RJRCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG5cbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgLy8gUmVjb3JkIHRoZSByb290IGVsZW1lbnQgaW4gY2FzZSBpdCBsYXRlciBnZXRzIHRyYW5zcGxhbnRlZC5cbiAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbGVtZW50IHN0cmluZywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgKyAnaXQgYnkgcGFzc2luZyBpdCB0byBSZWFjdC5jcmVhdGVFbGVtZW50LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNvbXBvbmVudCBjbGFzcywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgKyAnaXQgYnkgcGFzc2luZyBpdCB0byBSZWFjdC5jcmVhdGVFbGVtZW50LicgOlxuICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGFuIGVsZW1lbnRcbiAgICBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhjb250YWluZXIgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKV07XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFjdFJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbnRhaW5lckhhc1JlYWN0TWFya3VwID0gcmVhY3RSb290RWxlbWVudCAmJiBSZWFjdE1vdW50LmlzUmVuZGVyZWRCeVJlYWN0KHJlYWN0Um9vdEVsZW1lbnQpO1xuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChSZWFjdE1vdW50LmlzUmVuZGVyZWRCeVJlYWN0KHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IFJlYWN0TW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHBhcmVudENvbXBvbmVudCAhPSBudWxsID8gcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIDogZW1wdHlPYmplY3QpLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGNvbXBvbmVudCBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgIHdpdGggYGluaXRpYWxQcm9wc2AgYW5kXG4gICAqIHJlbmRlcnMgaXQgaW50byB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yIFJlYWN0IGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wcyBJbml0aWFsIHByb3BzIG9mIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHByb3BzLCBjb250YWluZXIpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50KGNvbnN0cnVjdG9yLCBwcm9wcyk7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQucmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBjb21wb25lbnQgaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYCB3aXRoIGBpbml0aWFsUHJvcHNgIGFuZFxuICAgKiByZW5kZXJzIGl0IGludG8gYSBjb250YWluZXIgbm9kZSBpZGVudGlmaWVkIGJ5IHN1cHBsaWVkIGBpZGAuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBvbmVudENvbnN0cnVjdG9yIFJlYWN0IGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByb3BzIEluaXRpYWwgcHJvcHMgb2YgdGhlIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiB0aGUgY29udGFpbmVyIG5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnRCeUlEOiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHByb3BzLCBpZCkge1xuICAgIHZhciBkb21Ob2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICFkb21Ob2RlID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1RyaWVkIHRvIGdldCBlbGVtZW50IHdpdGggaWQgb2YgXCIlc1wiIGJ1dCBpdCBpcyBub3QgcHJlc2VudCBvbiB0aGUgcGFnZS4nLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBSZWFjdE1vdW50LmNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudChjb25zdHJ1Y3RvciwgcHJvcHMsIGRvbU5vZGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjb250YWluZXIgbm9kZSBpbnRvIHdoaWNoIFJlYWN0IGNvbXBvbmVudHMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICogVGhpcyBhbHNvIGNyZWF0ZXMgdGhlIFwicmVhY3RSb290XCIgSUQgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBlbGVtZW50XG4gICAqIHJlbmRlcmVkIHdpdGhpbi5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgYXMgYSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFwicmVhY3RSb290XCIgSUQgb2YgZWxlbWVudHMgcmVuZGVyZWQgd2l0aGluLlxuICAgKi9cbiAgcmVnaXN0ZXJDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpO1xuICAgIGlmIChyZWFjdFJvb3RJRCkge1xuICAgICAgLy8gSWYgb25lIGV4aXN0cywgbWFrZSBzdXJlIGl0IGlzIGEgdmFsaWQgXCJyZWFjdFJvb3RcIiBJRC5cbiAgICAgIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKHJlYWN0Um9vdElEKTtcbiAgICB9XG4gICAgaWYgKCFyZWFjdFJvb3RJRCkge1xuICAgICAgLy8gTm8gdmFsaWQgXCJyZWFjdFJvb3RcIiBJRCBmb3VuZCwgY3JlYXRlIG9uZS5cbiAgICAgIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB9XG4gICAgY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gY29udGFpbmVyO1xuICAgIHJldHVybiByZWFjdFJvb3RJRDtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcblxuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpO1xuICAgIHZhciBjb21wb25lbnQgPSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBjb21wb25lbnQsIGNvbnRhaW5lcik7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGRlbGV0ZSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGRlbGV0ZSByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyBSZWFjdCBjb21wb25lbnQgdG8gd2hpY2ggdGhlXG4gICAqIHN1cHBsaWVkIERPTSBgaWRgIGJlbG9uZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgYW4gZWxlbWVudCByZW5kZXJlZCBieSBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7P0RPTUVsZW1lbnR9IERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGBpZGAuXG4gICAqL1xuICBmaW5kUmVhY3RDb250YWluZXJGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKGlkKTtcbiAgICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuXG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgICAgaWYgKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50LnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgICAgLy8gQ2FsbCBpbnRlcm5hbEdldElEIGhlcmUgYmVjYXVzZSBnZXRJRCBjYWxscyBpc1ZhbGlkIHdoaWNoIGNhbGxzXG4gICAgICAgIC8vIGZpbmRSZWFjdENvbnRhaW5lckZvcklEICh0aGlzIGZ1bmN0aW9uKS5cbiAgICAgICAgaW50ZXJuYWxHZXRJRChyb290RWxlbWVudCkgPT09IHJlYWN0Um9vdElELCAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IElEIGRpZmZlcmVkIGZyb20gcmVhY3RSb290SUQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjb250YWluZXJDaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY29udGFpbmVyQ2hpbGQgJiYgcmVhY3RSb290SUQgPT09IGludGVybmFsR2V0SUQoY29udGFpbmVyQ2hpbGQpKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBoYXMgYSBuZXcgY2hpbGQgd2l0aCB0aGUgc2FtZSBJRCBhcyB0aGUgb2xkXG4gICAgICAgICAgLy8gcm9vdCBlbGVtZW50LCB0aGVuIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdIGlzXG4gICAgICAgICAgLy8ganVzdCBzdGFsZSBhbmQgbmVlZHMgdG8gYmUgdXBkYXRlZC4gVGhlIGNhc2UgdGhhdCBkZXNlcnZlcyBhXG4gICAgICAgICAgLy8gd2FybmluZyBpcyB3aGVuIHRoZSBjb250YWluZXIgaXMgZW1wdHkuXG4gICAgICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXJDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0TW91bnQ6IFJvb3QgZWxlbWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20gaXRzIG9yaWdpbmFsICcgKyAnY29udGFpbmVyLiBOZXcgY29udGFpbmVyOicsIHJvb3RFbGVtZW50LnBhcmVudE5vZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYW4gZWxlbWVudCByZW5kZXJlZCBieSBSZWFjdCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGEgRE9NIG5vZGUgaW4gdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gUm9vdCBET00gbm9kZSBvZiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKi9cbiAgZmluZFJlYWN0Tm9kZUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciByZWFjdFJvb3QgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5maW5kQ29tcG9uZW50Um9vdChyZWFjdFJvb3QsIGlkKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgYG5vZGVgIGlzIHJlbmRlcmVkIGJ5IFJlYWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGUgRE9NIEVsZW1lbnQgdG8gY2hlY2suXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBFbGVtZW50IGFwcGVhcnMgdG8gYmUgcmVuZGVyZWQgYnkgUmVhY3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaXNSZW5kZXJlZEJ5UmVhY3Q6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIC8vIE5vdCBhIERPTUVsZW1lbnQsIHRoZXJlZm9yZSBub3QgYSBSZWFjdCBjb21wb25lbnRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlkID0gUmVhY3RNb3VudC5nZXRJRChub2RlKTtcbiAgICByZXR1cm4gaWQgPyBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiA6IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdXAgdGhlIGFuY2VzdG9ycyBvZiB0aGUgc3VwcGxpZWQgbm9kZSB0byBmaW5kIGEgbm9kZSB0aGF0IGlzIGFcbiAgICogRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGVcbiAgICogQHJldHVybiB7P0RPTUV2ZW50VGFyZ2V0fVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEZpcnN0UmVhY3RET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQucGFyZW50Tm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgaWYgKFJlYWN0TW91bnQuaXNSZW5kZXJlZEJ5UmVhY3QoY3VycmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAgaW5zaWRlIG9mIHRoZSBzdXBwbGllZFxuICAgKiBgYW5jZXN0b3JOb2RlYC4gIEV4cGxvaXRzIHRoZSBJRCBuYW1pbmcgc2NoZW1lIHRvIHBlcmZvcm0gdGhlIHNlYXJjaFxuICAgKiBxdWlja2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBhbmNlc3Rvck5vZGUgU2VhcmNoIGZyb20gdGhpcyByb290LlxuICAgKiBAcGFyYXJtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZmluZENvbXBvbmVudFJvb3Q6IGZ1bmN0aW9uIChhbmNlc3Rvck5vZGUsIHRhcmdldElEKSB7XG4gICAgdmFyIGZpcnN0Q2hpbGRyZW4gPSBmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXk7XG4gICAgdmFyIGNoaWxkSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlZXBlc3RBbmNlc3RvciA9IGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHx8IGFuY2VzdG9yTm9kZTtcblxuICAgIGZpcnN0Q2hpbGRyZW5bMF0gPSBkZWVwZXN0QW5jZXN0b3IuZmlyc3RDaGlsZDtcbiAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDE7XG5cbiAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGZpcnN0Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQgPSBmaXJzdENoaWxkcmVuW2NoaWxkSW5kZXgrK107XG4gICAgICB2YXIgdGFyZ2V0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJRCkge1xuICAgICAgICAgIC8vIEV2ZW4gaWYgd2UgZmluZCB0aGUgbm9kZSB3ZSdyZSBsb29raW5nIGZvciwgd2UgZmluaXNoIGxvb3BpbmdcbiAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBzaWJsaW5ncyB0byBlbnN1cmUgdGhleSdyZSBjYWNoZWQgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gdG8gcmV2aXNpdCB0aGlzIG5vZGUgYWdhaW4uIE90aGVyd2lzZSwgd2UgbWFrZSBuXjIgY2FsbHMgdG8gZ2V0SURcbiAgICAgICAgICAvLyB3aGVuIHZpc2l0aW5nIHRoZSBtYW55IGNoaWxkcmVuIG9mIGEgc2luZ2xlIG5vZGUgaW4gb3JkZXIuXG5cbiAgICAgICAgICBpZiAodGFyZ2V0SUQgPT09IGNoaWxkSUQpIHtcbiAgICAgICAgICAgIHRhcmdldENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChSZWFjdEluc3RhbmNlSGFuZGxlcy5pc0FuY2VzdG9ySURPZihjaGlsZElELCB0YXJnZXRJRCkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgYSBjaGlsZCB3aG9zZSBJRCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gSUQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiBiZSBzdXJlIHRoYXQgd2Ugb25seSB3YW50IHRvIHNlYXJjaCB0aGUgc3VidHJlZVxuICAgICAgICAgICAgLy8gcm9vdGVkIGF0IHRoaXMgY2hpbGQsIHNvIHdlIGNhbiB0aHJvdyBvdXQgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAvLyBzZWFyY2ggc3RhdGUuXG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IGNoaWxkSW5kZXggPSAwO1xuICAgICAgICAgICAgZmlyc3RDaGlsZHJlbi5wdXNoKGNoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGNoaWxkIGhhZCBubyBJRCwgdGhlbiB0aGVyZSdzIGEgY2hhbmNlIHRoYXQgaXQgd2FzXG4gICAgICAgICAgLy8gaW5qZWN0ZWQgYXV0b21hdGljYWxseSBieSB0aGUgYnJvd3NlciwgYXMgd2hlbiBhIGA8dGFibGU+YFxuICAgICAgICAgIC8vIGVsZW1lbnQgc3Byb3V0cyBhbiBleHRyYSBgPHRib2R5PmAgY2hpbGQgYXMgYSBzaWRlIGVmZmVjdCBvZlxuICAgICAgICAgIC8vIGAuaW5uZXJIVE1MYCBwYXJzaW5nLiBPcHRpbWlzdGljYWxseSBjb250aW51ZSBkb3duIHRoaXNcbiAgICAgICAgICAvLyBicmFuY2gsIGJ1dCBub3QgYmVmb3JlIGV4YW1pbmluZyB0aGUgb3RoZXIgc2libGluZ3MuXG4gICAgICAgICAgZmlyc3RDaGlsZHJlbi5wdXNoKGNoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldENoaWxkKSB7XG4gICAgICAgIC8vIEVtcHR5aW5nIGZpcnN0Q2hpbGRyZW4vZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5IGlzXG4gICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIGNvcnJlY3RuZXNzLCBidXQgaXQgaGVscHMgdGhlIEdDIHJlY2xhaW1cbiAgICAgICAgLy8gYW55IG5vZGVzIHRoYXQgd2VyZSBsZWZ0IGF0IHRoZSBlbmQgb2YgdGhlIHNlYXJjaC5cbiAgICAgICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXRDaGlsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAhZmFsc2UgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnZmluZENvbXBvbmVudFJvb3QoLi4uLCAlcyk6IFVuYWJsZSB0byBmaW5kIGVsZW1lbnQuIFRoaXMgcHJvYmFibHkgJyArICdtZWFucyB0aGUgRE9NIHdhcyB1bmV4cGVjdGVkbHkgbXV0YXRlZCAoZS5nLiwgYnkgdGhlIGJyb3dzZXIpLCAnICsgJ3VzdWFsbHkgZHVlIHRvIGZvcmdldHRpbmcgYSA8dGJvZHk+IHdoZW4gdXNpbmcgdGFibGVzLCBuZXN0aW5nIHRhZ3MgJyArICdsaWtlIDxmb3JtPiwgPHA+LCBvciA8YT4sIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgaW4gYW4gPHN2Zz4gJyArICdwYXJlbnQuICcgKyAnVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50IHdpdGggUmVhY3QgSUQgYCVzYC4nLCB0YXJnZXRJRCwgUmVhY3RNb3VudC5nZXRJRChhbmNlc3Rvck5vZGUpKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogZnVuY3Rpb24gKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChtYXJrdXAsIHJvb3RNYXJrdXApO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKSArICdcXG4gKHNlcnZlcikgJyArIHJvb3RNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCk7XG5cbiAgICAgICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IHVzaW5nICcgKyAnc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgJyArICdtZWFucyB5b3UgcmVuZGVyZWQgYSBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGUgb3IgcHJvcHMgb24gJyArICd0aGUgY2xpZW50IGZyb20gdGhlIG9uZSBvbiB0aGUgc2VydmVyLCBvciB5b3VyIHJlbmRlcigpICcgKyAnbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gJyArICdjcm9zcy1icm93c2VyIHF1aXJrcyBieSByZW5kZXJpbmcgYXQgdGhlIGRvY3VtZW50IHJvb3QuIFlvdSAnICsgJ3Nob3VsZCBsb29rIGZvciBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY29kZSBpbiB5b3VyIGNvbXBvbmVudHMgJyArICdhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgYXR0ZW1wdGVkIHRvIHJldXNlIG1hcmt1cCBpbiBhIGNvbnRhaW5lciBidXQgdGhlICcgKyAnY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgeW91IGFyZSAnICsgJ3VzaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSAnICsgJ3NlcnZlciB3YXMgbm90IHdoYXQgdGhlIGNsaWVudCB3YXMgZXhwZWN0aW5nLiBSZWFjdCBpbmplY3RlZCAnICsgJ25ldyBtYXJrdXAgdG8gY29tcGVuc2F0ZSB3aGljaCB3b3JrcyBidXQgeW91IGhhdmUgbG9zdCBtYW55ICcgKyAnb2YgdGhlIGJlbmVmaXRzIG9mIHNlcnZlciByZW5kZXJpbmcuIEluc3RlYWQsIGZpZ3VyZSBvdXQgJyArICd3aHkgdGhlIG1hcmt1cCBiZWluZyBnZW5lcmF0ZWQgaXMgZGlmZmVyZW50IG9uIHRoZSBjbGllbnQgJyArICdvciBzZXJ2ZXI6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCBidXQgJyArICd5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyAnICsgJ3dpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuICcgKyAnU2VlIFJlYWN0LnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhY3QgSUQgdXRpbGl0aWVzLlxuICAgKi9cblxuICBnZXRSZWFjdFJvb3RJRDogZ2V0UmVhY3RSb290SUQsXG5cbiAgZ2V0SUQ6IGdldElELFxuXG4gIHNldElEOiBzZXRJRCxcblxuICBnZXROb2RlOiBnZXROb2RlLFxuXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG5cbiAgcHVyZ2VJRDogcHVyZ2VJRFxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0TW91bnQsICdSZWFjdE1vdW50Jywge1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyxcbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogJ19tb3VudEltYWdlSW50b05vZGUnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnRcIik7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1wiKTtcblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoXCIuL1JlYWN0UmVjb25jaWxlclwiKTtcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHJlcXVpcmUoXCIuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyXCIpO1xuXG4vKipcbiAqIFVwZGF0aW5nIGNoaWxkcmVuIG9mIGEgY29tcG9uZW50IG1heSB0cmlnZ2VyIHJlY3Vyc2l2ZSB1cGRhdGVzLiBUaGUgZGVwdGggaXNcbiAqIHVzZWQgdG8gYmF0Y2ggcmVjdXJzaXZlIHVwZGF0ZXMgdG8gcmVuZGVyIG1hcmt1cCBtb3JlIGVmZmljaWVudGx5LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXBkYXRlRGVwdGggPSAwO1xuXG4vKipcbiAqIFF1ZXVlIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gKlxuICogRWFjaCBvYmplY3QgaGFzIGEgYHR5cGVgIHByb3BlcnR5IHRoYXQgaXMgaW4gYFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzYC5cbiAqXG4gKiBAdHlwZSB7YXJyYXk8b2JqZWN0Pn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIFF1ZXVlIG9mIG1hcmt1cCB0byBiZSByZW5kZXJlZC5cbiAqXG4gKiBAdHlwZSB7YXJyYXk8c3RyaW5nPn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtYXJrdXBRdWV1ZSA9IFtdO1xuXG4vKipcbiAqIEVucXVldWVzIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlTWFya3VwKHBhcmVudElELCBtYXJrdXAsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQLFxuICAgIG1hcmt1cEluZGV4OiBtYXJrdXBRdWV1ZS5wdXNoKG1hcmt1cCkgLSAxLFxuICAgIHRleHRDb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4XG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVNb3ZlKHBhcmVudElELCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIHRleHRDb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVSZW1vdmUocGFyZW50SUQsIGZyb21JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIHRleHRDb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgc2V0dGluZyB0aGUgdGV4dCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVRleHRDb250ZW50KHBhcmVudElELCB0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVCxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgaWYgKHVwZGF0ZVF1ZXVlLmxlbmd0aCkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyh1cGRhdGVRdWV1ZSwgbWFya3VwUXVldWUpO1xuICAgIGNsZWFyUXVldWUoKTtcbiAgfVxufVxuXG4vKipcbiAqIENsZWFycyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICB1cGRhdGVRdWV1ZS5sZW5ndGggPSAwO1xuICBtYXJrdXBRdWV1ZS5sZW5ndGggPSAwO1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4pO1xuICAgICAgICAvLyBUT0RPOiBUaGUgc2V0VGV4dENvbnRlbnQgb3BlcmF0aW9uIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGRCeU5hbWUocHJldkNoaWxkcmVuW25hbWVdLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICAgIHRoaXMuc2V0VGV4dENvbnRlbnQobmV4dENvbnRlbnQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wcm92ZSBwZXJmb3JtYW5jZSBieSBpc29sYXRpbmcgdGhpcyBob3QgY29kZSBwYXRoIGZyb20gdGhlIHRyeS9jYXRjaFxuICAgICAqIGJsb2NrIGluIGB1cGRhdGVDaGlsZHJlbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbmV4dEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZEJ5TmFtZShwcmV2Q2hpbGQsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB0aGlzLl9tb3VudENoaWxkQnlOYW1lQXRJbmRleChuZXh0Q2hpbGQsIG5hbWUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGRCeU5hbWUocHJldkNoaWxkcmVuW25hbWVdLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4pO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIGVucXVldWVNb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4LCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbW91bnRJbWFnZSkge1xuICAgICAgZW5xdWV1ZU1hcmt1cCh0aGlzLl9yb290Tm9kZUlELCBtb3VudEltYWdlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGVucXVldWVSZW1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHRleHRDb250ZW50KSB7XG4gICAgICBlbnF1ZXVlVGV4dENvbnRlbnQodGhpcy5fcm9vdE5vZGVJRCwgdGV4dENvbnRlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQnlOYW1lQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBuYW1lLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIG1vdW50SW1hZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZCBpbiBgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbmAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkQnlOYW1lOiBmdW5jdGlvbiAoY2hpbGQsIG5hbWUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcblxuLyoqXG4gKiBXaGVuIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYXJlIHVwZGF0ZWQsIGEgc2VyaWVzIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9uXG4gKiBvYmplY3RzIGFyZSBjcmVhdGVkIGluIG9yZGVyIHRvIGJhdGNoIGFuZCBzZXJpYWxpemUgdGhlIHJlcXVpcmVkIGNoYW5nZXMuXG4gKlxuICogRW51bWVyYXRlcyBhbGwgdGhlIHBvc3NpYmxlIHR5cGVzIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0ga2V5TWlycm9yKHtcbiAgSU5TRVJUX01BUktVUDogbnVsbCxcbiAgTU9WRV9FWElTVElORzogbnVsbCxcbiAgUkVNT1ZFX05PREU6IG51bGwsXG4gIFRFWFRfQ09OVEVOVDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TmF0aXZlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3MgPSBudWxsO1xudmFyIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IG51bGw7XG4vLyBUaGlzIHJlZ2lzdHJ5IGtlZXBzIHRyYWNrIG9mIHdyYXBwZXIgY2xhc3NlcyBhcm91bmQgbmF0aXZlIHRhZ3MuXG52YXIgdGFnVG9Db21wb25lbnRDbGFzcyA9IHt9O1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEga2V5ZWQgb2JqZWN0IHdpdGggY2xhc3NlcyBhcyB2YWx1ZXMuIEVhY2gga2V5IHJlcHJlc2VudHMgYVxuICAvLyB0YWcuIFRoYXQgcGFydGljdWxhciB0YWcgd2lsbCB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZS5cbiAgaW5qZWN0Q29tcG9uZW50Q2xhc3NlczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBhc3NpZ24odGFnVG9Db21wb25lbnRDbGFzcywgY29tcG9uZW50Q2xhc3Nlcyk7XG4gIH0sXG4gIC8vIFRlbXBvcmFyeSBoYWNrIHNpbmNlIHdlIGV4cGVjdCBET00gcmVmcyB0byBiZWhhdmUgbGlrZSBjb21wb3NpdGVzLFxuICAvLyBmb3IgdGhpcyByZWxlYXNlLlxuICBpbmplY3RBdXRvV3JhcHBlcjogZnVuY3Rpb24gKHdyYXBwZXJGYWN0b3J5KSB7XG4gICAgYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzID0gd3JhcHBlckZhY3Rvcnk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGEgY29tcG9zaXRlIGNvbXBvbmVudCB3cmFwcGVyIGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgdGFnIGZvciB3aGljaCB0byBnZXQgdGhlIGNsYXNzLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBSZWFjdCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9XG4gIHZhciB0YWcgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IHRhZ1RvQ29tcG9uZW50Q2xhc3NbdGFnXTtcbiAgaWYgKGNvbXBvbmVudENsYXNzID09IG51bGwpIHtcbiAgICB0YWdUb0NvbXBvbmVudENsYXNzW3RhZ10gPSBjb21wb25lbnRDbGFzcyA9IGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyh0YWcpO1xuICB9XG4gIHJldHVybiBjb21wb25lbnRDbGFzcztcbn1cblxuLyoqXG4gKiBHZXQgYSBuYXRpdmUgaW50ZXJuYWwgY29tcG9uZW50IGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGludGVybmFsIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XG4gICFnZW5lcmljQ29tcG9uZW50Q2xhc3MgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLCBlbGVtZW50LnR5cGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBnZW5lcmljQ29tcG9uZW50Q2xhc3MoZWxlbWVudC50eXBlLCBlbGVtZW50LnByb3BzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSB7XG4gIGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudDogZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50LFxuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdE5hdGl2ZUNvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAgICogQGZpbmFsXG4gICAqL1xuICBpc1ZhbGlkT3duZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gISEob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRvIHJlY29yZCB0aGUgcmVmLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFRoaXMgJyArICd1c3VhbGx5IG1lYW5zIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIGFkZCBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0ICcgKyAnZG9lc25cXCd0IGhhdmUgYW4gb3duZXIgKHRoYXQgaXMsIHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgb2YgYW5vdGhlciAnICsgJ2NvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kKS4gVHJ5IHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBpbnNpZGUgb2YgJyArICdhIG5ldyB0b3AtbGV2ZWwgY29tcG9uZW50IHdoaWNoIHdpbGwgaG9sZCB0aGUgcmVmLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBvd25lci5hdHRhY2hSZWYocmVmLCBjb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGJ5IHJlZiBmcm9tIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBkZXJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIG9mIHRoZSByZWYgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0aGUgcmVmIGlzIHJlY29yZGVkLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZW1vdmVDb21wb25lbnRBc1JlZkZyb206IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3JlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBUaGlzICcgKyAndXN1YWxseSBtZWFucyB0aGF0IHlvdVxcJ3JlIHRyeWluZyB0byByZW1vdmUgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCAnICsgJ2RvZXNuXFwndCBoYXZlIGFuIG93bmVyICh0aGF0IGlzLCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIG9mIGFub3RoZXIgJyArICdjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCkuIFRyeSByZW5kZXJpbmcgdGhpcyBjb21wb25lbnQgaW5zaWRlIG9mICcgKyAnYSBuZXcgdG9wLWxldmVsIGNvbXBvbmVudCB3aGljaCB3aWxsIGhvbGQgdGhlIHJlZi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gQ2hlY2sgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWYgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0b1xuICAgIC8vIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UGVyZlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVhY3RQZXJmIGlzIGEgZ2VuZXJhbCBBT1Agc3lzdGVtIGRlc2lnbmVkIHRvIG1lYXN1cmUgcGVyZm9ybWFuY2UuIFRoaXNcbiAqIG1vZHVsZSBvbmx5IGhhcyB0aGUgaG9va3M6IHNlZSBSZWFjdERlZmF1bHRQZXJmIGZvciB0aGUgYW5hbHlzaXMgdG9vbC5cbiAqL1xudmFyIFJlYWN0UGVyZiA9IHtcbiAgLyoqXG4gICAqIEJvb2xlYW4gdG8gZW5hYmxlL2Rpc2FibGUgbWVhc3VyZW1lbnQuIFNldCB0byBmYWxzZSBieSBkZWZhdWx0IHRvIHByZXZlbnRcbiAgICogYWNjaWRlbnRhbCBsb2dnaW5nIGFuZCBwZXJmIGxvc3MuXG4gICAqL1xuICBlbmFibGVNZWFzdXJlOiBmYWxzZSxcblxuICAvKipcbiAgICogSG9sZHMgb250byB0aGUgbWVhc3VyZSBmdW5jdGlvbiBpbiB1c2UuIEJ5IGRlZmF1bHQsIGRvbid0IG1lYXN1cmVcbiAgICogYW55dGhpbmcsIGJ1dCB3ZSdsbCBvdmVycmlkZSB0aGlzIGlmIHdlIGluamVjdCBhIG1lYXN1cmUgZnVuY3Rpb24uXG4gICAqL1xuICBzdG9yZWRNZWFzdXJlOiBfbm9NZWFzdXJlLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmplY3ROYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0PHN0cmluZz59IG1ldGhvZE5hbWVzXG4gICAqL1xuICBtZWFzdXJlTWV0aG9kczogZnVuY3Rpb24gKG9iamVjdCwgb2JqZWN0TmFtZSwgbWV0aG9kTmFtZXMpIHtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZE5hbWVzKSB7XG4gICAgICAgIGlmICghbWV0aG9kTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gUmVhY3RQZXJmLm1lYXN1cmUob2JqZWN0TmFtZSwgbWV0aG9kTmFtZXNba2V5XSwgb2JqZWN0W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXNlIHRoaXMgdG8gd3JhcCBtZXRob2RzIHlvdSB3YW50IHRvIG1lYXN1cmUuIFplcm8gb3ZlcmhlYWQgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgKi9cbiAgbWVhc3VyZTogZnVuY3Rpb24gKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB2YXIgbWVhc3VyZWRGdW5jID0gbnVsbDtcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUpIHtcbiAgICAgICAgICBpZiAoIW1lYXN1cmVkRnVuYykge1xuICAgICAgICAgICAgbWVhc3VyZWRGdW5jID0gUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lYXN1cmVkRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgd3JhcHBlci5kaXNwbGF5TmFtZSA9IG9iak5hbWUgKyAnXycgKyBmbk5hbWU7XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWVhc3VyZVxuICAgICAqL1xuICAgIGluamVjdE1lYXN1cmU6IGZ1bmN0aW9uIChtZWFzdXJlKSB7XG4gICAgICBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZSA9IG1lYXN1cmU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNpbXBseSBwYXNzZXMgdGhyb3VnaCB0aGUgbWVhc3VyZWQgZnVuY3Rpb24sIHdpdGhvdXQgbWVhc3VyaW5nIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gX25vTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQZXJmOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUcmFuc2ZlcmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBqb2luQ2xhc3NlcyA9IHJlcXVpcmUoXCIuL2pvaW5DbGFzc2VzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2ZlciBzdHJhdGVneSB0aGF0IHdpbGwgbWVyZ2UgcHJvcCB2YWx1ZXMgdXNpbmcgdGhlIHN1cHBsaWVkXG4gKiBgbWVyZ2VTdHJhdGVneWAuIElmIGEgcHJvcCB3YXMgcHJldmlvdXNseSB1bnNldCwgdGhpcyBqdXN0IHNldHMgaXQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWVyZ2VTdHJhdGVneVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZmVyU3RyYXRlZ3kobWVyZ2VTdHJhdGVneSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHByb3BzLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzW2tleV0gPSBtZXJnZVN0cmF0ZWd5KHByb3BzW2tleV0sIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB0cmFuc2ZlclN0cmF0ZWd5TWVyZ2UgPSBjcmVhdGVUcmFuc2ZlclN0cmF0ZWd5KGZ1bmN0aW9uIChhLCBiKSB7XG4gIC8vIGBtZXJnZWAgb3ZlcnJpZGVzIHRoZSBmaXJzdCBvYmplY3QncyAoYHByb3BzW2tleV1gIGFib3ZlKSBrZXlzIHVzaW5nIHRoZVxuICAvLyBzZWNvbmQgb2JqZWN0J3MgKGB2YWx1ZWApIGtleXMuIEFuIG9iamVjdCdzIHN0eWxlJ3MgZXhpc3RpbmcgYHByb3BBYCB3b3VsZFxuICAvLyBnZXQgb3ZlcnJpZGRlbi4gRmxpcCB0aGUgb3JkZXIgaGVyZS5cbiAgcmV0dXJuIGFzc2lnbih7fSwgYiwgYSk7XG59KTtcblxuLyoqXG4gKiBUcmFuc2ZlciBzdHJhdGVnaWVzIGRpY3RhdGUgaG93IHByb3BzIGFyZSB0cmFuc2ZlcnJlZCBieSBgdHJhbnNmZXJQcm9wc1RvYC5cbiAqIE5PVEU6IGlmIHlvdSBhZGQgYW55IG1vcmUgZXhjZXB0aW9ucyB0byB0aGlzIGxpc3QgeW91IHNob3VsZCBiZSBzdXJlIHRvXG4gKiB1cGRhdGUgYGNsb25lV2l0aFByb3BzKClgIGFjY29yZGluZ2x5LlxuICovXG52YXIgVHJhbnNmZXJTdHJhdGVnaWVzID0ge1xuICAvKipcbiAgICogTmV2ZXIgdHJhbnNmZXIgYGNoaWxkcmVuYC5cbiAgICovXG4gIGNoaWxkcmVuOiBlbXB0eUZ1bmN0aW9uLFxuICAvKipcbiAgICogVHJhbnNmZXIgdGhlIGBjbGFzc05hbWVgIHByb3AgYnkgbWVyZ2luZyB0aGVtLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBjcmVhdGVUcmFuc2ZlclN0cmF0ZWd5KGpvaW5DbGFzc2VzKSxcbiAgLyoqXG4gICAqIFRyYW5zZmVyIHRoZSBgc3R5bGVgIHByb3AgKHdoaWNoIGlzIGFuIG9iamVjdCkgYnkgbWVyZ2luZyB0aGVtLlxuICAgKi9cbiAgc3R5bGU6IHRyYW5zZmVyU3RyYXRlZ3lNZXJnZVxufTtcblxuLyoqXG4gKiBNdXRhdGVzIHRoZSBmaXJzdCBhcmd1bWVudCBieSB0cmFuc2ZlcnJpbmcgdGhlIHByb3BlcnRpZXMgZnJvbSB0aGUgc2Vjb25kXG4gKiBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiB0cmFuc2ZlckludG8ocHJvcHMsIG5ld1Byb3BzKSB7XG4gIGZvciAodmFyIHRoaXNLZXkgaW4gbmV3UHJvcHMpIHtcbiAgICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmZXJTdHJhdGVneSA9IFRyYW5zZmVyU3RyYXRlZ2llc1t0aGlzS2V5XTtcblxuICAgIGlmICh0cmFuc2ZlclN0cmF0ZWd5ICYmIFRyYW5zZmVyU3RyYXRlZ2llcy5oYXNPd25Qcm9wZXJ0eSh0aGlzS2V5KSkge1xuICAgICAgdHJhbnNmZXJTdHJhdGVneShwcm9wcywgdGhpc0tleSwgbmV3UHJvcHNbdGhpc0tleV0pO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICBwcm9wc1t0aGlzS2V5XSA9IG5ld1Byb3BzW3RoaXNLZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbi8qKlxuICogUmVhY3RQcm9wVHJhbnNmZXJlciBhcmUgY2FwYWJsZSBvZiB0cmFuc2ZlcnJpbmcgcHJvcHMgdG8gYW5vdGhlciBjb21wb25lbnRcbiAqIHVzaW5nIGEgYHRyYW5zZmVyUHJvcHNUb2AgbWV0aG9kLlxuICpcbiAqIEBjbGFzcyBSZWFjdFByb3BUcmFuc2ZlcmVyXG4gKi9cbnZhciBSZWFjdFByb3BUcmFuc2ZlcmVyID0ge1xuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gcHJvcHMgb2JqZWN0cyB1c2luZyBUcmFuc2ZlclN0cmF0ZWdpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvbGRQcm9wcyBvcmlnaW5hbCBwcm9wcyAodGhleSB0YWtlIHByZWNlZGVuY2UpXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBuZXcgcHJvcHMgdG8gbWVyZ2UgaW5cbiAgICogQHJldHVybiB7b2JqZWN0fSBhIG5ldyBvYmplY3QgY29udGFpbmluZyBib3RoIHNldHMgb2YgcHJvcHMgbWVyZ2VkLlxuICAgKi9cbiAgbWVyZ2VQcm9wczogZnVuY3Rpb24gKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIHJldHVybiB0cmFuc2ZlckludG8oYXNzaWduKHt9LCBvbGRQcm9wcyksIG5ld1Byb3BzKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFRyYW5zZmVyZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IGtleU1pcnJvcih7XG4gIHByb3A6IG51bGwsXG4gIGNvbnRleHQ6IG51bGwsXG4gIGNoaWxkQ29udGV4dDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RGcmFnbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RnJhZ21lbnRcIik7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1wiKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdSZXF1aXJlZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHdhcyBub3Qgc3BlY2lmaWVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgJycgKyBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gZXhwZWN0ZWRWYWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sICcnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCAnJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcHJvcFZhbHVlID0gUmVhY3RGcmFnbWVudC5leHRyYWN0SWZGcmFnbWVudChwcm9wVmFsdWUpO1xuICAgICAgZm9yICh2YXIgayBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05vZGUocHJvcFZhbHVlW2tdKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuICdvYmplY3QnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZShcIi4vQ2FsbGJhY2tRdWV1ZVwiKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RJbnB1dFNlbGVjdGlvblwiKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL1RyYW5zYWN0aW9uXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQsIHdoZW4gcG9zc2libGUsIHRoZSBzZWxlY3Rpb24gcmFuZ2UgKGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0XG4gKiBpbnB1dCkgaXMgbm90IGRpc3R1cmJlZCBieSBwZXJmb3JtaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIFNFTEVDVElPTl9SRVNUT1JBVElPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gU2VsZWN0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbixcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWwgU2VsZWN0aW9uIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gYGluaXRpYWxpemVgLlxuICAgKi9cbiAgY2xvc2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24ucmVzdG9yZVNlbGVjdGlvblxufTtcblxuLyoqXG4gKiBTdXBwcmVzc2VzIGV2ZW50cyAoYmx1ci9mb2N1cykgdGhhdCBjb3VsZCBiZSBpbmFkdmVydGVudGx5IGRpc3BhdGNoZWQgZHVlIHRvXG4gKiBoaWdoIGxldmVsIERPTSBtYW5pcHVsYXRpb25zIChsaWtlIHRlbXBvcmFyaWx5IHJlbW92aW5nIGEgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICogRE9NKS5cbiAqL1xudmFyIEVWRU5UX1NVUFBSRVNTSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZVxuICAgKiB0aGUgcmVjb25jaWxpYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRseUVuYWJsZWQgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaXNFbmFibGVkKCk7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQoZmFsc2UpO1xuICAgIHJldHVybiBjdXJyZW50bHlFbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXZpb3VzbHlFbmFibGVkIEVuYWJsZWQgc3RhdHVzIG9mXG4gICAqICAgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlIHRoZSByZWNvbmNpbGlhdGlvbiBvY2N1cmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIERPTSBpcyBmbHVzaGVkLCBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcy5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtTRUxFQ1RJT05fUkVTVE9SQVRJT04sIEVWRU5UX1NVUFBSRVNTSU9OLCBPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdFRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWVkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXN1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoXCIuL1JlYWN0UmVmXCIpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFZhbGlkYXRvclwiKTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gY2FsbCBSZWFjdFJlZi5hdHRhY2hSZWZzIHdpdGggdGhpcyBjb21wb3NpdGUgY29tcG9uZW50LCBzcGxpdCBvdXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpb25zIGluIHRoZSB0cmFuc2FjdGlvbiBtb3VudC1yZWFkeSBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoUmVmcygpIHtcbiAgUmVhY3RSZWYuYXR0YWNoUmVmcyh0aGlzLCB0aGlzLl9jdXJyZW50RWxlbWVudCk7XG59XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSB7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIFJlYWN0RWxlbWVudFZhbGlkYXRvci5jaGVja0FuZFdhcm5Gb3JNdXRhdGVkUHJvcHMoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBuZXh0RWxlbWVudC5fb3duZXIgIT0gbnVsbCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFByb3BzKG5leHRFbGVtZW50KTtcbiAgICB9XG5cbiAgICB2YXIgcmVmc0NoYW5nZWQgPSBSZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQpIHtcbiAgICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgcHJldkVsZW1lbnQpO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uKSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlZlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdE93bmVyXCIpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGF0dGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cblJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMgPSBmdW5jdGlvbiAocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIC8vIElmIGVpdGhlciB0aGUgb3duZXIgb3IgYSBgcmVmYCBoYXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXdlc3Qgb3duZXJcbiAgLy8gaGFzIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBgdGhpc2AsIGFuZCB0aGUgcHJldmlvdXMgb3duZXIgKGlmIGRpZmZlcmVudClcbiAgLy8gaGFzIGZvcmdvdHRlbiB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYC4gV2UgdXNlIHRoZSBlbGVtZW50IGluc3RlYWRcbiAgLy8gb2YgdGhlIHB1YmxpYyB0aGlzLnByb3BzIGJlY2F1c2UgdGhlIHBvc3QgcHJvY2Vzc2luZyBjYW5ub3QgZGV0ZXJtaW5lXG4gIC8vIGEgcmVmLiBUaGUgcmVmIGNvbmNlcHR1YWxseSBsaXZlcyBvbiB0aGUgZWxlbWVudC5cblxuICAvLyBUT0RPOiBTaG91bGQgdGhpcyBldmVuIGJlIHBvc3NpYmxlPyBUaGUgb3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlXG4gIC8vIGl0J3MgZm9yYmlkZGVuIGJ5IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LiBUaGUgcmVmIGNhbiBjaGFuZ2VcbiAgLy8gaWYgeW91IHN3YXAgdGhlIGtleXMgb2YgYnV0IG5vdCB0aGUgcmVmcy4gUmVjb25zaWRlciB3aGVyZSB0aGlzIGNoZWNrXG4gIC8vIGlzIG1hZGUuIEl0IHByb2JhYmx5IGJlbG9uZ3Mgd2hlcmUgdGhlIGtleSBjaGVja2luZyBhbmRcbiAgLy8gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCBpcyBkb25lLlxuXG4gIHJldHVybiBuZXh0RWxlbWVudC5fb3duZXIgIT09IHByZXZFbGVtZW50Ll9vd25lciB8fCBuZXh0RWxlbWVudC5yZWYgIT09IHByZXZFbGVtZW50LnJlZjtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJvb3RJbmRleEluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IF9jcmVhdGVSZWFjdFJvb3RJbmRleFxuICAgKi9cbiAgaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uIChfY3JlYXRlUmVhY3RSb290SW5kZXgpIHtcbiAgICBSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCA9IF9jcmVhdGVSZWFjdFJvb3RJbmRleDtcbiAgfVxufTtcblxudmFyIFJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogbnVsbCxcbiAgaW5qZWN0aW9uOiBSZWFjdFJvb3RJbmRleEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJvb3RJbmRleDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKFwiLi9SZWFjdE1hcmt1cENoZWNrc3VtXCIpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXCIpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKFwiLi9lbXB0eU9iamVjdFwiKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGVsZW1lbnQpIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJUb1N0cmluZygpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RFbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgdHJhbnNhY3Rpb247XG4gIHRyeSB7XG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKGZhbHNlKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICB2YXIgbWFya3VwID0gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCBlbXB0eU9iamVjdCk7XG4gICAgICByZXR1cm4gUmVhY3RNYXJrdXBDaGVja3N1bS5hZGRDaGVja3N1bVRvTWFya3VwKG1hcmt1cCk7XG4gICAgfSwgbnVsbCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBIVE1MIG1hcmt1cCwgd2l0aG91dCB0aGUgZXh0cmEgUmVhY3QgSUQgYW5kIGNoZWNrc3VtXG4gKiAoZm9yIGdlbmVyYXRpbmcgc3RhdGljIHBhZ2VzKVxuICovXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY01hcmt1cChlbGVtZW50KSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyVG9TdGF0aWNNYXJrdXAoKTogWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0RWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZCh0cnVlKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCBlbXB0eU9iamVjdCk7XG4gICAgfSwgbnVsbCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVuZGVyVG9TdHJpbmc6IHJlbmRlclRvU3RyaW5nLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogcmVuZGVyVG9TdGF0aWNNYXJrdXBcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZShcIi4vQ2FsbGJhY2tRdWV1ZVwiKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL1RyYW5zYWN0aW9uXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIGBDYWxsYmFja1F1ZXVlYCBxdWV1ZSBmb3IgY29sbGVjdGluZyBgb25ET01SZWFkeWAgY2FsbGJhY2tzXG4gKiBkdXJpbmcgdGhlIHBlcmZvcm1pbmcgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIGNsb3NlOiBlbXB0eUZ1bmN0aW9uXG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuLyoqXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXJUb1N0YXRpY01hcmt1cFxuICovXG5mdW5jdGlvbiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKHJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXl9IEVtcHR5IGxpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmVzdXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcbiAgfVxufTtcblxuYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTdGF0ZVNldHRlcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFN0YXRlU2V0dGVycyA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiwgYW5kIHVzZXMgdGhlIHJlc3VsdFxuICAgKiBvZiB0aGF0IHRvIHNldCB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb3NpdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmV0dXJuaW5nU3RhdGUgUmV0dXJuZWQgY2FsbGJhY2sgdXNlcyB0aGlzIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmUgaG93IHRvIHVwZGF0ZSBzdGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIHRoYXQgd2hlbiBpbnZva2VkIHVzZXMgZnVuY1JldHVybmluZ1N0YXRlIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVkIHRoZSBvYmplY3QgbGl0ZXJhbCB0byBzZXRTdGF0ZS5cbiAgICovXG4gIGNyZWF0ZVN0YXRlU2V0dGVyOiBmdW5jdGlvbiAoY29tcG9uZW50LCBmdW5jUmV0dXJuaW5nU3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBmdW5jUmV0dXJuaW5nU3RhdGUuY2FsbChjb21wb25lbnQsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgaWYgKHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICBjb21wb25lbnQuc2V0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2luZ2xlLWFyZ3VtZW50IGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIGEgc2luZ2xlXG4gICAqIGtleSBpbiB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgaXMgbWVtb2l6ZWQgZnVuY3Rpb24sIHdoaWNoIG1ha2VzIGl0IGluZXhwZW5zaXZlIHRvIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb3NpdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgaW4gdGhlIHN0YXRlIHRoYXQgeW91IHNob3VsZCB1cGRhdGUuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjYWxsYmFjayBvZiAxIGFyZ3VtZW50IHdoaWNoIGNhbGxzIHNldFN0YXRlKCkgd2l0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgdGhlIHByb3ZpZGVkIGtleU5hbWUgYW5kIGNhbGxiYWNrIGFyZ3VtZW50LlxuICAgKi9cbiAgY3JlYXRlU3RhdGVLZXlTZXR0ZXI6IGZ1bmN0aW9uIChjb21wb25lbnQsIGtleSkge1xuICAgIC8vIE1lbW9pemUgdGhlIHNldHRlcnMuXG4gICAgdmFyIGNhY2hlID0gY29tcG9uZW50Ll9fa2V5U2V0dGVycyB8fCAoY29tcG9uZW50Ll9fa2V5U2V0dGVycyA9IHt9KTtcbiAgICByZXR1cm4gY2FjaGVba2V5XSB8fCAoY2FjaGVba2V5XSA9IGNyZWF0ZVN0YXRlS2V5U2V0dGVyKGNvbXBvbmVudCwga2V5KSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlS2V5U2V0dGVyKGNvbXBvbmVudCwga2V5KSB7XG4gIC8vIFBhcnRpYWwgc3RhdGUgaXMgYWxsb2NhdGVkIG91dHNpZGUgb2YgdGhlIGZ1bmN0aW9uIGNsb3N1cmUgc28gaXQgY2FuIGJlXG4gIC8vIHJldXNlZCB3aXRoIGV2ZXJ5IGNhbGwsIGF2b2lkaW5nIG1lbW9yeSBhbGxvY2F0aW9uIHdoZW4gdGhpcyBmdW5jdGlvblxuICAvLyBpcyBjYWxsZWQuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0YXRlS2V5U2V0dGVyKHZhbHVlKSB7XG4gICAgcGFydGlhbFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICBjb21wb25lbnQuc2V0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgfTtcbn1cblxuUmVhY3RTdGF0ZVNldHRlcnMuTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIGFuZCB1c2VzIHRoZSByZXN1bHRcbiAgICogb2YgdGhhdCB0byBzZXQgdGhlIGNvbXBvbmVudCdzIHN0YXRlLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgdGhlc2Ugc3RhdGVtZW50cyBhcmUgZXF1aXZhbGVudDpcbiAgICpcbiAgICogICB0aGlzLnNldFN0YXRlKHt4OiAxfSk7XG4gICAqICAgdGhpcy5jcmVhdGVTdGF0ZVNldHRlcihmdW5jdGlvbih4VmFsdWUpIHtcbiAgICogICAgIHJldHVybiB7eDogeFZhbHVlfTtcbiAgICogICB9KSgxKTtcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1JldHVybmluZ1N0YXRlIFJldHVybmVkIGNhbGxiYWNrIHVzZXMgdGhpcyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lIGhvdyB0byB1cGRhdGUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjYWxsYmFjayB0aGF0IHdoZW4gaW52b2tlZCB1c2VzIGZ1bmNSZXR1cm5pbmdTdGF0ZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lZCB0aGUgb2JqZWN0IGxpdGVyYWwgdG8gc2V0U3RhdGUuXG4gICAqL1xuICBjcmVhdGVTdGF0ZVNldHRlcjogZnVuY3Rpb24gKGZ1bmNSZXR1cm5pbmdTdGF0ZSkge1xuICAgIHJldHVybiBSZWFjdFN0YXRlU2V0dGVycy5jcmVhdGVTdGF0ZVNldHRlcih0aGlzLCBmdW5jUmV0dXJuaW5nU3RhdGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2luZ2xlLWFyZ3VtZW50IGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIGEgc2luZ2xlXG4gICAqIGtleSBpbiB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCB0aGVzZSBzdGF0ZW1lbnRzIGFyZSBlcXVpdmFsZW50OlxuICAgKlxuICAgKiAgIHRoaXMuc2V0U3RhdGUoe3g6IDF9KTtcbiAgICogICB0aGlzLmNyZWF0ZVN0YXRlS2V5U2V0dGVyKCd4JykoMSk7XG4gICAqXG4gICAqIE5vdGU6IHRoaXMgaXMgbWVtb2l6ZWQgZnVuY3Rpb24sIHdoaWNoIG1ha2VzIGl0IGluZXhwZW5zaXZlIHRvIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBpbiB0aGUgc3RhdGUgdGhhdCB5b3Ugc2hvdWxkIHVwZGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIG9mIDEgYXJndW1lbnQgd2hpY2ggY2FsbHMgc2V0U3RhdGUoKSB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICB0aGUgcHJvdmlkZWQga2V5TmFtZSBhbmQgY2FsbGJhY2sgYXJndW1lbnQuXG4gICAqL1xuICBjcmVhdGVTdGF0ZUtleVNldHRlcjogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBSZWFjdFN0YXRlU2V0dGVycy5jcmVhdGVTdGF0ZUtleVNldHRlcih0aGlzLCBrZXkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U3RhdGVTZXR0ZXJzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRlc3RVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbXB0eUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlTWFwXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoXCIuL2VtcHR5T2JqZWN0XCIpO1xudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZShcIi4vZmluZERPTU5vZGVcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gRXZlbnQoc3VmZml4KSB7fVxuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFRlc3RVdGlsc1xuICovXG5cbi8qKlxuICogVG9kbzogU3VwcG9ydCB0aGUgZW50aXJlIERPTS5zY3J5IHF1ZXJ5IHN5bnRheC4gRm9yIG5vdywgdGhlc2Ugc2ltcGxlXG4gKiB1dGlsaXRpZXMgd2lsbCBzdWZmaWNlIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICogQGxlbmRzIFJlYWN0VGVzdFV0aWxzXG4gKi9cbnZhciBSZWFjdFRlc3RVdGlscyA9IHtcbiAgcmVuZGVySW50b0RvY3VtZW50OiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gTm9uZSBvZiBvdXIgdGVzdHMgYWN0dWFsbHkgcmVxdWlyZSBhdHRhY2hpbmcgdGhlIGNvbnRhaW5lciB0byB0aGVcbiAgICAvLyBET00sIGFuZCBkb2luZyBzbyBjcmVhdGVzIGEgbWVzcyB0aGF0IHdlIHJlbHkgb24gdGVzdCBpc29sYXRpb24gdG9cbiAgICAvLyBjbGVhbiB1cCwgc28gd2UncmUgZ29pbmcgdG8gc3RvcCBob25vcmluZyB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZFxuICAgIC8vIChhbmQgcHJvYmFibHkgcmVuYW1lIGl0IGV2ZW50dWFsbHkpIGlmIG5vIHByb2JsZW1zIGFyaXNlLlxuICAgIC8vIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgIHJldHVybiBSZWFjdC5yZW5kZXIoaW5zdGFuY2UsIGRpdik7XG4gIH0sXG5cbiAgaXNFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCk7XG4gIH0sXG5cbiAgaXNFbGVtZW50T2ZUeXBlOiBmdW5jdGlvbiAoaW5zdCwgY29udmVuaWVuY2VDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkgJiYgaW5zdC50eXBlID09PSBjb252ZW5pZW5jZUNvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGlzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGhldXJpc3RpYy4gSXQncyBqdXN0IGhlcmUgYmVjYXVzZSBjb21wb3NpdGVzIGNhbiBjdXJyZW50bHlcbiAgICAvLyBwcmV0ZW5kIHRvIGJlIERPTSBjb21wb25lbnRzLlxuICAgIHJldHVybiAhIShpbnN0ICYmIGluc3QudGFnTmFtZSAmJiBpbnN0LmdldERPTU5vZGUpO1xuICB9LFxuXG4gIGlzRE9NQ29tcG9uZW50RWxlbWVudDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gISEoaW5zdCAmJiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkgJiYgISFpbnN0LnRhZ05hbWUpO1xuICB9LFxuXG4gIGlzQ29tcG9zaXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5zdC5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3Quc2V0U3RhdGUgPT09ICdmdW5jdGlvbic7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnRXaXRoVHlwZTogZnVuY3Rpb24gKGluc3QsIHR5cGUpIHtcbiAgICByZXR1cm4gISEoUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnQoaW5zdCkgJiYgaW5zdC5jb25zdHJ1Y3RvciA9PT0gdHlwZSk7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnRFbGVtZW50OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGluc3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFdlIGNoZWNrIHRoZSBwcm90b3R5cGUgb2YgdGhlIHR5cGUgdGhhdCB3aWxsIGdldCBtb3VudGVkLCBub3QgdGhlXG4gICAgLy8gaW5zdGFuY2UgaXRzZWxmLiBUaGlzIGlzIGEgZnV0dXJlIHByb29mIHdheSBvZiBkdWNrIHR5cGluZy5cbiAgICB2YXIgcHJvdG90eXBlID0gaW5zdC50eXBlLnByb3RvdHlwZTtcbiAgICByZXR1cm4gdHlwZW9mIHByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHByb3RvdHlwZS5zZXRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSxcblxuICBpc0NvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnRXaXRoVHlwZTogZnVuY3Rpb24gKGluc3QsIHR5cGUpIHtcbiAgICByZXR1cm4gISEoUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnRFbGVtZW50KGluc3QpICYmIGluc3QuY29uc3RydWN0b3IgPT09IHR5cGUpO1xuICB9LFxuXG4gIGdldFJlbmRlcmVkQ2hpbGRPZkNvbXBvc2l0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICBpZiAoIVJlYWN0VGVzdFV0aWxzLmlzQ29tcG9zaXRlQ29tcG9uZW50KGluc3QpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0KTtcbiAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgfSxcblxuICBmaW5kQWxsSW5SZW5kZXJlZFRyZWU6IGZ1bmN0aW9uIChpbnN0LCB0ZXN0KSB7XG4gICAgaWYgKCFpbnN0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciByZXQgPSB0ZXN0KGluc3QpID8gW2luc3RdIDogW107XG4gICAgaWYgKFJlYWN0VGVzdFV0aWxzLmlzRE9NQ29tcG9uZW50KGluc3QpKSB7XG4gICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpO1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSBpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciBrZXk7XG4gICAgICBmb3IgKGtleSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghcmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZW5kZXJlZENoaWxkcmVuW2tleV0uZ2V0UHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KFJlYWN0VGVzdFV0aWxzLmZpbmRBbGxJblJlbmRlcmVkVHJlZShyZW5kZXJlZENoaWxkcmVuW2tleV0uZ2V0UHVibGljSW5zdGFuY2UoKSwgdGVzdCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnQoaW5zdCkpIHtcbiAgICAgIHJldCA9IHJldC5jb25jYXQoUmVhY3RUZXN0VXRpbHMuZmluZEFsbEluUmVuZGVyZWRUcmVlKFJlYWN0VGVzdFV0aWxzLmdldFJlbmRlcmVkQ2hpbGRPZkNvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSwgdGVzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgaW5zdGFuY2Ugb2YgY29tcG9uZW50cyBpbiB0aGUgcmVuZGVyZWQgdHJlZSB0aGF0IGFyZSBET01cbiAgICogY29tcG9uZW50cyB3aXRoIHRoZSBjbGFzcyBuYW1lIG1hdGNoaW5nIGBjbGFzc05hbWVgLlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAgICovXG4gIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3M6IGZ1bmN0aW9uIChyb290LCBjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gUmVhY3RUZXN0VXRpbHMuZmluZEFsbEluUmVuZGVyZWRUcmVlKHJvb3QsIGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICB2YXIgaW5zdENsYXNzTmFtZSA9IGluc3QucHJvcHMuY2xhc3NOYW1lO1xuICAgICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmlzRE9NQ29tcG9uZW50KGluc3QpICYmIChpbnN0Q2xhc3NOYW1lICYmICgnICcgKyBpbnN0Q2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgIT09IC0xKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTGlrZSBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHQsXG4gICAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAgICogbnVtYmVyIG9mIG1hdGNoZXMgYmVzaWRlcyBvbmUuXG4gICAqIEByZXR1cm4geyFSZWFjdERPTUNvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAgICovXG4gIGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhDbGFzczogZnVuY3Rpb24gKHJvb3QsIGNsYXNzTmFtZSkge1xuICAgIHZhciBhbGwgPSBSZWFjdFRlc3RVdGlscy5zY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzKHJvb3QsIGNsYXNzTmFtZSk7XG4gICAgaWYgKGFsbC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGV4YWN0bHkgb25lIG1hdGNoICcgKyAnKGZvdW5kOiAnICsgYWxsLmxlbmd0aCArICcpIGZvciBjbGFzczonICsgY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbFswXTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYWxsIGluc3RhbmNlIG9mIGNvbXBvbmVudHMgaW4gdGhlIHJlbmRlcmVkIHRyZWUgdGhhdCBhcmUgRE9NXG4gICAqIGNvbXBvbmVudHMgd2l0aCB0aGUgdGFnIG5hbWUgbWF0Y2hpbmcgYHRhZ05hbWVgLlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAgICovXG4gIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnOiBmdW5jdGlvbiAocm9vdCwgdGFnTmFtZSkge1xuICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChpbnN0KSAmJiBpbnN0LnRhZ05hbWUgPT09IHRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTGlrZSBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aFRhZyBidXQgZXhwZWN0cyB0aGVyZSB0byBiZSBvbmUgcmVzdWx0LFxuICAgKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gICAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICAgKiBAcmV0dXJuIHshUmVhY3RET01Db21wb25lbnR9IFRoZSBvbmUgbWF0Y2guXG4gICAqL1xuICBmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoVGFnOiBmdW5jdGlvbiAocm9vdCwgdGFnTmFtZSkge1xuICAgIHZhciBhbGwgPSBSZWFjdFRlc3RVdGlscy5zY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aFRhZyhyb290LCB0YWdOYW1lKTtcbiAgICBpZiAoYWxsLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGZpbmQgZXhhY3RseSBvbmUgbWF0Y2ggZm9yIHRhZzonICsgdGFnTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBhbGxbMF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBpbnN0YW5jZXMgb2YgY29tcG9uZW50cyB3aXRoIHR5cGUgZXF1YWwgdG8gYGNvbXBvbmVudFR5cGVgLlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAgICovXG4gIHNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZTogZnVuY3Rpb24gKHJvb3QsIGNvbXBvbmVudFR5cGUpIHtcbiAgICByZXR1cm4gUmVhY3RUZXN0VXRpbHMuZmluZEFsbEluUmVuZGVyZWRUcmVlKHJvb3QsIGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICByZXR1cm4gUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnRXaXRoVHlwZShpbnN0LCBjb21wb25lbnRUeXBlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgc2NyeVJlbmRlcmVkQ29tcG9uZW50c1dpdGhUeXBlYCBidXQgZXhwZWN0cyB0aGVyZSB0byBiZSBvbmUgcmVzdWx0XG4gICAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAgICogbnVtYmVyIG9mIG1hdGNoZXMgYmVzaWRlcyBvbmUuXG4gICAqIEByZXR1cm4geyFSZWFjdENvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAgICovXG4gIGZpbmRSZW5kZXJlZENvbXBvbmVudFdpdGhUeXBlOiBmdW5jdGlvbiAocm9vdCwgY29tcG9uZW50VHlwZSkge1xuICAgIHZhciBhbGwgPSBSZWFjdFRlc3RVdGlscy5zY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGUocm9vdCwgY29tcG9uZW50VHlwZSk7XG4gICAgaWYgKGFsbC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGV4YWN0bHkgb25lIG1hdGNoIGZvciBjb21wb25lbnRUeXBlOicgKyBjb21wb25lbnRUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbFswXTtcbiAgfSxcblxuICAvKipcbiAgICogUGFzcyBhIG1vY2tlZCBjb21wb25lbnQgbW9kdWxlIHRvIHRoaXMgbWV0aG9kIHRvIGF1Z21lbnQgaXQgd2l0aFxuICAgKiB1c2VmdWwgbWV0aG9kcyB0aGF0IGFsbG93IGl0IHRvIGJlIHVzZWQgYXMgYSBkdW1teSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEluc3RlYWQgb2YgcmVuZGVyaW5nIGFzIHVzdWFsLCB0aGUgY29tcG9uZW50IHdpbGwgYmVjb21lIGEgc2ltcGxlXG4gICAqIDxkaXY+IGNvbnRhaW5pbmcgYW55IHByb3ZpZGVkIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbW9kdWxlIHRoZSBtb2NrIGZ1bmN0aW9uIG9iamVjdCBleHBvcnRlZCBmcm9tIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdGhhdCBkZWZpbmVzIHRoZSBjb21wb25lbnQgdG8gYmUgbW9ja2VkXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbW9ja1RhZ05hbWUgb3B0aW9uYWwgZHVtbXkgcm9vdCB0YWcgbmFtZSB0byByZXR1cm5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHJlbmRlciBtZXRob2QgKG92ZXJyaWRlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5tb2NrVGFnTmFtZSBpZiBwcm92aWRlZClcbiAgICogQHJldHVybiB7b2JqZWN0fSB0aGUgUmVhY3RUZXN0VXRpbHMgb2JqZWN0IChmb3IgY2hhaW5pbmcpXG4gICAqL1xuICBtb2NrQ29tcG9uZW50OiBmdW5jdGlvbiAobW9kdWxlLCBtb2NrVGFnTmFtZSkge1xuICAgIG1vY2tUYWdOYW1lID0gbW9ja1RhZ05hbWUgfHwgbW9kdWxlLm1vY2tUYWdOYW1lIHx8ICdkaXYnO1xuXG4gICAgbW9kdWxlLnByb3RvdHlwZS5yZW5kZXIubW9ja0ltcGxlbWVudGF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KG1vY2tUYWdOYW1lLCBudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgYSB0b3AgbGV2ZWwgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIGEgcmF3IGV2ZW50IHRoYXQgb2NjdXJlZFxuICAgKiBvbiBhbiBgRWxlbWVudGAgbm9kZS5cbiAgICogQHBhcmFtIHRvcExldmVsVHlwZSB7T2JqZWN0fSBBIHR5cGUgZnJvbSBgRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc2BcbiAgICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBUaGUgZG9tIHRvIHNpbXVsYXRlIGFuIGV2ZW50IG9jY3VycmluZyBvbi5cbiAgICogQHBhcmFtIHs/RXZlbnR9IGZha2VOYXRpdmVFdmVudCBGYWtlIG5hdGl2ZSBldmVudCB0byB1c2UgaW4gU3ludGhldGljRXZlbnQuXG4gICAqL1xuICBzaW11bGF0ZU5hdGl2ZUV2ZW50T25Ob2RlOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBub2RlLCBmYWtlTmF0aXZlRXZlbnQpIHtcbiAgICBmYWtlTmF0aXZlRXZlbnQudGFyZ2V0ID0gbm9kZTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBmYWtlTmF0aXZlRXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgYSB0b3AgbGV2ZWwgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIGEgcmF3IGV2ZW50IHRoYXQgb2NjdXJlZFxuICAgKiBvbiB0aGUgYFJlYWN0RE9NQ29tcG9uZW50YCBgY29tcGAuXG4gICAqIEBwYXJhbSB0b3BMZXZlbFR5cGUge09iamVjdH0gQSB0eXBlIGZyb20gYEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXNgLlxuICAgKiBAcGFyYW0gY29tcCB7IVJlYWN0RE9NQ29tcG9uZW50fVxuICAgKiBAcGFyYW0gez9FdmVudH0gZmFrZU5hdGl2ZUV2ZW50IEZha2UgbmF0aXZlIGV2ZW50IHRvIHVzZSBpbiBTeW50aGV0aWNFdmVudC5cbiAgICovXG4gIHNpbXVsYXRlTmF0aXZlRXZlbnRPbkRPTUNvbXBvbmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgY29tcCwgZmFrZU5hdGl2ZUV2ZW50KSB7XG4gICAgUmVhY3RUZXN0VXRpbHMuc2ltdWxhdGVOYXRpdmVFdmVudE9uTm9kZSh0b3BMZXZlbFR5cGUsIGZpbmRET01Ob2RlKGNvbXApLCBmYWtlTmF0aXZlRXZlbnQpO1xuICB9LFxuXG4gIG5hdGl2ZVRvdWNoRGF0YTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG91Y2hlczogW3sgcGFnZVg6IHgsIHBhZ2VZOiB5IH1dXG4gICAgfTtcbiAgfSxcblxuICBjcmVhdGVSZW5kZXJlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUmVhY3RTaGFsbG93UmVuZGVyZXIoKTtcbiAgfSxcblxuICBTaW11bGF0ZTogbnVsbCxcbiAgU2ltdWxhdGVOYXRpdmU6IHt9XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNoYWxsb3dSZW5kZXJlclxuICovXG52YXIgUmVhY3RTaGFsbG93UmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbn07XG5cblJlYWN0U2hhbGxvd1JlbmRlcmVyLnByb3RvdHlwZS5nZXRSZW5kZXJPdXRwdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQgJiYgdGhpcy5faW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll9yZW5kZXJlZE91dHB1dCB8fCBudWxsO1xufTtcblxudmFyIE5vb3BJbnRlcm5hbENvbXBvbmVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuX3JlbmRlcmVkT3V0cHV0ID0gZWxlbWVudDtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlID8gUmVhY3RFbXB0eUNvbXBvbmVudC5lbXB0eUVsZW1lbnQgOiBlbGVtZW50O1xufTtcblxuTm9vcEludGVybmFsQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcblxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9yZW5kZXJlZE91dHB1dCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlID8gUmVhY3RFbXB0eUNvbXBvbmVudC5lbXB0eUVsZW1lbnQgOiBlbGVtZW50O1xuICB9LFxuXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9XG5cbn07XG5cbnZhciBTaGFsbG93Q29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFNoYWxsb3dDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQuTWl4aW4sIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBOb29wSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gIH0sXG4gIF9yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBmdW5jdGlvbiAoKSB7fSxcbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogUmVhY3RDb21wb3NpdGVDb21wb25lbnQuTWl4aW4uX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dFxufSk7XG5cblJlYWN0U2hhbGxvd1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gIH1cbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gIHRoaXMuX3JlbmRlcihlbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufTtcblxuUmVhY3RTaGFsbG93UmVuZGVyZXIucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgIHRoaXMuX2luc3RhbmNlLnVubW91bnRDb21wb25lbnQoKTtcbiAgfVxufTtcblxuUmVhY3RTaGFsbG93UmVuZGVyZXIucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgIHZhciByb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBTaGFsbG93Q29tcG9uZW50V3JhcHBlcihlbGVtZW50LnR5cGUpO1xuICAgIGluc3RhbmNlLmNvbnN0cnVjdChlbGVtZW50KTtcblxuICAgIGluc3RhbmNlLm1vdW50Q29tcG9uZW50KHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9pbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KGVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeHBvcnRzOlxuICpcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlLmNsaWNrKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUubW91c2VNb3ZlKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUuY2hhbmdlKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSAuLi4gKEFsbCBrZXlzIGZyb20gZXZlbnQgcGx1Z2luIGBldmVudFR5cGVzYCBvYmplY3RzKVxuICovXG5mdW5jdGlvbiBtYWtlU2ltdWxhdG9yKGV2ZW50VHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGRvbUNvbXBvbmVudE9yTm9kZSwgZXZlbnREYXRhKSB7XG4gICAgdmFyIG5vZGU7XG4gICAgaWYgKFJlYWN0VGVzdFV0aWxzLmlzRE9NQ29tcG9uZW50KGRvbUNvbXBvbmVudE9yTm9kZSkpIHtcbiAgICAgIG5vZGUgPSBmaW5kRE9NTm9kZShkb21Db21wb25lbnRPck5vZGUpO1xuICAgIH0gZWxzZSBpZiAoZG9tQ29tcG9uZW50T3JOb2RlLnRhZ05hbWUpIHtcbiAgICAgIG5vZGUgPSBkb21Db21wb25lbnRPck5vZGU7XG4gICAgfVxuXG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudFR5cGVdO1xuXG4gICAgdmFyIGZha2VOYXRpdmVFdmVudCA9IG5ldyBFdmVudCgpO1xuICAgIGZha2VOYXRpdmVFdmVudC50YXJnZXQgPSBub2RlO1xuICAgIC8vIFdlIGRvbid0IHVzZSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQgaW4gb3JkZXIgdG8gbm90IGhhdmUgdG8gd29ycnkgYWJvdXRcbiAgICAvLyBwcm9wZXJseSBkZXN0cm95aW5nIGFueSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGZyb20gYGV2ZW50RGF0YWAgdXBvbiByZWxlYXNlXG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBSZWFjdE1vdW50LmdldElEKG5vZGUpLCBmYWtlTmF0aXZlRXZlbnQpO1xuICAgIGFzc2lnbihldmVudCwgZXZlbnREYXRhKTtcblxuICAgIGlmIChkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudCk7XG4gICAgfVxuXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICAgICAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTaW11bGF0b3JzKCkge1xuICBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSA9IHt9O1xuXG4gIHZhciBldmVudFR5cGU7XG4gIGZvciAoZXZlbnRUeXBlIGluIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFFbGVtZW50IHx8IFJlYWN0RE9NQ29tcG9uZW50fSBkb21Db21wb25lbnRPck5vZGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50RGF0YSBGYWtlIGV2ZW50IGRhdGEgdG8gdXNlIGluIFN5bnRoZXRpY0V2ZW50LlxuICAgICAqL1xuICAgIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlW2V2ZW50VHlwZV0gPSBtYWtlU2ltdWxhdG9yKGV2ZW50VHlwZSk7XG4gIH1cbn1cblxuLy8gUmVidWlsZCBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSB3aGVuZXZlciBldmVudCBwbHVnaW5zIGFyZSBpbmplY3RlZFxudmFyIG9sZEluamVjdEV2ZW50UGx1Z2luT3JkZXIgPSBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjtcbkV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyID0gZnVuY3Rpb24gKCkge1xuICBvbGRJbmplY3RFdmVudFBsdWdpbk9yZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGJ1aWxkU2ltdWxhdG9ycygpO1xufTtcbnZhciBvbGRJbmplY3RFdmVudFBsdWdpbnMgPSBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lO1xuRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgb2xkSW5qZWN0RXZlbnRQbHVnaW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGJ1aWxkU2ltdWxhdG9ycygpO1xufTtcblxuYnVpbGRTaW11bGF0b3JzKCk7XG5cbi8qKlxuICogRXhwb3J0czpcbiAqXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZU5hdGl2ZS5jbGljayhFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlLm1vdXNlTW92ZShFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlLm1vdXNlSW4vUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVOYXRpdmUubW91c2VPdXQoRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIC4uLiAoQWxsIGtleXMgZnJvbSBgRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc2ApXG4gKlxuICogTm90ZTogVG9wIGxldmVsIGV2ZW50IHR5cGVzIGFyZSBhIHN1YnNldCBvZiB0aGUgZW50aXJlIHNldCBvZiBoYW5kbGVyIHR5cGVzXG4gKiAod2hpY2ggaW5jbHVkZSBhIGJyb2FkZXIgc2V0IG9mIFwic3ludGhldGljXCIgZXZlbnRzKS4gRm9yIGV4YW1wbGUsIG9uRHJhZ0RvbmVcbiAqIGlzIGEgc3ludGhldGljIGV2ZW50LiBFeGNlcHQgd2hlbiB0ZXN0aW5nIGFuIGV2ZW50IHBsdWdpbiBvciBSZWFjdCdzIGV2ZW50XG4gKiBoYW5kbGluZyBjb2RlIHNwZWNpZmljYWxseSwgeW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlXG4gKiB0byBkaXNwYXRjaCBzeW50aGV0aWMgZXZlbnRzLlxuICovXG5cbmZ1bmN0aW9uIG1ha2VOYXRpdmVTaW11bGF0b3IoZXZlbnRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZG9tQ29tcG9uZW50T3JOb2RlLCBuYXRpdmVFdmVudERhdGEpIHtcbiAgICB2YXIgZmFrZU5hdGl2ZUV2ZW50ID0gbmV3IEV2ZW50KGV2ZW50VHlwZSk7XG4gICAgYXNzaWduKGZha2VOYXRpdmVFdmVudCwgbmF0aXZlRXZlbnREYXRhKTtcbiAgICBpZiAoUmVhY3RUZXN0VXRpbHMuaXNET01Db21wb25lbnQoZG9tQ29tcG9uZW50T3JOb2RlKSkge1xuICAgICAgUmVhY3RUZXN0VXRpbHMuc2ltdWxhdGVOYXRpdmVFdmVudE9uRE9NQ29tcG9uZW50KGV2ZW50VHlwZSwgZG9tQ29tcG9uZW50T3JOb2RlLCBmYWtlTmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSBpZiAoISFkb21Db21wb25lbnRPck5vZGUudGFnTmFtZSkge1xuICAgICAgLy8gV2lsbCBhbGxvdyBvbiBhY3R1YWwgZG9tIG5vZGVzLlxuICAgICAgUmVhY3RUZXN0VXRpbHMuc2ltdWxhdGVOYXRpdmVFdmVudE9uTm9kZShldmVudFR5cGUsIGRvbUNvbXBvbmVudE9yTm9kZSwgZmFrZU5hdGl2ZUV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBldmVudFR5cGU7XG5mb3IgKGV2ZW50VHlwZSBpbiB0b3BMZXZlbFR5cGVzKSB7XG4gIC8vIEV2ZW50IHR5cGUgaXMgc3RvcmVkIGFzICd0b3BDbGljaycgLSB3ZSB0cmFuc2Zvcm0gdGhhdCB0byAnY2xpY2snXG4gIHZhciBjb252ZW5pZW5jZU5hbWUgPSBldmVudFR5cGUuaW5kZXhPZigndG9wJykgPT09IDAgPyBldmVudFR5cGUuY2hhckF0KDMpLnRvTG93ZXJDYXNlKCkgKyBldmVudFR5cGUuc3Vic3RyKDQpIDogZXZlbnRUeXBlO1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudCB8fCBSZWFjdERPTUNvbXBvbmVudH0gZG9tQ29tcG9uZW50T3JOb2RlXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBuYXRpdmVFdmVudERhdGEgRmFrZSBuYXRpdmUgZXZlbnQgdG8gdXNlIGluIFN5bnRoZXRpY0V2ZW50LlxuICAgKi9cbiAgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVOYXRpdmVbY29udmVuaWVuY2VOYW1lXSA9IG1ha2VOYXRpdmVTaW11bGF0b3IoZXZlbnRUeXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFRlc3RVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKFwiLi9SZWFjdENoaWxkcmVuXCIpO1xudmFyIFJlYWN0RnJhZ21lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEZyYWdtZW50XCIpO1xuXG52YXIgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nID0ge1xuICAvKipcbiAgICogR2l2ZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gLCByZXR1cm4gYW4gb2JqZWN0IG1hcHBpbmcga2V5IHRvIGNoaWxkLiBKdXN0XG4gICAqIHNpbXBsZSBzeW50YWN0aWMgc3VnYXIgYXJvdW5kIFJlYWN0Q2hpbGRyZW4ubWFwKCkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gY2hpbGRyZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gXG4gICAqIEByZXR1cm4ge29iamVjdH0gTWFwcGluZyBvZiBrZXkgdG8gY2hpbGRcbiAgICovXG4gIGdldENoaWxkTWFwcGluZzogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3RGcmFnbWVudC5leHRyYWN0KFJlYWN0Q2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4geW91J3JlIGFkZGluZyBvciByZW1vdmluZyBjaGlsZHJlbiBzb21lIG1heSBiZSBhZGRlZCBvciByZW1vdmVkIGluIHRoZVxuICAgKiBzYW1lIHJlbmRlciBwYXNzLiBXZSB3YW50IHRvIHNob3cgKmJvdGgqIHNpbmNlIHdlIHdhbnQgdG8gc2ltdWx0YW5lb3VzbHlcbiAgICogYW5pbWF0ZSBlbGVtZW50cyBpbiBhbmQgb3V0LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgcHJldmlvdXMgc2V0IG9mIGtleXNcbiAgICogYW5kIGEgbmV3IHNldCBvZiBrZXlzIGFuZCBtZXJnZXMgdGhlbSB3aXRoIGl0cyBiZXN0IGd1ZXNzIG9mIHRoZSBjb3JyZWN0XG4gICAqIG9yZGVyaW5nLiBJbiB0aGUgZnV0dXJlIHdlIG1heSBleHBvc2Ugc29tZSBvZiB0aGUgdXRpbGl0aWVzIGluXG4gICAqIFJlYWN0TXVsdGlDaGlsZCB0byBtYWtlIHRoaXMgZWFzeSwgYnV0IGZvciBub3cgUmVhY3QgaXRzZWxmIGRvZXMgbm90XG4gICAqIGRpcmVjdGx5IGhhdmUgdGhpcyBjb25jZXB0IG9mIHRoZSB1bmlvbiBvZiBwcmV2Q2hpbGRyZW4gYW5kIG5leHRDaGlsZHJlblxuICAgKiBzbyB3ZSBpbXBsZW1lbnQgaXQgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXYgcHJldiBjaGlsZHJlbiBhcyByZXR1cm5lZCBmcm9tXG4gICAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dCBuZXh0IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAgICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gICAqIEByZXR1cm4ge29iamVjdH0gYSBrZXkgc2V0IHRoYXQgY29udGFpbnMgYWxsIGtleXMgaW4gYHByZXZgIGFuZCBhbGwga2V5c1xuICAgKiBpbiBgbmV4dGAgaW4gYSByZWFzb25hYmxlIG9yZGVyLlxuICAgKi9cbiAgbWVyZ2VDaGlsZE1hcHBpbmdzOiBmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgIHByZXYgPSBwcmV2IHx8IHt9O1xuICAgIG5leHQgPSBuZXh0IHx8IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVGb3JLZXkoa2V5KSB7XG4gICAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXh0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJldltrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAgIC8vIHRoZSBjb21iaW5lZCBsaXN0XG4gICAgdmFyIG5leHRLZXlzUGVuZGluZyA9IHt9O1xuXG4gICAgdmFyIHBlbmRpbmdLZXlzID0gW107XG4gICAgZm9yICh2YXIgcHJldktleSBpbiBwcmV2KSB7XG4gICAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eShwcmV2S2V5KSkge1xuICAgICAgICBpZiAocGVuZGluZ0tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgbmV4dEtleXNQZW5kaW5nW3ByZXZLZXldID0gcGVuZGluZ0tleXM7XG4gICAgICAgICAgcGVuZGluZ0tleXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0tleXMucHVzaChwcmV2S2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgY2hpbGRNYXBwaW5nID0ge307XG4gICAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0KSB7XG4gICAgICBpZiAobmV4dEtleXNQZW5kaW5nLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGVuZGluZ05leHRLZXkgPSBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV07XG4gICAgICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nTmV4dEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5XSA9IGdldFZhbHVlRm9yS2V5KG5leHRLZXkpO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIGFkZCB0aGUga2V5cyB3aGljaCBkaWRuJ3QgYXBwZWFyIGJlZm9yZSBhbnkga2V5IGluIGBuZXh0YFxuICAgIGZvciAoaSA9IDA7IGkgPCBwZW5kaW5nS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRNYXBwaW5nW3BlbmRpbmdLZXlzW2ldXSA9IGdldFZhbHVlRm9yS2V5KHBlbmRpbmdLZXlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRNYXBwaW5nO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUcmFuc2l0aW9uRXZlbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxuLyoqXG4gKiBFVkVOVF9OQU1FX01BUCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBldmVudCBmaXJlZCB3aGVuIGFcbiAqIHRyYW5zaXRpb24vYW5pbWF0aW9uIGVuZHMsIGJhc2VkIG9uIHRoZSBzdHlsZSBwcm9wZXJ0eSB1c2VkIHRvXG4gKiBkZWZpbmUgdGhhdCBldmVudC5cbiAqL1xudmFyIEVWRU5UX05BTUVfTUFQID0ge1xuICB0cmFuc2l0aW9uZW5kOiB7XG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAnbW96VHJhbnNpdGlvbkVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uJzogJ01TVHJhbnNpdGlvbkVuZCdcbiAgfSxcblxuICBhbmltYXRpb25lbmQ6IHtcbiAgICAnYW5pbWF0aW9uJzogJ2FuaW1hdGlvbmVuZCcsXG4gICAgJ1dlYmtpdEFuaW1hdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICdNb3pBbmltYXRpb24nOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICAnT0FuaW1hdGlvbic6ICdvQW5pbWF0aW9uRW5kJyxcbiAgICAnbXNBbmltYXRpb24nOiAnTVNBbmltYXRpb25FbmQnXG4gIH1cbn07XG5cbnZhciBlbmRFdmVudHMgPSBbXTtcblxuZnVuY3Rpb24gZGV0ZWN0RXZlbnRzKCkge1xuICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzdHlsZSA9IHRlc3RFbC5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzZWFibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW1cbiAgLy8gZnJvbSB0aGUgbWFwXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICB9XG5cbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cblxuICBmb3IgKHZhciBiYXNlRXZlbnROYW1lIGluIEVWRU5UX05BTUVfTUFQKSB7XG4gICAgdmFyIGJhc2VFdmVudHMgPSBFVkVOVF9OQU1FX01BUFtiYXNlRXZlbnROYW1lXTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gYmFzZUV2ZW50cykge1xuICAgICAgaWYgKHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICBlbmRFdmVudHMucHVzaChiYXNlRXZlbnRzW3N0eWxlTmFtZV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBkZXRlY3RFdmVudHMoKTtcbn1cblxuLy8gV2UgdXNlIHRoZSByYXcge2FkZHxyZW1vdmV9RXZlbnRMaXN0ZW5lcigpIGNhbGwgYmVjYXVzZSBFdmVudExpc3RlbmVyXG4vLyBkb2VzIG5vdCBrbm93IGhvdyB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFuZCB3ZSByZWFsbHkgc2hvdWxkXG4vLyBjbGVhbiB1cC4gQWxzbywgdGhlc2UgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIGluIG9sZGVyIGJyb3dzZXJzXG4vLyBzbyB3ZSBzaG91bGQgYmUgQS1PSyBoZXJlLlxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHtcbiAgYWRkRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKG5vZGUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgQ1NTIHRyYW5zaXRpb25zIGFyZSBub3Qgc3VwcG9ydGVkLCB0cmlnZ2VyIGFuIFwiZW5kIGFuaW1hdGlvblwiXG4gICAgICAvLyBldmVudCBpbW1lZGlhdGVseS5cbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGV2ZW50TGlzdGVuZXIsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW5kRXZlbnQpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbW92ZUVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGVuZEV2ZW50KSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFRyYW5zaXRpb25FdmVudHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VHJhbnNpdGlvbkdyb3VwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwiLi9SZWFjdFwiKTtcbnZhciBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcgPSByZXF1aXJlKFwiLi9SZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmdcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGNsb25lV2l0aFByb3BzID0gcmVxdWlyZShcIi4vY2xvbmVXaXRoUHJvcHNcIik7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbnZhciBSZWFjdFRyYW5zaXRpb25Hcm91cCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdFRyYW5zaXRpb25Hcm91cCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY29tcG9uZW50OiBSZWFjdC5Qcm9wVHlwZXMuYW55LFxuICAgIGNoaWxkRmFjdG9yeTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcG9uZW50OiAnc3BhbicsXG4gICAgICBjaGlsZEZhY3Rvcnk6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudFxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKHRoaXMucHJvcHMuY2hpbGRyZW4pXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzID0ge307XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbml0aWFsQ2hpbGRNYXBwaW5nID0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5pdGlhbENoaWxkTWFwcGluZykge1xuICAgICAgaWYgKGluaXRpYWxDaGlsZE1hcHBpbmdba2V5XSkge1xuICAgICAgICB0aGlzLnBlcmZvcm1BcHBlYXIoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0Q2hpbGRNYXBwaW5nID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyhuZXh0UHJvcHMuY2hpbGRyZW4pO1xuICAgIHZhciBwcmV2Q2hpbGRNYXBwaW5nID0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2hpbGRyZW46IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5tZXJnZUNoaWxkTWFwcGluZ3MocHJldkNoaWxkTWFwcGluZywgbmV4dENoaWxkTWFwcGluZylcbiAgICB9KTtcblxuICAgIHZhciBrZXk7XG5cbiAgICBmb3IgKGtleSBpbiBuZXh0Q2hpbGRNYXBwaW5nKSB7XG4gICAgICB2YXIgaGFzUHJldiA9IHByZXZDaGlsZE1hcHBpbmcgJiYgcHJldkNoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKG5leHRDaGlsZE1hcHBpbmdba2V5XSAmJiAhaGFzUHJldiAmJiAhdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldKSB7XG4gICAgICAgIHRoaXMua2V5c1RvRW50ZXIucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoa2V5IGluIHByZXZDaGlsZE1hcHBpbmcpIHtcbiAgICAgIHZhciBoYXNOZXh0ID0gbmV4dENoaWxkTWFwcGluZyAmJiBuZXh0Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAocHJldkNoaWxkTWFwcGluZ1trZXldICYmICFoYXNOZXh0ICYmICF0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0pIHtcbiAgICAgICAgdGhpcy5rZXlzVG9MZWF2ZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2Ugd2FudCB0byBzb21lZGF5IGNoZWNrIGZvciByZW9yZGVyaW5nLCB3ZSBjb3VsZCBkbyBpdCBoZXJlLlxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBrZXlzVG9FbnRlciA9IHRoaXMua2V5c1RvRW50ZXI7XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIGtleXNUb0VudGVyLmZvckVhY2godGhpcy5wZXJmb3JtRW50ZXIpO1xuXG4gICAgdmFyIGtleXNUb0xlYXZlID0gdGhpcy5rZXlzVG9MZWF2ZTtcbiAgICB0aGlzLmtleXNUb0xlYXZlID0gW107XG4gICAga2V5c1RvTGVhdmUuZm9yRWFjaCh0aGlzLnBlcmZvcm1MZWF2ZSk7XG4gIH0sXG5cbiAgcGVyZm9ybUFwcGVhcjogZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSA9IHRydWU7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG5cbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxBcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsQXBwZWFyKHRoaXMuX2hhbmRsZURvbmVBcHBlYXJpbmcuYmluZCh0aGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlRG9uZUFwcGVhcmluZyhrZXkpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlRG9uZUFwcGVhcmluZzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZEFwcGVhcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudERpZEFwcGVhcigpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV07XG5cbiAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcodGhpcy5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICBpZiAoIWN1cnJlbnRDaGlsZE1hcHBpbmcgfHwgIWN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhpcyB3YXMgcmVtb3ZlZCBiZWZvcmUgaXQgaGFkIGZ1bGx5IGFwcGVhcmVkLiBSZW1vdmUgaXQuXG4gICAgICB0aGlzLnBlcmZvcm1MZWF2ZShrZXkpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtRW50ZXI6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0gPSB0cnVlO1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuXG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsRW50ZXIpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsRW50ZXIodGhpcy5faGFuZGxlRG9uZUVudGVyaW5nLmJpbmQodGhpcywga2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZURvbmVFbnRlcmluZyhrZXkpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlRG9uZUVudGVyaW5nOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkRW50ZXIpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnREaWRFbnRlcigpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV07XG5cbiAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcodGhpcy5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICBpZiAoIWN1cnJlbnRDaGlsZE1hcHBpbmcgfHwgIWN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhpcyB3YXMgcmVtb3ZlZCBiZWZvcmUgaXQgaGFkIGZ1bGx5IGVudGVyZWQuIFJlbW92ZSBpdC5cbiAgICAgIHRoaXMucGVyZm9ybUxlYXZlKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIHBlcmZvcm1MZWF2ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSA9IHRydWU7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsTGVhdmUpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTGVhdmUodGhpcy5faGFuZGxlRG9uZUxlYXZpbmcuYmluZCh0aGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgc29tZXdoYXQgZGFuZ2Vyb3VzIGIvYyBpdCBjYWxscyBzZXRTdGF0ZSgpXG4gICAgICAvLyBhZ2FpbiwgZWZmZWN0aXZlbHkgbXV0YXRpbmcgdGhlIGNvbXBvbmVudCBiZWZvcmUgYWxsIHRoZSB3b3JrXG4gICAgICAvLyBpcyBkb25lLlxuICAgICAgdGhpcy5faGFuZGxlRG9uZUxlYXZpbmcoa2V5KTtcbiAgICB9XG4gIH0sXG5cbiAgX2hhbmRsZURvbmVMZWF2aW5nOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuXG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRMZWF2ZSkge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudERpZExlYXZlKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XTtcblxuICAgIHZhciBjdXJyZW50Q2hpbGRNYXBwaW5nID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmIChjdXJyZW50Q2hpbGRNYXBwaW5nICYmIGN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhpcyBlbnRlcmVkIGFnYWluIGJlZm9yZSBpdCBmdWxseSBsZWZ0LiBBZGQgaXQgYWdhaW4uXG4gICAgICB0aGlzLnBlcmZvcm1FbnRlcihrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBhc3NpZ24oe30sIHN0YXRlLmNoaWxkcmVuKTtcbiAgICAgICAgZGVsZXRlIG5ld0NoaWxkcmVuW2tleV07XG4gICAgICAgIHJldHVybiB7IGNoaWxkcmVuOiBuZXdDaGlsZHJlbiB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IHdlIGNvdWxkIGdldCByaWQgb2YgdGhlIG5lZWQgZm9yIHRoZSB3cmFwcGVyIG5vZGVcbiAgICAvLyBieSBjbG9uaW5nIGEgc2luZ2xlIGNoaWxkXG4gICAgdmFyIGNoaWxkcmVuVG9SZW5kZXIgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zdGF0ZS5jaGlsZHJlbikge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5zdGF0ZS5jaGlsZHJlbltrZXldO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIC8vIFlvdSBtYXkgbmVlZCB0byBhcHBseSByZWFjdGl2ZSB1cGRhdGVzIHRvIGEgY2hpbGQgYXMgaXQgaXMgbGVhdmluZy5cbiAgICAgICAgLy8gVGhlIG5vcm1hbCBSZWFjdCB3YXkgdG8gZG8gaXQgd29uJ3Qgd29yayBzaW5jZSB0aGUgY2hpbGQgd2lsbCBoYXZlXG4gICAgICAgIC8vIGFscmVhZHkgYmVlbiByZW1vdmVkLiBJbiBjYXNlIHlvdSBuZWVkIHRoaXMgYmVoYXZpb3IgeW91IGNhbiBwcm92aWRlXG4gICAgICAgIC8vIGEgY2hpbGRGYWN0b3J5IGZ1bmN0aW9uIHRvIHdyYXAgZXZlcnkgY2hpbGQsIGV2ZW4gdGhlIG9uZXMgdGhhdCBhcmVcbiAgICAgICAgLy8gbGVhdmluZy5cbiAgICAgICAgY2hpbGRyZW5Ub1JlbmRlci5wdXNoKGNsb25lV2l0aFByb3BzKHRoaXMucHJvcHMuY2hpbGRGYWN0b3J5KGNoaWxkKSwgeyByZWY6IGtleSwga2V5OiBrZXkgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmNvbXBvbmVudCwgdGhpcy5wcm9wcywgY2hpbGRyZW5Ub1JlbmRlcik7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VHJhbnNpdGlvbkdyb3VwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TGlmZUN5Y2xlID0gcmVxdWlyZShcIi4vUmVhY3RMaWZlQ3ljbGVcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VNYXBcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAhPT0gUmVhY3RMaWZlQ3ljbGUuY3VycmVudGx5TW91bnRpbmdJbnN0YW5jZSkge1xuICAgIC8vIElmIHdlJ3JlIGluIGEgY29tcG9uZW50V2lsbE1vdW50IGhhbmRsZXIsIGRvbid0IGVucXVldWUgYSByZXJlbmRlclxuICAgIC8vIGJlY2F1c2UgUmVhY3RVcGRhdGVzIGFzc3VtZXMgd2UncmUgaW4gYSBicm93c2VyIGNvbnRleHQgKHdoaWNoIGlzXG4gICAgLy8gd3JvbmcgZm9yIHNlcnZlciByZW5kZXJpbmcpIGFuZCB3ZSdyZSBhYm91dCB0byBkbyBhIHJlbmRlciBhbnl3YXkuXG4gICAgLy8gU2VlIGJ1ZyBpbiAjMTc0MC5cbiAgICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgIShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IENhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gJyArICcoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlLicsIGNhbGxlck5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgJyArICdjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PT0gUmVhY3RMaWZlQ3ljbGUuY3VycmVudGx5VW5tb3VudGluZ0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2VucXVldWVDYWxsYmFjayguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICsgJ2BzZXRTdGF0ZWAsIGByZXBsYWNlU3RhdGVgLCBvciBgZm9yY2VVcGRhdGVgIHdpdGggYSBjYWxsYmFjayB0aGF0ICcgKyAnaXNuXFwndCBjYWxsYWJsZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UgfHwgaW50ZXJuYWxJbnN0YW5jZSA9PT0gUmVhY3RMaWZlQ3ljbGUuY3VycmVudGx5TW91bnRpbmdJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS4gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIGRpc2FsbG93XG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2VucXVldWVDYWxsYmFjayguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICsgJ2BzZXRTdGF0ZWAsIGByZXBsYWNlU3RhdGVgLCBvciBgZm9yY2VVcGRhdGVgIHdpdGggYSBjYWxsYmFjayB0aGF0ICcgKyAnaXNuXFwndCBjYWxsYWJsZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkVXBkYXRlQ29tcG9uZW50YCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbY29tcGxldGVTdGF0ZV07XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFByb3BzJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAhaW50ZXJuYWxJbnN0YW5jZS5faXNUb3BMZXZlbCA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2Agb24gYSAnICsgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgKyAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArICd3aGVyZSBpdCBpcyBjcmVhdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgLy8gZWxlbWVudCBwcm9wcy5cbiAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50IHx8IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcywgcGFydGlhbFByb3BzKTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyhlbGVtZW50LCBwcm9wcyk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIE5ldyBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHByb3BzKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlUHJvcHMnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICFpbnRlcm5hbEluc3RhbmNlLl9pc1RvcExldmVsID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3JlcGxhY2VQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGByZXBsYWNlUHJvcHNgIG9uIGEgJyArICdjb21wb25lbnQgd2l0aCBhIHBhcmVudC4gVGhpcyBpcyBhbiBhbnRpLXBhdHRlcm4gc2luY2UgcHJvcHMgd2lsbCAnICsgJ2dldCByZWFjdGl2ZWx5IHVwZGF0ZWQgd2hlbiByZW5kZXJlZC4gSW5zdGVhZCwgY2hhbmdlIHRoZSBvd25lclxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QgdG8gcGFzcyB0aGUgY29ycmVjdCB2YWx1ZSBhcyBwcm9wcyB0byB0aGUgY29tcG9uZW50ICcgKyAnd2hlcmUgaXQgaXMgY3JlYXRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBNZXJnZSB3aXRoIHRoZSBwZW5kaW5nIGVsZW1lbnQgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZ1xuICAgIC8vIGVsZW1lbnQgcHJvcHMuXG4gICAgdmFyIGVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCB8fCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyhlbGVtZW50LCBwcm9wcyk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVFbGVtZW50SW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXdFbGVtZW50KSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0VsZW1lbnQgPSBuZXdFbGVtZW50O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZVF1ZXVlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZShcIi4vQ2FsbGJhY2tRdWV1ZVwiKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoXCIuL1JlYWN0UmVjb25jaWxlclwiKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL1RyYW5zYWN0aW9uXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG52YXIgYXNhcEVucXVldWVkID0gZmFsc2U7XG5cbnZhciBiYXRjaGluZ1N0cmF0ZWd5ID0gbnVsbDtcblxuZnVuY3Rpb24gZW5zdXJlSW5qZWN0ZWQoKSB7XG4gICEoUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gJiYgYmF0Y2hpbmdTdHJhdGVneSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IGluamVjdCBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcyBhbmQgYmF0Y2hpbmcgJyArICdzdHJhdGVneScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIE5FU1RFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCAhPT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gQWRkaXRpb25hbCB1cGRhdGVzIHdlcmUgZW5xdWV1ZWQgYnkgY29tcG9uZW50RGlkVXBkYXRlIGhhbmRsZXJzIG9yXG4gICAgICAvLyBzaW1pbGFyOyBiZWZvcmUgb3VyIG93biBVUERBVEVfUVVFVUVJTkcgd3JhcHBlciBjbG9zZXMsIHdlIHdhbnQgdG8gcnVuXG4gICAgICAvLyB0aGVzZSBuZXcgdXBkYXRlcyBzbyB0aGF0IGlmIEEncyBjb21wb25lbnREaWRVcGRhdGUgY2FsbHMgc2V0U3RhdGUgb25cbiAgICAgIC8vIEIsIEIgd2lsbCB1cGRhdGUgYmVmb3JlIHRoZSBjYWxsYmFjayBBJ3MgdXBkYXRlciBwcm92aWRlZCB3aGVuIGNhbGxpbmdcbiAgICAgIC8vIHNldFN0YXRlLlxuICAgICAgZGlydHlDb21wb25lbnRzLnNwbGljZSgwLCB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCk7XG4gICAgICBmbHVzaEJhdGNoZWRVcGRhdGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Q29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFVQREFURV9RVUVVRUlORyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5yZXNldCgpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW05FU1RFRF9VUERBVEVTLCBVUERBVEVfUVVFVUVJTkddO1xuXG5mdW5jdGlvbiBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xufVxuXG5hc3NpZ24oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uTWl4aW4ucGVyZm9ybS5jYWxsKHRoaXMsIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSwgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgbWV0aG9kLCBzY29wZSwgYSk7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG4gIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBtb3VudCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnRPcmRlckNvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAhKGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvICcgKyAnbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnRPcmRlckNvbXBhcmF0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaXQgd2lsbCBzdGlsbFxuICAgIC8vIGJlIGhlcmUsIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCBoYXMgY2xlYXJlZCBpdHMgX3BlbmRpbmdDYWxsYmFja3MgYW5kXG4gICAgLy8gdGhhdCBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaXMgYSBub29wLlxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG5cbiAgICAvLyBJZiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaGFwcGVucyB0byBlbnF1ZXVlIGFueSBuZXcgdXBkYXRlcywgd2VcbiAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgIC8vIHN0YXNoIHRoZSBjYWxsYmFja3MgZmlyc3RcbiAgICB2YXIgY2FsbGJhY2tzID0gY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzO1xuICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICBSZWFjdFJlY29uY2lsZXIucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KGNvbXBvbmVudCwgdHJhbnNhY3Rpb24ucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrc1tqXSwgY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAvLyBhcnJheSBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBlbnF1ZXVlZCBieSBtb3VudC1yZWFkeSBoYW5kbGVycyAoaS5lLixcbiAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxuICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgYXNhcCBjYWxscy5cbiAgd2hpbGUgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGggfHwgYXNhcEVucXVldWVkKSB7XG4gICAgaWYgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKHJ1bkJhdGNoZWRVcGRhdGVzLCBudWxsLCB0cmFuc2FjdGlvbik7XG4gICAgICBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChhc2FwRW5xdWV1ZWQpIHtcbiAgICAgIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XG4gICAgICBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gICAgICBxdWV1ZS5ub3RpZnlBbGwoKTtcbiAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XG4gICAgfVxuICB9XG59O1xuZmx1c2hCYXRjaGVkVXBkYXRlcyA9IFJlYWN0UGVyZi5tZWFzdXJlKCdSZWFjdFVwZGF0ZXMnLCAnZmx1c2hCYXRjaGVkVXBkYXRlcycsIGZsdXNoQmF0Y2hlZFVwZGF0ZXMpO1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50KSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG5cbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChUaGlzIGlzIGNhbGxlZCBieSBlYWNoIHRvcC1sZXZlbCB1cGRhdGVcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0UHJvcHMsIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXG4gIC8vIGRlc3RydWN0aW9uIG9mIHRvcC1sZXZlbCBjb21wb25lbnRzIGlzIGd1YXJkZWQgaW4gUmVhY3RNb3VudC4pXG4gICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ2VucXVldWVVcGRhdGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyAnICsgJ2FuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90ICcgKyAnYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLicpIDogdW5kZWZpbmVkO1xuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmUnICsgJ3VwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RXaXRoQWRkb25zXG4gKi9cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBleGlzdHMgcHVyZWx5IGluIHRoZSBvcGVuIHNvdXJjZSBwcm9qZWN0LCBhbmQgaXMgbWVhbnQgYXMgYSB3YXlcbiAqIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHN0YW5kYWxvbmUgYnVpbGQgb2YgUmVhY3QuIFRoaXMgYnVpbGQgaGFzIFwiYWRkb25zXCIsIG9yXG4gKiBmdW5jdGlvbmFsaXR5IHdlJ3ZlIGJ1aWx0IGFuZCB0aGluayBtaWdodCBiZSB1c2VmdWwgYnV0IGRvZXNuJ3QgaGF2ZSBhIGdvb2RcbiAqIHBsYWNlIHRvIGxpdmUgaW5zaWRlIFJlYWN0IGNvcmUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlua2VkU3RhdGVNaXhpbiA9IHJlcXVpcmUoXCIuL0xpbmtlZFN0YXRlTWl4aW5cIik7XG52YXIgUmVhY3QgPSByZXF1aXJlKFwiLi9SZWFjdFwiKTtcbnZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW5cIik7XG52YXIgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAgPSByZXF1aXJlKFwiLi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cFwiKTtcbnZhciBSZWFjdEZyYWdtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RGcmFnbWVudFwiKTtcbnZhciBSZWFjdFRyYW5zaXRpb25Hcm91cCA9IHJlcXVpcmUoXCIuL1JlYWN0VHJhbnNpdGlvbkdyb3VwXCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGNsb25lV2l0aFByb3BzID0gcmVxdWlyZShcIi4vY2xvbmVXaXRoUHJvcHNcIik7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKFwiLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclwiKTtcbnZhciBzaGFsbG93Q29tcGFyZSA9IHJlcXVpcmUoXCIuL3NoYWxsb3dDb21wYXJlXCIpO1xudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIuL3VwZGF0ZVwiKTtcblxuUmVhY3QuYWRkb25zID0ge1xuICBDU1NUcmFuc2l0aW9uR3JvdXA6IFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwLFxuICBMaW5rZWRTdGF0ZU1peGluOiBMaW5rZWRTdGF0ZU1peGluLFxuICBQdXJlUmVuZGVyTWl4aW46IFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBSZWFjdFRyYW5zaXRpb25Hcm91cCxcblxuICBiYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICBjbG9uZVdpdGhQcm9wczogY2xvbmVXaXRoUHJvcHMsXG4gIGNyZWF0ZUZyYWdtZW50OiBSZWFjdEZyYWdtZW50LmNyZWF0ZSxcbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLFxuICBzaGFsbG93Q29tcGFyZTogc2hhbGxvd0NvbXBhcmUsXG4gIHVwZGF0ZTogdXBkYXRlXG59O1xuXG5pZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBSZWFjdC5hZGRvbnMuUGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0RGVmYXVsdFBlcmZcIik7XG4gIFJlYWN0LmFkZG9ucy5UZXN0VXRpbHMgPSByZXF1aXJlKFwiLi9SZWFjdFRlc3RVdGlsc1wiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU1ZHRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBjbGlwUGF0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGN4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGw6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRGYW1pbHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250U2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJFbmQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJNaWQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJTdGFydDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9mZnNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVyblVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcG9pbnRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3ByZWFkTWV0aG9kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcENvbG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VEYXNoYXJyYXk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VMaW5lY2FwOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZVdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdGV4dEFuY2hvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZlcnNpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2aWV3Qm94OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FjdHVhdGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FyY3JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0hyZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1Nob3c6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1RpdGxlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sQmFzZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbExhbmc6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxTcGFjZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5OiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gICAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gICAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICAgIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICAgIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICAgIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gICAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gICAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICAgIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICAgIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICAgIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gICAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgICB4bWxTcGFjZTogJ3htbDpzcGFjZSdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VsZWN0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdElucHV0U2VsZWN0aW9uXCIpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZShcIi4vZ2V0QWN0aXZlRWxlbWVudFwiKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKFwiLi9pc1RleHRJbnB1dEVsZW1lbnRcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKFwiLi9zaGFsbG93RXF1YWxcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWxlY3RDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnUsIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vLyBUcmFjayB3aGV0aGVyIGEgbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbi8vIG5vdCBleHRyYWN0IGV2ZW50cy5cbnZhciBoYXNMaXN0ZW5lciA9IGZhbHNlO1xudmFyIE9OX1NFTEVDVF9LRVkgPSBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudElELCBuYXRpdmVFdmVudCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpIHtcblxuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkgfHwgdG9wTGV2ZWxUYXJnZXQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudElEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLlxuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX1NFTEVDVF9LRVkpIHtcbiAgICAgIGhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlcnZlclJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaXplIG9mIHRoZSByZWFjdFJvb3QgSUQgc3BhY2UuIFdlIGdlbmVyYXRlIHJhbmRvbSBudW1iZXJzIGZvciBSZWFjdCByb290XG4gKiBJRHMgYW5kIGlmIHRoZXJlJ3MgYSBjb2xsaXNpb24gdGhlIGV2ZW50cyBhbmQgRE9NIHVwZGF0ZSBzeXN0ZW0gd2lsbFxuICogZ2V0IGNvbmZ1c2VkLiBJbiB0aGUgZnV0dXJlIHdlIG5lZWQgYSB3YXkgdG8gZ2VuZXJhdGUgR1VJRHMgYnV0IGZvclxuICogbm93IHRoaXMgd2lsbCB3b3JrIG9uIGEgc21hbGxlciBzY2FsZS5cbiAqL1xudmFyIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5cbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiBHTE9CQUxfTU9VTlRfUE9JTlRfTUFYKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJSZWFjdFJvb3RJbmRleDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2ltcGxlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9FdmVudExpc3RlbmVyXCIpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblV0aWxzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcIik7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRm9jdXNFdmVudFwiKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljS2V5Ym9hcmRFdmVudFwiKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljTW91c2VFdmVudFwiKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNEcmFnRXZlbnRcIik7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1RvdWNoRXZlbnRcIik7XG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1doZWVsRXZlbnRcIik7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRDaGFyQ29kZVwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmx1cjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmx1cjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmx1ckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29weToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29weTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29weUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkb3VibGVDbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbnRlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VudGVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0V4aXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFeGl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRXhpdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnTGVhdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ092ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ1N0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyb3A6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyb3BDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBmb2N1czoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRm9jdXM6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkZvY3VzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgaW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbklucHV0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25JbnB1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5UHJlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVByZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5VXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRXJyb3I6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVycm9yQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgLy8gTm90ZTogV2UgZG8gbm90IGFsbG93IGxpc3RlbmluZyB0byBtb3VzZU92ZXIgZXZlbnRzLiBJbnN0ZWFkLCB1c2UgdGhlXG4gIC8vIG9uTW91c2VFbnRlci9vbk1vdXNlTGVhdmUgY3JlYXRlZCBieSBgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luYC5cbiAgbW91c2VEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlVXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGFzdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhc3RlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJlc2V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25SZXNldENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNjcm9sbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Nyb2xsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TY3JvbGxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdWJtaXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1Ym1pdDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3VibWl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hDYW5jZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaEVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BCbHVyOiBldmVudFR5cGVzLmJsdXIsXG4gIHRvcENsaWNrOiBldmVudFR5cGVzLmNsaWNrLFxuICB0b3BDb250ZXh0TWVudTogZXZlbnRUeXBlcy5jb250ZXh0TWVudSxcbiAgdG9wQ29weTogZXZlbnRUeXBlcy5jb3B5LFxuICB0b3BDdXQ6IGV2ZW50VHlwZXMuY3V0LFxuICB0b3BEb3VibGVDbGljazogZXZlbnRUeXBlcy5kb3VibGVDbGljayxcbiAgdG9wRHJhZzogZXZlbnRUeXBlcy5kcmFnLFxuICB0b3BEcmFnRW5kOiBldmVudFR5cGVzLmRyYWdFbmQsXG4gIHRvcERyYWdFbnRlcjogZXZlbnRUeXBlcy5kcmFnRW50ZXIsXG4gIHRvcERyYWdFeGl0OiBldmVudFR5cGVzLmRyYWdFeGl0LFxuICB0b3BEcmFnTGVhdmU6IGV2ZW50VHlwZXMuZHJhZ0xlYXZlLFxuICB0b3BEcmFnT3ZlcjogZXZlbnRUeXBlcy5kcmFnT3ZlcixcbiAgdG9wRHJhZ1N0YXJ0OiBldmVudFR5cGVzLmRyYWdTdGFydCxcbiAgdG9wRHJvcDogZXZlbnRUeXBlcy5kcm9wLFxuICB0b3BFcnJvcjogZXZlbnRUeXBlcy5lcnJvcixcbiAgdG9wRm9jdXM6IGV2ZW50VHlwZXMuZm9jdXMsXG4gIHRvcElucHV0OiBldmVudFR5cGVzLmlucHV0LFxuICB0b3BLZXlEb3duOiBldmVudFR5cGVzLmtleURvd24sXG4gIHRvcEtleVByZXNzOiBldmVudFR5cGVzLmtleVByZXNzLFxuICB0b3BLZXlVcDogZXZlbnRUeXBlcy5rZXlVcCxcbiAgdG9wTG9hZDogZXZlbnRUeXBlcy5sb2FkLFxuICB0b3BNb3VzZURvd246IGV2ZW50VHlwZXMubW91c2VEb3duLFxuICB0b3BNb3VzZU1vdmU6IGV2ZW50VHlwZXMubW91c2VNb3ZlLFxuICB0b3BNb3VzZU91dDogZXZlbnRUeXBlcy5tb3VzZU91dCxcbiAgdG9wTW91c2VPdmVyOiBldmVudFR5cGVzLm1vdXNlT3ZlcixcbiAgdG9wTW91c2VVcDogZXZlbnRUeXBlcy5tb3VzZVVwLFxuICB0b3BQYXN0ZTogZXZlbnRUeXBlcy5wYXN0ZSxcbiAgdG9wUmVzZXQ6IGV2ZW50VHlwZXMucmVzZXQsXG4gIHRvcFNjcm9sbDogZXZlbnRUeXBlcy5zY3JvbGwsXG4gIHRvcFN1Ym1pdDogZXZlbnRUeXBlcy5zdWJtaXQsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BXaGVlbDogZXZlbnRUeXBlcy53aGVlbFxufTtcblxuZm9yICh2YXIgdHlwZSBpbiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcpIHtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3R5cGVdLmRlcGVuZGVuY2llcyA9IFt0eXBlXTtcbn1cblxudmFyIE9OX0NMSUNLX0tFWSA9IGtleU9mKHsgb25DbGljazogbnVsbCB9KTtcbnZhciBvbkNsaWNrTGlzdGVuZXJzID0ge307XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBleGNlcHQgY2FuY2VscyB0aGUgZXZlbnQgd2hlbiByZXR1cm5cbiAgICogdmFsdWUgaXMgZmFsc2UuIFRoaXMgYmVoYXZpb3Igd2lsbCBiZSBkaXNhYmxlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gRXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gSUQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBleGVjdXRlRGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIsIGRvbUlEKSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBkb21JRCk7XG5cbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyh0eXBlb2YgcmV0dXJuVmFsdWUgIT09ICdib29sZWFuJywgJ1JldHVybmluZyBgZmFsc2VgIGZyb20gYW4gZXZlbnQgaGFuZGxlciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlICcgKyAnaWdub3JlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBJbnN0ZWFkLCBtYW51YWxseSBjYWxsICcgKyAnZS5zdG9wUHJvcGFnYXRpb24oKSBvciBlLnByZXZlbnREZWZhdWx0KCksIGFzIGFwcHJvcHJpYXRlLicpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHJldHVyblZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVycm9yOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJlc2V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAgIC8vIEZpcmVGb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDbGljazpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRG91YmxlQ2xpY2s6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW50ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0V4aXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0xlYXZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcm9wOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29weTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICFFdmVudENvbnN0cnVjdG9yID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLCB0b3BMZXZlbFR5cGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQpO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gICAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAgIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgICBpZiAoIW9uQ2xpY2tMaXN0ZW5lcnNbaWRdKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNbaWRdID0gRXZlbnRMaXN0ZW5lci5saXN0ZW4obm9kZSwgJ2NsaWNrJywgZW1wdHlGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHdpbGxEZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0ucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgb25DbGlja0xpc3RlbmVyc1tpZF07XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LCBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNEcmFnRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY01vdXNlRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKFwiLi9nZXRFdmVudFRhcmdldFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IGdldEV2ZW50VGFyZ2V0LFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuZGlzcGF0Y2hNYXJrZXIgPSBkaXNwYXRjaE1hcmtlcjtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xufVxuXG5hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBhc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MudGhyZWVBcmd1bWVudFBvb2xlcik7XG59O1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oU3ludGhldGljRXZlbnQsIFBvb2xlZENsYXNzLnRocmVlQXJndW1lbnRQb29sZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0V2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNVSUV2ZW50XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNJbnB1dEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNLZXlib2FyZEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNVSUV2ZW50XCIpO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50Q2hhckNvZGVcIik7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKFwiLi9nZXRFdmVudEtleVwiKTtcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudE1vZGlmaWVyU3RhdGVcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljTW91c2VFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljVUlFdmVudFwiKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKFwiLi9WaWV3cG9ydE1ldHJpY3NcIik7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudE1vZGlmaWVyU3RhdGVcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBXZWJraXQsIEZpcmVmb3gsIElFOStcbiAgICAvLyB3aGljaDogIDEgMiAzXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gSUU8OVxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXG4gICAgLy8gYnV0dG9uOiAwIDAgMFxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xuICB9LFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdDtcbiAgfSxcbiAgcGFnZVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1RvdWNoRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudE1vZGlmaWVyU3RhdGVcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRUYXJnZXRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVUlFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljV2hlZWxFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljTW91c2VFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxuICpcbiAqIFRyYW5zYWN0aW9uYWwgcGx1Z2luIEFQSTpcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcbiAqICAgd2hlbiB0aGUgd3JhcHBlZCBwcm9jZXNzIGlzIGNvbXBsZXRlZCwgb3IgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xuICogdGhhdCBpbXBsZW1lbnQgYGluaXRpYWxpemVgIGFuZCBgY2xvc2VgLlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICovXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKCF0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhcmdzLi4uIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2QgKG9wdGlvbmFsKS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBIZWxwcyBwcmV2ZW50IG5lZWQgdG8gYmluZCBpbiBtYW55IGNhc2VzLlxuICAgKiBAcmV0dXJuIFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgJyArICdpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG52YXIgVHJhbnNhY3Rpb24gPSB7XG5cbiAgTWl4aW46IE1peGluLFxuXG4gIC8qKlxuICAgKiBUb2tlbiB0byBsb29rIGZvciB0byBkZXRlcm1pbmUgaWYgYW4gZXJyb3Igb2NjdXJlZC5cbiAgICovXG4gIE9CU0VSVkVEX0VSUk9SOiB7fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBWaWV3cG9ydE1ldHJpY3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWaWV3cG9ydE1ldHJpY3MgPSB7XG5cbiAgY3VycmVudFNjcm9sbExlZnQ6IDAsXG5cbiAgY3VycmVudFNjcm9sbFRvcDogMCxcblxuICByZWZyZXNoU2Nyb2xsVmFsdWVzOiBmdW5jdGlvbiAoc2Nyb2xsUG9zaXRpb24pIHtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQgPSBzY3JvbGxQb3NpdGlvbi54O1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb24ueTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0TWV0cmljczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWNjdW11bGF0ZUludG9cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICpcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgdmFyIGN1cnJlbnRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjdXJyZW50KTtcbiAgdmFyIG5leHRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXh0KTtcblxuICBpZiAoY3VycmVudElzQXJyYXkgJiYgbmV4dElzQXJyYXkpIHtcbiAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoY3VycmVudElzQXJyYXkpIHtcbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAobmV4dElzQXJyYXkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTU9EID0gNjU1MjE7XG5cbi8vIFRoaXMgaXMgYSBjbGVhbi1yb29tIGltcGxlbWVudGF0aW9uIG9mIGFkbGVyMzIgZGVzaWduZWQgZm9yIGRldGVjdGluZ1xuLy8gaWYgbWFya3VwIGlzIG5vdCB3aGF0IHdlIGV4cGVjdCBpdCB0byBiZS4gSXQgZG9lcyBub3QgbmVlZCB0byBiZVxuLy8gY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBvbmx5IHJlYXNvbmFibHkgZ29vZCBhdCBkZXRlY3RpbmcgaWYgbWFya3VwXG4vLyBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBpcyBkaWZmZXJlbnQgdGhhbiB0aGF0IG9uIHRoZSBjbGllbnQuXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGEgPSAoYSArIGRhdGEuY2hhckNvZGVBdChpKSkgJSBNT0Q7XG4gICAgYiA9IChiICsgYSkgJSBNT0Q7XG4gIH1cbiAgcmV0dXJuIGEgfCBiIDw8IDE2O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbWVsaXplXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKFwiLi9jYW1lbGl6ZVwiKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqIEBwcm92aWRlc01vZHVsZSBjbG9uZVdpdGhQcm9wc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdFByb3BUcmFuc2ZlcmVyID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHJhbnNmZXJlclwiKTtcblxudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBDSElMRFJFTl9QUk9QID0ga2V5T2YoeyBjaGlsZHJlbjogbnVsbCB9KTtcblxuLyoqXG4gKiBTb21ldGltZXMgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBwcm9wcyBvZiBhIGNoaWxkIHBhc3NlZCB0byB5b3UuIFVzdWFsbHlcbiAqIHRoaXMgaXMgdG8gYWRkIGEgQ1NTIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBjaGlsZCBjaGlsZCBlbGVtZW50IHlvdSdkIGxpa2UgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBwcm9wcyB5b3UnZCBsaWtlIHRvIG1vZGlmeS4gY2xhc3NOYW1lIGFuZCBzdHlsZSB3aWxsIGJlXG4gKiBtZXJnZWQgYXV0b21hdGljYWxseS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gYSBjbG9uZSBvZiBjaGlsZCB3aXRoIHByb3BzIG1lcmdlZCBpbi5cbiAqL1xuZnVuY3Rpb24gY2xvbmVXaXRoUHJvcHMoY2hpbGQsIHByb3BzKSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoIWNoaWxkLnJlZiwgJ1lvdSBhcmUgY2FsbGluZyBjbG9uZVdpdGhQcm9wcygpIG9uIGEgY2hpbGQgd2l0aCBhIHJlZi4gVGhpcyBpcyAnICsgJ2Rhbmdlcm91cyBiZWNhdXNlIHlvdVxcJ3JlIGNyZWF0aW5nIGEgbmV3IGNoaWxkIHdoaWNoIHdpbGwgbm90IGJlICcgKyAnYWRkZWQgYXMgYSByZWYgdG8gaXRzIHBhcmVudC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBuZXdQcm9wcyA9IFJlYWN0UHJvcFRyYW5zZmVyZXIubWVyZ2VQcm9wcyhwcm9wcywgY2hpbGQucHJvcHMpO1xuXG4gIC8vIFVzZSBgY2hpbGQucHJvcHMuY2hpbGRyZW5gIGlmIGl0IGlzIHByb3ZpZGVkLlxuICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KENISUxEUkVOX1BST1ApICYmIGNoaWxkLnByb3BzLmhhc093blByb3BlcnR5KENISUxEUkVOX1BST1ApKSB7XG4gICAgbmV3UHJvcHMuY2hpbGRyZW4gPSBjaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgfVxuXG4gIC8vIFRoZSBjdXJyZW50IEFQSSBkb2Vzbid0IHJldGFpbiBfb3duZXIgYW5kIF9jb250ZXh0LCB3aGljaCBpcyB3aHkgdGhpc1xuICAvLyBkb2Vzbid0IHVzZSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudChjaGlsZC50eXBlLCBuZXdQcm9wcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVXaXRoUHJvcHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNvbnRhaW5zTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZShcIi4vaXNUZXh0Tm9kZVwiKTtcblxuLypqc2xpbnQgYml0d2lzZTp0cnVlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqXG4gKiBAcGFyYW0gez9ET01Ob2RlfSBvdXRlck5vZGUgT3V0ZXIgRE9NIG5vZGUuXG4gKiBAcGFyYW0gez9ET01Ob2RlfSBpbm5lck5vZGUgSW5uZXIgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvdXRlck5vZGVgIGNvbnRhaW5zIG9yIGlzIGBpbm5lck5vZGVgLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUoX3gsIF94Mikge1xuICB2YXIgX2FnYWluID0gdHJ1ZTtcblxuICBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHtcbiAgICB2YXIgb3V0ZXJOb2RlID0gX3gsXG4gICAgICAgIGlubmVyTm9kZSA9IF94MjtcbiAgICBfYWdhaW4gPSBmYWxzZTtcblxuICAgIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgICBfeCA9IG91dGVyTm9kZTtcbiAgICAgIF94MiA9IGlubmVyTm9kZS5wYXJlbnROb2RlO1xuICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlIF9mdW5jdGlvbjtcbiAgICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb250YWlucykge1xuICAgICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZUFycmF5RnJvbU1peGVkXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvQXJyYXkgPSByZXF1aXJlKFwiLi90b0FycmF5XCIpO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuIChcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiYgJ2xlbmd0aCcgaW4gb2JqICYmXG4gICAgLy8gbm90IHdpbmRvd1xuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxuICAgIC8vIGEgcmVhbCBhcnJheVxuICAgIChBcnJheS5pc0FycmF5KG9iaikgfHwgJ2NhbGxlZScgaW4gb2JqIHx8ICdpdGVtJyBpbiBvYmopKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG4vLyBhcnJheXMgYXJlIG9iamVjdHMsIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuXG4vLyBxdWFja3MgbGlrZSBhbiBhcnJheVxuXG4vLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4vLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcblxuLy8gYXJndW1lbnRzXG5cbi8vIEhUTUxDb2xsZWN0aW9uL05vZGVMaXN0IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gRGVmZWF0IGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgcmVxdWlyaW5nIHRoaXMgZGlyZWN0bHkuXG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoXCIuL1JlYWN0Q2xhc3NcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvbXBvbmVudCB0aGF0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gdW5tb3VudGVkLlxuICpcbiAqIENvbXBvbmVudHMgbGlrZSA8aHRtbD4gPGhlYWQ+IGFuZCA8Ym9keT4gY2FuJ3QgYmUgcmVtb3ZlZCBvciBhZGRlZFxuICogZWFzaWx5IGluIGEgY3Jvc3MtYnJvd3NlciB3YXksIGhvd2V2ZXIgaXQncyB2YWx1YWJsZSB0byBiZSBhYmxlIHRvXG4gKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gKiBtYW5hZ2VtZW50LiBTbyB3ZSBqdXN0IGRvY3VtZW50IGl0IGFuZCB0aHJvdyBpbiBkYW5nZXJvdXMgY2FzZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgdGFnIHRvIHdyYXBcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjb252ZW5pZW5jZSBjb25zdHJ1Y3RvciBvZiBuZXcgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KHRhZykge1xuICB2YXIgZWxlbWVudEZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSh0YWcpO1xuXG4gIHZhciBGdWxsUGFnZUNvbXBvbmVudCA9IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3Moe1xuICAgIHRhZ05hbWU6IHRhZy50b1VwcGVyQ2FzZSgpLFxuICAgIGRpc3BsYXlOYW1lOiAnUmVhY3RGdWxsUGFnZUNvbXBvbmVudCcgKyB0YWcsXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgIWZhbHNlID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJyVzIHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgJyArICdpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCA8aGVhZD4sICcgKyAnYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhIHNpbmdsZSAnICsgJ3RvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgZWxlbWVudHMuJywgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBlbGVtZW50RmFjdG9yeSh0aGlzLnByb3BzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBGdWxsUGFnZUNvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVGdWxsUGFnZUNvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTm9kZXNGcm9tTWFya3VwXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUsIHN1YjogdHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKFwiLi9jcmVhdGVBcnJheUZyb21NaXhlZFwiKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZShcIi4vZ2V0TWFya3VwV3JhcFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBjcmVhdGVBcnJheUZyb21NaXhlZChub2RlLmNoaWxkTm9kZXMpO1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkYW5nZXJvdXNTdHlsZVZhbHVlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZShcIi4vQ1NTUHJvcGVydHlcIik7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcbiAgaWYgKGlzTm9uTnVtZXJpYyB8fCB2YWx1ZSA9PT0gMCB8fCBpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eU9iamVjdFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJzwnOiAnJmx0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjeDI3Oydcbn07XG5cbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcblxuZnVuY3Rpb24gZXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gRVNDQVBFX0xPT0tVUFttYXRjaF07XG59XG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBlc2NhcGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZpbmRET01Ob2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VNYXBcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgaXNOb2RlID0gcmVxdWlyZShcIi4vaXNOb2RlXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZ2V0RE9NTm9kZSBvciBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzTm9kZShjb21wb25lbnRPckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuICBpZiAoUmVhY3RJbnN0YW5jZU1hcC5oYXMoY29tcG9uZW50T3JFbGVtZW50KSkge1xuICAgIHJldHVybiBSZWFjdE1vdW50LmdldE5vZGVGcm9tSW5zdGFuY2UoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgfVxuICAhKGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT0gbnVsbCB8fCB0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciAhPT0gJ2Z1bmN0aW9uJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAnQ29tcG9uZW50ICh3aXRoIGtleXM6ICVzKSBjb250YWlucyBgcmVuZGVyYCBtZXRob2QgJyArICdidXQgaXMgbm90IG1vdW50ZWQgaW4gdGhlIERPTScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgIWZhbHNlID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZERPTU5vZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZsYXR0ZW5DaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKFwiLi90cmF2ZXJzZUFsbENoaWxkcmVuXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IHBhc3NlZCB0aHJvdWdoIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P1JlYWN0Q29tcG9uZW50fSBjaGlsZCBSZWFjdCBjaGlsZCBjb21wb25lbnQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgU3RyaW5nIG5hbWUgb2Yga2V5IHBhdGggdG8gY2hpbGQuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gIHZhciBrZXlVbmlxdWUgPSByZXN1bHRbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhrZXlVbmlxdWUsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4nLCBuYW1lKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcbiAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcbiAqIGNoaWxkcmVuIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9jdXNOb2RlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvckVhY2hBY2N1bXVsYXRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gZnVuY3Rpb24gKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IGJvZHkgaXMgbm90IHlldCBkZWZpbmVkLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudENoYXJDb2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRLZXlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50Q2hhckNvZGVcIik7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgJ0VzYyc6ICdFc2NhcGUnLFxuICAnU3BhY2ViYXInOiAnICcsXG4gICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICdVcCc6ICdBcnJvd1VwJyxcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAnRGVsJzogJ0RlbGV0ZScsXG4gICdXaW4nOiAnT1MnLFxuICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgJ01velByaW50YWJsZUtleSc6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRJdGVyYXRvckZuXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0TWFya3VwV3JhcFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG52YXIgc2hvdWxkV3JhcCA9IHtcbiAgLy8gRm9yY2Ugd3JhcHBpbmcgZm9yIFNWRyBlbGVtZW50cyBiZWNhdXNlIGlmIHRoZXkgZ2V0IGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4sXG4gIC8vIHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpbiB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG4gICdjaXJjbGUnOiB0cnVlLFxuICAnY2xpcFBhdGgnOiB0cnVlLFxuICAnZGVmcyc6IHRydWUsXG4gICdlbGxpcHNlJzogdHJ1ZSxcbiAgJ2cnOiB0cnVlLFxuICAnbGluZSc6IHRydWUsXG4gICdsaW5lYXJHcmFkaWVudCc6IHRydWUsXG4gICdwYXRoJzogdHJ1ZSxcbiAgJ3BvbHlnb24nOiB0cnVlLFxuICAncG9seWxpbmUnOiB0cnVlLFxuICAncmFkaWFsR3JhZGllbnQnOiB0cnVlLFxuICAncmVjdCc6IHRydWUsXG4gICdzdG9wJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlXG59O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcCxcblxuICAnY2lyY2xlJzogc3ZnV3JhcCxcbiAgJ2NsaXBQYXRoJzogc3ZnV3JhcCxcbiAgJ2RlZnMnOiBzdmdXcmFwLFxuICAnZWxsaXBzZSc6IHN2Z1dyYXAsXG4gICdnJzogc3ZnV3JhcCxcbiAgJ2xpbmUnOiBzdmdXcmFwLFxuICAnbGluZWFyR3JhZGllbnQnOiBzdmdXcmFwLFxuICAncGF0aCc6IHN2Z1dyYXAsXG4gICdwb2x5Z29uJzogc3ZnV3JhcCxcbiAgJ3BvbHlsaW5lJzogc3ZnV3JhcCxcbiAgJ3JhZGlhbEdyYWRpZW50Jzogc3ZnV3JhcCxcbiAgJ3JlY3QnOiBzdmdXcmFwLFxuICAnc3RvcCc6IHN2Z1dyYXAsXG4gICd0ZXh0Jzogc3ZnV3JhcFxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gICEhIWR1bW15Tm9kZSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlU3R5bGVOYW1lXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoXCIuL2h5cGhlbmF0ZVwiKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbXB0eUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0TmF0aXZlQ29tcG9uZW50XCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8vIFRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3ksIHdlIGNyZWF0ZSB0aGUgZmluYWwgY2xhc3MgaW4gdGhpcyBtb2R1bGVcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7fTtcbmFzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHR5cGUgcmVmZXJlbmNlIGlzIGEga25vd24gaW50ZXJuYWwgdHlwZS4gSS5lLiBub3QgYSB1c2VyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXG4gKlxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Kn0gcGFyZW50Q29tcG9zaXRlVHlwZSBUaGUgY29tcG9zaXRlIHR5cGUgdGhhdCByZXNvbHZlZCB0aGlzLlxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHBhcmVudENvbXBvc2l0ZVR5cGUpIHtcbiAgdmFyIGluc3RhbmNlO1xuXG4gIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgbm9kZSA9IFJlYWN0RW1wdHlDb21wb25lbnQuZW1wdHlFbGVtZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcbiAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJyksICdPbmx5IGZ1bmN0aW9ucyBvciBzdHJpbmdzIGNhbiBiZSBtb3VudGVkIGFzIFJlYWN0IGNvbXBvbmVudHMuJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgICBpZiAocGFyZW50Q29tcG9zaXRlVHlwZSA9PT0gZWxlbWVudC50eXBlICYmIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBBdm9pZCByZWN1cnNpb24gaWYgdGhlIHdyYXBwZXIgcmVuZGVycyBpdHNlbGYuXG4gICAgICBpbnN0YW5jZSA9IFJlYWN0TmF0aXZlQ29tcG9uZW50LmNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgLy8gQWxsIG5hdGl2ZSBjb21wb25lbnRzIGFyZSBjdXJyZW50bHkgd3JhcHBlZCBpbiBhIGNvbXBvc2l0ZSBzbyB3ZSdyZVxuICAgICAgLy8gc2FmZSB0byBhc3N1bWUgdGhhdCB0aGlzIGlzIHdoYXQgd2Ugc2hvdWxkIGluc3RhbnRpYXRlLlxuICAgIH0gZWxzZSBpZiAoaXNJbnRlcm5hbENvbXBvbmVudFR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgICAgLy8gVGhpcyBpcyB0ZW1wb3JhcmlseSBhdmFpbGFibGUgZm9yIGN1c3RvbSBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VuYXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5jb25zdHJ1Y3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gU2V0cyB1cCB0aGUgaW5zdGFuY2UuIFRoaXMgY2FuIHByb2JhYmx5IGp1c3QgbW92ZSBpbnRvIHRoZSBjb25zdHJ1Y3RvciBub3cuXG4gIGluc3RhbmNlLmNvbnN0cnVjdChub2RlKTtcblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaW5zdGFuY2UuX2lzT3duZXJOZWNlc3NhcnkgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignSW52YXJpYW50IFZpb2xhdGlvbjogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZG9jdW1lbnQpO1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgJ2NvbG9yJzogdHJ1ZSxcbiAgJ2RhdGUnOiB0cnVlLFxuICAnZGF0ZXRpbWUnOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICAnZW1haWwnOiB0cnVlLFxuICAnbW9udGgnOiB0cnVlLFxuICAnbnVtYmVyJzogdHJ1ZSxcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3NlYXJjaCc6IHRydWUsXG4gICd0ZWwnOiB0cnVlLFxuICAndGV4dCc6IHRydWUsXG4gICd0aW1lJzogdHJ1ZSxcbiAgJ3VybCc6IHRydWUsXG4gICd3ZWVrJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0gJiYgKGVsZW0ubm9kZU5hbWUgPT09ICdJTlBVVCcgJiYgc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdIHx8IGVsZW0ubm9kZU5hbWUgPT09ICdURVhUQVJFQScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0Tm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc05vZGUgPSByZXF1aXJlKFwiLi9pc05vZGVcIik7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgam9pbkNsYXNzZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGNsYXNzTmFtZSBzdHJpbmdzIGludG8gb25lLlxuICogaHR0cDovL2pzcGVyZi5jb20vam9pbmNsYXNzZXMtYXJncy12cy1hcnJheVxuICpcbiAqIEBwYXJhbSB7Li4uP3N0cmluZ30gY2xhc3Nlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBqb2luQ2xhc3NlcyhjbGFzc05hbWUgLyosIC4uLiAqLykge1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIGNsYXNzTmFtZSA9ICcnO1xuICB9XG4gIHZhciBuZXh0Q2xhc3M7XG4gIHZhciBhcmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAoYXJnTGVuZ3RoID4gMSkge1xuICAgIGZvciAodmFyIGlpID0gMTsgaWkgPCBhcmdMZW5ndGg7IGlpKyspIHtcbiAgICAgIG5leHRDbGFzcyA9IGFyZ3VtZW50c1tpaV07XG4gICAgICBpZiAobmV4dENsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuZXh0Q2xhc3M7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gam9pbkNsYXNzZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU1pcnJvclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gICEob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ2tleU1pcnJvciguLi4pOiBBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU9mXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgZXh0cmFjdGlvbiBvZiBhIG1pbmlmaWVkIGtleS4gTGV0J3MgdGhlIGJ1aWxkIHN5c3RlbSBtaW5pZnkga2V5c1xuICogd2l0aG91dCBsb29zaW5nIHRoZSBhYmlsaXR5IHRvIGR5bmFtaWNhbGx5IHVzZSBrZXkgc3RyaW5ncyBhcyB2YWx1ZXNcbiAqIHRoZW1zZWx2ZXMuIFBhc3MgaW4gYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5L3ZhbCBwYWlyIGFuZCBpdCB3aWxsIHJldHVyblxuICogeW91IHRoZSBzdHJpbmcga2V5IG9mIHRoYXQgc2luZ2xlIHJlY29yZC4gU3VwcG9zZSB5b3Ugd2FudCB0byBncmFiIHRoZVxuICogdmFsdWUgZm9yIGEga2V5ICdjbGFzc05hbWUnIGluc2lkZSBvZiBhbiBvYmplY3QuIEtleS92YWwgbWluaWZpY2F0aW9uIG1heVxuICogaGF2ZSBhbGlhc2VkIHRoYXQga2V5IHRvIGJlICd4YTEyJy4ga2V5T2Yoe2NsYXNzTmFtZTogbnVsbH0pIHdpbGwgcmV0dXJuXG4gKiAneGExMicgaW4gdGhhdCBjYXNlLiBSZXNvbHZlIGtleXMgeW91IHdhbnQgdG8gdXNlIG9uY2UgYXQgc3RhcnR1cCB0aW1lLCB0aGVuXG4gKiByZXVzZSB0aG9zZSByZXNvbHV0aW9ucy5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlPZiA9IGZ1bmN0aW9uIChvbmVLZXlPYmopIHtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb25lS2V5T2JqKSB7XG4gICAgaWYgKCFvbmVLZXlPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU9mOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtYXBPYmplY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGBjYWxsYmFja2Agb25jZSBmb3IgZWFjaCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0eSBpbiB0aGVcbiAqIG9iamVjdCBhbmQgY29uc3RydWN0cyBhIG5ldyBvYmplY3QgZnJvbSB0aGUgcmVzdWx0cy4gVGhlIGBjYWxsYmFja2AgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKlxuICogIC0gdGhlIHByb3BlcnR5IHZhbHVlXG4gKiAgLSB0aGUgcHJvcGVydHkgbmFtZVxuICogIC0gdGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGFkZGVkIGFmdGVyIHRoZSBjYWxsIHRvIGBtYXBPYmplY3RgIHdpbGwgbm90IGJlIHZpc2l0ZWRcbiAqIGJ5IGBjYWxsYmFja2AuIElmIHRoZSB2YWx1ZXMgb2YgZXhpc3RpbmcgcHJvcGVydGllcyBhcmUgY2hhbmdlZCwgdGhlIHZhbHVlXG4gKiBwYXNzZWQgdG8gYGNhbGxiYWNrYCB3aWxsIGJlIHRoZSB2YWx1ZSBhdCB0aGUgdGltZSBgbWFwT2JqZWN0YCB2aXNpdHMgdGhlbS5cbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgZGVsZXRlZCBiZWZvcmUgYmVpbmcgdmlzaXRlZCBhcmUgbm90IHZpc2l0ZWQuXG4gKlxuICogQGdyZXAgZnVuY3Rpb24gb2JqZWN0TWFwKClcbiAqIEBncmVwIGZ1bmN0aW9uIG9iak1hcCgpXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0W25hbWVdLCBuYW1lLCBvYmplY3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcE9iamVjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWVtb2l6ZVN0cmluZ09ubHlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG9ubHlDaGlsZFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi4gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpc1xuICogZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHMgcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlXG4gKiBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlXG4gKiBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RDb21wb25lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ29ubHlDaGlsZCBtdXN0IGJlIHBhc3NlZCBhIGNoaWxkcmVuIHdpdGggZXhhY3RseSBvbmUgY2hpbGQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBwZXJmb3JtYW5jZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlTm93XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZShcIi4vcGVyZm9ybWFuY2VcIik7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAoIXBlcmZvcm1hbmNlIHx8ICFwZXJmb3JtYW5jZS5ub3cpIHtcbiAgcGVyZm9ybWFuY2UgPSBEYXRlO1xufVxuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSBwZXJmb3JtYW5jZS5ub3cuYmluZChwZXJmb3JtYW5jZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXCIpO1xuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiogQHByb3ZpZGVzTW9kdWxlIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRJbm5lckhUTUxcbiAqL1xuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn07XG5cbi8vIFdpbjggYXBwczogQWxsb3cgYWxsIGh0bWwgdG8gYmUgaW5zZXJ0ZWRcbmlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0pO1xuICB9O1xufVxuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1Mjc5KSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRUZXh0Q29udGVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXCIpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoXCIuL3NldElubmVySFRNTFwiKTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgc2hhbGxvd0NvbXBhcmVcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuL3NoYWxsb3dFcXVhbFwiKTtcblxuLyoqXG4gKiBEb2VzIGEgc2hhbGxvdyBjb21wYXJpc29uIGZvciBwcm9wcyBhbmQgc3RhdGUuXG4gKiBTZWUgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKGluc3RhbmNlLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICByZXR1cm4gIXNoYWxsb3dFcXVhbChpbnN0YW5jZS5wcm9wcywgbmV4dFByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKGluc3RhbmNlLnN0YXRlLCBuZXh0U3RhdGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dDb21wYXJlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaGFsbG93RXF1YWxcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZ1xuICogZmFsc2Ugd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuXG4gKiBvYmpBIGFuZCBvYmpCLiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIHZhciBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXlzQVtpXSkgfHwgb2JqQVtrZXlzQVtpXV0gIT09IG9iakJba2V5c0FbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgaWYgKHByZXZFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQgIT0gbnVsbCkge1xuICAgIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgICB2YXIgbmV4dFR5cGUgPSB0eXBlb2YgbmV4dEVsZW1lbnQ7XG4gICAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdG9BcnJheVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZSBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdCBpblxuICAvLyBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuXG4vLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RGcmFnbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RnJhZ21lbnRcIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKFwiLi9nZXRJdGVyYXRvckZuXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIFNFUEFSQVRPUiA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLlNFUEFSQVRPUjtcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyTG9va3VwID0ge1xuICAnPSc6ICc9MCcsXG4gICcuJzogJz0xJyxcbiAgJzonOiAnPTInXG59O1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvWz0uOl0vZztcblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXNlclByb3ZpZGVkS2V5RXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cFttYXRjaF07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gd3JhcFVzZXJQcm92aWRlZEtleShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEVzY2FwZSBhIGNvbXBvbmVudCBrZXkgc28gdGhhdCBpdCBpcyBzYWZlIHRvIHVzZSBpbiBhIHJlYWN0aWQuXG4gKlxuICogQHBhcmFtIHsqfSBrZXkgQ29tcG9uZW50IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsIHVzZXJQcm92aWRlZEtleUVzY2FwZXIpO1xufVxuXG4vKipcbiAqIFdyYXAgYSBga2V5YCB2YWx1ZSBleHBsaWNpdGx5IHByb3ZpZGVkIGJ5IHRoZSB1c2VyIHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbiAqIGltcGxpY2l0bHktZ2VuZXJhdGVkIGtleXMgZ2VuZXJhdGVkIGJ5IGEgY29tcG9uZW50J3MgaW5kZXggaW4gaXRzIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFZhbHVlIG9mIGEgdXNlci1wcm92aWRlZCBga2V5YCBhdHRyaWJ1dGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gd3JhcFVzZXJQcm92aWRlZEtleShrZXkpIHtcbiAgcmV0dXJuICckJyArIGVzY2FwZVVzZXJQcm92aWRlZEtleShrZXkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSAobmFtZVNvRmFyICE9PSAnJyA/IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUiA6IFNFUEFSQVRPUikgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSAobmFtZVNvRmFyICE9PSAnJyA/IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUiA6IFNFUEFSQVRPUikgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gKG5hbWVTb0ZhciAhPT0gJycgPyBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1IgOiBTRVBBUkFUT1IpICsgd3JhcFVzZXJQcm92aWRlZEtleShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgIShjaGlsZHJlbi5ub2RlVHlwZSAhPT0gMSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VBbGxDaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCBhbiBpbnZhbGlkIGNoaWxkOyBET00gJyArICdlbGVtZW50cyBhcmUgbm90IHZhbGlkIGNoaWxkcmVuIG9mIFJlYWN0IGNvbXBvbmVudHMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGZyYWdtZW50ID0gUmVhY3RGcmFnbWVudC5leHRyYWN0KGNoaWxkcmVuKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmcmFnbWVudCkge1xuICAgICAgICBpZiAoZnJhZ21lbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNoaWxkID0gZnJhZ21lbnRba2V5XTtcbiAgICAgICAgICBuZXh0TmFtZSA9IChuYW1lU29GYXIgIT09ICcnID8gbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SIDogU0VQQVJBVE9SKSArIHdyYXBVc2VyUHJvdmlkZWRLZXkoa2V5KSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHVwZGF0ZVxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgaGFzT3duUHJvcGVydHkgPSAoe30pLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBzaGFsbG93Q29weSh4KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIHguY29uY2F0KCk7XG4gIH0gZWxzZSBpZiAoeCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gYXNzaWduKG5ldyB4LmNvbnN0cnVjdG9yKCksIHgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4O1xuICB9XG59XG5cbnZhciBDT01NQU5EX1BVU0ggPSBrZXlPZih7ICRwdXNoOiBudWxsIH0pO1xudmFyIENPTU1BTkRfVU5TSElGVCA9IGtleU9mKHsgJHVuc2hpZnQ6IG51bGwgfSk7XG52YXIgQ09NTUFORF9TUExJQ0UgPSBrZXlPZih7ICRzcGxpY2U6IG51bGwgfSk7XG52YXIgQ09NTUFORF9TRVQgPSBrZXlPZih7ICRzZXQ6IG51bGwgfSk7XG52YXIgQ09NTUFORF9NRVJHRSA9IGtleU9mKHsgJG1lcmdlOiBudWxsIH0pO1xudmFyIENPTU1BTkRfQVBQTFkgPSBrZXlPZih7ICRhcHBseTogbnVsbCB9KTtcblxudmFyIEFMTF9DT01NQU5EU19MSVNUID0gW0NPTU1BTkRfUFVTSCwgQ09NTUFORF9VTlNISUZULCBDT01NQU5EX1NQTElDRSwgQ09NTUFORF9TRVQsIENPTU1BTkRfTUVSR0UsIENPTU1BTkRfQVBQTFldO1xuXG52YXIgQUxMX0NPTU1BTkRTX1NFVCA9IHt9O1xuXG5BTExfQ09NTUFORFNfTElTVC5mb3JFYWNoKGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gIEFMTF9DT01NQU5EU19TRVRbY29tbWFuZF0gPSB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIGludmFyaWFudEFycmF5Q2FzZSh2YWx1ZSwgc3BlYywgY29tbWFuZCkge1xuICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlKCk6IGV4cGVjdGVkIHRhcmdldCBvZiAlcyB0byBiZSBhbiBhcnJheTsgZ290ICVzLicsIGNvbW1hbmQsIHZhbHVlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciBzcGVjVmFsdWUgPSBzcGVjW2NvbW1hbmRdO1xuICAhQXJyYXkuaXNBcnJheShzcGVjVmFsdWUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiBleHBlY3RlZCBzcGVjIG9mICVzIHRvIGJlIGFuIGFycmF5OyBnb3QgJXMuICcgKyAnRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlciBpbiBhbiBhcnJheT8nLCBjb21tYW5kLCBzcGVjVmFsdWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlKHZhbHVlLCBzcGVjKSB7XG4gICEodHlwZW9mIHNwZWMgPT09ICdvYmplY3QnKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGUoKTogWW91IHByb3ZpZGVkIGEga2V5IHBhdGggdG8gdXBkYXRlKCkgdGhhdCBkaWQgbm90IGNvbnRhaW4gb25lICcgKyAnb2YgJXMuIERpZCB5b3UgZm9yZ2V0IHRvIGluY2x1ZGUgeyVzOiAuLi59PycsIEFMTF9DT01NQU5EU19MSVNULmpvaW4oJywgJyksIENPTU1BTkRfU0VUKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3BlYywgQ09NTUFORF9TRVQpKSB7XG4gICAgIShPYmplY3Qua2V5cyhzcGVjKS5sZW5ndGggPT09IDEpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBoYXZlIG1vcmUgdGhhbiBvbmUga2V5IGluIGFuIG9iamVjdCB3aXRoICVzJywgQ09NTUFORF9TRVQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBzcGVjW0NPTU1BTkRfU0VUXTtcbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBzaGFsbG93Q29weSh2YWx1ZSk7XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3BlYywgQ09NTUFORF9NRVJHRSkpIHtcbiAgICB2YXIgbWVyZ2VPYmogPSBzcGVjW0NPTU1BTkRfTUVSR0VdO1xuICAgICEobWVyZ2VPYmogJiYgdHlwZW9mIG1lcmdlT2JqID09PSAnb2JqZWN0JykgPyAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlKCk6ICVzIGV4cGVjdHMgYSBzcGVjIG9mIHR5cGUgXFwnb2JqZWN0XFwnOyBnb3QgJXMnLCBDT01NQU5EX01FUkdFLCBtZXJnZU9iaikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEobmV4dFZhbHVlICYmIHR5cGVvZiBuZXh0VmFsdWUgPT09ICdvYmplY3QnKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGUoKTogJXMgZXhwZWN0cyBhIHRhcmdldCBvZiB0eXBlIFxcJ29iamVjdFxcJzsgZ290ICVzJywgQ09NTUFORF9NRVJHRSwgbmV4dFZhbHVlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgYXNzaWduKG5leHRWYWx1ZSwgc3BlY1tDT01NQU5EX01FUkdFXSk7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzcGVjLCBDT01NQU5EX1BVU0gpKSB7XG4gICAgaW52YXJpYW50QXJyYXlDYXNlKHZhbHVlLCBzcGVjLCBDT01NQU5EX1BVU0gpO1xuICAgIHNwZWNbQ09NTUFORF9QVVNIXS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBuZXh0VmFsdWUucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNwZWMsIENPTU1BTkRfVU5TSElGVCkpIHtcbiAgICBpbnZhcmlhbnRBcnJheUNhc2UodmFsdWUsIHNwZWMsIENPTU1BTkRfVU5TSElGVCk7XG4gICAgc3BlY1tDT01NQU5EX1VOU0hJRlRdLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIG5leHRWYWx1ZS51bnNoaWZ0KGl0ZW0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3BlYywgQ09NTUFORF9TUExJQ0UpKSB7XG4gICAgIUFycmF5LmlzQXJyYXkodmFsdWUpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkICVzIHRhcmdldCB0byBiZSBhbiBhcnJheTsgZ290ICVzJywgQ09NTUFORF9TUExJQ0UsIHZhbHVlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIUFycmF5LmlzQXJyYXkoc3BlY1tDT01NQU5EX1NQTElDRV0pID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiBleHBlY3RlZCBzcGVjIG9mICVzIHRvIGJlIGFuIGFycmF5IG9mIGFycmF5czsgZ290ICVzLiAnICsgJ0RpZCB5b3UgZm9yZ2V0IHRvIHdyYXAgeW91ciBwYXJhbWV0ZXJzIGluIGFuIGFycmF5PycsIENPTU1BTkRfU1BMSUNFLCBzcGVjW0NPTU1BTkRfU1BMSUNFXSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHNwZWNbQ09NTUFORF9TUExJQ0VdLmZvckVhY2goZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICFBcnJheS5pc0FycmF5KGFyZ3MpID8gJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZSgpOiBleHBlY3RlZCBzcGVjIG9mICVzIHRvIGJlIGFuIGFycmF5IG9mIGFycmF5czsgZ290ICVzLiAnICsgJ0RpZCB5b3UgZm9yZ2V0IHRvIHdyYXAgeW91ciBwYXJhbWV0ZXJzIGluIGFuIGFycmF5PycsIENPTU1BTkRfU1BMSUNFLCBzcGVjW0NPTU1BTkRfU1BMSUNFXSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgbmV4dFZhbHVlLnNwbGljZS5hcHBseShuZXh0VmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc3BlYywgQ09NTUFORF9BUFBMWSkpIHtcbiAgICAhKHR5cGVvZiBzcGVjW0NPTU1BTkRfQVBQTFldID09PSAnZnVuY3Rpb24nKSA/ICdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGUoKTogZXhwZWN0ZWQgc3BlYyBvZiAlcyB0byBiZSBhIGZ1bmN0aW9uOyBnb3QgJXMuJywgQ09NTUFORF9BUFBMWSwgc3BlY1tDT01NQU5EX0FQUExZXSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIG5leHRWYWx1ZSA9IHNwZWNbQ09NTUFORF9BUFBMWV0obmV4dFZhbHVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGsgaW4gc3BlYykge1xuICAgIGlmICghKEFMTF9DT01NQU5EU19TRVQuaGFzT3duUHJvcGVydHkoaykgJiYgQUxMX0NPTU1BTkRTX1NFVFtrXSkpIHtcbiAgICAgIG5leHRWYWx1ZVtrXSA9IHVwZGF0ZSh2YWx1ZVtrXSwgc3BlY1trXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGRhdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB2YWxpZGF0ZURPTU5lc3RpbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKCdwcm9kdWN0aW9uJyAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBwYXJlbnRUYWc6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBhc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5wYXJlbnRUYWcgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG5cbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcblxuICAgICAgY2FzZSAndGFibGUnOlxuXG4gICAgICBjYXNlICdocic6XG5cbiAgICAgIGNhc2UgJ3htcCc6XG5cbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGluc3RhbmNlLCByZXR1cm4gYSBsaXN0IG9mIGl0cyByZWN1cnNpdmVcbiAgICogb3duZXJzLCBzdGFydGluZyBhdCB0aGUgcm9vdCBhbmQgZW5kaW5nIHdpdGggdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHZhciBmaW5kT3duZXJTdGFjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAvKmVzbGludC1kaXNhYmxlIHNwYWNlLWFmdGVyLWtleXdvcmRzICovXG4gICAgZG8ge1xuICAgICAgLyplc2xpbnQtZW5hYmxlIHNwYWNlLWFmdGVyLWtleXdvcmRzICovXG4gICAgICBzdGFjay5wdXNoKGluc3RhbmNlKTtcbiAgICB9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIHN0YWNrLnJldmVyc2UoKTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5wYXJlbnRUYWc7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmIChwcm9ibGVtYXRpYykge1xuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XG5cbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGFuZCBjaGlsZCBpbnN0YW5jZXMgaGF2ZSBhIGNvbW1vbiBvd25lciBhbmNlc3Rvciwgc3RhcnRcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXG4gICAgICAvLyBJZiB3ZSdyZSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgKG5vbi1wYXJlbnQpIGFuY2VzdHJ5LCBhZGQgJy4uLidcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XG5cbiAgICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIG93bmVySW5mbztcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgJ3Byb2R1Y3Rpb24nICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogPCVzPiBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4gJyArICdTZWUgJXMuJXMnLCBjaGlsZFRhZywgYW5jZXN0b3JUYWcsIG93bmVySW5mbywgaW5mbykgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiA8JXM+IGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4gU2VlICVzLicsIGNoaWxkVGFnLCBhbmNlc3RvclRhZywgb3duZXJJbmZvKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXkgPSAnX192YWxpZGF0ZURPTU5lc3RpbmdfYW5jZXN0b3JJbmZvJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8ucGFyZW50VGFnO1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlRE9NTmVzdGluZzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgd2FybmluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmICgncHJvZHVjdGlvbicgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8IC9eW3NcXFddKiQvLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICsgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZzsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG4iLCJ2YXIgQXBwRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvQXBwRGlzcGF0Y2hlcicpO1xyXG5cclxudmFyIElucHV0QWN0aW9ucyA9IHtcclxuXHJcbiAgICB1cHNlcnQ6IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgQXBwRGlzcGF0Y2hlci5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IGlucHV0LmFjdGlvblR5cGUsXHJcbiAgICAgICAgICAgIG1vZGVsS2V5OiBpbnB1dC5tb2RlbEtleSxcclxuICAgICAgICAgICAgbW9kZWxWYWx1ZTogaW5wdXQubW9kZWxWYWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5wdXRBY3Rpb25zOyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBNYWluQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL01haW5Db21wb25lbnQnKTtcclxuXHJcblJlYWN0LnJlbmRlcig8TWFpbkNvbXBvbmVudCAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKTsiLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIgSW5wdXRBY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vYWN0aW9ucy9JbnB1dEFjdGlvbnMnKTtcclxuXHJcbnZhciBJbnB1dENvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIF9vbklucHV0Q2hhbmdlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBpbnB1dCA9IFJlYWN0LmZpbmRET01Ob2RlKHRoaXMucmVmcy5pbnB1dCkudmFsdWUudHJpbSgpO1xyXG4gICAgICAgIGlmKGlucHV0ID09PSAnJyl7XHJcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkOyAvL2RlbGV0ZWQgdGhlaXIgaW5wdXQ7IHJlc29ydCB0byB1bmRlZmluZWR8fGRlZmF1bHRzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMucHJvcHMuaXNWYWxpZChpbnB1dCkpe1xyXG4gICAgICAgICAgICBpZihpbnB1dCAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gdGhpcy5wcm9wcy5jb252ZXJ0KGlucHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBJbnB1dEFjdGlvbnMudXBzZXJ0KHtcclxuICAgICAgICAgICAgICAgIGFjdGlvblR5cGU6IHRoaXMucHJvcHMuYWN0aW9uVHlwZSxcclxuICAgICAgICAgICAgICAgIG1vZGVsS2V5OiB0aGlzLnByb3BzLmlkLFxyXG4gICAgICAgICAgICAgICAgbW9kZWxWYWx1ZTogaW5wdXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGJlZm9yZSwgYWZ0ZXI7XHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5hZGRPbkJlZm9yZUlucHV0ID09PSB1bmRlZmluZWQgfHwgdGhpcy5wcm9wcy5hZGRPbkJlZm9yZUlucHV0KXtcclxuICAgICAgICAgICAgYmVmb3JlID0gPHNwYW4gY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj57dGhpcy5wcm9wcy5hZGRPbn08L3NwYW4+O1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBhZnRlciA9IDxzcGFuIGNsYXNzTmFtZT1cImlucHV0LWdyb3VwLWFkZG9uXCI+e3RoaXMucHJvcHMuYWRkT259PC9zcGFuPjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gdGhpcy5wcm9wcy5yZXF1aXJlZCA/ICcgcmVxdWlyZWQnIDogJyc7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9e1wibGFiZWwgbGFiZWwtZGVmYXVsdFwiICsgcmVxdWlyZWR9IGh0bWxGb3I9e3RoaXMucHJvcHMuaWR9Pnt0aGlzLnByb3BzLmxhYmVsfTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0LWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAge2JlZm9yZX1cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ9e3RoaXMucHJvcHMuaWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9e3RoaXMucHJvcHMudHlwZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17dGhpcy5wcm9wcy5pZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3RoaXMucHJvcHMuZGVmYXVsdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uSW5wdXRDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj1cImlucHV0XCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICAgIHthZnRlcn1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5wdXRDb21wb25lbnQ7IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIElucHV0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9JbnB1dENvbXBvbmVudCcpO1xyXG52YXIgTW9udGhseUNvc3RJbnB1dERlZmluaXRpb25zID0gcmVxdWlyZSgnLi4vLi4vZGVmaW5lcy9Nb250aGx5Q29zdElucHV0RGVmaW5pdGlvbnMnKTtcclxudmFyIFNjZW5hcmlvSW5wdXREZWZpbml0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RlZmluZXMvU2NlbmFyaW9JbnB1dERlZmluaXRpb25zJyk7XHJcblxyXG52YXIgTWFpbkNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGlucHV0cyA9IFNjZW5hcmlvSW5wdXREZWZpbml0aW9ucy5nZXQoKTtcclxuICAgICAgICBpbnB1dHMgPSBpbnB1dHMuY29uY2F0KE1vbnRobHlDb3N0SW5wdXREZWZpbml0aW9ucy5nZXQoKSk7XHJcbiAgICAgICAgdmFyIGlucHV0Q29tcG9uZW50cztcclxuICAgICAgICBpZihpbnB1dHMgIT09IHVuZGVmaW5lZCAmJiBpbnB1dHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpbnB1dENvbXBvbmVudHMgPSBpbnB1dHMubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxJbnB1dENvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2UuaWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPXtlLmlkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25UeXBlPXtlLmFjdGlvblR5cGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9e2UudHlwZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2UubGFiZWx9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ9e2UuZGVmYXVsdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ9e2UucmVxdWlyZWR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9uQmVmb3JlSW5wdXQ9e2UuYWRkT25CZWZvcmVJbnB1dHx8dHJ1ZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT249e2UuYWRkT259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQ9e2UuaXNWYWxpZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydD17ZS5jb252ZXJ0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXRMaXN0XCI+XHJcbiAgICAgICAgICAgICAgICB7aW5wdXRDb21wb25lbnRzfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFpbkNvbXBvbmVudDsiLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIgVGl0bGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1RpdGxlQ29tcG9uZW50L1RpdGxlQ29tcG9uZW50Jyk7XHJcbnZhciBJbnB1dExpc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL0lucHV0TGlzdENvbXBvbmVudC9JbnB1dExpc3RDb21wb25lbnQnKTtcclxudmFyIFJlc3VsdExpc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1Jlc3VsdExpc3RDb21wb25lbnQvUmVzdWx0TGlzdENvbXBvbmVudCcpO1xyXG5cclxudmFyIE1haW5Db21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWFpbkNvbXBvbmVudFwiPlxyXG4gICAgICAgICAgICAgICAgPFRpdGxlQ29tcG9uZW50IC8+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXRMaXN0Q29tcG9uZW50IC8+XHJcbiAgICAgICAgICAgICAgICA8UmVzdWx0TGlzdENvbXBvbmVudCAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWFpbkNvbXBvbmVudDtcclxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIEhpZ2hjaGFydHMgPSByZXF1aXJlKCdyZWFjdC1oaWdoY2hhcnRzJyk7XHJcblxyXG52YXIgSW5jb21lQnJlYWtkb3duQ29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaW5jb21lQnJlYWtEb3duQ2hhcnQ7XHJcblxyXG4gICAgICAgIGlmKHRoaXMucHJvcHMubW9udGhseUluY29tZSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBicmVha2Rvd25zID0gW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnVGFrZSBob21lJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKHRoaXMucHJvcHMubmV0SW5jb21lIC8gdGhpcy5wcm9wcy5tb250aGx5SW5jb21lKSAqIDEwMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0V4cGVuc2VzJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKHRoaXMucHJvcHMubW9udGhseUV4cGVuc2VzIC8gdGhpcy5wcm9wcy5tb250aGx5SW5jb21lKSAqIDEwMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ01vbnRobHkgQ2FyIENvc3QnLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAodGhpcy5wcm9wcy5tb250aGx5Q2FyQ29zdCAvIHRoaXMucHJvcHMubW9udGhseUluY29tZSkgKiAxMDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gW107XHJcbiAgICAgICAgICAgIGJyZWFrZG93bnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUudmFsdWUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtlLmxhYmVsLCBlLnZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxvdEJhY2tncm91bmRDb2xvcjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBwbG90Qm9yZGVyV2lkdGg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcGxvdFNoYWRvdzogZmFsc2VcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0aXRsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdJbmNvbWU8YnI+QnJlYWtkb3duJyxcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogNDBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRGb3JtYXQ6ICd7c2VyaWVzLm5hbWV9OiA8Yj57cG9pbnQucGVyY2VudGFnZTouMWZ9JTwvYj4nXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGxvdE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBwaWU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxhYmVsczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAtNTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0U2hhZG93OiAnMHB4IDFweCAycHggYmxhY2snXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IC05MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IDkwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IFsnNTAlJywgJzc1JSddXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNlcmllczogW3tcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGllJyxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnSW5jb21lIEJyZWFrZG93bicsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTaXplOiAnNTAlJyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpbmNvbWVCcmVha0Rvd25DaGFydCA9IDxIaWdoY2hhcnRzIGNvbmZpZyA9IHtjb25maWd9PjwvSGlnaGNoYXJ0cz47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICB7aW5jb21lQnJlYWtEb3duQ2hhcnR9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmNvbWVCcmVha2Rvd25Db21wb25lbnQ7XHJcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG52YXIgTmV0SW5jb21lVGV4dENvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ3ZWxsIGNlbnRlclRleHRcIj5UYWtlIEhvbWUgUGVyIE1vbnRoIEFmdGVyIEV4cGVuc2VzIEFuZCBDYXIgUGF5bWVudCAke3RoaXMucHJvcHMubmV0SW5jb21lLnRvRml4ZWQoMil9PC9oMj47XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOZXRJbmNvbWVUZXh0Q29tcG9uZW50OyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBJbnB1dEFjdGlvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG52YXIgSW5wdXRTdG9yZSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3N0b3Jlcy9JbnB1dFN0b3JlJyk7XHJcblxyXG52YXIgU2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICBfb25JbnB1dENoYW5nZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIGlucHV0czogSW5wdXRTdG9yZS5nZXRBbGwoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBJbnB1dFN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKElucHV0QWN0aW9uQ29uc3RhbnRzLlNBRkVUWV9ORVRfQ0hBTkdFLCB0aGlzLl9vbklucHV0Q2hhbmdlKTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgSW5wdXRTdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcihJbnB1dEFjdGlvbkNvbnN0YW50cy5TQUZFVFlfTkVUX0NIQU5HRSwgdGhpcy5fb25JbnB1dENoYW5nZSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbnB1dHM6IElucHV0U3RvcmUuZ2V0QWxsKClcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNhZmV0eU5ldEVmZmVjdFRleHQ7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuc3RhdGUuaW5wdXRzLnNhZmV0eU5ldCA+IDApe1xyXG4gICAgICAgICAgICB2YXIgbW9udGhzT2ZTYWZldHlOZXRFZmZlY3QgPSAxMjtcclxuICAgICAgICAgICAgdmFyIG92ZXJUaW1lID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0xOyBpPD1tb250aHNPZlNhZmV0eU5ldEVmZmVjdDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIG92ZXJUaW1lW2ldID0gKHRoaXMuc3RhdGUuaW5wdXRzLnNhZmV0eU5ldCArICh0aGlzLnByb3BzLm5ldEluY29tZSAqIGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzYWZldHlOZXRFZmZlY3RUZXh0ID0gPGgyIGNsYXNzTmFtZT1cIndlbGwgY2VudGVyVGV4dFwiPkFmdGVyIDYgTW9udGhzIFlvdXIgU2FmZXR5IE5ldCBXb3VsZCBCZSBBdCAke292ZXJUaW1lWzZdLnRvRml4ZWQoMil9PC9oMj47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAge3NhZmV0eU5ldEVmZmVjdFRleHR9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudDsiLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIElucHV0QWN0aW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uc3RhbnRzL0lucHV0QWN0aW9uQ29uc3RhbnRzJyk7XHJcbnZhciBJbnB1dFN0b3JlID0gcmVxdWlyZSgnLi4vLi4vLi4vc3RvcmVzL0lucHV0U3RvcmUnKTtcclxudmFyIFZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL1ZhbGlkYXRvcnMnKTtcclxudmFyIFNjZW5hcmlvSW5wdXREZWZpbml0aW9ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL2RlZmluZXMvU2NlbmFyaW9JbnB1dERlZmluaXRpb25zJyk7XHJcblxyXG52YXIgSW5jb21lQnJlYWtkb3duQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9OZXRJbmNvbWVCYXNlZENvbXBvbmVudHMvSW5jb21lQnJlYWtkb3duQ29tcG9uZW50Jyk7XHJcbnZhciBOZXRJbmNvbWVUZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9OZXRJbmNvbWVCYXNlZENvbXBvbmVudHMvTmV0SW5jb21lVGV4dENvbXBvbmVudCcpO1xyXG52YXIgU2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnQgPSByZXF1aXJlKCcuL05ldEluY29tZUJhc2VkQ29tcG9uZW50cy9TYWZldHlOZXRPdmVyVGltZUNvbXBvbmVudCcpO1xyXG5cclxudmFyIGxpc3RlblRvQWN0aW9ucyA9IFtcclxuICAgIElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfSU5DT01FX0NIQU5HRSxcclxuICAgIElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfRVhQRU5TRVNfQ0hBTkdFXHJcbl07XHJcblxyXG52YXIgUmVzdWx0TGlzdENvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIF9vbklucHV0Q2hhbmdlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgaW5wdXRzOiBJbnB1dFN0b3JlLmdldEFsbCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBsaXN0ZW5Ub0FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb25UeXBlQ29uc3RhbnQpe1xyXG4gICAgICAgICAgICBJbnB1dFN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKGFjdGlvblR5cGVDb25zdGFudCwgc2VsZi5fb25JbnB1dENoYW5nZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBsaXN0ZW5Ub0FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb25UeXBlQ29uc3RhbnQpe1xyXG4gICAgICAgICAgICBJbnB1dFN0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKGFjdGlvblR5cGVDb25zdGFudCwgc2VsZi5fb25JbnB1dENoYW5nZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbnB1dHM6IElucHV0U3RvcmUuZ2V0QWxsKClcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGluY29tZUJyZWFrZG93bkNvbXBvbmVudDtcclxuICAgICAgICB2YXIgbmV0SW5jb21lVGV4dENvbXBvbmVudDtcclxuICAgICAgICB2YXIgc2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnQ7XHJcblxyXG4gICAgICAgIGlmKFZhbGlkYXRvcnMudmFsaWRhdGVSZXF1aXJlZElucHV0c0V4aXN0KFNjZW5hcmlvSW5wdXREZWZpbml0aW9ucy5nZXQoKSwgdGhpcy5zdGF0ZS5pbnB1dHMpKXtcclxuICAgICAgICAgICAgdmFyIG5ldEluY29tZSA9IHRoaXMuc3RhdGUuaW5wdXRzLm1vbnRobHlJbmNvbWUgLSB0aGlzLnN0YXRlLmlucHV0cy5tb250aGx5RXhwZW5zZXMgLSB0aGlzLnByb3BzLm1vbnRobHlDYXJDb3N0O1xyXG4gICAgICAgICAgICBpbmNvbWVCcmVha2Rvd25Db21wb25lbnQgPSA8SW5jb21lQnJlYWtkb3duQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBuZXRJbmNvbWU9e25ldEluY29tZX1cclxuICAgICAgICAgICAgICAgIG1vbnRobHlJbmNvbWU9e3RoaXMuc3RhdGUuaW5wdXRzLm1vbnRobHlJbmNvbWV9XHJcbiAgICAgICAgICAgICAgICBtb250aGx5Q2FyQ29zdD17dGhpcy5wcm9wcy5tb250aGx5Q2FyQ29zdH1cclxuICAgICAgICAgICAgICAgIG1vbnRobHlFeHBlbnNlcz17dGhpcy5zdGF0ZS5pbnB1dHMubW9udGhseUV4cGVuc2VzfVxyXG4gICAgICAgICAgICAvPjtcclxuICAgICAgICAgICAgbmV0SW5jb21lVGV4dENvbXBvbmVudCA9IDxOZXRJbmNvbWVUZXh0Q29tcG9uZW50IG5ldEluY29tZT17bmV0SW5jb21lfSAvPjtcclxuICAgICAgICAgICAgc2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnQgPSA8U2FmZXR5TmV0T3ZlclRpbWVDb21wb25lbnQgbmV0SW5jb21lPXtuZXRJbmNvbWV9IC8+O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAge2luY29tZUJyZWFrZG93bkNvbXBvbmVudH1cclxuICAgICAgICAgICAgICAgIHtuZXRJbmNvbWVUZXh0Q29tcG9uZW50fVxyXG4gICAgICAgICAgICAgICAge3NhZmV0eU5ldE92ZXJUaW1lQ29tcG9uZW50fVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzdWx0TGlzdENvbXBvbmVudDtcclxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIElucHV0QWN0aW9uQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vY29uc3RhbnRzL0lucHV0QWN0aW9uQ29uc3RhbnRzJyk7XHJcbnZhciBJbnB1dFN0b3JlID0gcmVxdWlyZSgnLi4vLi4vc3RvcmVzL0lucHV0U3RvcmUnKTtcclxudmFyIFZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi8uLi91dGlsL1ZhbGlkYXRvcnMnKTtcclxudmFyIE1vbnRobHlDb3N0SW5wdXREZWZpbml0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RlZmluZXMvTW9udGhseUNvc3RJbnB1dERlZmluaXRpb25zJyk7XHJcbnZhciBDYWxjdWxhdGlvbnMgPSByZXF1aXJlKCcuLi8uLi91dGlsL0NhbGN1bGF0aW9ucycpO1xyXG52YXIgTmV0SW5jb21lQmFzZWRMaXN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZXN1bHRDb21wb25lbnRzL05ldEluY29tZUJhc2VkTGlzdENvbXBvbmVudCcpO1xyXG5cclxudmFyIFJlc3VsdExpc3RDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICBfb25JbnB1dENoYW5nZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIGlucHV0czogSW5wdXRTdG9yZS5nZXRBbGwoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBJbnB1dFN0b3JlLmFkZENoYW5nZUxpc3RlbmVyKElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UsIHRoaXMuX29uSW5wdXRDaGFuZ2UpO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBJbnB1dFN0b3JlLnJlbW92ZUNoYW5nZUxpc3RlbmVyKElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UsIHRoaXMuX29uSW5wdXRDaGFuZ2UpO1xyXG4gICAgfSxcclxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW5wdXRzOiBJbnB1dFN0b3JlLmdldEFsbCgpXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmKFZhbGlkYXRvcnMudmFsaWRhdGVSZXF1aXJlZElucHV0c0V4aXN0KE1vbnRobHlDb3N0SW5wdXREZWZpbml0aW9ucy5nZXQoKSwgdGhpcy5zdGF0ZS5pbnB1dHMpKXtcclxuICAgICAgICAgICAgdmFyIG1vbnRobHlDYXJDb3N0ID0gQ2FsY3VsYXRpb25zLm1vbnRobHlDb3N0KFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMudmVoaWNsZVByaWNlLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMuZG93blBheW1lbnQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy50cmFkZUluLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMuaW50ZXJlc3RSYXRlLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnB1dHMuc2FsZXNUYXgsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0cy50ZXJtXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJtb250aGx5Q29zdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwid2VsbCBjZW50ZXJUZXh0XCI+Q2FyIFBheW1lbnQgJHttb250aGx5Q2FyQ29zdH0vbW9udGg8L2gyPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxOZXRJbmNvbWVCYXNlZExpc3RDb21wb25lbnQgbW9udGhseUNhckNvc3Q9e21vbnRobHlDYXJDb3N0fSAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+PC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VsdExpc3RDb21wb25lbnQ7XHJcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcbnZhciBUaXRsZURlZmluaXRpb25zID0gcmVxdWlyZSgnLi4vLi4vZGVmaW5lcy9UaXRsZURlZmluaXRpb25zJyk7XHJcbnZhciB0aXRsZUludGVydmFsVGltZSA9IDEwMDAwO1xyXG52YXIgdGl0bGVVcGRhdGVJbnRlcnZhbDtcclxuXHJcbnZhciBJbnB1dENvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgdGl0bGVzID0gVGl0bGVEZWZpbml0aW9ucy5nZXQoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aXRsZTogdGl0bGVzW01hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAodGl0bGVzLmxlbmd0aCkpKV1cclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aXRsZVVwZGF0ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHRpdGxlcyA9IFRpdGxlRGVmaW5pdGlvbnMuZ2V0KCk7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlc1tNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogKHRpdGxlcy5sZW5ndGgpKSldXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIHRpdGxlSW50ZXJ2YWxUaW1lKTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKXtcclxuICAgICAgICBjbGVhckludGVydmFsKHRpdGxlVXBkYXRlSW50ZXJ2YWwpO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgPGg1IGtleT1cInRpdGxlXCIgY2xhc3NOYW1lPVwiY2VudGVyVGV4dFwiPnt0aGlzLnN0YXRlLnRpdGxlfTwvaDU+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dENvbXBvbmVudDtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBNT05USExZX0lOQ09NRV9ERUZBVUxUOiAwLFxyXG4gICAgTU9OVEhMWV9FWFBFTlNFU19ERUZBVUxUOiAwLFxyXG4gICAgU0FGRVRZX05FVF9ERUZBVUxUOiAwLFxyXG4gICAgVkVISUNMRV9QUklDRV9ERUZBVUxUOiB1bmRlZmluZWQsIC8vb25seSByZXF1aXJlZCBmaWVsZCBmb3IgYXBwIHRvIGRvIGJhc2ljIGZ1bmNcclxuICAgIERPV05fUEFZTUVOVF9ERUZBVUxUOiAwLFxyXG4gICAgVFJBREVfSU5fREVGQVVMVDogMCxcclxuICAgIFNBTEVTX1RBWF9ERUZBVUxUOiA1LjEsXHJcbiAgICBJTlRFUkVTVF9SQVRFX0RFRkFVTFQ6IDIuOSxcclxuICAgIFRFUk1fREVGQVVMVDogNzJcclxufTsiLCJ2YXIga2V5TWlycm9yID0gcmVxdWlyZSgna2V5bWlycm9yJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcih7XHJcbiAgICBNT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFOiBudWxsLFxyXG4gICAgTU9OVEhMWV9JTkNPTUVfQ0hBTkdFOiBudWxsLFxyXG4gICAgTU9OVEhMWV9FWFBFTlNFU19DSEFOR0U6IG51bGwsXHJcbiAgICBTQUZFVFlfTkVUX0NIQU5HRTogbnVsbFxyXG59KTsiLCJtb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIERlZmF1bHRJbnB1dENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9EZWZhdWx0SW5wdXRWYWx1ZUNvbnN0YW50cycpO1xyXG4gICAgdmFyIElucHV0QWN0aW9ucyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG4gICAgdmFyIFZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi91dGlsL1ZhbGlkYXRvcnMnKTtcclxuICAgIHZhciBpbnB1dHMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3ZlaGljbGVQcmljZScsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9ucy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdWZWhpY2xlIFByaWNlJyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlZFSElDTEVfUFJJQ0VfREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5WRUhJQ0xFX1BSSUNFX0RFRkFVTFQgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWRkT246ICckJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZU51bWJlcklucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlSW50KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnZG93blBheW1lbnQnLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbnMuTU9OVEhMWV9DT1NUX0lOUFVUX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnRG93biBQYXltZW50JyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLkRPV05fUEFZTUVOVF9ERUZBVUxULFxyXG4gICAgICAgICAgICByZXF1aXJlZDogRGVmYXVsdElucHV0Q29uc3RhbnRzLkRPV05fUEFZTUVOVF9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3RyYWRlSW4nLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbnMuTU9OVEhMWV9DT1NUX0lOUFVUX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnVHJhZGUgSW4nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBEZWZhdWx0SW5wdXRDb25zdGFudHMuVFJBREVfSU5fREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5UUkFERV9JTl9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3NhbGVzVGF4JyxcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogSW5wdXRBY3Rpb25zLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ1NhbGVzIFRheCcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5TQUxFU19UQVhfREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5TQUxFU19UQVhfREVGQVVMVCA9PT0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBhZGRPbkJlZm9yZUlucHV0OiBmYWxzZSxcclxuICAgICAgICAgICAgYWRkT246ICclJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZVBlcmNlbnRJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUZsb2F0KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnaW50ZXJlc3RSYXRlJyxcclxuICAgICAgICAgICAgYWN0aW9uVHlwZTogSW5wdXRBY3Rpb25zLk1PTlRITFlfQ09TVF9JTlBVVF9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ0ludGVyZXN0IFJhdGUgKEFQUiknLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBEZWZhdWx0SW5wdXRDb25zdGFudHMuSU5URVJFU1RfUkFURV9ERUZBVUxULFxyXG4gICAgICAgICAgICByZXF1aXJlZDogRGVmYXVsdElucHV0Q29uc3RhbnRzLklOVEVSRVNUX1JBVEVfREVGQVVMVCA9PT0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBhZGRPbkJlZm9yZUlucHV0OiBmYWxzZSxcclxuICAgICAgICAgICAgYWRkT246ICclJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZVBlcmNlbnRJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUZsb2F0KGUpOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAndGVybScsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9ucy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdUZXJtIChNb250aHMpJyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLlRFUk1fREVGQVVMVCxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5URVJNX0RFRkFVTFQgPT09IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWRkT25CZWZvcmVJbnB1dDogZmFsc2UsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnbW9udGhzJyxcclxuICAgICAgICAgICAgaXNWYWxpZDogVmFsaWRhdG9ycy52YWxpZGF0ZU51bWJlcklucHV0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbihlKXsgcmV0dXJuIHBhcnNlSW50KGUpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgXTtcclxuICAgIHJldHVybiBpbnB1dHM7XHJcbn07IiwibW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBEZWZhdWx0SW5wdXRDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvRGVmYXVsdElucHV0VmFsdWVDb25zdGFudHMnKTtcclxuICAgIHZhciBJbnB1dEFjdGlvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG4gICAgdmFyIFZhbGlkYXRvcnMgPSByZXF1aXJlKCcuLi91dGlsL1ZhbGlkYXRvcnMnKTtcclxuICAgIHZhciBpbnB1dHMgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ21vbnRobHlJbmNvbWUnLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0lOQ09NRV9DSEFOR0UsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxyXG4gICAgICAgICAgICBsYWJlbDogJ01vbnRobHkgSW5jb21lJyxcclxuICAgICAgICAgICAgZGVmYXVsdDogRGVmYXVsdElucHV0Q29uc3RhbnRzLk1PTlRITFlfSU5DT01FX0RFRkFVTFQsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBEZWZhdWx0SW5wdXRDb25zdGFudHMuTU9OVEhMWV9JTkNPTUVfREVGQVVMVCA9PT0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBhZGRPbjogJyQnLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBWYWxpZGF0b3JzLnZhbGlkYXRlTnVtYmVySW5wdXQsXHJcbiAgICAgICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uKGUpeyByZXR1cm4gcGFyc2VJbnQoZSk7IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6ICdtb250aGx5RXhwZW5zZXMnLFxyXG4gICAgICAgICAgICBhY3Rpb25UeXBlOiBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0VYUEVOU0VTX0NIQU5HRSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnTW9udGhseSBFeHBlbnNlcycsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5NT05USExZX0VYUEVOU0VTX0RFRkFVTFQsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBEZWZhdWx0SW5wdXRDb25zdGFudHMuTU9OVEhMWV9FWFBFTlNFU19ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3NhZmV0eU5ldCcsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IElucHV0QWN0aW9uQ29uc3RhbnRzLlNBRkVUWV9ORVRfQ0hBTkdFLFxyXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgICAgbGFiZWw6ICdTYXZpbmdzIC8gU2FmZXR5IE5ldCcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IERlZmF1bHRJbnB1dENvbnN0YW50cy5TQUZFVFlfTkVUX0RFRkFVTFQsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBEZWZhdWx0SW5wdXRDb25zdGFudHMuU0FGRVRZX05FVF9ERUZBVUxUID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZE9uOiAnJCcsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IFZhbGlkYXRvcnMudmFsaWRhdGVOdW1iZXJJbnB1dCxcclxuICAgICAgICAgICAgY29udmVydDogZnVuY3Rpb24oZSl7IHJldHVybiBwYXJzZUludChlKTsgfVxyXG4gICAgICAgIH1cclxuICAgIF07XHJcbiAgICByZXR1cm4gaW5wdXRzO1xyXG59OyIsIm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIFwiSXQncyBXb3J0aCBJdC4gU2lnbi4gVHJ1c3QgTWUuXCIsXHJcbiAgICAgICAgXCJJdCdzIE9ubHkgNUsgTGVzcyBUaGFuIEEgTW9ydGdhZ2UuXCIsXHJcbiAgICAgICAgXCJDYW4gWW91IFJlYWxseSBQdXQgQSBQcmljZSBPbiBGdW4/XCIsXHJcbiAgICAgICAgXCJSZXRpcmVtZW50IElzIFN0aWxsIDQwIFllYXJzIE91dC5cIixcclxuICAgICAgICBcIldoZW4gSW4gRG91YnQgR2V0IEEgVjguXCIsXHJcbiAgICAgICAgXCJBZHJlbmFsaW5lIElzIFByaWNlbGVzcy5cIixcclxuICAgICAgICBcIkxpZmUgSXMgVG9vIFNob3J0IFRvIERyaXZlIEEgQm9yaW5nIENhci5cIixcclxuICAgICAgICBcIkp1c3QgQ3V0IEJhY2sgT24gRWF0aW5nIE91dC5cIlxyXG4gICAgXVxyXG59O1xyXG4iLCJ2YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJ2ZsdXgnKS5EaXNwYXRjaGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRGlzcGF0Y2hlcigpOyIsInZhciBBcHBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9BcHBEaXNwYXRjaGVyJyk7XHJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XHJcbnZhciBJbnB1dEFjdGlvbkNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9JbnB1dEFjdGlvbkNvbnN0YW50cycpO1xyXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIF9pbnB1dHMgPSB7fTtcclxuXHJcbnZhciBJbnB1dFN0b3JlID0gYXNzaWduKHt9LCBFdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XHJcblxyXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICAgIHJldHVybiBfaW5wdXRzW2tleV07XHJcbiAgICB9LFxyXG4gICAgZ2V0QWxsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX2lucHV0cztcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdE1vbnRobHlDb3N0SW5wdXRDaGFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuZW1pdChJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFKTtcclxuICAgIH0sXHJcblxyXG4gICAgZW1pdFNjZW5hcmlvQ2hhbmdlOiBmdW5jdGlvbihzY2VuYXJpb0FjdGlvblR5cGVDb25zdGFudCkge1xyXG4gICAgICAgIHRoaXMuZW1pdChzY2VuYXJpb0FjdGlvblR5cGVDb25zdGFudCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbihUeXBlT2ZDaGFuZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5vbihUeXBlT2ZDaGFuZ2UsIGNhbGxiYWNrKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24oVHlwZU9mQ2hhbmdlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoVHlwZU9mQ2hhbmdlLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcbkFwcERpc3BhdGNoZXIucmVnaXN0ZXIoZnVuY3Rpb24oYWN0aW9uKSB7XHJcblxyXG4gICAgc3dpdGNoKGFjdGlvbi5hY3Rpb25UeXBlKSB7XHJcbiAgICAgICAgY2FzZSBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0NPU1RfSU5QVVRfQ0hBTkdFOlxyXG4gICAgICAgICAgICBfaW5wdXRzW2FjdGlvbi5tb2RlbEtleV0gPSBhY3Rpb24ubW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgSW5wdXRTdG9yZS5lbWl0TW9udGhseUNvc3RJbnB1dENoYW5nZSgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIElucHV0QWN0aW9uQ29uc3RhbnRzLk1PTlRITFlfSU5DT01FX0NIQU5HRTpcclxuICAgICAgICAgICAgX2lucHV0c1thY3Rpb24ubW9kZWxLZXldID0gYWN0aW9uLm1vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIElucHV0U3RvcmUuZW1pdFNjZW5hcmlvQ2hhbmdlKGFjdGlvbi5hY3Rpb25UeXBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBJbnB1dEFjdGlvbkNvbnN0YW50cy5NT05USExZX0VYUEVOU0VTX0NIQU5HRTpcclxuICAgICAgICAgICAgX2lucHV0c1thY3Rpb24ubW9kZWxLZXldID0gYWN0aW9uLm1vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIElucHV0U3RvcmUuZW1pdFNjZW5hcmlvQ2hhbmdlKGFjdGlvbi5hY3Rpb25UeXBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBJbnB1dEFjdGlvbkNvbnN0YW50cy5TQUZFVFlfTkVUX0NIQU5HRTpcclxuICAgICAgICAgICAgX2lucHV0c1thY3Rpb24ubW9kZWxLZXldID0gYWN0aW9uLm1vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIElucHV0U3RvcmUuZW1pdFNjZW5hcmlvQ2hhbmdlKGFjdGlvbi5hY3Rpb25UeXBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAvLyBubyBvcFxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0U3RvcmU7IiwibW9kdWxlLmV4cG9ydHMubW9udGhseUNvc3QgPSBmdW5jdGlvbih2ZWhpY2xlUHJpY2UsIGRvd25QYXltZW50LCB0cmFkZUluLCBpbnRlcmVzdFJhdGUsIHNhbGVzVGF4LCB0ZXJtKXtcclxuICAgIHZhciBhZGp1c3RlZEludGVyZXN0UmF0ZVBlcmNlbnQgPSBpbnRlcmVzdFJhdGUgKiAuMDE7XHJcbiAgICB2YXIgYWRqdXN0ZWRTYWxlc1RheFBlcmNlbnQgPSBzYWxlc1RheCAqIC4wMTsgLy8gMi45ID0+IC4wMjlcclxuICAgIHZhciBzYWxlc1RheEFtb3VudCA9IHZlaGljbGVQcmljZSAqIGFkanVzdGVkU2FsZXNUYXhQZXJjZW50O1xyXG4gICAgdmFyIG5ldENvc3QgPSB2ZWhpY2xlUHJpY2UgKyBzYWxlc1RheEFtb3VudCAtIGRvd25QYXltZW50IC0gdHJhZGVJbjtcclxuICAgIHZhciByYXRlID0gYWRqdXN0ZWRJbnRlcmVzdFJhdGVQZXJjZW50IC8gMTI7XHJcbiAgICB2YXIgcmF0ZUNhbGMgPSAocmF0ZSAqIE1hdGgucG93KCgxICsgcmF0ZSksIHRlcm0pKS8oTWF0aC5wb3coKDEgKyByYXRlKSwgdGVybSkgLSAxKTtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KChuZXRDb3N0ICogcmF0ZUNhbGMpLnRvRml4ZWQoMikpO1xyXG59OyIsIi8qXHJcbiAgdW5kZWZpbmVkJ3MgYXJlIG9rLCBkZWZhdWx0cyBhcmUgc2V0IGZvciBpbnB1dHMgKGFuZCBpZiBubyBkZWZhdWx0LCBjYWxjIHNpbXBseSBpc24ndCBtYWRlKVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMudmFsaWRhdGVOdW1iZXJJbnB1dCA9IGZ1bmN0aW9uKGlucHV0KXtcclxuICAgIHRyeXtcclxuICAgICAgICBpZihpbnB1dCA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHBhcnNlSW50KGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5tb2R1bGUuZXhwb3J0cy52YWxpZGF0ZVBlcmNlbnRJbnB1dCA9IGZ1bmN0aW9uKHBlcmNlbnQpe1xyXG4gICAgdHJ5e1xyXG4gICAgICAgIGlmKHBlcmNlbnQgPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQocGVyY2VudCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1jYXRjaChlKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzLnZhbGlkYXRlUmVxdWlyZWRJbnB1dHNFeGlzdCA9IGZ1bmN0aW9uKGlucHV0RGVmaW5pdGlvbnMsIGlucHV0TW9kZWxzKXtcclxuICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcclxuICAgIGlucHV0RGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihlKXtcclxuICAgICAgICBpZihpbnB1dE1vZGVsc1tlLmlkXSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgaWYoZS5kZWZhdWx0ICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgaW5wdXRNb2RlbHNbZS5pZF0gPSBlLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gaXNWYWxpZDtcclxufTsiXX0=
